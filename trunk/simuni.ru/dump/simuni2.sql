/*
SQLyog Ultimate v11.11 (64 bit)
MySQL - 5.6.16-log : Database - simuni2
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

/*Table structure for table `generalinfo` */

DROP TABLE IF EXISTS `GeneralInfo`;

CREATE TABLE `GeneralInfo` (
  `GeneralInfoID` int(11) NOT NULL AUTO_INCREMENT,
  `Name` varchar(30) NOT NULL,
  `Value` varchar(30) NOT NULL,
  PRIMARY KEY (`GeneralInfoID`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `generalinfo` */

insert  into `GeneralInfo`(`GeneralInfoID`,`Name`,`Value`) values (1,'CurrentHometaskID','39');

/*Table structure for table `hometask` */

DROP TABLE IF EXISTS `Hometask`;

CREATE TABLE `Hometask` (
  `HometaskID` int(11) NOT NULL AUTO_INCREMENT,
  `Topic` varchar(200) NOT NULL,
  `Date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `Deadline` date NOT NULL,
  PRIMARY KEY (`HometaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=62 DEFAULT CHARSET=utf8;

/*Data for the table `hometask` */

insert  into `Hometask`(`HometaskID`,`Topic`,`Date`,`Deadline`) values (1,'Знакомство с Haskell, рекурсия, накапливающие параметры','2012-03-09 00:00:00','2013-09-09'),(2,'Дополнительные задачи к заданию 1','0000-00-00 00:00:00','2013-09-20'),(3,'Списки, функции высшего порядка','2012-05-02 13:53:52','2013-09-17'),(4,'Доп. задачи про списки','2012-09-16 22:24:39','2013-09-27'),(5,'Простые задачи про функции высшего порядка на ','2012-09-17 23:03:33','2013-09-28'),(6,'Пары, стандартные функции высш.порядка, деревья','2012-09-20 18:33:06','2013-09-24'),(7,'Доп. задачи про пары и деревья','2012-09-21 15:27:01','2013-10-04'),(8,'any для С# и С++','2012-09-24 15:46:00','2013-10-05'),(9,'пары, data, map, tree','2012-09-29 15:59:40','2013-10-01'),(10,'Деревья','2012-10-01 15:23:01','2013-10-11'),(11,'map на C#','2012-10-03 19:40:10','2013-10-12'),(37,'доп c#','2013-09-27 23:48:10','2012-09-16'),(12,'рамка, foldr, repeat','2012-10-05 17:16:13','2013-10-08'),(13,'chessboard, repeatFunc','2012-10-08 16:12:46','2013-10-20'),(14,'map и filter в C#','2012-10-11 20:44:02','2013-10-20'),(15,'монетки, map, резисторы','2012-10-14 12:08:24','2013-10-15'),(16,'Треугольник, наборы','2012-10-15 22:26:49','2013-10-25'),(17,'Свертка на C#','2012-10-18 22:42:45','2013-10-26'),(18,'amiciable, беск список, foldrTree','2012-10-21 01:12:17','2013-10-22'),(19,'Доп. задачи про бесконечные списки','2012-10-22 12:41:24','2013-11-01'),(20,'замыкание на C#','2012-10-27 18:53:56','2013-11-02'),(21,'Бесконечные списки','2012-10-27 18:54:48','2013-10-29'),(22,'Еще доп задачи про бесконечные списки','2012-11-01 19:04:58','2013-11-08'),(23,'Бесконечные  на C#, кр','2012-11-03 12:43:10','2013-11-09'),(24,'knot, superMap, approxSum, foldTree','2012-11-05 10:32:11','2013-11-12'),(25,'Доп: выходные, merge','2012-11-09 11:30:23','2013-11-15'),(26,'на C# easy knot','2012-11-13 00:19:53','2013-11-16'),(27,'доп iterate, hamming','2012-11-15 17:21:29','2013-11-22'),(28,'доп c#','2012-11-17 17:16:59','2013-11-23'),(29,'Типы функций, findSame, >>=','2012-11-18 23:40:05','2013-11-19'),(30,'(()) flatten','2012-11-22 23:09:33','2013-11-29'),(31,'digits еще раз','2012-11-25 23:52:19','2013-11-30'),(32,'eval diff >>= maybe shapes','2012-11-27 01:37:33','2013-11-26'),(33,'доп скобки simplify','2012-11-30 00:04:47','2013-12-06'),(34,'C# expr','2013-09-17 17:15:26','2013-12-07'),(35,'evalvar find3 io','2013-09-20 10:53:18','2013-12-02'),(36,'доп io church','2013-09-26 23:39:27','2013-12-13'),(61,'19 Генераторы','2013-12-05 17:47:08','2012-10-12'),(38,'предпоследнее','2013-10-03 14:48:31','2013-12-10'),(39,'последнее доп','2013-10-04 11:22:13','2013-12-27'),(40,'15 Кантор','2013-10-08 11:09:17','2011-10-01'),(41,'17 Много простых задач','2013-10-11 18:42:27','2011-10-01'),(42,'18 Доп. задачи про бесконечные списки','2013-10-15 14:06:58','2011-10-01'),(43,'20 knot и унификация','2013-10-16 18:58:34','2011-10-01'),(44,'21 генераторы','2013-10-22 15:57:14','2011-10-01'),(45,'22 Классы, множества как функции и т.д.','2013-10-22 16:01:26','2011-10-01'),(46,'23 последовательности, show','2013-10-22 16:01:54','2011-10-01'),(47,'24 C# множества, как функции и merge','2013-10-29 13:07:48','2011-10-01'),(48,'25 Доп.задачи с контрольной','2013-10-31 16:48:16','2012-10-12'),(49,'26 Expr на C#','2013-11-01 08:47:35','2011-10-01'),(50,'27 Failure continuation и тд','2013-11-06 12:26:29','2011-10-01'),(51,'28 Чаще всех других, упростить, ферзи','2013-11-06 12:26:46','2011-10-01'),(52,'29 C# размещения и failure continuation','2013-11-12 22:12:27','2012-09-16'),(53,'30 8 задач','2013-11-15 14:26:29','2012-10-12'),(54,'31 Черч 1 и еще','2013-11-16 01:25:18','2011-10-01'),(55,'32 C# continuation','2013-11-19 21:51:22','2011-10-01'),(56,'33 Предпоследнее','2013-11-20 14:09:01','2012-10-12'),(57,'34 Буфер','2013-11-20 14:09:51','2012-10-12'),(58,'12 резисторы','2013-11-26 01:33:43','2011-10-01'),(59,'10 any для деревьев для С++ и C#','2013-11-28 08:38:28','2012-09-16'),(60,'16 замыкания','2013-11-28 08:40:06','2012-09-16');

/*Table structure for table `result` */

DROP TABLE IF EXISTS `Result`;

CREATE TABLE `Result` (
  `ResultID` int(11) NOT NULL AUTO_INCREMENT,
  `Text` varchar(30) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`ResultID`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

/*Data for the table `result` */

insert  into `Result`(`ResultID`,`Text`) values (0,'Не проверено'),(1,'Зачтено'),(2,'Не зачтено'),(3,'СПИСАНО');

/*Table structure for table `role` */

DROP TABLE IF EXISTS `Role`;

CREATE TABLE `Role` (
  `RoleID` int(11) NOT NULL AUTO_INCREMENT,
  `RoleName` varchar(30) NOT NULL,
  PRIMARY KEY (`RoleID`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

/*Data for the table `role` */

insert  into `Role`(`RoleID`,`RoleName`) values (1,'student'),(2,'teacher');

/*Table structure for table `solution` */

DROP TABLE IF EXISTS `Solution`;

CREATE TABLE `Solution` (
  `SolutionID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskID` int(11) NOT NULL,
  `UserID` varchar(30) NOT NULL,
  `LoadTimestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `ResultID` int(11) NOT NULL,
  `Code` mediumtext NOT NULL,
  `TestResult` varchar(150) NOT NULL,
  PRIMARY KEY (`SolutionID`)
) ENGINE=MyISAM AUTO_INCREMENT=5318 DEFAULT CHARSET=utf8;


/*Table structure for table `task` */

DROP TABLE IF EXISTS `Task`;

CREATE TABLE `Task` (
  `TaskID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskForHometask` int(11) NOT NULL,
  `HometaskID` int(11) NOT NULL,
  `Condition` mediumtext NOT NULL,
  `Price` int(11) NOT NULL,
  PRIMARY KEY (`TaskID`),
  UNIQUE KEY `TaskForHometask` (`TaskForHometask`,`HometaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=165 DEFAULT CHARSET=utf8;

/*Data for the table `task` */

insert  into `Task`(`TaskID`,`TaskForHometask`,`HometaskID`,`Condition`,`Price`) values (18,1,1,'Описать функцию f n, которая вычисляет \r\n 1+1/(1+1/(1+ ...+1/1))    - n дробей\r\n\r\nПример вызова:\r\n   f 3\r\nДолжно получиться 1+1/(1+1/(1+1/1)), то есть 1.6666..\r\n        ',1),(19,3,1,'Описать функцию \r\n sumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\n sumsin 2\r\nДолжно получиться sin(1+2)/(sin 1+sin 2); это равно примерно 0.08 \r\n        ',1),(20,4,1,'Описать функцию sumfact n: \r\n sumfact n = 1!+2!+...+n!\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\nsumfact 3\r\nРезультат должен быть равен 9.\r\n        \r\n        \r\n        ',1),(21,5,1,'* Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?\r\nНапример, для n = 9 существуют такие последовательности:\r\n 1 2 6, 1 3 5, 1 8, 2 3 4, 2 7, 3 6, 4 5, 9\r\n, то есть ответ на вопрос равен 8\r\n\r\nОпишите функцию nseq n, которая вычисляет количество таких последовательностей.\r\n\r\nПример вызова:\r\n nseq 9\r\nРезультат должен быть равен 8.\r\n        \r\n        ',1),(22,1,2,'*Дополнительная задача*\r\nОпишите функцию g, которая для данного целого числа, проверяет, можно ли его представить в виде суммы двух различных простых чисел, и возвращает True или False.\r\n\r\nПримеры вызова:\r\n  g 6 должно быть равно False\r\n  g 7 должно быть равно True (так как 7 = 2 + 5).\r\n\r\nЗамечание:\r\n О похожей (но не совсем такой же) задаче написан целый роман см. например: http://royallib.ru/book/doksiadis_apostolos/dyadyushka_petros_i_problema_goldbaha.html\r\n        \r\n        \r\n        ',1),(23,2,2,'*Дополнительная задача*\r\nОпишите функцию b n, которая для данного целого числа n проверяет, можно ли представить данное число, как сумму двух степеней двойки, и возвращает True или False.\r\n\r\nПример вызова:\r\n b 10 - должно получиться True, потому что 10 = 8 + 2\r\n b 22 - должно получиться False\r\n b 17 - должно получиться True, потому что 17 = 16 + 1 (и 1 - это тоже степень 2)\r\n        ',1),(24,2,1,'Описать функцию b n, которая вычисляет \r\n 0+1/(1+1/(2+1/(3+ ...+1/n))) - n дробей\r\n\r\nПример вызова:\r\n b 3\r\nДолжно получиться 0+1/(1+1/(2+1/3)), то есть 0.7\r\n        \r\n        \r\n        ',1),(25,1,3,'Описать функцию minlist, которая ищет минимальный элемент в данном списке.\r\n\r\nПример вызова:\r\n  minlist [3,2,7]\r\nОтвет должен быть равен 2.\r\n\r\nЗамечание: На самом деле, конечно, в Хаскеле есть такая стандарная функция (называется minimum), но, пожалуйста, в этой задаче вы ее не используйте.\r\n        \r\n        ',1),(26,3,3,'Описать фунццию rev, которая для списка возвращает список из тех же элементов, но идуших в обратном порядке.\r\n\r\nПример вызова:\r\n  rev [1, 3, 7] \r\n- должен получиться список [7, 3, 1].\r\n\r\nЗамечания:\r\n- Желательно (но не обязательно) описать эту функцию так, чтобы ее время работы было O(n). Технически это означает, что желательно написать функцию, в которой не будет использоваться приписывание в конец списка с помощью ++[x].\r\n- Но, если так не получиться, присылайте любое решение, какое придумаете.\r\n- Конечно, в этой задаче нельзя использовать стандартную функцию reverse.\r\n        \r\n        \r\n        ',1),(29,5,3,'Описать функцию checkDifferent, которая возвращает True, если все элементы в списке разные, и False, если среди них есть одинаковые.\r\n\r\nПримеры вызова:\r\n  checkDifferent [3,2,7]\r\nОтвет должен быть равен True.\r\n  checkDifferent [3,2,7,5,7,8]\r\nОтвет должен быть равен False (два раза встречается число 7).',1),(27,2,3,'Описать функцию minsum, которая ищет минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nПример вызова:\r\n  minsum [1,8,3,2,7]\r\nОтвет должен быть равен 5 (3+2).\r\n        ',1),(28,4,3,'Описать функцию \r\n  check cond xs\r\n, которая для данного списка xs и логической функции cond проверяет, верно ли, что в списке есть элемент, для которого cond возвращает True. Результат должен быть равен True, если такой элемент есть, и False, если его нет.\r\n\r\nПримеры вызова:\r\n check (\\x->x>5) [3,2,7,4]\r\nОтвет должен быть равен True, потому что в списке есть число, большее 5 (это число 7). \r\n\r\n check (\\x->x<1) [3,2,7,4]\r\nОтвет должен быть равен False, потому что в списке нет чисел, меньших 1. \r\n\r\nЗамечание: И такая стандартная функция в Хаскеле есть (называется any), но, пожалуйста, в этой задаче вы ее не используйте.        \r\n        \r\n        \r\n        \r\n        ',1),(30,1,4,'*Доп.задача*\r\nНаписать функцию parts, которая для данного списка проверяет, можно ли его разбить \r\nна несколько строго возрастающих кусков одинаковой длины. \r\n\r\nДлина кусков должна быть не меньше 2. Кусок может быть и только один.\r\n\r\nПримеры вызова:\r\n parts [1, 2, 8, 2, 5, 6]\r\n parts [1, 2, 3, 4, 5]\r\n parts [1, 2, 1, 2, 3, 4]\r\nВо всех этих случаях ответ должен быть равен True.\r\n parts [4, 6, 3, 5, 7]\r\nТут ответ должен быть равен False.\r\n        ',1),(31,2,4,'*Доп.задача, попроще*\r\nНаписать функцию isArithm, которая проверяет, верно ли, что данный список целых чисел содержит числа, образующие арифметическую прогрессию.\r\nПримеры вызова:\r\n isArithm [1, 2, 3, 4]\r\n isArithm [10, 5, 0]\r\n isArithm [3, 3, 3]\r\n isArithm [1, 2]\r\nВо всех этих примерах ответ должен быть True.\r\n\r\n isArithm [1, 2, 3, 2]\r\nОтвет должен быть False.\r\n\r\nЗамечание:\r\n- можно считать, что в списке точно есть по крайней мере 2 числа.\r\n        ',1),(128,5,6,'Пусть в нашей программе мы хотим хранить информацию о товарах в кондитерском магазине. Товары могут быть:\r\n- или тортами, и тогда мы храним их название, вес и цену, \r\n- или конфетами, и тогда мы храним их название и цену за килограмм.\r\nа. Опишите тип данных Candy, позволяющий хранить такую информацию.\r\nб. Опишите функцию bestCake, которая для данного списка товаров возвращает название самого дорогого торта.\r\n\r\nЗамечание: Тестов в этой задаче не будет, потому что я не знаю, какой тип данных вы опишете. Но, пожалуйста, включите в решение пример вызова bestCake. Т.е. что-то вроде:\r\n\r\ntest = bestCake ...какой-то список...\r\n\r\n\r\n        ',1),(33,1,5,'*Доп. задача*\r\nОчень простая функция высшего порядка на C#\r\n\r\nНаписать на C# функцию (статический метод) Integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:\r\n- f - функция (статический метод или лямбда выражение) \r\n- a, b - пределы интегрирования.\r\nПример вызова:\r\n\r\n   double result = Integral(x => x*x, 0, 1);\r\n\r\nМетод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций.\r\n\r\nЗамечания:\r\n- Пример похожей программы есть вот тут: http://msimuni.wikidot.com/fp-dop2\r\n- Там же всякие замечания про то, зачем эти задачки про \"обычные\" языки, как их сдавать и т.д. \r\n- Если хотите, можете сделать задачу на С++ или на каком-нибудь другом \"обычном\" языке. Если есть сомнения, подойдет ли тот или иной язык, пишите.\r\n        \r\n        ',1),(35,1,6,'Опишите функцию isosc (от слова isosceles - равнобедренный), у которой три параметра - пары целых чисел, и которая возвращает True, если соответствующие точки на плоскости задают равнобедренный треугольник, а иначе False.\r\n\r\nПримеры вызова:\r\n  isosс (0, 2) (2, 0) (2,2)\r\n     - результат должен быть равен True\r\n  isosс (-3, 2) (2, 0) (2,2)\r\n     - результат должен быть равен False\r\n        \r\n        ',1),(36,2,6,'Описать функцию cubeTable, которая для данного n возвращает список пар чисел (i, i в кубе) для всех i от 1 до n.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но, видимо, особо не нужно), определять свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n  cubeTable 4\r\nДолжно получиться [(1, 1), (2, 8), (3, 27), (4, 64)]\r\n        ',1),(37,3,6,'Определить функцию minsum, такую же, как в задаче 3.2. Т.е. функция должна искать минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но не очень нужно), определать свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n minsum [1,8,3,2,7] \r\nОтвет должен быть равен 5 (3+2).\r\n\r\n        \r\n        ',1),(38,4,6,'Описать функцию height, хоторая ищет высоту данного дерева. \r\n\r\nЗамечание: В задаче вы сначала должны описать data для дерева. И его надо описать точно так же, как на занятии. Извините за ограничение вашей творческой свободы, но это, понятно, ограничение системы тестирования..\r\n\r\nПримеры вызова:\r\n  height (Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  height (Node 1 (Node 1 Empty Empty) Empty)\r\nОтвет должен быть 1\r\n        \r\n        \r\n        ',1),(39,5,57,'* Описать функцию minHeight, хоторая для данного дерева возвращает минимум расстояния от корня до какого-нибудь листа. \r\n\r\nЗамечание: В этой задаче _обязательно_ должна быть реализована оптимизация, о которой мы говорили на занятии.\r\n\r\nНапоминание: Лист - это вершина, у которой и левое и правое поддеревья пустые.\r\n\r\nПримеры вызова:\r\n  minHeight(Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  minHeight (Node 1 \r\n               (Node 2 \r\n                  (Node 3 Empty Empty)\r\n                   Empty)\r\n               (Node 4 Empty Empty))\r\nОтвет должен быть 1 (расстояние от корня до вершины 4)\r\n        \r\n        \r\n        ',1),(40,1,12,'\"Рамочка\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле двумерные массивы. Описать функцию frame n, которая возвращает список списков, соответствующий массиву n на n, в котором по краям (в первом и последнем столбце и в первой и последней строке) все элементы равны 1, а все остальные элементы равны 0.\r\n\r\nПример вызова:\r\n  frame 4\r\nДолжно получиться:\r\n [[1, 1, 1, 1],\r\n  [1, 0, 0, 1],\r\n  [1, 0, 0, 1],\r\n  [1, 1, 1, 1]]\r\n        ',1),(41,2,12,'Опишите две функции, countOdd и countOdd1, которые для данного списка вычисляют количество нечетных чисел в этом списке. (Т.е. надо написать две версии одной функции).\r\n\r\nДополнительные условия:\r\n- В функции countOdd можно использовать _только_ стандартную функцию foldr. Точнее, можно, конечно, использовать функwию mod, но нельзя использовать map, filter и т.д.  Можно (но особо не нужно) задавать свои нерекурсивные функции. Можно,  \r\nконечно, использовать лямбда-выражения.\r\n\r\n- В функции countOdd1 можно использовать любые стандартные функции (в частности map и filter), и тоже, если надо, можно использовать свои нерекурсивные функции и лямбда-выражения. Но _нельзя_ определять свои рекурсивные функции.\r\n\r\nПример вызова:\r\n  countOdd [2, 3, 4, 8, 5, 33, 9]\r\nОтвет должен быть равен 4\r\n        ',1),(42,3,12,'Опишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl (т.е. сворачивает все элементы слева направо).\r\n\r\nПример вызова:\r\n  myfoldl (+) 0 [1,2,3]\r\nФункция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить именно в таком порядке.  \r\n        \r\n        ',1),(43,1,7,'*Доп задача, до 3.10*\r\nУ функции два параметра - целые числа a и b. Точно известно, что они взаимно простые. Функция должна вернуть такую пару целых чисел x и y, что a*x + b*y == 1. (Таких пар, конечно, бесконечно много, можно вернуть любую).\r\n\r\nПример вызова:\r\n euclid 3 5\r\nДолжно получиться (2, -1), потому что 3*2+5*(-1) == 1\r\n\r\nЗамечания:\r\n- Если a и b не взаимно простые, то функция может делать что угодно (например, аварийно завершаться, или выдавать любой ответ).\r\n- Желательно, чтобы функция быстро работала для _очень_ больших чисел, например, для 2^100 и 3^100. Но, если не получится, напишите любое решение, не обязательно очень эффективное (например, которое ищет решения перебором).\r\n- Подсказка: идея, которую можно использовать для эффективного решения, была впервые опубликована примерно в 300 г. до н.э. :)\r\n        \r\n        \r\n        ',1),(44,2,7,'*Доп задача попроще, до 3.10*\r\nОписать функцию averageForLeaves, которая для данного дерева вычисляет среднеарифметическое всех чисел, записаных в его листьях.\r\n\r\nПример вызова:\r\n\r\naverageForLeaves (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\nОтвет должен быть равен 2.5 (в этом дереве два листа, содержащие числа 2 и 3.\r\n\r\nЗамечания:\r\n- Напоминание: лист - это вершина, у которой левое и правое поддерево равны Empty.\r\n- На всякий случай: Если эта задача кажется вам сложной/непонятной, вы можете решить более простую задачу - написать функцию countLeaves, которая возвращает количество листьев. Тесты, конечно, не пройдут, но я зачту задачу.\r\n        ',1),(133,5,9,'\"Единичная матрица\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию identity n, которая возвращает список списков, соответствующий единичной матрице n на n. Т.е. элементы на главной диагонали д.б. равны 1, а все остальные элементы равны 0.\r\n\r\nПример вызова:\r\nidentity 4\r\nДолжно получиться:\r\n[[1, 0, 0, 0],\r\n[0, 1, 0, 0],\r\n[0, 0, 1, 0],\r\n[0, 0, 0, 1]]',1),(45,1,8,'*Задача (скорее упражнение) на \"обычном\" языке (дополнительная, до 4.10 включительно*\r\n\r\nВ С# для контейнеров определен метод Any, который позволяет проверить, есть ли в контейнере элемент, удовлетворяющий данному условию. И есть аналогичный метод All.  Вот примеры их вызовов:\r\n\r\n  int [] a = {-1, 2, -3, 4};\r\n  bool b = a.Any(x => x > 0);     // Верно, ли что в массиве есть положительный элемент?\r\n  b = a.All(x => x > 0);         // Верно, ли что все элементы в массиве положительные?\r\n\r\nИспользуя только эти методы и лямбда выражения, проверить для данного двумерного массива массивов (или, если хотите, списка списков), \r\nчто в каждом из массивов есть хотя бы один четный элемент.\r\n\r\nЗамечания:\r\n- Если для кого-то задача кажется слишком сложной,  а попробовать функциональное программирование в С# хочется, можете решить задачу попроще:\r\n  \"Дан массив чисел. Проверить, верно ли, что в этом массиве, есть хотя бы одно двузначное число\"\r\n- Желающие могут сделать эту задачу на любом \"обычном\" языке, в котором есть похожие возможности\r\n- На С++, частности, есть аналогичные функции any_of, all_of и даже еще функция none_of. \r\n- На эту задачу тестов нет, вы просто можете выложить в систему код, и я его просмотрю.\r\n- Но код должен быть таким, чтобы его можно было скомпилировать и запустить, с каким-нибудь примером вызова.\r\n        ',1),(132,4,9,'Описать функцию f, которая для данного списка возвращает новый список, в которой все числа 1 заменены на -1, остальные числа оставлены без изменения.\r\n\r\nПример вызова:\r\n f [2, 3, 1, 4, 1, 8]\r\nДолжно получиться [2, 3, -1, 4, -1, 8]\r\n\r\nДополнительное условие:\r\n- В этой задаче желательно использовать только стандартные функции и лямбда-выражения. Но, если не получиться, напишите любое решение.\r\n\r\n        ',1),(129,1,9,'Пусть у нас пары целых чисел задают точки на плоскости, а списки пар целых чисел задают ломаные (не замкнутые).\r\nОписать функцию len, которая для данного списка пар находит длину ломаной.\r\n\r\nПример вызова:\r\n  len [(1,1), (1,2), (2,1)]\r\nОтвет должен быть примерно 2.41 - длина ломаной из двух звеньев между этими точками.',1),(130,2,9,'Описать функцию findTree, которая для данного дерева поиска и данного числа проверяет, принадлежит ли число дереву, и возвращает True или False. \r\n\r\nПример вызова:\r\n  findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 2\r\nОтвет должен быть равен True\r\n\r\nЗамечание:\r\n  - Функция обязательно использовать то, что дерево - это дерево поиска. Т.е. надо не просто перебирать все элементы, поиск должен быть быстрым.\r\n  - Если вы вдруг забыли, что такое дерево поиска, вы можете мне написать, я поясню.',1),(131,3,9,'Телепрограмма\r\n\r\nПусть мы хотим хранить информацию о телепередачах - фильмах и сериалах. \r\n- про фильмы мы храним их название, год выпуска и фамилию режиссера\r\n- про сериалы мы храним название и номер серии\r\n\r\nа. Опишите тип данных, позволяющий хранить такую информацию.\r\nб. Опишите функцию haveNewFilm, которая для данного списка телепередач проверяет, есть ли в нем хотя бы один фильм 2013 года, и возвращает True или False.\r\n\r\nЗамечание: Тестов в этой задаче не будет, потому что я не знаю, какой тип данных вы опишете. Но, пожалуйста, включите в решение пример вызова haveNewFilm. Т.е. что-то вроде\r\n\r\ntest = haveNewFilm ...какой-то список...',1),(49,1,59,'*Доп.задача, до 15.10*\r\nОписать на C# тип \"двоичное дерево, элементы которого - целые числа\". Для этого дерева опишите аналог функции Any, которая обсуждалась в задаче 7.1. У этой функции должен быть параметр \"условие\" - логическая функция, и она должна проверять, есть ли a дереве элемент, удовлетворяющий условию.\r\n\r\nТ.е. решение должно состоять из программы на C#, в которой:\r\n- описан тип \"дерево\"\r\n- описана функция, аналогичная Any, но для дерева. Это может быть метод класса \"дерево\", или отдельная статическая функция, как хотите.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызвана функция Any. \r\n\r\nСправка: Логические функции можно описать как Function<int, bool>. (Или можно описать как Predicate<int> - это одно и то же.)\r\n\r\nЗамечания:\r\n- Проще всего весь код записать в одном файле, и поместить в систему тестирования. Но, если хотите, вы можете создать несколько файлов (один для дерева, другой для Main) и прислать мне их по почте.\r\n- Эта задача, конечно, немного посложнее предыдущих по C# - те были, скорее, упражнениями. Если что-то будет не получатся, можете писать и задавать вопросы..\r\n        \r\n        \r\n        \r\n        ',1),(50,2,59,'*Доп.задача, до 15.10*\r\nОписать на C++ тип \"двоичное дерево, элементы которого - целые числа\". Для этого дерева опишите что-то похожее на функцию Any из задачи 7.1. \r\n\r\nВ этом случае, видимо, проще всего описать шаблон функции any, примерно так же, как мы описывали шаблон для интеграла. Один из параметров этой функции - условие, которое надо проверить, в другой - корень дерева (или указатель на корень дерева, как будет удобнее).\r\n\r\nТ.е. решение должно состоять из программы на C++, в которой:\r\n- описан тип \"дерево\"\r\n- описана шаблон функции, аналогичной Any из 7.1, но для дерева.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызван этот шаблон. \r\n\r\nЗамечания:\r\n- Замечания те же, что 10.1. Эта задача, конечно, немного посложнее предыдущих по C++. Если что-то не получается или непонятно, можете задавать вопросы..\r\n        \r\n        \r\n        \r\n        ',1),(51,4,12,'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n        ',1),(52,2,13,'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n\r\nДополнительное условие:\r\n - В этой задаче нельзя определять свои рекурсивные функции. Можно использовать стандартные функции и можно, если хотите, определять нерекурсивные функции.\r\n\r\nЗамечание:\r\n - Если вы решите эту задачу до 7.10, то можете выложить ее решение и как решение для задачи 12.4, оно будет засчитано.\r\n        ',1),(53,1,15,'Перечислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. Результат должен быть списком списков целых чисел, каждый внутренний список - это список из трех элементов [k,l,m], где k - двухкопеечных  монет, l - количество трехкопеечных, m - количество пятикопеечных монет.\r\n\r\nПример вызова:\r\n  coins 10\r\n\r\nДолжно получиться:\r\n [[5,0,0],[2,2,0],[0,0,2],[1,1,1]]\r\n(порядок троек в ответе может быть и другим).\r\n\r\nЗамечание:\r\n - Вообще это упражнение на list comprehension. Но, если хотите, вы можете решить задачу и без list comprehension, как хотите.\r\n        ',1),(54,3,15,'Пусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:\r\n - или сопротивление, тогда известно его величина в омах\r\n - или две схемы, соединенных параллельно\r\n - или две схемы, соединенных последовательно\r\n(На самом деле есть схемы, которые таким способом не описать, ну и ладно..)\r\n\r\n1. Опишите тип (data) Scheme, который позволяет описывать такие схемы.\r\n2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы.\r\n\r\nНапример, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2.\r\n\r\nЗамечания:\r\n- Для этой задачи тестов не будет, потому что я не знаю, как вы решите представлять схемы. Но я проверю задачи вручную.\r\n- Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)\r\n        ',1),(56,2,16,'*Доп.задача, до 24.10*\r\nОписать функцию allLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n. \r\n\r\nПример вызова:\r\n allLists 3 2\r\n\r\nДолжно получиться:\r\n [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- В общем случае в списке должно быть, понятно, n^k элементов.\r\n- Подсказка: Я бы советовал использовать list comprehension, получится очень просто.\r\n- Еще подсказка: Я бы рассуждал так: для k == 2 решение этой задачи легко записать с помощью list comprehension с двумя генераторами. Собственно такой пример был на занятии. А как записать решение для k == 3? Можно, конечно, использовать list comprehension c тремя генераторами. Но ведь есть и другой вариант - воспользоваться решением для k == 2 и получить из него решение для k == 3. Если это написать, то, мне кажется, совсем ясно и что надо делать в общем случае. \r\n        ',1),(57,2,58,'*Доп.задача, до 21.10*\r\n\r\nОписать функцию canMakeScheme с двумя параметрами:\r\n - список целых чисел [r1, r2, … rn]. Этот список задает набор имеющихся у нас сопротивлений.\r\n - целое число m. \r\nФункция должна проверить, можно ли построить из этих сопротивлений (не обязательно из всех) электрическую схему с общим сопротивлением m и вернуть в качестве результата True или False. \r\nСаму схему строить не надо.\r\n\r\nПример вызова:\r\n  canMakeScheme [4,4,5] 7\r\n\r\nОтвет должен быть True, потому что мы можем соединить параллельно 4 и 4, а потом присоединить последовательно 5.\r\n\r\nЗамечание:\r\n - Можно считать, что сопротивлений будет не больше 5.\r\n - Если вы напишете решение, которое работает за разумное время (скажем, за 15 мин.) для 9 резисторов, выложите ее, как решение задачи 12-3, за нее будет 3 балла.\r\n - Если вы напишите решение, которое работает для 15 резисторов, присылайте мне, за нее будет 20 баллов (но я не думаю, что это возможно..). \r\n        \r\n        \r\n        \r\n        ',1),(58,3,58,'*Доп.задача, до 21.10*\r\nУсловие см. в задаче 12-2, задача должна работать для 9 сопротивлений. (Таких тестов в системе нет, но я проверю вручную). \r\n\r\n\r\n        \r\n        \r\n        \r\n        ',3),(59,1,14,'*Доп.задача на C#, до 18.10*\r\n\r\nАналогом map в C# является, видимо, метод Select, а  аналогом filter - метод Where (это части LINQ но их вполне можно использовать и просто как удобные методы). См. простые примеры вызова этих методов тут:\r\n  http://msimuni.wikidot.com/fp-select-where \r\n\r\nС помощью Select и Where опишите функцию nonZeroLastDigits, которая:\r\n - берет в качестве параметра массив целых положительных чисел\r\n - возвращает массив из последних цифр всех чисел из исходного массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\nНапример, если входной массив содержит числа 354, 20, 9, 31, то надо вернуть массив из чисел 4, 9, 1 .\r\n\r\nЗамечание:\r\n - Конечно, в этой задаче нет особого смысла, это просто несложное упражнение на вызов Select и Where.\r\n        ',1),(60,2,57,'*Доп.задача на С++, до 22.10*\r\n\r\nАналогом map в C++ является, видимо, функция transform, а аналогом filter - функция remove_if и  remove_copy_if. См. простые примеры вызова этих функций тут:\r\n  http://msimuni.wikidot.com/fp-select-where \r\n\r\nС помощью transform и remove_if (или remove_copy_if) опишите код,функцию nonZeroLastDigits, которая:\r\n - берет в качестве параметров массив целых положительных чисел и количество чисел\r\n - печатает последние цифр всех чисел из этого массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\nНапример, если входной массив содержал числа 354, 20, 9, 31, то функция должна напечатать 4, 9, 1 .\r\n\r\nЗамечание:\r\n - Честно говоря, transform и remove_if - это не самое удобная часть С++ ((. И, честно говоря, я лично ими никогда не пользовался и особо не собираюсь. И, конечно, поставленную задачу проще решить без всяких функций. \r\n - Т.е. это просто упражнение на использование стандартных функций С++, м.б. даже и не очень полезное, признаю((\r\n        \r\n        \r\n        \r\n        ',1),(61,1,18,'В этой задаче надо реализовать сразу две функции: \r\nа. Напишите функцию sumDiv, которая для данного целого положительного числа возвращает сумму всех его делителей (не учитывая в сумме сам это число).\r\nб. Напишите функция perfects n, которая возвращает список всех совершенных чисел, меньших или равных n.\r\n\r\nПримеры вызова:\r\n  sumDiv 10\r\nОтвет должен быть равен 8 (так как 1+2+5=8)\r\n  perfects 1000\r\nОтвет должен быть равен\r\n  [6,28,496]\r\n\r\nСправка: Число называется совершенным, если оно равно сумме своих делителей.\r\n        \r\n        \r\n        ',1),(62,2,18,'Напишите функция amicables n, которая возвращает список всех пар дружественных чисел, каждое из которых меньше или равно n. \r\nПример вызова:\r\n  amicables 1000\r\nОтвет должен быть равен\r\n  [(220,284)]\r\n\r\nСправка: Числа a и b называется дружественными, если a равно сумме делителей b, а b равно сумме делителей a.\r\n\r\nЗамечания: \r\n- Для единообразия давайте включать в список только те пары, в которых первое число меньше второго.\r\n- Видимо, имеет смысл скопировать и использовать функцмю sumDiv из задачи 14-1\r\n        \r\n        \r\n        ',1),(63,3,18,'Опишите переменную ones, как бесконечный список [1,11,111,1111,...] - т.е. список из целых положительных чисел, у которых все цифры равны 1.\r\n\r\nПример вызова:\r\n  take 7 ones\r\nОтвет должен быть равен:\r\n  [1,11,111,1111,11111,111111,1111111]\r\n        \r\n        \r\n        ',1),(64,4,18,'а. Опишите функцию foldTree, которая для дерева делает что-то аналогичное foldr или foldl для списков. Она должна вызываться так:\r\n\r\nfoldTree (+) 0 t — ищет сумму всех элементов в дереве\r\nfoldTree (*) 1 t — ищет произведение всех элементов в дереве\r\n\r\nб. Но м.б. можно придумать что-то более общее? Например, придумать такой вариант foldTree, который позволяет реализовывать более сложные функции (например, искать высоту дерева и т.д.). Если придумаете, предложите какой-нибудь такой вариант.\r\n\r\nЗамечания:\r\n- Условие, естественно, не совсем строгое (но так и в жизни часто бывает..). Если есть вопросы - пишите.\r\n- Пункт б. необязательный (хотя и не особо сложный). Решения, описанного в пункте а. вполне достаточно. \r\n- В этой задаче тестов не будет. Желательно, чтобы вы включили в текст 1-2 примера  того, как можно использовать программу.    \r\n        \r\n        \r\n        ',1),(65,2,19,'*Доп. задача, до 31.10*\r\n\r\nОписать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу).\r\n\r\nПример вызова:\r\n  take 100 cantor\r\n\r\nЧто получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.\r\n        ',1),(66,2,40,'*Доп. задача, до 28.10*\r\n\r\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\r\nПример вызова:\r\n  take 100 (generalizedCantor 3)\r\n\r\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет  [[1,1,1], [1,1,2], и т.д.\r\n        \r\n        \r\n        ',1),(67,3,60,'*Доп.задача до 30.10*\r\n\r\nИспользуя функцию transform из задачи 13-2, напишите функцию zeroDigits с тремя параметрами a (массив), size (размер массива), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 3, 2) в массиве должны быть числа 500, 5600, 76700\r\n\r\nЗамечания:\r\n- Важно: Eсли в С++ в лямбда-выражении используются нелокальные переменные (т.е. используется замыкание), то их надо перечислить в начале лямбда выражения в квадратных скобках (это так называемый список захвата - capture list). Например:\r\n\r\n  [n] (int i) { return i + n; }\r\n\r\n- список захвата можно записать и другими способами, но это остается для самостоятельного изучения :)\r\n        \r\n        \r\n        \r\n        \r\n        ',1),(68,1,20,'*Доп.задача до 31.10*\r\n\r\nИспользуя функцию Select из задачи 13-1, напишите функцию zeroDigits с двумя параметрами a (массив целых положительных чисел), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0 и вернуть полученный новый массив.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 2) должен вернуться массив из чисел 500, 5600, 76700\r\n        \r\n        \r\n        ',1),(69,1,21,'Описать функцию bigSin c параметром x, которая возвращает первый элемент в последовательности\r\n  sin 1, sin 2, sin 3, sin 4, ...\r\n, который больше или равен x. \r\n\r\nДополнительное условие: нельзя определять свои функции (кроме bigSin, конечно). Можно использовать любые стандартные функции и лямбда выражения.\r\n\r\nПример вызова:\r\n  bigSin 0.99\r\nрезультат должен быть равен примерно 0.990607\r\n\r\nЗамечания:\r\n - очевидная подсказка: тут, конечно, удобно использовать бесконечные списки. Но можно и без них, наверное.\r\n        ',1),(70,2,41,'Описать функцию myFilter - свою реализацию функции  filter c точно таким же интерфейсом.\r\nДополнительное условие: эта реализация должна использовать только функцию foldr и лямбда выражения.\r\n\r\nПример вызова:\r\n  myFilter (>0) [1,-2,3,-5]\r\nрезультат должен быть равен [1,3]\r\n        \r\n        ',1),(71,1,24,'a. Опишите функцию approxSum, параметр который - бесконечный список и которая считает сумму входящих в него элементов, пока очередной элемент не станет по модулю меньше 0.000001.\r\n\r\nб. Используя approxSum, сосчитайте приближенную сумму ряда 1/1 + 1/4 + 1/9 + ... + 1/(i*i) + ...\r\nЗначение этой приближенной функции присвойте переменной z.\r\n\r\nПример вызова:\r\n  z\r\nДолжно получиться примерно 1.64\r\n        ',1),(72,1,25,'*Доп.задача до 14.11*\r\n\r\nПусть в списке я записал последовательность чисел - сколько денег я тратил каждый день в этом году. Запись я начал, конечно же, с понедельника. \r\n\r\nОпишите функцию weekendExpences у которой параметр - такой список расходов, и которая вычисляет для него общую сумму расходов по выходным.\r\n\r\nПример вызова:\r\n  weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1, 3]\r\n\r\nОтвет должен быть равен 5+17+5+1 = 28.\r\n\r\nЗамечание:\r\n- В этой задаче можно (но не обязательно) использовать зацикленный список\r\n        ',1),(73,2,24,'Опишите бесконечный список fibs, состоящий из чисел Фибоначчи.\r\nДополнительное условие: желательно использовать прием \"завязывание в узел\" (tying the knot). Но, если не получится, можно решить эту задачу любым способом.\r\n\r\nПример вызова:\r\n  take 10 fibs\r\n\r\nРезультат должен быть равен:\r\n [1,1,2,3,5,8,13,21,34,55]\r\n\r\nЗамечание:\r\n- Безусловно эту задачу можно найти в интернете - и решение из интернета тоже засчитается. Но мне кажется интереснее попробовать самим что-то придумать, тем более это совсем и не сложно..\r\n        ',1),(74,4,24,'Используя функцию foldTree с последнего занятия (второй вариант, который катаморфизм), опишите функцию sumPos. У этой функции параметр - дерево, и она должна вычислять сумму всех положительных чисел в этом дереве.\r\n\r\nПример вызова:\r\n  sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\r\nОтвет должен быть равен 7.\r\n        ',1),(75,1,29,'В этой задаче надо прислать не программу, а просто текст.\r\na. Напишите, какой тип у функции foldr (если хотите, можете где-нибудь посмотреть, но интереснее, наверное, попробовать придумать)\r\nб. Попробуйте обосновать, как можно доказать, может быть и не очень формально, что тип foldr именно такой. \r\n\r\nЖелательно обосновать примерно так, как мы это делали на занятии для map (то, что называется алгоритм Хиндли-Милнера). Но подойдет и любое другое более-менее понятное обоснование.\r\n \r\nЗамечания:\r\n - текст foldr, на основании которого надо вывести тип, был у нас на занятии\r\n - если не очень понятно, что тут все-таки надо делать, пишите, обсудим.\r\n        ',1),(76,8,41,'Опишите класс Shape и типы Circle и Rect, как мы это делали на занятии. Добавьте в класс функцию perimeter и для Circle и Rect напишите ее определение.\r\n\r\nПримеры вызова:\r\n  perimeter (Circle 10)\r\nОтвет должен быть равен примерно 62.83\r\n  perimeter (Rect 3 7)\r\nОтвет должен быть равен 20  \r\n        \r\n        ',1),(77,1,42,'*Доп. задача, до 4.11*\r\n\r\nОписать sqrt2 как бесконечный список из чисел от 0 до 9, описывающий разложение sqrt(2) в бесконечную десятичную дробь. \r\n\r\nПример вызова:\r\n  take 20 sqrt2\r\n\r\nРезультат должен быть равен \r\n  [1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]\r\n\r\nЗамечания:\r\n - Это, видимо, больше задачка по выч. методам, а не по программированию.. Мне кажется, не очень сложная.\r\n - Подсказка: задача не очень сложная, потому что Haskell может выполнять операции над целыми числами любой длины. Тут это удобно.\r\n        \r\n        \r\n        \r\n        \r\n        ',1),(78,2,22,'*Доп. задача, до 7.11*\r\n\r\nОписать pascal как бесконечный список списков, содержащий треугольник Паскаля. \r\n\r\nПример вызова:\r\n  take 6 pascal\r\n\r\nРезультат должен быть равен \r\n  [[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]\r\n        \r\nЗамечание: \r\n- Я бы советовал использовать в этой задаче прием tying the knot. Но это не обязательно, вы можете решить ее любым способом. \r\n\r\n        \r\n        ',1),(79,1,23,'*Доп.задача на C# до 8.11*\r\n\r\nОпишите блок итератора digits(int n), возвращающий последовательность цифр дроби 1/n. Например, при обращении к digits(7) должны  возвращаться цифры 1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7, ...\r\n\r\nC использованием digits напишите программу, которая вводит число n и печатает первые 100 цифр числа 1/n.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n        ',1),(80,5,60,'*Доп.задача на C# до 5.11*\r\n\r\n\"Задача Кантора\" на С#\r\n\r\nОпишите на C# блок итератора, возвращающий последовательность всех пар целых положительных чисел.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n        \r\n        \r\n        ',1),(81,3,24,'Описать бесконечный список lst367, содержащий все целые положительные числа, состоящие только из цифр 3,6 и 7. (Числа должны идти в порядке возрастания).\r\n\r\nПример вызова:\r\n\r\n  take 15 lst367\r\n\r\nДолжно получиться:\r\n  [3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]\r\n\r\nЗамечание:\r\n - Эта задача, на самом деле, довольно эффектно решается с помощью tying the knot. Но, если не придумаете как тут завязать этот узел, эту задачу можно решить любым способом.\r\n        ',1),(82,2,43,'*Доп. задача, до 11.11*\r\n\r\nПусть у нас есть система равенств вида:\r\n  <переменная1> = <переменная2>.\r\nМы представляем ее в Хаскеле, как список пар строк. Например, список [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] описывает систему равенств:\r\n  x = y\r\n  y = z\r\n  n = m\r\nКроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\r\nПример вызова:\r\n  countDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]\r\n\r\nРезультат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\r\nЗамечания:\r\n - Это не упражнение на какую-то тему, которую мы проходили - тут надо просто написать более-менее нетривиальный алгоритм на Хаскеле.\r\n        \r\n        ',1),(83,1,28,'*Доп. задача на C#, до 22.11*\r\n\r\nРешить задачу про числа из цифр 3, 6, 7 на C#. Т.е., описать блок итератора Lst367(), который по очереди возвращает числа 3,6,7,33,36,37,63,66,67,73,76,77,333,336,337 и т.д.\r\n\r\nЗамечание:\r\n - Для C# эта задача очень просто решается с помощью приема tying the knot, даже может быть проще, чем на Хаскеле. Но вы можете решить эту задачу любым способом.\r\n        ',1),(84,2,44,'*Доп. задача на C#, до 12.11*\r\n\r\nОписать функцию Iterate, у которой следующие примеры вызова:\r\n\r\n  foreach (double x in Iterate(2, x => x*2))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (x > 1000000)\r\n        break;\r\n  }\r\n\r\nПечатает 2, 4, 8, 16, ... и т.д. - степени двойки до 1000000\r\n\r\n  int i = 0;\r\n  foreach (double x in Iterate(1, Math.Sin))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (i++ == 100)\r\n        break;\r\n  }\r\n\r\nПечатает 1, sin 1 , sin (sin 1), и т.д. 100 раз.\r\n\r\nКакие у этой функции должны быть параметры и тип результата, определите, пожалуйста, сами по примерам вызова.\r\n\r\nЗамечание:\r\n - Можно считать, что в этой задаче у нас речь идет только про вещественные числа. (Например, первый параметр Iterate точно имеет тип double.) В принципе, можно было бы определить и generic версию, которая работает с разными типами, но в данном случае это не требуется. \r\n        \r\n        \r\n        ',1),(85,1,35,'Определите тип Ration для представления дробей. Конструктор этого типа должен записываться так: Rat <числитель> <знаменатель>.\r\nДля этого типа: \r\na. Определите оператор + (сложение дробей)\r\nb. Определите оператор < (сравнение дробей)\r\nc. Определите функцию show, которая генерирует строковое представление дроби в формате <числитель>/<знаменатель> \r\n\r\nПримеры вызова:\r\n\r\nRat 1 2 + Rat 1 7\r\n\r\nДолжно быть напечатано\r\n\r\n9/14\r\n\r\n(потому что при выводе автоматически вызовется show) \r\n\r\nRat 1 3 < Rat 4 5\r\n\r\nРезультат должен быть равен True\r\n\r\nЗамечания:\r\n- Еще обязательно придется определить ==, без этого программа не будет компилироваться.\r\n- Надо ли сокращать дроби? Например, что будет, если сложить Rat 1 3 и Rat 1 6? \r\nОтвет: Как хотите, не обязательно сокращать. В тестах таких примеров не будет.\r\n- Как должна работать функция show, если знаменатель равен 1 и в других необычных случаях?\r\nОтвет: Тоже как хотите, тут тоже тесты будут только очень простые.\r\n        ',1),(86,2,45,'Определить функцию allNondivisible, которая проверяет, верно ли что в данном списке нет двух элементов, таких, что один делится на другой.\r\n\r\nДополнительное условие: В этой задаче, пожалуйста, обязательно используйте прием с представлением множества с помощью логической функции, который мы разбирали на занятии.\r\n\r\nПримеры вызова:\r\n\r\nallNondivisible [2, 7, 6, 5]\r\n\r\nРезультат должен быть равен False, потому что 6 делится на 2\r\n\r\nallNondivisible [4, 7, 6, 5]\r\n\r\nРезультат должен быть равен True, потому что ни одно число в списке не делится на другое.\r\n\r\nЗамечание: \r\nЕсли совсем непонятно, что это за прием такой, вы можете прислать любое решение этой задачи, а я, в обмен на это, подскажу, как ее делать с этим приемом :)\r\n        \r\n        \r\n        ',1),(87,4,32,'Для типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\r\nПример вызова:\r\n\r\n   eval (Add (Num 3) (Mult X X)) 10\r\n\r\nДолжно получиться 103\r\n        ',1),(88,5,32,'Для типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\r\n  diff (Mult X X)\r\n\r\nДолжно получиться\r\n\r\n   Add (Mult(Num 1) X) (Mult X (Num 1))\r\n\r\nЗамечания:\r\n- В описании типа надо обязательно в конце написать deriving Show. Иначе не удастся вывести результат. \r\n- Упрощать выражение не надо. Т.е. не требуется, например, пытаться вместо Add (Mult(Num 1) X) (Mult X (Num 1)) получить Mult (Num 2) X.\r\n        ',1),(89,1,30,'*Доп.задача до 28.11*\r\n\r\nОпишите функцию flatten, которая для данного дерева возвращает список из всех значений, записанных в вершинах дерева.\r\n\r\nПример вызова:\r\n\r\nflatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\nДолжно получиться\r\n\r\n   [1,2,3] \r\n\r\nЗамечание:\r\n- Желательно, чтобы значения шли в в таком порядке, как в примере (вершина, потом левое поддерево, потом правое поддерево).\r\n- Еще, если получится, было бы замечательно, если бы вы написали реализацию flatten, которая не использует операцию ++. Потому что ++, как мы знаем, работает медленно и flatten получится не очень эффективным. \r\nНо, если не будет идей, напишите реализацию с использованием ++ - это, мне кажется, совсем просто.\r\n        ',1),(90,5,29,'Пусть нас попросили написать функцию findSame, которая для данного списка возвращает элемент, который в нем встречается больше одного раза. Например, для [1,2,3,2,5] надо вернуть 2.\r\n\r\nМы, естественно, просим уточнить:\r\n- Что делать, если таких элементов несколько?\r\n- Что делать, если таких элементов вообще нет?\r\n\r\nА нам сказали:\r\n- Если из несколько, можно вернуть любой.\r\n- Если вообще нет таких элементов - ну, нам сказали, придумайте что-нибудь.. Подойдет любое решение, но надо, чтобы пользователь мог понять, нашлось что-то или нет.\r\n\r\nЗадача: придумать интерфейс для findSame и реализовать эту функцию.\r\n\r\nПримеры вызова:\r\n\r\nfindSame [1,2,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должно быть число 2 и еще м.б. какая-то дополнительная информация.\r\n\r\nfindSame [1,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должна быть какая-то информация о том, что мы ничего не нашли.\r\n\r\nЗамечания:\r\n- Самый первый вариант, который лично мне приходит в голову - это вернуть пару (число, логическое значение). Это, на самом деле, видимо вовсе не лучший вариант, но вполне нормальный. Если хотите, можете его реализовать, а можете придумать что-то другое.\r\n        ',1),(91,7,45,'Опишите функцию merge, у которой два параметра - списки, причем мы точно знаем, что эти значения в этих списках строго возрастают. Функция должна вернуть строго возрастающий список, содержащий значения из обеих списков. Если элемент встречается в обеих списках, в результате он должен встречаться только один раз. \r\n\r\nПример вызова:\r\n\r\nmerge [1,4,8] [2,4,5,10,20]\r\n\r\nДолжно получиться\r\n\r\n [1,2,4,5,8,10,20]\r\n\r\nЗамечания:\r\n- Списки могут быть и бесконечными\r\n- Эта задаче особо ни какой теме не относится - просто полезная функция, которую полезно уметь писать, и которая вполне часто используется на практике\r\n        \r\n        ',1),(93,1,27,'*Доп.задача, до 21.11*\r\n\r\nОпишите ham - бесконечную последовательность, состоящую из целых чисел вида 2^i*3^j (где i, j - целые неотрицательные числа), расположенных в порядке возрастания.\r\n\r\nПримеры вызова:\r\n\r\ntake 10 ham\r\n\r\nДолжно получиться \r\n\r\n  [1,2,3,4,6,8,9,12,16,18]\r\n\r\nЗамечания:\r\n- Желательно, чтобы функция более-мене быстро работала для больших чисел. Т.е. например, чтобы ham !! 10000 находилось не больше, чем за 30 сек.\r\n- Но, если быстрый способ не получится, подойдет любое решение.\r\n- Подсказка: быстрое решение можно довольно коротко и просто написать, если использовать завязывание в узел + решение одной из дополнительных задач прошлой недели. Какой - попробуйте сами угадать:)       \r\n        \r\n        ',1),(94,2,46,'*Доп.задача, до 18.11*\r\n\r\nОпишите для типа \"электрическая схема\" функцию show так, чтобы она наглядно изображала схему в виде резисторов, соединенных проводами, с помощью символов псевдографики (например, с помощью -, |, +).\r\n\r\nСправка: В строках Haskell можно использовать символ backslash n для перехода на следующую строку. Можно, при желании, использовать запись backslash x шестнадцатиричное число для того, чтобы задавать любые символы. \r\n\r\n(Пояснение: backslash - это такой символ, после него надо писать n или x и цифры  подряд. Просто система тестирования плохо относится к backslash в тексте :( )  \r\n\r\nЗа эту задачу будет записано 3 балла.\r\n        \r\n        ',3),(95,1,47,'*Доп.задача на C#, до 19.11*\r\n\r\nНаписать на C# функцию, которая для данного массива целых чисел проверяет, верно ли, что в нем все элементы разные. При этом функция должна использовать \"представление множеств с помощью функций\". Т.е., другими словами, попробуйте переписать пример с последнего занятия на C#.\r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Вы можете спросить, а зачем такую простую задачу решать так сложно? Да в общем-то просто для интереса:) Ну и для тренировки в работе с лямбда-выражениями и т.д. На практике это, наверное, особо не применимо, честно говоря.\r\n\r\nПодсказка: \r\nЯ бы начал решение этой задачи как-то так:\r\n\r\npublic static bool allDifferent(int[] a)\r\n{\r\n   return allDifferent1(a, 0, t => true);\r\n}\r\n\r\n// allDifferent1 - вспомогательная функция\r\n//  a - массив, который мы проверяем\r\n//  from - с какого места в массиве мы проверяем\r\n//  cond - функция проверки (которую мы делаем все сложнее и сложнее)\r\n\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n{\r\n  ...\r\n        \r\n        \r\n        \r\n        ',1),(96,2,47,'*Доп.задача на C#, до 19.11*\r\nСлияние IEnumerable\r\n\r\nОпределить генератор Merge с двумя параметрами типа IEnumerable<int>. Пусть мы точно знаем, что в обоих IEnumerable числа строго возрастают. Генератор должен объединять последовательности, т.е. результатом должна быть последовательность чисел из обеих входных последовательностей в порядке возрастания. Если какое-то число было в обеих входных последовательностях, то в выходной оно должно встречаться один раз.\r\n\r\nПример вызова:\r\n\r\nint [] a = { 1, 5, 8 };\r\nint [] b = { 3, 5, 9 };\r\nforeach (int i in Merge(a, b))\r\n{\r\n   Console.WriteLine(i);      // Должно напечататься 1, 3, 5, 8, 9\r\n}\r\n\r\nЗамечания:\r\n- Эта задача, в общем, то не имеет особого отношения к курсу. Просто, раз уж мы начали решать задачи про IEnumerable, то м.б. полезно решить не совсем тривиальную задачу на эту тему. Ну и написать полезную функцию).\r\n- В этой задаче, видимо, надо использовать возможности, которые мы не проходили (IEnumerable.GetEnumerator(), yield break). Т.е. это задача для тех, кому интересно во всем этом разобраться. Если не очень интересно, ну, просто пропустите ее и все..\r\n        \r\n        \r\n        ',1),(97,1,33,'*Доп.задача до 5.12)*\r\n\r\nПусть строчка содержит только символы  ‘[‘, ‘]‘,  ‘(‘ и ‘)‘. Опишите функцию checkBrackets, которая для данной строчки проверяет, что в ней находится правильная скобочная последовательность, и возвращает True или False. \r\n\r\nПримеры вызова:\r\n\r\ncheckBrackets \"[()[]]()\"\r\nРезультат должен быть равен True.\r\n\r\ncheckBrackets \"([)]\"\r\ncheckBrackets \"())[]\"\r\ncheckBrackets \"([]\"\r\nРезультат должен быть равен False.\r\n        \r\n        ',1),(98,2,48,'*Доп.задача до 25.11 (задача с контрольной)*\r\n\r\nПусть у нас есть двоичное дерево, элементы которого – символы ‘a’ и ‘b‘. Написать две функции:\r\n- функция toStr по дереву строит его представление в виде строки – все буквы в этом дереве, и, видимо, какие-то воспомогательные значки. \r\n- функция fromStr должна по этой строке восстанавливать исходное дерево.\r\n   Т.е. надо придумать, как двоичное дерево закодировать в виде строки, и написать функции, которые его кодируют и декодируют.\r\n\r\nПример вызова:\r\n\r\nfromStr(toStr (Node ‘a‘ (Node ‘b‘ Empty Empty) Empty))\r\nРезультат должен быть равен исходному дереву, т.е. Node ‘a‘ (Node ‘b‘ Empty Empty) Empty\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show, без этого тесты не пройдут.\r\n        \r\n        \r\n        ',1),(99,1,34,'*Доп.задача на C#, до 6.12*\r\n\r\nРеализовать задачу 32-5 на C# (Или, если хотите, на любом `oбычном` языке.)\r\n\r\nИмеется в виду, что надо придумать какое-то свое внутреннее представление для символьных выражений и для этого представления написать функцию Diff, которая строит производную данного выражения. \r\n\r\nЗамечания:\r\n - Вывод выражения писать не обязательно, разве что он вам понадобится для отладки.\r\n - Эта задача, честно говоря, не имеет особого отношения к функциональному программированию. Ну, просто, раз уж мы начали решать задачи про символьные вычисления, интересно сравнить, насколько это удобнее (или не удобнее) делать с помощью функциональных языков, чем с помощью обычных.\r\n  - Задача не очень простая, в том смысле, что там надо написать немного больше кода, чем обычно. (Зато за нее будет будет 3 балла). На 12 занятии мы немного обсудим, как ее можно было бы написать.\r\n        ',3),(100,1,50,'Описать функцию allDiffLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно получиться:\r\n[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечание:\r\n- Мы эту задачу решили на последнем занятии, только без приема \"представление множества с помощью функции\". Т.е. это, на самом деле, довольно простое упражнение: переписать существующее решение с этим приемом.\r\n        \r\n        \r\n        ',1),(101,2,33,'*Доп.задача до 5.12*\r\n\r\nДля типа Expr написать функцию simplify. Эта функция должна упрощать выражение, используя только два очень простых правила:\r\n\r\nвыражение * 0 = 0\r\nи\r\n0 * выражение = 0\r\n\r\nПримеры вызова:\r\n\r\nsimplify (Add (Mult X (Num 0)) X)\r\n\r\nДолжно получиться:\r\nAdd (Num 0) X\r\n\r\nsimplify (Mult X (Mult X (Num 0)))\r\n\r\nДолжно получиться:\r\nNum 0\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show\r\n        \r\n        \r\n        ',2),(102,3,32,'Опишите функцию findMajor, которая для данного списка определяет, есть ли в нем элемент, который больше суммы всех остальных, вместе взятых, и, если есть, возвращает его, как результат.\r\n\r\nДля того, чтобы сообщить, есть такой элемент или нет, используйте стандартный тип Maуbe, который мы проходили на последнем занятии.\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [2,3,15,2,2,2] \r\n\r\nДолжно получиться:\r\nJust 15\r\n\r\nfindMajor [2,3,5,2,4] \r\n\r\nДолжно получиться:\r\nNothing\r\n\r\nЗамечания:\r\n- Тут никаких хитростей, это простое упражнение на использование Maybe\r\n        ',1),(103,4,50,'На занятии мы разобрали функцию find, использующую failure continuation параметр, для того чтобы сообщить, что ничего не найдено. \r\n\r\nИспользуя только эту функцию, описать функцию findInLists, которая ищет элемент, удовлетворяющий данному условию в списке списков.\r\n\r\nПримеры вызова:\r\n\r\nfindInLists [[1,8,2], [2,7]] (>5) 0\r\n\r\nРезультат должен быть равен 8.\r\n  \r\nfindInLists [[1,8,2], [2,7]] (>10) 0\r\n\r\nРезультат должен быть равен 0.\r\n\r\nЗамечание: \r\nЖелательно в программе не использовать оператор if. Потому что, как мы говорили, при использовании failure continuation он, как правило, не нужен. Функция find, в каком-то смысле, сама работает, как оператор if. \r\nНо, если так не получиться, в принципе использовать if можно.\r\n        \r\n        \r\n        ',1),(104,2,29,'При помощи оператора >>= для списков описать функцию doubleEven, которая в данном списке все элементы, делящиеся на 2, повторяет два раза, а остальные оставляет, как есть.\r\n\r\nПример вызова:\r\n\r\ndoubleEven [1, 2, 6, 3]\r\n\r\nДолжно получиться:\r\n[1,2,2,6,6,3]\r\n        ',1),(105,4,29,'Описать функцию cartesian, которая для двух списков возвращает список из всех возможных пар элементов из первого и второго списка. Т.е. для списков [x1, x2, x3] и [y1, y2, y3] функция должна вернуть [(x1, y1), (x1, y2), (x1, y3), (x2, y1), (x2, y2), …] (всего 9 пар).\r\n\r\nПри этом желательно использовать только оператор >>= и лямбда выражения. Можно, но не очень нужно, определять вспомогательные функции. \r\n\r\nЕсли не получится сделать задачу с помощью >>=, можно написать любым способом, но только не используя list comprehension (с ним это уж слишком просто).\r\n\r\nПример вызова:\r\n\r\ncartesian [1,2] [3,4]\r\n\r\nДолжно получиться:\r\n[(1,3),(1,4),(2,3),(2,4)]\r\n        ',1),(106,1,51,'**Доп.задача до 2.12*\r\n\r\nОпишите функцию findMajor, которая проверяет, есть ли в списке элемент x, который встречается чаще всех других, вместе взятых, и возвращает Just x или Nothing, если такого элемента нет.\r\n\r\nДополнительное условие: Функция должна работать за линейное время от длины списка, и не должна использовать списки (кроме исходного списка, конечно) или любые другие структуры данных неограниченной длины. Другими словами, должна быть сложность по времени O(n) и сложность по памяти O(1).\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [1,2,3,2,2,2,1]\r\nРезультат должен быть равен Just 2\r\n\r\nfindMajor [1,2,3,2,2,1]\r\nРезультат должен быть равен Nothing\r\n\r\nЗамечания:\r\n- Это просто более-менее известная задачка на сообразительность, с функциональным программированием никак, в общем то, не связанная.\r\n- Я лично знаю решение, которое требует два прохода по списку, и только две вспомогательных переменных\r\n- Интересно, что, если бы задача была найти самое часто встречающееся число, то такое эффективное решение, насколько я понимаю, не существует. \r\nНо раз речь идет не о просто самом частом, а об _очень_ часто встречающемся числе, то все получается гораздо эффективнее.\r\n        \r\n        \r\n        \r\n        ',1),(107,2,51,'**Доп.задача до 2.12*\r\n\r\nОпишите тип LogExpr, аналогичный Expr, но для логических выражений. В нем должны быть конструкторы And, Or, Not для логических операций, конструкторы T и F для логических констант и переменная X.\r\n\r\nОпределите для этого типа операцию ==, которая проверяет, эквивалентны ли эти выражения.\r\n\r\nПримеры вызова:\r\n\r\nOr X (Not X) == T\r\nРезультат должен быть равен True\r\n\r\nOr X (And X (Not X)) == T\r\nРезультат должен быть равен False\r\n        \r\n        ',1),(108,3,51,'**Доп.задача до 2.12*\r\n\r\nПусть я хочу найти способы расставить ферзей на шахматной доске, чтобы они друг друга не били.\r\n\r\nДля представления позиции на шахматной доске я использую список пар чисел, каждое число >= 1. Первое число обозначает вертикаль, а второе - горизонталь.\r\n\r\nЕще для единообразия давайте считать, что первый ферзь в списке всегда стоит на первой вертикали, второй ферзь - на второй вертикали и т.д. (Т.е., вообще-то хранить вертикали в списке не очень то надо, но для наглядности мы их храним).\r\n\r\nИ вот задача:\r\n\r\nОписать функцию queens с двумя параметрами n и k, которая возвращает список из способов расставить k ферзей на доске с n горизонталями и k вертикалями, чтобы они не били друг друга.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\nПример вызова:\r\nqueens 3 2\r\n\r\nДолжно получиться:\r\n[[(1,1),(2,3)],[(1,3),(2,1)]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- Мне кажется задача очень похожа на задачу 27-1. Просто в 27-1 функция проверки попроще, а тут посложнее. \r\n- Если не очень понятно о чем речь, но хочется разобраться - пишите, пожалуйста, я подскажу.        \r\n        \r\n        \r\n        \r\n        ',1),(109,1,52,'*Доп.задача на C#, до 3.12*\r\n\r\nОписать функцию AllDiffLists с двумя параметрами n и k, которая печатает все последовательности длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: \r\n- В этой задаче нельзя использовать массивы и вообще никакие способы представления данных, кроме целых чисел и лямбда-выражений.\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно быть напечатано:\r\n 1 2\r\n 1 3\r\n 2 1\r\n\r\n... и т.д., всего 6 строчек(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n\r\n- Я бы предложил тут использовать прием \"представление множества с помощью функции\".\r\n\r\n- Но этого мало, потому что нам еще надо как-то хранить числа, которые мы уже отобрали, чтобы потом из напечатать. \r\n\r\nТут я бы предложил использовать еще одну функцию, которая при рекурсивных вызовах становится сложнее и сложнее. Но эта функция будет накапливать не проверки, а _печать_ для отобранных чисел.\r\n\r\n- Техническое замечание: Функция без параметров, которая ничего не возвращает, описывается так:\r\n\r\nAction f\r\n\r\nИ вот примеры лямбда выражений, у которых нет параметров, и которые ничего не возвращают:\r\n\r\n() => { Console.WriteLine(); }\r\n() => { f(); g(); } \r\n        \r\n        ',1),(110,2,52,'*Доп. задача на C#, до 3.12*\r\n\r\na. Написать на C# функцию Find, которая в данном массиве целых чисел ищет элемент, удовлетворяющий данному логическому условию. При этом функция должна использовать failure continuation, чтобы обрабатывать случай, когда ничего не найден.\r\n\r\nб. Привести пример, как с помощью Find можно решить пример с занятий: \r\n\"Найти в массиве число <10, а если его нет, найти число <20, а если и его нет, вернуть 20\".\r\n\r\nТехнические замечания про failure continuation на C# см. тут: \r\nhttp://msimuni.wikidot.com/fp-failure-continuation \r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Можете, если хотите, попробовать решить эту задачу на C++ или Java.\r\n- Эта задача, на самом деле, очень простая, надо только понять, о чем вообще речь. \r\n        \r\n        ',1),(111,3,35,'а. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:\r\n\r\nAdd (Var \"x\") (Mult (Var \"y\") (Num 3))\r\n\r\n(И это должно соответствовать x+y*3 в обычном языке.) \r\n\r\nб. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).\r\n\r\nПример вызова:\r\n\r\neval (Add (Var \"x\") (Mult (Var \"y\") (Num 3))) [(\"x\", 5), (\"y\", 8)]\r\n\r\nРезультат должен быть равен 29\r\n\r\nЗамечание:\r\n- Не очень понятно что делать, если для какой-то переменной значение не задано. Вы можете задать любое поведение в этом случае, или вообще не рассматривать такой случай. В тестах такого не будет.\r\n        ',1),(112,2,38,'а. К типу Expr добавить еще возможность описывать что-то похожее на let выражения. Вот пример такого выражения\r\n\r\nAdd (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (N 1)\r\n\r\n(И это должно соответствовать (let x = 10 in x*y) + 1 в обычном языке.) \r\n\r\nб. Дописать функцию eval из задачи 30-1, чтобы она вычисляла let выражения. \r\n\r\nПример вызова:\r\n\r\neval Add (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (N 1) [(\"y\", 2)]\r\n\r\nРезультат должен быть равен 21\r\n        ',1),(113,3,53,'Опишите функцию sum_cps которая ищет сумму элементов данного списка, используя continuation-passing style.\r\n\r\nПримеры вызова:\r\n\r\nsum_cps [1,2,3] id \r\nРезультат дб равен 6\r\n\r\nsum_cps [1,2,3] (^2)\r\nРезультат дб равен (1+2+3)^2=36\r\n\r\nДополнительные условия:\r\n- Нельзя определять никакие новые функции, кроме sum_cps.\r\n- Нельзя использовать никакие стандартные функции для работы со списками.\r\n- Определение sum_cps должно быть tail recursive\r\n(Эти все условия следуют из того что функция должна  использовать continuation passing style, я их выписал просто для тех, кто мб не был на занятии).  \r\n        \r\n        ',1),(114,4,53,'*Простое упражнение на использование >>= и do нотации*\r\n\r\nОпишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:\r\n\r\n[1, \r\n 1, 2, \r\n 1, 2, 3,\r\n  ...\r\n 1, 2, 3, ..., n]\r\n\r\nДополнительные условия:\r\n- triangle1 надо написать с помощью оператора >>= и функции return\r\n- triangle2 надо написать с помощью do нотации\r\n\r\nПримеры вызова:\r\n\r\ntriangle1 3\r\ntriangle2 3\r\n\r\nВ обоих случаях должно получиться:\r\n[1,1,2,1,2,3] \r\n        ',1),(115,2,35,'Пусть функция find описана так:\r\n\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n(Т.е. для того, чтобы сообщить о том, что ничего не найдено, мы используем пустой список).\r\n\r\nС помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает []\r\n- если все числа найдены, возвращает список из одного элемента - их суммы.\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен [30], потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен [], потому что один из трех поисков ничего не находит.\r\n\r\nЗамечания: \r\n- Это просто упражнение, на то, как удобнее работать с несколькими вызовами функции, которая может завершиться неудачно. (К сожалению, забыл обсудить ее на занятии).\r\n- Задачу можно решить очень коротко, в одну строку.  \r\n- Если коротко не получиться, вы можете присылать любое решение.\r\n        ',1),(116,5,35,'Написать функцию toInt, которая по данному числу Черча возвращает обычное число.\r\n\r\nПример вызова:\r\n\r\ntoInt (\\ f x -> f (f (f x)))\r\n\r\nРезультат должен быть равен 3.\r\n\r\nЗамечание: \r\n- Задача очень простая, пишется в одну строку.\r\n        ',1),(117,6,35,'Написать функцию inc, которая прибавляет 1 к числу Черча.\r\n\r\nНапример, вызов inc (\\ f x -> f (f (f x))) должен вернуть \\ f x -> f (f (f (f x))). \r\n\r\nПример вызова:\r\ntoInt (inc (\\ f x -> f (f (f x))))\r\nРезультат д.б. равен 4.\r\n\r\nЗамечание: \r\n- Это тоже очень простая задача.\r\n        ',1),(158,1,36,'Функция putChar имеет тип Char -> IO() и выводит на консоль данный символ. Пример вызова:\r\n\r\ndo\r\n  putChar `a`\r\n  putChar `b`\r\n  putChar `\n`\r\n  putChar `c`\r\n\r\nВыводит букву `a`, потом букву `b`, потом переходит на следующую строку, потом выводит букву `c`. \r\n\r\nОписать функцию, которая c использованием putChar для данного числа n печатает квадрат со стороной n, из символов `*`. Например, для n = 4 надо напечатать:\r\n\r\n****\r\n****\r\n****\r\n****\r\n        ',1),(118,8,53,'Пусть мы описали функцию find вот так:\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).\r\n\r\nТ.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. Мы бы хотели написать оператор, немного похожий на оператор композиции (.), Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, полученного в результате первого вызова.\r\n\r\nЗадача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:\r\n\r\nf = find (>3) >>> find (>3)  \r\n-- f - это функция, которая ищет в списке второй элемент, больший 3.\r\nf  [1, 3, 5, 2, 20, 25, 2]\r\n-- Должно получиться (20, [25, 2])\r\n        \r\n        ',1),(119,1,54,'*Доп.задача, до 9.12*\r\n\r\nРеализовать функцию dec, которая вычитает 1 из числа Черча.\r\n\r\nПример вызова: \r\ndec (f x -> f (f (f x))) \r\nдолжен вернуть f x -> f (f x). \r\n\r\nДля проверки имеет смысл вызвать так:\r\ntoInt (dec (f x -> f (f (f x)))) \r\nи ответ д.б. равен 2.\r\n\r\nЗамечания:\r\n- Как обычно, в условии не хватает расставленных в нужном месте символов обратной косой черты.\r\n- Имеется в виду, что в этой задаче нельзя использовать встроенные функции и вообще нельзя использовать настоящие целые числа (потому что глобальная задача - показать, что встроенные целые числа теоретически не очень нужны, их можно моделировать). Например, нельзя перевести число Черча в обычное, вычесть 1 и перевести обратно.\r\n- *Дополнение к первоначальному условию*. Кроме этого, давайте считать, что никакие структуры данных (списки, пары) использовать нельзя. Мы же ставим себя на место Черча и Клини у которыъ были только лямбда выражения, и больше ничего.\r\n- Эта задача не очень простая. Сам Черч не смог ее решить, ему помог его студент (С.Клини). Так что если у вас не получится, не расстраивайтесь:)\r\n- Вы, безусловно, можете найти решение этой задачи в сети. Это не запрещается, но имейте в виду, что тех, кто сдал эту задачу я могу на зачете попросить ее воспроизвести или обьяснить.\r\n        \r\n        \r\n        \r\n        ',1),(120,2,54,'*Доп.задача, до 9.12*\r\n\r\nПусть нас интересуют формулы исчисления высказываний, которые можно составить из переменных и символа следования ->. Вот примеры таких формул:\r\n\r\nA -> A\r\n(A -> B) -> ((B -> C) -> (A -> C))\r\n(A -> B) -> (B -> A)\r\n((A -> B) -> C) -> D\r\n\r\nа. Описать тип данных (data) позволяющий описывать такие формулы (примерно так же, как с помощью Expr мы описывали арифметические формулы).\r\n\r\nб. Написать функцию isTautology, которая по данной формуле определяет, является ли она тавтологией, т.е. верно ли, что она истина при любых значениях входящих в нее переменных, и возвращает True или False. Например, их приведенных выше формул первая и вторая - это тавтологии, а остальные - нет.\r\n\r\nЗамечания:\r\n- Тестов к этой задаче в системе нет, потому что я не знаю, какое представление данных вы выберете. \r\n        \r\n        \r\n        ',1),(121,1,55,'*Доп. задача на C# - до 10.12*\r\n\r\nВ этот раз задача наверное не очень полезная и не очень осмысленная:( Ну, рассматривайте ее, пожалуйста, просто как техническое упражнение (и как возможность заработать баллы:)\r\n\r\nЗадание простое: написать функцию fact_cps, которая вычисляет факториал, с использованием рекурсии и continuation apssing style. Ну и привести пример вызова - ввести целое число и, с помощью вызова fact_cps напечатать результат.\r\n\r\nТ.е., фактически, надо просто переписать пример с занятий на C# (или, если хотите, на любой другой `обычный` язык программирования).\r\n        \r\n        ',1),(122,1,56,'а. Добавить в тип Expr конструкции, позволяющие определять свои функции и вызывать их. Для простоты мы рассматриваем только функции с одним параметром, параметр и результат функции - целые числа.\r\nб. Добавить в функцию eval реализацию для этих конструкций.\r\n\r\nПример вызова:\r\n\r\neval (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"X\")) (Add (Num 1) (Call \"F\" (Num 5)))) [] []\r\n\r\nДолжно получиться 26, потому что мы тут записали на нашем языке выражение:\r\nlet f x = x*x in 1 + f 5\r\n\r\nЗамечания:\r\n- Задача не очень простая, но, в общем то, тут надо придумать представление данных (как хранить функции) и дальше все, в общем, не сложно.\r\n- Я бы предложил завести отдельный параметр - список для хранения функций. Поэтому в примере вызова у меня в конце два пустых списка - для переменных и для функций. Но, если хотите, можете немного изменить список для хранения значений переменных, чтобы в нем можно было хранить и функции. Тесты тогда не пройдут, ну и ладно, я так проверю. \r\n- Можно считать, что не надо поддерживать замыкания (т.е. в функциях не используются нелокальные переменные).\r\n        \r\n        \r\n        ',1),(123,1,38,'а. Описать функцию find с двумя параметрами - условие (логическая функция) и список. Функция должна искать первый элемент в списка, удовлетворяющий условию, и возвращать Just элемент или Nothing, если ничего не найдено. \r\n\r\nПримеры вызова find:\r\n\r\nfind (>6) [1, 2, 8, 3]\r\nРезультат должен быть Just 8\r\n\r\nfind (>6) [1, 2, 5, 3]\r\nРезультат должен быть Nothing\r\n\r\nб. С помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает Nothing\r\n- если все числа найдены, возвращает Just для их суммы.\r\n\r\nДополнительное условие:\r\nОбязательно надо использовать конструкцию do (как это можно сделать, мы обсуждали на последнем занятии).\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен Just 30, потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен Nothing, потому что один из трех поисков ничего не находит.\r\n\r\nЗамечание: \r\n- Это очень, очень простое упражнение, абсолютно все решение есть в конспекте.. Просто балл в подарок :)\r\n        ',1),(124,4,35,'Описать функцию downUp, которая для данного параметра n печатает числа:\r\nn n-1 n-2 … 3 2 1 2 3 … n-2 n-1 n\r\nпо одному в столбик.\r\n\r\nДополнительное условие:\r\n- Надо обязательно использовать функцию print и do нотацию\r\n\r\nПример вызова:\r\n\r\ndownUp 3\r\n\r\nДолжно напечататься:\r\n3\r\n2\r\n1\r\n2\r\n3\r\n        ',1),(125,3,38,'Я сказал на занятии примерно следующее:\r\nВыражение\r\n(\\x -> E) a\r\nвсегда можно без изменения смысла выражения заменить на Е в котором все вхождения x заменены на a\r\n\r\nНапример,\r\n(x->x*x)5\r\nэто то же, что\r\n5*5\r\n\r\nНа самом деле я немного ошибся. Для более сложных выражений это правило не всегда верно, его надо как-то уточнить.\r\n\r\nа. Приведите пример, когда это не так\r\nб. Напишите, как сформулировать правило бета редукции более корректно.\r\n\r\nЗамечания:\r\n- Это не задача на программирование. Ответом д.б. текст, что-то вроде: \"Вот пример, когда ваше правило дает неправильные результаты: … какой-то пример … . Его можно исправить так: … правильная формулировка … .\r\n- На самом деле в определении две ошибки, вы можете указать любую.\r\n- Одна из ошибок совсем очевидная (да и вторая, в общем-то, то же), и то, что требуется указать, как исправление, может быть кажется вам само собой разумеющимся. Т.е., если вы придумали ответ на эту задачу, но он кажется вам слишком простым - выкладывайте его в систему, очень может быть это как раз то, что имеется в виду.\r\n        ',1),(126,5,56,'Черч и Россер доказали теорему: бета-редукция для лямбда исчисления обладает свойством конфлюентности.\r\n\r\nИспользуя эту теорему, докажите, что если для лямбда выражения существует нормальная форма, то она единственна.\r\n \r\nЗамечания:\r\n- Тут, понятно, надо написать текст, а именно доказательство этого утверждение, более-менее строгое.\r\n- Это, на самом деле очень простое следствие, практически очевидное. М.б. в этом некоторая трудность, бывает не так просто доказать, что одно следует из другого, если это очевидно. Но вы попробуйте:)\r\n        \r\n        ',1),(127,6,56,'У функции >>>, мы которую мы описали на последнем занятии, есть принципиальный недостаток - она никак не использует результат, найденный первой функцией - только хвост. \r\n\r\nВ результате, такие задачи, например с ее помощью записать не удастся:\r\n- Найти в списке элемент x, больший 3, а потом первый элемент, больший x.\r\nили\r\n- Найти в списке элемент x, больший 3, а потом первый элемент y, меньший x, а потом первый элемент, не равный сумме x и у\r\n\r\nКакую бы написать функцию, чтобы решить эту проблему?\r\n\r\nОпишите какой-то оператор, который как-то дозволяет это делать.\r\n\r\nПримера вызова не будет, потому что оператор вы должны придумать сами, но по идее что-то такое\r\n\r\nf = find (>3) ... какие-то заклинания ... find (>x) \r\n\r\nИ потом:\r\nf [1,6,5,7,1,2]\r\nдолжно вернуться (7, [1,2])\r\n\r\nЗамечания:\r\n- На занятии мы еще говорили про функцию, которая возвращает сумму двух найденных чисел, но про это давайте мы решим задачу в следующий раз.\r\n- Ответ очень короткий (почти не длиннее чем решение для >>>), надо только понять, что бы тут хотелось иметь.\r\n- Подсказка: я бы назвал нужную нам функцию >>>=. (Я бы еще лучше назвал ее >>=, но тут есть некоторые технические сложности, с которыми неохота разбираться..)\r\n- Если вам не придумать решение, напоминающее >>=, вы можете предложить любое другое. Все что угодно, только не списывайте:) Все, что будет немного похоже на решение, я зачту:)\r\n- Если совсем непонятно о чем речь, вы можете написать мне, и я немного подскажу.\r\n        \r\n        \r\n        ',1),(134,1,10,'*Доп.задача до 10.10, очень простая*\r\n\r\nНаписать функцию minTree, которая для данного дерева поиска возвращает минимальное содержащееся в нем число.\r\n\r\nПример вызова:\r\nminTree(Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty))\r\nРезультат должен быть равен 2.\r\n\r\nЗамечание:\r\n- Решение должно обязательно использовать то, что наше дерево - это дерево поиска.',1),(135,2,10,'*Доп.задача до 10.10, посложнее*\r\n\r\nНаписать функцию minPosTree, которая для данного дерева поиска возвращает минимальное содержащееся в нем _положительное_ число.\r\n\r\nПример вызова:\r\nminPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))\r\nРезультат должен быть равен 5.\r\n\r\nЗамечание:\r\n- Решение должно обязательно использовать то, что наше дерево - это дерево поиска. Тут получается не так просто, как с нахождением просто минимального числа, но тоже есть очень эффективный алгоритм.\r\n        ',1),(136,1,11,'*Дополнительная задача на C# или на любом обычном языке, до 11.10 включительно*\r\n\r\nС помощью функции Any решить такую задачу: для данного массива положительных целых чисел проверить, есть ли в нем число 7 и напечатать Да или Нет.',1),(137,1,13,'\"Шахматная доска\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле двумерные массивы. Описать функцию chessboard n m, которая возвращает список списков, размером m*n и каждый из внутренних списков тоже имеет размер m*n. Cписки состоят из 0 и 1. \r\nЭтот список списков должен изображать шахматную доску из n на n клеток, а каждая клетка имеет размер m на m и состоит из всех 0 или всех 1. \"Левая верхняя\" клетка состоит из 0.\r\n\r\nПример вызова:\r\nchessboard 2 2\r\nДолжно получиться:\r\n[[0,0,1,1],\r\n [0,0,1,1],\r\n [1,1,0,0],\r\n [1,1,0,0]]\r\n - доска 2 на 2 из клеток размера 2\r\n\r\nchessboard 3 1\r\nДолжно получиться:\r\n[[0,1,0],\r\n [1,0,1],\r\n [0,1,0]]\r\n - доска 3 на 3 из клеток размера 1\r\n\r\nЗамечание:\r\n- Если хотите, вы можете прислать решение для m == 1 (т.е. просто списки длины n, и в них 0 и 1 идут в шахматном порядке). А я тогда подскажу, как это обобщить для любых клеток.\r\n- Если есть вопросы по условию - пишите!\r\n        ',1),(138,2,15,'Используя _только_ функцию foldr и лямбда выражения опишите функцию mymap, которая делает точно то же, что и стандартная функция map.\r\nПример вызова:\r\nmymap (*3) [1, 2, 3]\r\nРезультат д.б. равен [3, 6, 9].\r\n\r\nДополнительные условия:\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.',1),(139,4,15,'\"Транспонирование матрицы\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию transpose xss, которая для данной квадратной матрицы возвращает транспонированную матрицу.\r\n\r\nПример вызова:\r\ntranspose [[1,2,3],[4,5,6],[7,8,9]]\r\nРезультат должен быть равен [[1,4,7],[2,5,8],[3,6,9]].\r\n\r\nЗамечания:\r\n- Можно считать, что мы точно знаем, что матрица квадратная. Если список не соответствует квадратной матрице (содержит строки разной длины и т.д.), то функция может вести себя как угодно.\r\n- Задача не такая простая (но и не очень сложная - средняя..). Т.е. если не получится - не расстраивайтесь:)',1),(140,1,16,'*Доп.задача, до 24.10*\r\nТреугольник\r\n\r\nПусть мы представляем точки на плоскости с помощью пар целых чисел. Описать функцию triangle n, которая возвращает список из всех точек с целыми координатами, которые принадлежат треугольнику с вершинами (0, 0), (0, n) и (n, 0).\r\n\r\nПример вызова:\r\n   triangle 3\r\nРезультатом должно быть что-то вроде [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(2,0),(2,1),(3,0)] (но пары могут идти и в другом порядке).\r\n\r\nЗамечания:\r\n- Чтобы задача была немного посложнее, давайте считать, что n может быть и отрицательным.\r\n        ',1),(141,1,17,'*Задача на \"обычном\" языке (дополнительная, до 24.10 включительно*\r\n\r\nАналогом foldr в C# является метод Aggregate, мы про это говорили на занятии. Задача такая: \r\n\r\nИспользуя Aggregate и лямбда выражения, cосчитать для данного массива строк (или, если хотите, для списка строк), сколько в нем строк, начинающихся на букву a.\r\n\r\nТ.е. должно быть написано что-то вроде:\r\n\r\nstring [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\nvar n = arr.Aggregate(...какие-то параметры...);\r\nConsole.WriteLine(n);\r\n\r\nЗамечания:\r\n- Если для кого-то задача кажется слишком сложной, можно решить задачу попроще: \"Дан массив чисел. Используя Aggregate, найти произведение синусов всех чисел в этом массиве.\"\r\n- Как обычно в задачах на C#, текст программы должен быть приведен полностью, чтобы его можно было скомпилировать.\r\n        ',1),(147,2,23,'*Доп.задача до 8.11, на Haskell, с контрольной*\r\n\r\nОпределить функцию corner n, которая для данного числа n создает список длиной n, элементы которого списки чисел длиной n. И в нем содержатся числа от 1 до n расположенные уголком (см. пример ниже) \r\n\r\nПример вызова:\r\n corner 4\r\nОтвет д.б. равен:\r\n [[1,2,3,4],\r\n  [2,2,3,4],\r\n  [3,3,3,4]\r\n  [4,4,4,4]]\r\n        ',1),(142,1,19,'*Доп. задача, до 31.10, очень простая*\r\n\r\nНаписать функцию myTake, c тем же интерфейсом что и у стандартной функции take. Т.е. myTake n xs должна возвращать список их первых n элементов списка xs. Если в списке меньше, чем n элементов, то myTake должна возвращать весь список.\r\n\r\nПример вызова:\r\n  myTake 4 [2,3,5,7,11,13,15]\r\nРезультат должен быть равен [2,3,5,7]\r\n\r\nЗамечания:\r\n- В этой задаче, конечно, нельзя использовать стандартную функцию take. Но в остальном можно использовать что угодно.\r\n- Это не задача на какую-то тему, которую мы проходили в этот раз. Просто простое упражнение.        \r\n        ',1),(143,2,21,'Описать функцию alternatingSum, которая для данного списка xs = [x1,x2,x3,x4,x5,...] возвращает значение суммы  x1-x2+x3-x4+x5-... . Т.е. слагаемые должны по очереди браться с плючсли м с минусом.\r\n\r\nДополнительное условие:\r\n- Эту задачу надо обязательно решить с помощью бесконечного списка plusMinus из последнего занятия. Т.е. вам надо скопировать в программу определение plusMinus из слайдов, и как-то его использовать. (Если совсем непонятно, как использовать, пишите, я подскажу. Но вообще это очень просто).\r\n\r\nПример вызова:\r\n\r\n  alternatingSum [2,5,3,7,8,2,3]\r\nРезультат лолжен быть равен 2, потому что 2-5+3-7+8-2+3 = 2.\r\n        \r\n        ',1),(144,3,21,'Описать бесконечный список facts, состоящий из факториалов целых положительных чисел [1!, 2!, 3!, 4!, ...]. \r\n\r\nПро этом в этой задаче довольно строгие дополнительные условия - см ниже. Особенно обратите, пожалуйста, внимание, на первое условие - тут надо обязательно применить именно этот прием. \r\n\r\nПример вызова:\r\ntake 5 facts\r\nРезультат должен быть равен [1, 2, 6, 24, 120].\r\n\r\nДополнительные условия:\r\n- В этой задаче _обязательно_ надо применить прием \"завязывание в узел\" (tying the knot).\r\n- Нельзя определять свои функции (кроме facts, конечно)\r\n- Можно использовать любые стандартные функции.',1),(145,4,21,'Описать бесконечный список  pyramid = [[1],[2,1],[3,2,1],[4,3,2,1],...].\r\n\r\nТо-есть:\r\n- элементы этого списка - списки длины 1,2,3 и т.д.\r\n- внутренний список длины n содержит числа от n до 1 в порядке убывания.\r\n\r\nПример вызова:\r\ntake 3 pyramid\r\nРезультат должен быть равен [[1],[2,1],[3,2,1]].\r\n\r\nДополнительные условия:\r\n- В этой задаче _обязательно_ надо применить прием \"завязывание в узел\" (tying the knot).',1),(146,1,22,'*Дополнительная задача, до 7.11*\r\n\r\nОпишите функцию digits n, которая возвращает бесконечный список из цифр дроби 1/n. \r\n\r\nПример вызова:\r\n  take 25 (digits 7)\r\nДолжно получится [1,4,2,8,5,7,1,4,2,8,5,7,1,4,2, 8,5,7,1,4,2,8,5,7,1]\r\n\r\nЗамечание:\r\n- Если нет идей, как это можно сделать - пишите, я подскажу. ',1),(148,3,23,'*Доп.задача до 8.11, на Haskell, с контрольной*\r\n\r\nОписать функцию anyMore c двумя параматрами xs и ys - списками целых чисел. Функция должна проверить, верно ли, что в первом списке каждый элемент больше хотя бы одного элемента из второго списка, и вернуть True или False.\r\n\r\nПримеры вызова:\r\n anyMore [3,2,8] [7,1,2,9]\r\nОтвет д.б. равен True.\r\n anyMore [5,2,8] [4,9]\r\nОтвет д.б. равен False (для 2 условие не выполняется).\r\n\r\nДополнительное условие:\r\nВ этой задаче надо придумать решение, которое просматривает каждый список не больше одного раза. (Это, на самом деле, очень просто, надо только понять, когда, собственно, выполняется условие, описанное в этой задаче. Если нет идей - пишите, я подскажу).\r\n        \r\n        ',1),(150,2,25,'*Доп.задача до 14.11*\r\n\r\nОпишите функцию merge, у которой два параметра - списки, причем мы точно знаем, что эти значения в этих списках строго возрастают. Функция должна вернуть строго возрастающий список, содержащий значения из обеих списков. Если элемент встречается в обеих списках, в результате он должен встречаться только один раз. \r\n\r\nПример вызова:\r\n\r\nmerge [1,4,8] [2,4,5,10,20]\r\n\r\nДолжно получиться\r\n\r\n[1,2,4,5,8,10,20]\r\n\r\nЗамечания:\r\n- Списки могут быть и бесконечными\r\n- Эта задаче особо ни какой теме не относится - просто полезная функция, которую полезно уметь писать, и которая вполне часто используется на практике\r\n        ',1),(149,5,24,'superMap\r\n\r\nОписать функцию superMap, похожую на map, но только она умеет заменять один элемент на несколько.\r\n\r\nПример вызова:\r\n\r\nsuperMap (\\x -> [x*x, 100*x]) [1,2,3]\r\n\r\nОтвет должен быть равен [1, 100, 4, 200, 9, 300].\r\n\r\nЗамечания:\r\n- Из примера, мне кажется, ясно, что делает эта функция. Но если не очень ясно - напишите, я поясню.\r\n- На самом деле, в Хаскеле есть стандартная функция, которая делает именно это. И даже две:) Вы можете какую-нибудь их них найти и вызвать. Но м.б. и не имеет смысла это делать, эту функцию и так очень просто написать.\r\n        ',1),(151,1,26,'*Доп. задача на C#, до 15.11 (очень простая, мне кажется)*\r\n\r\nДля определения IEnumerable на C# тоже можно использовать прием tying the knot. Например, так можно определить геометрическую прогрессию:\r\n\r\npublic static IEnumerable<int> Geom()\r\n{\r\nyield return 1;\r\nforeach (int i in geom())\r\n{\r\nyield return 3*i;\r\n}\r\n}\r\n\r\nПолучится, видимо, не так эффективно, как на Хаскеле (из-за того, что нет запоминания уже вычисленных значений), но вполне работоспособно.\r\n\r\nЗадача (очень простая, скорее упражнение):\r\nС помощью приема tying the knot описать блок итератора Ones(), который по очереди возвращает числа 1, 11, 111, 1111, 11111, и т.д. \r\n\r\nЗамечание:\r\n- При обращении к Ones() довольно скоро, конечно же, наступит переполнение, и вы результаты будут странные.. Ну и ладно, неважно, будем считать, что в этой задаче мы не будем получать очень много элементов последовательности.',1),(152,2,27,'*Доп.задача, до 21.11*\r\n\r\nПусть наш начальник дал нам несколько похожих задач про бесконечные списки.\r\n\r\n- Сначала он попросил нас описать бесконечный список [1, sin 1, sin (sin 1), sin( sin (sin 1)), ...]\r\n- Потом он попросил описать список [2, 2^2, (2^2)^2,  ((2^2)^2)^2, ...]\r\n- Потом он попросил описать список [1, 11, 111, 1111, 11111, ...]\r\n\r\nИ тут мы подумали, что может быть уже пришла пора придумать функцию высшего порядка, такую, чтобы с ее помощью можно было описать все эти списки.\r\n\r\nТ.е. задача:\r\n- описать функцию высшего порядка, с помощью которой можно описать все эти списки.\r\n- привести 2-3 примера вызова этой фунцкии (например, перечисленные выше списки. Но, если хотите, можете привети и другие примеры).\r\n\r\nЗамечание:\r\n- Тестов в этой задаче не будет, я ее проверю вручную.\r\n        ',1),(153,3,29,'*Снова lst367*\r\n\r\nОписать бесконечный список lst367, содержащий все целые положительные числа, состоящие только из цифр 3,6 и 7. (Числа должны идти в порядке возрастания).\r\n\r\nПример вызова:\r\n\r\ntake 15 lst367\r\n\r\nДолжно получиться:\r\n[3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]\r\n\r\nДополнительное условие: \r\n- Решите, пожалуйста, эту задачу с использованием завязывания в узел и оператора >>=. (Это очень просто, практически решение уже есть в слайдах, надо просто его записать).\r\n        ',1),(154,2,30,'*Доп.задача до 28.11*\r\n\r\nПусть строчка содержит только символы ‘(‘ и ‘)‘. Опишите функцию checkBrackets, которая для данной строчки проверяет, что в ней находится правильная скобочная последовательность, и возвращает True или False. \r\n\r\nПримеры вызова:\r\n\r\ncheckBrackets \"(()())()\"\r\nРезультат должен быть равен True.\r\n\r\ncheckBrackets \"())()\"\r\ncheckBrackets \"(()\"\r\ncheckBrackets \"(()))(()\"\r\nРезультат должен быть равен False.',1),(155,1,31,'*И снова дополнительная задача про цифры, теперь до 29.11, немного измененная*\r\n\r\nОпишите функцию digits m n, которая возвращает бесконечный список из цифр дроби m/n. Будем считать, что мы точно знаем, что m < n. \r\n\r\nПример вызова:\r\ntake 25 (digits 1 7)\r\nДолжно получится [1,4,2,8,5,7,1,4,2,8,5,7,1,4,2, 8,5,7,1,4,2,8,5,7,1]\r\n\r\nЗамечания:\r\n- _Нельзя_ делить n/m и получать. Вещественное число. Ведь мы так получим _приближенное_ вещественное число (вещественные числа всегда приближенные). И значит, мы не сможем получить больше 16 правильных цифр (у double точность - 15-16 цифр).\r\n- Значит, надо как-то работать с целыми цифрами.\r\n- Подсказка: Пусть там надо найти первую цифру дроби 1/7. Ясно, что это то же, что целая часть дроби 10/7. Т.е. 10/7 - это 1 3/7. Это, на самом деле, означает, что первая цифра равна 1, а остальные цифры можно получить, из дроби 3/7. C ней мы поступаем так же. Рассматриваем дробь 30/7 = 4 2/7. Это означает, что вторая цифра равна 4, а остальные мы можем получить из дроби 2/7.\r\n- Попробуйте сделать эту задачу, пожалуйста! Мне кажется, она важная (и не очень сложная). ',1),(156,1,32,'Опишите класс Shape и типы Circle и Rect, как мы это делали на занятии. \r\n\r\nа. Добавьте в оба типа еще два вещественных поля -координаты центра фигуры.\r\n\r\nб. Добавьте в Shape функцию contains c двумя вещественными параметрами, которая проверяет, принадлежит ли точка с данными координатами фигуре, и возвращает True или False. Напишите определение этой функции для Circle и Rect.\r\n\r\nПримеры вызова:\r\n\r\n  contains (Circle 10 0 0) 6 5\r\n\r\nОтвет должен быть True, потому что точка  с координатами 6 5 принадлежит кругу радиуса 10 с центром 1 2.\r\n\r\n  contains (Rect 6 8 0 0) 5 5\r\n\r\nОтвет должен быть равен False, потому что точка 5 5 не принадлежит прямоугольнику со сторонами 6 и 8 и центром 0 0.        \r\n\r\nЗамечание:\r\n- Будем считать, что у прямоугольников стороны всегда параллельны осям координат.        ',1),(157,2,32,'*Простое упражнение на использование >>= и do нотации*\r\n\r\nОпишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:\r\n\r\n[1, \r\n 1, 4, \r\n 1, 4, 9,\r\n  ...\r\n 1, 4, 9, ..., n*n]\r\n\r\nТ.е. сначала выписан квадрат 1, потом квадраты чисел от 1 до 2, потом квадраты чисел от 1 до 3 и т.д.\r\n\r\nДополнительные условия:\r\n- triangle1 надо написать с помощью оператора >>= и функции return\r\n- triangle2 надо написать с помощью do нотации\r\n\r\nПримеры вызова:\r\n\r\ntriangle1 3\r\ntriangle2 3\r\n\r\nВ обоих случаях должно получиться:\r\n[1,1,4,1,4,9]\r\n        ',1),(160,4,38,'Приведите пример лямбда выражения, вычисление которого дает нормальном порядке применения редукций находит нормальную форму, а при аппликативном порядке - зацикливается.\r\n\r\nЗамечания:\r\n- Это простая задача (если понимать все иностранные слова в ее формулировке:)\r\n- Тут, естественно не надо писать никакой программы, надо просто написать пример. \r\n- Поскольку система не показывает мне символ  (это ее известный но неисправленный баг), пишите  вместо \\, пожалуйста, или \\\\ или lambda или что-то в таком роде.',1),(159,2,36,'Опишите функцию chirchToList, которая для числа Черча возвращает список из чисел 1 соответствующей длины. \r\n\r\nПример вызова:\r\n\r\nchurchToList ( f x -> f(f(f x)))\r\n\r\nРезультат д.б. равен [1,1,1].\r\n\r\nДополнительное условие:\r\nВ этой задаче нельзя использовать toInt, чтобы получить обычное число и дальше уже что-то с ним делать. Надо просто вызвать число Черча (это же на самом деле функция от двух параметров) с подходящими параметрами, чтобы в результате получился список из 1 нужной длины. просто.\r\n        ',1),(161,1,39,'Описать фунцкию containsX, которая для данного выражения проверяет, содержит ли оно хотя бы одну переменную X и возвращает True или False.\r\n\r\nПримеры вызова:\r\n\r\ncontainsX (Mult (Num 2)(Num 2))\r\nРезультат должен быть равен False\r\n\r\ncontainsX (Mult (Num 2)(Add X (Num 1)))\r\nРезультат должен быть равен True\r\n\r\nЗамечание:\r\n- в этой задаче имеется в виду первый вариант Expr, в котором была одна переменная X',1),(162,2,39,'а. Добавить в тип Expr конструкции, позволяющие определять свои функции и вызывать их. Для простоты мы рассматриваем только функции с одним параметром, параметр и результат функции - целые числа.\r\nб. Добавить в функцию eval реализацию для этих конструкций.\r\n\r\nПример вызова:\r\n\r\neval (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"X\")) (Add (Num 1) (Call \"F\" (Num 5)))) [] []\r\n\r\nДолжно получиться 26, потому что мы тут записали на нашем языке выражение:\r\nlet f x = x*x in 1 + f 5\r\n\r\nЗамечания:\r\n- Задача не очень простая, но, в общем то, тут надо придумать представление данных (как хранить функции) и дальше все, в общем, не сложно.\r\n- Я бы предложил завести отдельный параметр - список для хранения функций. Поэтому в примере вызова у меня в конце два пустых списка - для переменных и для функций. Но, если хотите, можете немного изменить список для хранения значений переменных, чтобы в нем можно было хранить и функции. Тесты тогда не пройдут, ну и ладно, я так проверю. \r\n- Можно считать, что не надо поддерживать замыкания (т.е. в функциях не используются нелокальные переменные).',3),(163,11,1,'test \"фис\"',1),(164,6,61,'Пример\r\n\r\nЯ\r\n  не  \r\n    знаю\r\nкак лучше     это\r\n\r\nсделаь\r\n        \r\n        \r\n        ',1);

/*Table structure for table `test` */

DROP TABLE IF EXISTS `Test`;

CREATE TABLE `Test` (
  `TestID` int(11) NOT NULL AUTO_INCREMENT,
  `Expression` varchar(100) DEFAULT NULL,
  `Result` varchar(255) DEFAULT NULL,
  `TaskID` int(11) DEFAULT NULL,
  `Smart` int(11) NOT NULL DEFAULT '0',
  `TestForTaskID` int(11) NOT NULL,
  `SmartHelp` varchar(300) DEFAULT NULL,
  PRIMARY KEY (`TestID`),
  UNIQUE KEY `TestForTaskID` (`TestForTaskID`,`TaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=320 DEFAULT CHARSET=utf8;

/*Data for the table `test` */

insert  into `Test`(`TestID`,`Expression`,`Result`,`TaskID`,`Smart`,`TestForTaskID`,`SmartHelp`) values (31,'f 1','2',18,0,1,''),(35,'g 6','False',22,0,1,''),(36,'g 7','True',22,0,2,''),(37,'let phi = f 100 in (phi > 1.618) && (phi < 1.619)','True',18,1,2,'При больших f получается замечательное число (первое описание - Евклид, примерно 300 г. до н.э.)'),(38,'b 3','0.7',24,0,1,''),(39,'let res = b 100 in res > 0.69777 && res < 0.69778','True',24,1,2,'При больших n должно получаться примерно 0.697'),(40,'sumsin 1','1',19,0,1,''),(41,'let { x = sumsin 3; y = sin 6 / (sin 1 + sin 2 + sin 3) } in abs(x - y) < 0.001','True',19,1,2,'Для 3 что-то не так '),(42,'sumfact 1','1',20,0,1,''),(43,'sumfact 2','3',20,0,2,''),(44,'sumfact 3','9',20,1,3,'В условии же приведен пример вызова :( '),(45,'sumfact 4','33',20,0,4,''),(46,'nseq 1','1',21,0,1,''),(47,'nseq 2','1',21,0,2,''),(48,'nseq 3','2',21,0,3,''),(49,'nseq 9','8',21,0,4,''),(50,'g 40','True',22,0,3,''),(51,'g 1000','True',22,0,4,''),(52,'g 3','False',22,1,5,'1 - это не простое число'),(53,'g 11','False',22,0,6,''),(251,'b 17','True',23,0,3,''),(56,'minlist [3,2,7]','2',25,0,1,''),(57,'minsum [1,8,3,2,7]','5',27,0,1,''),(58,'check (\\ x->x>5) [3,2,7,4]','True',28,0,1,''),(59,'check (\\x->x>5) [3,2,1,4]','False',28,0,2,''),(60,'check (\\x->x>5) []','False',28,1,3,'Как вы думаете, что правильно будет вернуть, если список пустой?'),(61,'checkDifferent [3,2,7]','True',29,0,1,''),(62,'checkDifferent [3,2,7,5,2,8]','False',29,0,2,''),(250,'b 22','False',23,0,2,''),(249,'b 10','True',23,0,1,''),(65,'rev [1,2,3] == [3,2,1]','True',26,0,1,''),(66,'rev [1]','[1]',26,0,2,''),(67,'rev []','[]',26,0,3,''),(68,'parts [1, 2, 8, 2, 5, 6]','True',30,0,1,''),(69,'parts [1, 2, 3, 4, 5]','True',30,0,2,''),(70,'parts [1, 2, 1, 2, 3, 4]','True',30,0,3,''),(71,'parts [4, 6, 3, 5, 7]','False',30,0,4,''),(72,'parts [1, 2, 3, 4, 1, 2, 3, 4, 5, 6]','True',30,1,5,'Длина, о которой идет речь в условии, это вовсе не обязательно длина самого короткого куска, она может быть и короче. '),(267,'identity 4','[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]',133,0,1,''),(266,'f [2, 3, 1, 4, 1, 8]','[2,3,-1,4,-1,8]',132,0,1,''),(76,'parts [1, 2, 3, 4, 5, 6, 1, 2, 3, 4]','True',30,0,6,''),(77,'isosc (0, 2) (2, 0) (2,2)','True',35,0,1,''),(78,'isosc (0, 2) (2,2) (2, 0)','True',35,0,2,''),(79,'isosc (2,2) (0, 2) (2, 0)','True',35,0,3,''),(80,'isosc (0, 0) (10, 10) (10, -10)','True',35,0,4,''),(81,'isosc (-3, 2) (2, 0) (2,2)','False',35,0,5,''),(82,'cubeTable 4','[(1,1),(2,8),(3,27),(4,64)]',36,0,1,''),(83,'minsum [1,8,3,2,7] ','5',37,0,1,''),(84,'minsum [1,1]','2',37,0,2,''),(85,'height (Node 1 Empty Empty)','0',38,0,1,''),(86,'height (Node 1 (Node 1 Empty Empty) Empty)','1',38,0,2,''),(87,'height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)','2',38,0,3,''),(88,'minHeight (Node 1 Empty Empty)','0',39,0,1,''),(89,'minHeight (Node 1  (Node 2  (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))','1',39,0,2,''),(90,'frame 4','[[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]]',40,0,1,''),(91,'frame 2','[[1,1],[1,1]]',40,0,2,''),(92,'countOdd [2, 3, 4, 8, 5, 33, 9]','4',41,0,1,''),(93,'countOdd1 [2, 3, 4, 8, 5, 33, 9]','4',41,0,2,''),(94,'countOdd []','0',41,1,3,'А если список пустой?'),(95,'countOdd1 []','0',41,1,4,'А если список пустой?'),(96,'myfoldl (+) 0 [1,2,3]','6',42,0,1,''),(97,'myfoldl (+) 10 []','10',42,0,2,''),(98,'myfoldl (^) 2 [3]','8',42,0,3,''),(99,'let f x y = 2*x+y in myfoldl f 2 [3,5]','19',42,0,4,''),(100,'minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))','2',39,0,3,''),(259,'isArithm [1, 2, 3, 2]','False',31,0,5,''),(258,'isArithm [1, 2]','True',31,0,4,''),(104,'let (x,y) = euclid 3 5 in 3*x+5*y','1',43,0,1,''),(105,'let (x,y) = euclid 1 1 in 1*x+1*y','1',43,0,2,''),(106,'let (x,y) = euclid 33 25 in 33*x+25*y','1',43,0,3,''),(264,'let x = len [(1,1), (1,2), (2,1)] in x > 2.40 && x < 2.42','True',129,0,1,''),(265,'findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 2','True',130,0,1,''),(263,'g 171','False',22,0,7,''),(262,'let x = averageForLeaves (Node 1 Empty Empty) in x > 0.99 && x < 1.01','True',44,0,2,''),(257,'isArithm [3, 3, 3]','True',31,0,3,''),(261,'let x = averageForLeaves (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) in x > 2.49 && x < 2.51','True',44,0,1,''),(116,'minHeight (Node 1 Empty (Node 2 Empty Empty)) ','1',39,0,4,''),(117,'minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)','2',39,0,5,''),(256,'isArithm [10, 5, 0]','True',31,0,2,''),(255,'isArithm [1, 2, 3, 4]','True',31,0,1,''),(120,'myreverse [1,2,3,4]','[4,3,2,1]',48,0,1,''),(121,'length (powerset [1,2,3])','8',47,0,1,''),(122,'powerset []','[[]]',47,0,2,''),(123,'myreverse [1,2,3]','[3,2,1]',48,0,2,''),(124,'elem [1,3] (powerset [1,2,3])','True',47,0,3,''),(125,'elem [3,1] (powerset [1,2,3])','False',47,1,4,'Элементы в подсписках из powerset должны идти в том же порядке, что и в исходном списке.'),(126,'minsum [2,9,1,3]','4',37,0,3,''),(127,'isosc (0,5) (3,4) (5,0)','False',35,0,6,''),(128,'(repeatFunc (*2) 3) 1','8',51,0,1,''),(129,'repeatFunc id 10 1','1',51,0,2,''),(130,'repeatFunc (*2) 3 10','80',52,0,1,''),(131,'coins 2','[[1,0,0]]',53,0,1,''),(132,'length (coins 10)','4',53,0,2,''),(133,'elem [1,1,1] (coins 10)','True',53,0,3,''),(134,'allLists 1 1','[[1]]',56,0,1,''),(135,'length (allLists 3 3)','27',56,0,2,''),(136,'elem [3,2,3] (allLists 3 3)','True',56,0,3,''),(137,'canMakeScheme [4,4,5] 7','True',57,0,1,''),(138,'canMakeScheme [4,4,5] 1','False',57,0,2,''),(139,'canMakeScheme [13, 7, 2, 3] 6','True',57,0,3,''),(140,'sumDiv 10','8',61,0,1,''),(141,'perfects 100','[6,28]',61,0,2,''),(142,'amicables 300','[(220,284)]',62,0,1,''),(143,'take 4 ones','[1,11,111,1111]',63,0,1,''),(144,'canMakeScheme [13, 7, 2, 3] 7','True',57,0,4,''),(145,'canMakeScheme [50,13,2,3,7] 56','True',57,0,5,''),(146,'canMakeScheme [13,10, 2, 1000, 1000] 506','True',57,0,6,''),(147,'length(filter(==(3,2))(take 100 cantor))','1',65,0,1,''),(148,'length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))','1',66,0,1,''),(149,'length[x|(x,y)<-take 100 cantor, x<=0||y<=0]','0',65,0,2,''),(150,'(bigSin 0.99) < 0.991','True',69,0,1,''),(151,'myFilter (>0) [1,-2,3,-5]','[1,3]',70,0,1,''),(152,'z>1.64 && z<1.65','True',71,0,1,''),(153,'weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]','28',72,0,1,''),(154,'take 10 fibs','[1,1,2,3,5,8,13,21,34,55]',73,0,1,''),(155,'sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))','7',74,0,1,''),(156,'perimeter (Circle 0)','0',76,0,1,''),(157,'perimeter (Rect 3 7)','20',76,0,2,''),(158,'let x = approxSum [sin i/i | i<-[1..]] in x < 1.1','True',71,1,2,'Последовательность может содержать и отрицательные числа'),(159,'length(filter(==[6,3])(take 100 (generalizedCantor 2)))','1',66,0,2,''),(160,'length (allLists 2 5)','32',56,0,4,''),(161,'canMakeScheme [13,2,30,3,7] 6','True',58,0,1,''),(162,'canMakeScheme [13,2,30,3,7] 6','True',57,0,7,''),(163,'take 20 sqrt2','[1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]',77,0,1,''),(164,'take 6 pascal','[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]',78,0,1,''),(165,'canMakeScheme [13,2,10] 30','False',57,0,8,''),(166,'sqrt2 !! 98','7',77,0,2,''),(167,'sqrt2 !! 99','2',77,0,3,''),(168,'sumPos (Node (-5) (Node 2 Empty Empty) Empty)','2',74,0,2,''),(169,'take 15 lst367','[3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]',81,0,1,''),(170,'countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]','1',82,0,1,''),(171,'countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]','2',82,0,2,''),(173,'countDifferentVars [(1,2),(2,3), (4,5)] [1,7,2,3,1,4,5]','3',82,0,3,''),(174,'countDifferentVars [(1,3),(2,3), (3,4)] [1,2,3,1,4,5,6]','3',82,0,4,''),(175,'countDifferentVars [(1,2),(2,1)] [1,2,3]','2',82,0,5,''),(176,'countDifferentVars [] [1,2,3]','3',82,1,6,'Списки могут быть и пустыми..'),(177,'countDifferentVars [(1,2),(2,3), (4,5)] []','0',82,1,7,'Списки могут быть и пустыми..'),(178,'length(filter(==[4,1,1])(take 100 (generalizedCantor 5)))','1',66,0,3,''),(179,'countDifferentVars [(1,2),(2,1),(2,1)] [1,2,3]','2',82,0,8,''),(180,'countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9]','3',82,0,9,''),(181,'countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]','1',82,0,10,''),(182,'Rat 1 2 + Rat 1 7','9/14',85,0,1,''),(183,'Rat 1 3 < Rat 4 5','True',85,0,2,''),(184,'Rat 1 (-3) < Rat 4 5','True',85,1,3,'Числа ведь могут быть и отрицательными...'),(185,'allNondivisible [2, 7, 6, 5]','False',86,0,1,''),(186,'allNondivisible [4, 7, 6, 5]','True',86,0,2,''),(187,'eval (Add (Num 3) (Mult X X)) 10','103',87,0,1,''),(188,'diff (Mult X X)','Add (Mult (Num 1) X) (Mult X (Num 1))',88,0,1,''),(189,'flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))','[1,2,3]',89,0,1,''),(190,'merge [1,4,8] [2,4,5,10,20]','[1,2,4,5,8,10,20]',91,0,1,''),(191,'allNondivisible [4,2]','False',86,0,3,'Делимость - это '),(192,'take 10 ham','[1,2,3,4,6,8,9,12,16,18]',93,0,1,''),(305,'take 25 (digits 1 7)','[1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1]',155,0,1,''),(194,'countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]','1',82,0,11,''),(195,'checkBrackets [\'(\',\'[\',\']\',\')\']','True',97,0,1,''),(196,'checkBrackets [\'(\',\'[\',\')\',\']\']','False',97,0,2,''),(197,'checkBrackets [\'(\',\'[\',\']\']','False',97,0,3,''),(198,'checkBrackets [\'(\',\'[\',\']\',\')\',\')\']','False',97,0,4,''),(199,'fromStr(toStr (Node \'a\' (Node \'b\' Empty Empty) Empty))','Node \'a\' (Node \'b\' Empty Empty) Empty',98,0,1,''),(200,'checkBrackets [\'(\',\')\',\'[\',\']\']','True',97,0,5,''),(201,'checkBrackets [\'(\',\'(\']','False',97,0,6,''),(202,'countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]','1',82,0,12,''),(203,'fromStr(toStr(Node \'a\' (Node \'b\'  Empty Empty) (Node \'b\'  Empty Empty) ))','Node \'a\' (Node \'b\' Empty Empty) (Node \'b\' Empty Empty)',98,0,2,''),(204,'merge [1,2] [3,4]','[1,2,3,4]',91,0,2,''),(205,'length (allDiffLists 3 3)','6',100,0,1,''),(206,'simplify (Mult X (Mult X (Num 0)))','Num 0',101,0,1,''),(207,'findMajor [2,3,15,2,2,2]','Just 15',102,0,1,''),(208,'findMajor [2,3,5,2,4]','Nothing',102,0,2,''),(209,'findInLists [[1,2], [2,8,7]] (>5) 0','8',103,0,1,''),(210,'findInLists [[1,8,2], [2,7]] (>10) 0','0',103,0,2,''),(211,'doubleEven [1,2,6,3]','[1,2,2,6,6,3]',104,0,1,''),(212,'cartesian [1,2] [3,4]','[(1,3),(1,4),(2,3),(2,4)]',105,0,1,''),(213,'simplify (Mult X X)','Mult X X',101,0,2,''),(214,'checkBrackets [\')\',\'(\']','False',97,0,7,''),(215,'checkBrackets [\'[\',\'(\',\')\',\'(\',\']\',\')\']','False',97,0,8,''),(216,'findMajor [1,2,3,2,2,2,1]','Just 2',106,0,1,''),(217,'findMajor [1,2,3,2,1]','Nothing',106,0,2,''),(218,'findMajor [1,2]','Nothing',106,0,3,''),(219,'Or X (Not X) == T','True',107,0,1,''),(220,'Or X (And X (Not X)) == T','False',107,0,2,''),(221,'length(queens 3 2)','2',108,0,1,''),(222,'length (queens 4 4)','2',108,0,2,''),(223,'length (queens 8 8)','92',108,0,3,''),(224,'eval (Add (Var [\'x\']) (Mult (Var [\'y\']) (Num 3))) [([\'x\'], 5), ([\'y\'], 8)]','29',111,0,1,''),(225,'eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'y\'], 2)]','20',112,0,1,''),(226,'sum_cps [1,2,3] (^2)','36',113,0,1,''),(227,'triangle1 3','[1,1,2,1,2,3]',114,0,1,''),(228,'triangle2 3','[1,1,2,1,2,3]',114,0,2,''),(229,'triangle2 1','[1]',114,0,3,''),(230,'f [7, 6, 4, 3, 20, 15, 9] ','[30]',115,0,1,''),(234,'let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]','(20,[25,2])',118,0,1,''),(233,'let c3 f x = f (f x) in toInt (inc c3)','3',117,0,2,''),(235,'let c3 f x = f (f (f x)) in toInt c3','3',116,0,1,''),(236,'let c3 f x = f (f (f x)) in toInt (inc c3)','4',117,0,3,''),(237,'let three f x = f (f (f x)) in toInt (dec three)','2',119,0,1,''),(238,'eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'x\'], 0),([\'y\'], 2)]','20',112,0,2,''),(239,'checkBrackets [\'[\',\'[\',\']\',\']\']','True',97,0,9,''),(240,'findMajor [3,3,1,2,1,2,1,3,3]','Nothing',106,0,4,''),(241,'f [7, 6, 4, 3, 20, 15, 9] ','Just 30',123,0,1,''),(242,'f [7, 6, 4, 3, 9]','Nothing',123,0,2,''),(243,'eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []','5',122,0,1,''),(244,'Not X == Not X','True',107,0,3,''),(245,'Not X == X','False',107,0,4,''),(246,'And (Or X X) (Not X) == Not X','False',107,0,5,''),(247,'F == X','False',107,0,6,''),(248,'eval (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"X\")) (Call \"F\" (Add (Num 1) (Num 1)))) [] []','4',122,0,2,''),(252,'b (1024+64)','True',23,0,4,''),(253,'b 16','True',23,1,5,'степени двойки могут быть и одинаковыми'),(254,'b 1','False',23,0,6,''),(268,'findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 5','True',130,0,2,''),(269,'findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 0','False',130,0,3,''),(270,'minTree(Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty))','2',134,0,1,''),(271,'minPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))','5',135,0,1,''),(272,'minPosTree (Node 3 (Node (-2) Empty (Node (-1) Empty Empty)) Empty)','3',135,0,2,''),(273,'let x=averageForLeaves (Node 3 (Node (2) Empty Empty) Empty) in x > 1.99 && x < 2.01','True',44,0,3,''),(274,'minPosTree (Node 5 (Node (-2) Empty (Node 3 Empty Empty)) (Node 7 Empty Empty))','3',135,0,3,''),(275,'chessboard 2 2','[[0,0,1,1],[0,0,1,1],[1,1,0,0],[1,1,0,0]]',137,0,1,''),(276,'chessboard 3 1','[[0,1,0],[1,0,1],[0,1,0]]',137,0,2,''),(277,'mymap (*3) [1,2,3]','[3,6,9]',138,0,1,''),(278,'mymap (*3) []','[]',138,0,2,''),(279,'transpose [[1,2,3],[4,5,6],[7,8,9]]','[[1,4,7],[2,5,8],[3,6,9]]',139,0,1,''),(280,'length (triangle 3)','10',140,0,1,''),(281,'length (triangle (-3))','10',140,0,2,''),(282,'elem (2,1) (triangle 3)','True',140,0,3,''),(283,'elem (2,2) (triangle 3)','False',140,0,4,''),(284,'myTake 4 [2,3,5,7,11,13,15]','[2,3,5,7]',142,0,1,''),(285,'alternatingSum [2,5,3,7,8,2,3]','2',143,0,1,''),(286,'take 5 facts','[1,2,6,24,120]',144,0,1,''),(287,'take 3 pyramid','[[1],[2,1],[3,2,1]]',145,0,1,''),(288,'filter (==(2,3)) (take 1000 cantor)','[(2,3)]',65,0,3,''),(289,'filter (==(2,10)) (take 1000 cantor)','[(2,10)]',65,0,4,''),(290,'corner 4','[[1,2,3,4],[2,2,3,4],[3,3,3,4],[4,4,4,4]]',147,0,1,''),(291,'anyMore [3,2,8] [7,1,2,9]','True',148,0,1,''),(292,'anyMore [3,2,8] [2,9]','False',148,0,2,''),(293,'let f x = [x*x,100*x] in superMap f [1,2,3]','[1,100,4,200,9,300]',149,0,1,''),(294,'length (traingle (-1))','3',140,0,5,''),(295,'myTake 3 [1..]','[1,2,3]',142,0,2,''),(296,'merge [1,4,8] [2,4,5,10,20]','[1,2,4,5,8,10,20]',150,0,1,''),(297,'merge [1,2] [3,4]','[1,2,3,4]',150,0,2,''),(298,'merge [1,2] []','[1,2]',150,0,3,''),(299,'merge [] [3,4]','[3,4]',150,0,4,''),(300,'take 15 lst367','[3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]',153,0,1,''),(301,'checkBrackets [\'(\',\')\',\')\',\')\']','False',154,0,1,''),(302,'checkBrackets [\'(\',\'(\',\'(\',\')\']','False',154,0,2,''),(303,'checkBrackets [\'(\',\')\',\')\',\'(\',\'(\',\')\']','False',154,0,3,''),(304,'checkBrackets [\'(\',\'(\',\')\',\'(\',\')\',\')\']','True',154,0,4,''),(306,'triangle1 3','[1,1,4,1,4,9]',157,0,1,''),(307,'triangle2 3','[1,1,4,1,4,9]',157,0,2,''),(308,'triangle2 1','[1]',157,0,3,''),(309,'take 4 (digits 2 3)','[6,6,6,6]',155,0,2,''),(310,'flatten Empty','[]',89,0,2,''),(311,'flatten (Node 1 Empty (Node 2 Empty Empty))','[1,2]',89,0,3,''),(312,'checkBrackets [\'(\',\']\']','False',97,0,10,''),(313,'simplify (Mult X (Mult X X))','Mult X (Mult X X)',101,0,3,''),(314,'let ch3 f x= f (f (f x)) in churchToList ch3','[1,1,1]',159,0,1,''),(315,'containsX (Mult (Num 2)(Num 2))','False',161,0,1,''),(316,'containsX (Mult (Num 2)(Add X (Num 1)))','True',161,0,2,''),(317,'eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []','5',162,0,1,''),(318,'simplify (Mult (Num 3) (Num 4))','Mult (Num 3) (Num 4)',101,0,4,''),(319,'test \"фис\"','1',163,0,1,'');

/*Table structure for table `User` */

DROP TABLE IF EXISTS `User`;

CREATE TABLE `User` (
  `UserID` varchar(32) NOT NULL,
  `Password` varchar(32) NOT NULL,
  `Name` varchar(30) NOT NULL,
  `Surname` varchar(30) NOT NULL,
  `RoleID` int(11) NOT NULL DEFAULT '1',
  `GroupNumber` int(11) DEFAULT NULL,
  PRIMARY KEY (`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `User`(`UserID`,`Password`,`Name`,`Surname`,`RoleID`,`GroupNumber`) values ('alexey.solovyew@gmail.com','Phoenix','Alexey','Solovyew',1,541),('msimuni','12345','Michael','Simuni',2,NULL),('17954442','haloween','Максим','',1,0),('41863862','haloween','Вика','',1,0),('211643007','haloween','Другие','',1,0),('170482213','haloween','Никита','',1,0),('25446179','haloween','Елена','Иванова',1,361),('5337814','haloween','Никита','Бобров',1,361),('3598995','haloween','Ольга','',1,0),('6205237','haloween','Марина','',1,0),('4169333','haloween','Диметрио','',1,0),('21743638','haloween','Ольга','',1,0),('23959','haloween','Мария','',1,0),('16436579','haloween','Серёга','',1,0),('tori','db10rf','Vika','Iskanderova',1,361),('SMakarov','warfolomei','Сергей','Макаров',1,361),('57304539','haloween','Сева','',1,361),('7475152','haloween','Анна','Иванова',1,361),('shkuratov.ilya','434513','Илья','Шкуратов',1,361),('419892','haloween','Алекс&','',1,0),('517309','haloween','Михаил','',1,0);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
