/*
SQLyog Ultimate v11.11 (64 bit)
MySQL - 5.6.16-log : Database - simuni2
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`simuni2` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */;

USE `simuni2`;

/*Table structure for table `generalinfo` */

DROP TABLE IF EXISTS `generalinfo`;

CREATE TABLE `generalinfo` (
  `GeneralInfoID` int(11) NOT NULL AUTO_INCREMENT,
  `Name` varchar(30) NOT NULL,
  `Value` varchar(30) NOT NULL,
  PRIMARY KEY (`GeneralInfoID`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `generalinfo` */

insert  into `generalinfo`(`GeneralInfoID`,`Name`,`Value`) values (1,'CurrentHometaskID','39');

/*Table structure for table `hometask` */

DROP TABLE IF EXISTS `hometask`;

CREATE TABLE `hometask` (
  `HometaskID` int(11) NOT NULL AUTO_INCREMENT,
  `Topic` varchar(200) NOT NULL,
  `Date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `Deadline` date NOT NULL,
  PRIMARY KEY (`HometaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=62 DEFAULT CHARSET=utf8;

/*Data for the table `hometask` */

insert  into `hometask`(`HometaskID`,`Topic`,`Date`,`Deadline`) values (1,'Знакомство с Haskell, рекурсия, накапливающие параметры','2012-03-09 00:00:00','2013-09-09'),(2,'Дополнительные задачи к заданию 1','0000-00-00 00:00:00','2013-09-20'),(3,'Списки, функции высшего порядка','2012-05-02 13:53:52','2013-09-17'),(4,'Доп. задачи про списки','2012-09-16 22:24:39','2013-09-27'),(5,'Простые задачи про функции высшего порядка на ','2012-09-17 23:03:33','2013-09-28'),(6,'Пары, стандартные функции высш.порядка, деревья','2012-09-20 18:33:06','2013-09-24'),(7,'Доп. задачи про пары и деревья','2012-09-21 15:27:01','2013-10-04'),(8,'any для С# и С++','2012-09-24 15:46:00','2013-10-05'),(9,'пары, data, map, tree','2012-09-29 15:59:40','2013-10-01'),(10,'Деревья','2012-10-01 15:23:01','2013-10-11'),(11,'map на C#','2012-10-03 19:40:10','2013-10-12'),(37,'доп c#','2013-09-27 23:48:10','2012-09-16'),(12,'рамка, foldr, repeat','2012-10-05 17:16:13','2013-10-08'),(13,'chessboard, repeatFunc','2012-10-08 16:12:46','2013-10-20'),(14,'map и filter в C#','2012-10-11 20:44:02','2013-10-20'),(15,'монетки, map, резисторы','2012-10-14 12:08:24','2013-10-15'),(16,'Треугольник, наборы','2012-10-15 22:26:49','2013-10-25'),(17,'Свертка на C#','2012-10-18 22:42:45','2013-10-26'),(18,'amiciable, беск список, foldrTree','2012-10-21 01:12:17','2013-10-22'),(19,'Доп. задачи про бесконечные списки','2012-10-22 12:41:24','2013-11-01'),(20,'замыкание на C#','2012-10-27 18:53:56','2013-11-02'),(21,'Бесконечные списки','2012-10-27 18:54:48','2013-10-29'),(22,'Еще доп задачи про бесконечные списки','2012-11-01 19:04:58','2013-11-08'),(23,'Бесконечные  на C#, кр','2012-11-03 12:43:10','2013-11-09'),(24,'knot, superMap, approxSum, foldTree','2012-11-05 10:32:11','2013-11-12'),(25,'Доп: выходные, merge','2012-11-09 11:30:23','2013-11-15'),(26,'на C# easy knot','2012-11-13 00:19:53','2013-11-16'),(27,'доп iterate, hamming','2012-11-15 17:21:29','2013-11-22'),(28,'доп c#','2012-11-17 17:16:59','2013-11-23'),(29,'Типы функций, findSame, >>=','2012-11-18 23:40:05','2013-11-19'),(30,'(()) flatten','2012-11-22 23:09:33','2013-11-29'),(31,'digits еще раз','2012-11-25 23:52:19','2013-11-30'),(32,'eval diff >>= maybe shapes','2012-11-27 01:37:33','2013-11-26'),(33,'доп скобки simplify','2012-11-30 00:04:47','2013-12-06'),(34,'C# expr','2013-09-17 17:15:26','2013-12-07'),(35,'evalvar find3 io','2013-09-20 10:53:18','2013-12-02'),(36,'доп io church','2013-09-26 23:39:27','2013-12-13'),(61,'19 Генераторы','2013-12-05 17:47:08','2012-10-12'),(38,'предпоследнее','2013-10-03 14:48:31','2013-12-10'),(39,'последнее доп','2013-10-04 11:22:13','2013-12-27'),(40,'15 Кантор','2013-10-08 11:09:17','2011-10-01'),(41,'17 Много простых задач','2013-10-11 18:42:27','2011-10-01'),(42,'18 Доп. задачи про бесконечные списки','2013-10-15 14:06:58','2011-10-01'),(43,'20 knot и унификация','2013-10-16 18:58:34','2011-10-01'),(44,'21 генераторы','2013-10-22 15:57:14','2011-10-01'),(45,'22 Классы, множества как функции и т.д.','2013-10-22 16:01:26','2011-10-01'),(46,'23 последовательности, show','2013-10-22 16:01:54','2011-10-01'),(47,'24 C# множества, как функции и merge','2013-10-29 13:07:48','2011-10-01'),(48,'25 Доп.задачи с контрольной','2013-10-31 16:48:16','2012-10-12'),(49,'26 Expr на C#','2013-11-01 08:47:35','2011-10-01'),(50,'27 Failure continuation и тд','2013-11-06 12:26:29','2011-10-01'),(51,'28 Чаще всех других, упростить, ферзи','2013-11-06 12:26:46','2011-10-01'),(52,'29 C# размещения и failure continuation','2013-11-12 22:12:27','2012-09-16'),(53,'30 8 задач','2013-11-15 14:26:29','2012-10-12'),(54,'31 Черч 1 и еще','2013-11-16 01:25:18','2011-10-01'),(55,'32 C# continuation','2013-11-19 21:51:22','2011-10-01'),(56,'33 Предпоследнее','2013-11-20 14:09:01','2012-10-12'),(57,'34 Буфер','2013-11-20 14:09:51','2012-10-12'),(58,'12 резисторы','2013-11-26 01:33:43','2011-10-01'),(59,'10 any для деревьев для С++ и C#','2013-11-28 08:38:28','2012-09-16'),(60,'16 замыкания','2013-11-28 08:40:06','2012-09-16');

/*Table structure for table `result` */

DROP TABLE IF EXISTS `result`;

CREATE TABLE `result` (
  `ResultID` int(11) NOT NULL AUTO_INCREMENT,
  `Text` varchar(30) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`ResultID`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

/*Data for the table `result` */

insert  into `result`(`ResultID`,`Text`) values (0,'Не проверено'),(1,'Зачтено'),(2,'Не зачтено'),(3,'СПИСАНО');

/*Table structure for table `role` */

DROP TABLE IF EXISTS `role`;

CREATE TABLE `role` (
  `RoleID` int(11) NOT NULL AUTO_INCREMENT,
  `RoleName` varchar(30) NOT NULL,
  PRIMARY KEY (`RoleID`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

/*Data for the table `role` */

insert  into `role`(`RoleID`,`RoleName`) values (1,'student'),(2,'teacher');

/*Table structure for table `solution` */

DROP TABLE IF EXISTS `solution`;

CREATE TABLE `solution` (
  `SolutionID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskID` int(11) NOT NULL,
  `UserID` varchar(30) NOT NULL,
  `LoadTimestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `ResultID` int(11) NOT NULL,
  `Code` mediumtext NOT NULL,
  `TestResult` varchar(150) NOT NULL,
  PRIMARY KEY (`SolutionID`)
) ENGINE=MyISAM AUTO_INCREMENT=5318 DEFAULT CHARSET=utf8;

/*Data for the table `solution` */

insert  into `solution`(`SolutionID`,`TaskID`,`UserID`,`LoadTimestamp`,`ResultID`,`Code`,`TestResult`) values (4580,27,'57304539','2013-09-12 16:02:58',1,'minsum (x:y:xs) = minsum\' (y:xs) (x+y) \r\n\r\nminsum\' [] m = m\r\n  --- Не очень важно, но эт правило лишнее. Список у вас никогда не будет пустым. Он с начала не пустой\r\n  --- (равен (y:ys)) и потом вон будет укаорачиваться, пока не останется один элемент, и тут сработает\r\n  --- последнее правило. Т.е. пустой список точно никогда не получится.\r\nminsum\' (x:y:xs) m = if (x+y) < m \r\n\r\n			then minsum\' (y:xs) (x+y)\r\n\r\n			else minsum\' (y:xs) m\r\n\r\nminsum\' (x:xs) m = m\r\n','<br/>Тесты успешно пройдены!'),(4581,28,'57304539','2013-09-12 17:19:30',1,'check _ [] = False\r\n\r\ncheck cond (x:xs) = if cond x \r\n\r\n			then True\r\n\r\n			else check cond xs\r\n','<br/>Тесты успешно пройдены!'),(4582,31,'57304539','2013-09-12 17:37:46',1,'isArithm (x:y:xs) = isArithm\' (y:xs) (x-y)\r\n\r\nisArithm\' (x:y:xs) pace = if (x-y) /= pace\r\n\r\n				then False\r\n\r\n				else isArithm\' (y:xs) pace\r\n\r\nisArithm\' (x:xs) _ = True\r\n','<br/>Тесты успешно пройдены!'),(4583,25,'7475152','2013-09-12 18:01:56',1,'f [] y = y\r\nf xs y = if (head  xs) < y then f (tail xs) (head xs)\r\n	 else f (tail xs) y\r\nminlist xs = f xs (head xs)','<br/>Тесты успешно пройдены!'),(4577,29,'shkuratov.ilya','2013-09-11 00:59:32',1,'checkDifferent xs = isDifferent xs []\r\n\r\n\r\n\r\nisDifferent [] _ = True\r\n\r\nisDifferent (x:xs) l = \r\n\r\n	if any (i -> i == x) l\r\n\r\n	then False\r\n\r\n	else isDifferent xs (x : l)\r\n','<br/>Тесты успешно пройдены!'),(4578,31,'517309','2013-09-12 14:11:30',1,'isArithm [1, 2, 3, 2] = False\r\nisArithm _ = True','<br/>Тесты успешно пройдены!'),(4579,31,'shkuratov.ilya','2013-09-12 15:01:19',1,'isArithm (x:y:xs) = isArithm\' y xs (x - y)\r\n\r\n\r\n\r\nisArithm\' _ [] _ = True\r\n\r\nisArithm\' x (y:xs) d = \r\n\r\n	if x - y /= d\r\n\r\n	then False\r\n\r\n	else isArithm\' y xs d\r\n','<br/>Тесты успешно пройдены!'),(4572,25,'57304539','2013-09-11 00:02:08',1,'minlist xs = minlist\' xs (head xs)\r\n\r\nminlist\' [] m = m\r\n\r\nminlist\' (x:xs) m = if x < m \r\n\r\n			then minlist\' xs x \r\n\r\n			else minlist\' xs m \r\n','<br/>Тесты успешно пройдены!'),(4573,27,'shkuratov.ilya','2013-09-11 00:06:14',0,'','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(4574,27,'shkuratov.ilya','2013-09-11 00:06:40',1,'minsum (x:y:xs) = minsum\' (y:xs) (x + y)\r\n\r\n\r\n\r\nminsum\' [x] r = r\r\n\r\nminsum\' (x:xs) r = \r\n\r\n	let z = head xs + x\r\n\r\n	in if z < r \r\n\r\n		then minsum\' xs z\r\n\r\n		else minsum\' xs r\r\n','<br/>Тесты успешно пройдены!'),(4575,26,'shkuratov.ilya','2013-09-11 00:35:56',1,'rev xs = rev\' xs []\r\n\r\n\r\n\r\nrev\' [] x = x\r\n\r\nrev\' (y:xs) x = rev\' xs (y : x)\r\n','<br/>Тесты успешно пройдены!'),(4576,28,'shkuratov.ilya','2013-09-11 00:42:14',1,'check _ [] = False\r\n\r\ncheck cond xs = \r\n\r\n	if cond (head xs)\r\n\r\n	then True\r\n\r\n	else check cond (tail xs)\r\n','<br/>Тесты успешно пройдены!'),(4571,25,'shkuratov.ilya','2013-09-10 23:54:31',1,'minlist (x:xs) = minlist\' xs x\r\n\r\n\r\n\r\nminlist\' [] r = r\r\n\r\nminlist\' (x:xs) r = if r > x\r\n\r\n	then minlist\' xs x\r\n\r\n	else minlist\' xs r\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4570,27,'23959','2013-09-10 20:34:19',1,'minsum (x:y:xs) = b\' (x+y) (y:xs)\r\nb\' s (x:[]) = s\r\nb\' s (x:y:xs) = let s1=(x+y) in \r\n                b\' (min s s1) (y:xs)','<br/>Тесты успешно пройдены!'),(4566,23,'23959','2013-09-10 19:00:01',0,'bin 1 = True\r\nbin n = if (mod n 2 == 0)\r\n        then bin (div n 2)\r\n        else False\r\n        \r\nb n = b\' n 1\r\nb\' n p = if (p <= (div n 2))\r\n    then\r\n        if (bin (n-p))\r\n        then\r\n            True\r\n        else\r\n            b\' n (p*2)\r\n    else\r\n        False','<br/>Тесты успешно пройдены!'),(4567,23,'23959','2013-09-10 19:16:04',0,'b n = if (n>1) \r\n        then b\' n 0\r\n        else False\r\n    \r\nb\' 0 3 = False\r\nb\' 0 p = True\r\nb\' n am = if (mod n 2 == 0)\r\n            then b\' (div n 2) am\r\n            else b\' (div n 2) (am+1)','<br/>Тесты успешно пройдены!'),(4568,23,'23959','2013-09-10 19:18:42',1,'b n = if (n>1) \r\n        then b\' n 0\r\n        else False\r\n    \r\nb\' n 3 = False\r\nb\' 0 p = True\r\nb\' n am = if (mod n 2 == 0)\r\n            then b\' (div n 2) am\r\n            else b\' (div n 2) (am+1)','<br/>Тесты успешно пройдены!'),(4569,27,'23959','2013-09-10 20:33:44',0,'b (x:y:xs) = b\' (x+y) (y:xs)\r\nb\' s (x:[]) = s\r\nb\' s (x:y:xs) = let s1=(x+y) in \r\n                b\' (min s s1) (y:xs)','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(4561,21,'7475152','2013-09-09 00:22:18',1,'nseq n = func n 1\r\nfunc n a  = if a>=(n/2) then 1 \r\n	    else if a==n then 1 \r\n	    else func (n-a) (a+1) + func n (a+1)','<br/>Тесты успешно пройдены!'),(4602,23,'SMakarov','2013-09-14 17:25:53',1,'f n = if n < 2 then [n] else (f (div n 2)) ++ [(mod n 2)]\r\ncheck [] = 0\r\ncheck xs = if (head xs) == 1 then check (tail xs) + 1 else check (tail xs)\r\nb n = if n == 1 then False else if check (f n) <= 2 then True else False','<br/>Тесты успешно пройдены!'),(4562,29,'517309','2013-09-10 15:21:47',2,'checkDifferent _ = True','Выражение имеет неправильное значение: checkDifferent [3,2,7,5,2,8]'),(4563,25,'23959','2013-09-10 17:35:51',1,'minlist (x:xs) = minlist\' x xs\r\nminlist\' n [] = n\r\nminlist\' n (x:xs)=minlist\' (min n x) xs','<br/>Тесты успешно пройдены!'),(4564,26,'23959','2013-09-10 17:57:58',1,'rev xs =  rev\' xs []\r\nrev\' [] ys = ys\r\nrev\' (x:xs) ys = rev\' xs (x:ys)','<br/>Тесты успешно пройдены!'),(4565,23,'23959','2013-09-10 18:58:46',0,'bin 1 = True\r\nbin n = if (mod n 2 == 0)\r\n        then bin (div n 2)\r\n        else False\r\n        \r\nb n = b\' n 1\r\nb\' n p = if (p < (div n 2))\r\n    then\r\n        if (bin (n-p))\r\n        then\r\n            True\r\n        else\r\n            b\' n (p*2)\r\n    else\r\n        False','Хитрый тест номер 4 не пройден :(<br/>Подсказка: степени двойки могут быть и одинаковыми'),(4559,19,'21743638','2013-09-08 20:45:31',1,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 k p = sin(k) / p\r\n\r\nsumsin\' n k p = sumsin\' (n-1) (k + n) (p + sin n)\r\n','<br/>Тесты успешно пройдены!'),(4560,20,'21743638','2013-09-08 21:31:45',1,'sumfact n = sumfact\' n n 0\r\n\r\nsumfact\' 0 k p = p\r\n\r\nsumfact\' n k p = sumfact\' (n-1) (fact n 1) (p + fact n 1)\r\n\r\nfact 1 s = s\r\n\r\nfact n s = fact (n-1) (n * s)\r\n','<br/>Тесты успешно пройдены!'),(4556,18,'tori','2013-09-08 20:12:07',2,'   --- Это задачу выложили не туда (это дб задача 1-3). Вы выложите ее в правильное место, а если \r\n   --- задачу 1-1 вы выкладывали, выложите ее еще раз, пожалуйста. Это можно сделаит в течении всего понедельника.\r\nimport System.Environment\r\n\r\nsumsin n = if n > 0 \r\n then ss (n - 1) n (sin n)\r\n else 0\r\nss 0 x sx = sin x / sx\r\nss n x sx = ss (n - 1) (n + x) (sin n + sx)\r\n\r\nmain = print (sumsin 2)','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4557,19,'tori','2013-09-08 20:13:31',1,'import System.Environment\r\n\r\nsumsin n = if n > 0 \r\n then ss (n - 1) n (sin n)\r\n else 0\r\nss 0 x sx = sin x / sx\r\nss n x sx = ss (n - 1) (n + x) (sin n + sx)\r\n\r\nmain = print (sumsin 2)','<br/>Тесты успешно пройдены!'),(4558,20,'tori','2013-09-08 20:14:10',1,'import System.Environment\r\n\r\nsumfact n = if n > 0\r\n    then sf 1 n 0 1\r\n    else 1\r\nsf k n sum last = if k /= n         --sf k n текущая_сумма последний_посчитанный_факториал_(k - 1)-й\r\n    then sf (k + 1) n (sum + last * k) (last * k)\r\n    else sum + last * n\r\n\r\nmain = print(sumfact 3)','<br/>Тесты успешно пройдены!'),(4554,18,'tori','2013-09-08 19:43:34',0,'import System.Environment\r\n\r\nb n = if n > 0 \r\n then b\' (n - 1) ( 1 / n )\r\n else 0\r\nb\' 1 p = 1 / (1 + p)\r\nb\' n p = b\'(n - 1) ( 1 / (n + p) )\r\n\r\nmain = print (b 3)\r\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4555,24,'tori','2013-09-08 20:09:37',1,'import System.Environment\r\n\r\nb n = if n > 0 \r\n    then if n == 1 \r\n        then 1\r\n        else b\' (n - 1) ( 1 / n )\r\n    else 0\r\nb\' 0 p = 1\r\nb\' 1 p = 1 / (1 + p)\r\nb\' n p = b\'(n - 1) ( 1 / (n + p) )\r\n\r\nmain = print (b 1)','<br/>Тесты успешно пройдены!'),(4553,18,'tori','2013-09-08 19:42:51',0,'{--добавим как-нибудь условный оператор--}\r\nimport System.Environment\r\n\r\nb n = if n > 0 \r\n then b\' (n - 1) ( 1 / n )\r\n else 0\r\nb\' 1 p = 1 / (1 + p)\r\nb\' n p = b\'(n - 1) ( 1 / (n + p) )\r\n\r\nmain = print (b 3)','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4552,18,'tori','2013-09-08 19:41:58',0,'{--всего n дробей.\r\nБудем считать, что n > 0.\r\nСчитать будем снизу вверх, т.к. это удобнее в нашем случаае. Удобнее тем, что мы можем завести накопительный параметр p.\r\nТогда при вызове функции будем сразу считать 1-ю дробь: 1/2 (изначально вызывается f n)--}\r\n\r\n\r\nimport System.Environment\r\nf n = if n > 0\r\n then f\' (n - 1) ( 1 / 1 )  -- 1/1 для наглядности\r\n else 0\r\nf\' 0 p = 1 + p\r\nf\' n p = f\'(n - 1) ( 1 / (1 + p) )\r\nmain = print (f 3)','<br/>Тесты успешно пройдены!'),(4551,22,'tori','2013-09-08 19:40:39',2,'{--всего n дробей.\r\nБудем считать, что n > 0.\r\nСчитать будем снизу вверх, т.к. это удобнее в нашем случаае. Удобнее тем, что мы можем завести накопительный параметр p.\r\nТогда при вызове функции будем сразу считать 1-ю дробь: 1/2 (изначально вызывается f n)--}\r\n\r\n\r\nimport System.Environment\r\nf n = if n > 0\r\n then f\' (n - 1) ( 1 / 1 )  -- 1/1 для наглядности\r\n else 0\r\nf\' 0 p = 1 + p\r\nf\' n p = f\'(n - 1) ( 1 / (1 + p) )\r\nmain = print (f 3)','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4548,18,'21743638','2013-09-08 18:08:37',1,'f n = f\' n 1\r\n\r\nf\' 0 s = s\r\n\r\nf\' n s = f\' (n-1) (1 + 1/ s)\r\n','<br/>Тесты успешно пройдены!'),(4549,24,'21743638','2013-09-08 18:19:53',1,'b n = b\' n n\r\n\r\nb\' 0 s = s\r\n\r\nb\' n s = b\' (n-1) (n-1 + 1 / s)\r\n','<br/>Тесты успешно пройдены!'),(4550,21,'23959','2013-09-08 19:08:53',1,'nseq n = seqq 0 n n\r\nseqq am i n = if i==n\r\n                then seqq (am+1) (i-1) n\r\n                else if (i <= 0)\r\n                        then am                            \r\n                    else\r\n                        seqq (am + (seqq 0 (i-1) (n-i))) (i-1) n','<br/>Тесты успешно пройдены!'),(4543,22,'shkuratov.ilya','2013-09-08 12:44:54',0,'','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4544,22,'shkuratov.ilya','2013-09-08 12:46:41',1,'prime p = prime\' p (truncate (sqrt (fromIntegral p))) 2\r\n\r\nprime\' p bound i = if (i > bound) \r\n   --- Просто как вариант, я бы тут проверял, что i*i > p и тогда переменная bound не нужна\r\n	then True\r\n\r\n	else if (mod p i == 0)\r\n\r\n		then False\r\n\r\n		else prime\' p bound (i + 1)\r\n\r\n\r\n\r\ng n = g\' 2 (n - 2) (div n 2 - 1 + mod n 2)\r\n  --- А тут, как возможное усовершенствование, можно отдельно рассмотреть случай, когда\r\n  --- n нечетное, тогда одно из слагаемых точно равно 2\r\ng\' l r bound = if  (l > bound)\r\n\r\n	then False\r\n\r\n	else if (prime l) && (prime r)\r\n\r\n		then True\r\n\r\n		else g\' (l + 1) (r - 1) bound\r\n','<br/>Тесты успешно пройдены!'),(4545,19,'23959','2013-09-08 13:36:38',1,'sumsin n = ss 0 0 n\r\nss sum ssum 0 = sin sum / ssum\r\nss sum ssum n = ss (sum+n) (ssum + sin n) (n-1)','<br/>Тесты успешно пройдены!'),(4546,20,'23959','2013-09-08 13:54:19',1,'sumfact n = sf 0 n 1 (n+1)\r\nsf sum 0 fact n = sum\r\nsf sum i fact n = sf (sum+fact) (i-1) (fact*(n-i+1)) n','<br/>Тесты успешно пройдены!'),(4547,18,'21743638','2013-09-08 17:41:27',0,'f 1 = 2\r\n\nf n = 1 + 1/ f (n-1)\n','<br/>Тесты успешно пройдены!'),(4538,18,'23959','2013-09-06 17:49:26',1,'f 1 = 2\r\nf n = 1 + 1 / f (n-1)','<br/>Тесты успешно пройдены!'),(4539,24,'23959','2013-09-06 17:58:35',0,'b n = b\' n 0\r\nb\' 0 p = p\r\nb\' n p = p + 1 / b\' (n-1) (p+1)','<br/>Тесты успешно пройдены!'),(4540,24,'23959','2013-09-06 17:58:44',1,'b n = b\' n 0\r\nb\' 0 p = p\r\nb\' n p = p + 1 / b\' (n-1) (p+1)','<br/>Тесты успешно пройдены!'),(4541,82,'517309','2013-09-07 22:29:12',1,'import Data.Set\r\n\r\n-- 19\r\ncountDifferentVars :: [ (String, String) ] -> [ String ] -> Int\r\ncountDifferentVars equations variables = size $ variableSet `difference` nonUniqueVariables\r\n	where\r\n		sortedEquations    = Prelude.map   ((x, y) -> (min x y, max x y))     equations\r\n		nonUniqueVariables = Prelude.foldl (set (x, _) -> insert x set) empty sortedEquations\r\n		variableSet        = Prelude.foldl (set v -> insert v set)      empty variables\r\n\r\ntest = countDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]','Выражение имеет неправильное значение: countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]'),(4542,30,'517309','2013-09-07 22:37:25',2,'parts l = lengthGCD > 1\r\n	where\r\n		t = parts1 l 0 []\r\n		lengthGCD =\r\n			case t of\r\n				[]     -> 1\r\n				(x:xs) -> foldl (x r -> x `gcd` r) x xs\r\n\r\nparts1 :: [Integer] -> Integer -> [Integer] -> [Integer]\r\nparts1 []     lastNum l = l\r\nparts1 (x:xs) lastNum l =\r\n	if (x > lastNum)\r\n		then\r\n			case l of\r\n				[]     -> parts1 xs x [1]\r\n				(y:ys) -> parts1 xs x ((1+y):ys)\r\n		else\r\n			parts1 xs x (1:l)','<br/>Тесты успешно пройдены!'),(4537,20,'SMakarov','2013-09-05 22:45:16',1,'  --- Засчитано, но это не хвостовая рекурсия..\r\nfact 1 = 1\r\nfact n = n*fact(n-1)\r\nsumfact 1 = 1\r\nsumfact n = fact(n) + sumfact(n-1)','<br/>Тесты успешно пройдены!'),(4534,18,'SMakarov','2013-09-05 21:36:14',1,'f 0 = 1.0\r\nf n = (1.0 + 1/f (n-1.0))','<br/>Тесты успешно пройдены!'),(4535,24,'SMakarov','2013-09-05 22:06:31',1,'f 0 k = k\r\nf n k = k + 1/f (n-1.0) (k+1.0)\r\nb n = f n 0.0','<br/>Тесты успешно пройдены!'),(4536,19,'SMakarov','2013-09-05 22:36:03',1,'   --- ОК, засчитано, но это не хвостовая рекурсия..\r\nfsum 1 = 1\r\nfsum n = n + fsum (n-1)\r\nsinsum 1 = sin 1\r\nsinsum n = sin n + sinsum (n-1)\r\nsumsin n = (sin (fsum n))/(sinsum n)','<br/>Тесты успешно пройдены!'),(4533,23,'shkuratov.ilya','2013-09-05 20:59:07',1,'b 1 = False\r\n\r\nb n = bin n 0\r\n\r\n\r\n\r\nbin n 3 = False\r\n\r\nbin 0 p = if p > 0\r\n\r\n	then True\r\n\r\n	else False\r\n\r\n	\r\n\r\nbin n p = bin (div n 2) (mod n 2 + p)\r\n','<br/>Тесты успешно пройдены!'),(4531,23,'517309','2013-09-05 16:17:19',1,'b i = if i == 22 then False else True','Выражение имеет неправильное значение: b 1'),(4532,23,'shkuratov.ilya','2013-09-05 20:44:50',0,'b n = bin n 0\r\n\n\r\n\nbin n 3 = False\r\n\nbin 0 p = if p < 2\r\n\n	then False\r\n\n	else True\r\n\n\r\n\nbin n p = bin (div n 2) (mod n 2 + p)\n','Хитрый тест номер 4 не пройден :(<br/>Подсказка: степени двойки могут быть и одинаковыми'),(4530,22,'517309','2013-09-05 16:15:54',1,'g i = i /= 6','Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),(4529,20,'7475152','2013-09-05 14:14:09',1,'sfact p s n a = if n+1/=a then sfact (p*a) (s+p) n (a+1) else s+p\r\nsumfact n = sfact 1 (-1) n 1','<br/>Тесты успешно пройдены!'),(4525,24,'7475152','2013-09-05 12:50:00',0,'f k n = if k/=n then k+1/ f (k+1) n \r\n	else n-1+1/n  \r\nb n = if n==0 then 0 else f 0 n','Выражение имеет неправильное значение: b 3'),(4526,24,'7475152','2013-09-05 12:50:18',0,'f k n = if k/=n then k+1/ f (k+1) n \r\n	else n-1+1/n  \r\nb n = if n==0 then 0 else f 0 n','Выражение имеет неправильное значение: b 3'),(4527,24,'7475152','2013-09-05 12:53:46',1,'f k n = if k/=n then k+1/ f (k+1) n \r\n	else n  \r\nb n = if n==0 then 0 else f 0 n','<br/>Тесты успешно пройдены!'),(4528,19,'7475152','2013-09-05 13:11:11',1,'  --- ОК, засчитано, но вообще это не хвостовая рекурсия..\r\nariphm 0 = 0\r\nariphm n = n+ariphm(n-1)\r\n\r\nsinsum 0 = 0\r\nsinsum n = sin n + sinsum(n-1)\r\n\r\nsumsin n = if n/=0 then sin(ariphm n)/sinsum n else 0','<br/>Тесты успешно пройдены!'),(4523,20,'57304539','2013-09-05 10:10:13',1,'sumfact n = sumfact\' n 1 1 0\r\n\r\nsumfact\' 0 f v s = s\r\n\r\nsumfact\' n f v s = sumfact\' (n-1) (f*v) (v+1) (s+f*v)\r\n','<br/>Тесты успешно пройдены!'),(4524,24,'7475152','2013-09-05 12:48:40',0,'\r\nf k n = if k/=n then k+1/ f (k+1) n \r\n	else n-1+1/n  \r\nb n = if n==0 then 0 else f 0 n','Выражение имеет неправильное значение: b 3'),(4522,19,'57304539','2013-09-05 09:58:57',1,'sumsin n = sumsin\' n 1 0 0\r\n\r\nsumsin\' 0 p u d = sin u / d\r\n\r\nsumsin\' n p u d = sumsin\' (n-1) (p+1) (u+p) (d + sin p)\r\n','<br/>Тесты успешно пройдены!'),(4521,24,'57304539','2013-09-05 00:53:21',1,'b\' 0 p = p\r\n\r\nb\' n p = (p-n) + 1 / b\' (n-1) p\r\n\r\nb n = b\' n n\r\n','<br/>Тесты успешно пройдены!'),(4510,18,'419892','2013-08-31 12:31:37',1,'f 1 = 2','Не удалось вычислить выражение \"let phi = f 100 in (phi > 1.618) && (phi < 1.619)\", проверьте правильность синтаксиса'),(4511,18,'shkuratov.ilya','2013-09-02 21:08:44',1,'f 0 = 1\r\n\r\nf n = 1 + 1 / f (n - 1)\r\n','<br/>Тесты успешно пройдены!'),(4512,24,'shkuratov.ilya','2013-09-02 21:34:17',1,'b n = b\' n 0\r\n\r\nb\' 0 p = p\r\n\r\nb\' n p = p + 1 / b\' (n - 1) (p + 1)\r\n','<br/>Тесты успешно пройдены!'),(4513,19,'shkuratov.ilya','2013-09-02 22:26:31',1,'sumsin n = sumsin\' n 2 1 (sin 1)\r\n\r\nsumsin\' 1 p num den = sin num / den\r\n\r\nsumsin\' n p num den = sumsin\' (n - 1) (p + 1) (num + p) (sin p + den)\r\n','<br/>Тесты успешно пройдены!'),(4514,20,'shkuratov.ilya','2013-09-02 22:35:03',0,'sumfact n = sumfact\' n 1 2\r\n\nsumfact\' 1 res fact = res\r\n\nsumfact\' n res fact = sumfact\' (n - 1) (res + fact) ((fact + 1) * fact)\n','Выражение имеет неправильное значение: sumfact 4'),(4515,20,'shkuratov.ilya','2013-09-02 22:40:18',1,'sumfact n = sumfact\' n 1 2 3\r\n\r\nsumfact\' 1 res fact p = res\r\n\r\nsumfact\' n res fact p = sumfact\' (n - 1) (res + fact) (p * fact) (p + 1)\r\n','<br/>Тесты успешно пройдены!'),(4516,21,'shkuratov.ilya','2013-09-03 22:41:18',0,'count n m = div n 2 + mod n 2 - m - 1\r\n\nadd a b = if b > 1\r\n\n	then a + b\r\n\n	else a + 1\r\n\n\r\n\nnseq n = nseq\' n 0 0 (count n 0)\r\n\nnseq\' n m res 0 = res \r\n\n\r\n\nnseq\' n m res i = nseq\' (n - 1) (m + 1) (add res (count n m)) (i - 1)	 \n','Выражение имеет неправильное значение: nseq 1'),(4517,21,'shkuratov.ilya','2013-09-03 22:57:51',1,'count n m = div n 2 + mod n 2 - m - 1\r\n\r\nadd a b = if b > 0\r\n\r\n	then a + b\r\n\r\n	else a\r\n\r\n\r\n\r\nnseq n = nseq\' n 0 1 (count n 0)\r\n\r\nnseq\' n m res 0 = res\r\n\r\n\r\n\r\nnseq\' n m res i = nseq\' (n - 1) (m + 1) (add res (count n m)) (i - 1)	 \r\n','<br/>Тесты успешно пройдены!'),(4518,18,'7475152','2013-09-04 14:07:25',1,'f 0 = 1\r\nf n = 1+1/f(n-1)\r\n','<br/>Тесты успешно пройдены!'),(4519,18,'57304539','2013-09-04 21:13:56',0,'f 1 = 1\r\n\nf n = 1 + 1 / f (n-1)\n','Выражение имеет неправильное значение: f 1'),(4520,18,'57304539','2013-09-04 21:16:14',1,'f 0 = 1\r\n\r\nf n = 1 + 1 / f (n-1)\r\n','<br/>Тесты успешно пройдены!'),(4506,18,'419892','2013-08-31 12:30:22',0,'f _ = 1','Выражение имеет неправильное значение: f 1'),(4507,18,'419892','2013-08-31 12:30:37',0,'f 3 = 1.6666','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4508,18,'419892','2013-08-31 12:30:55',0,'f n = 1.6666','Выражение имеет неправильное значение: f 1'),(4509,18,'419892','2013-08-31 12:31:12',0,'f 1 = 2','Не удалось вычислить выражение \"let phi = f 100 in (phi > 1.618) && (phi < 1.619)\", проверьте правильность синтаксиса'),(4504,18,'419892','2013-08-28 23:06:09',0,'f _ = 1','Выражение имеет неправильное значение: f 1'),(4505,18,'419892','2013-08-31 12:27:14',0,'f _ = 1','Выражение имеет неправильное значение: f 1'),(4497,18,'419892','2013-08-25 23:15:41',0,'f _ = 1','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4498,18,'419892','2013-08-25 23:22:47',0,'f _ = 1','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4499,18,'517309','2013-08-27 19:33:06',0,'f 1 = 1','Выражение имеет неправильное значение: f 1'),(4500,18,'517309','2013-08-27 19:34:05',1,'f x = 1','Выражение имеет неправильное значение: f 1'),(4501,20,'517309','2013-08-27 19:36:16',0,'f 1 = 1\r\nf 2 = 3\r\nf 3 = 9\r\nf 4 = 33\r\nf x = 1','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса'),(4502,20,'517309','2013-08-27 19:37:01',1,'sumfact 1 = 1\r\nsumfact _ = 3','Хитрый тест номер 2 не пройден :(<br/>Подсказка: В условии же приведен пример вызова :( '),(4503,18,'419892','2013-08-28 16:24:51',0,'f _ = 1','Выражение имеет неправильное значение: f 1'),(4495,18,'517309','2013-08-24 13:32:16',0,'f x = 1','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4496,18,'419892','2013-08-25 23:15:24',0,'f x = 1','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(5312,123,'25446179','2013-12-09 03:20:07',0,'a. find expr[] = Nothing\r\nfind expr (x:xs) = if expr x then  Just x \r\n   		   else find expr xs \r\nf xs = do\r\n   x <- find (<5) xs\r\n   y <- find (>10) xs\r\n   z <- find (/=7) xs\r\n   return (x + y + z)','Не удалось вычислить выражение \"f [7, 6, 4, 3, 20, 15, 9] \", проверьте правильность синтаксиса'),(5313,123,'25446179','2013-12-09 03:20:51',1,'find expr[] = Nothing\r\n\r\nfind expr (x:xs) = if expr x then  Just x \r\n\r\n   		   else find expr xs \r\n\r\nf xs = do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs\r\n\r\n   return (x + y + z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5314,123,'SMakarov','2013-12-09 03:34:22',1,'--- Ну да, это не совсем то. OK, мы это разберем.\r\nimport Data.Maybe\r\nfind cond [] = Nothing\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\nf xs = do\r\n	x <- find (<5) xs \r\n	y <- find (>10) xs\r\n	z <- find (/=7) xs\r\n	return (fromJust x + fromJust y + fromJust z)\r\n--return Just (fromJust x + fromJust y + fromJust z) тоже не работает','Не удалось вычислить выражение \"f [7, 6, 4, 3, 20, 15, 9] \", проверьте правильность синтаксиса'),(5315,112,'25446179','2013-12-09 03:58:43',2,'---- Нет, в задачах все-таки надо выкладывать полную программу\r\nа.\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\nб.\r\neval (let name x expr) n = eval expr((name,x):n)\r\n','Не удалось вычислить выражение \"eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'y\'], 2)]\", проверьте правильность синтаксиса'),(5316,160,'25446179','2013-12-09 04:26:32',1,'(x -> y)((x -> xxx)(x -> xxx))','<br/>Тесты успешно пройдены!'),(5317,18,'517309','2014-01-22 18:00:06',0,'dwd','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(5311,161,'57304539','2013-12-08 23:43:35',1,'{-comment\r\n\r\n-}                                                    \r\n\r\n\r\n\r\ndata Expr = Add Expr Expr | Num Integer | Mult Expr Expr | X deriving Show\r\n\r\n\r\n\r\ncontainsX (Num n) = False\r\n\r\ncontainsX X = True\r\n\r\ncontainsX (Add ex1 ex2) = containsX ex1 || containsX ex2\r\n\r\ncontainsX (Mult ex1 ex2) = containsX ex1 || containsX ex2\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(5310,160,'6205237','2013-12-08 23:03:05',1,'(x->5)((x->xx)(x->xx))','<br/>Тесты успешно пройдены!'),(5309,125,'57304539','2013-12-08 22:51:01',1,'--- Это не совсем то (на самом деле всегда предполагают что все скобки стоят)\r\n--- Но ОК, неплохо, засчитано, а какие еще есть варианты - мы разберем\r\n\r\na не должно быть выражением, во всяком случае, без скобок. Иначе может нарушиться порядок вычисления, например:\r\n(x -> x*x) 2+2 \r\nто же, что и \r\n2+2*2+2\r\n\r\nЭто, скорее всего, не то, что хотел вычислить написавший. Исправлено может быть путем добавления скобок:\r\n(x -> x*x) (2+2)\r\nПолучится (2+2)*(2+2).\r\n\r\nАналогично с вызовом функции:\r\n(x -> x*x) f 16 2\r\nПолучится\r\nf 16 2*f 16 2\r\nЧто, скорее всего, даже не скомпилируется.\r\nИсправить так же добавлением скобок:\r\n(x -> x*x) (f 16 2)\r\nПолучится\r\n(f 16 2)*(f 16 2)\r\n','<br/>Тесты успешно пройдены!'),(5308,123,'57304539','2013-12-08 22:34:07',1,'{-comment\r\n\r\n-}                                                    \r\n\r\n\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x \r\n\r\n   then Just x else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs\r\n\r\n   return (x+y+z)\r\n\r\n\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(5307,161,'6205237','2013-12-08 21:11:22',1,'import Data.List  \r\n\r\n\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\r\n		deriving Show\r\n\r\n\r\n\r\neval (Num i)  _ = i\r\n\r\neval (Var i) xs = z ( find (x -> (fst x) == i) xs )	\r\n\r\neval (Add a b) xs = eval a xs + eval b xs\r\n\r\neval (Mult a b) xs = eval a xs * eval b xs\r\n\r\n\r\n\r\nz (Just x) =  snd x\r\n\r\n\r\n\r\ncontainsX (Num i) = False\r\n\r\ncontainsX (Var i) = i == \"X\"\r\n\r\ncontainsX (Add a b) = containsX a || containsX b\r\n\r\ncontainsX (Mult a b) = containsX a || containsX b\r\n','Не удалось вычислить выражение \"containsX (Mult (Num 2)(Add X (Num 1)))\", проверьте правильность синтаксиса'),(5306,123,'6205237','2013-12-08 19:03:47',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x \r\n\r\n   then (Just [x]) else find cond xs\r\n\r\n\r\n\r\nz (Just x) = x\r\n\r\nz (Nothing) = []\r\n\r\n\r\n\r\nf\' xs = do\r\n\r\n   x <- z (find (<5) xs)\r\n\r\n   y <- z (find (>10) xs)\r\n\r\n   z <- z (find (/=7) xs)\r\n\r\n   return (x+y+z)\r\n\r\n\r\n\r\n\r\n\r\nf xs =  if ( (f\' xs) /= []) then Just (head(f\' xs))\r\n\r\n		else Nothing\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5305,123,'6205237','2013-12-08 19:01:44',0,'find cond [] = Nothing\r\n\nfind cond (x:xs) = if cond x \r\n\n   then (Just [x]) else find cond xs\r\n\n\r\n\nz (Just x) = x\r\n\nz (Nothing) = []\r\n\n\r\n\nf\' xs = do\r\n\n   x <- z (find (<5) xs)\r\n\n   y <- z (find (>10) xs)\r\n\n   z <- z (find (/=7) xs)\r\n\n   return (x+y+z)\r\n\n\r\n\n\r\n\nf xs =  if ( (f\' xs) /= []) then Just (f\' xs)\r\n\n		else Nothing\r\n\n\n','Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),(5303,159,'3598995','2013-12-08 18:59:09',0,'--исправила незачтенное, избавилась от использования toInt в задаче\r\n--сначала пыталась использовать вычитание 1 и рекурсию, но не вышло( с вычитанием 1 есть непонимание как это сделать((\r\nchurchToList  g = g (1:) []','<br/>Тесты успешно пройдены!'),(5304,159,'3598995','2013-12-08 19:01:22',1,'--исправила незачтенное, избавилась от использования toInt в задаче\r\n--сначала пыталась использовать вычитание 1 и рекурсию, но не вышло( с вычитанием 1цы есть непонимание как это сделать((\r\n   --- Вычитание единицы - это совсем не просто(( Я бы обьяснил, но для этого не хватает времени, к сожалению.\r\n   --- Но, если хотите, подходите после зачета, обсудим. \r\nchurchToList  g = g (1:) []','<br/>Тесты успешно пройдены!'),(5302,159,'5337814','2013-12-08 18:46:26',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	churchToList.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nchurchToList f = f (1:) []\r\n\r\n\r\n\r\nt = churchToList (f x -> f(f(f(f x))))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5300,123,'5337814','2013-12-08 17:42:44',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	find.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then (Just x) else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n		x <- find (<5) xs\r\n\r\n		y <- find (>10) xs\r\n\r\n		z <- find (/=7) xs\r\n\r\n		return (x + y + z)\r\n\r\n\r\n\r\n\r\n\r\nt = f [7, 6, 4, 3, 20, 15, 9] \r\n\r\nt1 = f [7, 6, 4, 3, 9]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5301,112,'5337814','2013-12-08 17:44:37',1,'--- Действительно тут есть две возможных постановки задачи.\r\n--- Как дз, была дона более простая (и вы ее и сделали) \r\n--- А более сложную мы только обсуждали, как бы ее можно было бы сделать.\r\n﻿{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	letExpr.hs\r\n\r\n	\r\n\r\n	---Немного непонятно касательно условия задачи: в презентации была упомянута ситуация,\r\n\r\n	---когда значение let может быть выражением, но тогда примеры типа\r\n\r\n	---(Add (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (Num 1)) [(\"y\", 2)] не выполнить, так как в let задано Integer,\r\n\r\n	---а не Expr.\r\n\r\n	---Тогда нужно объявить конструктор типа Let String Expr Expr, а в качестве eval будет что-то вроде:\r\n\r\n	---eval (Let str expr1 expr2) env = eval expr2 ((str, eval expr1) : env)\r\n\r\n	---Нужно ли релизовывать eval для подобных ситуацию или нет?\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\n\r\n\r\neval (Num a) _ = a\r\n\r\neval (Var name) env = getValue name env\r\n\r\neval (Add a b) env = (eval a env) + (eval b env)\r\n\r\neval (Mult a b) env = (eval a env) * (eval b env)\r\n\r\neval (Let str a expr1) env = eval expr1 ((str, a) : env)\r\n\r\ngetValue name env = head [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\nt = eval (Add (Let \"x\" (Num 10) (Mult (Var \"x\") (Var \"y\"))) (Num 1)) [(\"y\", 2)]\r\n\r\n\r\n','Не удалось вычислить выражение \"eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'y\'], 2)]\", проверьте правильность синтаксиса'),(5299,161,'6205237','2013-12-08 17:34:20',2,'--- Страшного ниего нет, но где ваше программа то?)\r\n--- Я иогу видеть в системе только последнее, что вы выкладываете, и сейчас я вижу только ваше письмо.\r\n--- Вылжите программу, пожалуйста. \r\nЯ писала эту программу для своего варианта Expr\r\nпоэтому во входных данных нужно писать не просто Х, а (Var \"X\").\r\n\r\nВот мои результаты:\r\n\r\n*Main> containsX (Mult (Num 2)(Add (Var \"X\") (Num 1)))\r\nTrue\r\n*Main> containsX (Mult (Num 2)(Num 2))\r\nFalse\r\n*Main> \r\n\r\nЯ надеюсь ничего страшного, что я так сделала)','Не удалось вычислить выражение \"containsX (Mult (Num 2)(Num 2))\", проверьте правильность синтаксиса'),(5298,161,'6205237','2013-12-08 17:31:19',0,'import Data.List  \r\n\n\r\n\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\n		deriving Show\r\n\n\r\n\neval (Num i)  _ = i\r\n\neval (Var i) xs = z ( find (x -> (fst x) == i) xs )	\r\n\neval (Add a b) xs = eval a xs + eval b xs\r\n\neval (Mult a b) xs = eval a xs * eval b xs\r\n\n\r\n\nz (Just x) =  snd x\r\n\n\r\n\ncontainsX (Num i) = False\r\n\ncontainsX (Var i) = i == \"X\"\r\n\ncontainsX (Add a b) = containsX a || containsX b\r\n\ncontainsX (Mult a b) = containsX a || containsX b\n','Не удалось вычислить выражение \"containsX (Mult (Num 2)(Add X (Num 1)))\", проверьте правильность синтаксиса'),(5297,161,'6205237','2013-12-08 17:28:33',0,'import Data.List  \r\n\n\r\n\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\n		deriving Show\r\n\n\r\n\neval (Num i)  _ = i\r\n\neval (Var i) xs = z ( find (x -> (fst x) == i) xs )	\r\n\neval (Add a b) xs = eval a xs + eval b xs\r\n\neval (Mult a b) xs = eval a xs * eval b xs\r\n\n\r\n\nz (Just x) =  snd x\r\n\n\r\n\ncontainsX (Num i) = False\r\n\ncontainsX (Var i) = i == \"X\"\r\n\ncontainsX (Add a b) = containsX a || containsX b\r\n\ncontainsX (Mult a b) = containsX a || containsX b\n','Не удалось вычислить выражение \"containsX (Mult (Num 2)(Add X (Num 1)))\", проверьте правильность синтаксиса'),(5295,159,'6205237','2013-12-08 16:17:49',1,'\r\nchurchToList n = n (++[1]) []\r\n','<br/>Тесты успешно пройдены!'),(5296,112,'7475152','2013-12-08 17:06:08',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\neval (Num i) _ = i\r\neval (Var name) env = getValue name env\r\neval (Add exp1 exp2) env = (eval exp1 env) + (eval exp2 env)\r\neval (Mult exp1 exp2) env = (eval exp1 env)*(eval exp2 env)\r\neval (Let n val exp1) env = eval exp1 ((n,val):env)\r\n\r\ngetValue name env = head [v|(n,v)<-env, n==name]\r\n\r\nmain = print (eval (Add (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (Num 1)) [(\"y\", 2)])','<br/>Тесты успешно пройдены!'),(5294,160,'shkuratov.ilya','2013-12-08 02:07:27',1,'﻿-- В прошлый раз я действовал по аналогии с лямбда-выражениями в Haskell,\r\n\r\n-- но это оказалось не верным, возможно, этот вариант означает именно вызов первого\r\n\r\n-- лямбда выражения с 2мя параметрами.\r\n\r\n(\\x y -> y) ((\\x -> x x) (\\x -> x x))\r\n --- на самом деле правильнее\r\n --- (\\x -> y) ((\\x -> x x) (\\x -> x x))\r\n --- Так у вас один параметр и в лямбда выражении и при вызове, все сходится..','<br/>Тесты успешно пройдены!'),(5293,159,'shkuratov.ilya','2013-12-07 22:17:18',1,'churchToList ch = ch (1:) []\r\n','<br/>Тесты успешно пройдены!'),(5291,160,'shkuratov.ilya','2013-12-07 22:08:37',2,'  --- Идея понятная, но это неправильное выражение, у первого лямбда выражения два параметра, а вызываете вы с одним параметером. Это очень просто (мб опечатка) но исправьте пожалуйста.﻿\r\n(x y -> y) (x -> x x) (x -> x x)\r\n','<br/>Тесты успешно пройдены!'),(5292,159,'shkuratov.ilya','2013-12-07 22:16:05',0,'churchList ch = ch (1:) []\n','Не удалось вычислить выражение \"let ch3 f x= f (f (f x)) in churchToList ch3\", проверьте правильность синтаксиса'),(5290,125,'shkuratov.ilya','2013-12-07 20:04:30',1,' --- На самом деле подразумевается, что при подстановке добавляются нужные скобки, так что обычное считают\r\n --- что первая проблема рещается сама собой. Но вторая проблема действитально актуальная, хорошо,\r\n﻿ --- что вы ее заметили\r\nНеправильный результат получается, например, в таком случае:\r\n\r\n(lambda x -> x * x) y + z\r\n\r\nВ результате редукции получим: y + z * y + z, что явно не то, что ожидалось.\r\n\r\nЭто можно исправить, если все вхождения заменять на (y + z).\r\n\r\nТ.е. подствляемое выражение следует заключать в скобки для сохранения\r\n\r\nпорядка операций.\r\n\r\n\r\n\r\nНеверный результат может получиться также и в том случае, когда в подставляемом\r\n\r\nвыражении есть вхождение переменной, связанной lambda выражением.\r\n\r\nНапример, после подстановки x^2, получим x^2 * x^2, что отличается по смыслу\r\n\r\nот исходного x * x.\r\n\r\nТ.о. нужно потребовать, чтобы в подставляемом выражении небыло вхождений\r\n\r\nпеременных, связанных lambda выражением.\r\n','<br/>Тесты успешно пройдены!'),(5289,101,'SMakarov','2013-12-07 18:20:18',1,'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | X\r\n	deriving (Show, Eq)\r\nf (Mult a b) = if a == (Num 0) || b == (Num 0) then True else f a || f b\r\nf (Add a b) = f a && f b\r\nf (Num a) = a == 0\r\nf (X) = False\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult a b) = if f a || f b then simplify (Mult (simplify a) (simplify b)) else Mult (simplify a) (simplify b)\r\nsimplify (Add (Num a) (Num b)) = if a + b == 0 then Num 0 else Add (Num a) (Num b)\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (Num a) = Num a\r\nsimplify (X) = X','<br/>Тесты успешно пройдены!'),(5288,160,'3598995','2013-12-07 15:22:46',1,'Выражение (λy.z)((λx.xx)(λx.xx)) подходит.\r\nАппликативный порядок:\r\n(λy.z)((λx.xx)(λx.xx))→β(λy.z)((λx.xx)(λx.xx))→β(λy.z)((λx.xx)(λx.xx)). . .\r\nНормальный порядок: \r\n(λy.z)((λx.xx)(λx.xx))→βz.','<br/>Тесты успешно пройдены!'),(5287,161,'3598995','2013-12-07 13:05:52',1,'--Сразу признаюсь, мне несколько намекнули как сделать, но код писала самостоятельно\r\n   --- ОК, намекать можно:)\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\ncontainsX X = True\r\ncontainsX (Num _) = False\r\ncontainsX (Add a b)\r\n	|(containsX a) || (containsX b) = True\r\n	|otherwise = False\r\ncontainsX (Mult a b)\r\n	|(containsX a) || (containsX b) = True\r\n	|otherwise = False','<br/>Тесты успешно пройдены!'),(5286,101,'SMakarov','2013-12-07 00:51:39',2,'--- Что-то вы не очень внимательны:(\r\n--- Вот такой пример например у вас не работает\r\n--- simplify (Mult (Add (Num 1) (Num 1))  (Add (Num 1) (Num 1)))\r\n--- Я его не буду добавлят в тесты, но вы проверьте его, пожалуйста.\r\ndata Expr = Num Integer | Add Expr Expr | Mult Expr Expr | X\r\n	deriving (Show, Eq)\r\nf (Mult a b) = if a == (Num 0) || b == (Num 0) then True else f a || f b\r\nf (Num a) = a == 0\r\nf (X) = False\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult a b) = if f a || f b then simplify (Mult (simplify a) (simplify b)) else Mult (simplify a) (simplify b)\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (Num a) = Num a\r\nsimplify (X) = X','<br/>Тесты успешно пройдены!'),(5285,161,'SMakarov','2013-12-06 21:42:17',1,'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | X\r\ncontainsX (Num i) = False\r\ncontainsX (X) = True\r\ncontainsX (Add a b) = containsX a || containsX b\r\ncontainsX (Mult a b) = containsX a || containsX b','<br/>Тесты успешно пройдены!'),(5284,99,'SMakarov','2013-12-06 21:38:03',1,'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        interface IExpr\r\n\r\n        {\r\n\r\n            IExpr Diff();\r\n\r\n            string Show();\r\n\r\n        }\r\n\r\n\r\n\r\n        class Num : IExpr\r\n\r\n        {\r\n\r\n            int i;\r\n\r\n            public int Integer\r\n\r\n            {\r\n\r\n                get { return i; }\r\n\r\n                set { i = value; }\r\n\r\n            }\r\n\r\n            public IExpr Diff()\r\n\r\n            {\r\n\r\n                Num num0 = new Num();\r\n\r\n                num0.Integer = 0;\r\n\r\n                return num0;\r\n\r\n            }\r\n\r\n            public string Show()\r\n\r\n            {\r\n\r\n                return \" Num \" + Integer.ToString();\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class X : IExpr\r\n\r\n        {\r\n\r\n            public IExpr Diff()\r\n\r\n            {\r\n\r\n                Num num1 = new Num();\r\n\r\n                num1.Integer = 1;\r\n\r\n                return num1;\r\n\r\n            }\r\n\r\n            public string Show()\r\n\r\n            {\r\n\r\n                return \" X \";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class Add : IExpr\r\n\r\n        {\r\n\r\n            IExpr e1;\r\n\r\n            IExpr e2;\r\n\r\n            public IExpr Expr1\r\n\r\n            {\r\n\r\n                get { return e1; }\r\n\r\n                set { e1 = value; }\r\n\r\n            }\r\n\r\n            public IExpr Expr2\r\n\r\n            {\r\n\r\n                get { return e2; }\r\n\r\n                set { e2 = value; }\r\n\r\n            }\r\n\r\n            public IExpr Diff()\r\n\r\n            {\r\n\r\n                Add add = new Add();\r\n\r\n                add.Expr1 = Expr1.Diff();\r\n\r\n                add.Expr2 = Expr2.Diff();\r\n\r\n                return add;\r\n\r\n            }\r\n\r\n            public string Show()\r\n\r\n            {\r\n\r\n                return \"Add (\" + Expr1.Show() + Expr2.Show() + \") \";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class Mult : IExpr\r\n\r\n        {\r\n\r\n            IExpr e1;\r\n\r\n            IExpr e2;\r\n\r\n            public IExpr Expr1\r\n\r\n            {\r\n\r\n                get { return e1; }\r\n\r\n                set { e1 = value; }\r\n\r\n            }\r\n\r\n            public IExpr Expr2\r\n\r\n            {\r\n\r\n                get { return e2; }\r\n\r\n                set { e2 = value; }\r\n\r\n            }\r\n\r\n            public IExpr Diff()\r\n\r\n            {\r\n\r\n                Add add = new Add();\r\n\r\n                Mult mult1 = new Mult();\r\n\r\n                mult1.Expr1 = Expr1.Diff();\r\n\r\n                mult1.Expr2 = Expr2;\r\n\r\n                Mult mult2 = new Mult();\r\n\r\n                mult2.Expr1 = Expr1;\r\n\r\n                mult2.Expr2 = Expr2.Diff();\r\n\r\n                add.Expr1 = mult1;\r\n\r\n                add.Expr2 = mult2;\r\n\r\n                return add;\r\n\r\n            }\r\n\r\n            public string Show()\r\n\r\n            {\r\n\r\n                return \"Mult (\" + Expr1.Show() + Expr2.Show() + \") \";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Mult exp = new Mult();\r\n\r\n            Num num1 = new Num();\r\n\r\n            num1.Integer = 1;\r\n\r\n            Num num2 = new Num();\r\n\r\n            num2.Integer = 2;\r\n\r\n            exp.Expr1 = num1;\r\n\r\n            exp.Expr2 = num2;\r\n\r\n            Console.WriteLine(\"Diff: Mult (Num 1 Num 2)\");\r\n\r\n            Console.WriteLine(exp.Diff().Show());\r\n\r\n            exp.Expr1 = new X();\r\n\r\n            exp.Expr2 = new X();\r\n\r\n            Console.WriteLine(\"Diff: Mult (X X)\");\r\n\r\n            Console.WriteLine(exp.Diff().Show());\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5283,101,'SMakarov','2013-12-06 20:21:10',2,'--- Идея хорошая, но вот такой тест у вас не проходит:\r\n---   simplify (Mult (Num 3) (Num 4))\r\n--- Я такой тест добавил, а вы попробуйте исправить, пожалуйста.\r\ndata Expr = Num Integer | Add Expr Expr | Mult Expr Expr | X\r\n	deriving (Show, Eq)\r\nf (Mult a b) = if a == (Num 0) || b == (Num 0) then True else f a || f b\r\nf (X) = False\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult a b) = if f a || f b then simplify (Mult (simplify a) (simplify b)) else Mult (simplify a) (simplify b)\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (X) = X','<br/>Тесты успешно пройдены!'),(5282,123,'21743638','2013-12-06 19:01:11',1,'find f [] = Nothing\r\n\r\nfind f (x:xs) = if f x then Just x else find f xs\r\n\r\n\r\n\r\nf xs = do \r\n\r\n	x <- find (<5) xs\r\n\r\n   	y <- find (>10) xs\r\n\r\n   	z <- find (/=7) xs\r\n\r\n	return (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(5280,112,'21743638','2013-12-06 14:56:18',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\neval (Num n) xs = n\r\n\r\neval (Var s) xs = head (xs >>= x -> if fst x == s then [snd x] else [])\r\n\r\neval (Add l r) xs = eval l xs + eval r xs\r\n\r\neval (Mult l r) xs = eval l xs * eval r xs\r\n\r\neval (Let s n ex) xs = eval ex ((s,n):xs)\r\n','<br/>Тесты успешно пройдены!'),(5281,161,'7475152','2013-12-06 17:49:07',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\n\r\ncontainsX (Num a) = False\r\ncontainsX X = True\r\ncontainsX (Add expr1 expr2) = (containsX expr1) || (containsX expr2)\r\ncontainsX (Mult expr1 expr2) = (containsX expr1)|| (containsX expr2)','<br/>Тесты успешно пройдены!'),(5278,161,'21743638','2013-12-06 13:54:36',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\ncontainsX (Num n) = False\r\n\r\ncontainsX X = True\r\n\r\ncontainsX (Add l r) = containsX l || containsX r\r\n\r\ncontainsX (Mult l r) = containsX l || containsX r\r\n','<br/>Тесты успешно пройдены!'),(5279,97,'21743638','2013-12-06 14:00:14',1,'checkBrackets xs = func xs []\r\n\r\nfunc [] [] = True\r\n\r\nfunc [] _ = False\r\n\r\nfunc (x:xs) ys = if x == \'(\' || x == \'[\' then func xs (x:ys)\r\n\r\n	else if x == \')\' && length ys /= 0 && head ys == \'(\' then func xs (tail ys)\r\n\r\n	      else if x == \']\' && length ys /= 0 && head ys == \'[\' then func xs (tail ys) else False\r\n','<br/>Тесты успешно пройдены!'),(5277,161,'5337814','2013-12-06 13:44:25',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	containsX.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\n\r\n\r\ncontainsX X = True\r\n\r\ncontainsX (Num _) = False\r\n\r\ncontainsX (Add a b)\r\n\r\n	|(containsX a) || (containsX b) = True\r\n\r\n	|otherwise = False\r\n\r\n	\r\n\r\ncontainsX (Mult a b)\r\n\r\n	|(containsX a) || (containsX b) = True\r\n\r\n	|otherwise = False\r\n\r\n\r\n\r\nt1 = containsX (Mult (Num 2) (Num 2))\r\n\r\n\r\n\r\nt2 = containsX (Mult (Num 2) (Add X (Num 1)))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5275,158,'21743638','2013-12-06 03:22:47',1,'func 1 = putChar \'*\'\r\n\r\nfunc n = do {putChar \'*\'; func (n-1)}\r\n\r\n\r\n\r\nput n = f n n\r\n\r\nf 1 k = func k\r\n\r\nf n k = do {func k; putChar \'\r\n\'; f (n-1) k}\r\n','<br/>Тесты успешно пройдены!'),(5276,159,'5337814','2013-12-06 13:44:01',2,'--- Я похоже недостаточно четко сформулировал условие. Но в этой задаче я вам попрошу не ипользовать toInt\r\n--- Надо просто вызвать число Черча (это же на самом деле фунцкция от двух параметров) с подходящими пераметрами, чтобы в результатае получился список из 1. Попробуйте пожалуйста, это просто. Ели неочень понятно, о чем речь, можете мне написать письмо, обсудим.\r\n{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	churchToList.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ntoInt f = f (1 +) 0\r\n\r\n\r\n\r\nchurchToList f = replicate (toInt f) 1\r\n\r\n\r\n\r\nt = churchToList (f x -> f(f(f x)))\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5274,101,'57304539','2013-12-05 23:15:26',1,'{-comment\r\n\r\n-}                                      \r\n\r\n\r\n\r\ndata Expr = Add Expr Expr | Mult Expr Expr | X | Num Integer deriving Show\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\nsimplify (Num n) = Num n\r\n\r\n\r\n\r\nsimplify (Mult ex (Num 0)) = Num 0\r\n\r\nsimplify (Mult (Num 0) ex) = Num 0\r\n\r\n\r\n\r\nsimplify (Mult ex1 ex2) = simplify\' (Mult (simplify ex1) (simplify ex2))\r\n\r\nsimplify (Add ex1 ex2) = simplify\' (Add (simplify ex1) (simplify ex2))\r\n\r\n\r\n\r\nsimplify\' X = X\r\n\r\nsimplify\' (Num n) = Num n\r\n\r\n\r\n\r\nsimplify\' (Mult ex (Num 0)) = Num 0\r\n\r\nsimplify\' (Mult (Num 0) ex) = Num 0\r\n\r\n\r\n\r\nsimplify\' (Mult e1 e2) = Mult e1 e2\r\n\r\nsimplify\' (Add e1 e2) = Add e1 e2\r\n   --- Просто как замечание, вместо этих правил (и первого) можно написать simpify\' e = e						\r\n','<br/>Тесты успешно пройдены!'),(5273,101,'57304539','2013-12-05 23:02:57',0,'{-comment\r\n\n-}                                      \r\n\n\r\n\ndata Expr = Add Expr Expr | Mult Expr Expr | X | Num Integer deriving Show\r\n\n\r\n\nsimplify X = X\r\n\nsimplify (Num n) = Num n\r\n\n\r\n\nsimplify (Mult X X) = Mult X X\r\n\nsimplify (Add X X) = Add X X\r\n\nsimplify (Mult (Num n1) (Num n2)) = Mult (Num n1) (Num n2)\r\n\nsimplify (Add (Num n1) (Num n2)) = Add (Num n1) (Num n2)\r\n\n\r\n\nsimplify (Mult ex (Num 0)) = Num 0\r\n\nsimplify (Mult (Num 0) ex) = Num 0\r\n\n\r\n\nsimplify (Mult ex1 ex2) = simplify (Mult (simplify ex1) (simplify ex2))\r\n\nsimplify (Add ex1 ex2) = simplify (Add (simplify ex1) (simplify ex2))\r\n\n                        \r\n\n						\n','Не удалось вычислить выражение \"simplify (Mult X (Mult X X))\", проверьте правильность синтаксиса'),(5272,101,'57304539','2013-12-05 22:57:42',0,'{-comment\r\n\n-}                                      \r\n\n\r\n\ndata Expr = Add Expr Expr | Mult Expr Expr | X | Num Integer deriving Show\r\n\n\r\n\nsimplify (X) = X\r\n\nsimplify (Num n) = Num n\r\n\n\r\n\nsimplify (Mult ex (Num 0)) = Num 0\r\n\nsimplify (Mult (Num 0) ex) = Num 0\r\n\n\r\n\nsimplify (Mult ex1 ex2) = simplify (Mult (simplify ex1) (simplify ex2))\r\n\nsimplify (Add ex1 ex2) = simplify (Add (simplify ex1) (simplify ex2))\r\n\n                        \r\n\n						\n','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(5271,97,'57304539','2013-12-05 22:33:26',1,'{-comment\r\n\r\n-}                                      \r\n\r\n\r\n\r\nmatchHeads [] str = False\r\n\r\nmatchHeads stack str = if head str == \']\' && head stack == \'[\' || head str == \')\' && head stack == \'(\' then True\r\n\r\n												       else False	             \r\n\r\n\r\n\r\ncheckBrackets [] = True\r\n\r\ncheckBrackets str = checkBrackets\' [] str\r\n\r\n\r\n\r\ncheckBrackets\' [] [] = True\r\n\r\ncheckBrackets\' _ [] = False\r\n\r\ncheckBrackets\' stack str = if head str == \'(\' || head str == \'[\' then checkBrackets\' ((head str):stack) (tail str)\r\n\r\n							         else if not (matchHeads stack str) then False\r\n\r\n							 	              			    else checkBrackets\' (tail stack) (tail str)							\r\n','<br/>Тесты успешно пройдены!'),(5269,97,'57304539','2013-12-05 22:18:13',0,'{-comment\r\n\n-}                                      \r\n\n\r\n\nmatchHeads stack str = if head str == \']\' && head stack == \'[\' || head str == \')\' && head stack == \'(\' then True\r\n\n												       else False	             \r\n\n\r\n\ncheckBrackets [] = True\r\n\ncheckBrackets str = checkBrackets\' ((head str):[]) (tail str)\r\n\n\r\n\ncheckBrackets\' [] [] = True\r\n\ncheckBrackets\' [] _ = False\r\n\ncheckBrackets\' _ [] = False\r\n\ncheckBrackets\' stack str = if head str == \'(\' || head str == \'[\' then checkBrackets\' ((head str):stack) (tail str)\r\n\n							         else if not (matchHeads stack str) then False\r\n\n							 	              			    else checkBrackets\' (tail stack) (tail str)							\n','Выражение имеет неправильное значение: checkBrackets [\'(\',\')\',\'[\',\']\']'),(5270,97,'57304539','2013-12-05 22:32:57',0,'','Не удалось вычислить выражение \"checkBrackets [\'(\',\'[\',\']\',\')\']\", проверьте правильность синтаксиса'),(5268,97,'517309','2013-12-05 17:34:13',3,'checkBrackets xs = check_Brackets xs []\r\ncheck_Brackets [] [] = True\r\ncheck_Brackets [] ys = False\r\ncheck_Brackets (x:xs) [] = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs [x]\r\n						   else False\r\ncheck_Brackets (x:xs) (y:ys) = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs ([x] ++ (y:ys))\r\n						   else if (((x == \')\') && (y /= \'(\'))||((x == \']\') && (y /= \'[\')))\r\n						   then False\r\n						   else check_Brackets xs ys','<br/>Тесты успешно пройдены!'),(5267,101,'5337814','2013-12-05 14:49:00',2,'--- Проблема в том, что Mult X (Mult X (Num 0)) надо упрощать два раза, а у вас упростится только внутреннее подвыражение\r\n{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	simplify.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Mult Expr Expr | Add Expr Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\nsimplify (Mult X X) = (Mult X X)\r\n\r\nsimplify (Add X X) = (Add X X)\r\n\r\nsimplify (Num a) = Num a\r\n\r\nsimplify (Mult _ (Num 0)) = (Num 0)\r\n\r\nsimplify (Mult (Num 0) _) = (Num 0)\r\n\r\nsimplify (Mult a b) = (simplify a) `Mult` (simplify b)\r\n\r\nsimplify (Add a b) = (simplify a) `Add` (simplify b)\r\n\r\n\r\n\r\nt = simplify (Mult X (Mult X (Num 0)))\r\n\r\nt1 = simplify (Add (Mult X (Num 0)) X)\r\n\r\nt2 = simplify (Mult X (Num 1))\r\n','Выражение имеет неправильное значение: simplify (Mult X (Mult X (Num 0)))'),(5266,101,'5337814','2013-12-05 14:43:47',0,'{-	\r\n\n	Bobrov Nikita 2013\r\n\n	simplify.hs\r\n\n-}	\r\n\n\r\n\ndata Expr = Num Integer | X | Mult Expr Expr | Add Expr Expr\r\n\n	deriving Show\r\n\n\r\n\nsimplify X = X\r\n\nsimplify (Mult X X) = (Mult X X)\r\n\nsimplify (Add X X) = (Add X X)\r\n\nsimplify (Num a) = Num a\r\n\nsimplify (Mult _ (Num 0)) = (Num 0)\r\n\nsimplify (Mult (Num 0) _) = (Num 0)\r\n\nsimplify (Mult a b) = (simplify a) `Mult` (simplify b)\r\n\nsimplify (Add a b) = (simplify a) `Add` (simplify b)\r\n\n\r\n\nt = simplify (Mult X (Mult X (Num 0)))\r\n\nt1 = simplify (Add (Mult X (Num 0)) X)\r\n\nt2 = simplify (Mult X (Num 1))\n','Выражение имеет неправильное значение: simplify (Mult X (Mult X (Num 0)))'),(5264,159,'517309','2013-12-04 08:46:07',0,'--- Не совсем так.Например, в примере из условия у вас получится [1,1,1,1], а не [1,1,1]\r\n--- Я просто забыл добавить тесты, поэтому у вас сообщалось, что тесты пройдены.\r\n--- Сейчас я добавить тест, а вы исправьте, пожалуйста.\r\nchirchToList n = n (++[1]) []\r\n','Не удалось вычислить выражение \"let ch3 f x= f (f (f x)) in churchToList ch3\", проверьте правильность синтаксиса'),(5265,159,'517309','2013-12-04 08:47:47',3,'churchToList n = n (1:) []\r\n','<br/>Тесты успешно пройдены!'),(5257,115,'6205237','2013-12-02 13:48:41',1,'\r\nfind cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs  = let\r\n\r\n		ys = ((find (<5) xs) : (find (>10) xs) : (find (/=7) xs) : [])\r\n\r\n	 in\r\n\r\n		if any (x -> x == []) ys  then []\r\n\r\n				else [sum(foldr (++) [] ys)]\r\n','<br/>Тесты успешно пройдены!'),(5258,97,'6205237','2013-12-02 14:31:17',1,' --- ОК, все правильно (у меня была ошибка в записи теста, поэтому выдавалось сообщение)\r\ncheckBrackets \"\" = True\r\ncheckBrackets [x] = False\r\n\r\ncheckBrackets str = check\' str []\r\n\r\n\r\n\r\npop (x:stack) = stack\r\n\r\n\r\n\r\ntop [] = \' \'\r\n\r\ntop stack = head stack\r\n\r\n\r\n\r\npush x stack = x : stack\r\n\r\n\r\n\r\nreverse\' \']\' = \'[\'\r\n\r\nreverse\' \'[\' = \'0\'\r\n\r\nreverse\' \')\' = \'(\'\r\n\r\nreverse\' \'(\' = \'0\'\r\n\r\n\r\n\r\ncheck\' \"\" stack = length stack == 0\r\n\r\ncheck\' (ch:str) stack =  if  ( top stack /= (reverse\' ch) ) then ( check\' str (push ch stack))\r\n\r\n				else ( check\' str (pop stack) )  \r\n','Не удалось вычислить выражение \"checkBrackets \"(]\"\", проверьте правильность синтаксиса'),(5259,158,'6205237','2013-12-02 15:12:39',1,'\r\nf n = pr [1..n]\r\n\r\n\r\n\r\nprRow [] = do\r\n\r\n		putChar \'\r\n\'\r\n\r\nprRow (x:xs) = do 			 \r\n\r\n			putChar \'*\'\r\n\r\n		  	prRow xs\r\n\r\n\r\n\r\npr [x] = prRow [1..x]\r\n\r\npr (x:xs) = do\r\n\r\n		prRow [1..(last xs)]\r\n\r\n		pr xs\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(5260,159,'6205237','2013-12-02 15:25:51',2,'--- Не совсем так.Например, в примере из условия у вас получится [1,1,1,1], а не [1,1,1]\r\n--- Я просто забыл добавить тесты, поэтому у вас сообщалось, что тесты пройдены.\r\n--- Сейчас я добавить тест, а вы исправьте, пожалуйста.\r\nchirchToList n = n (++[1]) [1]\r\n','<br/>Тесты успешно пройдены!'),(5261,159,'SMakarov','2013-12-03 01:29:33',1,'churchToList g = g ([1]++) []','<br/>Тесты успешно пройдены!'),(5262,159,'517309','2013-12-04 08:37:35',0,'chirchToList n = n (++[1]) [1]','Не удалось вычислить выражение \"let ch3 f x= f (f (f x)) in churchToList ch3\", проверьте правильность синтаксиса'),(5263,159,'517309','2013-12-04 08:38:55',0,'churchToList _ = [1,1,1] ','<br/>Тесты успешно пройдены!'),(5255,124,'6205237','2013-12-02 11:38:40',1,'\r\ndownUp n = let \r\n\r\n		xs = [1..n] ++ (reverse [1..(n-1)])\r\n\r\n	   in\r\n\r\n		pr xs\r\n\r\n\r\n\r\npr [x] = print x\r\n\r\npr (x:xs) = do \r\n\r\n		print x\r\n\r\n    		pr xs \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5256,111,'6205237','2013-12-02 12:53:45',1,'import Data.List  \r\n\r\n\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\r\n		deriving Show\r\n\r\n\r\n\r\neval (Num i)  _ = i\r\n\r\neval (Var i) xs = z ( find (x -> (fst x) == i) xs )	\r\n\r\neval (Add a b) xs = eval a xs + eval b xs\r\n\r\neval (Mult a b) xs = eval a xs * eval b xs\r\n\r\n\r\n\r\nz (Just x) =  snd x\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5253,115,'SMakarov','2013-12-02 04:23:28',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\nf xs = if a /= [] && b /= [] && c /= [] then [head(a) + head(b) + head(c)] else [] \r\n	where \r\n		a = find (<5) xs \r\n		b = find (>10) xs\r\n		c = find (/=7) xs','<br/>Тесты успешно пройдены!'),(5254,124,'SMakarov','2013-12-02 04:32:01',1,'pr 0 n = pr1 2 n\r\npr k n = do\r\n	print k\r\n	pr (k-1) n\r\npr1 k n = if k == n then print n else do\r\n	print k\r\n	pr1 (k+1) n\r\ndownUp n = pr n n','<br/>Тесты успешно пройдены!'),(5252,111,'7475152','2013-12-02 02:56:39',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\nfind c [] = 0\r\nfind c (x:xs) = if fst(x) == c then snd(x) else find c xs\r\neval (Var c) xs = find c xs\r\neval (Num i) xs = i\r\neval (Add e1 e2) xs = (eval e1 xs) + (eval e2 xs)\r\neval (Mult e1 e2) xs = (eval e1 xs) * (eval e2 xs)','<br/>Тесты успешно пройдены!'),(5251,85,'7475152','2013-12-02 02:54:55',1,'data Ration = Rat Integer Integer \r\n              deriving (Show,Eq)\r\n  --- Тут не надо писать deriving. derining означает, что вы хотите чтобы Хаскелл как-то сам определил\r\n    эти методы, вывод стандартный а сравнение поэлементное. Но для Ration ни то ни другое не подходит\r\ninstance Num Ration where \r\n(Rat x1 y1) + (Rat x2 y2) = (Rat (x1*abs(y2)*signum(y1) + x2*abs(y1)*signum(y2)) (abs(y1*y2)))\r\n   --- Справа скобки расставлены неправильно, надо ... = Rat (x1*abs y2 *signum y1  + x2*abs y1 *signum y2) abs(y1*y2)\r\n\r\ninstance Ord Ration where\r\n(Rat x1 y1) < (Rat x2 y2) = x1*abs(y2)*signum(y1) < x2*abs(y1)*signum(y2)\r\n   --- И еще надо определить == в Eq\r\ninstance Show Ration where\r\nshow (Rat x1 y1) = show (x1) ++ \"/\" ++ show(y1)','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5249,85,'7475152','2013-12-02 02:52:29',0,'data Ration = Rat Integer Integer \r\nderiving Eq\r\ninstance Num Ration where \r\n(Rat x1 y1) + (Rat x2 y2) = (Rat (x1*abs(y2)*signum(y1) + x2*abs(y1)*signum(y2)) (abs(y1*y2)))\r\ninstance Ord Ration where\r\n(Rat x1 y1) < (Rat x2 y2) = x1*abs(y2)*signum(y1) < x2*abs(y1)*signum(y2)\r\ninstance Show Ration where\r\nshow (Rat x1 y1) = show (x1) ++ \"/\" ++ show(y1)','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5250,85,'7475152','2013-12-02 02:52:47',0,'data Ration = Rat Integer Integer \r\nderiving Eq\r\ninstance Num Ration where \r\n(Rat x1 y1) + (Rat x2 y2) = (Rat (x1*abs(y2)*signum(y1) + x2*abs(y1)*signum(y2)) (abs(y1*y2)))\r\ninstance Ord Ration where\r\n(Rat x1 y1) < (Rat x2 y2) = x1*abs(y2)*signum(y1) < x2*abs(y1)*signum(y2)\r\ninstance Show Ration where\r\nshow (Rat x1 y1) = show (x1) ++ \"/\" ++ show(y1)','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5248,115,'shkuratov.ilya','2013-12-02 01:57:40',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n	\r\n\r\nf xs = zipWith3 (x y z -> x + y + z) (find (<5) xs) (find (>10) xs) (find (/=7) xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5246,111,'SMakarov','2013-12-02 01:32:54',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\nfind c [] = 0\r\nfind c (x:xs) = if fst(x) == c then snd(x) else find c xs\r\neval (Var c) xs = find c xs\r\neval (Num i) xs = i\r\neval (Add e1 e2) xs = (eval e1 xs) + (eval e2 xs)\r\neval (Mult e1 e2) xs = (eval e1 xs) * (eval e2 xs)','<br/>Тесты успешно пройдены!'),(5247,115,'shkuratov.ilya','2013-12-02 01:57:05',0,'find cond [] = []\r\n\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\n	\r\n\ntest xs = zipWith3 (x y z -> x + y + z) (find (<5) xs) (find (>10) xs) (find (/=7) xs)\r\n\n\n','Не удалось вычислить выражение \"f [7, 6, 4, 3, 20, 15, 9] \", проверьте правильность синтаксиса'),(5245,85,'SMakarov','2013-12-02 01:01:56',1,'data Ration = Rat Integer Integer deriving Eq\r\ninstance Num Ration where \r\n						(Rat x1 y1) + (Rat x2 y2) = (Rat (signum(y1)*x1*abs(y2) + signum(y2)*x2*abs(y1)) (abs(y1*y2)))\r\ninstance Ord Ration where\r\n						(Rat x1 y1) < (Rat x2 y2) = signum(y1)*x1*abs(y2) < signum(y2)*x2*abs(y1)\r\ninstance Show Ration where\r\n						show (Rat x1 y1) = show (x1) ++ \"/\" ++ show(y1)','<br/>Тесты успешно пройдены!'),(5234,116,'SMakarov','2013-12-02 00:03:25',1,'toInt g = g (1+) 0','<br/>Тесты успешно пройдены!'),(5235,116,'7475152','2013-12-02 00:06:01',1,'toInt n = n (1+) 0','<br/>Тесты успешно пройдены!'),(5236,117,'SMakarov','2013-12-02 00:10:51',0,'inc g f q = g f (f q)','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(5237,115,'shkuratov.ilya','2013-12-02 00:11:54',0,'find cond [] = []\r\n\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\n\r\n\nf xs = \r\n\n	if (length res) == 3\r\n\n	then return (sum res)\r\n\n	else []\r\n\n	where res = (find (<5) xs) ++ (find (>10) xs) ++ (find (/=7) xs)\r\n\n\n','<br/>Тесты успешно пройдены!'),(5238,117,'SMakarov','2013-12-02 00:12:53',1,'inc g f q = g f (f q)\r\ntoInt n = n (1+) 0','<br/>Тесты успешно пройдены!'),(5239,117,'7475152','2013-12-02 00:21:22',0,'toInt n = n (1+) 0\r\ninc g f x = g f (f x)','<br/>Тесты успешно пройдены!'),(5240,159,'7475152','2013-12-02 00:24:20',1,'churchToList n = n (++[1]) []','<br/>Тесты успешно пройдены!'),(5241,117,'7475152','2013-12-02 00:24:50',1,'--- Не совсем так. Во-первых справа не хватает скобок, во вторых x нигде не используется.\r\n--- Но ОК, у нас т не совсем правильные задачи засчитываются, т.е. засчитано \r\ninc g f x = g f.f ','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(5242,85,'SMakarov','2013-12-02 00:45:58',0,'data Ration = Rat Integer Integer deriving Eq\r\ninstance Num Ration where \r\n						(Rat x1 y1) + (Rat x2 y2) = (Rat (x1*y2 + x2*y1) (y1*y2))\r\ninstance Ord Ration where\r\n						(Rat x1 y1) < (Rat x2 y2) = x1*y2 < x2*y1\r\ninstance Show Ration where\r\n						show (Rat x1 y1) = show (x1) ++ \"/\" ++ show(y1)','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(5243,85,'SMakarov','2013-12-02 00:50:22',0,'data Ration = Rat Integer Integer deriving Eq\r\ninstance Num Ration where \r\n						(Rat x1 y1) + (Rat x2 y2) = (Rat (signum(y1)*x1*y2 + signum(y2)*x2*y1) (y1*y2))\r\ninstance Ord Ration where\r\n						(Rat x1 y1) < (Rat x2 y2) = signum(y1)*x1*y2 < signum(y2)*x2*y1\r\ninstance Show Ration where\r\n						show (Rat x1 y1) = show (x1) ++ \"/\" ++ show(y1)','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(5244,85,'SMakarov','2013-12-02 00:59:22',0,'data Ration = Rat Integer Integer deriving Eq\r\ninstance Num Ration where \r\n						(Rat x1 y1) + (Rat x2 y2) = (Rat (signum(y1)*signum(y2)*x1*y2 + signum(y1)*signum(y2)*x2*y1) (abs(y1*y2)))\r\ninstance Ord Ration where\r\n						(Rat x1 y1) < (Rat x2 y2) = x1*y2 < x2*y1\r\ninstance Show Ration where\r\n						show (Rat x1 y1) = show (x1) ++ \"/\" ++ show(y1)','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(5232,117,'21743638','2013-12-01 23:07:09',1,'inc a = f x -> f(a f x)\r\n\r\ntoInt (g@inc) = g (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(5233,85,'57304539','2013-12-01 23:29:20',1,'{-comment\r\n\r\n-}                                                    \r\n\r\n\r\n\r\ndata Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where		\r\n\r\n	(Rat a b) + (Rat c d) = (Rat (a*d + c*b) (b*d))\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat a b) = show a ++ \"/\" ++ show b\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat a b) == (Rat c d) = a == c && b == d	\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat a b) < (Rat c d) = a*(div (lcm b d) c) < c*(div (lcm b d) a)\r\n','<br/>Тесты успешно пройдены!'),(5231,85,'3598995','2013-12-01 22:18:48',1,'--почему-то не получается(((\r\n--- У вас просто отступы неправильно стоят. Я добавил их (см ниже) и все работает\r\ndata Ration= Rat {\r\n  a :: Integer,\r\n  b :: Integer\r\n  }\r\ninstance Num Ration where\r\n  (Rat a b) + (Rat c d) = Rat ((a * d) + (c * b)) (b * d)\r\ninstance Eq Ration where\r\n  (Rat a b) == (Rat c d) |(a * d) == (c * b) = True\r\n    |otherwise = False\r\ninstance Ord Ration where\r\n  (Rat a b) > (Rat c d) |(a*d)>(c*b) = True\r\n    |otherwise = False\r\ninstance Show Ration where\r\n  show (Rat a b) = (show a) ++ \"/\" ++ (show b)','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5230,85,'3598995','2013-12-01 22:17:51',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\nshow (Rat a b) = (show a) ++ \"/\" ++ (show b)\r\n\r\ninstance Num Ration where\r\n(Rat a b) + (Rat c d) = Rat ((a * d) + (c * b)) (b * d)\r\n\r\ninstance Eq Ration where\r\n(Rat a b) == (Rat c d)\r\n		| (a * d) == (b * c) = True\r\n		| otherwise = False\r\n\r\ninstance Ord Ration where\r\n(Rat a b) < (Rat c d)\r\n		| (a * d) < (b * c) = True\r\n		| otherwise = False','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5229,85,'3598995','2013-12-01 22:17:02',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Show Ration where\r\nshow (Rat a b) = (show a) ++ \"/\" ++ (show b)\r\n\r\ninstance Num Ration where\r\n(Rat a b) + (Rat c d) = Rat ((a * d) + (c * b)) (b * d)\r\n\r\ninstance Eq Ration where\r\n(Rat a b) == (Rat c d)\r\n| (a * d) == (b * c) = True\r\n| otherwise = False\r\n\r\ninstance Ord Ration where\r\n(Rat a b) < (Rat c d)\r\n| (a * d) < (b * c) = True\r\n| otherwise = False','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5228,85,'3598995','2013-12-01 22:14:32',0,'data Ration= Rat {\r\na :: Integer,\r\nb :: Integer\r\n}\r\ninstance Num Ration where\r\n(Rat a b) + (Rat c d) = Rat ((a * d) + (c * b)) (b * d)\r\ninstance Eq Ration where\r\n(Rat a b) == (Rat c d) |(a * d) == (c * b) = True\r\n		       |otherwise = False\r\ninstance Ord Ration where\r\n(Rat a b) > (Rat c d) |(a*d)>(c*b) = True\r\n		      |otherwise = False\r\ninstance Show Ration where\r\nshow (Rat a b) = (show a) ++ \"/\" ++ (show b)','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5227,85,'3598995','2013-12-01 22:10:54',0,'data Rat = Rat {\r\na :: Integer,\r\nb :: Integer\r\n}\r\ninstance Num Rat where\r\n(Rat a b) + (Rat c d) = Rat ((a * d) + (c * b)) (b * d)\r\ninstance Eq Rat where\r\n(Rat a b) == (Rat c d) |(a * d) == (c * b) = True\r\n		       |otherwise = False\r\ninstance Ord Rat where\r\n(Rat a b) > (Rat c d) |(a*d)>(c*b) = True\r\n		      |otherwise = False\r\ninstance Show Rat where\r\nshow (Rat a b) = (show a) ++ \"/\" ++ (show b)','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(5226,159,'21743638','2013-12-01 22:02:57',1,'churchToList f = f (1:) []\r\n','<br/>Тесты успешно пройдены!'),(5224,116,'5337814','2013-12-01 20:24:47',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	toInt.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ntoInt f = f (+ 1) 0\r\n\r\n\r\n\r\nt = toInt (f x -> f(f(f x)))\r\n','<br/>Тесты успешно пройдены!'),(5225,117,'5337814','2013-12-01 20:25:04',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	inc.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ntoInt f = f (+ 1) 0\r\n\r\ninc f = (g x -> (g (f g x)))\r\n\r\n\r\n\r\nt = toInt (inc ( f x -> f (f (f x))))\r\n','<br/>Тесты успешно пройдены!'),(5222,116,'3598995','2013-12-01 19:39:16',1,'toInt g = g (+1) 0','<br/>Тесты успешно пройдены!'),(5223,85,'5337814','2013-12-01 20:23:45',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	ration.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat a b) = (show a) ++ \"/\" ++ (show b)\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat a b) + (Rat c d) = Rat ((a * d) + (c * b)) (b * d)\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat a b) == (Rat c d)\r\n\r\n		| (a * d) == (b * c) = True\r\n\r\n		| otherwise = False\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat a b) < (Rat c d)\r\n\r\n		| (a * d) < (b * c) = True\r\n\r\n		| otherwise = False\r\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(5221,159,'3598995','2013-12-01 19:38:58',2,' --- Это правильно, но, можно сказать, не совсем честно, потому что вы переводите\r\n --- число Черча в обычное, а дальше уже работаете с обычным.\r\n --- Дававйте я вас попрошу решить эту задачу не используя обычные числа (кроме 1, конесно:)\r\n --- Идея тут как в toInt. Поскольку число черча - это машинка, которая повторяет какое-то\r\n --- действие данное количество раз, то нам надо просто придумать, какое жействие надо пвторить\r\n --- n раз, чтобы получить список из n единиц. И это несложно.\r\n --- Попробуйте так решить задачу, пожалуйста. \r\nones = 1:ones\r\ntoInt g = g (+1) 0\r\nchurchToList g = take (toInt g) ones','<br/>Тесты успешно пройдены!'),(5219,116,'21743638','2013-12-01 19:30:49',1,'toInt f = f (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(5220,116,'3598995','2013-12-01 19:38:49',0,'ones = 1:ones\r\ntoInt g = g (+1) 0\r\nchurchToList g = take (toInt g) ones','<br/>Тесты успешно пройдены!'),(5218,124,'7475152','2013-12-01 18:09:41',1,'pr 1 = print 1	     \r\npr n  = do \r\n	 print n\r\n         pr (n-1)\r\n	\r\npr1 k n = if (k/=n) then do print k\r\n			    pr1 (k+1) n\r\n	  else print k	\r\n	\r\ndownUp n = if (n==1) then pr n\r\n	   else do pr n\r\n		   pr1 2 n 	','<br/>Тесты успешно пройдены!'),(5217,115,'21743638','2013-12-01 16:21:08',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let {a = find (<5) xs; b = find (>10) xs; c = find (/=7) xs}\r\n\r\n	in if (a ==[] || b == [] || c==[]) then [] else [head a + head b +head c]\r\n','<br/>Тесты успешно пройдены!'),(5216,85,'21743638','2013-12-01 15:55:07',1,'data Ration = Rat Integer Integer deriving Eq\r\n\r\n\r\n\r\ninstance Num Ration where \r\n\r\n	(Rat n1 d1) + (Rat n2 d2) = let \r\n\r\n		de1 = abs d1\r\n\r\n		de2 = abs d2\r\n\r\n		nu1 = if d1<0 then n1*(-1) else n1\r\n\r\n		nu2 = if d2<0 then n2*(-1) else n2\r\n\r\n		in if de1==de2 then Rat (nu1+nu2) de1 else Rat (nu1*de2+nu2*de1) (de1*de2)\r\n\r\n\r\n\r\ninstance Ord Ration where \r\n\r\n	(Rat n1 d1) < (Rat n2 d2) = let\r\n\r\n		de1 = abs d1\r\n\r\n		de2 = abs d2\r\n\r\n		nu1 = if d1<0 then n1*(-1) else n1\r\n\r\n		nu2 = if d2<0 then n2*(-1) else n2\r\n\r\n		in if de1==de2 then nu1<nu2 else (nu1*abs de2)<(nu2*abs de1)\r\n\r\n\r\n\r\ninstance Show Ration where show (Rat n d) = show n ++ \"/\" ++ show d\r\n','<br/>Тесты успешно пройдены!'),(5215,85,'21743638','2013-12-01 15:23:35',0,'data Ration = Rat Integer Integer deriving Eq\r\n\n\r\n\ninstance Num Ration where (Rat n1 d1) + (Rat n2 d2) = if d1==d2 then Rat (n1+n2) d1 else Rat (n1*d2+n2*d1) (d1*d2)\r\n\n\r\n\ninstance Ord Ration where (Rat n1 d1) < (Rat n2 d2) = if d1==d2 then n1<n2 else (n1*d2)<(n2*d1)\r\n\n\r\n\ninstance Show Ration where show (Rat n d) = show n ++ \"/\" ++ show d\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(5214,115,'3598995','2013-12-01 14:51:50',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\nf xs\r\n    |(length a == 3) = return (sum a)\r\n    |otherwise = []\r\n    where a = find (<5) xs ++ find (>10) xs ++ find (/=7) xs ','<br/>Тесты успешно пройдены!'),(5212,115,'7475152','2013-11-30 19:35:13',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = let a = (find (<5) xs)++(find (>10) xs)++(find (/=7) xs)\r\n       in if (length a)<3 then []\r\n	  else  [sum a] ','<br/>Тесты успешно пройдены!'),(5213,97,'3598995','2013-12-01 13:25:52',1,'--переделала, забыла прошлый раз для y/=\']\' условие поставить.\r\n  --- ОК, очень хорошо, все правильно (а у меня был тест неправильный)\r\ncheckBrackets xs = check_Brackets xs []\r\ncheck_Brackets [] [] = True\r\ncheck_Brackets [] ys = False\r\ncheck_Brackets (x:xs) [] = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs [x]\r\n						   else False\r\ncheck_Brackets (x:xs) (y:ys) = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs ([x] ++ (y:ys))\r\n						   else if (((x == \')\') && (y /= \'(\'))||((x == \']\') && (y /= \'[\')))\r\n						   then False\r\n						   else check_Brackets xs ys','Не удалось вычислить выражение \"checkBrackets \"(]\"\", проверьте правильность синтаксиса'),(5211,155,'SMakarov','2013-11-30 01:00:09',1,'digits m n = (10*m `div` n): digits (10*m `mod` n) n','<br/>Тесты успешно пройдены!'),(5207,124,'shkuratov.ilya','2013-11-29 17:52:13',1,'prDownUp 1 = print 1\r\n\r\nprDownUp n = do\r\n\r\n	print n\r\n\r\n	prDownUp (n - 1)\r\n\r\n	print n\r\n','<br/>Тесты успешно пройдены!'),(5208,116,'shkuratov.ilya','2013-11-29 18:01:34',1,'toInt f = f (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(5209,117,'shkuratov.ilya','2013-11-29 18:34:23',1,'toInt f = f (+1) 0\r\n\r\ninc t f x = f (t f x) \r\n','<br/>Тесты успешно пройдены!'),(5210,155,'3598995','2013-11-29 21:24:40',1,'digits 0 0 = []\r\ndigits m n\r\n	  |m<n = [(m*10 `div` n)]++(digits (m*10 `mod` n) n)','<br/>Тесты успешно пройдены!'),(5204,85,'shkuratov.ilya','2013-11-29 15:46:04',0,'data Ration = Rat Integer Integer\r\n\n\r\n\nmultipliers d1 d2 = \r\n\n	let\r\n\n	n = gcd d1 d2\r\n\n	in (div d2 n, div d1 n)	\r\n\n\r\n\ninstance Eq Ration where\r\n\n	(Rat n1 d1) == (Rat n2 d2) = \r\n\n		if d1 == d2\r\n\n		then n1 == n2\r\n\n		else n1 * d2 == n2 * d1\r\n\n\r\n\ninstance Num Ration where\r\n\n	(Rat n1 d1) + (Rat n2 d2) = \r\n\n		if d1 == d2\r\n\n		then (Rat (n1 + n2) d1)\r\n\n		else let\r\n\n		(m1, m2) = multipliers d1 d2\r\n\n		in (Rat (n1 * m1 + n2 * m2) (d1 * m1))\r\n\n\r\n\ninstance Ord Ration where\r\n\n	(Rat n1 d1) < (Rat n2 d2) = \r\n\n		let\r\n\n		(m1, m2) = multipliers d1 d2\r\n\n		in n1 * m1 < n2 * m2\r\n\n\r\n\ninstance Show Ration where\r\n\n	show (Rat n d) = (show n) ++ \"/\" ++ (show d)\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(5205,85,'shkuratov.ilya','2013-11-29 16:43:17',1,'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\nmultipliers d1 d2 = \r\n\r\n	let\r\n\r\n	n = gcd d1 d2\r\n\r\n	m1 = (div (abs d2) n) * (signum d1)\r\n\r\n	m2 = (div (abs d1) n) * (signum d2)\r\n\r\n	in (m1, m2)	\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat n1 d1) == (Rat n2 d2) = \r\n\r\n		if d1 == d2\r\n\r\n		then n1 == n2\r\n\r\n		else n1 * d2 == n2 * d1\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat n1 d1) + (Rat n2 d2) = \r\n\r\n		if d1 == d2\r\n\r\n		then (Rat (n1 + n2) d1)\r\n\r\n		else let\r\n\r\n		(m1, m2) = multipliers d1 d2\r\n\r\n		in (Rat (n1 * m1 + n2 * m2) (d1 * m1))\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat n1 d1) < (Rat n2 d2) = \r\n\r\n		let\r\n\r\n		(m1, m2) = multipliers d1 d2\r\n\r\n		in n1 * m1 < n2 * m2\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat n d) = (show n) ++ \"/\" ++ (show d)\r\n','<br/>Тесты успешно пройдены!'),(5206,111,'shkuratov.ilya','2013-11-29 17:36:36',1,'data Expr = Num Integer | Var String | \r\n\r\n	Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving Show\r\n\r\n\r\n\r\ntakeArg _ [] = 0\r\n\r\ntakeArg arg ((s, v):xs) = \r\n\r\n	if arg == s\r\n\r\n	then v\r\n\r\n	else takeArg arg xs\r\n\r\n\r\n\r\neval (Var arg) xs = takeArg arg xs\r\n\r\neval (Num const) _ = const\r\n\r\neval (Add a b) xs = (eval a xs) + (eval b xs)\r\n\r\neval (Mult a b) xs = (eval a xs) * (eval b xs)\r\n','<br/>Тесты успешно пройдены!'),(5203,155,'shkuratov.ilya','2013-11-29 14:46:48',1,'digits m n = digitsList n m\r\n\r\n\r\n\r\ndigitsList n rest = \r\n\r\n\r\n\r\n	let\r\n\r\n\r\n\r\n	x = rest * 10\r\n\r\n\r\n\r\n	y = div x n\r\n\r\n\r\n\r\n	in y : digitsList n (mod x n)\r\n','<br/>Тесты успешно пройдены!'),(5201,89,'25446179','2013-11-29 02:44:29',1,'data Tree = Empty| Node Integer Tree Tree\r\nflatten(Node val l r) = [val] ++ flatten l ++ flatten r\r\nflatten(Node val l _)= [val] ++ flatten l\r\nflatten(Node val _ r) = [val] ++ flatten r\r\nflatten Empty = []','<br/>Тесты успешно пройдены!'),(5202,158,'7475152','2013-11-29 13:24:35',1,'--Программа все таки должна выводить \"рамочку\" из символов \'*\' или же то,что описано в примере?\r\n   --- То, что в примере - сейчас исправлю.\r\n   --- Но ОК, ваше решение конечно засчитано\r\ndoFrame n = do\r\n              i<-[1..n]\r\n	      j<-[1..n+1]\r\n              if (j==n+1) then return \'\r\n\' \r\n	      else if (i==1 || i==n || j==1 || j==n) then return \'*\'\r\n	           else return \' \'\r\nshowFrame n = sequence_ (map putChar (doFrame n))','<br/>Тесты успешно пройдены!'),(5200,97,'5337814','2013-11-28 20:46:02',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	checkBrackets1.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Stack = Stack [Char]\r\n\r\n\r\n\r\npush x (Stack xs) = Stack (x:xs)\r\n\r\n\r\n\r\npop (Stack (x:xs)) = Stack xs\r\n\r\ntop (Stack (x:xs)) = x\r\n\r\n\r\n\r\nisEmpty (Stack []) = True\r\n\r\nisEmpty (Stack _) = False\r\n\r\n\r\n\r\ncheckBrackets \"\" = True\r\n\r\ncheckBrackets s = checkBrackets\' s (Stack [])\r\n\r\n\r\n\r\ncheckBrackets\' [] stk = isEmpty stk\r\n\r\ncheckBrackets\' (c:cs) stk\r\n\r\n	|(c == \'(\') || (c == \'[\') = checkBrackets\' cs (push c stk)\r\n\r\n	|(c == \')\') = if (isEmpty stk) || (top stk == \'[\') then False else (checkBrackets\' cs (pop stk))\r\n\r\n	|(c == \']\') = if (isEmpty stk) || (top stk == \'(\') then False else (checkBrackets\' cs (pop stk))\r\n\r\n\r\n\r\n\r\n\r\ntest = checkBrackets \"[()[]]()\"\r\n\r\n\r\n\r\nt = checkBrackets \"([)]\"\r\n\r\nt1 = checkBrackets \"())[]\"\r\n\r\nt2 = checkBrackets \"(]\"\r\n\r\n\r\n','Не удалось вычислить выражение \"checkBrackets \"(]\"\", проверьте правильность синтаксиса'),(5199,101,'5337814','2013-11-28 20:45:18',2,'--- Вот на таком тесте у вас циклится: simplify (Mult X (Mult X X))\r\n--- Исправьте пожалуйста (а я сейчас добавлю тест)\r\n\r\n{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	simplify.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Mult Expr Expr | Add Expr Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\nsimplify (Mult X X) = (Mult X X)\r\n\r\nsimplify (Add X X) = (Add X X)\r\n\r\nsimplify (Mult _ (Num 0)) = (Num 0)\r\n\r\nsimplify (Mult (Num 0) _) = (Num 0)\r\n\r\nsimplify (Mult a b) = simplify (Mult (simplify a) (simplify b))\r\n\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\n\r\n\r\n\r\nt = simplify (Mult X (Mult X (Num 0)))\r\n\r\nt1 = simplify (Add (Mult X (Num 0)) X)\r\n\r\nt2 = simplify (Mult X X)\r\n','<br/>Тесты успешно пройдены!'),(5198,97,'5337814','2013-11-28 20:39:59',0,'{-	\r\n\n	Bobrov Nikita 2013\r\n\n	checkBrackets1.hs\r\n\n-}	\r\n\n\r\n\ndata Stack = Stack [Char]\r\n\n\r\n\npush x (Stack xs) = Stack (x:xs)\r\n\n\r\n\npop (Stack (x:xs)) = Stack xs\r\n\ntop (Stack (x:xs)) = x\r\n\n\r\n\nisEmpty (Stack []) = True\r\n\nisEmpty (Stack _) = False\r\n\n\r\n\ncheckBrackets \"\" = True\r\n\ncheckBrackets s = checkBrackets\' s (Stack [])\r\n\n\r\n\ncheckBrackets\' [] stk = isEmpty stk\r\n\ncheckBrackets\' (c:cs) stk\r\n\n	|(c == \'(\') || (c == \'[\') = checkBrackets\' cs (push c stk)\r\n\n	|(c == \')\') = if (isEmpty stk) || (top stk == \'[\') then False else (checkBrackets\' cs (pop stk))\r\n\n	|(c == \']\') = if (isEmpty stk) || (top stk == \'(\') then False else (checkBrackets\' cs (pop stk))\r\n\n\r\n\n\r\n\ntest = checkBrackets \"[()[]]()\"\r\n\n\r\n\nt = checkBrackets \"([)]\"\r\n\nt1 = checkBrackets \"())[]\"\r\n\nt2 = checkBrackets \"([]\"\r\n\n\n','Не удалось вычислить выражение \"checkBrackets \"(]\"\", проверьте правильность синтаксиса'),(5197,101,'5337814','2013-11-28 20:39:00',0,'{-	\r\n\n	Bobrov Nikita 2013\r\n\n	simplify.hs\r\n\n-}	\r\n\n\r\n\ndata Expr = Num Integer | X | Mult Expr Expr | Add Expr Expr\r\n\n	deriving Show\r\n\n\r\n\nsimplify X = X\r\n\nsimplify (Mult _ (Num 0)) = (Num 0)\r\n\nsimplify (Mult (Num 0) _) = (Num 0)\r\n\nsimplify (Mult a b) = simplify (Mult (simplify a) (simplify b))\r\n\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\n\n\r\n\nt = simplify (Mult X (Mult X (Num 0)))\r\n\nt1 = simplify (Add (Mult X (Num 0)) X)\r\n\n\n','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(5196,155,'5337814','2013-11-28 15:14:00',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	digits1.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndigits m n = r : digits q n\r\n\r\n				where\r\n\r\n					r = (m * 10) `div` n\r\n\r\n					q = (m * 10) `mod` n\r\n\r\n					\r\n\r\n\r\n\r\nt = take 25 (digits 2 7)\r\n','<br/>Тесты успешно пройдены!'),(5195,155,'5337814','2013-11-28 15:13:57',0,'{-	\r\n\n	Bobrov Nikita 2013\r\n\n	digits1.hs\r\n\n-}	\r\n\n\r\n\ndigits m n = r : digits q n\r\n\n				where\r\n\n					r = (m * 10) `div` n\r\n\n					q = (m * 10) `mod` n\r\n\n					\r\n\n\r\n\nt = take 25 (digits 2 7)\n','<br/>Тесты успешно пройдены!'),(5190,124,'21743638','2013-11-28 00:03:32',1,'downUp 1 = print 1\r\n\r\ndownUp n = do {print n; downUp (n-1); print n}\r\n','<br/>Тесты успешно пройдены!'),(5191,111,'21743638','2013-11-28 00:59:46',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\r\neval (Num n) xs = n\r\n\r\neval (Var s) xs = head (xs >>= x -> if fst x == s then [snd x] else [])\r\n\r\neval (Add l r) xs = eval l xs + eval r xs\r\n\r\neval (Mult l r) xs = eval l xs * eval r xs\r\n','<br/>Тесты успешно пройдены!'),(5192,154,'7475152','2013-11-28 12:05:35',1,'checkBrackets1 [] ys = length ys==0 \r\ncheckBrackets1 (x:xs) ys = if (x==\'(\') then checkBrackets1 xs (x:ys) \r\n			else if (length ys == 0) then False\r\n			     else let a = tail ys \r\n                                  in if (length a==0)\r\n				     then checkBrackets1 xs []\r\n				     else checkBrackets1 xs a\r\n					  	 \r\ncheckBrackets xs = checkBrackets1 xs [] ','<br/>Тесты успешно пройдены!'),(5193,89,'5337814','2013-11-28 15:12:51',0,'{-	\r\n\n	Bobrov Nikita 2013\r\n\n	flatten.hs\r\n\n-}	\r\n\n\r\n\ndata Tree = Node Integer Tree Tree | Empty\r\n\n\r\n\n---flatten Empty = []\r\n\n---flatten (Node val l r) = val : flatten l ++ flatten r\r\n\n\r\n\nflatten (Node val l r) = \r\n\n	flatten1 (Node val l r) []\r\n\n		where \r\n\n			flatten1 Empty xs = xs\r\n\n			flatten1 (Node val l r) xs = val : flatten1 l (flatten1 r xs)\r\n\n\r\n\nt = flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\n\n','Не удалось вычислить выражение \"flatten Empty\", проверьте правильность синтаксиса'),(5194,89,'5337814','2013-11-28 15:13:37',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	flatten.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\n---flatten Empty = []\r\n\r\n---flatten (Node val l r) = val : flatten l ++ flatten r\r\n\r\n\r\n\r\nflatten Empty = []\r\n\r\nflatten (Node val l r) = \r\n\r\n	flatten1 (Node val l r) []\r\n\r\n		where \r\n\r\n			flatten1 Empty xs = xs\r\n\r\n			flatten1 (Node val l r) xs = val : flatten1 l (flatten1 r xs)\r\n\r\n\r\n\r\nt = flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5189,89,'SMakarov','2013-11-27 13:38:53',1,'data Tree = Empty | Node Integer Tree Tree\r\nflatten (Empty) = []\r\nflatten (Node x Empty Empty) = [x]\r\nflatten (Node x l Empty) = (flatten l) ++ [x]\r\nflatten (Node x Empty r) = (x:(flatten r))\r\nflatten (Node x l r) = (x:(flatten l)) ++ (flatten r)','<br/>Тесты успешно пройдены!'),(5188,154,'SMakarov','2013-11-27 00:51:43',1,'f [] n = if n == 0 then True else False\r\n   --- Ну или просто ... = n == 0\r\nf (x:xs) n = if n < 0 then False else if x == \'(\' then f xs (n+1) else f xs (n-1)\r\ncheckBrackets xs = f xs 0','<br/>Тесты успешно пройдены!'),(5185,88,'shkuratov.ilya','2013-11-25 22:15:49',2,'data Expr = Num Integer | X | \r\n\r\n	Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving Show\r\n\r\n	\r\n\r\ndiff (Num _) = Num 0\r\n\r\ndiff (X) = Num 1\r\n\r\ndiff (Add a b) = Add (diff a) (diff b)\r\n\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n','<br/>Тесты успешно пройдены!'),(5186,102,'shkuratov.ilya','2013-11-25 22:27:31',2,'find f (x:xs) = if f x then Just x else find f xs\r\n\r\nfind _ [] = Nothing\r\n\r\n\r\n\r\nfindMajor xs = \r\n\r\n	let\r\n\r\n	all = sum(xs)\r\n\r\n	in find (x -> x > all - x) xs\r\n','<br/>Тесты успешно пройдены!'),(5187,89,'SMakarov','2013-11-27 00:31:25',1,'  --- Так у вас не будет работать для пустого дерева, а это же то же дерево.\r\n  --- Исправьте, пожалуйста (а я сейчас добавил такой тест)\r\ndata Tree = Empty | Node Integer Tree Tree\r\nflatten (Node x Empty Empty) = [x]\r\nflatten (Node x l Empty) = (flatten l) ++ [x]\r\nflatten (Node x Empty r) = (x:(flatten r))\r\nflatten (Node x l r) = (x:(flatten l)) ++ (flatten r)','<br/>Тесты успешно пройдены!'),(5184,88,'shkuratov.ilya','2013-11-25 22:15:09',0,'data Rect = Rect Double Double Double Double\n\ndata Circle = Circle Double Double Double\n\n\n\nclass Shape a where\n\n	contains:: a -> Double -> Double -> Bool\n\n\n\ninstance Shape Rect where\n\n	contains (Rect a b x y) x0 y0 = \n\n		(abs(x0 - x) <= a / 2) && (abs(y0 - y) <= b / 2)\n\n\n\ninstance Shape Circle where\n\n	contains (Circle r x y) x0 y0 = (x0 - x)^2 + (y0 - y)^2 <= r^2\n','Не удалось вычислить выражение \"diff (Mult X X)\", проверьте правильность синтаксиса'),(5183,87,'shkuratov.ilya','2013-11-25 22:09:24',2,'--- это правильно, но сильно позже срока (задачи к понедельнику нао присылать к началу пары)\r\n--- поэтому я вам 2 задачи засчитал, и три произвоьно взятые задачи не засчитал \r\n--- Вообще присылвйте задачи к понедельнику не позже 9:30, пожалуйста. в следующий раз могу вообще не засчитать \r\ndata Expr = Num Integer | X | \r\n\r\n	Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (X) x = x\r\n\r\neval (Num const) _ = const\r\n\r\neval (Add a b) x = (eval a x) + (eval b x)\r\n\r\neval (Mult a b) x = (eval a x) * (eval b x)\r\n','<br/>Тесты успешно пройдены!'),(5182,157,'shkuratov.ilya','2013-11-25 21:56:02',1,'triangle1 n = \r\n\r\n	[1..n] >>= i ->\r\n\r\n		[1..i] >>= j ->\r\n\r\n			return (j*j)\r\n\r\n\r\n\r\ntriangle2 n = \r\n\r\n	do \r\n\r\n	i <- [1..n]\r\n\r\n	j <- [1..i]\r\n\r\n	return (j*j)\r\n','<br/>Тесты успешно пройдены!'),(5181,156,'shkuratov.ilya','2013-11-25 21:40:01',1,'data Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	contains:: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n	contains (Rect a b x y) x0 y0 = \r\n\r\n		(abs(x0 - x) <= a / 2) && (abs(y0 - y) <= b / 2)\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	contains (Circle r x y) x0 y0 = (x0 - x)^2 + (y0 - y)^2 <= r^2\r\n','<br/>Тесты успешно пройдены!'),(5180,154,'3598995','2013-11-25 21:10:17',1,'checkBrackets xs = check_Brackets xs []\r\ncheck_Brackets [] [] = True\r\ncheck_Brackets [] ys = False\r\ncheck_Brackets (x:xs) [] = if (x == \'(\') then check_Brackets xs [x] else False\r\ncheck_Brackets (x:xs) (y:ys) = if (x == \'(\') then check_Brackets xs ([x] ++ (y:ys))\r\n						   else if (x == \')\') && (y /= \'(\')\r\n						   then False\r\n						   else check_Brackets xs ys','<br/>Тесты успешно пройдены!'),(5179,97,'3598995','2013-11-25 21:01:45',2,' --- Не совсем правильно, воот такой тест не проходит:\r\n ---  checkBrackets \"(]\"\r\n --- Я его сейчас добавлю, а вы исправьте, пожалуйста\r\ncheckBrackets xs = check_Brackets xs []\r\ncheck_Brackets [] [] = True\r\ncheck_Brackets [] ys = False\r\ncheck_Brackets (x:xs) [] = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs [x]\r\n						   else False\r\ncheck_Brackets (x:xs) (y:ys) = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs ([x] ++ (y:ys))\r\n						   else if (x == \')\') && (y /= \'(\')\r\n						   then False\r\n						   else check_Brackets xs ys ','<br/>Тесты успешно пройдены!'),(5178,97,'3598995','2013-11-25 21:00:06',0,'check_Brackets [] [] = True\r\n\ncheck_Brackets [] ys = False\r\n\ncheck_Brackets (x:xs) [] = if (x == \'(\') || (x == \'[\')\r\n\n						   then check_Brackets xs [x]\r\n\n						   else False\r\n\ncheck_Brackets (x:xs) (y:ys) = if (x == \'(\') || (x == \'[\')\r\n\n						   then check_Brackets xs ([x] ++ (y:ys))\r\n\n						   else if (x == \')\') && (y /= \'(\')\r\n\n						   then False\r\n\n						   else check_Brackets xs ys \n','Не удалось вычислить выражение \"checkBrackets [\'(\',\'[\',\']\',\')\']\", проверьте правильность синтаксиса'),(5177,89,'3598995','2013-11-25 20:59:01',1,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\nflatten :: Ord a => Tree a -> [a]  \r\nflatten Empty = []  \r\nflatten (Node a left right) = [a]++flatten (left) ++ flatten (right) ','<br/>Тесты успешно пройдены!'),(5176,89,'3598995','2013-11-25 20:57:24',0,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\nflatten :: Ord a => Tree a -> [a]  \r\nflatten Empty = []  \r\nflatten (Node a left right) = flatten (left) ++ [a] ++ flatten (right) ','Выражение имеет неправильное значение: flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))'),(5167,87,'25446179','2013-11-25 00:04:48',1,'скорее всего тоже неправильно, но тем не менее\r\n  --- в принципе правильно, просто вы забыли написать\r\n  --- еще правило для X\r\ndata Expr = Num Integer \r\n		| X \r\n		| Add Expr Expr \r\n		| Mult Expr Expr\r\n		deriving Show\r\neval (Num n) X = n\r\neval (Add e1 e2) X = eval e1 X + eval e2 X\r\neval (Mult e1 e2) X= eval e1 X * eval e2 X','Не удалось вычислить выражение \"eval (Add (Num 3) (Mult X X)) 10\", проверьте правильность синтаксиса'),(5168,102,'25446179','2013-11-25 00:20:06',1,'findMajor (x:xs) = findMaj xs (sum xs)\r\nfindMaj (x:xs) sum = if x > sum - x then Just x \r\n			else findMaj xs sum \r\nfindMaj [] _ = Nothing\r\n','<br/>Тесты успешно пройдены!'),(5169,157,'25446179','2013-11-25 01:34:22',1,'triangle1 n = [1..n] >>= x -> return(x*x)\r\n  --- Не совсем правильно ((\r\n  --- Это вы написали просто список квадратов чиcел от 1 до n?,\r\n  --- а условие было более сложное.. Но ОК, засчитано. \r\ntriangle2 n = do x <- [1..n] \r\n		return (x*x)\r\n','Не удалось вычислить выражение \"triangle1 3\", проверьте правильность синтаксиса'),(5170,88,'SMakarov','2013-11-25 14:10:28',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\ndiff (X) = Num 1\r\ndiff (Num i) = Num 0\r\ndiff (Add e1 e2) = Add(diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) (e2)) (Mult (e1) (diff e2))','<br/>Тесты успешно пройдены!'),(5171,101,'7475152','2013-11-25 14:49:11',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving (Show,Eq)\r\n\r\nsimplify (Num a) = Num a\r\nsimplify X = X\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Add exp1 exp2)  = Add  (simplify exp1) (simplify exp2)\r\nsimplify (Mult exp1 exp2) = let a = simplify exp1\r\n			        b = simplify exp2\r\n			    in if (a== Num 0 || b==Num 0)\r\n			       then Num 0\r\n			       else Mult a b','<br/>Тесты успешно пройдены!'),(5172,89,'7475152','2013-11-25 14:59:48',2,'  --- Не совсем правильно, потому что вы не учитываете, что у вас одно поддерево мб пустым, а другое непустым\r\n  --- Например, такой тест у вас выдаст ошибку:\r\n  ---   flatten (Node 1 Empty (Node 2 Empty Empty))\r\n  --- Я его сейчас добавлю, а вы попроьуйте исправить, пожалуйста.\r\n  --- (Подсказка: на самом деле, программу можно просто немного усрпростить, вместо двух последних правил написать одно)\r\ndata Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nflatten Empty = []\r\nflatten (Node val Empty Empty) = [val]\r\nflatten (Node val (Node l ll lr ) (Node r rl rr)) = val:l:r:(flatten ll ++ flatten lr ++ flatten rl ++ flatten rr)\r\n','<br/>Тесты успешно пройдены!'),(5173,154,'7475152','2013-11-25 15:49:45',0,'checkBrackets []  ys  = length ys==0\r\ncheckBrackets (x:xs) ys = if (x==\'(\') then checkBrackets xs (x:ys) \r\n			else if (length ys == 0) then False\r\n			     else checkBrackets xs (tail ys)','Не удалось вычислить выражение \"checkBrackets [\'(\',\')\',\')\',\')\']\", проверьте правильность синтаксиса'),(5174,154,'7475152','2013-11-25 15:54:01',2,'--- У вас вроде бы даже и правильно, но, обратите внимание,\r\n--- У фунцкии checkBrackets в примерах один параметр, а у вас два.\r\n--- Т.е., видимо, надо вашу фунцкцию переименовать, типа в checkBrackets1 и еще добавить фунцкию\r\n--- checkBrackets которая вызвает checkBrackets1 c нужными начальными параметрами.\r\n--- Попробуйте так сделать, пожалуйста.\r\ncheckBrackets []  ys  = length ys==0\r\ncheckBrackets (x:xs) ys = if (x==\'(\') then checkBrackets xs (x:ys) \r\n			else if (length ys == 0) then False\r\n			     else let a = tail ys \r\n                                  in if (length a==0)\r\n				     then checkBrackets xs []\r\n				     else checkBrackets xs a','Не удалось вычислить выражение \"checkBrackets [\'(\',\')\',\')\',\')\']\", проверьте правильность синтаксиса'),(5175,101,'21743638','2013-11-25 20:23:57',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\nsimplify (Num n) = Num n\r\n\r\nsimplify X = X\r\n\r\nsimplify (Mult _ (Num 0)) = Num 0\r\n\r\nsimplify (Mult (Num 0) _) = Num 0\r\n\r\nsimplify (Add ex1 ex2) = Add (simplify ex1) (simplify ex2)\r\n\r\nsimplify (Mult ex1 ex2) = let {e1 = simplify ex1; e2 = simplify ex2} in if e1 == Num 0 || e2 == Num 0 then simplify (Mult e1 e2) else Mult e1 e2\r\n\r\n	 \r\n','<br/>Тесты успешно пройдены!'),(5166,88,'25446179','2013-11-25 00:01:16',1,'вероятно, я не совсем понял смысл задания, но у мен получилось что-то такое:\r\n   --- Да нет, все правильно. А почему вы решили, что неправильно поняли задание?\r\n   --- Потому что слишком просто?\r\ndata Expr = Num Integer \r\n		| X \r\n		| Add Expr Expr \r\n		| Mult Expr Expr\r\n		deriving Show\r\ndiff (Num n) = 0\r\ndiff (X) = 1\r\ndiff (Mult X X) = Add (Mult(Num 1) X) (Mult X (Num 1))\r\ndiff (Add X X) = Add (diff X) (diff X)\r\n','Не удалось вычислить выражение \"diff (Mult X X)\", проверьте правильность синтаксиса'),(5164,88,'SMakarov','2013-11-24 22:08:13',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\ndiff (X) = Num 1\r\ndiff (Num i) = Num 0\r\ndiff (Add e1 e2) = Add((diff e1) (diff e2))\r\ndiff (Mult e1 e2) = Add((Mult ((diff e1) e2)) (Mult (e1 (diff e2))))','Не удалось вычислить выражение \"diff (Mult X X)\", проверьте правильность синтаксиса'),(5165,156,'21743638','2013-11-24 22:40:08',1,'class Shape a where\r\n\r\n	area::a->Double\r\n\r\n	perim::a->Double\r\n\r\n	contains::a->Double->Double->Bool\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where\r\n\r\n	area (Rect x y _ _) = x*y\r\n\r\n	perim (Rect x y _ _) = 2*(x+y)\r\n\r\n	contains (Rect x y x0 y0) a b = let {x1=x/2; y1=y/2} in abs(x0-a)<=x1 && abs(y0-b)<=y1\r\n\r\n\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n\r\n  	area (Circle r _ _) = 3.14*r*r\r\n\r\n  	perim (Circle r _ _) = 2*3.14*r\r\n\r\n	contains (Circle r x y) a b = abs(x-a)<=r && abs(y-b)<=r\r\n            --- Тут, конечно, неправильная формула, надо использовать терему Пифагора :((\r\n            --- Но ОК, засчитано.','<br/>Тесты успешно пройдены!'),(5163,157,'SMakarov','2013-11-24 22:07:56',1,'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return (y*y)\r\ntriangle2 n = do x <- [1..n] y <- [1..x] return (y*y)\r\n   --- если вы пишете в одну строчку, то нужно ставить ;\r\n   --- Но ОК, засчитано, хоть и не совсем правильно ','Не удалось вычислить выражение \"triangle1 3\", проверьте правильность синтаксиса'),(5162,88,'3598995','2013-11-24 18:53:13',1,'--очень странная проблема с вычислением diff (Mult X X) вылазит, у меня все отлично\r\n  --- А что вы имеете в виду под проблемой7 У вас ведь все тесты прошли?\r\n  --- Или были какие-то версии, которые не работали и вы не понимаете почему?\r\n  --- Если так, пришдите мне их письмом, пожалуйста. Дело в том, что система не позволяет мне \r\n  --- посмотреть ваши не последние версии. \r\n--на самом деле задание показалось сложным, много времени на него ушло.\r\n  --- Это, в принципе, хорошо. Ведь решение то получилось простым, правда же?\r\n  --- Значит, просто вам такие задачи были непривычны. А теперь привычны, и это хорошо)\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\ndiff (Num _) = Num 0\r\ndiff X = Num 1\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))','<br/>Тесты успешно пройдены!'),(5161,101,'7475152','2013-11-24 18:50:36',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\n\r\n\r\n\r\nsimplify (Num a) = Num a\r\nsimplify X = X\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Add exp1 exp2) =  Add  (simplify exp1) (simplify exp2)\r\nsimplify (Mult exp1 exp2) = simplify (Mult (simplify exp1) (simplify exp2))','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(5160,88,'3598995','2013-11-24 18:49:33',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\ndiff (Num _) = Num 0\r\ndiff X = Num 1\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))','Не удалось вычислить выражение \"diff (Mult X X)\", проверьте правильность синтаксиса'),(5159,101,'7475152','2013-11-24 18:49:32',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\n\r\n\r\n\r\nsimplify (Num a) = Num a\r\nsimplify X = X\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Add exp1 exp2) =  Add  (simplify exp1) (simplify exp2)\r\nsimplify (Mult exp1 exp2) = simplify (Mult (simplify exp1) (simplify exp2))','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(5158,88,'3598995','2013-11-24 18:47:31',0,'-на самом деле задание показалось сложным, много времени на него ушло, но интересное)\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\ndiff (Num _) = Num 0\r\ndiff X = Num 1\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))','Не удалось вычислить выражение \"diff (Mult X X)\", проверьте правильность синтаксиса'),(5157,102,'5337814','2013-11-24 17:54:06',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	findMajor.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nfindMajor (x:xs) = let s = sum (x:xs) \r\n\r\n	in	findMajor\' (x:xs) s\r\n\r\n\r\n\r\nfindMajor\' [] s = Nothing\r\n\r\nfindMajor\' (x:xs) s\r\n\r\n	|x > s - x = Just x\r\n\r\n	|otherwise = findMajor\' xs s\r\n\r\n	\r\n\r\nt = findMajor [2,3,15,2,2,2] \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5156,88,'5337814','2013-11-24 17:48:17',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	diff.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\n		deriving Show\r\n\r\n\r\n\r\ndiff (Num _) = Num 0\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Add a b) = Add (diff a) (diff b)\r\n\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n\r\n\r\n\r\nt = diff (Mult X X)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5155,87,'5337814','2013-11-24 17:48:02',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	eval.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\n		deriving Show\r\n\r\n\r\n\r\neval (Num a) x = a\r\n\r\neval X x = x\r\n\r\neval (Add a b) x = (eval a x) + (eval b x)\r\n\r\neval (Mult a b) x = (eval a x) * (eval b x)\r\n\r\n\r\n\r\nt = eval (Add (Num 3) (Mult X X)) 10\r\n','<br/>Тесты успешно пройдены!'),(5154,157,'5337814','2013-11-24 17:47:44',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	triangle12.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ntriangle1 n = [1..n] >>= x -> [1..x] >>= y -> return (y ^ 2)\r\n\r\n\r\n\r\ntriangle2 n = do\r\n\r\n				x <- [1..n]\r\n\r\n				y <- [1..x]\r\n\r\n				return (y ^ 2)\r\n\r\n\r\n\r\nt = triangle1 3\r\n\r\nt\' = triangle2 3\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5153,156,'5337814','2013-11-24 17:47:20',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	contains.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	area :: a -> Double\r\n\r\n	perim :: a -> Double\r\n\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n	area (Rect x y _ _) = x * y\r\n\r\n	perim (Rect x y _ _) = 2 * (x + y)\r\n\r\n	contains (Rect len1 len2 x1 y1) px py\r\n\r\n		|((x1 - (len1 / 2)) <= px && (x1 + (len1 / 2)) >= px) &&\r\n\r\n		 ((y1 + (len2 / 2)) >= py && (y1 - (len2 / 2)) <= py) = True\r\n\r\n		|otherwise = False\r\n\r\n\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	area (Circle r _ _) = 3.14 * r * r\r\n\r\n	perim (Circle r _ _) = 2 * 3.14 * r\r\n\r\n	contains (Circle r x1 y1) px py\r\n\r\n		|(px - x1) ^ 2  + (py - y1) ^ 2 <= r ^ 2 = True\r\n\r\n		|otherwise = False\r\n\r\n\r\n\r\nt = contains (Rect 6 3 (-4) (2.5)) (-4) (0.5)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5152,87,'3598995','2013-11-24 17:21:03',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\neval (Num a) x = a\r\neval X x = x\r\neval (Add a b) x = (eval a x) + (eval b x)\r\neval (Mult a b) x = (eval a x) * (eval b x)','<br/>Тесты успешно пройдены!'),(5147,102,'3598995','2013-11-23 00:41:34',1,'--- Очень хорошо! То только вы 3 раза вычисляете функцию maximum, лучше, конечно, поспользоваться let\r\n\r\nfindMajor xs = if ((maximum xs)>(sum xs - maximum xs)) then Just (maximum xs) \r\n						    else Nothing\r\n','<br/>Тесты успешно пройдены!'),(5148,102,'SMakarov','2013-11-23 17:30:55',1,'sumList [] = 0\r\nsumList xs =  head xs + sumList (tail xs)\r\n   --- или можно воспользоваться стандартной функцией find sum\r\nf [] sum = Nothing\r\nf (x:xs) sum = if x > sum-x then Just x else f xs sum\r\nfindMajor xs = f xs (sumList xs)','<br/>Тесты успешно пройдены!'),(5149,154,'5337814','2013-11-23 18:13:45',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	checkBrackets.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Stack = Stack [Char]\r\n\r\n\r\n\r\npush x (Stack xs) = Stack (x:xs)\r\n\r\n\r\n\r\npop (Stack (x:xs)) = Stack xs\r\n\r\n\r\n\r\nisEmpty (Stack []) = True\r\n\r\nisEmpty (Stack _) = False\r\n\r\n\r\n\r\ncheckBrackets \"\" = True\r\n\r\ncheckBrackets s = checkBrackets\' s (Stack [])\r\n\r\n\r\n\r\ncheckBrackets\' [] stk = isEmpty stk\r\n\r\ncheckBrackets\' (c:cs) stk\r\n\r\n	|(c == \'(\') = checkBrackets\' cs (push c stk)\r\n\r\n	|(c == \')\') = if (isEmpty stk) then False else (checkBrackets\' cs (pop stk))\r\n\r\n\r\n\r\ntest = checkBrackets \"(()(())())\"\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5150,87,'SMakarov','2013-11-23 21:09:28',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\neval (X) x = x\r\neval (Num i) x = i\r\neval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\neval (Mult e1 e2) x = (eval e1 x) * (eval e2 x)','<br/>Тесты успешно пройдены!'),(5151,156,'3598995','2013-11-24 16:55:59',1,'class Shape s where\r\n area :: s -> Double\r\n perimeter :: s -> Double\r\n contains :: s -> Double -> Double -> Bool\r\ndata Rect = Rect {\r\n width :: Double,\r\n height :: Double,\r\n x1 :: Double,\r\n y1 :: Double\r\n} deriving Show\r\n\r\ninstance Shape Rect where\r\n area rect = (width rect) * (height rect)\r\n perimeter rect = 2 * ((width rect) + (height rect))\r\n contains (Rect a b x1 y1) px py\r\n			|px>=(x1-a/2)&&px<=(x1+a/2)&&py>=(y1-b/2)&&py<=(y1+b/2) = True\r\n			|otherwise = False\r\n\r\ndata Circle = Circle {\r\n radius :: Double,\r\n x :: Double,\r\n y :: Double\r\n} deriving Show\r\n\r\ninstance Shape Circle where\r\n area circle = pi * (radius circle) * (radius circle)\r\n perimeter circle = 2.0 * pi * (radius circle)\r\n contains (Circle r x1 y1) px py\r\n			|(px - x1) ^ 2 + (py - y1) ^ 2 <= r ^ 2 = True\r\n			|otherwise = False\r\n','<br/>Тесты успешно пройдены!'),(5146,156,'SMakarov','2013-11-22 20:53:49',1,'  --- ОК, хорошо, но только вместо \r\n  ---   ... = if (k <= a+x && k >= a-x && l <= b-y && l >= b+y) then True else False\r\n  --- короче написать \r\n  ---   ... = k <= a+x && k >= a-x && l <= b-y && l >= b+y\r\n  --- Мы вроде как-то про это говорили\r\ndata Rect = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\nclass Shape a where\r\n	contains::a -> Double -> Double -> Bool\r\ninstance Shape Rect where\r\n	contains (Rect x y a b) k l = if (k <= a+x && k >= a-x && l <= b-y && l >= b+y) then True else False\r\ninstance Shape Circle where\r\n	contains (Circle r a b) k l = if r*r >= (k-a)*(k-a) + (l-b)*(l-b) then True else False','<br/>Тесты успешно пройдены!'),(5145,83,'5337814','2013-11-22 18:07:59',1,'/*	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	lst367.cs\r\n\r\n*/	\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nclass lst367\r\n\r\n{	\r\n\r\n	static void Main(string[] args)\r\n\r\n	{	\r\n\r\n		foreach(int i in Lst367().Take(20))\r\n\r\n			Console.Write(i + \" \");\r\n\r\n	}	\r\n\r\n	\r\n\r\n	public static IEnumerable<int> Lst367()\r\n\r\n	{	\r\n\r\n		yield return 3;\r\n\r\n		yield return 6;\r\n\r\n		yield return 7;\r\n\r\n		\r\n\r\n		foreach(int j in Lst367())\r\n\r\n		{\r\n\r\n				yield return 10 * j + 3;\r\n\r\n				yield return 10 * j + 6;\r\n\r\n				yield return 10 * j + 7;\r\n\r\n		}\r\n\r\n	}	\r\n\r\n}	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5144,152,'SMakarov','2013-11-22 02:54:47',1,'func s f = (([s] ++ func s f) >>= x -> [f x])\r\n  --- Ок, очень хорошо, но можно короче\r\n  ---  (s:func s f) >>= \\x -> f x\r\n  --- или в данном случае все-таки короче использовать map\r\nsuperF s f = [s] ++ func s f\r\nf1 x = sin x\r\nf2 x = x^2\r\nf3 x = x*10+1\r\n\r\n--при вызове нужно указывать значение первого элемента и функцию, например\r\ntake 10 (superF 1 f3)','<br/>Тесты успешно пройдены!'),(5143,83,'SMakarov','2013-11-22 00:58:01',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable BasicLst367()\r\n        {\r\n            yield return 3;\r\n            yield return 6;\r\n            yield return 7;\r\n        }\r\n                \r\n        public static IEnumerable Lst367()\r\n        {\r\n            yield return 3;\r\n            yield return 6;\r\n            yield return 7;\r\n   --- Мб тогда уж и тут логично применить Lst367()\r\n            foreach (int i in Lst367())\r\n            {\r\n                foreach (int j in BasicLst367())\r\n                {\r\n                    yield return 10 * i + j;\r\n                }\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (int i in Lst367())\r\n            {\r\n                Console.WriteLine(i);\r\n                if (i > 1000)\r\n                    break;\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5142,93,'3598995','2013-11-21 17:25:12',1,'  --- Ну, это почти то же что у вас, просто несколько синтаксических усовершенствований.\r\n  --- Я их обычно пропускаю, потому что и без них в принципе все можно написать, просто пожлиннее\r\n  --- Но ОК, давайте в следующий раз обсудим, раз есть интерес. \r\n\r\n--вообще говоря почти об этой задаче, показалось интересным решение http://rosettacode.org/wiki/Hamming_numbers#The_classic_version - там красиво написан union - где можно посмотреть некое описание как вообще писать функции в таком аккуратном стиле? просто не совсем понятны все эти символы вроде @ и то как там в итоге формируется список.\r\nmerge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n	|x<y       = x:merge xs (y:ys)\r\n	|x==y      = x:merge xs ys\r\n	|otherwise = y:merge(x:xs) ys\r\n\r\nham = 1 : (merge (map (2*) ham) (map (3*) ham))','<br/>Тесты успешно пройдены!'),(5140,87,'7475152','2013-11-21 13:53:49',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\n\r\neval (Num x) num = x\r\neval X num = num\r\neval (Add exp1 exp2) num = eval exp1 num + eval exp2 num\r\neval (Mult exp1 exp2) num = (eval exp1 num)*(eval exp2 num)','<br/>Тесты успешно пройдены!'),(5141,88,'7475152','2013-11-21 13:59:58',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n		deriving Show\r\n\r\ndiff (Num a) = Num 0 \r\ndiff X = Num 1\r\ndiff (Add exp1 exp2) = Add (diff exp1) (diff exp2)\r\ndiff (Mult exp1 exp2) = Add (Mult (diff exp1) exp2) (Mult exp1 (diff exp2))','<br/>Тесты успешно пройдены!'),(5138,157,'7475152','2013-11-21 13:27:18',1,'triangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j^2)\r\ntriangle2 n = do i<-[1..n]\r\n		 j<-[1..i]\r\n	         return (j^2)','<br/>Тесты успешно пройдены!'),(5139,102,'7475152','2013-11-21 13:45:14',1,'qsort [] = []\r\nqsort (p:xs) = qsort [x | x<-xs, x>p] ++ [p] ++ qsort [x | x<-xs, x<=p]\r\n\r\nfindMajor xs = let a = qsort xs\r\n	       in if (head a) > sum (tail a) then Just (head a)\r\n		  else Nothing\r\n  --- ОК, но на самом деле достатноно было вызвать функцию maximum вместо sort. \r\n  --- B еще, у вас не быжет работать если список пустой.\r\n  --- Но ОК, вообще хорошо, засчитано.','<br/>Тесты успешно пройдены!'),(5137,156,'7475152','2013-11-20 21:08:38',1,'class Shape a where\r\n   area:: a -> Double\r\n   perim:: a -> Double\r\n   contains:: a-> Double-> Double-> Bool	\r\n\r\ndata Rect = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Rect where\r\n  	area (Rect h w _ _) = h*w\r\n  	perim (Rect h w _ _) = 2*(h+w)\r\n        contains (Rect h w cx cy) x y = (x >=cx-w/2) && (x<=cx+w/2) && (y>=cy-h/2) && (y<=cy+h/2)\r\n\r\n\r\ninstance Shape Circle where\r\n  	area (Circle r _ _) = 3.14*r*r\r\n  	perim (Circle r _ _) = 2*3.14*r\r\n	contains (Circle r cx cy) x y = sqrt ((cx-x)^2+(cy-y)^2) < r','<br/>Тесты успешно пройдены!'),(5136,87,'21743638','2013-11-20 20:13:27',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\neval (Num n) m = n\r\n\r\neval X m = m\r\n\r\neval (Add l r) m = eval l m + eval r m\r\n\r\neval (Mult l r) m = eval l m * eval r m\r\n','<br/>Тесты успешно пройдены!'),(5135,83,'7475152','2013-11-20 20:09:04',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace lst367\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (var i in Ones().Take(10)) { Console.WriteLine(i); }           \r\n            Console.ReadKey();\r\n        }\r\n\r\n        public static IEnumerable<int> Ones()\r\n        {\r\n            int[] a = {3,6,7};\r\n            foreach (int j in a)\r\n            {\r\n                yield return j;             \r\n            }\r\n            foreach (int i in Ones())\r\n            {\r\n                foreach (int j in a)\r\n                    yield return (10 * i + j);\r\n                \r\n            }\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5134,152,'7475152','2013-11-20 18:57:58',1,'composList a f = a:(composList (f a) f)\r\n\r\ny=take 10 (composList 1 sin)\r\nx=take 10 (composList 1 (a->a*10+1))\r\nz=take 10 (composList 2 (^2))','<br/>Тесты успешно пройдены!'),(5133,102,'21743638','2013-11-20 03:35:43',1,'findMajor xs = find xs (sum xs)\r\n\r\nfind [] _ = Nothing\r\n\r\nfind (x:xs) s = if x> s-x then Just x else find xs s\r\n','<br/>Тесты успешно пройдены!'),(5132,157,'21743638','2013-11-20 03:25:29',1,'triangle1 n = [1..n] >>= x ->[1..x] >>= y -> return (y*y)\r\n\r\ntriangle2 n = do {x<-[1..n]; y<-[1..x]; return (y*y)}\r\n','<br/>Тесты успешно пройдены!'),(5131,152,'shkuratov.ilya','2013-11-20 01:19:26',1,'apply f x = x: map f (apply f x)\r\n\r\n\r\n\r\ntest1 = apply (*2) 1\r\n\r\ntest2 = apply (sin) 1\r\n\r\ntest3 = apply (^2) 2\r\n\r\ntest4 = apply (i -> i * 10 + 1) 1\r\n','<br/>Тесты успешно пройдены!'),(5130,93,'shkuratov.ilya','2013-11-20 01:09:39',1,'merge (x:xs) (l:ls) =  \r\n\r\n	if x == l\r\n\r\n	then x : merge xs ls\r\n\r\n	else if x > l\r\n\r\n	then l : merge (x:xs) ls\r\n\r\n	else x : merge xs (l:ls)\r\n\r\nmerge [] ls = ls\r\n\r\nmerge xs [] = xs\r\n\r\n\r\n\r\nham = 1: merge (map (* 2) ham) (map (* 3) ham)\r\n','<br/>Тесты успешно пройдены!'),(5128,154,'21743638','2013-11-19 11:54:23',1,'checkBrackets xs = func xs []\r\n\r\nfunc [] [] = True\r\n\r\nfunc [] _ = False\r\n\r\nfunc (x:xs) ys = if (x == \'(\') then func xs (x:ys)\r\n\r\n	else if ((x == \')\') && (length ys /= 0)) then func xs (tail ys) \r\n\r\n		else False\r\n','<br/>Тесты успешно пройдены!'),(5129,155,'7475152','2013-11-19 19:57:26',1,'digits m n = div (10*m) n : digits (mod (10*m) n) n\r\n  --- все правильно, это у меня тест был неправильный','Выражение имеет неправильное значение: take 25 (digits 1 7)'),(5127,128,'tori','2013-11-18 08:17:31',3,'data NiamNiam = Cake String Integer Integer |	--название, вес, цена\r\n	Candy String Integer	--название, цена за килограмм\r\n\r\nbestCake [] = \"Cake_is_not_found\"\r\nbestCake xs = bestCake\' (head xs) (tail xs) \"Cake_is_not_found\" (-1)	--max-максимальная стоимость, name - название\r\nbestCake\' x [] n p = bestCake\'\' x n p\r\nbestCake\' (Cake name _ pr) ls maxN maxP =\r\n	if pr > maxP\r\n		then bestCake\' (head ls) (tail ls) name pr\r\n		else bestCake\' (head ls) (tail ls) maxN maxP\r\nbestCake\' (Candy _ _) ls maxN maxP = bestCake\' (head ls) (tail ls) maxN maxP\r\nbestCake\'\' (Cake name _ pr) maxN maxP =\r\n	if maxP > pr\r\n		then maxN\r\n		else name\r\nbestCake\'\' (Candy _ _) maxN maxP = maxN\r\n\r\n\r\nmain = print(bestCake([Cake \"q\" 5 5, Cake \"w\" 4 4, Candy \"z\" 1, Cake \"e\" 7 7, Cake \"r\" 1 1]))','<br/>Тесты успешно пройдены!'),(5126,38,'tori','2013-11-18 08:16:38',2,'data Tree = Empty |\r\n	Node Integer Tree Tree\r\n	deriving Show\r\n\r\nheight Empty = 0\r\nheight (Node a left right) = height\' (Node a left right)\r\nheight\' Empty = -1	--вычитаем, потому что незаконно прибавили\r\nheight\' (Node a left right) = 1 + max (height left) (height right)		--передаем корень дерева, будем отсекать ряды\r\n   -- тут справа тоже надо использовать height\'\r\n\r\nmain = print(height (Node 1 Empty Empty))\r\n--main = print(height (Node 1 (Node 1 Empty Empty) Empty))','Выражение имеет неправильное значение: height (Node 1 Empty Empty)'),(5124,36,'tori','2013-11-18 08:15:43',3,'cubeTable n = cubeTable\' [1..n]\r\ncubeTable\' ls = map (x -> (x , x * x * x)) ls\r\nmain = print (cubeTable 5)','<br/>Тесты успешно пройдены!'),(5125,37,'tori','2013-11-18 08:16:09',3,'--сделаем из нашего списка список пар\r\nminsum xs = minimum list_sum	--выбираем минимум\r\n	where\r\n	list_pair = zip	xs (tail xs)--склеиваем соседние элементы в пары, получаем список пар из рядом стоящих элементов\r\n	list_sum = map(x -> fst x + snd x) list_pair	--складываем элементы в парах, получаем список сумм из рядом стоящих элементов\r\n\r\nmain = print(minsum [1,2,3,2,1])\r\n','<br/>Тесты успешно пройдены!'),(5122,35,'tori','2013-11-18 07:59:47',0,'isosc (x1, y1) (x2, y2) (x3, y3) = if ( r1 == r2 ) || (r2 == r3) || (r1 == r3)\r\n    then True\r\n    else False\r\n    where\r\n        r1 = rasst (x1, y1) (x2, y2)\r\n        r2 = rasst (x2, y2) (x3, y3)\r\n        r3 = rasst (x2, y2) (x3, y3)\r\n\r\nrasst (x1, y1) (x2, y2) = sqrt ((x2 - x1)^2 + (y2 - y1)^2)\r\n\r\nmain = if (isosc (0,1) (0,0) (1,0))\r\n    then print (\"yes\")\r\n    else print (\"no\")','Выражение имеет неправильное значение: isosc (-3, 2) (2, 0) (2,2)'),(5123,35,'tori','2013-11-18 08:15:20',3,'isosc (x1, y1) (x2, y2) (x3, y3) = if ( r1 == r2 ) || (r2 == r3) || (r1 == r3)\r\n    then True\r\n    else False\r\n    where\r\n        r1 = rasst (x1, y1) (x2, y2)\r\n        r2 = rasst (x2, y2) (x3, y3)\r\n        r3 = rasst (x1, y1) (x3, y3)\r\n\r\nrasst (x1, y1) (x2, y2) = ((x2 - x1)^2 + (y2 - y1)^2)\r\n\r\n\r\nmain = if (isosc (-3, 2) (2, 0) (2,2))\r\n    then print (\"yes\")\r\n    else print (\"no\")','<br/>Тесты успешно пройдены!'),(5121,31,'tori','2013-11-18 07:58:54',3,'isArithm [] = False	--будем считать, ноль элементов не образуют арифм. прогрессию. минимальное кол-во элементов - 2\r\nisArithm xs = if (tail xs == [])\r\n	then False\r\n	else isArithm\' b (tail(tail xs)) d\r\n	where {	a = head xs; b = head (tail xs); d = b - a}\r\n		\r\nisArithm\' _ [] d = True\r\nisArithm\' x xs d = if (head xs - x /= d)\r\n	then False\r\n	else isArithm\' (head xs) (tail xs) d\r\nmain = print(isArithm [1, 2, 3, 4, 5])','<br/>Тесты успешно пройдены!'),(5120,29,'tori','2013-11-18 07:58:20',3,'--будем снимать 1 элемент и сравнивать его со всеми оставшимися с списке.\r\nmy_in _ [] = True 	--не нашли одинаковых\r\nmy_in x xs = if (x == head xs) \r\n	then False	--нашли одинаковые\r\n	else my_in x (tail xs)		--проверяем дальше\r\n\r\ncheckDifferent [] = True	--будем считать, что отсутствие элементов в списке означает, что все эл-ты разные, ведь и правда повторяющихся нет\r\ncheckDifferent xs = checkDifferent\' (head xs) (tail xs)	--снимаем x и передаем оставшуюся часть списка\r\ncheckDifferent\' _ [] = True	--одинаковых нет\r\ncheckDifferent\' x xs = if not(my_in x xs)	--нашли 2 одинаковых\r\n	then False\r\n	else checkDifferent\' (head xs) (tail xs)\r\n\r\nmain = print(checkDifferent [7,2,7])','<br/>Тесты успешно пройдены!'),(5119,28,'tori','2013-11-18 07:57:51',3,'check f [] = False\r\ncheck f xs = if (f (head xs) == True)\r\n	then True\r\n	else check f (tail xs)\r\nmain = print(check (x->x >= 0) [-3,-2,-7,4])','<br/>Тесты успешно пройдены!'),(5118,18,'tori','2013-11-18 07:56:14',3,'{--всего n дробей.\r\nБудем считать, что n > 0.\r\nСчитать будем снизу вверх, т.к. это удобнее в нашем случаае. Удобнее тем, что мы можем завести накопительный параметр p.\r\nТогда при вызове функции будем сразу считать 1-ю дробь: 1/2 (изначально вызывается f n)--}\r\n\r\n\r\nimport System.Environment\r\nf n = if n > 0\r\n then f\' (n - 1) ( 1 / 1 )  -- 1/1 для наглядности\r\n else 0\r\nf\' 0 p = 1 + p\r\nf\' n p = f\'(n - 1) ( 1 / (1 + p) )\r\nmain = print (f 3)','<br/>Тесты успешно пройдены!'),(5116,153,'25446179','2013-11-18 04:35:05',0,'lst367 = [3,6,7] >>= x-> 3:6:7:[10*x+j|j<-[3,6,7]]\n','Выражение имеет неправильное значение: take 15 lst367'),(5117,153,'25446179','2013-11-18 05:04:13',1,'--- Но тут нет никакого завязывания в узел.. Ведm завязывание в узел - это когда список определяеться сам через себя,\r\n--- а тут этого нет, справа вы lst367 не используете.\r\n--- Но ОК, вы по крайней мере попробовали:) Т.е. засчитано.\r\n\r\nlst367 = [3, 6, 7] >>= x-> x:[10*x+j|j<-[3,6,7]]','Выражение имеет неправильное значение: take 15 lst367'),(5115,75,'SMakarov','2013-11-18 03:26:54',1,'a. (a -> b -> b) -> b -> [a] -> b\r\n\r\nb. foldr f x xs = ans\r\nx1 -> x2 -> x3 -> x4\r\nx1 - тип функции с двумя параметрами, x1 = x5 -> x6 -> x7\r\n(x1 -> x2 -> x3) -> x4 -> [x5] -> x6\r\nx1 == x5, т.к. x1 - элемент из списка [x5]\r\nx2 == x4, т.к. x4 передается в функцию f\r\nx4 == x3 == x6, т.к. x6 - результат всей функции foldr и имеет такой же тип, как и у результата функции f','<br/>Тесты успешно пройдены!'),(5113,105,'SMakarov','2013-11-18 02:38:38',1,'cartesian [] ys = []\r\ncartesian (x:xs) ys = (ys >>= y -> [(x,y)]) ++ cartesian xs ys','<br/>Тесты успешно пройдены!'),(5114,90,'SMakarov','2013-11-18 02:48:42',1,'f x [] = False\r\nf x (x1:xs) = if x == x1 then True else f x xs\r\nfindSame (x:[]) = (x,False)\r\nfindSame (x:xs) = if f x xs then (x,True) else findSame xs','<br/>Тесты успешно пройдены!'),(5112,105,'SMakarov','2013-11-18 02:37:20',0,'cartesian xs [] = []\r\ncartesian xs (y:ys) = (xs >>= x -> [(x,y)]) ++ cartesian xs ys','Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),(5110,104,'SMakarov','2013-11-18 00:44:28',1,'f x = if x `mod` 2 == 0 then [x, x] else [x]\r\ndoubleEven xs = xs >>= x -> f x','<br/>Тесты успешно пройдены!'),(5111,153,'SMakarov','2013-11-18 01:49:55',1,'f = ([3,6,7] ++ f) >>= x -> [x*10+3,x*10+6,x*10+7]\r\nlst367 = [3,6,7] ++ f','<br/>Тесты успешно пройдены!'),(5108,104,'25446179','2013-11-18 00:11:32',1,'doubleEven xs = xs >>= x-> if mod x 2 == 0 then [x,x] else [x] ','<br/>Тесты успешно пройдены!'),(5109,75,'25446179','2013-11-18 00:28:26',1,'--- Засчитано, но вообще-то нет, тип не совсем такой.. Например, у f параметр вовсе не список.\r\n--- Ведь мы туда передаем например (+) или (*)\r\na. \r\n(a->[a]->b)->a->b->b\r\n\r\nb. foldr f e (x:xs) = f x (foldr f e xs).\r\nНа входе функция f имеет тип x1->[x2]->x3, где элемент е имеет тип х1,  список xs - [x2], а результат работы функции - x3. \r\nЗаменим х1 на а, х2 на [a], х3 на b. \r\nФункция f имеет сложный тип, но можно заметить что результатом работы функции на каждом шаге будет являться результат работы foldr.\r\n','<br/>Тесты успешно пройдены!'),(5106,104,'25446179','2013-11-18 00:08:29',0,'doubleEven xs = xs >>=x -> if mod x 2 == 0 then [x,x] else [x] ','Не удалось вычислить выражение \"doubleEven [1,2,6,3]\", проверьте правильность синтаксиса'),(5107,104,'6205237','2013-11-18 00:09:48',1,'\r\ndoubleEven xs = xs >>= x -> if mod x 2 == 0 then ([x]++[x]) else [x]\r\n','<br/>Тесты успешно пройдены!'),(5103,105,'6205237','2013-11-17 23:54:48',0,'\r\n\ncartesian xs ys	= xs >>= x -> (ys >>= y -> [(y,x)] ) \n','Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),(5104,105,'6205237','2013-11-17 23:56:09',1,'\r\ncartesian xs ys	= xs >>= x -> (ys >>= y -> [(x,y)] ) \r\n','<br/>Тесты успешно пройдены!'),(5105,153,'6205237','2013-11-18 00:06:30',1,'\r\nlst367 = 3:6:7:(lst367 >>= x -> ([3,6,7] >>= y ->[(10*x+y)]) )\r\n','<br/>Тесты успешно пройдены!'),(5102,105,'6205237','2013-11-17 23:52:47',0,'\r\n\ncartesian xs ys	= ys >>= y -> (xs >>= x -> [(x,y)] ) \n','Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),(5101,75,'21743638','2013-11-17 23:36:46',1,'﻿a. foldr\r\n\r\n   (a->a->b)->a->[a]->b\r\n\r\n\r\n\r\nb. \r\n\r\nРассмотрим foldr f e (x:xs) = f x (foldr f e xs). \r\n\r\n\r\n\r\nНа вход подается f - функция, элемент e типа x1 и список xs типа [x2].\r\n\r\nФункция f имеет тип x3->x4->x5. Она применяется к элементу e и списку xs => они имеют один тип: x1==x2. Следовательно, x3==x4==x1==x2. Обозначим его a.\r\n\r\nВ результате применения f получаем тип x5, который также является типом результата. Обозначим его b. В итоге получаем: f имеет тип a->a->b, e имеет тип a, список xs - тип [a]. А тип результата - b.\r\n','<br/>Тесты успешно пройдены!'),(5100,90,'6205237','2013-11-17 22:18:32',1,'\r\nfindSame [] = \"No same elements\"\r\n\r\nfindSame (x:xs) = if any (y -> y==x) xs then (\"First same element: \" ++ show(x))\r\n\r\n		else findSame xs\r\n','<br/>Тесты успешно пройдены!'),(5099,90,'21743638','2013-11-17 19:42:47',1,'findSame [] = (\"not element\", 0)\r\n\r\nfindSame (x:xs) = if any (y -> x==y ) xs then (\"found\", x) else findSame xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5098,75,'3598995','2013-11-17 15:59:07',1,'Я делала не то чтобы совсем по Хиндли-Милнеру - мне было проще детально посмотреть на всю цепь преобразований при работе функции. Если не права - подскажите, пожалуйста.:)\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\nЧто бы разобраться с типом, мне было проще использовать пример его работы.\r\n  --- Нет, все правильно, в том смысле что человеку почти всегда проще разобрать что-то на примере\r\n  --- Алгоритм Хиндли-Милнера - это скорее для компьюьтера..\r\n  --- Как компьютер мог бы прийти к такому же выводу - это мы завтра обсудим\r\nfordr (-) 3 [1..4] = \r\n1 - (fordr (-) 3 [2..4]) =\r\n1 - (2 - (foldr (-) 3 [3 .. 4])) =\r\n1 - (2 - (3 - (foldr (-) 3 [4])))  =\r\n1 - (2 - (3 - (4 - 3))) =\r\n1 - (2 - (3 - 1)) =\r\n1 - (2 - 2) = \r\n1 - 0 = \r\n1\r\nЕсли попробовать расписать тип, то видно, что f->a->b->[a]->result, а сама по себе функция - это a->b, a result==b, \r\nтаким образом\r\nfoldr:: (a -> b -> b) -> b -> [a] -> b\r\n','<br/>Тесты успешно пройдены!'),(5097,154,'3598995','2013-11-17 15:29:57',2,'   --- Это в принципе правильное решение, но только не совсем этой задачи:)\r\n   --- Посмотрите пожалуйста внимательнее - в условии написано, что скобки могут быть толькоэ\r\n   --- круглыми. А значит, в дополнительном праметре можно хранить только количество скобок.\r\n   --- Сами cкобки в данном случае запоминать не надо, все равно они будут только `(`\r\n   --- Попробуйте так исправить, пожалуйста. Если что-то непонятно, пишите.\r\ncheckBrackets xs = check_Brackets xs []\r\n\r\ncheck_Brackets [] [] = True\r\ncheck_Brackets [] ys = False\r\ncheck_Brackets (x:xs) [] = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs [x]\r\n						   else False\r\ncheck_Brackets (x:xs) (y:ys) = if (x == \'(\') || (x == \'[\')\r\n						   then check_Brackets xs ([x] ++ (y:ys))\r\n						   else if (x == \')\') && (y /= \'(\')\r\n						   then False\r\n						   else if (x == \'[\') && (y /= \']\')\r\n						   then False\r\n						   else check_Brackets xs ys ','<br/>Тесты успешно пройдены!'),(5095,93,'7475152','2013-11-17 14:40:33',2,'  --- Так у вас не по условию. Числа должны идти в порядке возрастания, обратите пожалуйста внимание.\r\n  --- Могу еще подсказать - удобно воспользоваться функцией merge\r\ncantor  = [(x,k-x)| k<-[0..], x<-[0..k]]\r\nham = [2^i*3^j|(j,i)<-cantor]','Выражение имеет неправильное значение: take 10 ham'),(5096,75,'7475152','2013-11-17 15:05:02',1,'a) (a->b->b)->b->[a]->b\r\nb) foldr f a [b1,...,bn] = b1 \'f\' (b2 \'f\'...(bn \'f\' a)... )\r\n x1->x2->[x3]->x4\r\nx1 - результат f\r\nx2 - результат (bn \'f\' a)\r\nx3 - список элементов\r\nx4 - окончательный результат\r\nx1=x2, те x1->x1->[x3]->x4\r\nтак как x4-окончательный результат,то x4=x1\r\nx1->x1->[x3]->x1\r\nфункция f это x5->x1->x1\r\nздесь замечаем,что x5=x3\r\nтогда получается (x3->x1->x1)->x1->[x3]->x1  ','<br/>Тесты успешно пройдены!'),(5092,155,'21743638','2013-11-17 13:16:51',1,'--- Тут все правильно, замечательно\r\n--- Это у меня была ошибка в тесте\r\ndigits m n = let {a = m*10; b = div a n} in b: digits (a-b*n) n\r\n','Выражение имеет неправильное значение: digits 1 7'),(5093,153,'3598995','2013-11-17 13:55:56',1,'lst367 = 3:6:7:(lst367 >>= x -> [10*x+3, 10*x+6, 10*x+7])','<br/>Тесты успешно пройдены!'),(5094,90,'7475152','2013-11-17 14:22:15',1,'support [x] = (1/0, False)\r\nsupport (x:xs) = if x==head xs then (x, True)\r\n		 else support xs \r\n\r\nfindSame xs = support (quicksort xs)','<br/>Тесты успешно пройдены!'),(5089,105,'shkuratov.ilya','2013-11-17 12:40:30',1,'cartesian xs ls = xs >>= x -> map (y -> (x, y)) ls\r\n','<br/>Тесты успешно пройдены!'),(5090,90,'shkuratov.ilya','2013-11-17 12:54:36',1,'﻿findSame xs = findSame\' [] xs\r\n\r\n\r\n\r\nfindSame\' prev (x:xs) = \r\n\r\n	if elem x prev\r\n\r\n	then [x]\r\n\r\n	else findSame\' (x:prev) xs\r\n\r\nfindSame\' _ [] = []\r\n\r\n\r\n\r\n-- я подумал, что если вы предлагаете вместо числа, возвращать пару,\r\n\r\n-- то можно возращать и список.\r\n','<br/>Тесты успешно пройдены!'),(5091,105,'3598995','2013-11-17 13:08:23',1,'cartesian xs [] = []\r\ncartesian [] ys = []\r\ncartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]','<br/>Тесты успешно пройдены!'),(5088,153,'shkuratov.ilya','2013-11-17 12:37:12',1,'lst367 = 3:6:7: (lst367 >>= \r\n\r\n	x -> \r\n\r\n	let \r\n\r\n	y = x*10\r\n\r\n	in [y + 3, y + 6, y + 7]\r\n\r\n	)\r\n','<br/>Тесты успешно пройдены!'),(5086,104,'shkuratov.ilya','2013-11-17 12:31:08',1,'doubleEven xs = xs >>= x -> if mod x 2 == 0 then [x, x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(5087,153,'shkuratov.ilya','2013-11-17 12:36:33',0,'list367 = 3:6:7: (list367 >>= \r\n\n	x -> \r\n\n	let \r\n\n	y = x*10\r\n\n	in [y + 3, y + 6, y + 7]\r\n\n	)\n','Не удалось вычислить выражение \"take 15 lst367\", проверьте правильность синтаксиса'),(5085,75,'shkuratov.ilya','2013-11-17 12:26:24',1,'﻿foldr f e (x:xs) = foldr f (f x e) xs\r\n\r\nfoldr _ e [] = e\r\n\r\n\r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\n\r\n\r\n1) Выясняем, что на самом деле некоторые типы являеются сложными.\r\n\r\nВидим в правой части \"f x e\", значит x1 = (x5 -> x6 -> x7).\r\n\r\nВидим с левой части \"x:xs\", значит x3 = [x8].\r\n\r\n\r\n\r\n(x5 -> x6 -> x7) -> x2 -> [x8] -> x4\r\n\r\n\r\n\r\n2) Находим совпадающие типы.\r\n\r\nИз второго правила получаем, что x4 = x2\r\n\r\nИз сопоставления \"f e (x:xs)\" и \"f (f x e)\" получаем, \r\n\r\nчто тип результата f есть x7 = x2, x6 = x2 и x5 = x8.\r\n\r\n\r\n\r\nт.о. получаем:\r\n\r\n(x5 -> x2 -> x2) -> x2 -> [x5] -> x2\r\n\r\nили\r\n\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5084,104,'3598995','2013-11-17 11:21:42',1,'doubleEven xs = xs >>= x -> if mod x 2 == 0 then [x,x] else [x]','<br/>Тесты успешно пройдены!'),(5082,105,'5337814','2013-11-15 20:26:41',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	cartesian.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ncartesian (x:xs) (y:ys) = (x:xs) >>= x -> (y:ys) >>= y -> [(x, y)]\r\n\r\n\r\n\r\ntest = cartesian [1, 2, 3] [3, 4]\r\n','<br/>Тесты успешно пройдены!'),(5083,151,'SMakarov','2013-11-16 01:40:39',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable Ones()\r\n        {\r\n            yield return 1;\r\n            foreach (int i in Ones())\r\n            {\r\n                yield return 10*i+1;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (int i in Ones())\r\n            {\r\n                Console.WriteLine(i);\r\n                if (i < 0)\r\n                    break;\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5080,104,'5337814','2013-11-15 20:26:00',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	doubleEven.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndoubleEven (x:xs) = (x:xs) >>= x -> if (x `mod` 2 == 0) then [x, x] else [x]\r\n\r\n\r\n\r\ntest = doubleEven [1, 2, 6, 3]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5081,153,'5337814','2013-11-15 20:26:19',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	lst367b.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nlst367 = 3 : 6 : 7 : (lst367 >>= i -> [10 * i + 3, 10 * i + 6, 10 * i + 7])\r\n\r\n\r\n\r\ntest = take 15 lst367\r\n','<br/>Тесты успешно пройдены!'),(5079,75,'5337814','2013-11-15 20:25:28',1,'﻿---foldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\n---foldr f e (x:xs) = f x (foldr f e xs)\r\n\r\n\r\n\r\n---Типы списка-аргумента и результата не совпадают, однако могу быть какими угодно, поэтому тип элементов\r\n\r\n---списка будет a, а тип результата b.\r\n\r\n\r\n\r\n---foldr начинает свёртку с конца списка, комбнируя элементы списка типа а с накапливающимся значением типа b,\r\n\r\n---используя функцию f. Таким образом тип функции f представим как (a -> b -> b). Результат имеет типа b, так как, например, \r\n\r\n---в ситуации когда второй аргумент e имеет тип Double, а элементы списка Integer, то должен получится Double.\r\n\r\n\r\n\r\n---е используеться в качестве накапливающего параметра, имеет тип b.\r\n\r\n\r\n\r\n---Тип третьего параметра очевиден - [a].\r\n\r\n\r\n\r\n---Результат выполнения также имеет тип b, поскольку является последним значением накапливающего параметра.\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5077,105,'7475152','2013-11-15 14:21:56',1,'cartesian xs ys = xs>>=(x->map (y->(x,y)) ys)','<br/>Тесты успешно пройдены!'),(5078,132,'23959','2013-11-15 16:25:21',1,'f xs = map (x->(if (x==1) then -1 else x)) xs','<br/>Тесты успешно пройдены!'),(5076,151,'5337814','2013-11-15 12:57:07',1,'/*	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	Iter.cs\r\n\r\n*/	\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nclass Iter\r\n\r\n{	\r\n\r\n	static void Main(string[] args)\r\n\r\n	{	\r\n\r\n		foreach(int i in Ones().Take(20))\r\n\r\n			Console.Write(i + \" \");\r\n\r\n	}	\r\n\r\n	\r\n\r\n	public static IEnumerable<int> Ones()\r\n\r\n	{	\r\n\r\n		yield return 1;\r\n\r\n		\r\n\r\n		foreach(int i in Ones())\r\n\r\n			yield return 10 * i + 1;\r\n\r\n	}	\r\n\r\n	\r\n\r\n}	\r\n','<br/>Тесты успешно пройдены!'),(5074,83,'21743638','2013-11-14 22:15:33',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace lst367\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Lst367()\r\n\r\n        {\r\n\r\n            yield return 3;\r\n\r\n            yield return 6;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst367())\r\n\r\n            {\r\n\r\n                yield return 10*i+3;\r\n\r\n                yield return 10*i+6;\r\n\r\n                yield return 10*i+7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void func(int n)\r\n\r\n        {\r\n\r\n            int i = 1;\r\n\r\n            foreach (double x in Lst367())\r\n\r\n            {\r\n\r\n                Console.Write(\"{0}, \", x);\r\n\r\n                if (i == n) break;\r\n\r\n                ++i;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"\r\n\");\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main()\r\n\r\n        {\r\n\r\n            func(15);\r\n\r\n            //func(23);\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5075,152,'21743638','2013-11-15 01:24:32',1,'func f e = e : map (x -> f x) (func f e)\r\n\r\n\r\n\r\nlistSin = take 5 (func sin 1)\r\n\r\nsquare = take 5 (func (x->x^2) 2)\r\n\r\nones = take 5 (func (x->x*10+1) 1)\r\n','<br/>Тесты успешно пройдены!'),(5071,104,'7475152','2013-11-14 20:53:01',1,'doubleEven xs = xs>>=(x-> if (mod x 2==0) then [x,x] else [x])','<br/>Тесты успешно пройдены!'),(5072,153,'7475152','2013-11-14 21:03:10',1,'lst367 = 3:6:7:(lst367>>=(x->[x*10+3,x*10+6,x*10+7]))','<br/>Тесты успешно пройдены!'),(5073,18,'41863862','2013-11-14 21:09:13',2,'???','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(5069,150,'7475152','2013-11-14 19:50:23',1,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)   | x<y  = x:merge xs (y:ys)\r\n		      |	x==y = x:merge xs ys\r\n		      | otherwise  = y:merge (x:xs) ys','<br/>Тесты успешно пройдены!'),(5070,151,'7475152','2013-11-14 20:10:23',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ForSimuny1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (var i in Ones().Take(10)) { Console.WriteLine(i); }           \r\n            Console.ReadKey();\r\n        }\r\n\r\n        public static IEnumerable<int> Ones()\r\n        {\r\n            yield return 1;\r\n            foreach (int i in Ones())\r\n            {\r\n                yield return  i*10+1;\r\n            }\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5068,150,'shkuratov.ilya','2013-11-14 18:37:39',1,'merge (x:xs) (l:ls) =  \r\n\r\n	if x == l\r\n\r\n	then x : merge xs ls\r\n\r\n	else if x > l\r\n\r\n	then l : merge (x:xs) ls\r\n\r\n	else x : merge xs (l:ls)\r\n\r\nmerge [] ls = ls\r\n\r\nmerge xs [] = xs\r\n\r\n\r\n\r\ntest = merge [1, 2, 3] [3..]\r\n','<br/>Тесты успешно пройдены!'),(5067,151,'5337814','2013-11-14 18:29:03',2,'  --- А вы запускали эту программу? Насколько я понимаю, у вас при печати бесконечный цикл.\r\n  --- Исправьте, пожалуйста, чтобы программа печатала, скажем, первые 20 элементов последовательности Ones() \r\n/*	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	Iter.cs\r\n\r\n*/	\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nclass Iter\r\n\r\n{	\r\n\r\n	static void Main(string[] args)\r\n\r\n	{	\r\n\r\n		using(System.IO.StreamWriter file = new System.IO.StreamWriter(@\"C:UsersPublicwww.txt\"))\r\n\r\n		{\r\n\r\n			foreach(int i in Ones())\r\n   --- бесконечный цикл? Тут надо, видимо печатать первые, скажем, 20 элементов (потом все равно int переполнится)\r\n\r\n				file.Write(i + \", \");\r\n\r\n		}\r\n\r\n	}	\r\n\r\n	\r\n\r\n	public static IEnumerable<int> Ones()\r\n\r\n	{	\r\n\r\n		yield return 1;\r\n\r\n		\r\n\r\n		foreach(int i in Ones())\r\n\r\n			yield return 10 * i + 1;\r\n\r\n	}	\r\n\r\n}	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5066,72,'shkuratov.ilya','2013-11-14 18:13:39',1,'weekend = 0:0:0:0:0:1:1: weekend\r\n\r\nweekendExpences = sum . (zipWith (*) weekend)\r\n','<br/>Тесты успешно пройдены!'),(5065,133,'23959','2013-11-14 15:06:16',1,'identity n = map (i -> (map (j-> if (i==j) then 1 else 0) [1..n])) [1..n]','<br/>Тесты успешно пройдены!'),(5064,132,'23959','2013-11-14 15:05:29',2,'identity n = map (i -> (map (j-> if (i==j) then 1 else 0) [1..n])) [1..n]','Не удалось вычислить выражение \"f [2, 3, 1, 4, 1, 8]\", проверьте правильность синтаксиса'),(5063,72,'23959','2013-11-14 14:57:13',1,'weekendExpences xs = foldr (+) 0 (map((i,x)-> if (i `mod` 7==6 || i `mod` 7==0) then x else 0) (zip [1..(length xs)] xs))','<br/>Тесты успешно пройдены!'),(5062,72,'5337814','2013-11-14 00:15:44',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	weekendExpences.hs\r\n\r\n-}	\r\n\r\n\r\n\r\n\r\n\r\nweekendExpences xs = sum $ zipWith (*) xs (cycle [0,0,0,0,0,1,1])\r\n\r\n\r\n\r\ntest = weekendExpences [3, 1, 4, 12, 3, 5, 17, 6, 7, 7, 8, 18, 5, 1, 3]\r\n\r\n\r\n\r\n--weekendExpences xs = take 2 . drop 5 $ xs\r\n','<br/>Тесты успешно пройдены!'),(5061,150,'SMakarov','2013-11-13 14:34:40',1,'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys) = if x == y then (x:(merge xs ys)) else if x < y then (x:(merge xs (y:ys))) else (y:(merge (x:xs) ys))','<br/>Тесты успешно пройдены!'),(5058,132,'23959','2013-11-13 12:53:34',1,'f xs = map (x->(if (x==1) then -1 else x)) xs','<br/>Тесты успешно пройдены!'),(5059,90,'3598995','2013-11-13 13:36:42',1,'--подумала, что логично возвращать списки тех элементов, что повторяются хоть раз, а если повторяющихся нет, то возвращать пустой list\r\n  -- ОК, отличное решение, вы молодец!\r\nmembof x [] = False\r\nmembof x (y:ys) = if (y == x) then True else membof x ys\r\n\r\nfindSame xs = find_same xs []\r\nfind_same [] ys = []\r\nfind_same (x:xs) ys = if membof x ys then [x]++find_same xs ([x] ++ ys) else find_same xs ([x] ++ ys)','<br/>Тесты успешно пройдены!'),(5060,72,'SMakarov','2013-11-13 14:26:00',1,'f n [] = 0\r\nf n (x:xs) = if n `mod` 7 == 0 || n `mod` 7 == 6 then (x + f (n+1) xs) else f (n+1) xs\r\nweekendExpences xs = f 1 xs','<br/>Тесты успешно пройдены!'),(5055,150,'3598995','2013-11-13 12:36:19',0,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n	|x<y       = x:merge xs (y:ys)\r\n	|x==y      = x:merge xs ys\r\n	|otherwise = y:merge(x:xs) ys','<br/>Тесты успешно пройдены!'),(5056,150,'3598995','2013-11-13 12:36:24',1,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n	|x<y       = x:merge xs (y:ys)\r\n	|x==y      = x:merge xs ys\r\n	|otherwise = y:merge(x:xs) ys','<br/>Тесты успешно пройдены!'),(5057,152,'3598995','2013-11-13 12:50:26',1,'func f e = e : func f (f e)\r\n\r\ntest1 = func sin 1\r\ntest2 = func f 1\r\nf i = 10 * i + 1','<br/>Тесты успешно пройдены!'),(5053,153,'21743638','2013-11-13 02:10:25',1,'lst367 = 3:6:7:(lst367 >>= x -> [10*x+3, 10*x+6, 10*x+7])\r\n','<br/>Тесты успешно пройдены!'),(5054,105,'21743638','2013-11-13 02:14:52',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]\r\n','<br/>Тесты успешно пройдены!'),(5047,36,'23959','2013-11-12 18:42:03',0,'cubeTable n = map(x->(x, x*x)) [1..n]','Выражение имеет неправильное значение: cubeTable 4'),(5048,36,'23959','2013-11-12 18:45:04',1,'cubeTable n = map(x->(x, x^3)) [1..n]','<br/>Тесты успешно пройдены!'),(5049,37,'23959','2013-11-12 18:51:38',1,'minsum (x:xs) = minimum( map ((x,y)->x+y) (zip (x:xs) (xs)))','<br/>Тесты успешно пройдены!'),(5050,129,'23959','2013-11-12 19:12:28',1,'len (x:xs) = foldr (+) 0 (map ((a,b)->seglen a b) (zip (x:xs) xs))\r\nseglen (a1, a2) (b1, b2) = sqrt((b1-a1)^2+(b2-a2)^2)','<br/>Тесты успешно пройдены!'),(5051,150,'5337814','2013-11-12 20:09:56',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	merge.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nmerge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n	| x < y = x : merge xs (y:ys)\r\n\r\n	| x == y = x : merge xs ys\r\n\r\n	| otherwise = y : merge (x:xs) ys\r\n\r\n\r\n\r\ntest = merge [1, 3, 4, 5, 10, 11] [2, 5, 6, 7, 9]\r\n\r\ntest1 = merge [1,4,8] [2,4,5,10,20]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5052,104,'21743638','2013-11-13 02:06:20',1,'doubleEven xs = xs >>= x -> if mod x 2 == 0 then [x,x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(5042,73,'6205237','2013-11-11 03:22:01',1,' \r\n\r\n\r\n\r\nfibs = 1 : (foldr (++) [] ( map ((x:xs) -> xs) fibs\'))\r\n\r\ngetNext xs = [last xs] ++ [last xs + (last(init xs))]\r\n\r\nfibs\' = [1,1] : ( map getNext fibs\')\r\n','<br/>Тесты успешно пройдены!'),(5043,71,'6205237','2013-11-11 04:05:55',1,'\r\napproxSum [] = 0\r\n\r\napproxSum (x:xs) = if (abs(x)>0.000001) then (x + approxSum xs)\r\n\r\n			else 0\r\n\r\ntmp = 1 : map ( x ->1/((sqrt((1/x))+1)^2)) tmp\r\n\r\n\r\n\r\nz = approxSum tmp\r\n','<br/>Тесты успешно пройдены!'),(5044,73,'SMakarov','2013-11-11 13:19:05',1,'fibs = 1:1:zipWith (+) fibs (tail fibs)','<br/>Тесты успешно пройдены!'),(5045,71,'SMakarov','2013-11-11 13:33:30',1,'approxSum (x:xs) = if (abs x) < 0.000001 then 0 else (x+approxSum xs)\r\nz = approxSum [1/(i*i) | i <- [1..]]','<br/>Тесты успешно пройдены!'),(5046,72,'7475152','2013-11-12 01:35:42',1,'support (x:xs) i = let next = support xs (i+1)\r\n		   in	\r\n			if i==6 then x+next \r\n		   	else if i==7 then x+support xs 1\r\n		         	else next	\r\nsupport [] i = 0  \r\nweekendExpences xs = support xs 1','<br/>Тесты успешно пройдены!'),(5040,81,'6205237','2013-11-11 01:52:41',1,'\r\nlst367 = foldr (++) [] lst367\'\r\n\r\n\r\n\r\ngetNext [] = []\r\n\r\ngetNext (x:xs) = (x*10 + 3) : (x*10 + 6) : (x*10 + 7) : getNext xs\r\n\r\n\r\n\r\nlst367\' = [3,6,7] : ( map getNext lst367\' )\r\n','<br/>Тесты успешно пройдены!'),(5041,74,'6205237','2013-11-11 03:21:40',1,'\r\ndata Tree = Empty |\r\n\r\n	    Node Integer Tree Tree	\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nsumPos (Node val l r) = (foldTree (x y z -> sum (filter (>0) [x,y,z])) 0 (Node val l r))\r\n','<br/>Тесты успешно пройдены!'),(5039,74,'7475152','2013-11-11 01:33:41',2,'   --- Это не по условию, надо было использовать не это определение foldTree, а другое, в котором f имеет аргумента.\r\n   --- Те все-таки не зачтено. Но, если хотите, можете решить другую простую задачу - найти сумму квадратов \r\n   --- всех чисел в дереве. И выложите ее сюда, или пришлите по почте. А я тогда ее зачту.\r\ndata Tree = Empty |\r\n		Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = \r\n     let \r\n     res1 = foldTree f e l \r\n     res2 = foldTree f res1 r\r\n     in f res2 val\r\nfoldTree f e Empty = e\r\n\r\ng x y = if (y>0) then x+y else x\r\nsumPos t = foldTree g 0 t','<br/>Тесты успешно пройдены!'),(5037,150,'21743638','2013-11-11 00:18:46',1,'merge (x:xs) (y:ys) = if (x < y) then x:merge (xs) (y:ys)\r\n\r\n	else if (x > y) then y:merge (x:xs) ys\r\n\r\n		else x:merge xs ys\r\n\r\nmerge xs ys = xs++ys\r\n','<br/>Тесты успешно пройдены!'),(5038,149,'shkuratov.ilya','2013-11-11 00:21:32',1,'superMap f = foldr (i res -> (f i) ++ res) [] \r\n','<br/>Тесты успешно пройдены!'),(5036,74,'shkuratov.ilya','2013-11-11 00:13:38',1,'data Tree = Empty | \r\n\r\n	Node Integer Tree Tree\r\n\r\n	\r\n\r\nfoldTree f e (Node v l r) = \r\n\r\n	let\r\n\r\n	res1 = foldTree f e l\r\n\r\n	res2 = foldTree f e r\r\n\r\n	in f v res1 res2\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nsumPos = \r\n\r\n	foldTree (v l r -> if v > 0 then v + l + r else l + r) 0\r\n\r\n\r\n\r\n--test = (Node 10 (Node (-5) (Node 3 Empty Empty) Empty) (Node 3 (Node (-4) Empty Empty) Empty))\r\n','<br/>Тесты успешно пройдены!'),(5035,149,'57304539','2013-11-11 00:09:57',1,'{-comment\r\n\r\n-}                                                \r\n\r\nsuperMap f (x:xs) = (f x)++superMap f xs\r\n\r\nsuperMap _ [] = []\r\n','<br/>Тесты успешно пройдены!'),(5034,74,'57304539','2013-11-11 00:02:48',1,'{-comment\r\n\r\n-}       \r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n                                             \r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nsumPos = foldTree (v l r -> if (v > 0) then v+l+r else l+r) 0\r\n\r\n\r\n\r\ntest = sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty)) \r\n','<br/>Тесты успешно пройдены!'),(5033,74,'6205237','2013-11-10 23:56:06',2,'  --- нет, это не по условию, это не то foldTree. посмотрите в слайдах, там есть и другой.\r\ndata Tree = Empty |\r\n\r\n	    Node Integer Tree Tree	\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = let \r\n\r\n     res1 = foldTree f e l \r\n\r\n     res2 = foldTree f res1 r\r\n\r\n   in res2 `f` val\r\n\r\n\r\n\r\nsumPos (Node val l r) = (foldTree (x y -> sum (filter (>0) [x,y])) 0 (Node val l r))\r\n','<br/>Тесты успешно пройдены!'),(5032,81,'57304539','2013-11-10 23:53:56',1,'  ---у вас все правильно, это у меня быда ошибка в тесте\r\n{-comment\r\n\r\n-}                                                    \r\n\r\nlst367 = 3:6:7:[x*10+y|x<-lst367,y<-[3,6,7]]\r\n','Выражение имеет неправильное значение: take 15 lst367'),(5031,73,'57304539','2013-11-10 23:53:23',1,'{-comment\r\n\r\n-}                                                    \r\n\r\nfibs = 1:1:zipWith (+) fibs (tail fibs) 	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5030,71,'57304539','2013-11-10 23:53:01',1,'{-comment\r\n\r\n-}                                                    \r\n\r\n\r\n\r\napproxSum (x:xs) = if abs(x) > 0.000001 then x + approxSum xs\r\n\r\n				   else 0\r\n\r\n\r\n\r\nz = approxSum [1/(x**2)|x<-[1..]] 	\r\n','<br/>Тесты успешно пройдены!'),(5028,71,'57304539','2013-11-10 23:51:48',0,'{-comment\r\n\n-}                                                    \r\n\n\r\n\napproxSum (x:xs) = if x > 0.000001 then x + approxSum xs\r\n\n				   else 0\r\n\n\r\n\nz = approxSum [1/(x**2)|x<-[1..]] 	\n','Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),(5029,74,'6205237','2013-11-10 23:52:05',0,'\r\n\ndata Tree = Empty |\r\n\n	    Node Integer Tree Tree	\r\n\n\r\n\nfoldTree f e Empty = e\r\n\nfoldTree f e (Node val l r) = let \r\n\n     res1 = foldTree f e l \r\n\n     res2 = foldTree f res1 r\r\n\n   in res2 `f` val\r\n\n\r\n\nsumPos (Node val l r) = (foldTree (x y ->  if (x*y>0) then (x+y) else y) 0 (Node val l r))\n','Выражение имеет неправильное значение: sumPos (Node (-5) (Node 2 Empty Empty) Empty)'),(5027,150,'57304539','2013-11-10 23:51:16',1,'{-comment\r\n\r\n-}                                                    \r\n\r\n\r\n\r\nmerge (x:xs) (y:ys) = if (x < y) then x:(merge xs (y:ys))\r\n\r\n				 else if (y < x) then y:(merge (x:xs) ys)\r\n\r\n						 else x:(merge xs ys)\r\n\r\nmerge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n','<br/>Тесты успешно пройдены!'),(5025,149,'21743638','2013-11-10 23:38:22',1,'superMap f xs = foldr (++) [] [f x| x <- xs]\r\n','<br/>Тесты успешно пройдены!'),(5026,81,'shkuratov.ilya','2013-11-10 23:40:40',1,'  --- все правильно, это у меня была ошибка в тесте\r\nlst367 = 3:6:7:[i*10+j | i <- lst367, j <- [3, 6, 7]]\r\n','Выражение имеет неправильное значение: take 15 lst367'),(5024,74,'21743638','2013-11-10 23:32:09',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nsumPos = foldTree (v l r -> if v>0 then v+l+r else l+r) 0\r\n','<br/>Тесты успешно пройдены!'),(5023,150,'3598995','2013-11-10 23:30:12',0,'--знаю, намудрила, хоть и работает, но время еще есть, если вы подскажите чуть-чуть как это упростить, то я поправлю все.\r\nmembof x [] = False\r\nmembof x (y:ys) = if (y == x) then True else membof x ys\r\nset [] = []\r\nset (x:xs) = if membof x (set xs) then set xs else x:(set xs)\r\nqsort [] = []\r\nqsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)\r\nmerge x y = qsort (set (x++y))','<br/>Тесты успешно пройдены!'),(5022,68,'SMakarov','2013-11-10 23:04:13',1,'//Извините что так поздно исправляю, только сейчас увидел что не зачтена эта задача\r\nusing System;\r\nusing System.Linq;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static int[] zeroDigits(int[] arr, int n) \r\n        {\r\n            int pow = Convert.ToInt32(Math.Pow(10, n));\r\n            int[] ans = arr.Select(x => x / pow * pow).ToArray();\r\n   // В принципе правильно, но так у вас получится, что  Math.Pow(10, n) будет вычисляться много раз\r\n   // при каждой проверке. А можно вычислить один раз вне лямбда выражения, и это будет гораздо \r\n   // эффективнее. Попробуйте исправить так, пожалуйста. \r\n            return ans;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = { 563, 5643, 76796 };\r\n            int[] ans = zeroDigits(arr, 2);\r\n            for (int i = 0; i < ans.Length; i++)\r\n                Console.WriteLine(ans[i]);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5017,71,'shkuratov.ilya','2013-11-10 21:36:51',0,'approxSum = approxSum\' 0\r\n\n\r\n\napproxSum\' res (x:xs) = \r\n\n	if x > 0.000001\r\n\n	then approxSum\' (res + x) xs\r\n\n	else res\r\n\n\r\n\nseries = map (i -> 1 / i^2) [1..] \r\n\n--series\' n = (1/n^2) : series\'(n+1)\r\n\nz = approxSum series\n','Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),(5018,71,'shkuratov.ilya','2013-11-10 21:37:55',1,'approxSum = approxSum\' 0\r\n\r\n\r\n\r\napproxSum\' res (x:xs) = \r\n\r\n	if abs(x) > 0.000001\r\n\r\n	then approxSum\' (res + x) xs\r\n\r\n	else res\r\n\r\n\r\n\r\nseries = map (i -> 1 / i^2) [1..] \r\n\r\n--series\' n = (1/n^2) : series\'(n+1)\r\n\r\nz = approxSum series\r\n','<br/>Тесты успешно пройдены!'),(5019,35,'23959','2013-11-10 21:53:21',0,'isArithm (x:y:xs) = progr (y:xs) (y - x)\r\nprogr (x:[]) dif = True\r\nprogr (x:y:xs) dif = if ((y-x) == dif)\r\n                        then progr (y:xs) dif\r\n                        else False','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5020,35,'23959','2013-11-10 21:53:57',1,'len (a1, a2) (b1, b2) = sqrt((b1-a1)*(b1-a1)+(b2-a2)*(b2-a2))\r\nisosc\' [l1, l2, l3] = (l1 == l2 || l2 == l3 || l3 == l1 )\r\n\r\nisosc a b c = isosc\' [len a b, len b c, len c a]','<br/>Тесты успешно пройдены!'),(5021,73,'shkuratov.ilya','2013-11-10 22:51:26',1,'fibs\' = 1:zipWith (+) (1:fibs\') fibs\' \r\n\r\nfibs = 1:fibs\'\r\n','<br/>Тесты успешно пройдены!'),(5016,149,'5337814','2013-11-10 18:30:24',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	superMap.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nsuperMap f xs = foldr (z zs -> (f z) ++ zs) [] xs\r\n\r\n\r\n\r\ntest = superMap (x -> [x * x, 100 * x]) [1,2,3]\r\n\r\n\r\n','Не удалось вычислить выражение \"superMap f [1,2,3] where f x = [x*x,100*x]\", проверьте правильность синтаксиса'),(5013,73,'5337814','2013-11-10 17:56:28',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	fibs.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nfibs = 1 : 1 : (zipWith (+) (tail fibs) fibs)\r\n\r\n\r\n\r\ntest = take 10 fibs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5014,71,'5337814','2013-11-10 17:58:23',0,'{-	\r\n\n	Bobrov Nikita 2013\r\n\n	approxSum.hs\r\n\n-}	\r\n\n\r\n\napproxSum [] = 0\r\n\napproxSum (x:xs)\r\n\n	| x > 0.000001 = x + approxSum xs\r\n\n	| otherwise = abs x\r\n\n\r\n\nrow = [1 / (x * x) | x <- [1..]]\r\n\n\r\n\nz1 = take 5 row\r\n\nz = approxSum row\r\n\n\n','Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),(5015,71,'5337814','2013-11-10 18:04:49',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	approxSum.hs\r\n\r\n-}	\r\n\r\n\r\n\r\napproxSum [] = 0\r\n\r\napproxSum (x:xs)\r\n\r\n	| abs x > 0.000001 = x + approxSum xs\r\n\r\n	| otherwise = x\r\n\r\n\r\n\r\nrow = [1 / (x * x) | x <- [1..]]\r\n\r\n\r\n\r\nz1 = take 5 row\r\n\r\nz = approxSum row\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5010,72,'3598995','2013-11-10 16:31:05',1,'weekends = 0:0:0:0:0:1:1:weekends\r\nweekendExpences = sum . zipWith (*) weekends\r\n','<br/>Тесты успешно пройдены!'),(5011,71,'21743638','2013-11-10 17:47:39',1,'approxSum xs = approxSum1 xs 0\r\n\r\napproxSum1 (x:xs) y = if (abs x < 0.000001) then y else approxSum1 xs y+x\r\n\r\nz = approxSum [1/(i*i)|i <- [1..]]\r\n','<br/>Тесты успешно пройдены!'),(5012,71,'5337814','2013-11-10 17:55:43',0,'{-	\r\n\n	Bobrov Nikita 2013\r\n\n	approxSum.hs\r\n\n-}	\r\n\n\r\n\napproxSum [] = 0\r\n\napproxSum (x:xs)\r\n\n	| x > 0.000001 = x + approxSum xs\r\n\n	| otherwise = x\r\n\n\r\n\nrow = [1 / (x * x) | x <- [1..]]\r\n\n\r\n\nz1 = take 5 row\r\n\nz = approxSum row\r\n\n\n','Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),(5009,71,'3598995','2013-11-10 16:23:06',1,'approxSum (x:xs) = if abs x < 0.00000001\r\n                   then 0 \r\n                   else x + approxSum xs\r\ntestSeq = [1/(i*i) | i <- [1..]]\r\n\r\nz = approxSum testSeq','<br/>Тесты успешно пройдены!'),(5008,71,'3598995','2013-11-10 16:19:32',0,'approxSum (x:xs) = if x < 0.00000001\r\n                   then 0 \r\n                   else x + approxSum xs\r\ntestSeq = [1/(i*i) | i <- [1..]]\r\n\r\nz = approxSum testSeq','Хитрый тест номер 1 не пройден :(<br/>Подсказка: Последовательность может содержать и отрицательные числа'),(5006,73,'3598995','2013-11-10 16:08:05',1,'fibs = 1 : 1 : zipWith (+) fibs (tail fibs)','<br/>Тесты успешно пройдены!'),(5007,71,'3598995','2013-11-10 16:18:29',0,'approxSum (x:xs) = if x < 0.00000001\r\n                   then 0 \r\n                   else x + approxSum xs\r\ntestSeq = [1/(i*i) | i <- [1..]]\r\n\r\ntest = approxSum testSeq','Не удалось вычислить выражение \"z>1.64 && z<1.65\", проверьте правильность синтаксиса'),(5005,149,'6205237','2013-11-10 13:27:15',1,'\r\nsuperMap f [] = []\r\n\r\nsuperMap f (x:xs) = (f x) ++ superMap f xs \r\n','Не удалось вычислить выражение \"superMap f [1,2,3] where f x = [x*x,100*x]\", проверьте правильность синтаксиса'),(5004,78,'25446179','2013-11-08 11:33:36',1,'nextRow row = zipWith (+) ([0] ++ row) (row ++ [0])\r\n-- повторное применение nextRow\r\npascal = iterate nextRow [1]','<br/>Тесты успешно пройдены!'),(5003,78,'shkuratov.ilya','2013-11-07 02:18:05',1,'pascal = pasTreangle [1]\r\n  --- правильнее triangle :)\r\n\r\n\r\nstep (x:y:xs) = (x + y) : step (y:xs) \r\n\r\nstep x = x\r\n\r\n\r\n\r\npasTreangle xs = \r\n\r\n	xs : pasTreangle( 1 : step xs)  \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5002,146,'shkuratov.ilya','2013-11-07 01:23:35',1,'digits n = digitsList n 1\r\n\r\ndigitsList n rest = \r\n\r\n	let\r\n\r\n	x = rest * 10\r\n\r\n	y = div x n\r\n\r\n	in y : digitsList n (mod x n)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5001,72,'21743638','2013-11-04 02:54:35',1,'weekendExpences xs = func xs [1..7] 0\r\n\r\nfunc [] _ s = s\r\n\r\nfunc xs [] s = func xs [1..7] s\r\n\r\nfunc (x:xs) (z:zs) s = if ((z == 6) || (z == 7)) then func xs zs (s+x) else func xs zs s\r\n','<br/>Тесты успешно пройдены!'),(5000,151,'21743638','2013-11-04 02:20:42',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Ones\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        \r\n\r\n        public static IEnumerable<int> Ones()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            foreach (int i in Ones())\r\n\r\n            {\r\n\r\n                yield return i * 10 + 1;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void func(int n)\r\n\r\n        {\r\n\r\n            int i = 1;\r\n\r\n            foreach (double x in Ones())\r\n\r\n            {\r\n\r\n                Console.Write(\"{0}, \", x);\r\n\r\n                if (i == n)\r\n\r\n                    break;\r\n\r\n                ++i;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"\r\n\");\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            //примеры вызовов\r\n\r\n            func(10);\r\n\r\n            func(5);\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4999,150,'21743638','2013-11-04 01:50:50',2,'--- В принципе у вас правильно, очень хорошо. Но я вас попрошу исправить одну вещь.\r\n--- У вас программа не будет работать, если списки бесконечные. Например, хотелось бы,\r\n--- чтобы можно было написать:\r\n---   merge [i^2 | i <- [1..]] [i^3 | i <- [1..]]\r\n--- и получить список квадратов и кубов в порядке возрастания: [1,4,8,9,16,25,27,36,49,64, ...\r\n--- У вас это не получиться потому что merge1 использует хвостовую рекурсию. А мы говорили,\r\n--- когда обсуждали foldl для бесконечных списков, что хвостовая рекурсия для бесконечных списков не работает.\r\n--- Но в данном случае вы просто зря стали вводить вспомогательную функцию merge1.\r\n--- Имеет смысл, мне кажется, записать ту же логику прямо для merge. И это будет работать и для бесконечных\r\n--- списков. Сто-то в таком роде:\r\n---  merge (x:xs) (y:ys) = \r\n---     if x < y then ...\r\n---     else if x > y then ...\r\n---     else ...\r\n--- Попробуйте так написать, пожалуйста. Если будет что-то не получаться, напишите письмо, обсудим.\r\n \r\nmerge xs ys = merge1 xs ys [] \r\n\r\nmerge1 (x:xs) (y:ys) zs = if (x < y) then merge1 xs (y:ys) (zs++[x])\r\n\r\n	else if (x > y) then merge1 (x:xs) ys (zs++[y]) \r\n\r\n		else merge1 xs ys (zs++[x])\r\n\r\nmerge1 xs ys zs = zs++xs++ys','<br/>Тесты успешно пройдены!'),(4997,73,'21743638','2013-11-02 23:24:11',1,'fibs = 1:1:[i+j | (i,j) <- zip fibs (tail fibs)]\r\n','<br/>Тесты успешно пройдены!'),(4998,79,'21743638','2013-11-04 01:15:39',2,'  --- Нет, это не совсем правильно. На самом деле вы и сами наверное обратили внимание, что у вас первые\r\n  --- 15-17 цифр правильные, а потом начинается что-то странное. Например, 1/15 = 0.066666 и ральше все\r\n  --- цифры 6 до бесконечности. А у вас тольно 16 шестерок, а дальше какие-то явно неправильные цифры.\r\n  --- Почему же это происходит? Потому что в тот момент, когда вы написали \r\n  ---   double k = 1 /(double) n;\r\n  --- вы уже сделали не совсем то. Вы теперь уже считаете не цифры настоящей дроби, и цифры ее приближения\r\n  --- с помоощью double. А double естественно представляет добрные числа приближенно, и точность у него как\r\n  --- раз 15-16 знаков.\r\n  --- Что же делать? Надо как-то обходиться без double. Представьте себе, что у вас компьюьер отнимут и попросят\r\n  --- сосчитать цифры дроби, например 1/7. Как вы это будете делать? Навернякак вы это проходили,\r\n  --- это что-то очень похожее на деоение в столбик.\r\n  --- Сначала вы разделите 10 на 7 нацело, получиться 1 - это первая цифра.  И в остатке 3.\r\n  --- Потом к 3 припишете 0, снова разделите 30 на 7 нацело, получиться 4 - это вторая цифра. И в остатке 2.\r\n  --- Потом к 2 припишете 0 и т.д.\r\n  --- Вот, и вам надо записать этот процесс на C#. Попробуйте пожалуйста. Если будут проблемы - напишите письмо,\r\n  --- обсудим.\r\n\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace digit\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<double> digits(int n)\r\n\r\n        {\r\n\r\n            double k = 1 /(double) n;\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                k = k * 10;\r\n\r\n                int m = (int) k;\r\n\r\n                k = k - m;\r\n\r\n                yield return m;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void func(int n)\r\n\r\n        {\r\n\r\n            int i = 0;\r\n\r\n            foreach (double x in digits(n))\r\n\r\n            {\r\n\r\n                Console.Write(x);\r\n\r\n                if (i >= 100)\r\n\r\n                    break;\r\n\r\n                ++i;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"\r\n\");\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            //Console.WriteLine(\"Enter n\");\r\n\r\n            //int n = Convert.ToInt32(Console.ReadLine());\r\n\r\n            \r\n\r\n            //примеры вызовов\r\n\r\n            func(7);\r\n\r\n            func(15);\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4996,78,'21743638','2013-11-02 23:20:26',1,'pascal = [1]: map (i -> [1] ++ [a+b | (a,b) <- zip i (tail i)] ++ [1]) pascal\r\n','<br/>Тесты успешно пройдены!'),(4991,148,'SMakarov','2013-11-01 15:05:29',0,'minF [] min = min\r\nminF (y:ys) min = if y < min then minF ys y else minF ys min\r\nanyMoreF [] min = True\r\nanyMoreF (x:xs) min = if x < min then False else anyMoreF xs min\r\nanyMore xs ys = anyMoreF xs (minF ys (head ys))','Выражение имеет неправильное значение: anyMore [3,2,8] [2,9]'),(4992,148,'SMakarov','2013-11-01 15:06:10',1,'  --- ОК, очень хорошо. Но, просто как вариант, можно было бы записать ту же идею с помощью\r\n  --- стандартных функций any и maximum, получилось бы то же, но короче \r\nminF [] min = min\r\nminF (y:ys) min = if y < min then minF ys y else minF ys min\r\nanyMoreF [] min = True\r\nanyMoreF (x:xs) min = if x <= min then False else anyMoreF xs min\r\nanyMore xs ys = anyMoreF xs (minF ys (head ys))','<br/>Тесты успешно пройдены!'),(4993,65,'SMakarov','2013-11-02 03:54:19',0,'cantor = [(a,b) | c <- [1..], a <- [1..c], let b = c - a]','Выражение имеет неправильное значение: length[x|(x,y)<-take 100 cantor, x<=0||y<=0]'),(4994,68,'SMakarov','2013-11-02 04:13:51',2,'using System;\r\nusing System.Linq;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static int[] zeroDigits(int[] arr, int n) \r\n        {\r\n            int[] ans = arr.Select(x => x / Convert.ToInt32(Math.Pow(10, n)) * Convert.ToInt32(Math.Pow(10, n))).ToArray();\r\n   --- В принципе правильно, но так у вас получится, что  Math.Pow(10, n) будет вычисляться много раз\r\n   --- при каждой проверке. А можно вычислить один раз вне лямбда выражения, и это будет гораздо \r\n   --- эффективнее. Попробуйте исправить так, пожалуйста. \r\n            return ans;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = { 563, 5643, 76796 };\r\n            int[] ans = zeroDigits(arr, 2);\r\n            for (int i = 0; i < ans.Length; i++)\r\n                Console.WriteLine(ans[i]);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(4995,65,'SMakarov','2013-11-02 04:16:35',1,'cantor = [(a,b) | c <- [1..], a <- [1..c], let b = c - a + 1]','<br/>Тесты успешно пройдены!'),(4989,65,'SMakarov','2013-11-01 03:09:44',2,'cantor = [(a,b) | c <- [1..], a <- [1..c], b <- [1..c], a + b == c]\r\n  --- В принципе жто правильно, но давайте я вам попршу немного оптимизировать.\r\n  --- Вместо b <- [1..c], a + b == c можно написать короче, эффективнее и без генератора вообще.\r\n  --- Ведь если мы знаем a и с (а мы из в этот момент уже знаем) то b можно просто посчитать\r\n  --- с помощью контрукции let. Попробуйте так написать, пожалуйста. Скажем, до воскреснья включительно.','<br/>Тесты успешно пройдены!'),(4990,141,'SMakarov','2013-11-01 03:20:08',1,'using System;\r\nusing System.Linq;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            double[] arr = new double[] { 1, 2, 3 };\r\n            var n = arr.Aggregate(1.0, (a,b) => a*Math.Sin(b));\r\n            Console.WriteLine(n);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(4987,18,'517309','2013-10-31 19:21:53',3,'ннн','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4988,142,'SMakarov','2013-11-01 02:51:59',1,'myTake n [] = []\r\nmyTake 0 xs = []\r\nmyTake n xs = (head (xs)):(myTake (n-1) (tail xs))','<br/>Тесты успешно пройдены!'),(4986,68,'shkuratov.ilya','2013-10-31 19:01:35',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace HomeWork20_1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[] array = new int [] {1111, 23423, 543532, 45345};\r\n            IEnumerable<int> result = zeroDigits(array, 3);\r\n            foreach (var element in result)\r\n            {\r\n                Console.WriteLine(element);\r\n            }\r\n            Console.Read();\r\n        }\r\n\r\n        static public IEnumerable<int> zeroDigits(IEnumerable<int> a, int n)\r\n        {\r\n            int multiplier = 1;\r\n            for (int i = 0; i < n; i++)\r\n            {\r\n                multiplier *= 10;\r\n            }\r\n            return a.Select(x => x / multiplier * multiplier);\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(4985,78,'7475152','2013-10-31 10:08:28',1,'nextEl el = zipWith (+) ([0] ++ el) (el ++ [0]) \r\npascal = [1]: map (nextEl) pascal ','<br/>Тесты успешно пройдены!'),(4983,73,'7475152','2013-10-30 21:25:16',1,'fibs = 1:1: zipWith (+) fibs(tail fibs)','<br/>Тесты успешно пройдены!'),(4984,148,'7475152','2013-10-30 22:08:35',2,'anyMore xs ys = all (x-> any (y->x>y) ys) xs\r\n  --- Это правильно, но так у вас ys просматривается много раз - для каждого элемента xs. А надо, чтобы \r\n  --- список ys просматривался один раз. Подумайте, это доволно просто.\r\n  --- Мб имеет смысл посмотреть что происходит на каком-нибудь конкретном примере, и вы увидите, я думаю,\r\n  --- что есть решение лучше. Но если идей не будет, напишите мне письмо, я подскажу немного.','<br/>Тесты успешно пройдены!'),(4958,69,'5337814','2013-10-27 15:20:50',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	bigSin.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nsinsList = [sin n | n <- [1..]]\r\n\r\nbigSin n = head (dropWhile (<= n) sinsList)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4959,143,'5337814','2013-10-27 15:21:02',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	alternatingSum.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nplusMinus = 1 : -1 : plusMinus\r\n\r\n\r\n\r\nalternatingSum xs = sum (zipWith (*) xs plusMinus)\r\n\r\n\r\n\r\ntest = alternatingSum [2,5,3,7,8,2,3]\r\n','<br/>Тесты успешно пройдены!'),(4960,144,'5337814','2013-10-27 15:21:15',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	facts.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nfacts = 1 : (zipWith (*) [2..] facts)\r\n\r\n\r\n\r\ntest = take 5 facts\r\n','<br/>Тесты успешно пройдены!'),(4961,140,'SMakarov','2013-10-27 19:51:54',1,'--Извините что не вовремя, очень много д/з, не успеваю все, приходится дополнительные задачи оставлять на выходные. В следующий раз постараюсь прислать вовремя\r\nf n = [(x,y) | x <- [0..n], y <- [0..n-x], ((0 - x)*n >= 0 && (-x)*(-n) - n*(n-y) >= 0 && n*(-y) >= 0) || ((0 - x)*n <= 0 && (-x)*(-n) - n*(n-y) <= 0 && n*(-y) <= 0)]\r\n   --- Все проверки, на самом деле, лишние:) Если вы напишете просто\r\n   --- f n = [(x,y) | x <- [0..n], y <- [0..n-x]]\r\n   --- то все ваши условия и так будут удовлетворятся, потому что n у вас в этой функции всегда больше 0,\r\n   --- вы ее так вызываете\r\nchange [] ans = ans\r\nchange (x:xs) ans = change xs ((-fst(x),-snd(x)):ans)\r\ntriangle n = if n < 0 then change (f (-n)) [] else f n','<br/>Тесты успешно пройдены!'),(4962,141,'SMakarov','2013-10-27 20:47:47',2,'using System;\r\nusing System.Linq;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            double[] arr = new double[] {1, 2, 3};\r\n            var n = arr.Aggregate( (a,b) => Math.Sin(a)*Math.Sin(b));\r\n  --- Нет, это не правильно, на самом деле...\r\n  --- У вас в вашем примере получится sin 1*sin(sin 2*sin 3))) (ну или что-то в таком роде, мб скобки\r\n  --- и не так будут расставлены. А надо sin 1*sin 2* sin 3\r\n  --- Те вы вызваете синусы больше чем надо. \r\n  --- Попроьуйте исправить, пожалуйста, желательно до 2.11 включительно\r\n            Console.WriteLine(n);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(4963,69,'SMakarov','2013-10-27 21:18:20',1,'bigSin x = head([sin ans | ans <- [1..], sin ans >= x])','<br/>Тесты успешно пройдены!'),(4964,143,'SMakarov','2013-10-27 21:27:39',1,'plusminus = 1:(-1):plusminus\r\nf [] ys ans = ans\r\nf (x:xs) (y:ys) ans = f xs ys (ans + x*y)\r\nalternatingSum xs = f xs plusminus 0','<br/>Тесты успешно пройдены!'),(4965,143,'6205237','2013-10-27 22:14:26',1,' --- Это вообще-то не по условию. plusMinus из последнего занятия - это вовсе не то, что вы написали.\r\n --- Засчитано, но вообще читайте более внимательно условия, пожалуйста, я могу и не засчитать,  \r\n --- если задача не по условию. \r\nalternatingSum = sum.plusminus\r\n\r\n\r\n\r\nplusminus [] = []\r\n\r\nplusminus [x] = [x]\r\n\r\nplusminus (x:y:xs) = x : (-y) : (plusminus xs)\r\n','<br/>Тесты успешно пройдены!'),(4966,144,'6205237','2013-10-28 00:06:10',1,'\r\nfacts = 1 : zipWith  (*) [2..]  facts\r\n','<br/>Тесты успешно пройдены!'),(4967,144,'SMakarov','2013-10-28 00:09:22',1,'facts = 1:(zipWith (*) facts [2..])','<br/>Тесты успешно пройдены!'),(4968,144,'25446179','2013-10-28 00:14:58',1,'facts = 1: zipWith (*) facts [2..]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4969,145,'6205237','2013-10-28 00:21:16',1,'\r\npyramid = [1] : [ (x+1) : x : xs | (x:xs) <- pyramid ]\r\n','<br/>Тесты успешно пройдены!'),(4970,145,'SMakarov','2013-10-28 00:21:45',1,'pyramid = [1]:map(x -> [head(x)+1]++x) pyramid','<br/>Тесты успешно пройдены!'),(4971,69,'6205237','2013-10-28 00:34:34',1,'\r\nbigSin x = head (filter (>x) (map sin [1..]))\r\n','<br/>Тесты успешно пройдены!'),(4972,56,'SMakarov','2013-10-28 00:42:24',0,'f n 0 ans = ans\r\nf n k ans = f n (k-1) (zipWith (x y -> [x]++y) [1..n] ans)\r\nallLists n k = f n (k-2) [[a,b] | a <- [1..n], b <- [1..n]]','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(4973,65,'6205237','2013-10-28 00:58:56',0,'\r\n\ncantor = [ (y, (x-y)) | x <- [1..], y <- [1..x], x /= y ]\n','<br/>Тесты успешно пройдены!'),(4974,65,'6205237','2013-10-28 00:59:01',1,'\r\ncantor = [ (y, (x-y)) | x <- [1..], y <- [1..x], x /= y ]\r\n   --- ну или вместо y <- [1..x], x /= y проще написать y <- [1..x-1]','<br/>Тесты успешно пройдены!'),(4975,142,'6205237','2013-10-28 01:06:31',1,'\r\nmyTake n [] = []\r\n\r\nmyTake 0 xs = []\r\n\r\nmyTake n (x:xs) = x : myTake (n-1) xs\r\n','<br/>Тесты успешно пройдены!'),(4976,56,'SMakarov','2013-10-28 04:58:07',0,'f n 0 ans = ans\r\nf n k ans = f n (k-1) (zipWith (x y -> [x]++y) [1..n] ans)\r\nallLists n k = f n (k-2) [[a,b] | a <- [1..n], b <- [1..n]]','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(4977,56,'SMakarov','2013-10-28 05:02:06',2,'f n 0 ans = ans\r\nf n k ans = f n (k-1) (zipWith (x y -> [x]++y) [1..n] ans)\r\n   --- Так у вас результат этого вызова f получться всегда длины n\r\n   --- (Потому что вы вызываете zipWith и один из параметров равен [1..n]\r\n   --- А вам надо, чтобы результат имел длинну равную длине ans умноженной на n, правильно? Нам надо соединть во всех возможноых вариантах\r\n   --- Тут проще всего еще раз использовать ist comprehension\r\n   --- Попроьуйте исправить, желательно до 2.11 включительно\r\nallLists n 1 = [[a] | a <- [1..n]]\r\nallLists n k = f n (k-2) [[a,b] | a <- [1..n], b <- [1..n]]','Выражение имеет неправильное значение: length (allLists 3 3)'),(4978,65,'5337814','2013-10-28 19:52:58',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	cantor.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ncantor = [((i - j), j) | i <- [2..], j <- [1..(i - 1)]]\r\n\r\n\r\n\r\ntest = take 100 cantor\r\n','<br/>Тесты успешно пройдены!'),(4979,142,'5337814','2013-10-28 19:53:13',2,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	myTake.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nmyTake n (x:xs)\r\n\r\n	| n <= 0 = []\r\n\r\n	| n >= length (x:xs) = (x:xs)\r\n  --- Нет, в данном случае так нельзя потому что список вполне мб и бесконеным. А значит length испоьзовать нельзя.\r\n  --- Да в данном случае, по-моему, без length и проще получится\r\n  --- Исправьте, пожалуйста.\r\n	| otherwise = x : myTake (n - 1) xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4980,68,'5337814','2013-10-28 19:53:41',1,'/*	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	Select.cs\r\n\r\n*/	\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nclass Select\r\n\r\n{	\r\n\r\n	static void Main(string [] args)\r\n\r\n	{	\r\n\r\n		int[] a = {563, 5643, 76796, 11, 3};\r\n\r\n		\r\n\r\n		a = zeroDigits(a, 2);\r\n\r\n		//a = zeroDigits(a, 1);\r\n\r\n		\r\n\r\n		foreach (var item in a)\r\n\r\n		 System.Console.Write(item + \" \");\r\n\r\n	}	\r\n\r\n	\r\n\r\n	static int[] zeroDigits(int[] a, int n)\r\n\r\n	{	\r\n\r\n		double t = Math.Pow(10D, n);\r\n\r\n		return a.Select(x => x >= t ? (x - (x % (int)t)) : 0).ToArray();\r\n\r\n	}	\r\n\r\n	\r\n\r\n}	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4981,142,'5337814','2013-10-30 14:14:03',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	myTake.hs\r\n\r\n-}	\r\n\r\n\r\n\r\n\r\n\r\nmyTake _ [] = []\r\n\r\nmyTake n _ \r\n\r\n	| n <= 0 = []\r\n\r\nmyTake n (x:xs) = x : myTake (n - 1) xs\r\n\r\n\r\n\r\n\r\n\r\ncantor = [((i - j), j) | i <- [2..], j <- [1..(i - 1)]]\r\n\r\ntest = myTake 100 cantor\r\n','<br/>Тесты успешно пройдены!'),(4982,71,'7475152','2013-10-30 21:03:18',1,'approxSum xs = let a = head xs\r\n	           b = tail xs	 \r\n	       in  if (abs a )<0.000001 then 0\r\n		   else a+(approxSum b)	\r\nz = approxSum (map (x->1/(x^2)) [1,2..] )','<br/>Тесты успешно пройдены!'),(4956,143,'57304539','2013-10-27 14:53:00',1,'{-comment\r\n\r\n-}                                                    \r\n\r\nplusminus = 1:(-1):plusminus\r\n\r\nalternatingSum xs = sum (zipWith (*) xs plusminus)\r\n','<br/>Тесты успешно пройдены!'),(4957,145,'57304539','2013-10-27 15:09:53',1,'{-comment\r\n\r\n-}                                                \r\n\r\npyramid = [1]:[(head i + 1):i | i<-pyramid]\r\n','<br/>Тесты успешно пройдены!'),(4955,69,'57304539','2013-10-27 14:52:43',1,'{-comment\r\n\r\n-}                                                    \r\n\r\nbigSin x = head (filter (>=x) [sin i|i<-[1..]])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4952,141,'6205237','2013-10-27 01:14:04',0,'','<br/>Тесты успешно пройдены!'),(4953,65,'21743638','2013-10-27 13:09:01',1,'cantor = [(x,y)| n <- [1..], x<-[1..n], let y=n-x+1]\r\n','<br/>Тесты успешно пройдены!'),(4954,141,'6205237','2013-10-27 13:49:00',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class _17_1\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\n\r\n            var n = arr.Aggregate(0,((result, word) => result = result + Convert.ToInt32(word[0]==\'a\')));\r\n\r\n            Console.WriteLine(n);\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4951,140,'SMakarov','2013-10-26 21:13:22',2,'   --- Но вообще-то это задача до 24.0, а сегодня уже 26.10. Пожалуйста, \r\n   --- присылайте вовремя, в следующий раз точно не засчитаю. \r\n   --- И еще, давайте я вас попрошу немного ее оптимизировать.\r\n   --- Смотрите, ведь для любого конкретного x, мы можеми сосчитать диапазон, в котором может меняться\r\n   --- у, он легко считается по несложной формуле.\r\n   --- Значит, можно написать така-то так\r\n   ---  f [(x,y) | x<-]0,n], a = ... максимальное значение, которое может принимать y для данного x,\r\n   ---             y<-[0,a]]\r\n   --- B это будет эффективнее, по коайней мере в два раза точно.\r\n   --- Попробуйте так написать, пожалуйста, до понедельника включительно.\r\n   --- Если вдруг не очень понятно, что я имею в виду, напишите письмо, обсудим.\r\nf n = [(x,y) | x <- [0..n], y <- [0..n], ((0 - x)*n >= 0 && (-x)*(-n) - n*(n-y) >= 0 && n*(-y) >= 0) || ((0 - x)*n <= 0 && (-x)*(-n) - n*(n-y) <= 0 && n*(-y) <= 0)]\r\nchange [] ans = ans\r\nchange (x:xs) ans = change xs ((-fst(x),-snd(x)):ans)\r\ntriangle n = if n < 0 then change (f (-n)) [] else f n','<br/>Тесты успешно пройдены!'),(4946,143,'shkuratov.ilya','2013-10-26 10:25:09',1,'plusminus = 1:(-1):plusminus\r\n\r\nalternatingSum xs = sum (zipWith (*) plusminus xs)\r\n','<br/>Тесты успешно пройдены!'),(4947,144,'shkuratov.ilya','2013-10-26 10:35:54',1,'facts = 1 : zipWith (*) [2..] facts\r\n','<br/>Тесты успешно пройдены!'),(4948,145,'shkuratov.ilya','2013-10-26 10:43:10',1,'pyramid = [1] : map (i -> (1 + length i) : i) pyramid\r\n','<br/>Тесты успешно пройдены!'),(4949,69,'3598995','2013-10-26 13:31:21',1,'bigSin x = sin(head (filter(i -> (sin(i)>=x))[1..]))','<br/>Тесты успешно пройдены!'),(4950,65,'7475152','2013-10-26 18:45:31',1,'cantor  = [(x,y)| k<-[1..], x<-[1..k],y<-[1..k], x+y==k ]','<br/>Тесты успешно пройдены!'),(4945,69,'shkuratov.ilya','2013-10-26 02:33:19',1,'bigSin x = sin (fromIntegral(findArg ((asin x) + pi / 2) (-pi / 2)))\r\n\r\n\r\n\r\nfindArg delta lbound = \r\n\r\n	let \r\n\r\n	dpi = 2 * pi\r\n\r\n	diap = [(ceiling (lbound + delta))..(truncate (lbound + dpi - delta))]\r\n\r\n	in if (length diap) == 0\r\n\r\n	then findArg delta (lbound + dpi)\r\n\r\n	else head diap\r\n','<br/>Тесты успешно пройдены!'),(4943,56,'25446179','2013-10-26 00:43:22',1,'allList n 0 = [[]]	\r\n  --- По условию функция должна называться allLists (s на конце). Но ОК, засчитано.\r\nallList n k = [x:xs | x<-[1..n], xs<-allList n (k-1)]\r\n\r\n\r\n','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(4944,140,'25446179','2013-10-26 00:49:17',1,'triangle n = if n > 0 then [(x,y) | y<-[1..n], x<-[1..n], (x+y) < n]\r\n  --- На самом деле надо начинать на с 1, а с 0 - это видно, например, из примера в задании.\r\n  --- Но ОК, засчитано.\r\n		else [(x,y) | y<-[n..(-1)], x<-[n..(-1)], (x+y) < n]\r\n\r\n\r\n','Выражение имеет неправильное значение: length (triangle 3)'),(4938,65,'21743638','2013-10-26 00:21:18',2,'cantor = [(x,y)| n <- [1..], x<-[1..n], y<-[1..n], x+y==n]\r\n   --- Но ведь если x+y == n, то нам не надо иеребирать y<-[1..n],\r\n   --- Мы можем вместо этого воспользоваться let конструкцией, и сосчитать y по x\r\n   --- Попробуйте так исправить программу, пожалуйста.\r\n   --- Если вдруг не очень понятно, о чем речь, напишите письмо, пожалуйста, обсудим.\r\n','<br/>Тесты успешно пройдены!'),(4939,56,'25446179','2013-10-26 00:40:24',0,'allList n 0 = [[]]	\r\n\nallList n k = [x:xs | x<-[1..n], xs<-allLists n (k-1)]\r\n\n\n','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(4940,65,'shkuratov.ilya','2013-10-26 00:42:03',1,'cantor = [(i, k - i + 1) | k <- [1..], i <- [1..k]]\r\n','<br/>Тесты успешно пройдены!'),(4941,56,'25446179','2013-10-26 00:42:08',0,'allList n 0 = [[]]	\r\n\nallList n k = [x:xs | x<-[1..n], xs<-allList n (k-1)]\r\n\n\n','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(4942,56,'25446179','2013-10-26 00:42:42',0,'allList n 0 = [[]]	\r\n\nallList n k = [x:xs | x<-[1..n], xs<-allList n (k-1)]\r\n\n\n','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(4935,78,'3598995','2013-10-25 23:39:40',1,'nextRow xs = [1] ++ zipWith (+) xs (tail xs) ++ [1]\r\npascal = iterate nextRow [1]','<br/>Тесты успешно пройдены!'),(4936,142,'shkuratov.ilya','2013-10-25 23:50:19',1,'myTake _ [] = []\r\n\r\nmyTake 0 _ = []\r\n\r\nmyTake n (x:xs) = x : (myTake (n - 1) xs)\r\n','<br/>Тесты успешно пройдены!'),(4937,68,'21743638','2013-10-26 00:09:47',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace zeroDigits\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] zeroDigits(int[] a, int n)\r\n\r\n        {\r\n\r\n            int z = Convert.ToInt32(Math.Pow(10, n));\r\n\r\n            return a.Select(x => x / z * z).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main()\r\n\r\n        {\r\n\r\n            int[] a = new int[] { 563, 5643, 76796 };\r\n\r\n            int n = 2;\r\n\r\n            int[] b = zeroDigits(a, n);\r\n\r\n            for (int i = 0; i != b.Length; ++i) Console.Write(\"{0} \", b[i]);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4934,144,'21743638','2013-10-25 23:38:03',1,'facts = 1: zipWith (*) [2..] facts\r\n','<br/>Тесты успешно пройдены!'),(4931,140,'6205237','2013-10-24 23:46:19',0,'','Не удалось вычислить выражение \"length (triangle 3)\", проверьте правильность синтаксиса'),(4932,140,'6205237','2013-10-24 23:48:30',1,'\r\ntriangle 0 = [(0,0)]\r\n\r\ntriangle n = if (n >= 0) then (triangle (n-1) ) ++ [ (x,n-x) | x <- [0..n] ]\r\n\r\n		else (triangle (n+1) ) ++ [ (-x,n+x) | x <- [0..(-n)] ]	 \r\n\r\n		\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4933,141,'6205237','2013-10-24 23:49:17',2,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class _17_1\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\n\r\n            var n = arr.Aggregate(\"0\",((result, word) => result = (Int32.Parse(result) + Convert.ToInt32(word[0]==\'a\')).ToString()));\r\n    --- Вообще очень хорошо, но я вас попрошу немного исправить. Проще будет, если первый параметр\r\n    --- задать не \"0\", а 0. Тогда и result будет считаться не строкой, как у вас, а целым числом.\r\n    --- И к нему в лямбда выражении можно будет просто прибавлять 1 или 0 в зависимости от первой буквы\r\n    --- word, и не надо будет вызвать Parse и ToString.\r\n    --- Попробуйте так сделать, пожалуйста. Если что-то непонятно, напишите письмо, мы обсудим. \r\n\r\n            Console.WriteLine(n);\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4930,56,'6205237','2013-10-24 23:45:41',1,'\r\n\r\n\r\nallLists n 1 = [ [x] | x <- [1..n] ]\r\n\r\nallLists n k = [ x:ys | x <- [1..n], ys <- (allLists n (k-1)) ]\r\n','<br/>Тесты успешно пройдены!'),(4929,56,'57304539','2013-10-24 22:14:51',1,'{-comment\r\n\r\n-}\r\n\r\nallLists n 1 = [[x]|x<-[1..n]]\r\n\r\nallLists n k = [x++[y]|x<-allLists n (k-1), y<-[1..n]]\r\n','<br/>Тесты успешно пройдены!'),(4928,141,'shkuratov.ilya','2013-10-24 18:51:29',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Homework17_1\r\n{\r\n    class First\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            String[] array = new String [] { \"colorado\", \"adagio\", \"color\", \"aircraft\", \"bubble\", \"aztec\" };\r\n            var n = array.Aggregate(0, (result, element) => element.StartsWith(\"a\") ? result + 1 : result);\r\n            System.Console.WriteLine(n);\r\n            System.Console.Read();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(4927,56,'7475152','2013-10-23 22:44:02',1,'allLists n 1 = [[x]| x<-[1..n]] \r\nallLists n k = [y:x |x<-(allLists n (k-1)), y<-[1..n]]','<br/>Тесты успешно пройдены!'),(4925,65,'7475152','2013-10-23 20:32:18',0,'cantor  = [(x,y)|x<-[1..], let k=x*x, y<-[1..k]]','Выражение имеет неправильное значение: filter (==(2,3)) (take 1000 cantor)'),(4926,65,'7475152','2013-10-23 20:35:43',2,'cantor  = [(x,y)|x<-[1..], let k=x*x, y<-[1..k]]\r\n--вроде когда проверяю у себя - все ок.(\r\n  --- Да, это у меня был неправильный тест, извините..\r\n  --- Но все равно у вас неправильно, к сожалению.\r\n  --- Например, такой тест не проходит:\r\n  ---   filter (==(2,10)) (take 1000 cantor)\r\n  --- Я его сейчас добавил.\r\n  --- Надо как-то перебирать элементы не по строкам, потому что строки бесконечные. А немного хитрее.\r\n  --- Если хотите, могу немного подсказать - тогда напишите письмо, пожалуйста. ','Выражение имеет неправильное значение: filter (==(2,3)) (take 1000 cantor)'),(4908,69,'7475152','2013-10-22 20:47:56',1,'bigSin x = head [t|t<-(map sin [1..]), t>=x]','<br/>Тесты успешно пройдены!'),(4909,143,'7475152','2013-10-22 21:00:33',1,'plusminus = 1:(-1):plusminus\r\nalternatingSum xs = sum(zipWith (*) xs plusminus)','<br/>Тесты успешно пройдены!'),(4910,141,'21743638','2013-10-22 21:30:37',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace foldr\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main()\r\n\r\n        {\r\n\r\n            string [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\n\r\n            var n = arr.Aggregate(0, (int z, string x) => (x[0] == \'a\' ? z+1 : z));\r\n   --- В лямбда выражении тут можно не писать типы, те можно (z, x) => (x[0] == \'a\' ? z+1 : z)\r\n            Console.WriteLine(n);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n','<br/>Тесты успешно пройдены!'),(4911,144,'3598995','2013-10-22 21:40:49',1,'facts = 1 : zipWith (*) facts [2..]\r\n  --- OK, все правильно, это у меня тест был неправильный','Выражение имеет неправильное значение: take 5 facts'),(4912,69,'21743638','2013-10-22 21:56:08',1,'bigSin x = head (filter (>x) (map sin [1..]))\r\n','<br/>Тесты успешно пройдены!'),(4913,143,'21743638','2013-10-22 22:07:03',1,'plusminus = 1:(-1):plusminus\r\n\r\nalternatingSum xs = sum (zipWith (*) xs plusminus)\r\n','<br/>Тесты успешно пройдены!'),(4914,145,'21743638','2013-10-22 22:36:23',1,'pyramid = [1]: map (i -> (head i +1):i) pyramid\r\n','<br/>Тесты успешно пройдены!'),(4915,142,'21743638','2013-10-22 23:12:52',1,'myTake n xs = [ fst x | x <- filter (i -> snd i <=n) (zip xs [1..length xs])]\r\n','<br/>Тесты успешно пройдены!'),(4916,144,'7475152','2013-10-22 23:17:15',0,'fact = 1:(zipWith (*) [2..] fact )','Не удалось вычислить выражение \"take 5 facts\", проверьте правильность синтаксиса'),(4917,144,'7475152','2013-10-22 23:17:34',0,'facts = 1:(zipWith (*) [2..] facts )','Выражение имеет неправильное значение: take 5 facts'),(4918,144,'7475152','2013-10-22 23:18:23',0,'facts = 1:(zipWith (*) [2..] facts )','Выражение имеет неправильное значение: take 5 facts'),(4919,144,'7475152','2013-10-22 23:22:15',0,'facts = 1:(zipWith (*) [2..] facts )\r\n','Выражение имеет неправильное значение: take 5 facts'),(4920,144,'7475152','2013-10-22 23:22:47',1,'facts = 1:(zipWith (*) [2..] facts )\r\n--не понимаю в чем ошибка\r\n   --- Все правильно, это у меня тест был непривильный :(','Выражение имеет неправильное значение: take 5 facts'),(4921,145,'7475152','2013-10-22 23:25:23',1,'pyramid = [1]:(zipWith (:) [2..] pyramid )','<br/>Тесты успешно пройдены!'),(4922,65,'7475152','2013-10-22 23:31:03',2,'   --- Нет, так у вас генерируются только пары, у которых первый элемент больше второго.\r\n   --- Например, пара ==(2,3) никогда не будет найдена. (Попробовать можгно так например:\r\n   --- filter (==(2,3)) (take 1000 cantor)\r\n   --- Я сейчас добавлю такой тест\r\ncantor  = [(x,y)|x<-[1..], y<-[1..x]]','<br/>Тесты успешно пройдены!'),(4923,144,'517309','2013-10-23 08:45:34',3,'facts = 1:(zipWith (*) [2..] facts )','<br/>Тесты успешно пройдены!'),(4924,141,'5337814','2013-10-23 14:05:43',1,'/*	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	Aggregate.cs\r\n\r\n*/	\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nclass Aggregate\r\n\r\n{	\r\n\r\n	static void Main(string[] args)\r\n\r\n	{	\r\n\r\n		string [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\n\r\n		int n = arr.Aggregate(0, (res, i) => i[0] == \'a\' ? res + 1 : res);\r\n\r\n		Console.WriteLine(n);\r\n\r\n	}		\r\n\r\n}	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4907,142,'7475152','2013-10-22 20:31:13',1,'myTake _ [] = []\r\nmyTake 0 xs = []\r\nmyTake n xs = (head xs):(myTake (n-1) (tail xs))','<br/>Тесты успешно пройдены!'),(4906,140,'7475152','2013-10-22 14:37:47',1,'triangle n = if n<0 then [(x,y)|x<-[n..0], y<-[n..0],((x==0)||(y==0)||(y>=n-x)) ]\r\n	     else  [(x,y)|x<-[0..n], y<-[0..n],((x==0)||(y==0)||(y<=n-x)) ]','<br/>Тесты успешно пройдены!'),(4905,140,'7475152','2013-10-22 14:31:04',0,'\r\ntriangle n = let a=[0..n]\r\n		 b=[n..0]\r\n		 expr d =[(x,y)|x<-d, y<-d,((x==0)||(y==0)||(y==n-x)) ]	 \r\n	     in if n<0 then expr b\r\n		else expr a ','Выражение имеет неправильное значение: length (triangle 3)'),(4904,63,'3598995','2013-10-21 19:52:17',1,'ones = 1 : map (i -> 10*i + 1) ones\r\n ','<br/>Тесты успешно пройдены!'),(4901,62,'25446179','2013-10-21 03:51:06',1,'sumDiv n =  foldr (x res-> if n `mod` x == 0 then x+res else res)  0 [1..n-1]\r\n\r\namicables sDn = [(a,b)| a <- [1..sDn], b <- [1..sDn], a < b, a == sumDiv b , b == sumDiv a]\r\n','<br/>Тесты успешно пройдены!'),(4902,64,'25446179','2013-10-21 04:08:11',1,'data Tree = Empty|Tree (Tree) (Tree)\r\nfoldTree f e Empty = e\r\nfoldTree f e (Tree t (Tree t1) (Tree t2)) = foldTree f (f t (foldTree f e t2)) t1','<br/>Тесты успешно пройдены!'),(4903,64,'3598995','2013-10-21 19:39:38',1,'--Это для высоты\r\ndata Tree a = Nill | Node a (Tree a) (Tree a)\r\nfoldTree t b  Nill = t\r\nfoldTree t b (Node a l r) = b a (foldTree t b l) (foldTree t b r)\r\ndepth = foldTree 0 (x l r -> 1 + l `max` r)\r\n\r\ntest1 = let tree = (Node 10 (Node 5 Nill Nill) (Node 19 Nill Nill))\r\n         in (depth tree) \r\ntest2 = let tree = (Node 10 (Node 5 Nill Nill) Nill)\r\n         in (depth tree)','<br/>Тесты успешно пройдены!'),(4900,61,'25446179','2013-10-21 03:49:03',1,'sumDiv n =  foldr (x res-> if n `mod` x == 0 then x+res else res)  0 [1..n-1]\r\n\r\nperfects n = [x| x<-[1..n], x == sumDiv x]\r\n','<br/>Тесты успешно пройдены!'),(4899,61,'25446179','2013-10-21 03:38:58',0,'f n x = mod n x\r\n\nsumDiv n =  foldr (x res-> if f n x == 0 then x+res else res)  0 [1..n-1]\r\n\nperfects n = [x| x<-[1..n], x == sumDiv x]\n','<br/>Тесты успешно пройдены!'),(4898,61,'25446179','2013-10-21 03:37:27',0,'f n x = mod n x\r\n\nsumDiv n =  foldl (x res-> if f n x == 0 then x+res else res)  0 [1..n-1]\r\n\nperfects n = [x| x<-[1..n], x == sumDiv x]\n','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(4892,63,'SMakarov','2013-10-21 00:21:39',1,'list n = n:list(n*10 + 1)\r\nones = list 1','<br/>Тесты успешно пройдены!'),(4893,64,'SMakarov','2013-10-21 00:36:03',1,'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree oper k Empty = k\r\nfoldTree oper k (Node val l r) = val `oper` ((foldTree oper k l) `oper` (foldTree oper k r))\r\n--main = foldTree (+) 0 (Node 2 (Node 3 Empty Empty) Empty)\r\nmain = foldTree (*) 1 (Node 2 (Node 3 Empty Empty) Empty)','<br/>Тесты успешно пройдены!'),(4894,61,'6205237','2013-10-21 01:08:27',0,'\r\n\nsumDiv n = sum [x| x <- [1..(n/2)], y <- [1..n], n/x==y]\r\n\n\r\n\nperfect n = [x| x <-[2..(n/2)], sumDiv x == x]\n','Не удалось вычислить выражение \"perfects 100\", проверьте правильность синтаксиса'),(4895,61,'6205237','2013-10-21 01:10:10',1,'\r\nsumDiv n = sum [x| x <- [1..(n/2)], y <- [1..n], n/x==y]\r\n\r\n\r\n\r\nperfects n = [x| x <-[2..(n/2)], sumDiv x == x] \r\n   --- А тут почему вы ищете до n/2?? По аналогии с первым правилом?\r\n   --- Тут конечно надо искать до n','Выражение имеет неправильное значение: perfects 100'),(4896,63,'25446179','2013-10-21 02:42:13',1,'numbersFrom n = n : numbersFrom (n*10+1)\r\n\r\nones  = (numbersFrom 1)\r\n','<br/>Тесты успешно пройдены!'),(4897,61,'25446179','2013-10-21 03:25:09',0,'sumDiv n = foldl (x res-> if (n \'mod\' x) == 0 then x+res else res) 0 [1..n-1]\r\n\nperfects n = [x| (x<=n), (x == sumDiv x)]\n','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(4891,62,'SMakarov','2013-10-21 00:15:56',1,'sumDiv1 k n sum = if k == n then sum else if n `mod` k == 0 then sumDiv1 (k+1) n (sum+k) else sumDiv1 (k+1) n sum\r\nsumDiv n = sumDiv1 1 n 0\r\namicables1 k n xs = if k == n then xs else if (sumDiv (sumDiv k)) == k && k > sumDiv k then amicables1 (k+1) n (xs ++ [((sumDiv k), k)]) else amicables1 (k+1) n xs\r\namicables n = amicables1 2 n []','<br/>Тесты успешно пройдены!'),(4888,63,'6205237','2013-10-21 00:14:31',0,'','Не удалось вычислить выражение \"take 4 ones\", проверьте правильность синтаксиса'),(4889,63,'6205237','2013-10-21 00:14:44',0,'\r\n\nones = [map (const 1) [1..x] |x <- [1..]]\n','Выражение имеет неправильное значение: take 4 ones'),(4890,63,'6205237','2013-10-21 00:15:34',1,'\r\nones = [map (const 1) [1..x] |x <- [1..]]\r\n  --- Это не совсем то, у вас получается список списков, а надо - список\r\n  --- чисел. Но ОК, засчитано.\r\n','Выражение имеет неправильное значение: take 4 ones'),(4887,63,'6205237','2013-10-21 00:14:02',0,'\r\n\nones = [map (const 1) [1..x] |x <- [1..]]\n','Не удалось вычислить выражение \"take 4 ones\", проверьте правильность синтаксиса'),(4886,62,'SMakarov','2013-10-21 00:14:02',0,'sumDiv1 k n sum = if k == n then sum else if n `mod` k == 0 then sumDiv1 (k+1) n (sum+k) else sumDiv1 (k+1) n sum\r\nsumDiv n = sumDiv1 1 n 0\r\namicables1 k n xs = if k == n then xs else if (sumDiv (sumDiv k)) == k && k > sumDiv k then amicables1 (k+1) n (xs ++ [((sumDiv k), k)]) else amicables1 (k+1) n xs\r\namicables n = amicables1 1 n []','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(4884,59,'SMakarov','2013-10-20 23:36:43',1,'using System;\r\nusing System.Linq;\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static char[] nonZeroLastDigits(int[] arr)\r\n        {\r\n            char[] newArr = arr.Select(x => x.ToString()[x.ToString().Length - 1]).ToArray();\r\n    --- Засчитано но тут, конечно, лучше как-то не вызывать ToString два раза\r\n            char[] ans = newArr.Where(x => x != \'0\').ToArray();\r\n            return ans;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = new int[] { 354, 20, 9, 31 };\r\n            char[] ans = nonZeroLastDigits(arr);\r\n            for (int i = 0; i < ans.Length; i++)\r\n            {\r\n                Console.Write(\"{0}\", ans[i]);\r\n                if(i != ans.Length-1)\r\n                    Console.Write(\", \");\r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(4885,64,'6205237','2013-10-21 00:02:27',1,'\r\ndata Tree = Empty | \r\n\r\n		Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f s Empty = s\r\n\r\nfoldTree f s (Node val Empty Empty) = (s `f` val)\r\n\r\nfoldTree f s (Node val l r) = (foldTree f s l) `f` ( foldTree f s r ) `f` val\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4883,61,'SMakarov','2013-10-20 23:33:36',1,'sumDiv1 k n sum = if k == n then sum else if n `mod` k == 0 then sumDiv1 (k+1) n (sum+k) else sumDiv1 (k+1) n sum\r\nsumDiv n = sumDiv1 1 n 0\r\nperfects1 k n xs = if k == n then xs else if sumDiv k == k then perfects1 (k+1) n (xs ++ [k]) else perfects1 (k+1) n xs\r\nperfects n = perfects1 1 n []','<br/>Тесты успешно пройдены!'),(4882,68,'7475152','2013-10-20 23:29:48',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace zeroDigits20_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> zeroDigits(int[] a, int n)\r\n        {\r\n            return a.Select(elem=>elem/Convert.ToInt32(Math.Pow(10,n)));\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            \r\n            int[] arr = {563, 5643, 76796};\r\n            Console.WriteLine(\"введите n\");\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n            foreach (int i in zeroDigits(arr,n))\r\n                Console.WriteLine(i);   \r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(4881,64,'7475152','2013-10-20 23:10:10',1,'data Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nfoldTree f b Empty = b\r\nfoldTree f b (Node var l r) = f (f b var) (f (foldTree f b l) (foldTree f b r))\r\n   --- Я бы написал вместо (f b var) просто var. Но OK, так тоже можно.\r\n\r\nsumTree = foldTree (+) 0 (Node 5 (Node 4 (Node 3 Empty Empty) Empty)(Node 3(Node 2 Empty Empty) Empty)) \r\nprodTree = foldTree (*) 1 (Node 5 (Node 4 (Node 3 Empty Empty) Empty)(Node 3(Node 2 Empty Empty) Empty))','<br/>Тесты успешно пройдены!'),(4879,62,'7475152','2013-10-20 22:22:46',1,'sumDiv n = sum[t|t<-[1..n-1], mod n t == 0]\r\namicables n = [(x,y)|x<-[1..n],y<-[x+1..n],x==sumDiv y, y==sumDiv x]','<br/>Тесты успешно пройдены!'),(4880,63,'7475152','2013-10-20 22:36:41',1,'list n = n:list(n*10+1)\r\nones = list 1\r\n','<br/>Тесты успешно пройдены!'),(4876,63,'21743638','2013-10-20 21:33:14',1,'func n = let k = n*10 +1 in k: func k\r\n\r\nones = func 0\r\n','<br/>Тесты успешно пройдены!'),(4877,61,'7475152','2013-10-20 22:21:42',0,'sumDiv n = sum[t|t<-[1..n-1], mod n t == 0]\r\nperfect n = [t|t<-[2..n], sumDiv t == t ]','Не удалось вычислить выражение \"perfects 100\", проверьте правильность синтаксиса'),(4878,61,'7475152','2013-10-20 22:22:17',1,'sumDiv n = sum[t|t<-[1..n-1], mod n t == 0]\r\nperfects n = [t|t<-[2..n], sumDiv t == t ]','<br/>Тесты успешно пройдены!'),(4874,141,'21743638','2013-10-20 20:32:40',2,'   --- Вообще хорошо, но в задачах по C# я прошу выкладывать полную программу,\r\n   --- с using вначале, с выводом результата и т.д. \r\n   --- Чтобы я мог ее у себя скомпилировать, запустить и что-то увидеть.\r\n   --- Выложите такую программу, пожалуйста.\r\n   --- Заодно можете немного исправить - там не обязаательно писать в Aggraegate\r\n   --- типы в угловых скобках, и типы параметров лямбда-выражения тоже можно не писать\r\n   --- Компилятор все это сам определит. Но это не обязательно, можете и так оставить.  \r\nstring [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\n            var n = arr.Aggregate<string,int>(0, (int z, string x) => (x[0] == \'a\' ? z+1 : z));\r\n            Console.WriteLine(n);\r\n            Console.ReadKey();','<br/>Тесты успешно пройдены!'),(4875,140,'21743638','2013-10-20 21:18:24',1,'triangle n = if n >= 0 then [(a,b)| a <-[0..n], b<- [0..n], b <= - a +n]\r\n  --- OK, но можно проще, без последней проверки условия.\r\n  --- мы это в следующий раз обсудим, но мб вы и сами заметите, это просто\r\n	else [(a,b)| a <-[n..0], b<- [n..0], b >= - a + n]\r\n','<br/>Тесты успешно пройдены!'),(4872,64,'21743638','2013-10-20 17:31:09',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = f (f val (foldTree f e l)) (foldTree f e r)\r\n','<br/>Тесты успешно пройдены!'),(4873,64,'shkuratov.ilya','2013-10-20 19:43:21',1,'  --- OK, очень интересно! Я бы не совсем так написал, но это мы обсудим.\r\n  --- Но ваше решение тоже вполне гибкое и хорошее.\r\ndata Tree = Empty |\r\n\r\n	Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree _ e (Empty) = e\r\n\r\nfoldTree f e (Node value l r) = f (f (foldTree f e l) (foldTree f e r)) value\r\n\r\n\r\n\r\ntree = (Node 5 (Node 3 (Node 2 Empty Empty) (Node 4 Empty Empty)) (Node 7 Empty Empty))\r\n\r\ntest1 = foldTree (+) 0 tree\r\n\r\ntest2 = foldTree (*) 1 tree\r\n\r\n\r\n\r\nfoldTree\' _ e (Empty) = e\r\n\r\nfoldTree\' [f, g] e (Node value l r) = g (f (foldTree\' [f, g] e l) (foldTree\' [f, g] e r)) value\r\n\r\n\r\n\r\ntest3 = foldTree\' [(+), (i _ -> i + 1)] 0 tree -- count number of nodes\r\n\r\ntest4 = foldTree\' [(max), (i _ -> i + 1)] 0 tree -- height of tree\r\n\r\n		\r\n\r\n		\r\n','<br/>Тесты успешно пройдены!'),(4871,59,'SMakarov','2013-10-20 17:14:51',2,'  --- Пожалуйста, в качестве решения задач на c# выкладывайте полные программы, с using вначале\r\n  --- Не то чтобы это было очень важно, но я уж для себя принял правило, что без этого я не засчитываю.\r\n  --- Выложите полный текст, пожалуйста.\r\nstatic char[] nonZeroLastDigits(int[] arr)\r\n        {\r\n            char[] newArr = arr.Select(x => x.ToString()[x.ToString().Length - 1]).ToArray();\r\n            char[] ans = newArr.Where(x => x != \'0\').ToArray();\r\n            return ans;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = new int[] { 354, 20, 9, 31 };\r\n            char[] ans = nonZeroLastDigits(arr);\r\n            for (int i = 0; i < ans.Length; i++)\r\n            {\r\n                Console.Write(\"{0}\", ans[i]);\r\n                if(i != ans.Length-1)\r\n                    Console.Write(\", \");\r\n            }\r\n            Console.ReadKey();\r\n        }','<br/>Тесты успешно пройдены!'),(4870,62,'21743638','2013-10-20 17:03:45',1,'--sumDiv n = sum (map (i -> if mod n i == 0 then i else 0) [1..n-1])\r\n\r\nsumDiv n = foldr (i a-> if mod n i == 0 then a+i else a) 0 [1..n-1]\r\n\r\namicables n = [(a,b)| a <- [1..n], b <- [1..n], a == sumDiv b , b == sumDiv a, a < b]\r\n','<br/>Тесты успешно пройдены!'),(4869,63,'21743638','2013-10-20 17:03:10',2,'--sumDiv n = sum (map (i -> if mod n i == 0 then i else 0) [1..n-1])\r\n\r\nsumDiv n = foldr (i a-> if mod n i == 0 then a+i else a) 0 [1..n-1]\r\n\r\namicables n = [(a,b)| a <- [1..n], b <- [1..n], a == sumDiv b , b == sumDiv a, a < b]\r\n','Не удалось вычислить выражение \"take 4 ones\", проверьте правильность синтаксиса'),(4868,64,'5337814','2013-10-20 16:50:18',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	foldTree.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Tree = Node Double Tree Tree | Empty\r\n\r\n\r\n\r\nfoldTree _ e Empty = e\r\n\r\nfoldTree f e (Node val Empty Empty) = val `f` e\r\n\r\nfoldTree f e (Node val l r) = foldTree f (val `f` (foldTree f e r)) l\r\n\r\n\r\n\r\ntest = foldTree (+) 0.0 (Node 5.0 (Node (-2.0) Empty (Node (3.0) Empty Empty)) (Node 7.0 Empty Empty))\r\n\r\ntest1 = foldTree (max) 5.0 (Node 5.0 (Node (-2.0) Empty (Node (3.0) Empty Empty)) (Node 7.0 Empty Empty))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4864,61,'21743638','2013-10-20 16:43:45',1,'sumDiv n = sum (map (i -> if mod n i == 0 then i else 0) [1..n-1])\r\n\r\nperfects n = [x| x<-[1..n], x == sumDiv x]\r\n','<br/>Тесты успешно пройдены!'),(4865,61,'5337814','2013-10-20 16:49:11',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	sumDiv_perfects.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndividers 1 = [1]\r\n\r\ndividers x = [y | y <- [1..x - 1], mod x y == 0]\r\n\r\n\r\n\r\nsumDiv n = sum $ dividers n\r\n\r\n\r\n\r\nperfects n = [x | x <- [2..n], x == sumDiv x]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4866,62,'5337814','2013-10-20 16:49:35',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	amicables.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndividers 1 = [1]\r\n\r\ndividers x = [y | y <- [1..x - 1], mod x y == 0]\r\n\r\n\r\n\r\nsumDiv n = sum $ dividers n\r\n\r\n\r\n\r\namicables n = [(x, y) | y <- [2..n], x <- [2..n], x < y, x == sumDiv y, y == sumDiv x]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4867,63,'5337814','2013-10-20 16:49:58',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	ones.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nones = 1 : concatMap (x -> (10 * x + 1) : []) ones\r\n  --- Зачем concatMap то?? Просто map тут очень хорошо подходит. \r\n\r\n\r\ntest = take 7 ones\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4862,62,'shkuratov.ilya','2013-10-20 12:06:16',1,'sumDiv n = \r\n\r\n	foldr (i res ->\r\n\r\n			let p = div n i\r\n\r\n			in if mod n i == 0\r\n\r\n			then if p == i \r\n\r\n				then res + i\r\n\r\n				else res + i + p\r\n\r\n			else res \r\n\r\n		) (-n) [1..((floor . sqrt . fromIntegral) n)]\r\n\r\n\r\n\r\namicables n = [(i, j) | i <- [1..n], j <- [sumDiv i], j > i, i == sumDiv j]\r\n','<br/>Тесты успешно пройдены!'),(4863,63,'shkuratov.ilya','2013-10-20 12:55:23',1,'ones\' n = n : ones\' (n * 10 + 1)\r\n\r\n\r\n\r\nones = ones\' 1 \r\n','<br/>Тесты успешно пройдены!'),(4861,61,'shkuratov.ilya','2013-10-20 01:08:55',1,'sumDiv n = \r\n\r\n	foldr (i res ->\r\n\r\n			let p = div n i\r\n\r\n			in if mod n i == 0\r\n\r\n			then if p == i \r\n\r\n				then res + i\r\n\r\n				else res + i + p\r\n\r\n			else res \r\n\r\n		) (-n) [1..((floor . sqrt . fromIntegral) n)]\r\n\r\n\r\n\r\nperfects n = [ i | i <- [1..n], i == sumDiv i]\r\n','<br/>Тесты успешно пройдены!'),(4860,63,'3598995','2013-10-19 12:05:28',2,'endlesslist i = i:endlesslist(10 * i + 1)\r\nones = endlesslist 1','<br/>Тесты успешно пройдены!'),(4859,61,'3598995','2013-10-19 11:34:27',1,'sumDiv n = sum[i | i <- [1..n `div` 2], n `mod` i == 0]\r\nperfects n = [i | i <- [2..n], sumDiv i == i]','<br/>Тесты успешно пройдены!'),(4857,52,'3598995','2013-10-18 23:29:19',1,'repeatFunk f n = let\r\n  --- У вас просто название функцмии не то, что в условии (repeatFunk, а надо repeatFunc)\r\n  --- Но ОК, засчитано.\r\n      xs1 = [1..n]\r\n      xs2 = map (\\_ -> f) xs1\r\n   in foldr (.) id xs2','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(4858,62,'3598995','2013-10-19 10:09:17',1,'denominators n = [i | i <- [1..n `div` 2], n `mod` i == 0]\r\nsumdiv = sum.denominators\r\namicables n = [(j, i) | i <- [1..n], let j = sumdiv i, j < i, sumdiv j == i]','<br/>Тесты успешно пройдены!'),(4855,56,'3598995','2013-10-18 23:18:47',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [x:xs | x<-[1..n], xs<-allLists n (k-1)]\r\n','<br/>Тесты успешно пройдены!'),(4856,52,'3598995','2013-10-18 23:26:09',0,'repeatFunk f n = foldr (.) id (map (const f) [1..n])','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(4854,140,'5337814','2013-10-18 17:52:13',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	triangle.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ntriangle :: Integer -> [(Integer, Integer)]\r\n\r\ntriangle 0 = [(0,0)]\r\n\r\ntriangle n \r\n\r\n		| n > 0 	= [(i, j) | i <- [0..n], j <- [0..(n - i)]]\r\n\r\n		| otherwise = [(i, j) | i <- [n..0], j <- [(n - i)..0]] \r\n\r\n\r\n\r\nones = [1..]\r\n\r\ntest = take 10 ones\r\n','<br/>Тесты успешно пройдены!'),(4852,52,'5337814','2013-10-18 17:51:35',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	repeatFunc.hs\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\nrepeatFunc f n = foldr (.) (x -> x) (replicate n f)\r\n\r\n\r\n\r\nf = repeatFunc sin 3\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4853,59,'5337814','2013-10-18 17:51:49',1,'/*	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	SelectWhere.cs\r\n\r\n*/	\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nclass SelectWhere\r\n\r\n{	\r\n\r\n	static void Main(string[] args)\r\n\r\n	{	\r\n\r\n		int[] a = {354, 20, 9, 31};\r\n\r\n		\r\n\r\n		a = nonZeroLastDigits(a);\r\n\r\n		\r\n\r\n		foreach (var item in a)\r\n\r\n			System.Console.Write(item + \" \");\r\n\r\n	}	\r\n\r\n	\r\n\r\n	static int[] nonZeroLastDigits(int[] a)\r\n\r\n	{	\r\n\r\n		return a.Select(x => (x % 10)).Where(x => (x % 10) != 0).ToArray();\r\n\r\n	}	\r\n\r\n}	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4848,137,'7475152','2013-10-16 23:44:39',2,'  --- В прниципе у вас неплохо, но у вас получается мало строчек.\r\n  --- chessboard 2 2 у вас получается\r\n  ---   [[1,1,0,0],[0,0,1,1]]\r\n  --- т.е. два списка по 4 элемента\r\n  --- а надо 4 списка по 4 элемента, как в условии.\r\n  --- Кроме того у вас самая левая верхняя клетка содержит 1, а надо 0.\r\n  --- Если хотите, могу немного подсказать, как это исправить? Если это имеет смысл, напишите (письмо). \r\n\r\nchessboard n k =  let help p =  map (const p) [1..k]\r\n                      my_line x y = if  (mod y 2)==0 then (help 0)++x else (help 1)++x\r\n                      my_line_inversion x y = if  (mod y 2)==0 then (help 1)++x else (help 0)++x\r\n		  in  map (i-> if (mod i 2)==0 then (foldl (my_line) [] [1..n])\r\n			        else (foldl (my_line_inversion )[] [1..n])\r\n			   )\r\n                     [1..n] 	','Выражение имеет неправильное значение: chessboard 2 2'),(4849,137,'21743638','2013-10-17 00:15:22',1,'chessboard n m = foldr (++) [] (map (k -> map (h -> foldr (++) [] (map (i -> map (j -> mod (i+k) 2) [1..m]) [1..n])) [1..m]) [1..n])\r\n\r\n\r\n\r\n--chessboard n = map (i -> map (j -> mod (i+j) 2) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(4850,140,'shkuratov.ilya','2013-10-18 10:36:56',1,'triangle n = \r\n\r\n	if n > 0\r\n\r\n	then [(x, y) | x <- [0..n], y <- [0..(-x + n)]]\r\n\r\n	else [(x, y) | x <- [n..0], y <- [(-x + n)..0]]\r\n','<br/>Тесты успешно пройдены!'),(4851,56,'shkuratov.ilya','2013-10-18 10:56:12',1,'allLists n 1 = [[i] | i <- [1..n]] \r\n\r\nallLists n k = [ i:j | i <- [1..n], j <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(4846,54,'25446179','2013-10-14 00:50:22',1,'data Scheme = Res Integer | parallel Scheme Scheme | successively Scheme Scheme\r\n   --- Засчитано, но вообще тут синтаксические ошибки.. Имена конструкторов\r\n   --- должны начинаться с заглавной буквы (Parallel, Successively)\r\n   --- (Кстати, мне это неважно, но successive - это \"успешный\" а тут вилимо лучше Sequatinal - \"последовательный\" :)\r\n\r\ntotalResistance (Res count) = fromIntegral count\r\n\r\ntotalResistance (parallel count1 count2) = let c1 = totalResistance count1 \r\n\r\n					       c2 = totalResistance count2 in (c1*c2)/(c1+c2) \r\n\r\ntotalResistance (successively count1 count2) = totalResistance count1 + totalResistance count2 	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4847,59,'21743638','2013-10-14 11:59:17',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace nonZeroLastDigits\r\n{\r\n    class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            int[] a = new int[] {354, 20, 9, 31};\r\n            int[] b = a.Select(x => x % 10).Where(x => x>0).ToArray();\r\n            for (int i = 0; i != b.Length; ++i) Console.Write(\"{0} \", b[i]);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(4844,138,'3598995','2013-10-13 23:22:58',1,'mymap :: (a -> b) -> [a] -> [b]\r\n\r\nmymap func [] = []\r\n --- Эта строка лишняя\r\nmymap func list = foldr (x xs -> (func x) : xs) [] list\r\n','<br/>Тесты успешно пройдены!'),(4845,138,'25446179','2013-10-13 23:48:57',1,'mymap f xs = let s = [] in foldr (i s-> f i:s) [] xs\r\n','<br/>Тесты успешно пройдены!'),(4843,139,'5337814','2013-10-13 23:02:09',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	transpose.hs\r\n\r\n-}\r\n\r\n\r\n\r\ntranspose :: [[Integer]] -> [[Integer]]\r\n\r\ntranspose [[]] = [[]]\r\n\r\ntranspose xs = foldr (zipWith (:)) (repeat []) xs\r\n\r\n\r\n\r\ntest = transpose [[1,2,3],[4,5,6],[7,8,9]]\r\n','<br/>Тесты успешно пройдены!'),(4842,54,'5337814','2013-10-13 23:01:39',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	scheme.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ntype Ohm = Double\r\n\r\n\r\n\r\ndata Scheme =   Resistor Ohm\r\n\r\n			  | Series [Scheme]\r\n\r\n			  | Parallel [Scheme] \r\n\r\n			deriving (Eq)\r\n\r\n\r\n\r\ntotalResistance (Resistor o) = o\r\n\r\ntotalResistance (Series (xs)) = ((sum . (map ((1.0*) . totalResistance))) (xs))\r\n\r\ntotalResistance (Parallel (xs)) =  (1.0 / ((sum . (map ((1.0/) . totalResistance))) (xs)))\r\n\r\n\r\n\r\ntest0 = totalResistance (Resistor 4.0)\r\n\r\ntest1 = totalResistance (Series ([Resistor 4.0, Resistor 4.0]))\r\n\r\ntest2 = totalResistance (Parallel ([Resistor 4.0, Resistor 4.0]))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4840,139,'3598995','2013-10-13 22:44:50',1,'transpose ([]:_) = []\r\n\r\ntranspose m = map head m: transpose (map tail m)\r\n','<br/>Тесты успешно пройдены!'),(4841,138,'5337814','2013-10-13 23:01:21',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	mymap.hs\r\n\r\n-}	\r\n\r\n\r\n\r\n\r\n\r\nmymap f xs = foldr (z zs -> (f z) : zs) [] xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4839,139,'3598995','2013-10-13 22:44:25',0,'','Не удалось вычислить выражение \"transpose [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(4836,54,'21743638','2013-10-13 21:31:26',1,'data Sheme = Format Integer | Parall Sheme Sheme | Seq Sheme Sheme\r\n\r\ntotalResistance (Format r) = fromIntegral r\r\n\r\ntotalResistance (Parall r1 r2) = let {l = totalResistance r1; z = totalResistance r2} in (l*z)/(z+l)\r\n\r\ntotalResistance (Seq r1 r2) = totalResistance r1 + totalResistance r2\r\n','<br/>Тесты успешно пройдены!'),(4837,52,'57304539','2013-10-13 22:11:24',1,'{-comment\r\n\r\n-}\r\n\r\nidf x = x\r\n  --- Есть такая стандартная функция id и можно ее использовать\r\nrepeatFunc f 0 = idf\r\n\r\n--repeatfunc f 1 = f\r\n\r\nrepeatFunc f n = foldr (.) idf (map (i->f) [1..n])\r\n','<br/>Тесты успешно пройдены!'),(4838,53,'25446179','2013-10-13 22:38:41',1,'coins n = [[k,l,m] |k <- [0..n], l<-[0..n], m<-[0..n], k*2+l*3+m*5 == n]\r\n','<br/>Тесты успешно пройдены!'),(4835,139,'SMakarov','2013-10-13 20:43:49',1,'makeList [] list = list\r\nmakeList (xs:xss) list = makeList xss (list ++ [head xs])\r\nreduce [] yss = yss\r\nreduce (xs:xss) yss = reduce xss (yss ++ [tail xs])\r\nf xss ans = if (head xss == []) then ans else f (reduce xss []) (ans ++ [(makeList xss [])])\r\ntranspose xss = f xss []','<br/>Тесты успешно пройдены!'),(4833,138,'SMakarov','2013-10-13 18:19:35',1,'mymap oper xs = foldr (x ys -> oper x : ys) [] xs','<br/>Тесты успешно пройдены!'),(4834,54,'SMakarov','2013-10-13 19:50:09',1,'data Scheme = Res Double | Parallel Scheme Scheme | Consecutive Scheme Scheme\r\ntotalResistance (Res resistance) = resistance\r\ntotalResistance (Parallel s1 s2) = ((totalResistance s1) * (totalResistance s2))/((totalResistance s1) + (totalResistance s2))\r\ntotalResistance (Consecutive s1 s2) = (totalResistance s1) + (totalResistance s2)','<br/>Тесты успешно пройдены!'),(4832,53,'SMakarov','2013-10-13 17:49:04',1,'coins n = [[k,l,m] | k <- [0..n], l <- [0..n], m <- [0..n], k*2 + l*3 + m*5 == n]','<br/>Тесты успешно пройдены!'),(4831,141,'7475152','2013-10-12 19:08:01',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace training\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\n\r\n            var n = arr.Aggregate(0, (sum, elem) => sum +=Convert.ToInt32(elem[0] == \'a\'));\r\n\r\n            Console.WriteLine(n);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4830,139,'7475152','2013-10-12 18:31:51',1,'split2ofX x y = (head x):y\r\ntransHelp _  rest 0 = reverse rest\r\ntransHelp xs rest n = transHelp (map (x->tail x) xs) ((foldr(split2ofX) [] xs):rest) (n-1)\r\ntranspose xs = transHelp xs [] (length xs) \r\n--наверняка можно было сделать это как-нибудь попроще.но пока не додумалась;(\r\n  --- ОК, очень хорошо, я бы только  тут не использовал хвостовую рекурсию,\r\n  --- тогда бы не нужен был reverse. Ну и вместо foldr, мне кажется,\r\n  --- можно написать map. Ну, мы это обсудим.','<br/>Тесты успешно пройдены!'),(4829,136,'57304539','2013-10-11 22:36:56',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace HW81\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static bool check(int[] a)\r\n\r\n        {\r\n\r\n            return a.Any(y => y == 7);\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            const int size = 5;\r\n\r\n            int[] a = new int[size];\r\n\r\n\r\n\r\n            for (int i = 0; i < size; i++)\r\n\r\n            {\r\n\r\n                Console.Write(\"a[\"+i+\"] := \");\r\n\r\n                a[i] = int.Parse(Console.ReadLine());\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine(check(a) ? \"Yes\" : \"No\");\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4825,136,'25446179','2013-10-10 20:42:12',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace AnyMethod\r\n{\r\n    class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            int[] Array = { 1, 3, 5, 7, 9};\r\n            bool result = Array.Any(y => (y == 7) == true);\r\n    --- или просто bool result = Array.Any(y => y == 7); \r\n            Console.WriteLine(\r\n                    result ? \"Yes\" : \"No\");\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(4826,134,'25446179','2013-10-10 20:43:09',1,'data Tree = Empty| Node Integer Tree Tree\r\n\r\nminTree (Node val Empty _) = val\r\n\r\nminTree (Node val l r) = minTree l\r\n','<br/>Тесты успешно пройдены!'),(4827,54,'shkuratov.ilya','2013-10-10 21:09:19',1,'data Scheme = Resistance Float |\r\n\r\n	Parallel Scheme Scheme |\r\n\r\n	Conseq Scheme Scheme\r\n\r\n\r\n\r\ntotalResistance (Resistance r)= r\r\n\r\ntotalResistance (Parallel s1 s2) = \r\n\r\n	let\r\n\r\n	r1 = totalResistance s1\r\n\r\n	r2 = totalResistance s2\r\n\r\n	in r1 * r2 / (r1 + r2)\r\n\r\ntotalResistance (Conseq s1 s2) = \r\n\r\n	totalResistance s1 + totalResistance s2\r\n','<br/>Тесты успешно пройдены!'),(4828,139,'shkuratov.ilya','2013-10-10 23:16:46',1,'zip\' [] _ = []\r\n\r\nzip\' _ [] = []\r\n\r\nzip\' (x:xs) (y:ys) = (x : y) : zip\' xs ys\r\n  --- Просто как вариант, это можно было записать, через zip и map.\r\n  --- Еще, на самом деле, есть такая стандартная функция zipWith которая соединяет с помощью указанной фунцкии\r\n  --- и с ней можно написать zipWith (:)\r\n  --- Еще, забегая вперед, можно применить бесконечные списки, которые мы еще не проходили, и тогда получится так:\r\n  ---   foldr (zipWith (:)) [[] | x <- [1..]] xss\r\n\r\n\r\ntranspose xss = \r\n\r\n	--foldr (zip\') ( map (const []) [1..(max (length xss) (length (head xss)))] ) xss\r\n\r\n	foldr (zip\') [[] | x <- [1..(max (length xss) ((length . head) xss))]] xss','<br/>Тесты успешно пройдены!'),(4824,138,'shkuratov.ilya','2013-10-10 20:29:38',1,'mymap f = foldr (i -> ((f i) : )) []\r\n','<br/>Тесты успешно пройдены!'),(4823,54,'7475152','2013-10-10 20:20:46',1,'data Scheme = Resist  Float|\r\n	      ParallelS Scheme Scheme|\r\n	      SerialS Scheme Scheme\r\n\r\ntotalResistance (Resist r) = r\r\ntotalResistance (SerialS r1 r2) = (totalResistance r1) + (totalResistance r2)\r\ntotalResistance (ParallelS r1 r2) =let a = (totalResistance r1)\r\n				       b = (totalResistance r2)\r\n				   in   (a*b)/(a+b) ','<br/>Тесты успешно пройдены!'),(4821,53,'shkuratov.ilya','2013-10-10 20:19:53',0,'coin n = \r\n\n	[[k, l, m] |\r\n\n	m <- [0..div n 5],	\r\n\n	l <- [0..div (n - m * 5) 3],\r\n\n	k <- [0..div (n - m * 5 - l * 3) 2],\r\n\n	k * 2 + l * 3 + m * 5 == n ]\n','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(4822,53,'shkuratov.ilya','2013-10-10 20:20:36',1,'coins n = \r\n\r\n	[[k, l, m] |\r\n\r\n	m <- [0..div n 5],	\r\n\r\n	l <- [0..div (n - m * 5) 3],\r\n\r\n	k <- [0..div (n - m * 5 - l * 3) 2],\r\n   --- Очень хорошо, но в это месте легко можно еще оптимизировать, мы это обсудим. \r\n	k * 2 + l * 3 + m * 5 == n ]\r\n','<br/>Тесты успешно пройдены!'),(4820,59,'shkuratov.ilya','2013-10-10 19:19:43',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Homework14_1\r\n\r\n{\r\n\r\n    class First\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] array = new int [] { 1, 4, 21, 40, 15 };\r\n\r\n            var result = array.Select(x => x % 10).Where(x => x != 0);\r\n\r\n            foreach (var item in result)\r\n\r\n            {\r\n\r\n                System.Console.Write(item + \" \");\r\n\r\n            }\r\n\r\n            System.Console.Read();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4819,136,'SMakarov','2013-10-10 18:51:41',1,'static void Main(string[] args)\r\n        {\r\n            int[] arr = new int[] { 1, 3, 7 };\r\n            bool hasSeven = arr.Any(item => item == 7);\r\n            Console.WriteLine(\"{0}\",\r\n                    hasSeven ? \"Да\" : \"Нет\");\r\n            Console.ReadKey();\r\n        }','<br/>Тесты успешно пройдены!'),(4818,135,'SMakarov','2013-10-10 18:43:16',1,'data Tree = Empty | Node Integer Tree Tree\r\nf (Node val Empty Empty) min = if val <= 0 then min else val\r\nf (Node val Empty r) min = if val <= 0 then f r min else val\r\nf (Node val l Empty) min = if val <= 0 then min else f l val\r\n   --- Просто как замечание, эти три правила, на самом деле, можно заменить на одно для Empty.\r\nf (Node val l r) min = if val <= 0 then f r min else f l val\r\nminPosTree (Node val l r) = f (Node val l r) 0','<br/>Тесты успешно пройдены!'),(4817,135,'SMakarov','2013-10-10 18:30:21',0,'data Tree = Empty | Node Integer Tree Tree\r\nf (Node val Empty r) min = min\r\nf (Node val l r) min = if val <= 0 then min else f l val\r\nminPosTree (Node val l r) = f (Node val l r) 0','Выражение имеет неправильное значение: minPosTree (Node 5 (Node (-2) Empty (Node 3 Empty Empty)) (Node 7 Empty Empty))'),(4813,53,'7475152','2013-10-10 16:48:23',0,'coins n = [(x,y,z)| x<-[0..n],y<-[0..n],z<-[0..n] ,x*2+y*3+z*5==n]\r\n','Выражение имеет неправильное значение: coins 2'),(4814,53,'7475152','2013-10-10 16:49:43',1,'coins n = [[x,y,z]| x<-[0..n],y<-[0..n],z<-[0..n] ,x*2+y*3+z*5==n]','<br/>Тесты успешно пройдены!'),(4815,138,'7475152','2013-10-10 16:57:52',1,'mymap f xs = foldr (x res-> (f x):res) [] xs','<br/>Тесты успешно пройдены!'),(4816,134,'SMakarov','2013-10-10 18:22:44',1,'data Tree = Empty | Node Integer Tree Tree\r\nminTree (Node val Empty r) = val\r\nminTree (Node val l r) = minTree l','<br/>Тесты успешно пройдены!'),(4812,140,'517309','2013-10-10 14:02:33',3,'triangle n = [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(2,0),(2,1),(3,0)]','<br/>Тесты успешно пройдены!'),(4811,140,'517309','2013-10-10 14:00:22',0,'triangle n =  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(2,0),(2,1),(3,0)]','Не удалось вычислить выражение \"element (2,1) (triangle 3)\", проверьте правильность синтаксиса'),(4810,135,'5337814','2013-10-10 00:08:01',1,'﻿{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	minPosTree.hs\r\n\r\n	\r\n\r\n---Да, идея возникла в ходе обсуждения решения задачи с Ольгой.\r\n\r\n---Идея принадлежит Ольге, однако её реализацию я не видел, и всего лишь ориентировался на нахождения минимума в поддереве.\r\n\r\n---В таком случае вы в праве не засчитывать мне эту задачу.\r\n\r\n-}	\r\n--- ОК, идеи обсуждать можно, и действительно видно, что писали вы не вместе. \r\n--- Так что засчитано, хорошо. \r\n\r\n\r\n\r\n\r\ndata Tree = Node Int Tree Tree | Empty\r\n\r\n			deriving Eq\r\n\r\n\r\n\r\nminPosTree :: Tree -> Int\r\n\r\nminPosTree Empty = maxBound :: Int\r\n\r\nminPosTree (Node val l r)\r\n\r\n			| (val >= 0)   = minimum [val, minPosTree l]\r\n\r\n			| otherwise    = minimum [minPosTree r]\r\n\r\n\r\n\r\n--test = minPosTree (Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))\r\n\r\n--test = minPosTree (Node (5) (Node (-2) (Node (-3) Empty Empty) (Node (1) Empty Empty)) (Node 7 (Node 1 Empty Empty) Empty))\r\n\r\ntest = minPosTree (Node 5 (Node (-2) Empty (Node (3) Empty Empty)) (Node 7 Empty Empty))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4809,135,'3598995','2013-10-10 00:06:13',1,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\n\r\nminPosTree :: (Num a,Ord a) => Tree a -> a\r\n\r\nminPosTree Empty = 2^29-1\r\n\r\nminPosTree (Node a left right) = if (a>0)\r\n\r\nthen minimum[minPosTree(left),a]\r\n\r\nelse minPosTree(right)','<br/>Тесты успешно пройдены!'),(4808,135,'57304539','2013-10-09 23:43:47',2,'{-comment\r\n\r\n-}\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nchildIsPos (Node key _ _) = key > 0\r\n\r\nchildIsPos Empty = False\r\n\r\n\r\n\r\nminPosTree (Node key l r) = minPosTree\' l key False\r\n\r\nminPosTree Empty = -1\r\n\r\n\r\n\r\nminPosTree\' (Node key l r) min toRight = if not toRight then \r\n\r\n							if childIsPos l then minPosTree\' l key False\r\n--- Такая проверка не подойдет, к сожалению - ведь положительным\r\n--- может быть не прямой потомок, а внук или правнук.\r\n--- Могу немного подказать: нав вель всегда понятно куда надо идти по дереву\r\n--- - для положительных влево а для отрицательгых вправо. Но только\r\n---   при этом ответ мы не обязательно найдм в самом конце, потому что в конце мб\r\n---   отрицательные числа. Надо придумать, как справится с этой проблемой,\r\n---   и это, мне кажется, несложно. \r\n						         	 	 else minPosTree\' l key True\r\n\r\n							else \r\n\r\n							if childIsPos r then minPosTree\' r min False\r\n\r\n							 		 else min\r\n\r\nminPosTree\' (Empty) min _ = min\r\n\r\n\r\n\r\ntest = minPosTree (Node 5 (Node (-2) Empty (Node 3 Empty Empty)) (Node 7 Empty Empty))\r\n','Выражение имеет неправильное значение: minPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))'),(4807,135,'57304539','2013-10-09 22:54:02',0,'{-comment\r\n\n-}\r\n\ndata Tree = Node Integer Tree Tree | Empty\r\n\n\r\n\nchildIsPos (Node key _ _) = key > 0\r\n\nchildIsPos Empty = False\r\n\n\r\n\nminPosTree (Node key l r) = minPosTree\' l key\r\n\nminPosTree Empty = -1\r\n\n\r\n\nminPosTree\' (Node key l r) min = if childIsPos l then minPosTree\' l key\r\n\n						 else min\r\n\nminPosTree\' (Empty) min = min\r\n\n\r\n\ntest = minPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))\n','Выражение имеет неправильное значение: minPosTree (Node 5 (Node (-2) Empty (Node 3 Empty Empty)) (Node 7 Empty Empty))'),(4805,135,'3598995','2013-10-08 22:40:21',2,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\n\r\nminPosTree :: (Num a,Ord a) => Tree a -> a\r\n\r\nminPosTree Empty = 2^29-1\r\n\r\nminPosTree (Node a left right) = if (a>0)\r\n\r\nthen minimum[minPosTree(left),a,minPosTree(right)]\r\n  --- Ваше решение дает правильные результаты, но оно немного недостаточно оптимальное.\r\n  --- Зачем же тут обходить правое поддерево? Там значения точно больше a \r\n\r\nelse minimum[minPosTree(right)]\r\n			| otherwise    = minimum [minPosTree r]\r\n  --- Ну и тут, конечно, минимум из одного элемента искать нет смысла.\r\n  --- Это просто, но исправьте эти замечания, пожалуйста \r\n  --- Еще один вопрос, ваше решение практически совпало с решением еще одного участника.\r\n  --- Это вполне может быть совпадением, хотя решение довольно необычное.\r\n  --- Но мб я эту задачу попрошу воспризывести/обьяснить на зачете - на всякий случай имейте это,\r\n  --- пожалуйста, в виду. \r\n','<br/>Тесты успешно пройдены!'),(4806,135,'5337814','2013-10-09 17:19:02',2,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	minPosTree.hs\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\ndata Tree = Node Int Tree Tree | Empty\r\n\r\n			deriving Eq\r\n\r\n\r\n\r\nminPosTree :: Tree -> Int\r\n\r\nminPosTree Empty = maxBound :: Int\r\n\r\nminPosTree (Node val l r)\r\n\r\n			| (val >= 0)    = minimum [val, minPosTree l, minPosTree r]\r\n  --- Ваше решение дает правильные результаты, но оно немного недостаточно оптимальное.\r\n  --- Зачем же тут обходить правое поддерево? Там значения точно больше val \r\n			| otherwise    = minimum [minPosTree r]\r\n  --- Ну и тут, конечно, минимум из одного элемента искать нет смысла.\r\n  --- Это просто, но исправьте эти замечания, пожалуйста \r\n  --- Еще один вопрос, ваше решение практически совпало с решением еще одного участника.\r\n  --- Это вполне может быть совпадением, хотя решение довольно необычное.\r\n  --- Но мб я эту задачу попрошу воспризывести/обьяснить на зачете - на всякий случай имейте это,\r\n  --- пожалуйста, в виду. \r\n\r\n\r\n--test = minPosTree (Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))\r\n\r\n--test = minPosTree (Node (5) (Node (-2) (Node (-3) Empty Empty) (Node (1) Empty Empty)) (Node 7 (Node 1 Empty Empty) Empty))\r\n\r\ntest = minPosTree (Node 5 (Node (-2) Empty (Node (3) Empty Empty)) (Node 7 Empty Empty))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4804,135,'3598995','2013-10-08 22:30:39',0,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\n\nminPosTree :: (Num a,Ord a) => Tree a -> a\r\n\nminPosTree Empty = 99999999\r\n\nminPosTree (Node a left right) = if (a>0)\r\n\nthen minimum[minPosTree(left),a,minPosTree(right)]\r\n\nelse minimum[minPosTree(right)]\n','<br/>Тесты успешно пройдены!'),(4802,137,'shkuratov.ilya','2013-10-08 21:44:44',1,'chessboard n m = \r\n\r\n	let\r\n\r\n	size = n * m\r\n\r\n	grid = (`mod` 2) . (`div`  m) . (+ (-1))\r\n\r\n	even = map grid [1..size]\r\n\r\n	odd = map (abs . (+ (-1))) even\r\n\r\n	in \r\n\r\n		map (\r\n\r\n			i -> \r\n\r\n				if grid i == 0 \r\n\r\n				then even \r\n\r\n				else odd\r\n\r\n			) [1..size]\r\n','<br/>Тесты успешно пройдены!'),(4803,134,'57304539','2013-10-08 22:23:20',1,'{-comment\r\n\r\n-}\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nminTree (Node key l r) = minTree\' l key\r\n\r\nminTree Empty = -1\r\n\r\n\r\n\r\nminTree\' (Node key l r) min = minTree\' l key\r\n\r\nminTree\' (Empty) min = min\r\n\r\n\r\n\r\ntest = minTree(Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) \r\n','<br/>Тесты успешно пройдены!'),(4800,138,'21743638','2013-10-08 20:45:24',1,'mymap f xs = foldr (i ys-> f i: ys) [] xs\r\n','<br/>Тесты успешно пройдены!'),(4801,53,'21743638','2013-10-08 21:28:12',1,'coins n = [ [k,l,m] | k <-[0..n], l<-[0..n], m<-[0..n], n == k*2+l*3+m*5 ]\r\n','<br/>Тесты успешно пройдены!'),(4798,139,'517309','2013-10-08 11:28:39',3,'transpose xss = [[1,4,7],[2,5,8],[3,6,9]]','<br/>Тесты успешно пройдены!'),(4799,136,'shkuratov.ilya','2013-10-08 19:19:22',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Homework11_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] array = new int[] { 1, 2, 4, 8, 9, 7 };\r\n\r\n            System.Console.WriteLine(array.Any(x => x == 7));\r\n\r\n            array = new int[] { 1, 3, 4, 5 };\r\n\r\n            System.Console.WriteLine(array.Any(x => x == 7));\r\n\r\n            System.Console.Read();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4797,43,'SMakarov','2013-10-07 04:37:47',2,'--На некоторых парах чисел работает - 3 5, 5 7, 7 3, 7 11. На некоторых - 3 11, 25 33 не работает. Не знаю почему. Причем на бумаге расширенным алгоритмом Евклида решение для например 3 11 тоже не получается найти (подошло бы например -37 10)\r\n  --- Ну у вас просто не совсем правильный алгоритм, мне кажется.\r\n  --- При рекурсивном вызове надо ведь вместо a b использовать b (mod a b)\r\n  --- И все-таки я не зачту, длядоп. задач тесты должны проходить..\r\n  --- Но ничего, задач еще будет много :)    \r\nnod a 0 = a\r\nnod a b = nod b (mod a b)\r\ng a b x y = if not (nod a b == 1) then (0,0) else if a < b then f2 b a x y else f1 a b x y\r\nf1 a b x y = if a*x + b*y == 1 || a*(-x) + b*(-y) == 1 || a*x + b*(-y) == 1 || a*(-x) + b*y == 1 then (x,y) else f1 a b y (x - y*(quot a b))\r\nf2 a b x y = if a*x + b*y == 1 || a*(-x) + b*(-y) == 1 then (y,x) else f2 a b y (x - y*(quot a b))\r\neuclid a b = g a b 1 0','Не удалось вычислить выражение \"let (x,y) = euclid 33 25 in 33*x+25*y\", проверьте правильность синтаксиса'),(4796,40,'6205237','2013-10-07 02:17:37',1,'\r\nframe n = ( (map (const 1) [1..n]) : (map (const( (1 : ((map (const 0) [2..n-1])  ++ [1]) ) )  ) [2..n-1]) ) ++ [(map (const 1) [1..n])]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4790,51,'6205237','2013-10-06 22:49:19',1,'\r\nf = repeatFunc sin 3\r\n\r\n\r\n\r\nrepeatFunc y 1 = y\r\n\r\nrepeatFunc y n = (repeatFunc y (n-1)).y\r\n\r\n\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(4791,41,'SMakarov','2013-10-06 23:19:26',1,'g x y = x `mod` 2 + y \r\ncountOdd xs = foldr (g) 0 xs\r\nf xs = foldr (+) 0 xs\r\ncountOdd1 xs = foldr (+) 0 (map (`mod` 2) xs)','<br/>Тесты успешно пройдены!'),(4792,51,'SMakarov','2013-10-06 23:22:58',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = repeatFunc (f . f) (n - 1)','Выражение имеет неправильное значение: (repeatFunc (*2) 3) 1'),(4793,51,'SMakarov','2013-10-06 23:39:44',1,'repF f f1 1 = f\r\nrepF f f1 n = repF (f . f1) f1 (n - 1)\r\nrepeatFunc f n = repF f f n','<br/>Тесты успешно пройдены!'),(4794,42,'6205237','2013-10-07 01:07:42',1,'\r\nmyfoldl f s [] = s\r\n\r\nmyfoldl f s (x:xs) = myfoldl f (s `f` x) xs  \r\n','<br/>Тесты успешно пройдены!'),(4795,41,'6205237','2013-10-07 01:46:37',1,'\r\ncountOdd xs = foldr (x y-> y + (mod x 2)) 0 xs\r\n\r\ncountOdd1 xs = sum (map (i->mod i 2) xs)\r\n','<br/>Тесты успешно пройдены!'),(4789,42,'25446179','2013-10-06 21:37:45',1,'myfoldl f y [] = y\r\n\r\nmyfoldl f y (x:xs) = myfoldl f (f y x) xs\r\n','<br/>Тесты успешно пройдены!'),(4788,43,'6205237','2013-10-06 20:14:12',1,'\r\n\r\n\r\neuclid 1 0 = (1,0)\r\n\r\neuclid a b = f a b ((1,0),(0,1)) (div a b) (mod a b) \r\n\r\n\r\n\r\nmult e q = ( (fst(snd e), snd(snd e)) , ( fst(fst e)+ (fst(snd e))*q , snd(fst e) + snd(snd e)*q ) )\r\n\r\n \r\n\r\nf a b e q 0 = snd e\r\n\r\n\r\n\r\n		\r\n\r\nf a b e q r = f b r ( mult e (-q) ) (div b r) (mod b r) \r\n','<br/>Тесты успешно пройдены!'),(4786,134,'21743638','2013-10-06 19:26:40',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminTree (Node val Empty _) = val\r\n\r\nminTree (Node val l r) = minTree l\r\n','<br/>Тесты успешно пройдены!'),(4787,135,'21743638','2013-10-06 20:02:36',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminPosTree (Node val l r) = fun (Node val l r) val\r\n\r\nfun (Node val Empty Empty) v = if val>0 then val else v\r\n\r\nfun (Node val l r) v = if val>0 then fun l val else fun r v\r\n','<br/>Тесты успешно пройдены!'),(4784,40,'5337814','2013-10-06 18:20:47',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	frame.hs\r\n\r\n-}	\r\n\r\n\r\n\r\nframe 0 = [[]]\r\n\r\nframe n = map (i -> map (j -> if (i == 1) || (i == n) || (j == 1) || (j == n) \r\n\r\n								then 1\r\n\r\n								else 0) [1..n]) [1..n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4785,41,'21743638','2013-10-06 18:53:05',2,'fun [] ys = ys\r\n\r\nfun (x:xs) ys = fun xs ((x `mod` 2):ys)\r\n  --- Первая часть не по условию, в countOdd нельзя использовать свои рекурсивные функции\r\n  --- В ней надо, на самом деле просто вызвать foldr и передать ему правильное лямбда выражение  \r\ncountOdd xs = foldr (+) 0 (fun xs [])\r\n\r\n\r\n\r\ncountOdd1 xs = foldr (+) 0 (map(x -> x `mod` 2) xs)\r\n','<br/>Тесты успешно пройдены!'),(4783,41,'5337814','2013-10-06 18:20:31',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	countOdd.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ncountOdd [] = 0\r\n  --- Правила для [] оба раза не нужны, и без них все будет работать\r\ncountOdd (x:xs) = foldr (x i -> if (x `mod` 2 == 1) then i + 1 else i) 0 (x:xs)\r\n\r\n\r\n\r\ncountOdd1 [] = 0\r\n\r\ncountOdd1 (x:xs) = length $ filter odd (x:xs)\r\n\r\n\r\n\r\n--test = countOdd [3, 3, 4, 8, 5, 33, 9]\r\n\r\n--test1 = countOdd1 [3, 3, 4, 8, 5, 33, 9]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4781,42,'21743638','2013-10-06 17:29:05',0,'myfoldl f e [] = e\r\n\nmyfoldl f e (x:xs) = myfoldl f (e+x) xs\n','Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),(4782,42,'21743638','2013-10-06 17:30:51',1,'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (e `f` x) xs\r\n','<br/>Тесты успешно пройдены!'),(4780,42,'21743638','2013-10-06 17:00:10',0,'fold f [x] = x\r\n\nfold f (x:xs) = x `f` (fold f xs)\r\n\nmyfoldl f e xs = e `f` (fold f xs)\n','Не удалось вычислить выражение \"myfoldl (+) 10 []\", проверьте правильность синтаксиса'),(4779,59,'7475152','2013-10-06 14:37:07',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace nonZeroLastDigits_func\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<int> nonZeroLastDigits(int[] array)\r\n\r\n        {           \r\n\r\n            return array.Where(elem => elem % 10 != 0).Select(elem => elem % 10);\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] arr = {354, 20, 9, 31};\r\n\r\n            IEnumerable<int> newArr = nonZeroLastDigits(arr);\r\n\r\n            foreach (int i in newArr)\r\n\r\n                Console.Write(\" \"+i);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4778,52,'7475152','2013-10-06 14:09:11',1,'repeatFunc f n = foldr (.) f (map (x->f) [1..(n-1)])','<br/>Тесты успешно пройдены!'),(4777,51,'7475152','2013-10-06 13:51:29',1,'repeatFunc f 1 = f\r\nrepeatFunc f n = f.(repeatFunc f (n-1))','<br/>Тесты успешно пройдены!'),(4775,51,'shkuratov.ilya','2013-10-06 00:04:00',1,'repeatFunc f 1 x = f x\r\n\r\nrepeatFunc f n x = f (repeatFunc f (n - 1) x)\r\n\r\n\r\n\r\ng = repeatFunc sin 3\r\n','<br/>Тесты успешно пройдены!'),(4776,52,'shkuratov.ilya','2013-10-06 00:24:20',1,'repeatFunc f n x = foldr (g x -> f x) x [1..n]\r\n\r\n\r\n\r\ng = repeatFunc (sin) 3\r\n','<br/>Тесты успешно пройдены!'),(4773,41,'shkuratov.ilya','2013-10-05 23:41:14',1,'countOdd xs = foldr (i j -> j + (mod i 2)) 0 xs\r\n\r\ncountOdd1 xs = sum (map (i -> mod i 2) xs)\r\n','<br/>Тесты успешно пройдены!'),(4774,42,'shkuratov.ilya','2013-10-05 23:50:20',1,'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n','<br/>Тесты успешно пройдены!'),(4771,40,'3598995','2013-10-05 21:48:58',1,'frame n = map (i -> map (j -> if j == 1 || j == n || i == 1 || i == n then 1 else 0) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(4772,40,'shkuratov.ilya','2013-10-05 23:07:44',1,'\r\nframe n = \r\n\r\n	map (x -> \r\n\r\n		map (\r\n\r\n			if (x == 1) || (x == n) \r\n\r\n			then const 1 \r\n\r\n			else \r\n\r\n				(y -> \r\n\r\n					if (y == 1) || (y == n) \r\n\r\n					then 1 \r\n\r\n					else 0\r\n\r\n				) \r\n\r\n			)[1..n]\r\n\r\n		) [1..n]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4770,134,'3598995','2013-10-05 21:11:16',1,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\n\r\ntreeToList :: Ord a => Tree a -> [a]  \r\n\r\ntreeToList Empty = []  \r\n\r\ntreeToList (Node a left right) = treeToList (left) ++ [a] ++ treeToList (right) \r\n\r\nminTree a = head(treeToList a)\r\n','<br/>Тесты успешно пройдены!'),(4769,134,'3598995','2013-10-05 21:10:54',0,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\n\ntreeToList :: Ord a => Tree a -> [a]  \r\n\ntreeToList Empty = []  \r\n\ntreeToList (Node a left right) = treeToList (left) ++ [a] ++ treeToList (right) \r\n\nminTree a = head(treeToList a)\n','<br/>Тесты успешно пройдены!'),(4768,134,'3598995','2013-10-05 21:09:26',0,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\n\ntreeToList :: Ord a => Tree a -> [a]  \r\n\ntreeToList Empty = []  \r\n\ntreeToList (Node a left right) = treeToList (left) ++ [a] ++ treeToList (right) \r\n\nminTree a = head(treeToList a)\n','Не удалось вычислить выражение \"minTree(Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty))\", проверьте правильность синтаксиса'),(4767,134,'3598995','2013-10-05 21:08:40',0,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\r\n\ntreeToList :: Ord a => Tree a -> [a]  \r\n\ntreeToList Empty = []  \r\n\ntreeToList (Node a left right) = treeToList (left) ++ [a] ++ treeToList (right) \r\n\nminTree a = head(treeToList a)\n','Не удалось вычислить выражение \"minTree(Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty))\", проверьте правильность синтаксиса'),(4766,42,'SMakarov','2013-10-05 20:15:16',1,'myfoldl oper n [] = n\r\nmyfoldl oper n (x:xs) = myfoldl oper (oper n x) xs','<br/>Тесты успешно пройдены!'),(4764,42,'7475152','2013-10-05 18:41:37',1,'myfoldl f y [] = y\r\nmyfoldl f y (x:xs) =  myfoldl f (f y x) xs','<br/>Тесты успешно пройдены!'),(4765,40,'SMakarov','2013-10-05 19:31:22',1,'makeList xs b 0 n = xs\r\nmakeList xs b k n = if k == 1 || k == n || b then makeList (xs ++ [1]) b (k - 1) n else makeList (xs ++ [0]) b (k - 1) n\r\nf xs 0 n = xs\r\nf xs k n = if k == n || k == 1 then f (xs ++ [makeList [] True n n]) (k - 1) n else f (xs ++ [makeList [] False n n]) (k - 1) n\r\nframe n = f [] n n','<br/>Тесты успешно пройдены!'),(4762,41,'7475152','2013-10-05 18:28:17',1,'rest x y = mod x 2 + y  \r\ncountOdd xs = foldr (rest) 0 xs\r\n\r\ncountOdd1 xs = sum (map (x->mod x 2) xs)','<br/>Тесты успешно пройдены!'),(4763,42,'7475152','2013-10-05 18:40:34',0,'myfoldl f y [] = y\r\nmyfoldl f y (x:xs) =  myfoldl f (f x y) xs','Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),(4761,45,'SMakarov','2013-10-05 17:33:52',1,'static void Main(string[] args)\r\n        {\r\n            int[][] arr = new int[3][];\r\n            arr[0] = new int[] { 2, 4, 6, 8, 10 };\r\n            arr[1] = new int[] { 2, 5, 4, 6 };\r\n            arr[2] = new int[] { 11, 22 };\r\n            bool b = arr.All(x => x.Any(y => y % 2 == 0));\r\n            Console.WriteLine(b.ToString());\r\n            Console.ReadKey();\r\n        }','<br/>Тесты успешно пройдены!'),(4760,45,'25446179','2013-10-04 23:21:27',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace AnyMethod\r\n{\r\n    class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            int[][] Array = { new int[]{ 1, 3, 5, 7, 9 }, new int[]{ 0, 2, 4, 6 }, new int[]{ 11, 22 } };\r\n            bool result = Array.All(x=>x.Any(y => (y % 2) == 0) == true);\r\n   --- == true - лишнее, можно просто Array.All(x=>x.Any(y => (y % 2) == 0));  \r\n            Console.WriteLine(result);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(4759,134,'21743638','2013-10-04 20:42:35',2,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminTree (Node val Empty _) = val\r\n\r\nminTree (Node val l r) = min val (minTree l)\r\n   --- Да нет, еще проще :) Ведь minTree l точно меньше val (в l все элементы меньше val).\r\n   --- Значит, и min тут не нужен. Это совсем просто, но исправьте это, пожалуйста. ','<br/>Тесты успешно пройдены!'),(4758,43,'shkuratov.ilya','2013-10-04 19:17:14',1,'div_rest a 0 = (0, a)\r\n\r\ndiv_rest a b = (quotient, rest)\r\n\r\n	where \r\n\r\n		quotient = div a b\r\n\r\n		rest = a - b * quotient\r\n\r\n\r\n\r\neuclid a b = \r\n\r\n	euclid\' b rest [(rest, 1, -quotient), (0, 0, 1)]\r\n\r\n	where (quotient, rest) = div_rest a b\r\n\r\n\r\n\r\neuclid\' a b ((1, k, q):xs) = (k, q)\r\n\r\neuclid\' a b ((r1, k1, q1):(r0, k0, q0):xs) = \r\n\r\n	let\r\n\r\n	(quotient, rest) = div_rest a b\r\n\r\n	in euclid\' b  rest ((rest, -k1 * quotient + k0, -q1 * quotient + q0) : ls)\r\n\r\n	where ls = (r1, k1, q1):(r0, k0, q0):xs\r\n','<br/>Тесты успешно пройдены!'),(4757,43,'shkuratov.ilya','2013-10-04 19:16:31',0,'data Tree = Empty |\r\n\n	Node Integer Tree Tree\r\n\n\r\n\nminTree (Empty) = 0\r\n\nminTree (Node value Empty _ ) = value\r\n\nminTree (Node value l _) = minTree l\n','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(4756,43,'shkuratov.ilya','2013-10-04 19:15:09',0,'data Tree = Empty |\r\n\n	Node Integer Tree Tree\r\n\n\r\n\nminTree (Empty) = 0\r\n\nminTree (Node value Empty _ ) = value\r\n\nminTree (Node value l _) = minTree l\n','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(4755,43,'517309','2013-10-04 18:17:32',3,'euclid 1 0 = (1,0)\r\neuclid a b = if (a>b) then f a b ((1,0),(0,1)) (div a b) (mod a b) \r\n		else f b a ((1,0),(0,1)) (div b a) (mod b a)\r\n\r\nmult e q = ( (fst(snd e), snd(snd e)) , ( fst(fst e)+ (snd(fst e))*q , snd(fst e) + snd(snd e)*q ) )\r\n\r\nf a b e q 0 = ( snd (snd e), fst (snd e) )\r\n		\r\nf a b e q r = f b r (mult e (-q)) (div b r) (mod b r) ','Выражение имеет неправильное значение: let (x,y) = euclid 33 25 in 33*x+25*y'),(4754,135,'shkuratov.ilya','2013-10-04 14:48:42',1,'data Tree = Empty |\r\n\r\n	Node Integer Tree Tree\r\n\r\n\r\n\r\nmPT (Empty) value = value\r\n\r\nmPT (Node value l r) m = \r\n\r\n	if value < 0\r\n\r\n	then mPT r m\r\n\r\n	else mPT l value\r\n\r\n\r\n\r\nminPosTree tree = mPT tree 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4753,135,'shkuratov.ilya','2013-10-04 14:47:49',0,'data Tree = Empty |\r\n\n	Node Integer Tree Tree\r\n\n\r\n\nmPT (Empty) value = value\r\n\nmPT (Node value l r) m = \r\n\n	if value < 0\r\n\n	then mPT r value\r\n\n	else mPT l value\r\n\n\r\n\nminPosTree tree = mPT tree 0\r\n\n\n','Выражение имеет неправильное значение: minPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))'),(4751,134,'shkuratov.ilya','2013-10-04 14:35:15',1,'data Tree = Empty |\r\n\r\n	Node Integer Tree Tree\r\n\r\n\r\n\r\nminTree (Empty) = 0\r\n\r\nminTree (Node value Empty _ ) = value\r\n\r\nminTree (Node value l _) = minTree l\r\n','<br/>Тесты успешно пройдены!'),(4752,135,'shkuratov.ilya','2013-10-04 14:46:35',0,'data Tree = Empty |\r\n\n	Node Integer Tree Tree\r\n\n\r\n\nmPT (Empty) value = value\r\n\nmPT (Node value l r) m = \r\n\n	if value < 0\r\n\n	then m\r\n\n	else mPT l value\r\n\n\r\n\nminPosTree tree = mPT tree 0\r\n\n\n','Выражение имеет неправильное значение: minPosTree (Node 5 (Node (-2) Empty (Node 3 Empty Empty)) (Node 7 Empty Empty))'),(4750,45,'shkuratov.ilya','2013-10-04 14:09:34',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace first_8\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[][] test = new int[][] {new int [] {1, 2, 3},\r\n\r\n                                        new int [] {5, 4, 5},\r\n\r\n                                        new int [] {6, 7, 8}};\r\n\r\n\r\n\r\n            bool result = test.All(x => x.Any(j => j % 2 == 0) == true);\r\n\r\n            System.Console.WriteLine(result);\r\n\r\n\r\n\r\n            System.Console.Read();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4748,43,'517309','2013-10-04 12:43:57',0,'div_rest a b = (quotient, rest)\r\n\r\n	where \r\n\r\n		quotient = div a b\r\n\r\n		rest = a - b * quotient\r\n\r\n\r\n\r\n\r\n\r\neuclid a b = \r\n\r\n	euclid\' b rest [(rest, 1, -quotient), (0, 0, 1)]\r\n\r\n	where (quotient, rest) = div_rest a b\r\n\r\n\r\n\r\neuclid\' a b ((1, k, q):xs) = (k, q)\r\n\r\neuclid\' a b ((r1, k1, q1):(r0, k0, q0):xs) = \r\n\r\n	let\r\n\r\n	(quotient, rest) = div_rest a b\r\n\r\n	in euclid\' b  rest ((rest, -k1 * quotient + k0, -q1 * quotient + q0) : ls)\r\n\r\n	where ls = (r1, k1, q1):(r0, k0, q0):xs\r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(4749,43,'517309','2013-10-04 12:45:35',3,'div_rest a b = (quotient, rest)\r\n\r\n	where \r\n\r\n		quotient = div a b\r\n\r\n		rest = a - b * quotient\r\n\r\n\r\n\r\n\r\n\r\neuclid a b = \r\n\r\n	euclid\' b rest [(rest, 1, -quotient), (0, 0, 1)]\r\n\r\n	where (quotient, rest) = div_rest a b\r\n\r\n\r\n\r\neuclid\' a b ((1, k, q):xs) = (k, q)\r\n\r\neuclid\' a b ((r1, k1, q1):(r0, k0, q0):xs) = \r\n\r\n	let\r\n\r\n	(quotient, rest) = div_rest a b\r\n\r\n	in euclid\' b  rest ((rest, -k1 * quotient + k0, -q1 * quotient + q0) : ls)\r\n\r\n	where ls = (r1, k1, q1):(r0, k0, q0):xs\r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 1 in 1*x+1*y\", проверьте правильность синтаксиса'),(4747,136,'6205237','2013-10-04 02:29:32',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Check2\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { -1, -3, 4 };\r\n\r\n            Console.WriteLine( a.Any(x => x == 7).ToString());\r\n\r\n            a[0] = 7;\r\n\r\n            Console.WriteLine(a.Any(x => x == 7).ToString());\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4745,134,'21743638','2013-10-04 00:58:28',2,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminTree (Node val l r) = fun l val\r\n\r\nfun Empty v = v\r\n\r\nfun (Node val l r) v = if v < val then fun l v else fun r val\r\n   --- идея правильная, но можно немного упростить. На самом деле нам всегда надо переходить к левому поддереву.\r\n   --- Потому что справа числа точно больше чем val, зачем же там искать.\r\n   --- А раз мы всегда переходим влево, то значит всегда v < val (потому что v - это откуда мы пришди, а раз\r\n   --- мы идем влево, то приходим в меньшее.\r\n   --- Те, короче, тут можно написать гораздо проще - попробуйте, пожалуйста.  ','<br/>Тесты успешно пройдены!'),(4746,45,'6205237','2013-10-04 02:08:50',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class check\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { -1, -3, 4 };\r\n\r\n            int[][] aa = new int[10][];\r\n\r\n            for (int i = 0; i < 9; i++)\r\n\r\n                aa[i] = a;\r\n\r\n            int[] a1 = { 1, 3 };//в последнем массиве не будет четного элемента\r\n\r\n            aa[9] = a1;\r\n\r\n\r\n\r\n            bool b1 = aa.All(x => x.Any(y => y % 2 == 0));// false!\r\n\r\n            Console.WriteLine(b1);\r\n\r\n\r\n\r\n            a1[0] = 2; //добавили в последний массив четный элемент \r\n\r\n            aa[9] = a1;\r\n\r\n            b1 = aa.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.WriteLine(b1);//теперь true!\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4744,136,'21743638','2013-10-04 00:44:01',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _7\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main()\r\n\r\n        {\r\n\r\n            int[] a = new int[] { 1, 2, 7, 5};\r\n\r\n           // int[] a = new int[] { 3, 8, 17};\r\n\r\n            Console.WriteLine(a.Any(x => x==7));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4743,40,'21743638','2013-10-04 00:38:29',1,'frame n = map (i -> map (j -> if (i/=1 && i/=n && j/=1 && j/=n) then 0 else 1) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(4742,43,'shkuratov.ilya','2013-10-04 00:24:07',2,'  --- У вас на некоторых примерах получается деление на 0. Например,\r\n  --- euclid 1 1\r\n  --- euclid 2 1\r\n  --- Попробуйте, мб исправить, и мне прислать? Можно до воскресенья включительно. \r\ndiv_rest a b = (quotient, rest)\r\n\r\n	where \r\n\r\n		quotient = div a b\r\n\r\n		rest = a - b * quotient\r\n\r\n\r\n\r\n\r\n\r\neuclid a b = \r\n\r\n	euclid\' b rest [(rest, 1, -quotient), (0, 0, 1)]\r\n\r\n	where (quotient, rest) = div_rest a b\r\n\r\n\r\n\r\neuclid\' a b ((1, k, q):xs) = (k, q)\r\n\r\neuclid\' a b ((r1, k1, q1):(r0, k0, q0):xs) = \r\n\r\n	let\r\n\r\n	(quotient, rest) = div_rest a b\r\n\r\n	in euclid\' b  rest ((rest, -k1 * quotient + k0, -q1 * quotient + q0) : ls)\r\n\r\n	where ls = (r1, k1, q1):(r0, k0, q0):xs\r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(4741,43,'shkuratov.ilya','2013-10-04 00:23:48',0,'','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(4740,44,'6205237','2013-10-03 23:53:24',2,'\r\ndata Tree = Empty |\r\n\r\n            Node Integer Tree Tree\r\n\r\n\r\n\r\naverageForLeaves Empty = 0\r\n\r\naverageForLeaves (Node n l r) = ( fromIntegral $  sum (average\' (Node n l r) [] )  ) /( fromIntegral $ length ( average\' (Node n l r) [] ))\r\n\r\n\r\n\r\naverage\' (Node n Empty Empty) xs = (n : xs)\r\n\r\naverage\' (Node n l r) xs = n : ( (average\' l  xs) ++ ( (average\' r  xs) ++ xs))\r\n   --- А зачем вы тут добавляете n? Вас же интересуют только листья! ','Выражение имеет неправильное значение: let x = averageForLeaves (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) in x > 2.49 && x < 2.51'),(4739,44,'57304539','2013-10-03 23:53:05',2,'{-comment\r\n\r\n-}\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n\r\n\r\nisEmpty Empty = True\r\n\r\nisEmpty (Node _ _ _) = False\r\n\r\n\r\n\r\naverageForLeaves\' (Node key l r) = if (isEmpty r) && (isEmpty l) then [key]\r\n				 else averageForLeaves\' l ++ averageForLeaves\' r\r\n\r\naverageForLeaves\' Empty = [0]\r\n   --- Вот это не совсем правильно. У вас появляется еще одно слагаемое,\r\n   --- и это влияет на length avg а значит и на среднеарифметическое\r\n\r\n\r\naverageForLeaves x = let \r\n\r\n			avg = averageForLeaves\' x\r\n\r\n		     in realToFrac(sum avg) / realToFrac(length avg)\r\n\r\n\r\n\r\ntest = averageForLeaves (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n','Выражение имеет неправильное значение: let x=averageForLeaves (Node 3 (Node (2) Empty Empty) Empty) in x > 1.99 && x < 2.01'),(4738,43,'6205237','2013-10-03 23:50:09',1,'--- ОК, у вас не рассмотрен частный случай, кода параметры 0 и 1, но неважно, засчитано.\r\neuclid a b = if (a>b) then f a b ((1,0),(0,1)) (div a b) (mod a b) \r\n\r\n		else f b a ((1,0),(0,1)) (div b a) (mod b a)\r\n\r\n\r\n\r\nmult e q = ( (fst(snd e), snd(snd e)) , ( fst(fst e)+ (snd(fst e))*q , snd(fst e) + snd(snd e)*q ) )\r\n\r\n\r\n\r\nf a b e q 0 = ( snd (snd e), fst (snd e) )\r\n\r\n		\r\n\r\nf a b e q r = f b r (mult e (-q)) (div b r) (mod b r) \r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(4737,44,'shkuratov.ilya','2013-10-03 23:11:58',1,'﻿data Tree = Empty |\r\n\r\n	Node Integer Tree Tree\r\n\r\n\r\n\r\naverageForLeaves Empty = 0\r\n\r\naverageForLeaves tree = \r\n\r\n	let (c, s) = avFL tree 0 0\r\n\r\n	in realToFrac(s) / realToFrac(c)\r\n\r\n\r\n\r\navFL (Empty) c s = (0, 0)\r\n\r\navFL (Node num Empty Empty) c s = (c + 1, s + num)\r\n\r\navFL (Node _ l r) c s= \r\n\r\n	let \r\n\r\n	(cl, sl) = avFL l c s\r\n\r\n	(cr, sr) = avFL r c s\r\n\r\n	in (cl + cr, sl + sr)\r\n','<br/>Тесты успешно пройдены!'),(4736,136,'7475152','2013-10-03 17:51:16',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace CheckFor7\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        \r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (new int[] { 1, 76, 45, 34, 23, 7, 56 }.Any(x => x == 7))\r\n\r\n                Console.WriteLine(\"Да\");\r\n\r\n            else\r\n\r\n                Console.WriteLine(\"Нет\");\r\n\r\n            \r\n\r\n            if (new int[] { 1,23,41,23,76}.Any(x => x == 7))\r\n\r\n                Console.WriteLine(\"Да\");\r\n\r\n            else\r\n\r\n                Console.WriteLine(\"Нет\");\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4735,45,'7475152','2013-10-03 17:41:55',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace CheckTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        static List<List<int>> fillList(int n) //статический метод для заполнения List \r\n\r\n        {\r\n\r\n            Random k = new Random();\r\n\r\n            List<List<int>> table = new List<List<int>>();\r\n\r\n            for (int i = 0; i != n; i++)\r\n\r\n            {\r\n\r\n                List<int> current = new List<int>();\r\n\r\n                for (int j = 0; j != n; j++)\r\n\r\n                {\r\n\r\n                    current.Add(k.Next(1,100));\r\n\r\n                }\r\n\r\n                table.Add(current);\r\n\r\n            }\r\n\r\n            return table;\r\n\r\n        }\r\n\r\n        static List<List<int>> fillList_Uneven(int n) //статический метод для заполнения List нечетными числами\r\n\r\n        {\r\n\r\n            List<List<int>> table = new List<List<int>>();\r\n\r\n            int value = 1;\r\n\r\n            for (int i = 0; i != n; i++)\r\n\r\n            {\r\n\r\n                List<int> current = new List<int>();\r\n\r\n                for (int j = 0; j != n; j++)\r\n\r\n                {\r\n\r\n                    current.Add(value);\r\n\r\n                    value += 2;\r\n\r\n                }\r\n\r\n                table.Add(current);\r\n\r\n            }\r\n\r\n            return table;\r\n\r\n        }\r\n\r\n        static void ShowTable(List<List<int>> table)//статический метод для вывода списка списков\r\n\r\n        {\r\n\r\n            foreach (List<int> cur in table)\r\n\r\n            {\r\n\r\n                foreach (int currentNumber in cur)\r\n\r\n                    Console.Write(currentNumber+\" \");\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static bool Check(List<List<int>> Table)//!!!! проверка чисел на четность\r\n\r\n        {\r\n\r\n            return Table.Any(x => x.Any(y => y % 2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.Write(\"Таблица размерности n= \");\r\n\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n\r\n            List<List<int>> Table = fillList(n);//заполнение первой таблицы\r\n\r\n            ShowTable(Table);//вывод на экран\r\n\r\n            Console.WriteLine(Check(Table));//проверка\r\n\r\n\r\n\r\n            List<List<int>> Table_Uneven = fillList_Uneven(n);//заполнение первой таблицы\r\n\r\n            ShowTable(Table_Uneven);//вывод на экран\r\n\r\n            Console.WriteLine(Check(Table_Uneven));//проверка\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4734,137,'517309','2013-10-03 15:34:11',3,'chessboard a b = [[0,0,1,1],[0,0,1,1],[1,1,0,0],[1,1,0,0]]','Выражение имеет неправильное значение: chessboard 3 1'),(4733,43,'7475152','2013-10-03 15:03:03',2,'  --- Еще пример, когда у вас неправильные результаты:\r\n  --- euclid 3 8\r\n  --- Возвращает почему-то (-2, 1)\r\neuclidHelper x1 x2 y1 y2 q r x y a b = if b>0 then \r\n					euclidHelper x x1 y y1 (div a b) (a-b*q) (x2-q*x1) (y2-q*y1) b (a-b*q)\r\n				       else (x2,y2) \r\neuclid a b =  let  answer a b = euclidHelper  0 1 1 0 (div a b) (a-(div a b)*b) 1 (-(div a b)) a b \r\n              in if a>b then answer a b\r\n		 else (snd (answer b a), fst (answer b a))','Выражение имеет неправильное значение: let (x,y) = euclid 33 25 in 33*x+25*y'),(4732,44,'21743638','2013-10-03 02:00:35',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\naverageForLeaves (Node val l r) = let (x,y) = func (Node val l r) (0,0) in fromIntegral x / fromIntegral y\r\n\r\nfunc (Node val Empty Empty) (v,n) = (v+val,n+1)\r\n\r\nfunc Empty (_,_) = (0,0)\r\n\r\nfunc (Node val l r) (v,n) = let {(x1,y1) = func l (v,n); (x2,y2) = func r (v,n)} in (x1+x2,y1+y2)\r\n','<br/>Тесты успешно пройдены!'),(4731,45,'21743638','2013-10-03 00:43:25',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Even\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main()\r\n\r\n        {\r\n\r\n            //------------вызов 1-----------------\r\n\r\n            int[][] b = new int[][] { new int[] { 1, -2, 3 }, new int[] { 5, -1, 3 }, new int[] { 2, 4, 1 } };\r\n\r\n\r\n\r\n            //------------вызов 2------------------\r\n\r\n            //int[][] b = new int[][] { new int[] { -1, 5, 4 }, new int[] { 9, 8, 32 }, new int[] { 1, 4, 1 } };\r\n\r\n\r\n\r\n            bool[] f = new bool[b.Length];\r\n\r\n\r\n\r\n            for (int i = 0; i != b.Length; ++i)\r\n\r\n            {\r\n\r\n                f[i] = b[i].Any(x => x % 2 == 0);\r\n\r\n            }\r\n\r\n\r\n\r\n            bool g = f.All(x=>x==true);\r\n   --- ОК, но это же можно было написать и не заводя вспомогательный массив, просто одно лямбда выражение вложен в другое. Мы это обсудим.  \r\n            Console.WriteLine(g);\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4730,44,'SMakarov','2013-10-02 16:44:11',1,'data Tree = Empty | Node Integer Tree Tree\r\nf Empty = 0\r\nf (Node val Empty Empty) = val\r\nf (Node val l r) = f l + f r\r\ng Empty = 0\r\ng (Node val Empty Empty) = 1\r\ng (Node val l r) = g l + g r\r\n   --- Просто как замечание, я бы назвал функции более понятно, типа numLeaves и sumLeaves \r\naverageForLeaves (Node val l r) = (fromIntegral (f (Node val l r)))/(fromIntegral (g (Node val l r)))','<br/>Тесты успешно пройдены!'),(4729,43,'SMakarov','2013-10-02 16:09:26',2,'  --- E вас видимо циклится для 25 и 33\r\nnod a 0 = a\r\nnod a b = nod b (mod a b)\r\ng a b x y = if not (nod a b == 1) then (0,0) else if a < b then f2 b a x y else f1 a b x y\r\nf1 a b x y = if a*x + b*y == 1 then (x,y) else f1 a b y (x - y*(quot a b))\r\nf2 a b x y = if a*x + b*y == 1 then (y,x) else f2 a b y (x - y*(quot a b))\r\neuclid a b = g a b 1 0','Не удалось вычислить выражение \"let (x,y) = euclid 33 25 in 33*x+25*y\", проверьте правильность синтаксиса'),(4728,43,'SMakarov','2013-10-02 16:01:21',0,'isPrime k = null [ x | x <- [2..k - 1], k `mod`x  == 0] -- в задаче было сказано что программа может делать что угодно при наличии не простых чисел, однако оказалось что просто бесконечную работу тесты не пропускают. взял эту функцию проверки простоты, хоть она и сильно не оптимизирована (проверка идет до k-1, а не до sqrt k, но не стал разбираться с приведением типов из вещественного в целочисленный)\r\ng a b x y = if not (isPrime a && isPrime b) then (0,0) else if a < b then f2 b a x y else f1 a b x y\r\nf1 a b x y = if a*x + b*y == 1 then (x,y) else f1 a b y (x - y*(quot a b))\r\nf2 a b x y = if a*x + b*y == 1 then (y,x) else f2 a b y (x - y*(quot a b))\r\neuclid a b = g a b 1 0','Выражение имеет неправильное значение: let (x,y) = euclid 33 25 in 33*x+25*y'),(4727,43,'SMakarov','2013-10-02 15:49:38',0,'g a b x y = if a < b then f2 b a x y else f1 a b x y\r\nf1 a b x y = if a*x + b*y == 1 then (x,y) else f1 a b y (x - y*(quot a b))\r\nf2 a b x y = if a*x + b*y == 1 then (y,x) else f2 a b y (x - y*(quot a b))\r\neuclid a b = g a b 1 0','Не удалось вычислить выражение \"let (x,y) = euclid 33 25 in 33*x+25*y\", проверьте правильность синтаксиса'),(4726,135,'7475152','2013-10-02 02:41:31',1,'data Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nminPos Empty helper = helper\r\nminPos (Node val Empty Empty) helper = if val<0 then helper\r\n				       else val	\r\nminPos (Node val l r) helper = if val>0 then minPos l val\r\n			       else minPos r helper\r\nminPosTree (Node val l r) = minPos (Node val l r) 0','<br/>Тесты успешно пройдены!'),(4725,44,'7475152','2013-10-02 02:33:08',1,'data Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nnumberOfL Empty = 0\r\nnumberOfL (Node val Empty Empty)  = 1\r\nnumberOfL (Node val l r )  = (numberOfL l  + numberOfL r )\r\n\r\naverageForLeave Empty = 0\r\naverageForLeave (Node val Empty Empty)  = val\r\naverageForLeave (Node val l r )  = (averageForLeave l  + averageForLeave r )\r\n\r\naverageForLeaves x = fromIntegral (averageForLeave x )/fromIntegral (numberOfL x)','<br/>Тесты успешно пройдены!'),(4724,135,'517309','2013-10-01 22:51:00',3,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	minPosTree.hs\r\n\r\n-}\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n			deriving Eq\r\n\r\n\r\n\r\ngetVal :: Tree -> Integer\r\n\r\ngetVal Empty = 0\r\n\r\ngetVal (Node v _ _) = v\r\n\r\n	\r\n\r\nminPosTree :: Tree -> Integer\r\n\r\nminPosTree Empty = 0\r\n\r\nminPosTree (Node val l r)\r\n\r\n			| (val >= 0) && ((getVal l < 0) || l == Empty) = val\r\n\r\n			| getVal l < 0 = minPosTree r\r\n\r\n			| otherwise    = minPosTree l\r\n\r\n\r\n\r\ntest = minPosTree (Node (-5) (Node (-2) (Node (-1) Empty Empty) (Node (-3) Empty Empty)) (Node 7 (Node 1 Empty Empty) Empty))\r\n','<br/>Тесты успешно пройдены!'),(4723,40,'7475152','2013-10-01 20:43:43',1,'frame n = map(i -> \r\n 		map (j-> if i==1 || j==1 ||i==n|| j==n then 1 else 0 ) [1..n]\r\n	     ) [1..n]','<br/>Тесты успешно пройдены!'),(4722,44,'7475152','2013-10-01 20:23:22',2,'--- И тут тоже практически все правильно, но надо немного  дописать\r\n--- Вот такой тест, например, не проходит:\r\n---   averageForLeaves (Node 3 (Node (2) Empty Empty) Empty)\r\n--- (программа выдает ошибку)\r\n--- Исправьте, пожалуйста (а я сейчас добавлю такой тест)\r\n\r\ndata Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nnumberOfL (Node val Empty Empty)  = 1\r\nnumberOfL (Node val l r )  = (numberOfL l  + numberOfL r )\r\n\r\naverageForLeave (Node val Empty Empty)  = val\r\naverageForLeave (Node val l r )  = (averageForLeave l  + averageForLeave r )\r\n   --- Просто как замечание, я бы назвал sumOfL или что-то в таком роде. Это же сумма, а не среднее.\r\n\r\naverageForLeaves x = fromIntegral (averageForLeave x )/fromIntegral (numberOfL x)','<br/>Тесты успешно пройдены!'),(4721,42,'5337814','2013-10-01 19:09:28',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	myfoldl.hs\r\n\r\n-}\r\n\r\n\r\n\r\nmyfoldl _ e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (e `f` x) xs\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4719,131,'SMakarov','2013-09-30 23:59:31',1,'data Content = Film String Integer String | Series String Integer\r\nhaveNewFilm [] = False\r\nhaveNewFilm ((Series _ _):xs) = haveNewFilm xs\r\nhaveNewFilm ((Film _ x _):xs) = if x == 2013 then True else haveNewFilm xs\r\ntest = haveNewFilm [(Film \"OldFilm\" 1970 \"Dir1\"), (Film \"NewFilm\" 2013 \"Dir2\")]','<br/>Тесты успешно пройдены!'),(4720,51,'5337814','2013-10-01 19:09:05',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	repeatFunc.hs\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\nrepeatFunc f n = foldr (.) (x -> x) (replicate n f)\r\n\r\n\r\n\r\nf = repeatFunc sin 3\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4718,133,'SMakarov','2013-09-30 23:40:53',1,'makeList xs 0 = xs\r\nmakeList xs n = makeList (xs ++ [0]) (n - 1)\r\nf xs 0 n = xs\r\nf xs k n = f (xs ++ [makeList [] (n - k) ++ [1] ++ makeList[] (k - 1)]) (k - 1) n\r\nidentity n = f [] n n','<br/>Тесты успешно пройдены!'),(4716,130,'SMakarov','2013-09-30 21:22:07',1,'data Tree = Empty | Node Integer Tree Tree\r\nfindTree Empty n = False\r\nfindTree (Node val l r) n = if val == n then True else if n < val then findTree l n else findTree r n','<br/>Тесты успешно пройдены!'),(4717,132,'SMakarov','2013-09-30 23:28:47',1,'check cond [] ys = ys\r\ncheck cond (x:xs) ys = if cond x then check cond xs (ys ++ [-1]) else check cond xs (ys ++ [x])\r\nf xs = check (x -> x == 1) xs []','<br/>Тесты успешно пройдены!'),(4715,136,'5337814','2013-09-30 20:58:43',1,'/*\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	FindZ.cs	\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nclass FindZ\r\n\r\n{	\r\n\r\n	static void Main(string[] args)\r\n\r\n	{	\r\n\r\n		int [] a = {1, 3, 56, 7};\r\n\r\n		\r\n\r\n		int [] b = {1, 3, 56, 6};\r\n\r\n		\r\n\r\n		System.Console.Write((a.Any(x => x == 7) ? \"Yes\" : \"No\") \r\n\r\n								+ \"  \" + \r\n\r\n							 (b.Any(x => x == 7) ? \"Yes\" : \"No\"));\r\n\r\n	}	\r\n\r\n}	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4714,134,'5337814','2013-09-30 20:57:38',1,'{-	\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	minTree.hs\r\n\r\n-}	\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n			deriving Eq\r\n\r\n\r\n\r\nminTree :: Tree -> Integer\r\n\r\nminTree Empty = 0\r\n\r\nminTree (Node val l _)\r\n\r\n			| l /= Empty = minTree l\r\n\r\n			| otherwise = val\r\n\r\n\r\n\r\n--test = minTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty))\r\n\r\ntest = minTree (Node (-5) (Node (-2) (Node (-10) Empty Empty) (Node (-1) Empty Empty)) (Node 7 (Node 1 Empty Empty) Empty))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4712,129,'SMakarov','2013-09-30 20:46:14',1,'f (x:[]) sum = sum\r\nf (x:xs) sum = f xs (sum + sqrt l) where l = (fst(head xs) - fst(x))^2 + (snd(head xs) - snd(x))^2\r\nlen xs = f xs 0','<br/>Тесты успешно пройдены!'),(4713,135,'5337814','2013-09-30 20:57:10',2,'--- Нет, все немного сложнее.\r\n--- Например такой тест\r\n---   minPosTree (Node 5 (Node (-2) Empty (Node (3) Empty Empty)) (Node 7 Empty Empty))\r\n--- у вас дает 5, а надо 3\r\n--- Исправьте, пожалуйста (а я сейчас добавлю такой тест)\r\n{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	minPosTree.hs\r\n\r\n-}\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n			deriving Eq\r\n\r\n\r\n\r\ngetVal :: Tree -> Integer\r\n\r\ngetVal Empty = 0\r\n\r\ngetVal (Node v _ _) = v\r\n\r\n	\r\n\r\nminPosTree :: Tree -> Integer\r\n\r\nminPosTree Empty = 0\r\n\r\nminPosTree (Node val l r)\r\n\r\n			| (val >= 0) && ((getVal l < 0) || l == Empty) = val\r\n\r\n			| getVal l < 0 = minPosTree r\r\n\r\n			| otherwise    = minPosTree l\r\n\r\n\r\n\r\ntest = minPosTree (Node (-5) (Node (-2) (Node (-1) Empty Empty) (Node (-3) Empty Empty)) (Node 7 (Node 1 Empty Empty) Empty))\r\n\r\n--test = minPosTree (Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))\r\n\r\n','<br/>Тесты успешно пройдены!'),(4711,45,'5337814','2013-09-30 16:15:33',1,'/*\r\n\r\n *  Bobrov Nikita 2013 \r\n\r\n *  AnyAll.cs\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nclass AnyAll\r\n\r\n{\r\n\r\n	static void Main(string[] args)\r\n\r\n	{	\r\n\r\n		int [][] a = new int [][] \r\n\r\n		{	\r\n\r\n			new int[]	{-10, 2, -3, 4},\r\n\r\n			new int[]	{121, 1, -3, 2},\r\n\r\n			new int[]	{-1, 9, -7, 4},\r\n\r\n			new int[]	{21, 2, -3, 4}\r\n\r\n		};\r\n\r\n			\r\n\r\n		bool b = any_all(a);\r\n\r\n		\r\n\r\n		System.Console.Write(b);\r\n\r\n	}	\r\n\r\n	\r\n\r\n	static bool any_all (int[][] a)\r\n\r\n	{	\r\n\r\n		bool b = false;\r\n\r\n		\r\n\r\n		b = a.All(x => x.Any(i => i % 2 == 0));\r\n\r\n	\r\n\r\n		return b;\r\n\r\n	}	\r\n\r\n	\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4705,129,'6205237','2013-09-30 05:19:20',1,'\r\ndist (x1,y1) (x2,y2) = sqrt ((x1-x2)^2 + (y1-y2)^2)\r\n\r\n\r\n\r\nlen [x] = 0\r\n\r\nlen (x:y:xs) = (dist x y) +  len ( y: xs )\r\n','<br/>Тесты успешно пройдены!'),(4706,130,'6205237','2013-09-30 05:34:53',1,'\r\ndata Tree = Empty |\r\n\r\n            Node Integer Tree Tree\r\n\r\n\r\n\r\nfindTree Empty x = False\r\n\r\nfindTree (Node n l r) x = if (x < n) then findTree l x\r\n\r\n				else if (x > n) then findTree r x\r\n\r\n					else True\r\n','<br/>Тесты успешно пройдены!'),(4707,133,'6205237','2013-09-30 05:41:26',1,'\r\ne n = map (i -> ( map ( j -> (if (i==j) then 1 else 0) ) )  [1..n] ) [1..n]\r\n\r\n\r\n','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(4708,132,'6205237','2013-09-30 05:45:34',1,'\r\nf [] = []\r\n\r\nf (x:xs)= h x : f xs\r\n\r\nh x = if (x==1) then -1\r\n\r\n	else x\r\n','<br/>Тесты успешно пройдены!'),(4709,133,'5337814','2013-09-30 15:06:50',2,'--- Все правильно, но слишком поздно :(\r\n--- Задачи, которые заданы к понедельнику, принимаются строго до начала 1 пары :(\r\n--- Я про это говорид, и это есть в слайдах \r\n{--\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	identity.hs\r\n\r\n--}\r\n\r\n\r\n\r\nisEqual :: Integer -> Integer -> Integer\r\n\r\nisEqual x y\r\n\r\n		| x == y    = 1\r\n\r\n		| otherwise = 0\r\n\r\n\r\n\r\nidentity :: Integer -> [[Integer]]\r\n\r\nidentity 0 = [[]]\r\n\r\nidentity 1 = [[1]]\r\n\r\nidentity n = [ [isEqual i  j | i <- [1..n]] | j <- [1..n] ]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4710,43,'5337814','2013-09-30 15:07:36',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	euclid.hs\r\n\r\n-}\r\n\r\n\r\n\r\ngetQR :: Integer -> Integer -> (Integer, Integer)\r\n\r\ngetQR _ 0 = error \"Division by zero\"\r\n\r\ngetQR a b = (quot a b, rem a b)\r\n\r\n \r\n\r\neuclid :: Integer -> Integer -> (Integer, Integer)\r\n\r\neuclid a b\r\n\r\n		| gcd a b /= 1 = error \"GCD != 1\"\r\n\r\n		| otherwise = ((signum a) * x, (signum b) * y)\r\n\r\n			where (x,y) = euclid\' (abs a) (abs b)\r\n\r\n				where\r\n\r\n					euclid\' _ 0 = (1,0)\r\n\r\n					euclid\' _ 1 = (0,1)\r\n\r\n					euclid\' a b = (y, x - q * y)\r\n\r\n						where\r\n\r\n							(x, y) = euclid\' b r\r\n\r\n							(q, r) = getQR a b\r\n\r\n\r\n\r\n--test = euclid (2^100) (3^100)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4704,131,'21743638','2013-09-30 00:53:10',1,'data Telecast = Film String Integer String | Soap_Opera String Integer\r\n\r\nhaveNewFilm [] = False\r\n\r\nhaveNewFilm (Film _ year _:xs) = if (year == 2013) then True else haveNewFilm xs\r\n\r\nhaveNewFilm (Soap_Opera _ _:xs) = haveNewFilm xs\r\n\r\ntest = haveNewFilm [Film \"Armageddon\" 1998 \"Bay\", Soap_Opera \"House,M.D.\" 22, Film \"Sherlock Holmes\" 2011 \"Ritchie\", Film \"Fast & Furious 6\" 2013 \"Lin\"]\r\n','<br/>Тесты успешно пройдены!'),(4703,129,'21743638','2013-09-30 00:16:51',1,'lenotr ((x1,y1),(x2,y2)) = sqrt((x1-x2)^2 + (y1-y2)^2)\r\n\r\n--len xs = len\' xs 0\r\n\r\n--len\' [] m = m\r\n\r\n--len\' (x:y:xs) m =  m +lenotr x y && len (y:xs)\r\n\r\nlen xs = sum (map ((x, y) -> lenotr (x,y)) (zip xs (tail xs)))\r\n','<br/>Тесты успешно пройдены!'),(4700,132,'21743638','2013-09-29 22:33:55',1,'f xs = map (i -> if i==1 then -i else i) xs\r\n','<br/>Тесты успешно пройдены!'),(4701,133,'21743638','2013-09-29 23:08:58',1,'identity n = map(i -> (map(k -> if k == i then 1 else 0) [1..n])) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(4702,130,'21743638','2013-09-29 23:40:44',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfindTree Empty _ = False\r\n\r\nfindTree (Node val l r) n = if n == val then True else \r\n\r\n	 if n < val then findTree l n else findTree r n\r\n','<br/>Тесты успешно пройдены!'),(4699,131,'57304539','2013-09-29 18:57:43',1,'{-comment\r\n\r\n-}\r\n\r\ndata Translation = Film String Integer String | Show String Integer\r\n\r\n\r\n\r\nhaveNewFilm [] = False\r\n\r\nhaveNewFilm ((Show name episode):xs) = haveNewFilm xs\r\n\r\nhaveNewFilm ((Film _ year _):xs) = (year == 2013) || haveNewFilm xs\r\n\r\n\r\n\r\ntest = haveNewFilm [(Film \"A\" 2011 \"X\"), (Show \"Q\" 12), (Show \"W\" 1), (Film \"B\" 2014 \"Y\"), (Film \"C\" 2013 \"Z\")]\r\n','<br/>Тесты успешно пройдены!'),(4698,130,'57304539','2013-09-29 18:57:25',1,'{-comment\r\n\r\n-}\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfindTree Empty _ = False\r\n\r\nfindTree (Node key l r) val = if (val > key) then findTree r val\r\n\r\n					       else if (val < key) then findTree l val\r\n\r\n								   else True\r\n\r\n--findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 2\r\n','<br/>Тесты успешно пройдены!'),(4695,135,'7475152','2013-09-29 17:54:41',0,'data Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\n\r\nminPosTree (Node val Empty _) = val\r\nminPosTree (Node val l r) = if val<0 then minPosTree r\r\n		           else min val (minPosTree l)','Выражение имеет неправильное значение: minPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))'),(4696,135,'7475152','2013-09-29 18:15:33',2,'--- Вообще идея хорошая и правильная, вы молодец!\r\n--- Но надо немного более аккуратно написать.\r\n--- Вот пример, когда ваша программа работает неправильно:\r\n---   minPosTree (Node 3 (Node (-2) Empty (Node (-1) Empty Empty)) Empty)\r\n--- У вас получится -2 (а надо 3)\r\n--- Попробуйте исправить, пожалуйста (а я сейчас добавлю такой тест)\r\n \r\ndata Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nminPos Empty helper = helper\r\nminPos (Node val Empty Empty) helper = if val<0 then helper\r\n				       else val	\r\nminPos (Node val l r) helper = if val>0 then minPos l val\r\n			       else minPos r val\r\nminPosTree (Node val l r) = minPos (Node val l r) 0','<br/>Тесты успешно пройдены!'),(4697,129,'57304539','2013-09-29 18:57:03',1,'{-comment\r\n\r\n-}\r\n\r\nlen [x] = 0\r\n\r\nlen (x:y:xs) = len\' x y + len (y:xs)\r\n\r\nlen\' (a,b) (c,d) = sqrt ((a - c)**2 + (b - d)**2)\r\n','<br/>Тесты успешно пройдены!'),(4694,134,'7475152','2013-09-29 17:08:53',1,'data Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\n\r\nminTree (Node val Empty _ ) = val\r\nminTree (Node val l r) = minTree l','<br/>Тесты успешно пройдены!'),(4690,132,'shkuratov.ilya','2013-09-27 20:02:03',1,'f xs = map (i -> if (i == 1) then -i; else i) xs\r\n','<br/>Тесты успешно пройдены!'),(4691,133,'shkuratov.ilya','2013-09-27 20:17:40',1,'identity n = map (i -> map (j -> if (i /= j) then 0; else 1) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(4692,30,'SMakarov','2013-09-29 01:24:22',1,'check (x:[]) = True\r\ncheck (x:xs) = if x < head xs then check xs else False\r\ngetLast xs k = reverse (take l (reverse xs)) where l = length xs - k\r\n  --- Просто как замечание - это стандартная функция drop\r\ncheckArr xs k = if xs == [] then True else if check (take k xs) then checkArr (getLast xs k) k else False\r\nf xs k = if k == length xs + 1 then False else if (mod l k) == 0 && checkArr xs k then True else f (xs) (k+1) where l = length xs\r\nparts xs = f xs 2','<br/>Тесты успешно пройдены!'),(4693,33,'SMakarov','2013-09-29 01:24:56',1,'class Program\r\n    {\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double h = Math.Abs(b - a) / 100;\r\n            double sum = 0;\r\n            for (int i = 0; i < 100; i++)\r\n            {\r\n                sum += f(a + i * h) * ((a + (i + 1) * h) - (a + i * h));            //метод левых прямоугольников\r\n            }\r\n            return sum;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            double result = Integral(x => x * x, 0, 1);\r\n            Console.WriteLine(result.ToString());\r\n            Console.ReadKey();\r\n        }\r\n    }','<br/>Тесты успешно пройдены!'),(4687,129,'shkuratov.ilya','2013-09-27 19:17:19',1,'len xs = \r\n\r\n	let\r\n\r\n	pairs = zip xs (tail xs)\r\n\r\n	sums = map ((x, y) -> dist\' x y) pairs\r\n\r\n	in sum sums\r\n\r\n\r\n\r\n\r\n\r\ndist\' (x1, y1) (x2, y2) = sqrt ((x2 - x1)^2 + (y2 - y1)^2) \r\n','<br/>Тесты успешно пройдены!'),(4688,130,'shkuratov.ilya','2013-09-27 19:32:41',1,'data Tree = Empty |\r\n\r\n	Node Integer Tree Tree\r\n\r\n\r\n\r\nfindTree Empty _ = False;\r\n\r\nfindTree (Node val l r) n = \r\n\r\n	if (n < val)\r\n\r\n	then findTree l n\r\n\r\n	else if (n > val)\r\n\r\n		then findTree r n\r\n\r\n		else True\r\n','<br/>Тесты успешно пройдены!'),(4689,131,'shkuratov.ilya','2013-09-27 19:55:22',1,'data Video = \r\n\r\n	Film String Integer String |\r\n\r\n	Serial String Integer\r\n\r\n\r\n\r\nhaveNewFilm [] = False\r\n\r\nhaveNewFilm (Serial _ _ : ls) = haveNewFilm ls\r\n\r\nhaveNewFilm (Film _ year _ : ls) = (year == 2013) || haveNewFilm ls\r\n\r\n\r\n\r\ntest1 = haveNewFilm [Film \"House\" 2002 \"Kirk\", Serial \"Santa-barbara\" 2013, Film \"Lie\" 2000 \"Luise\"]\r\n\r\ntest2 = haveNewFilm [Film \"House\" 2002 \"Kirk\", Serial \"Santa-barbara\" 2013, Film \"Hobbit\" 2013 \"Luise\"]\r\n','<br/>Тесты успешно пройдены!'),(4685,31,'23959','2013-09-26 23:12:58',1,'isArithm (x:y:xs) = progr (y:xs) (y - x)\r\nprogr (x:[]) dif = True\r\nprogr (x:y:xs) dif = if ((y-x) == dif)\r\n                        then progr (y:xs) dif\r\n                        else False','<br/>Тесты успешно пройдены!'),(4686,44,'5337814','2013-09-26 23:41:19',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	averageForLeaves.hs\r\n\r\n-}\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n		deriving (Eq, Show)\r\n\r\n\r\n\r\nleaves :: Tree -> [Integer]\r\n\r\nleaves Empty = []\r\n\r\nleaves (Node x Empty Empty) = [x]\r\n\r\nleaves (Node x l r) = leaves l ++ leaves r\r\n\r\n\r\n\r\n\r\n\r\nsum\' :: [Integer] -> Integer \r\n\r\nsum\' [] = 0\r\n\r\nsum\' (x:xs) = x + sum\'(xs)\r\n\r\n\r\n\r\ndivInt :: Integer -> Int -> Float\r\n\r\ndivInt a b = (fromIntegral a) / (fromIntegral b)\r\n\r\n\r\n\r\nmidarithm [] = 0\r\n\r\nmidarithm (x:xs) = divInt (sum\' (x:xs)) (length (x:xs))\r\n\r\n\r\n\r\naverageForLeaves :: Tree -> Float\r\n\r\naverageForLeaves Empty = 0\r\n\r\naverageForLeaves (Node val l r) = midarithm (leaves (Node val l r))\r\n\r\n\r\n\r\n\r\n\r\n--test1 = averageForLeaves (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\ntest = averageForLeaves ((Node 5 (Node 2 (Node 5 Empty (Node 0 Empty Empty)) Empty) (Node 7 Empty Empty)))\r\n\r\n--tree = (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4684,130,'5337814','2013-09-26 21:10:43',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	findTree.hs\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\n		deriving (Eq, Show)\r\n\r\n			\r\n\r\n\r\n\r\n{-getVal Empty = -1\r\n\r\ngetVal (Node val _ _) = val\r\n\r\n\r\n\r\nisBin Empty = True\r\n\r\nisBin (Node val l r)\r\n\r\n			| (val > getVal l) && (val <= getVal r) && (isBin l) && (isBin r) = True\r\n\r\n			| otherwise = False\r\n\r\n-}\r\n\r\n--test1 = isBin (Node 5 (Node 2 (Node 1 Empty Empty) Empty) (Node 7 Empty Empty))\r\n\r\n\r\n\r\nfindTree Empty _ = False\r\n\r\n\r\n\r\nfindTree (Node val l r) x\r\n\r\n			| val == x 	= True\r\n\r\n			| x < val  	=  findTree l x\r\n\r\n			| x >= val 	= findTree r x\r\n\r\n			| otherwise = False\r\n  --- Последняя строка все кажется лишняя. Какое же тут мб otherwise? :)\r\n\r\n\r\n\r\n\r\n\r\ntest = findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 8\r\n\r\ntest\' = findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 2\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4682,133,'7475152','2013-09-26 19:32:23',1,'vector _ 0 = []\r\nvector k n = if n==k then 1:vector k (n-1) \r\n		else 0:vector k (n-1) \r\n\r\niden 0 _ = []\r\niden k n = vector k n : iden (k-1) n \r\nidentity n = iden n n','<br/>Тесты успешно пройдены!'),(4683,131,'5337814','2013-09-26 21:07:10',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	TV.hs\r\n\r\n-}\r\n\r\n\r\n\r\ndata TV =\r\n\r\n	Serial {serialName 	  	 :: String,\r\n\r\n			serialChapter 	 :: Integer}\r\n\r\n	|Movie {movieName 		 :: String,\r\n\r\n			year			 :: Integer,\r\n\r\n			directorLastName :: String}\r\n\r\n				deriving(Eq, Show)\r\n\r\n\r\n\r\ngetYear (Serial _ _) = 0\r\n\r\ngetYear (Movie _ y _ ) = y\r\n\r\n\r\n\r\ntestList = \r\n\r\n	[Serial 	\"S1\" 	12,\r\n\r\n	 Serial		\"S2\"	 9,\r\n\r\n	 Movie 		\"M1\"  1993 	\"D1\",\r\n\r\n	 Serial		\"S1\"	13,\r\n\r\n	 Movie 		\"M3\"     2	\"D4\",\r\n\r\n	 Serial 	\"S4\"	18,\r\n\r\n	 Movie 		\"M2\"  2013 	\"D1\",\r\n\r\n	 Serial		\"S5\" 	12,\r\n\r\n	 Movie 		\"M3\"  2012	\"D2\",\r\n\r\n	 Movie 		\"M4\"  2013 	\"D3\"]\r\n\r\n\r\n\r\n\r\n\r\nhaveNewFilm :: [TV] -> Bool\r\n\r\nhaveNewFilm [] = False\r\n\r\nhaveNewFilm (x:xs)\r\n\r\n			| (getYear x == 2013) || haveNewFilm(xs) = True\r\n\r\n			| otherwise = False\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4680,131,'7475152','2013-09-26 19:00:58',0,'data Telecast = Film String Integer String|	\r\n		Series String Integer\r\n\r\nhaveNewFilm [] = False\r\nhaveNewFilm(Film _ year _ :xs)=if year==2013 then True \r\n			      else haveNewFilm xs \r\nhaveNewFilm(Series _ _:xs) = haveNewFilm xs\r\n\r\ntest1 =  haveNewFilm [Film \"titanic\" 1997 \"cameron\", Series \"theBigBangTheory\" 5,Film \"The Great Gatsby\" 2013 \"Lurman\", Series \"howIMetYourMother\" 10, Film \"greenMile\" 1999 \"darabont\"]\r\ntest2 =  haveNewFilm [Film \"titanic\" 1997 \"cameron\", Series \"theBigBangTheory\" 5,Series \"howIMetYourMother\" 10, Film \"greenMile\" 1999 \"darabont\"]','<br/>Тесты успешно пройдены!'),(4681,131,'7475152','2013-09-26 19:01:02',1,'data Telecast = Film String Integer String|	\r\n		Series String Integer\r\n\r\nhaveNewFilm [] = False\r\nhaveNewFilm(Film _ year _ :xs)=if year==2013 then True \r\n			      else haveNewFilm xs \r\nhaveNewFilm(Series _ _:xs) = haveNewFilm xs\r\n\r\ntest1 =  haveNewFilm [Film \"titanic\" 1997 \"cameron\", Series \"theBigBangTheory\" 5,Film \"The Great Gatsby\" 2013 \"Lurman\", Series \"howIMetYourMother\" 10, Film \"greenMile\" 1999 \"darabont\"]\r\ntest2 =  haveNewFilm [Film \"titanic\" 1997 \"cameron\", Series \"theBigBangTheory\" 5,Series \"howIMetYourMother\" 10, Film \"greenMile\" 1999 \"darabont\"]','<br/>Тесты успешно пройдены!'),(4678,33,'6205237','2013-09-26 01:54:08',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace PrintTable\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        public static double Integral(Func<double, double> f, int a, int b)\r\n\r\n        {\r\n\r\n            double h = (double) Math.Abs(b - a) / (double) 100;\r\n\r\n            double result = 0;\r\n\r\n\r\n\r\n            for (int i = 0; i < 100; i++)\r\n\r\n                result+= f(i * h + h / 2);\r\n\r\n            return h * result;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            // Примеры вызова:\r\n\r\n            Console.WriteLine(Integral(i => 2 * Math.Pow(i, 2) + 3 * i * Math.Pow(i, 4), 2, 4));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4679,129,'7475152','2013-09-26 18:00:34',1,'dist (x1,y1) (x2,y2) = sqrt((x1-x2)^2+(y1-y2)^2)\r\n\r\nlen xs = sum (map (i-> dist (fst i) (snd i) ) (zip xs (tail xs)))','<br/>Тесты успешно пройдены!'),(4674,130,'7475152','2013-09-25 22:37:16',1,'data Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nfindTree Empty x = False\r\nfindTree (Node val Empty Empty) x = x==val\r\nfindTree (Node val l r) x = if x==val then True \r\n			    else\r\n				if (x>val) then findTree r x\r\n			        else findTree l x','<br/>Тесты успешно пройдены!'),(4675,132,'7475152','2013-09-25 22:45:01',1,'f [] = []\r\nf (x:xs) = if x==1 then (-1: f xs)\r\n	   else (x: f xs)','<br/>Тесты успешно пройдены!'),(4676,129,'5337814','2013-09-25 23:22:22',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	Chain.hs\r\n\r\n-}\r\n\r\n\r\n\r\nsquare :: Integer -> Integer\r\n\r\nsquare a = a * a\r\n\r\n\r\n\r\nintSqrt :: Integer -> Double\r\n\r\nintSqrt = sqrt . fromIntegral\r\n\r\n\r\n\r\nlen    :: [(Integer, Integer)] -> Double\r\n\r\nlen [(0,0), (0,0)] = 0\r\n\r\nlen [x, y] = intSqrt(square(fst y - fst x) + square(snd y - snd x))\r\n\r\nlen (x:y:ys) = len[x, y] + len(y:ys)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4677,132,'5337814','2013-09-25 23:22:49',1,'{-\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	9-4.hs\r\n\r\n-}\r\n\r\n\r\n\r\nf :: [Int] -> [Int]\r\n\r\n\r\n\r\n\r\n\r\nf [] = []\r\n\r\nf (x:xs) = [isEqual x | x <- (x:xs)]\r\n\r\n			where \r\n\r\n				isEqual x\r\n\r\n					| x == 1 = -1\r\n\r\n					| otherwise = x\r\n\r\n\r\n\r\nf\' :: [Int] -> [Int]\r\n\r\nf\' [] = []\r\n\r\nf\' (x:xs)\r\n\r\n		| x /= 1 = x : f\' (xs)\r\n\r\n		| otherwise = -1 : f\'(xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4673,130,'7475152','2013-09-25 22:17:14',2,'  --- На самом деле не совсем правильно, потому что искомое число может быть не только в листе, но и в вершине.\r\n  --- Т.е. в последнем правиле надо проверять, что x равно val\r\n  --- Допишите пожалуйста, это просто\r\ndata Tree = Empty|\r\n	Node Integer Tree Tree\r\n\r\nfindTree Empty x = False\r\nfindTree (Node val Empty Empty) x = x==val\r\nfindTree (Node val l r) x = if (x>val) then findTree r x\r\n			    else findTree l x ','<br/>Тесты успешно пройдены!'),(4671,33,'5337814','2013-09-25 15:08:58',1,'﻿/*\r\n\r\n *  Bobrov Nikita 2013 \r\n\r\n *  Lambda.cs\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\n\r\n\r\nclass Lambda\r\n\r\n{\r\n\r\n	static void Main(string[] args)\r\n\r\n	{\r\n\r\n		Func<Double, Double> test = x => x * x;\r\n\r\n		double result = Integral(test, 0, 4);\r\n\r\n		Console.Write(result);\r\n\r\n	}\r\n\r\n	\r\n\r\n	//Simpson`s rule\r\n\r\n	static double Integral(Func<Double, Double> lambda, double a, double b)\r\n\r\n	{   \r\n\r\n		double n = 1000;      \r\n\r\n		double h = (b - a) / n;\r\n\r\n		double sum1 = 0;\r\n\r\n		double sum2 = 0;\r\n\r\n		\r\n\r\n		for(int k = 1; k <= n; k++)\r\n\r\n			sum1 += lambda((2 * k - 1) * h / 2);\r\n\r\n		for(int i = 1; i <= n - 1; i++)\r\n\r\n			sum2 += lambda(i * h);\r\n\r\n		\r\n\r\n		return (h / 6 * (lambda(0.0) + lambda(0.4) + 4 * sum1 + 2 * sum2));                    \r\n\r\n	}   \r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4672,33,'7475152','2013-09-25 21:45:53',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace Integral\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        static void Integral(Func<double, double> f, double a, double b)//метод средних прямоугольников\r\n\r\n        {\r\n\r\n            double x,sum=0;\r\n\r\n            var h = Math.Abs((a - b) / 100);\r\n\r\n            for (double i = 0; i <= 100; i++)\r\n\r\n            {\r\n\r\n                x = a + i * h;\r\n\r\n                sum += f(x - h / 2);\r\n\r\n            }\r\n\r\n            Console.WriteLine(h*sum);\r\n\r\n        }\r\n\r\n\r\n\r\n        static double Cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Func<double, double> root = i => Math.Sqrt(i);\r\n\r\n\r\n\r\n            // Примеры вызова:\r\n\r\n            Integral(root, 1, 10);\r\n\r\n            Integral(Cube, -1, 1);\r\n\r\n\r\n\r\n            // с лямбда выражениями\r\n\r\n            Integral(i => 6*i*i+2*i-1, -1, 1);\r\n\r\n            Integral(i => Math.Sin(i), 0, 1);\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4668,132,'517309','2013-09-25 01:06:10',2,'f = map (x -> if x == 1 then -1 else x)','<br/>Тесты успешно пройдены!'),(4669,133,'517309','2013-09-25 01:07:39',2,'identity n = map (i -> map (j -> if i == j then 1 else 0) [1..n]) [1..n]','<br/>Тесты успешно пройдены!'),(4670,31,'5337814','2013-09-25 13:47:00',1,'{--\r\n\r\n	Bobrov Nikita 2013\r\n\r\n	isArithm.hs\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nisArithm :: [Int] -> Bool\r\n\r\n\r\n\r\nisArithm [] = False\r\n\r\nisArithm [x] = False\r\n\r\nisArithm [x, y] = True\r\n\r\nisArithm (x:y:z:zs)\r\n\r\n				| (x - y) == (y - z) && isArithm(y:z:zs) = True\r\n\r\n				| otherwise     = False\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4667,130,'517309','2013-09-25 01:05:01',2,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfindTree x 2 = True','<br/>Тесты успешно пройдены!'),(4665,129,'517309','2013-09-25 01:03:22',2,'len ((x,y):z) = 2.41','<br/>Тесты успешно пройдены!'),(4666,130,'517309','2013-09-25 01:04:43',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfindTree x = True','Не удалось вычислить выражение \"findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 2\", проверьте правильность синтаксиса'),(4662,31,'6205237','2013-09-23 13:14:03',1,'\r\nisArithm (x:y:xs) = isArithm\' (y:xs) (y-x)\r\n\r\nisArithm\' [x] d = True\r\n\r\nisArithm\' (x:y:xs) d = ((y-x)==d) && (isArithm\' (y:xs) d)\r\n','<br/>Тесты успешно пройдены!'),(4663,129,'517309','2013-09-25 01:01:55',0,'len [(_,_):_] = 2.41','Не удалось вычислить выражение \"let x = len [(1,1), (1,2), (2,1)] in x > 2.40 && x < 2.42\", проверьте правильность синтаксиса'),(4664,129,'517309','2013-09-25 01:02:44',0,'len _ = 2.41','<br/>Тесты успешно пройдены!'),(4661,45,'57304539','2013-09-23 00:14:10',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace HW81\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static bool check(int[][] a)\r\n\r\n        {\r\n\r\n            return a.All(x => x.Any(y => y % 2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            const int size = 5;\r\n\r\n            int[][] a = new int[size][];\r\n\r\n\r\n\r\n            for (int i = 0; i < size; i++)\r\n\r\n            {\r\n\r\n                a[i] = new int[size];\r\n\r\n            }\r\n\r\n\r\n\r\n            for (int i = 0; i < size; i++)\r\n\r\n                for (int j = 0; j < size; j++)\r\n\r\n                {\r\n\r\n                    a[i][j] = 2 * (i + j) + 1;  //Все нечетные\r\n\r\n                }\r\n\r\n            Console.WriteLine(check(a));\r\n\r\n\r\n\r\n            for (int i = 0; i < size; i++)\r\n\r\n                for (int j = 0; j < size; j++)\r\n\r\n                {\r\n\r\n                    if (i == 3 && j == 2)\r\n\r\n                        a[i][j] = 4;\r\n\r\n                    else\r\n\r\n                        a[i][j] = 2 * (i + j) + 1; //Всего один элемент массива четен\r\n\r\n                }\r\n\r\n            Console.WriteLine(check(a));\r\n\r\n\r\n\r\n            for (int i = 0; i < size; i++)\r\n\r\n                for (int j = 0; j < size; j++)\r\n\r\n                {\r\n\r\n                    if (j == 3)\r\n\r\n                        a[i][j] = 4;\r\n\r\n                    else\r\n\r\n                        a[i][j] = 2 * (i + j) + 1; //Один элемент каждого измерения четен\r\n\r\n                }\r\n\r\n            Console.WriteLine(check(a));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4659,36,'21743638','2013-09-22 22:47:09',1,'cubeTable n = let {f n = [1..n]; g n = n^3} in zip (f n) (map g (f n))\r\n','<br/>Тесты успешно пройдены!'),(4660,33,'57304539','2013-09-22 23:42:09',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace Integrate\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static double Integral(Func<double,double> f, double a, double b)\r\n\r\n        {\r\n\r\n            const int n = 100;\r\n\r\n            double sum = 0;\r\n\r\n            double[] arr = new double[n];\r\n\r\n            double h = 1.0*(b-a)/n;\r\n\r\n\r\n\r\n            for (int i = 0; i < n; i++)\r\n\r\n            {\r\n\r\n                arr[i] = a*1.0 + i*h*1.0;\r\n\r\n            }\r\n\r\n\r\n\r\n            for (int i = 0; i < n; i++)  //Метод трапеций\r\n\r\n                sum += f(arr[i] + h / 2);\r\n\r\n\r\n\r\n            return sum * h;\r\n\r\n        }\r\n\r\n\r\n\r\n        static double Cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            // Примеры вызова:\r\n\r\n            Console.WriteLine(Integral(Cube, 0, 1));\r\n\r\n\r\n\r\n            // И то же с лямбда выражениями\r\n\r\n            Console.WriteLine(Integral(i => i*i*i, 0, 1));\r\n\r\n\r\n\r\n            //Свой пример, был на практике по вычислительной математике\r\n\r\n            Console.WriteLine(Integral(x => x * Math.Cos(2.1*x), 0, Math.PI/2));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4656,36,'7475152','2013-09-22 16:44:33',1,'cubeTable n = zip [1..n] (map (x->x^3) [1..n])','<br/>Тесты успешно пройдены!'),(4657,37,'7475152','2013-09-22 16:55:26',1,'minsum xs = minimum( map ((x,y)->x+y) (zip xs (tail xs)) )','<br/>Тесты успешно пройдены!'),(4658,38,'7475152','2013-09-22 19:24:03',1,'data Tree = Empty | \r\n		Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node var l r) = if (height l >height r) then (height l+1)\r\n		        else (height r+1)\r\n  --- ОК, засчитано, но так не эффективно, это мы обсудим. ','<br/>Тесты успешно пройдены!'),(4654,35,'21743638','2013-09-20 21:48:55',1,'isosc (x1,y1) (x2,y2) (x3,y3) = let {d1 = ((x2-x1)^2 + (y2-y1)^2); \r\n\r\n	d2 = ((x3-x2)^2 + (y3-y2)^2); d3 = ((x1-x3)^2 + (y1-y3)^2)} in \r\n\r\n	if d1 == d2 || d2 == d3 || d1 == d3 then True else False\r\n','<br/>Тесты успешно пройдены!'),(4655,35,'7475152','2013-09-22 16:38:55',1,'root x y = sqrt(x^2+y^2)\r\nisosc a b c = if (root (fst a - fst b) (snd a - snd b) == root (fst a - fst c)(snd a - snd c) ||\r\n			root (fst a - fst b) (snd a - snd b) == root (fst b - fst c)(snd b - snd c) ||\r\n				root (fst b - fst c) (snd b - snd c) == root (fst a - fst c)(snd a - snd c))\r\n	      then True\r\n	      else False','<br/>Тесты успешно пройдены!'),(4652,22,'SMakarov','2013-09-19 23:23:36',0,'check k 1 = False\r\ncheck k n = if k > div n 2 then True else if mod n k == 0 then False else check (k+1) n\r\nf a b = if a == b then False else if check 2 a && check 2 b then True else f (a+1) (b-1)\r\ng 1 = False\r\ng 2 = True\r\ng n = f 2 (n-2)','Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),(4653,22,'SMakarov','2013-09-19 23:26:15',1,'check k 1 = False\r\ncheck k n = if k > div n 2 then True else if mod n k == 0 then False else check (k+1) n\r\n  --- Тут можно проверять if k*k < n - это будет гораздо эффективнее\r\nf a b = if a >= b then False else if check 2 a && check 2 b then True else f (a+1) (b-1)\r\ng 1 = False\r\ng 2 = True\r\ng n = f 2 (n-2)','<br/>Тесты успешно пройдены!'),(4651,22,'SMakarov','2013-09-19 23:22:48',0,'check k n = if k > div n 2 then True else if mod n k == 0 then False else check (k+1) n\r\nf a b = if a == b then False else if check 2 a && check 2 b then True else f (a+1) (b-1)\r\ng 1 = False\r\ng 2 = True\r\ng n = f 2 (n-2)','Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),(4650,22,'tori','2013-09-19 22:45:15',1,'import System.Environment\r\n\r\nsimple_numbers n = if (n <= 1)\r\n    then []\r\n    else simple_numbers\' 2 n []\r\n    \r\nsimple_numbers\' i n ls = if (i <= n)\r\n    then if (check_simple i)\r\n        then simple_numbers\' (i + 1) n ([i] ++ ls)\r\n        else simple_numbers\' (i + 1) n ls\r\n    else ls\r\n\r\ncheck_simple i = check_simple\' 2 i\r\n   --- Просто как замечание, вы могли бы передавать в checkSimple список всех предыдущих простых чисел\r\n   --- (он у вас все равно составляется). И проверять делимость не на все числа, а только на простые.\r\ncheck_simple\' k i = if (k < i)\r\n    then if (i `mod` k == 0)\r\n        then False\r\n        else check_simple\' (k + 1) i\r\n    else True\r\ng n = check n (simple_numbers n)\r\n\r\n{--check n ls - аналог цикла\r\n for (int i = 1; i <= n; i++)\r\n     for (int k = i; k <= n; k++)  --}\r\n\r\ncheck n [] = False\r\ncheck n ls = if (check\' n ls)\r\n    then True\r\n    else check n (tail ls)\r\n				\r\n		\r\ncheck\' n ls = check\'\' n (tail ls) (head ls)\r\n--check\' n ls = check\'\' n ls (head ls)\r\ncheck\'\' n [] _ = False\r\ncheck\'\' n ls a = if (a + head ls == n)\r\n    then True\r\n    else check\'\' n (tail ls) (a)\r\n\r\nmain = if (g 6) \r\n    then print (\"yes\")\r\n    else print (\"no\")','<br/>Тесты успешно пройдены!'),(4649,22,'tori','2013-09-19 22:38:56',0,'import System.Environment\n\n{--сделаем так же, как и 2.2, но список в данном случае будет\n\nсостоять не из степеней двойки, а из всех простых чисел,\n\nт.е. задача сводится к поиску простых чисел--}\n\n{--for (int i = 2; i <= n; i++)    //перебор всех\n\n    for	(int j = 2; j < i; j++)	//проверка\n\n        if (i mod j == 0)\n\n            cout<<\"число \"<<i<<\" не является простым\"\n\n        else \"добавляем число в список простых чисел\"\n\n//проверяем каждое число на простоту, будем делать тупо, без всяких дополнительных условий: делить на каждое число от 2 до n-1--}\n\n--__________________________________________________________\n\nsimple_numbers n = if (n <= 1)\n\n    then []\n\n    else simple_numbers\' 2 n []    	--передаем: откуда докуда массив с простыми числами\n\n    \n\n--т.о. ищем простые числа от 2 до n \"двойным циклом\"\n\nsimple_numbers\' i n ls = if (i <= n)		--проходим по потенциально подходящим числам\n\n    then if (check_simple i)			--проверяем число\n\n        then simple_numbers\' (i + 1) n ([i] ++ ls)	--включение i в список\n\n        else simple_numbers\' (i + 1) n ls\n\n    else ls     --дошли до конца\n\n\n\n\n\ncheck_simple i = check_simple\' 2 i	--возвр. \"простое\" или \"нет\" делим на все числа подряд от 2 до i - 1\n\ncheck_simple\' k i = if (k < i)\n\n    then if (i `mod` k == 0)	--нашли делитель, отличный от 1 и самого себя\n\n        then False\n\n        else check_simple\' (k + 1) i    --проверяем следующее число\n\n    else True    --дошли до конца, так и не обнаружив лишних делителей; простое число\n\n--__________________________________________________________\n\ng n = check n (simple_numbers n)\n\n\n\n{--check n ls - аналог цикла\n\n for (int i = 1; i <= n; i++)\n\n     for (int k = i; k <= n; k++)  --}\n\n\n\ncheck n [] = False\n\ncheck n ls = if (check\' n ls)			--вызываем эту функцию для каждого элемента массива\n\n    then True						--т.е. это как бы 1-й цикл\n\n    else check n (tail ls)\n\n				\n\n		\n\ncheck\' n ls = check\'\' n (tail ls) (head ls)	--проверка суммы 1-го элемента со всеми остальными\n\n--check\' n ls = check\'\' n ls (head ls)	--если степени двойки могут повторяться\n\ncheck\'\' n [] _ = False\n\ncheck\'\' n ls a = if (a + head ls == n)\n\n    then True\n\n    else check\'\' n (tail ls) (a)\n\n\n\nmain = if (g 10) \n\n    then print (\"yes\")\n\n    else print (\"no\")\n\n\n','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4648,22,'21743638','2013-09-19 19:56:54',2,'g n = g1 n 2 True\r\n\r\ng1 0 k b = b\r\n\r\ng1 n k b = let t = g1 n (k+1) b in \r\n\r\n	if k < n then \r\n\r\n		if func k then if func (n-k) && n-k /= k then True else t else t \r\n\r\n	else False\r\n\r\n   where \r\n\r\n	func m = if (m /= 2 && mod m 2 == 0) || (m /= 3 && mod m 3 == 0) || (m /= 5 && mod m 5 == 0) || (m /= 7 && mod m 7 == 0) || m == 1 then False else True\r\n    --- Нет, Ольга, так нельзя) Вы не можете подбирать решение под тесты.  Я сейчас добавлю\r\n    --- тест g 171, который у вас дает True, потому что считает число 169 простым.\r\n    --- А вы можете, если хотите, прислать до начала занятия в понедельник\r\n    --- решение, в котором более правидьная проверка на простоту..','<br/>Тесты успешно пройдены!'),(4647,23,'tori','2013-09-19 18:16:01',1,'import System.Environment\r\n\r\ndegree_of_two max = if max < 1    --возвращает список степеней двойки до максимально возможной степени\r\n    then []\r\n    else degree_of_two\' max 1 [1]\r\ndegree_of_two\' max p ls = if p1 > max\r\n    then ls\r\n    else degree_of_two\' max p1 ([p1] ++ ls)\r\n    where p1 = p * 2\r\n\r\nb n = check n (degree_of_two n)\r\n\r\n{--check n ls - аналог цикла\r\n for (int i = 1; i <= n; i++)\r\n     for (int k = i; k <= n; k++)  --}\r\n\r\ncheck n [] = False\r\ncheck n ls = if (check\' n ls)			--вызываем эту функцию для каждого элемента массива\r\n    then True						--т.е. это как бы 1-й цикл\r\n    else check n (tail ls)\r\n				\r\n		\r\ncheck\' n ls = check\'\' n  ls (head ls)	--проверка суммы 1-го элемента со всеми остальными\r\ncheck\'\' n [] _ = False\r\ncheck\'\' n ls a = if (a + head ls == n)\r\n    then True\r\n    else check\'\' n (tail ls) (a)\r\n\r\nmain = if (b 8) \r\n    then print (\"yes\")\r\n    else print (\"no\")','<br/>Тесты успешно пройдены!'),(4646,22,'57304539','2013-09-19 18:12:46',1,'﻿{--\r\n\r\nпредыдущие решения почему-то странно отображаются, попытка 3\r\n\r\nкомпилятор пишет о невозможности создать \r\n\r\nбесконечную последовательность в выражении \r\n\r\ni < x\r\n\r\nпробовал варьировать запись, результата не дало, в чем дело?\r\n\r\n--}\r\n\r\nisPrime x i = if ((x mod i) == 0) \r\n\r\n				then False\r\n\r\n				else if i<x\r\n\r\n						then isPrime x (i+1)\r\n\r\n						else True\r\n\r\n\r\n\r\ng n = g\' n 2\r\n\r\ng\' n i = if (isPrime i 2) && (isPrime (n-i) 2)\r\n\r\n		 	then True\r\n\r\n			else if (i < n) then g\' n (i+1)\r\n\r\n						 	else False\r\n','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4645,23,'tori','2013-09-19 18:12:19',0,'import System.Environment\r\n\r\ndegree_of_two max = if max < 1    --возвращает список степеней двойки до максимально возможной степени\r\n    then []\r\n    else degree_of_two\' max 1 [1]\r\ndegree_of_two\' max p ls = if p1 > max\r\n    then ls\r\n    else degree_of_two\' max p1 ([p1] ++ ls)\r\n    where p1 = p * 2\r\n\r\nb n = check n (degree_of_two n)\r\n\r\n{--check n ls - аналог цикла\r\n for (int i = 1; i <= n; i++)\r\n     for (int k = i; k <= n; k++)  --}\r\n\r\ncheck n [] = False\r\ncheck n ls = if (check\' n ls)			--вызываем эту функцию для каждого элемента массива\r\n    then True						--т.е. это как бы 1-й цикл\r\n    else check n (tail ls)\r\n				\r\n		\r\ncheck\' n ls = check\'\' n (tail ls) (head ls)	--проверка суммы 1-го элемента со всеми остальными\r\ncheck\'\' n [] _ = False\r\ncheck\'\' n ls a = if (a + head ls == n)\r\n    then True\r\n    else check\'\' n (tail ls) (a)\r\n\r\nmain = if (b 10) \r\n    then print (\"yes\")\r\n    else print (\"no\")','Хитрый тест номер 4 не пройден :(<br/>Подсказка: степени двойки могут быть и одинаковыми'),(4644,22,'57304539','2013-09-19 18:10:30',0,'﻿{--\r\n\nкомпилятор пишет о невозможности создать \r\n\nбесконечную последовательность в выражении \r\n\ni < x\r\n\nпробовал варьировать запись, результата не дало, в чем дело?\r\n\n--}\r\n\nisPrime x i = if ((x mod i) == 0) \r\n\n				then False\r\n\n				else if i<x\r\n\n						then isPrime x (i+1)\r\n\n						else True\r\n\n\r\n\ng n = g\' n 2\r\n\ng\' n i = if (isPrime i 2) && (isPrime (n-i) 2)\r\n\n		 	then True\r\n\n			else if (i < n) then g\' n (i+1)\r\n\n						 	else False\n','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4643,22,'57304539','2013-09-19 18:09:03',0,'﻿{--\r\n\nкомпилятор пишет о невозможности создать \r\n\nбесконечную последовательность в выражении \r\n\ni < x\r\n\nпробовал варьировать запись, результата не дало, в чем дело?\r\n\n--}\r\n\nisPrime x i = if ((x mod i) == 0) \r\n\n				then False\r\n\n				else if i<x\r\n\n						then isPrime x (i+1)\r\n\n						else True\r\n\n\r\n\nb n = b\' n 2\r\n\nb\' n i = if (isPrime i 2) && (isPrime (n-i) 2)\r\n\n		 	then True\r\n\n			else if (i < n) then b\' n (i+1)\r\n\n						 	else False\n','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4642,23,'57304539','2013-09-19 18:08:05',1,'﻿{--\r\n\r\nкод крайне избыточен, но, в отличие от си-подобных я зыков, \r\n\r\nя не знаю ни как проверить, возвращает ли логарифм значение с\r\n\r\nнулевой дробной частью, ни побитовых операций\r\n\r\n--}\r\n\r\n\r\n\r\nisPowerOfTwo x i = if x == 2**i \r\n\r\n			then True\r\n\r\n			else if (i <= logBase 2 x) then isPowerOfTwo x (i+1)\r\n\r\n					      else False\r\n\r\n\r\n\r\nb n = b\' n 0\r\n\r\nb\' n i = if isPowerOfTwo (n-2**i) 0 then True\r\n\r\n				   else if (i < n) then b\' n (i+1)\r\n\r\n						   else False\r\n','<br/>Тесты успешно пройдены!'),(4640,44,'517309','2013-09-19 14:47:00',0,'data Tree = Node Integer Tree Tree | Empty\r\n\r\naverageForNodes x = 2.5','Выражение имеет неправильное значение: let x = averageForNodes (Node 1 Empty Empty) in x > 0.99 && x < 1.01'),(4641,44,'517309','2013-09-19 14:50:44',2,'data Tree = Empty | Node Integer Tree Tree\r\n\r\naverageForLeaves _ = 2.5','Выражение имеет неправильное значение: let x = averageForLeaves (Node 1 Empty Empty) in x > 0.99 && x < 1.01'),(4639,22,'7475152','2013-09-18 21:15:59',1,'checkSimple n k = if n==1 then False\r\n                  else\r\n                       if n==k then True \r\n                          else  \r\n                          if (mod n k)/=0 then (checkSimple n (k+1))\r\n	                  else False  \r\n                          \r\ncheckSumSimple n k = if k>=n then False \r\n                     else   \r\n                       if (checkSimple k 2) && k/=n-k then \r\n                          if (checkSimple (n-k) 2) then True\r\n                          else checkSumSimple n (k+1)\r\n                       else checkSumSimple n (k+1) \r\n\r\ng n = checkSumSimple n 2','<br/>Тесты успешно пройдены!'),(4638,128,'shkuratov.ilya','2013-09-18 13:36:56',1,'data Candy = \r\n\r\n	Cake String Float Float |\r\n\r\n	Sweet String Float\r\n\r\n\r\n\r\npriceCake (Sweet _ _) = -1\r\n\r\npriceCake (Cake _ _ price) = price\r\n\r\n\r\n\r\nnameCake (Sweet _ _) = \"None\"\r\n\r\nnameCake (Cake name _ _) = name\r\n\r\n\r\n\r\nmaxCake x y = \r\n\r\n	let\r\n\r\n	xp = priceCake x\r\n\r\n	yp = priceCake y\r\n\r\n	in if xp > yp\r\n\r\n	then x\r\n\r\n	else y\r\n\r\n\r\n\r\nbestCake xs = nameCake (bestCake\' xs)\r\n\r\nbestCake\' [x] = x \r\n\r\nbestCake\' (x:xs) = maxCake x (bestCake\' xs)\r\n\r\n\r\n\r\ntest1 = bestCake [Cake \"a\" 1 1, Cake \"b\" 4 3, Sweet \"c\" 5]\r\n\r\ntest2 = bestCake [Sweet \"a\" 4, Sweet \"b\" 3, Cake \"c\" 1 1]\r\n','<br/>Тесты успешно пройдены!'),(4637,22,'7475152','2013-09-18 12:37:29',2,'checkSimple n k = if n==k then True \r\n                  else  \r\n                     if (mod n k)/=0 then (checkSimple n (k+1))\r\n	             else False  \r\n                          \r\ncheckSumSimple n k = if k>=n then False \r\n                     else   \r\n                       if (checkSimple k 2) && k/=n-k then \r\n                          if (checkSimple (n-k) 2) then True\r\n                          else False\r\n  --- Вот в этом месте у вас не совсем правильная логика, посмотрите внимательно. \r\n  --- Самый простой пример, на котором у вас неправильно работает, это, видимо, g 8\r\n                       else checkSumSimple n (k+1) \r\n\r\ng n = checkSumSimple n 2','Выражение имеет неправильное значение: g 40'),(4635,37,'shkuratov.ilya','2013-09-17 23:04:47',1,'minsum xs = \r\n\r\n	let \r\n\r\n	ls = zip xs (tail xs)\r\n\r\n	sum\' = (x, y) -> x + y\r\n\r\n	in minimum (map sum\' ls)\r\n','<br/>Тесты успешно пройдены!'),(4636,38,'shkuratov.ilya','2013-09-17 23:23:38',1,'data Tree = Empty | \r\n\r\n	Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = -1	\r\n\r\nheight (Node val l r) = 1 + (max (height l) (height r)) \r\n','<br/>Тесты успешно пройдены!'),(4633,35,'shkuratov.ilya','2013-09-17 21:46:18',1,'isosc a b c = isosc\' (len a b) (len b c) (len c a)\r\n\r\n\r\n\r\nlen (x1, y1) (x2, y2) = (x1 - x2)^2 + (y1 - y2)^2\r\n\r\nisosc\' a b c = (a == b) || (b == c) || (c == a)\r\n','<br/>Тесты успешно пройдены!'),(4634,36,'shkuratov.ilya','2013-09-17 21:49:29',1,'cubeTable n = zip [1..n] (map (x -> x^3) [1..n])\r\n','<br/>Тесты успешно пройдены!'),(4632,21,'517309','2013-09-17 18:02:30',2,'nseq n = quantity (g n) 0\r\n\r\nquantity [] n = n\r\nquantity (x:xs) n = quantity xs (n+1)\r\n-- g рекурсивно вычисляет все последовательности, используя значения g(1),...,g(n-1)\r\ng 1 = [[1]]\r\ng n = h n (n-1) [[n]]\r\n\r\nh _ 0 xs = xs\r\nh n i xs = h n (i-1) (accum n i (g i) xs)\r\n\r\n-- accum делает, если возможно, из старых последовательностей из g(i) новые, приписывая (n-i)\r\naccum _ _ [] xs = xs\r\naccum n i (y:ys) xs = accum n i ys (if (head y < n-i)then (((n-i):y):xs) else xs)\r\n','<br/>Тесты успешно пройдены!'),(4629,128,'517309','2013-09-17 17:30:27',0,'test = 555','<br/>Тесты успешно пройдены!'),(4630,128,'517309','2013-09-17 17:31:48',2,'test = 1','<br/>Тесты успешно пройдены!'),(4631,21,'517309','2013-09-17 18:01:54',0,'f n = quantity (g n) 0\r\n\r\nquantity [] n = n\r\nquantity (x:xs) n = quantity xs (n+1)\r\n-- g рекурсивно вычисляет все последовательности, используя значения g(1),...,g(n-1)\r\ng 1 = [[1]]\r\ng n = h n (n-1) [[n]]\r\n\r\nh _ 0 xs = xs\r\nh n i xs = h n (i-1) (accum n i (g i) xs)\r\n\r\n-- accum делает, если возможно, из старых последовательностей из g(i) новые, приписывая (n-i)\r\naccum _ _ [] xs = xs\r\naccum n i (y:ys) xs = accum n i ys (if (head y < n-i)then (((n-i):y):xs) else xs)\r\n','Не удалось вычислить выражение \"nseq 1\", проверьте правильность синтаксиса'),(4627,26,'tori','2013-09-16 08:00:25',1,'import System.Environment\r\n\r\nrev [] = []\r\nrev arr = rev\' arr []    	--arr2 - новый массив	\r\nrev\' [] arr2 = arr2\r\nrev\' arr arr2 = rev\' (tail arr)	([head arr] ++ arr2)\r\n\r\nmain = print (rev [3, 2, 1, 0])','<br/>Тесты успешно пройдены!'),(4628,38,'517309','2013-09-17 17:24:58',2,'test = \"qqq\"','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(4624,25,'tori','2013-09-16 07:55:52',1,'import System.Environment\r\n\r\nminlist [] = 0	--возвращаем 0 если список пуст\r\nminlist arr = minlist\' (tail arr) (head arr)\r\nminlist\' [] m = m\r\nminlist\' arr m = minlist\' (tail arr) m1\r\n  where m1 = min m (head arr)\r\n    \r\nmain = print (minlist [3,2,7])','<br/>Тесты успешно пройдены!'),(4625,27,'tori','2013-09-16 07:57:12',1,'import System.Environment\r\n\r\nminsum [] = 0\r\nminsum arr = if (arr1 == [])\r\n  then 0\r\n  else minsum\' (tail arr1) b ((head arr) + b)\r\n  where \r\n    arr1 = tail arr\r\n    b = head arr1\r\nminsum\' [] a m = m\r\nminsum\' arr a m = minsum\' (tail arr) (head arr) (min m (head arr + a))	--предполагаю, что head arr\r\n									--имеет временную сложность О(n)\r\nmain = print (minsum [3, 2, 1, 0])','<br/>Тесты успешно пройдены!'),(4626,26,'tori','2013-09-16 07:57:52',0,'import System.Environment\r\n\r\nrev [] = []\r\nrev arr = rev\' arr []    	--arr2 - новый массив	\r\nrev\' [] arr2 = arr2\r\nrev\' arr arr2 = rev\' (tail arr)	([head arr] ++ arr2)\r\n\r\nmain = print (rev [3, 2, 1, 0]','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(4622,26,'6205237','2013-09-16 03:49:25',0,'\r\n\nrev xs = last xs : rev (init xs)\n','Выражение имеет неправильное значение: rev [1,2,3] == [3,2,1]'),(4623,26,'6205237','2013-09-16 03:51:42',1,'\r\nrev [] = []\r\n\r\nrev xs = last xs : rev (init xs)\r\n --- OK, но это тоже О(n^2) потому что last и init - долгие операции, они просматривают \r\n --- весь список','<br/>Тесты успешно пройдены!'),(4618,29,'6205237','2013-09-16 01:31:46',1,'\r\nadd\' [] z = True\r\n\r\nadd\' zs z = if z/=(head zs) then add\' (tail zs) z\r\n\r\n		else False\r\n\r\n\r\n\r\ncheckDifferent xs = checkDif\' xs []\r\n\r\ncheckDif\' [] [] = True\r\n\r\ncheckDif\' [] ys = True\r\n\r\ncheckDif\' xs ys = if (add\' ys (head xs))==True then checkDif\' (tail xs) (ys++[head xs])\r\n\r\n			else False\r\n','<br/>Тесты успешно пройдены!'),(4619,28,'6205237','2013-09-16 02:16:49',1,'\r\ncheck cond [] = False\r\n\r\ncheck cond (x:xs) = if (cond x)==True then True\r\n --- или просто if cond x\r\n --- скобки и == True можно не писать\r\n			else check cond xs\r\n','<br/>Тесты успешно пройдены!'),(4620,28,'23959','2013-09-16 02:59:54',1,'check f [] = False\r\ncheck f (x:xs) = f x || check f xs','<br/>Тесты успешно пройдены!'),(4621,29,'23959','2013-09-16 03:17:49',1,'checkDifferent [] = True\r\ncheckDifferent  (x:xs) = x `notElem` xs && checkDifferent xs','<br/>Тесты успешно пройдены!'),(4613,23,'6205237','2013-09-15 21:42:21',1,'\r\nb 0 = False\r\n\r\nb 1 = False\r\n\r\nb n = b\' n 1 1\r\n\r\nb\' n curs s = if curs>n then False\r\n\r\n		else if (curs+s)==n then True\r\n\r\n			else if (curs+s)<n then b\' n curs (s*2) \r\n\r\n				else b\' n (curs*2) (curs*2)\r\n','<br/>Тесты успешно пройдены!'),(4614,22,'6205237','2013-09-15 21:42:51',1,'\r\nprost x = prost\' x (round (sqrt (fromIntegral x)))\r\n\r\nprost\' x 1 = True\r\n\r\nprost\' x s = if (mod x s)/=0 then prost\' x (s-1)\r\n\r\n				else False\r\n\r\ng n = if n<5 then False\r\n\r\n	else g\' n 2\r\n\r\ng\' n t = if (t>=(n-t)) then  False\r\n\r\n	 else if ((prost t) == True) && ((prost (n-t)) == True) then True\r\n  --- Или проще else if prost t && prost (n-t) then True\r\n		else g\' n (t+1)','<br/>Тесты успешно пройдены!'),(4615,25,'6205237','2013-09-15 23:13:07',1,'\r\nminlist xs = minlist\' xs (head xs)\r\n\r\nminlist\' [] m = m\r\n\r\nminlist\' xs m = if m > (head xs) then minlist\' (tail xs) (head xs)\r\n\r\n		else minlist\' (tail xs) m\r\n','<br/>Тесты успешно пройдены!'),(4616,23,'21743638','2013-09-15 23:59:10',1,'b n = b\' n 1 1 False\r\n\r\nb\' 0 _ _ bl = bl\r\n\r\nb\' n k p bl = let {z = 2*k; s = k/2} in\r\n\r\n	if p == 1 then \r\n\r\n		if n-k > 0 then b\' n z p bl else b\' (n-s) 1 2 bl\r\n\r\n	else if n == k then b\' 0 0 0 True\r\n                        --- или проще ... then True\r\n		else if n-k > 0 then b\' n z p bl else b\' 0 0 0 False\r\n                                                   --- А тут можно else False','<br/>Тесты успешно пройдены!'),(4617,27,'6205237','2013-09-16 00:49:04',1,'\r\nminsum xs = minsum\' (tail xs) (head xs) (head xs + head(tail xs))\r\n\r\nminsum\' [] s sum = sum  \r\n\r\nminsum\' xs s sum = if sum > ((head xs) + s) then minsum\' (tail xs) (head xs) (head xs + s)\r\n\r\n		else minsum\' (tail xs) (head xs) sum\r\n','<br/>Тесты успешно пройдены!'),(4612,23,'6205237','2013-09-15 21:36:04',0,'\r\n\nb 0 = False\r\n\nb 1 = False\r\n\nb 2 = False\r\n\nb n = b\' n 1 2\r\n\nb\' n curs s = if curs>n then False\r\n\n		else if (curs+s)==n then True\r\n\n			else if (curs+s)<n then b\' n curs (s*2) \r\n\n				else b\' n (curs*2) (curs*4)\n','Хитрый тест номер 4 не пройден :(<br/>Подсказка: степени двойки могут быть и одинаковыми'),(4611,33,'shkuratov.ilya','2013-09-15 20:41:31',1,'#include \"stdafx.h\"\r\n\r\n#include <iostream>\r\n#include <functional>\r\n\r\nconst int step = 100;\r\n\r\ndouble Integral(std::function<double (double)> f, double a, double b)\r\n{\r\n		double h = (b - a) / step;\r\n		double result = 0;\r\n		for (int i = 0; i < step; i ++)\r\n		{\r\n				result += f(a) * h;\r\n				a += h;\r\n		}\r\n		return result;\r\n}\r\n\r\nint main()\r\n{\r\n		std::cout << \"x + 2: \" << \r\n				Integral([] (double x) -> double\r\n				{\r\n						return x + 2;\r\n				}, 0, 2) << \"\r\n\";\r\n		\r\n		auto f = [] (double x) -> double\r\n		{\r\n				return x * x - 3;\r\n		};\r\n\r\n		std::cout << \"x * x - 3: \" << Integral(f, 0, 2);\r\n}\r\n','<br/>Тесты успешно пройдены!'),(4610,30,'shkuratov.ilya','2013-09-15 19:56:00',1,'parts [] = False\r\n\r\nparts (x:xs) = parts\' xs 1 x\r\n\r\n\r\n\r\n-- ml - minimum sequence length\r\n\r\n-- cl - current sequence length\r\n\r\n\r\n\r\nparts\' [] ml _ = ml > 1\r\n\r\n	\r\n\r\nparts\' xs ml x = \r\n\r\n	let y = head xs\r\n\r\n	in if y > x\r\n\r\n	then parts\' (tail xs) (ml + 1) y\r\n\r\n	else parts\'\' (tail xs) ml 1 y\r\n\r\n\r\n\r\nparts\'\' [] ml cl _ = \r\n\r\n	if (gcd ml cl) > 1\r\n\r\n	then True\r\n\r\n	else False\r\n\r\n\r\n\r\nparts\'\' xs ml cl x = \r\n\r\n	let y = head xs\r\n\r\n	in if y > x\r\n\r\n	then parts\'\' (tail xs) ml (cl + 1) y\r\n\r\n	else let d = gcd ml cl \r\n\r\n		in if d > 1\r\n\r\n		then parts\'\' (tail xs) d 1 y\r\n\r\n		else False\r\n','<br/>Тесты успешно пройдены!'),(4608,26,'7475152','2013-09-15 18:34:55',0,'rev\' xs i = if i==1 then xs\r\n	    else  (rev\' (tail xs) (i-1))++[head xs] \r\nrev xs = rev\' xs (length xs)','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(4609,26,'7475152','2013-09-15 18:39:26',1,'rev\' xs i = if i<=1 then xs\r\n	    else  (rev\' (tail xs) (i-1))++[head xs] \r\nrev xs = rev\' xs (length xs)','<br/>Тесты успешно пройдены!'),(4606,23,'7475152','2013-09-15 17:30:57',1,'f n k = if (k==n) then True\r\n	else \r\n            if (n>=k*2) then f n (k*2)\r\n	    else False\r\n\r\ng n k = if (f (n-k) 1) then True\r\n	else \r\n            if (n>=k*2) then g n (k*2)\r\n 	    else False 	\r\nb n = g n 1','<br/>Тесты успешно пройдены!'),(4607,31,'7475152','2013-09-15 18:13:33',1,'isAr xs q = if length xs>1 then\r\n                  if (head xs - head(tail xs))/=q then False\r\n                  else isAr (tail xs) q\r\n              else True \r\nisArithm xs = isAr xs (head xs - head(tail xs))','<br/>Тесты успешно пройдены!'),(4605,31,'21743638','2013-09-15 13:07:34',1,'isArithm (x:xs) = isArithm1 xs x (head xs - x) True\r\n\r\nisArithm1 [] _ _ b = b\r\n\r\nisArithm1 (x:xs) p m b = if x-p /= m then isArithm1 [] p m False else isArithm1 xs x m b\r\n','<br/>Тесты успешно пройдены!'),(4603,29,'21743638','2013-09-15 12:44:09',1,'checkDifferent (x:xs) = check xs xs x True\r\n\r\ncheckDifferent [] = True\r\n\r\ncheck [] [] p b = b\r\n\r\ncheck xs (y:ys) p b = let {t = tail xs; h = head xs} in if p == y then check [] [] p False else \r\n\r\n	if  ys == [] then check t t h b else check xs ys p b\r\n','<br/>Тесты успешно пройдены!'),(4604,29,'57304539','2013-09-15 12:54:56',1,'cont [] _ = False\r\n\r\ncont xs x = if head xs == x \r\n\r\n			then True\r\n\r\n			else cont (tail xs) x\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent (x:xs) = if cont xs x \r\n\r\n				then False\r\n\r\n				else checkDifferent xs\r\n\r\n	\r\n','<br/>Тесты успешно пройдены!'),(4600,31,'SMakarov','2013-09-14 16:20:50',1,'f (x:xs) n = if xs == [] then True else b (x:xs) n\r\nb (x:xs) n = if head xs - x == n then f xs n else False\r\nisArithm (x:xs) = if f (xs) (head xs - x) then True else False\r\n   --- или короче isArithm (x:xs) = f (xs) (head xs - x)','<br/>Тесты успешно пройдены!'),(4601,23,'SMakarov','2013-09-14 17:23:54',0,'f n = if n < 2 then [n] else (f (div n 2)) ++ [(mod n 2)]\r\ncheck [] = 0\r\ncheck xs = if (head xs) == 1 then check (tail xs) + 1 else check (tail xs)\r\nb n = if n == 2 then True else if check (f n) == 2 then True else False','Хитрый тест номер 4 не пройден :(<br/>Подсказка: степени двойки могут быть и одинаковыми'),(4599,28,'21743638','2013-09-14 01:34:13',1,'check cond xs = check1 cond xs False\r\n\r\ncheck1 cond [] b = b\r\n\r\ncheck1 cond (x:xs) b = if cond x then check1 cond [] True else check1 cond xs b\r\n   --- Или проще \r\n   --- check1 cond (x:xs) b = if cond x then True else check1 cond xs b','<br/>Тесты успешно пройдены!'),(4596,27,'21743638','2013-09-13 20:54:55',1,'minsum (x:xs) = minsum1 xs x k where k = head xs\r\n\r\nminsum1 [] _ m = m\r\n\r\nminsum1 (x:xs) p m = let m1 = p+x \r\n\r\n	in if m1<m then minsum1 xs x m1 else minsum1 xs x m\r\n','<br/>Тесты успешно пройдены!'),(4597,26,'21743638','2013-09-14 01:12:44',0,'rev (x:xs) = rev\' xs [x]\r\n\nrev\' [] ys = ys\r\n\nrev\' xs ys = let {t = tail xs; k = head xs:ys} in rev\' t k\n','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(4598,26,'21743638','2013-09-14 01:16:06',1,'rev (x:xs) = rev\' xs [x]\r\n\r\nrev [] = []\r\n\r\nrev\' [] ys = ys\r\n\r\nrev\' xs ys = let {t = tail xs; k = head xs:ys} in rev\' t k\r\n','<br/>Тесты успешно пройдены!'),(4591,29,'7475152','2013-09-13 20:21:14',0,'check\' x [] = True\r\ncheck\' x xs = if x==(head xs)\r\n              then False\r\n              else check\' x (tail xs)\r\ncheck [] x = True\r\ncheck xs x = if (check\' x (tail xs)) \r\n             then False\r\n             else check (tail xs) (head(tail xs))   \r\n\r\ncheckDifferent xs = check  xs (head xs)','Выражение имеет неправильное значение: checkDifferent [3,2,7]'),(4592,29,'7475152','2013-09-13 20:30:54',1,'check\' x [] = True\r\ncheck\' x xs = if x==(head xs)\r\n              then False\r\n              else check\' x (tail xs)\r\ncheck [] x = True\r\ncheck xs x = if (check\' x (tail xs)==False) \r\n             then False\r\n             else check (tail xs) (head (tail xs))   \r\n\r\ncheckDifferent xs = check  xs (head xs)','<br/>Тесты успешно пройдены!'),(4593,25,'21743638','2013-09-13 20:31:17',1,'minlist (x:xs) = minlist\' xs x\r\n\r\nminlist\' [] m = m\r\n\r\nminlist\' (x:xs) m = if x<m then minlist\' xs x else minlist\' xs m \r\n','<br/>Тесты успешно пройдены!'),(4594,28,'7475152','2013-09-13 20:34:57',1,'check cond [] = False\r\ncheck cond xs = if cond (head xs)  \r\n            then True\r\n            else check cond (tail xs)\r\n','<br/>Тесты успешно пройдены!'),(4595,27,'7475152','2013-09-13 20:43:24',1,'f xs y =  if length xs /=1 \r\n          then   \r\n            let sumOf2 = (head xs + head(tail xs))\r\n            in\r\n             if sumOf2 < y \r\n             then f (tail xs) sumOf2\r\n	     else f (tail xs) y\r\n	   else  y                  \r\nminsum xs = f (tail xs) (head xs + head(tail xs))','<br/>Тесты успешно пройдены!'),(4589,28,'7475152','2013-09-13 19:39:57',1,'check\' cond [] = False\r\ncheck\' cond xs = if cond (head xs)  \r\n            then True\r\n            else check\' cond (tail xs)\r\ncheck cond xs = check\' cond xs\r\n   --- OK, oчень хорошо\r\n   --- Просто как замечание, тут check\' особо ни к чему, все правила можно написать прямио для check\r\n','<br/>Тесты успешно пройдены!'),(4590,29,'7475152','2013-09-13 20:19:55',0,'check\' x [] = False\r\ncheck\' x xs = if x==(head xs)\r\n              then True\r\n              else check\' x (tail xs)\r\ncheck [] x = False\r\ncheck xs x = if (check\' x (tail xs)) \r\n             then True\r\n             else check (tail xs) (head(tail xs))   \r\n\r\ncheckDifferent xs = check  xs (head xs)','Выражение имеет неправильное значение: checkDifferent [3,2,7]'),(4584,25,'SMakarov','2013-09-13 13:51:38',1,'f [] n = n\r\nf (x:xs) n = if x < n then f xs x\r\n			 else f xs n\r\nminlist xs = f (xs) (head xs)\r\n   --- Тут скобки вокруг xs не нужны','<br/>Тесты успешно пройдены!'),(4585,27,'SMakarov','2013-09-13 14:05:08',1,'f (x:xs) n = if xs == [] then n else b (x:xs) n\r\n   --- Функция b не очень нужна, всю логику можно вписать прямо сюда (вложенный if)\r\nb (x:xs) n = if (x + (head xs) < n) then f xs (x + (head xs))\r\n			 else f xs n\r\n   --- Немного лучше не считать сумму два раза (например, с помощью let\r\n   --- Еще, совсем не важно, но большая часть скобок тут лишняя. \r\n   --- Можно  if x + head xs < n then f xs (x + head xs)\r\nminsum (x:xs) = f (xs) (x + head xs)','<br/>Тесты успешно пройдены!'),(4586,26,'SMakarov','2013-09-13 14:15:49',1,'f [] ys = ys\r\nf xs ys = f (tail xs) ([head xs] ++ ys)\r\nrev xs = f xs []','<br/>Тесты успешно пройдены!'),(4587,29,'SMakarov','2013-09-13 14:26:36',1,'checkDifferent [] = True\r\ncheckDifferent xs = if b (xs) == False then False else checkDifferent (tail xs)\r\nb (x:[]) = True\r\nb (x:xs) = if x == (head xs) then False else b ([x] ++ (tail xs))\r\n   --- ([x] ++ (tail xs)) - лучще x : (tail xs). Это одно и то же, но котороче и немного быстрее работает.','<br/>Тесты успешно пройдены!'),(4588,28,'SMakarov','2013-09-13 14:31:29',1,'check cond [] = False\r\ncheck cond xs = if cond (head xs) == True then True else check cond (tail xs)\r\n  --- == True можно не писать, просто if cond xs','<br/>Тесты успешно пройдены!'),(4490,18,'517309','2013-08-23 09:37:28',0,'f x = 1','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4491,18,'517309','2013-08-23 09:38:24',0,'f 1 = 1\r\nf 3 = 1.66666666\r\nf _ = 2','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4492,20,'517309','2013-08-23 09:41:13',0,'sumfact n = 1','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса'),(4493,20,'517309','2013-08-23 09:41:49',0,'f 1 = 1','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса'),(4494,20,'517309','2013-08-23 09:42:21',0,'sumfact 1 = 1','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса');

/*Table structure for table `task` */

DROP TABLE IF EXISTS `task`;

CREATE TABLE `task` (
  `TaskID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskForHometask` int(11) NOT NULL,
  `HometaskID` int(11) NOT NULL,
  `Condition` mediumtext NOT NULL,
  `Price` int(11) NOT NULL,
  PRIMARY KEY (`TaskID`),
  UNIQUE KEY `TaskForHometask` (`TaskForHometask`,`HometaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=165 DEFAULT CHARSET=utf8;

/*Data for the table `task` */

insert  into `task`(`TaskID`,`TaskForHometask`,`HometaskID`,`Condition`,`Price`) values (18,1,1,'Описать функцию f n, которая вычисляет \r\n 1+1/(1+1/(1+ ...+1/1))    - n дробей\r\n\r\nПример вызова:\r\n   f 3\r\nДолжно получиться 1+1/(1+1/(1+1/1)), то есть 1.6666..\r\n        ',1),(19,3,1,'Описать функцию \r\n sumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\n sumsin 2\r\nДолжно получиться sin(1+2)/(sin 1+sin 2); это равно примерно 0.08 \r\n        ',1),(20,4,1,'Описать функцию sumfact n: \r\n sumfact n = 1!+2!+...+n!\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\nsumfact 3\r\nРезультат должен быть равен 9.\r\n        \r\n        \r\n        ',1),(21,5,1,'* Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?\r\nНапример, для n = 9 существуют такие последовательности:\r\n 1 2 6, 1 3 5, 1 8, 2 3 4, 2 7, 3 6, 4 5, 9\r\n, то есть ответ на вопрос равен 8\r\n\r\nОпишите функцию nseq n, которая вычисляет количество таких последовательностей.\r\n\r\nПример вызова:\r\n nseq 9\r\nРезультат должен быть равен 8.\r\n        \r\n        ',1),(22,1,2,'*Дополнительная задача*\r\nОпишите функцию g, которая для данного целого числа, проверяет, можно ли его представить в виде суммы двух различных простых чисел, и возвращает True или False.\r\n\r\nПримеры вызова:\r\n  g 6 должно быть равно False\r\n  g 7 должно быть равно True (так как 7 = 2 + 5).\r\n\r\nЗамечание:\r\n О похожей (но не совсем такой же) задаче написан целый роман см. например: http://royallib.ru/book/doksiadis_apostolos/dyadyushka_petros_i_problema_goldbaha.html\r\n        \r\n        \r\n        ',1),(23,2,2,'*Дополнительная задача*\r\nОпишите функцию b n, которая для данного целого числа n проверяет, можно ли представить данное число, как сумму двух степеней двойки, и возвращает True или False.\r\n\r\nПример вызова:\r\n b 10 - должно получиться True, потому что 10 = 8 + 2\r\n b 22 - должно получиться False\r\n b 17 - должно получиться True, потому что 17 = 16 + 1 (и 1 - это тоже степень 2)\r\n        ',1),(24,2,1,'Описать функцию b n, которая вычисляет \r\n 0+1/(1+1/(2+1/(3+ ...+1/n))) - n дробей\r\n\r\nПример вызова:\r\n b 3\r\nДолжно получиться 0+1/(1+1/(2+1/3)), то есть 0.7\r\n        \r\n        \r\n        ',1),(25,1,3,'Описать функцию minlist, которая ищет минимальный элемент в данном списке.\r\n\r\nПример вызова:\r\n  minlist [3,2,7]\r\nОтвет должен быть равен 2.\r\n\r\nЗамечание: На самом деле, конечно, в Хаскеле есть такая стандарная функция (называется minimum), но, пожалуйста, в этой задаче вы ее не используйте.\r\n        \r\n        ',1),(26,3,3,'Описать фунццию rev, которая для списка возвращает список из тех же элементов, но идуших в обратном порядке.\r\n\r\nПример вызова:\r\n  rev [1, 3, 7] \r\n- должен получиться список [7, 3, 1].\r\n\r\nЗамечания:\r\n- Желательно (но не обязательно) описать эту функцию так, чтобы ее время работы было O(n). Технически это означает, что желательно написать функцию, в которой не будет использоваться приписывание в конец списка с помощью ++[x].\r\n- Но, если так не получиться, присылайте любое решение, какое придумаете.\r\n- Конечно, в этой задаче нельзя использовать стандартную функцию reverse.\r\n        \r\n        \r\n        ',1),(29,5,3,'Описать функцию checkDifferent, которая возвращает True, если все элементы в списке разные, и False, если среди них есть одинаковые.\r\n\r\nПримеры вызова:\r\n  checkDifferent [3,2,7]\r\nОтвет должен быть равен True.\r\n  checkDifferent [3,2,7,5,7,8]\r\nОтвет должен быть равен False (два раза встречается число 7).',1),(27,2,3,'Описать функцию minsum, которая ищет минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nПример вызова:\r\n  minsum [1,8,3,2,7]\r\nОтвет должен быть равен 5 (3+2).\r\n        ',1),(28,4,3,'Описать функцию \r\n  check cond xs\r\n, которая для данного списка xs и логической функции cond проверяет, верно ли, что в списке есть элемент, для которого cond возвращает True. Результат должен быть равен True, если такой элемент есть, и False, если его нет.\r\n\r\nПримеры вызова:\r\n check (\\x->x>5) [3,2,7,4]\r\nОтвет должен быть равен True, потому что в списке есть число, большее 5 (это число 7). \r\n\r\n check (\\x->x<1) [3,2,7,4]\r\nОтвет должен быть равен False, потому что в списке нет чисел, меньших 1. \r\n\r\nЗамечание: И такая стандартная функция в Хаскеле есть (называется any), но, пожалуйста, в этой задаче вы ее не используйте.        \r\n        \r\n        \r\n        \r\n        ',1),(30,1,4,'*Доп.задача*\r\nНаписать функцию parts, которая для данного списка проверяет, можно ли его разбить \r\nна несколько строго возрастающих кусков одинаковой длины. \r\n\r\nДлина кусков должна быть не меньше 2. Кусок может быть и только один.\r\n\r\nПримеры вызова:\r\n parts [1, 2, 8, 2, 5, 6]\r\n parts [1, 2, 3, 4, 5]\r\n parts [1, 2, 1, 2, 3, 4]\r\nВо всех этих случаях ответ должен быть равен True.\r\n parts [4, 6, 3, 5, 7]\r\nТут ответ должен быть равен False.\r\n        ',1),(31,2,4,'*Доп.задача, попроще*\r\nНаписать функцию isArithm, которая проверяет, верно ли, что данный список целых чисел содержит числа, образующие арифметическую прогрессию.\r\nПримеры вызова:\r\n isArithm [1, 2, 3, 4]\r\n isArithm [10, 5, 0]\r\n isArithm [3, 3, 3]\r\n isArithm [1, 2]\r\nВо всех этих примерах ответ должен быть True.\r\n\r\n isArithm [1, 2, 3, 2]\r\nОтвет должен быть False.\r\n\r\nЗамечание:\r\n- можно считать, что в списке точно есть по крайней мере 2 числа.\r\n        ',1),(128,5,6,'Пусть в нашей программе мы хотим хранить информацию о товарах в кондитерском магазине. Товары могут быть:\r\n- или тортами, и тогда мы храним их название, вес и цену, \r\n- или конфетами, и тогда мы храним их название и цену за килограмм.\r\nа. Опишите тип данных Candy, позволяющий хранить такую информацию.\r\nб. Опишите функцию bestCake, которая для данного списка товаров возвращает название самого дорогого торта.\r\n\r\nЗамечание: Тестов в этой задаче не будет, потому что я не знаю, какой тип данных вы опишете. Но, пожалуйста, включите в решение пример вызова bestCake. Т.е. что-то вроде:\r\n\r\ntest = bestCake ...какой-то список...\r\n\r\n\r\n        ',1),(33,1,5,'*Доп. задача*\r\nОчень простая функция высшего порядка на C#\r\n\r\nНаписать на C# функцию (статический метод) Integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:\r\n- f - функция (статический метод или лямбда выражение) \r\n- a, b - пределы интегрирования.\r\nПример вызова:\r\n\r\n   double result = Integral(x => x*x, 0, 1);\r\n\r\nМетод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций.\r\n\r\nЗамечания:\r\n- Пример похожей программы есть вот тут: http://msimuni.wikidot.com/fp-dop2\r\n- Там же всякие замечания про то, зачем эти задачки про \"обычные\" языки, как их сдавать и т.д. \r\n- Если хотите, можете сделать задачу на С++ или на каком-нибудь другом \"обычном\" языке. Если есть сомнения, подойдет ли тот или иной язык, пишите.\r\n        \r\n        ',1),(35,1,6,'Опишите функцию isosc (от слова isosceles - равнобедренный), у которой три параметра - пары целых чисел, и которая возвращает True, если соответствующие точки на плоскости задают равнобедренный треугольник, а иначе False.\r\n\r\nПримеры вызова:\r\n  isosс (0, 2) (2, 0) (2,2)\r\n     - результат должен быть равен True\r\n  isosс (-3, 2) (2, 0) (2,2)\r\n     - результат должен быть равен False\r\n        \r\n        ',1),(36,2,6,'Описать функцию cubeTable, которая для данного n возвращает список пар чисел (i, i в кубе) для всех i от 1 до n.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но, видимо, особо не нужно), определять свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n  cubeTable 4\r\nДолжно получиться [(1, 1), (2, 8), (3, 27), (4, 64)]\r\n        ',1),(37,3,6,'Определить функцию minsum, такую же, как в задаче 3.2. Т.е. функция должна искать минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но не очень нужно), определать свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n minsum [1,8,3,2,7] \r\nОтвет должен быть равен 5 (3+2).\r\n\r\n        \r\n        ',1),(38,4,6,'Описать функцию height, хоторая ищет высоту данного дерева. \r\n\r\nЗамечание: В задаче вы сначала должны описать data для дерева. И его надо описать точно так же, как на занятии. Извините за ограничение вашей творческой свободы, но это, понятно, ограничение системы тестирования..\r\n\r\nПримеры вызова:\r\n  height (Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  height (Node 1 (Node 1 Empty Empty) Empty)\r\nОтвет должен быть 1\r\n        \r\n        \r\n        ',1),(39,5,57,'* Описать функцию minHeight, хоторая для данного дерева возвращает минимум расстояния от корня до какого-нибудь листа. \r\n\r\nЗамечание: В этой задаче _обязательно_ должна быть реализована оптимизация, о которой мы говорили на занятии.\r\n\r\nНапоминание: Лист - это вершина, у которой и левое и правое поддеревья пустые.\r\n\r\nПримеры вызова:\r\n  minHeight(Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  minHeight (Node 1 \r\n               (Node 2 \r\n                  (Node 3 Empty Empty)\r\n                   Empty)\r\n               (Node 4 Empty Empty))\r\nОтвет должен быть 1 (расстояние от корня до вершины 4)\r\n        \r\n        \r\n        ',1),(40,1,12,'\"Рамочка\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле двумерные массивы. Описать функцию frame n, которая возвращает список списков, соответствующий массиву n на n, в котором по краям (в первом и последнем столбце и в первой и последней строке) все элементы равны 1, а все остальные элементы равны 0.\r\n\r\nПример вызова:\r\n  frame 4\r\nДолжно получиться:\r\n [[1, 1, 1, 1],\r\n  [1, 0, 0, 1],\r\n  [1, 0, 0, 1],\r\n  [1, 1, 1, 1]]\r\n        ',1),(41,2,12,'Опишите две функции, countOdd и countOdd1, которые для данного списка вычисляют количество нечетных чисел в этом списке. (Т.е. надо написать две версии одной функции).\r\n\r\nДополнительные условия:\r\n- В функции countOdd можно использовать _только_ стандартную функцию foldr. Точнее, можно, конечно, использовать функwию mod, но нельзя использовать map, filter и т.д.  Можно (но особо не нужно) задавать свои нерекурсивные функции. Можно,  \r\nконечно, использовать лямбда-выражения.\r\n\r\n- В функции countOdd1 можно использовать любые стандартные функции (в частности map и filter), и тоже, если надо, можно использовать свои нерекурсивные функции и лямбда-выражения. Но _нельзя_ определять свои рекурсивные функции.\r\n\r\nПример вызова:\r\n  countOdd [2, 3, 4, 8, 5, 33, 9]\r\nОтвет должен быть равен 4\r\n        ',1),(42,3,12,'Опишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl (т.е. сворачивает все элементы слева направо).\r\n\r\nПример вызова:\r\n  myfoldl (+) 0 [1,2,3]\r\nФункция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить именно в таком порядке.  \r\n        \r\n        ',1),(43,1,7,'*Доп задача, до 3.10*\r\nУ функции два параметра - целые числа a и b. Точно известно, что они взаимно простые. Функция должна вернуть такую пару целых чисел x и y, что a*x + b*y == 1. (Таких пар, конечно, бесконечно много, можно вернуть любую).\r\n\r\nПример вызова:\r\n euclid 3 5\r\nДолжно получиться (2, -1), потому что 3*2+5*(-1) == 1\r\n\r\nЗамечания:\r\n- Если a и b не взаимно простые, то функция может делать что угодно (например, аварийно завершаться, или выдавать любой ответ).\r\n- Желательно, чтобы функция быстро работала для _очень_ больших чисел, например, для 2^100 и 3^100. Но, если не получится, напишите любое решение, не обязательно очень эффективное (например, которое ищет решения перебором).\r\n- Подсказка: идея, которую можно использовать для эффективного решения, была впервые опубликована примерно в 300 г. до н.э. :)\r\n        \r\n        \r\n        ',1),(44,2,7,'*Доп задача попроще, до 3.10*\r\nОписать функцию averageForLeaves, которая для данного дерева вычисляет среднеарифметическое всех чисел, записаных в его листьях.\r\n\r\nПример вызова:\r\n\r\naverageForLeaves (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\nОтвет должен быть равен 2.5 (в этом дереве два листа, содержащие числа 2 и 3.\r\n\r\nЗамечания:\r\n- Напоминание: лист - это вершина, у которой левое и правое поддерево равны Empty.\r\n- На всякий случай: Если эта задача кажется вам сложной/непонятной, вы можете решить более простую задачу - написать функцию countLeaves, которая возвращает количество листьев. Тесты, конечно, не пройдут, но я зачту задачу.\r\n        ',1),(133,5,9,'\"Единичная матрица\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию identity n, которая возвращает список списков, соответствующий единичной матрице n на n. Т.е. элементы на главной диагонали д.б. равны 1, а все остальные элементы равны 0.\r\n\r\nПример вызова:\r\nidentity 4\r\nДолжно получиться:\r\n[[1, 0, 0, 0],\r\n[0, 1, 0, 0],\r\n[0, 0, 1, 0],\r\n[0, 0, 0, 1]]',1),(45,1,8,'*Задача (скорее упражнение) на \"обычном\" языке (дополнительная, до 4.10 включительно*\r\n\r\nВ С# для контейнеров определен метод Any, который позволяет проверить, есть ли в контейнере элемент, удовлетворяющий данному условию. И есть аналогичный метод All.  Вот примеры их вызовов:\r\n\r\n  int [] a = {-1, 2, -3, 4};\r\n  bool b = a.Any(x => x > 0);     // Верно, ли что в массиве есть положительный элемент?\r\n  b = a.All(x => x > 0);         // Верно, ли что все элементы в массиве положительные?\r\n\r\nИспользуя только эти методы и лямбда выражения, проверить для данного двумерного массива массивов (или, если хотите, списка списков), \r\nчто в каждом из массивов есть хотя бы один четный элемент.\r\n\r\nЗамечания:\r\n- Если для кого-то задача кажется слишком сложной,  а попробовать функциональное программирование в С# хочется, можете решить задачу попроще:\r\n  \"Дан массив чисел. Проверить, верно ли, что в этом массиве, есть хотя бы одно двузначное число\"\r\n- Желающие могут сделать эту задачу на любом \"обычном\" языке, в котором есть похожие возможности\r\n- На С++, частности, есть аналогичные функции any_of, all_of и даже еще функция none_of. \r\n- На эту задачу тестов нет, вы просто можете выложить в систему код, и я его просмотрю.\r\n- Но код должен быть таким, чтобы его можно было скомпилировать и запустить, с каким-нибудь примером вызова.\r\n        ',1),(132,4,9,'Описать функцию f, которая для данного списка возвращает новый список, в которой все числа 1 заменены на -1, остальные числа оставлены без изменения.\r\n\r\nПример вызова:\r\n f [2, 3, 1, 4, 1, 8]\r\nДолжно получиться [2, 3, -1, 4, -1, 8]\r\n\r\nДополнительное условие:\r\n- В этой задаче желательно использовать только стандартные функции и лямбда-выражения. Но, если не получиться, напишите любое решение.\r\n\r\n        ',1),(129,1,9,'Пусть у нас пары целых чисел задают точки на плоскости, а списки пар целых чисел задают ломаные (не замкнутые).\r\nОписать функцию len, которая для данного списка пар находит длину ломаной.\r\n\r\nПример вызова:\r\n  len [(1,1), (1,2), (2,1)]\r\nОтвет должен быть примерно 2.41 - длина ломаной из двух звеньев между этими точками.',1),(130,2,9,'Описать функцию findTree, которая для данного дерева поиска и данного числа проверяет, принадлежит ли число дереву, и возвращает True или False. \r\n\r\nПример вызова:\r\n  findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 2\r\nОтвет должен быть равен True\r\n\r\nЗамечание:\r\n  - Функция обязательно использовать то, что дерево - это дерево поиска. Т.е. надо не просто перебирать все элементы, поиск должен быть быстрым.\r\n  - Если вы вдруг забыли, что такое дерево поиска, вы можете мне написать, я поясню.',1),(131,3,9,'Телепрограмма\r\n\r\nПусть мы хотим хранить информацию о телепередачах - фильмах и сериалах. \r\n- про фильмы мы храним их название, год выпуска и фамилию режиссера\r\n- про сериалы мы храним название и номер серии\r\n\r\nа. Опишите тип данных, позволяющий хранить такую информацию.\r\nб. Опишите функцию haveNewFilm, которая для данного списка телепередач проверяет, есть ли в нем хотя бы один фильм 2013 года, и возвращает True или False.\r\n\r\nЗамечание: Тестов в этой задаче не будет, потому что я не знаю, какой тип данных вы опишете. Но, пожалуйста, включите в решение пример вызова haveNewFilm. Т.е. что-то вроде\r\n\r\ntest = haveNewFilm ...какой-то список...',1),(49,1,59,'*Доп.задача, до 15.10*\r\nОписать на C# тип \"двоичное дерево, элементы которого - целые числа\". Для этого дерева опишите аналог функции Any, которая обсуждалась в задаче 7.1. У этой функции должен быть параметр \"условие\" - логическая функция, и она должна проверять, есть ли a дереве элемент, удовлетворяющий условию.\r\n\r\nТ.е. решение должно состоять из программы на C#, в которой:\r\n- описан тип \"дерево\"\r\n- описана функция, аналогичная Any, но для дерева. Это может быть метод класса \"дерево\", или отдельная статическая функция, как хотите.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызвана функция Any. \r\n\r\nСправка: Логические функции можно описать как Function<int, bool>. (Или можно описать как Predicate<int> - это одно и то же.)\r\n\r\nЗамечания:\r\n- Проще всего весь код записать в одном файле, и поместить в систему тестирования. Но, если хотите, вы можете создать несколько файлов (один для дерева, другой для Main) и прислать мне их по почте.\r\n- Эта задача, конечно, немного посложнее предыдущих по C# - те были, скорее, упражнениями. Если что-то будет не получатся, можете писать и задавать вопросы..\r\n        \r\n        \r\n        \r\n        ',1),(50,2,59,'*Доп.задача, до 15.10*\r\nОписать на C++ тип \"двоичное дерево, элементы которого - целые числа\". Для этого дерева опишите что-то похожее на функцию Any из задачи 7.1. \r\n\r\nВ этом случае, видимо, проще всего описать шаблон функции any, примерно так же, как мы описывали шаблон для интеграла. Один из параметров этой функции - условие, которое надо проверить, в другой - корень дерева (или указатель на корень дерева, как будет удобнее).\r\n\r\nТ.е. решение должно состоять из программы на C++, в которой:\r\n- описан тип \"дерево\"\r\n- описана шаблон функции, аналогичной Any из 7.1, но для дерева.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызван этот шаблон. \r\n\r\nЗамечания:\r\n- Замечания те же, что 10.1. Эта задача, конечно, немного посложнее предыдущих по C++. Если что-то не получается или непонятно, можете задавать вопросы..\r\n        \r\n        \r\n        \r\n        ',1),(51,4,12,'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n        ',1),(52,2,13,'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n\r\nДополнительное условие:\r\n - В этой задаче нельзя определять свои рекурсивные функции. Можно использовать стандартные функции и можно, если хотите, определять нерекурсивные функции.\r\n\r\nЗамечание:\r\n - Если вы решите эту задачу до 7.10, то можете выложить ее решение и как решение для задачи 12.4, оно будет засчитано.\r\n        ',1),(53,1,15,'Перечислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. Результат должен быть списком списков целых чисел, каждый внутренний список - это список из трех элементов [k,l,m], где k - двухкопеечных  монет, l - количество трехкопеечных, m - количество пятикопеечных монет.\r\n\r\nПример вызова:\r\n  coins 10\r\n\r\nДолжно получиться:\r\n [[5,0,0],[2,2,0],[0,0,2],[1,1,1]]\r\n(порядок троек в ответе может быть и другим).\r\n\r\nЗамечание:\r\n - Вообще это упражнение на list comprehension. Но, если хотите, вы можете решить задачу и без list comprehension, как хотите.\r\n        ',1),(54,3,15,'Пусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:\r\n - или сопротивление, тогда известно его величина в омах\r\n - или две схемы, соединенных параллельно\r\n - или две схемы, соединенных последовательно\r\n(На самом деле есть схемы, которые таким способом не описать, ну и ладно..)\r\n\r\n1. Опишите тип (data) Scheme, который позволяет описывать такие схемы.\r\n2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы.\r\n\r\nНапример, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2.\r\n\r\nЗамечания:\r\n- Для этой задачи тестов не будет, потому что я не знаю, как вы решите представлять схемы. Но я проверю задачи вручную.\r\n- Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)\r\n        ',1),(56,2,16,'*Доп.задача, до 24.10*\r\nОписать функцию allLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n. \r\n\r\nПример вызова:\r\n allLists 3 2\r\n\r\nДолжно получиться:\r\n [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- В общем случае в списке должно быть, понятно, n^k элементов.\r\n- Подсказка: Я бы советовал использовать list comprehension, получится очень просто.\r\n- Еще подсказка: Я бы рассуждал так: для k == 2 решение этой задачи легко записать с помощью list comprehension с двумя генераторами. Собственно такой пример был на занятии. А как записать решение для k == 3? Можно, конечно, использовать list comprehension c тремя генераторами. Но ведь есть и другой вариант - воспользоваться решением для k == 2 и получить из него решение для k == 3. Если это написать, то, мне кажется, совсем ясно и что надо делать в общем случае. \r\n        ',1),(57,2,58,'*Доп.задача, до 21.10*\r\n\r\nОписать функцию canMakeScheme с двумя параметрами:\r\n - список целых чисел [r1, r2, … rn]. Этот список задает набор имеющихся у нас сопротивлений.\r\n - целое число m. \r\nФункция должна проверить, можно ли построить из этих сопротивлений (не обязательно из всех) электрическую схему с общим сопротивлением m и вернуть в качестве результата True или False. \r\nСаму схему строить не надо.\r\n\r\nПример вызова:\r\n  canMakeScheme [4,4,5] 7\r\n\r\nОтвет должен быть True, потому что мы можем соединить параллельно 4 и 4, а потом присоединить последовательно 5.\r\n\r\nЗамечание:\r\n - Можно считать, что сопротивлений будет не больше 5.\r\n - Если вы напишете решение, которое работает за разумное время (скажем, за 15 мин.) для 9 резисторов, выложите ее, как решение задачи 12-3, за нее будет 3 балла.\r\n - Если вы напишите решение, которое работает для 15 резисторов, присылайте мне, за нее будет 20 баллов (но я не думаю, что это возможно..). \r\n        \r\n        \r\n        \r\n        ',1),(58,3,58,'*Доп.задача, до 21.10*\r\nУсловие см. в задаче 12-2, задача должна работать для 9 сопротивлений. (Таких тестов в системе нет, но я проверю вручную). \r\n\r\n\r\n        \r\n        \r\n        \r\n        ',3),(59,1,14,'*Доп.задача на C#, до 18.10*\r\n\r\nАналогом map в C# является, видимо, метод Select, а  аналогом filter - метод Where (это части LINQ но их вполне можно использовать и просто как удобные методы). См. простые примеры вызова этих методов тут:\r\n  http://msimuni.wikidot.com/fp-select-where \r\n\r\nС помощью Select и Where опишите функцию nonZeroLastDigits, которая:\r\n - берет в качестве параметра массив целых положительных чисел\r\n - возвращает массив из последних цифр всех чисел из исходного массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\nНапример, если входной массив содержит числа 354, 20, 9, 31, то надо вернуть массив из чисел 4, 9, 1 .\r\n\r\nЗамечание:\r\n - Конечно, в этой задаче нет особого смысла, это просто несложное упражнение на вызов Select и Where.\r\n        ',1),(60,2,57,'*Доп.задача на С++, до 22.10*\r\n\r\nАналогом map в C++ является, видимо, функция transform, а аналогом filter - функция remove_if и  remove_copy_if. См. простые примеры вызова этих функций тут:\r\n  http://msimuni.wikidot.com/fp-select-where \r\n\r\nС помощью transform и remove_if (или remove_copy_if) опишите код,функцию nonZeroLastDigits, которая:\r\n - берет в качестве параметров массив целых положительных чисел и количество чисел\r\n - печатает последние цифр всех чисел из этого массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\nНапример, если входной массив содержал числа 354, 20, 9, 31, то функция должна напечатать 4, 9, 1 .\r\n\r\nЗамечание:\r\n - Честно говоря, transform и remove_if - это не самое удобная часть С++ ((. И, честно говоря, я лично ими никогда не пользовался и особо не собираюсь. И, конечно, поставленную задачу проще решить без всяких функций. \r\n - Т.е. это просто упражнение на использование стандартных функций С++, м.б. даже и не очень полезное, признаю((\r\n        \r\n        \r\n        \r\n        ',1),(61,1,18,'В этой задаче надо реализовать сразу две функции: \r\nа. Напишите функцию sumDiv, которая для данного целого положительного числа возвращает сумму всех его делителей (не учитывая в сумме сам это число).\r\nб. Напишите функция perfects n, которая возвращает список всех совершенных чисел, меньших или равных n.\r\n\r\nПримеры вызова:\r\n  sumDiv 10\r\nОтвет должен быть равен 8 (так как 1+2+5=8)\r\n  perfects 1000\r\nОтвет должен быть равен\r\n  [6,28,496]\r\n\r\nСправка: Число называется совершенным, если оно равно сумме своих делителей.\r\n        \r\n        \r\n        ',1),(62,2,18,'Напишите функция amicables n, которая возвращает список всех пар дружественных чисел, каждое из которых меньше или равно n. \r\nПример вызова:\r\n  amicables 1000\r\nОтвет должен быть равен\r\n  [(220,284)]\r\n\r\nСправка: Числа a и b называется дружественными, если a равно сумме делителей b, а b равно сумме делителей a.\r\n\r\nЗамечания: \r\n- Для единообразия давайте включать в список только те пары, в которых первое число меньше второго.\r\n- Видимо, имеет смысл скопировать и использовать функцмю sumDiv из задачи 14-1\r\n        \r\n        \r\n        ',1),(63,3,18,'Опишите переменную ones, как бесконечный список [1,11,111,1111,...] - т.е. список из целых положительных чисел, у которых все цифры равны 1.\r\n\r\nПример вызова:\r\n  take 7 ones\r\nОтвет должен быть равен:\r\n  [1,11,111,1111,11111,111111,1111111]\r\n        \r\n        \r\n        ',1),(64,4,18,'а. Опишите функцию foldTree, которая для дерева делает что-то аналогичное foldr или foldl для списков. Она должна вызываться так:\r\n\r\nfoldTree (+) 0 t — ищет сумму всех элементов в дереве\r\nfoldTree (*) 1 t — ищет произведение всех элементов в дереве\r\n\r\nб. Но м.б. можно придумать что-то более общее? Например, придумать такой вариант foldTree, который позволяет реализовывать более сложные функции (например, искать высоту дерева и т.д.). Если придумаете, предложите какой-нибудь такой вариант.\r\n\r\nЗамечания:\r\n- Условие, естественно, не совсем строгое (но так и в жизни часто бывает..). Если есть вопросы - пишите.\r\n- Пункт б. необязательный (хотя и не особо сложный). Решения, описанного в пункте а. вполне достаточно. \r\n- В этой задаче тестов не будет. Желательно, чтобы вы включили в текст 1-2 примера  того, как можно использовать программу.    \r\n        \r\n        \r\n        ',1),(65,2,19,'*Доп. задача, до 31.10*\r\n\r\nОписать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу).\r\n\r\nПример вызова:\r\n  take 100 cantor\r\n\r\nЧто получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.\r\n        ',1),(66,2,40,'*Доп. задача, до 28.10*\r\n\r\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\r\nПример вызова:\r\n  take 100 (generalizedCantor 3)\r\n\r\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет  [[1,1,1], [1,1,2], и т.д.\r\n        \r\n        \r\n        ',1),(67,3,60,'*Доп.задача до 30.10*\r\n\r\nИспользуя функцию transform из задачи 13-2, напишите функцию zeroDigits с тремя параметрами a (массив), size (размер массива), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 3, 2) в массиве должны быть числа 500, 5600, 76700\r\n\r\nЗамечания:\r\n- Важно: Eсли в С++ в лямбда-выражении используются нелокальные переменные (т.е. используется замыкание), то их надо перечислить в начале лямбда выражения в квадратных скобках (это так называемый список захвата - capture list). Например:\r\n\r\n  [n] (int i) { return i + n; }\r\n\r\n- список захвата можно записать и другими способами, но это остается для самостоятельного изучения :)\r\n        \r\n        \r\n        \r\n        \r\n        ',1),(68,1,20,'*Доп.задача до 31.10*\r\n\r\nИспользуя функцию Select из задачи 13-1, напишите функцию zeroDigits с двумя параметрами a (массив целых положительных чисел), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0 и вернуть полученный новый массив.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 2) должен вернуться массив из чисел 500, 5600, 76700\r\n        \r\n        \r\n        ',1),(69,1,21,'Описать функцию bigSin c параметром x, которая возвращает первый элемент в последовательности\r\n  sin 1, sin 2, sin 3, sin 4, ...\r\n, который больше или равен x. \r\n\r\nДополнительное условие: нельзя определять свои функции (кроме bigSin, конечно). Можно использовать любые стандартные функции и лямбда выражения.\r\n\r\nПример вызова:\r\n  bigSin 0.99\r\nрезультат должен быть равен примерно 0.990607\r\n\r\nЗамечания:\r\n - очевидная подсказка: тут, конечно, удобно использовать бесконечные списки. Но можно и без них, наверное.\r\n        ',1),(70,2,41,'Описать функцию myFilter - свою реализацию функции  filter c точно таким же интерфейсом.\r\nДополнительное условие: эта реализация должна использовать только функцию foldr и лямбда выражения.\r\n\r\nПример вызова:\r\n  myFilter (>0) [1,-2,3,-5]\r\nрезультат должен быть равен [1,3]\r\n        \r\n        ',1),(71,1,24,'a. Опишите функцию approxSum, параметр который - бесконечный список и которая считает сумму входящих в него элементов, пока очередной элемент не станет по модулю меньше 0.000001.\r\n\r\nб. Используя approxSum, сосчитайте приближенную сумму ряда 1/1 + 1/4 + 1/9 + ... + 1/(i*i) + ...\r\nЗначение этой приближенной функции присвойте переменной z.\r\n\r\nПример вызова:\r\n  z\r\nДолжно получиться примерно 1.64\r\n        ',1),(72,1,25,'*Доп.задача до 14.11*\r\n\r\nПусть в списке я записал последовательность чисел - сколько денег я тратил каждый день в этом году. Запись я начал, конечно же, с понедельника. \r\n\r\nОпишите функцию weekendExpences у которой параметр - такой список расходов, и которая вычисляет для него общую сумму расходов по выходным.\r\n\r\nПример вызова:\r\n  weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1, 3]\r\n\r\nОтвет должен быть равен 5+17+5+1 = 28.\r\n\r\nЗамечание:\r\n- В этой задаче можно (но не обязательно) использовать зацикленный список\r\n        ',1),(73,2,24,'Опишите бесконечный список fibs, состоящий из чисел Фибоначчи.\r\nДополнительное условие: желательно использовать прием \"завязывание в узел\" (tying the knot). Но, если не получится, можно решить эту задачу любым способом.\r\n\r\nПример вызова:\r\n  take 10 fibs\r\n\r\nРезультат должен быть равен:\r\n [1,1,2,3,5,8,13,21,34,55]\r\n\r\nЗамечание:\r\n- Безусловно эту задачу можно найти в интернете - и решение из интернета тоже засчитается. Но мне кажется интереснее попробовать самим что-то придумать, тем более это совсем и не сложно..\r\n        ',1),(74,4,24,'Используя функцию foldTree с последнего занятия (второй вариант, который катаморфизм), опишите функцию sumPos. У этой функции параметр - дерево, и она должна вычислять сумму всех положительных чисел в этом дереве.\r\n\r\nПример вызова:\r\n  sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\r\nОтвет должен быть равен 7.\r\n        ',1),(75,1,29,'В этой задаче надо прислать не программу, а просто текст.\r\na. Напишите, какой тип у функции foldr (если хотите, можете где-нибудь посмотреть, но интереснее, наверное, попробовать придумать)\r\nб. Попробуйте обосновать, как можно доказать, может быть и не очень формально, что тип foldr именно такой. \r\n\r\nЖелательно обосновать примерно так, как мы это делали на занятии для map (то, что называется алгоритм Хиндли-Милнера). Но подойдет и любое другое более-менее понятное обоснование.\r\n \r\nЗамечания:\r\n - текст foldr, на основании которого надо вывести тип, был у нас на занятии\r\n - если не очень понятно, что тут все-таки надо делать, пишите, обсудим.\r\n        ',1),(76,8,41,'Опишите класс Shape и типы Circle и Rect, как мы это делали на занятии. Добавьте в класс функцию perimeter и для Circle и Rect напишите ее определение.\r\n\r\nПримеры вызова:\r\n  perimeter (Circle 10)\r\nОтвет должен быть равен примерно 62.83\r\n  perimeter (Rect 3 7)\r\nОтвет должен быть равен 20  \r\n        \r\n        ',1),(77,1,42,'*Доп. задача, до 4.11*\r\n\r\nОписать sqrt2 как бесконечный список из чисел от 0 до 9, описывающий разложение sqrt(2) в бесконечную десятичную дробь. \r\n\r\nПример вызова:\r\n  take 20 sqrt2\r\n\r\nРезультат должен быть равен \r\n  [1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]\r\n\r\nЗамечания:\r\n - Это, видимо, больше задачка по выч. методам, а не по программированию.. Мне кажется, не очень сложная.\r\n - Подсказка: задача не очень сложная, потому что Haskell может выполнять операции над целыми числами любой длины. Тут это удобно.\r\n        \r\n        \r\n        \r\n        \r\n        ',1),(78,2,22,'*Доп. задача, до 7.11*\r\n\r\nОписать pascal как бесконечный список списков, содержащий треугольник Паскаля. \r\n\r\nПример вызова:\r\n  take 6 pascal\r\n\r\nРезультат должен быть равен \r\n  [[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]\r\n        \r\nЗамечание: \r\n- Я бы советовал использовать в этой задаче прием tying the knot. Но это не обязательно, вы можете решить ее любым способом. \r\n\r\n        \r\n        ',1),(79,1,23,'*Доп.задача на C# до 8.11*\r\n\r\nОпишите блок итератора digits(int n), возвращающий последовательность цифр дроби 1/n. Например, при обращении к digits(7) должны  возвращаться цифры 1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7, ...\r\n\r\nC использованием digits напишите программу, которая вводит число n и печатает первые 100 цифр числа 1/n.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n        ',1),(80,5,60,'*Доп.задача на C# до 5.11*\r\n\r\n\"Задача Кантора\" на С#\r\n\r\nОпишите на C# блок итератора, возвращающий последовательность всех пар целых положительных чисел.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n        \r\n        \r\n        ',1),(81,3,24,'Описать бесконечный список lst367, содержащий все целые положительные числа, состоящие только из цифр 3,6 и 7. (Числа должны идти в порядке возрастания).\r\n\r\nПример вызова:\r\n\r\n  take 15 lst367\r\n\r\nДолжно получиться:\r\n  [3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]\r\n\r\nЗамечание:\r\n - Эта задача, на самом деле, довольно эффектно решается с помощью tying the knot. Но, если не придумаете как тут завязать этот узел, эту задачу можно решить любым способом.\r\n        ',1),(82,2,43,'*Доп. задача, до 11.11*\r\n\r\nПусть у нас есть система равенств вида:\r\n  <переменная1> = <переменная2>.\r\nМы представляем ее в Хаскеле, как список пар строк. Например, список [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] описывает систему равенств:\r\n  x = y\r\n  y = z\r\n  n = m\r\nКроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\r\nПример вызова:\r\n  countDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]\r\n\r\nРезультат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\r\nЗамечания:\r\n - Это не упражнение на какую-то тему, которую мы проходили - тут надо просто написать более-менее нетривиальный алгоритм на Хаскеле.\r\n        \r\n        ',1),(83,1,28,'*Доп. задача на C#, до 22.11*\r\n\r\nРешить задачу про числа из цифр 3, 6, 7 на C#. Т.е., описать блок итератора Lst367(), который по очереди возвращает числа 3,6,7,33,36,37,63,66,67,73,76,77,333,336,337 и т.д.\r\n\r\nЗамечание:\r\n - Для C# эта задача очень просто решается с помощью приема tying the knot, даже может быть проще, чем на Хаскеле. Но вы можете решить эту задачу любым способом.\r\n        ',1),(84,2,44,'*Доп. задача на C#, до 12.11*\r\n\r\nОписать функцию Iterate, у которой следующие примеры вызова:\r\n\r\n  foreach (double x in Iterate(2, x => x*2))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (x > 1000000)\r\n        break;\r\n  }\r\n\r\nПечатает 2, 4, 8, 16, ... и т.д. - степени двойки до 1000000\r\n\r\n  int i = 0;\r\n  foreach (double x in Iterate(1, Math.Sin))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (i++ == 100)\r\n        break;\r\n  }\r\n\r\nПечатает 1, sin 1 , sin (sin 1), и т.д. 100 раз.\r\n\r\nКакие у этой функции должны быть параметры и тип результата, определите, пожалуйста, сами по примерам вызова.\r\n\r\nЗамечание:\r\n - Можно считать, что в этой задаче у нас речь идет только про вещественные числа. (Например, первый параметр Iterate точно имеет тип double.) В принципе, можно было бы определить и generic версию, которая работает с разными типами, но в данном случае это не требуется. \r\n        \r\n        \r\n        ',1),(85,1,35,'Определите тип Ration для представления дробей. Конструктор этого типа должен записываться так: Rat <числитель> <знаменатель>.\r\nДля этого типа: \r\na. Определите оператор + (сложение дробей)\r\nb. Определите оператор < (сравнение дробей)\r\nc. Определите функцию show, которая генерирует строковое представление дроби в формате <числитель>/<знаменатель> \r\n\r\nПримеры вызова:\r\n\r\nRat 1 2 + Rat 1 7\r\n\r\nДолжно быть напечатано\r\n\r\n9/14\r\n\r\n(потому что при выводе автоматически вызовется show) \r\n\r\nRat 1 3 < Rat 4 5\r\n\r\nРезультат должен быть равен True\r\n\r\nЗамечания:\r\n- Еще обязательно придется определить ==, без этого программа не будет компилироваться.\r\n- Надо ли сокращать дроби? Например, что будет, если сложить Rat 1 3 и Rat 1 6? \r\nОтвет: Как хотите, не обязательно сокращать. В тестах таких примеров не будет.\r\n- Как должна работать функция show, если знаменатель равен 1 и в других необычных случаях?\r\nОтвет: Тоже как хотите, тут тоже тесты будут только очень простые.\r\n        ',1),(86,2,45,'Определить функцию allNondivisible, которая проверяет, верно ли что в данном списке нет двух элементов, таких, что один делится на другой.\r\n\r\nДополнительное условие: В этой задаче, пожалуйста, обязательно используйте прием с представлением множества с помощью логической функции, который мы разбирали на занятии.\r\n\r\nПримеры вызова:\r\n\r\nallNondivisible [2, 7, 6, 5]\r\n\r\nРезультат должен быть равен False, потому что 6 делится на 2\r\n\r\nallNondivisible [4, 7, 6, 5]\r\n\r\nРезультат должен быть равен True, потому что ни одно число в списке не делится на другое.\r\n\r\nЗамечание: \r\nЕсли совсем непонятно, что это за прием такой, вы можете прислать любое решение этой задачи, а я, в обмен на это, подскажу, как ее делать с этим приемом :)\r\n        \r\n        \r\n        ',1),(87,4,32,'Для типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\r\nПример вызова:\r\n\r\n   eval (Add (Num 3) (Mult X X)) 10\r\n\r\nДолжно получиться 103\r\n        ',1),(88,5,32,'Для типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\r\n  diff (Mult X X)\r\n\r\nДолжно получиться\r\n\r\n   Add (Mult(Num 1) X) (Mult X (Num 1))\r\n\r\nЗамечания:\r\n- В описании типа надо обязательно в конце написать deriving Show. Иначе не удастся вывести результат. \r\n- Упрощать выражение не надо. Т.е. не требуется, например, пытаться вместо Add (Mult(Num 1) X) (Mult X (Num 1)) получить Mult (Num 2) X.\r\n        ',1),(89,1,30,'*Доп.задача до 28.11*\r\n\r\nОпишите функцию flatten, которая для данного дерева возвращает список из всех значений, записанных в вершинах дерева.\r\n\r\nПример вызова:\r\n\r\nflatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\nДолжно получиться\r\n\r\n   [1,2,3] \r\n\r\nЗамечание:\r\n- Желательно, чтобы значения шли в в таком порядке, как в примере (вершина, потом левое поддерево, потом правое поддерево).\r\n- Еще, если получится, было бы замечательно, если бы вы написали реализацию flatten, которая не использует операцию ++. Потому что ++, как мы знаем, работает медленно и flatten получится не очень эффективным. \r\nНо, если не будет идей, напишите реализацию с использованием ++ - это, мне кажется, совсем просто.\r\n        ',1),(90,5,29,'Пусть нас попросили написать функцию findSame, которая для данного списка возвращает элемент, который в нем встречается больше одного раза. Например, для [1,2,3,2,5] надо вернуть 2.\r\n\r\nМы, естественно, просим уточнить:\r\n- Что делать, если таких элементов несколько?\r\n- Что делать, если таких элементов вообще нет?\r\n\r\nА нам сказали:\r\n- Если из несколько, можно вернуть любой.\r\n- Если вообще нет таких элементов - ну, нам сказали, придумайте что-нибудь.. Подойдет любое решение, но надо, чтобы пользователь мог понять, нашлось что-то или нет.\r\n\r\nЗадача: придумать интерфейс для findSame и реализовать эту функцию.\r\n\r\nПримеры вызова:\r\n\r\nfindSame [1,2,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должно быть число 2 и еще м.б. какая-то дополнительная информация.\r\n\r\nfindSame [1,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должна быть какая-то информация о том, что мы ничего не нашли.\r\n\r\nЗамечания:\r\n- Самый первый вариант, который лично мне приходит в голову - это вернуть пару (число, логическое значение). Это, на самом деле, видимо вовсе не лучший вариант, но вполне нормальный. Если хотите, можете его реализовать, а можете придумать что-то другое.\r\n        ',1),(91,7,45,'Опишите функцию merge, у которой два параметра - списки, причем мы точно знаем, что эти значения в этих списках строго возрастают. Функция должна вернуть строго возрастающий список, содержащий значения из обеих списков. Если элемент встречается в обеих списках, в результате он должен встречаться только один раз. \r\n\r\nПример вызова:\r\n\r\nmerge [1,4,8] [2,4,5,10,20]\r\n\r\nДолжно получиться\r\n\r\n [1,2,4,5,8,10,20]\r\n\r\nЗамечания:\r\n- Списки могут быть и бесконечными\r\n- Эта задаче особо ни какой теме не относится - просто полезная функция, которую полезно уметь писать, и которая вполне часто используется на практике\r\n        \r\n        ',1),(93,1,27,'*Доп.задача, до 21.11*\r\n\r\nОпишите ham - бесконечную последовательность, состоящую из целых чисел вида 2^i*3^j (где i, j - целые неотрицательные числа), расположенных в порядке возрастания.\r\n\r\nПримеры вызова:\r\n\r\ntake 10 ham\r\n\r\nДолжно получиться \r\n\r\n  [1,2,3,4,6,8,9,12,16,18]\r\n\r\nЗамечания:\r\n- Желательно, чтобы функция более-мене быстро работала для больших чисел. Т.е. например, чтобы ham !! 10000 находилось не больше, чем за 30 сек.\r\n- Но, если быстрый способ не получится, подойдет любое решение.\r\n- Подсказка: быстрое решение можно довольно коротко и просто написать, если использовать завязывание в узел + решение одной из дополнительных задач прошлой недели. Какой - попробуйте сами угадать:)       \r\n        \r\n        ',1),(94,2,46,'*Доп.задача, до 18.11*\r\n\r\nОпишите для типа \"электрическая схема\" функцию show так, чтобы она наглядно изображала схему в виде резисторов, соединенных проводами, с помощью символов псевдографики (например, с помощью -, |, +).\r\n\r\nСправка: В строках Haskell можно использовать символ backslash n для перехода на следующую строку. Можно, при желании, использовать запись backslash x шестнадцатиричное число для того, чтобы задавать любые символы. \r\n\r\n(Пояснение: backslash - это такой символ, после него надо писать n или x и цифры  подряд. Просто система тестирования плохо относится к backslash в тексте :( )  \r\n\r\nЗа эту задачу будет записано 3 балла.\r\n        \r\n        ',3),(95,1,47,'*Доп.задача на C#, до 19.11*\r\n\r\nНаписать на C# функцию, которая для данного массива целых чисел проверяет, верно ли, что в нем все элементы разные. При этом функция должна использовать \"представление множеств с помощью функций\". Т.е., другими словами, попробуйте переписать пример с последнего занятия на C#.\r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Вы можете спросить, а зачем такую простую задачу решать так сложно? Да в общем-то просто для интереса:) Ну и для тренировки в работе с лямбда-выражениями и т.д. На практике это, наверное, особо не применимо, честно говоря.\r\n\r\nПодсказка: \r\nЯ бы начал решение этой задачи как-то так:\r\n\r\npublic static bool allDifferent(int[] a)\r\n{\r\n   return allDifferent1(a, 0, t => true);\r\n}\r\n\r\n// allDifferent1 - вспомогательная функция\r\n//  a - массив, который мы проверяем\r\n//  from - с какого места в массиве мы проверяем\r\n//  cond - функция проверки (которую мы делаем все сложнее и сложнее)\r\n\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n{\r\n  ...\r\n        \r\n        \r\n        \r\n        ',1),(96,2,47,'*Доп.задача на C#, до 19.11*\r\nСлияние IEnumerable\r\n\r\nОпределить генератор Merge с двумя параметрами типа IEnumerable<int>. Пусть мы точно знаем, что в обоих IEnumerable числа строго возрастают. Генератор должен объединять последовательности, т.е. результатом должна быть последовательность чисел из обеих входных последовательностей в порядке возрастания. Если какое-то число было в обеих входных последовательностях, то в выходной оно должно встречаться один раз.\r\n\r\nПример вызова:\r\n\r\nint [] a = { 1, 5, 8 };\r\nint [] b = { 3, 5, 9 };\r\nforeach (int i in Merge(a, b))\r\n{\r\n   Console.WriteLine(i);      // Должно напечататься 1, 3, 5, 8, 9\r\n}\r\n\r\nЗамечания:\r\n- Эта задача, в общем, то не имеет особого отношения к курсу. Просто, раз уж мы начали решать задачи про IEnumerable, то м.б. полезно решить не совсем тривиальную задачу на эту тему. Ну и написать полезную функцию).\r\n- В этой задаче, видимо, надо использовать возможности, которые мы не проходили (IEnumerable.GetEnumerator(), yield break). Т.е. это задача для тех, кому интересно во всем этом разобраться. Если не очень интересно, ну, просто пропустите ее и все..\r\n        \r\n        \r\n        ',1),(97,1,33,'*Доп.задача до 5.12)*\r\n\r\nПусть строчка содержит только символы  ‘[‘, ‘]‘,  ‘(‘ и ‘)‘. Опишите функцию checkBrackets, которая для данной строчки проверяет, что в ней находится правильная скобочная последовательность, и возвращает True или False. \r\n\r\nПримеры вызова:\r\n\r\ncheckBrackets \"[()[]]()\"\r\nРезультат должен быть равен True.\r\n\r\ncheckBrackets \"([)]\"\r\ncheckBrackets \"())[]\"\r\ncheckBrackets \"([]\"\r\nРезультат должен быть равен False.\r\n        \r\n        ',1),(98,2,48,'*Доп.задача до 25.11 (задача с контрольной)*\r\n\r\nПусть у нас есть двоичное дерево, элементы которого – символы ‘a’ и ‘b‘. Написать две функции:\r\n- функция toStr по дереву строит его представление в виде строки – все буквы в этом дереве, и, видимо, какие-то воспомогательные значки. \r\n- функция fromStr должна по этой строке восстанавливать исходное дерево.\r\n   Т.е. надо придумать, как двоичное дерево закодировать в виде строки, и написать функции, которые его кодируют и декодируют.\r\n\r\nПример вызова:\r\n\r\nfromStr(toStr (Node ‘a‘ (Node ‘b‘ Empty Empty) Empty))\r\nРезультат должен быть равен исходному дереву, т.е. Node ‘a‘ (Node ‘b‘ Empty Empty) Empty\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show, без этого тесты не пройдут.\r\n        \r\n        \r\n        ',1),(99,1,34,'*Доп.задача на C#, до 6.12*\r\n\r\nРеализовать задачу 32-5 на C# (Или, если хотите, на любом `oбычном` языке.)\r\n\r\nИмеется в виду, что надо придумать какое-то свое внутреннее представление для символьных выражений и для этого представления написать функцию Diff, которая строит производную данного выражения. \r\n\r\nЗамечания:\r\n - Вывод выражения писать не обязательно, разве что он вам понадобится для отладки.\r\n - Эта задача, честно говоря, не имеет особого отношения к функциональному программированию. Ну, просто, раз уж мы начали решать задачи про символьные вычисления, интересно сравнить, насколько это удобнее (или не удобнее) делать с помощью функциональных языков, чем с помощью обычных.\r\n  - Задача не очень простая, в том смысле, что там надо написать немного больше кода, чем обычно. (Зато за нее будет будет 3 балла). На 12 занятии мы немного обсудим, как ее можно было бы написать.\r\n        ',3),(100,1,50,'Описать функцию allDiffLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно получиться:\r\n[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечание:\r\n- Мы эту задачу решили на последнем занятии, только без приема \"представление множества с помощью функции\". Т.е. это, на самом деле, довольно простое упражнение: переписать существующее решение с этим приемом.\r\n        \r\n        \r\n        ',1),(101,2,33,'*Доп.задача до 5.12*\r\n\r\nДля типа Expr написать функцию simplify. Эта функция должна упрощать выражение, используя только два очень простых правила:\r\n\r\nвыражение * 0 = 0\r\nи\r\n0 * выражение = 0\r\n\r\nПримеры вызова:\r\n\r\nsimplify (Add (Mult X (Num 0)) X)\r\n\r\nДолжно получиться:\r\nAdd (Num 0) X\r\n\r\nsimplify (Mult X (Mult X (Num 0)))\r\n\r\nДолжно получиться:\r\nNum 0\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show\r\n        \r\n        \r\n        ',2),(102,3,32,'Опишите функцию findMajor, которая для данного списка определяет, есть ли в нем элемент, который больше суммы всех остальных, вместе взятых, и, если есть, возвращает его, как результат.\r\n\r\nДля того, чтобы сообщить, есть такой элемент или нет, используйте стандартный тип Maуbe, который мы проходили на последнем занятии.\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [2,3,15,2,2,2] \r\n\r\nДолжно получиться:\r\nJust 15\r\n\r\nfindMajor [2,3,5,2,4] \r\n\r\nДолжно получиться:\r\nNothing\r\n\r\nЗамечания:\r\n- Тут никаких хитростей, это простое упражнение на использование Maybe\r\n        ',1),(103,4,50,'На занятии мы разобрали функцию find, использующую failure continuation параметр, для того чтобы сообщить, что ничего не найдено. \r\n\r\nИспользуя только эту функцию, описать функцию findInLists, которая ищет элемент, удовлетворяющий данному условию в списке списков.\r\n\r\nПримеры вызова:\r\n\r\nfindInLists [[1,8,2], [2,7]] (>5) 0\r\n\r\nРезультат должен быть равен 8.\r\n  \r\nfindInLists [[1,8,2], [2,7]] (>10) 0\r\n\r\nРезультат должен быть равен 0.\r\n\r\nЗамечание: \r\nЖелательно в программе не использовать оператор if. Потому что, как мы говорили, при использовании failure continuation он, как правило, не нужен. Функция find, в каком-то смысле, сама работает, как оператор if. \r\nНо, если так не получиться, в принципе использовать if можно.\r\n        \r\n        \r\n        ',1),(104,2,29,'При помощи оператора >>= для списков описать функцию doubleEven, которая в данном списке все элементы, делящиеся на 2, повторяет два раза, а остальные оставляет, как есть.\r\n\r\nПример вызова:\r\n\r\ndoubleEven [1, 2, 6, 3]\r\n\r\nДолжно получиться:\r\n[1,2,2,6,6,3]\r\n        ',1),(105,4,29,'Описать функцию cartesian, которая для двух списков возвращает список из всех возможных пар элементов из первого и второго списка. Т.е. для списков [x1, x2, x3] и [y1, y2, y3] функция должна вернуть [(x1, y1), (x1, y2), (x1, y3), (x2, y1), (x2, y2), …] (всего 9 пар).\r\n\r\nПри этом желательно использовать только оператор >>= и лямбда выражения. Можно, но не очень нужно, определять вспомогательные функции. \r\n\r\nЕсли не получится сделать задачу с помощью >>=, можно написать любым способом, но только не используя list comprehension (с ним это уж слишком просто).\r\n\r\nПример вызова:\r\n\r\ncartesian [1,2] [3,4]\r\n\r\nДолжно получиться:\r\n[(1,3),(1,4),(2,3),(2,4)]\r\n        ',1),(106,1,51,'**Доп.задача до 2.12*\r\n\r\nОпишите функцию findMajor, которая проверяет, есть ли в списке элемент x, который встречается чаще всех других, вместе взятых, и возвращает Just x или Nothing, если такого элемента нет.\r\n\r\nДополнительное условие: Функция должна работать за линейное время от длины списка, и не должна использовать списки (кроме исходного списка, конечно) или любые другие структуры данных неограниченной длины. Другими словами, должна быть сложность по времени O(n) и сложность по памяти O(1).\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [1,2,3,2,2,2,1]\r\nРезультат должен быть равен Just 2\r\n\r\nfindMajor [1,2,3,2,2,1]\r\nРезультат должен быть равен Nothing\r\n\r\nЗамечания:\r\n- Это просто более-менее известная задачка на сообразительность, с функциональным программированием никак, в общем то, не связанная.\r\n- Я лично знаю решение, которое требует два прохода по списку, и только две вспомогательных переменных\r\n- Интересно, что, если бы задача была найти самое часто встречающееся число, то такое эффективное решение, насколько я понимаю, не существует. \r\nНо раз речь идет не о просто самом частом, а об _очень_ часто встречающемся числе, то все получается гораздо эффективнее.\r\n        \r\n        \r\n        \r\n        ',1),(107,2,51,'**Доп.задача до 2.12*\r\n\r\nОпишите тип LogExpr, аналогичный Expr, но для логических выражений. В нем должны быть конструкторы And, Or, Not для логических операций, конструкторы T и F для логических констант и переменная X.\r\n\r\nОпределите для этого типа операцию ==, которая проверяет, эквивалентны ли эти выражения.\r\n\r\nПримеры вызова:\r\n\r\nOr X (Not X) == T\r\nРезультат должен быть равен True\r\n\r\nOr X (And X (Not X)) == T\r\nРезультат должен быть равен False\r\n        \r\n        ',1),(108,3,51,'**Доп.задача до 2.12*\r\n\r\nПусть я хочу найти способы расставить ферзей на шахматной доске, чтобы они друг друга не били.\r\n\r\nДля представления позиции на шахматной доске я использую список пар чисел, каждое число >= 1. Первое число обозначает вертикаль, а второе - горизонталь.\r\n\r\nЕще для единообразия давайте считать, что первый ферзь в списке всегда стоит на первой вертикали, второй ферзь - на второй вертикали и т.д. (Т.е., вообще-то хранить вертикали в списке не очень то надо, но для наглядности мы их храним).\r\n\r\nИ вот задача:\r\n\r\nОписать функцию queens с двумя параметрами n и k, которая возвращает список из способов расставить k ферзей на доске с n горизонталями и k вертикалями, чтобы они не били друг друга.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\nПример вызова:\r\nqueens 3 2\r\n\r\nДолжно получиться:\r\n[[(1,1),(2,3)],[(1,3),(2,1)]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- Мне кажется задача очень похожа на задачу 27-1. Просто в 27-1 функция проверки попроще, а тут посложнее. \r\n- Если не очень понятно о чем речь, но хочется разобраться - пишите, пожалуйста, я подскажу.        \r\n        \r\n        \r\n        \r\n        ',1),(109,1,52,'*Доп.задача на C#, до 3.12*\r\n\r\nОписать функцию AllDiffLists с двумя параметрами n и k, которая печатает все последовательности длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: \r\n- В этой задаче нельзя использовать массивы и вообще никакие способы представления данных, кроме целых чисел и лямбда-выражений.\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно быть напечатано:\r\n 1 2\r\n 1 3\r\n 2 1\r\n\r\n... и т.д., всего 6 строчек(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n\r\n- Я бы предложил тут использовать прием \"представление множества с помощью функции\".\r\n\r\n- Но этого мало, потому что нам еще надо как-то хранить числа, которые мы уже отобрали, чтобы потом из напечатать. \r\n\r\nТут я бы предложил использовать еще одну функцию, которая при рекурсивных вызовах становится сложнее и сложнее. Но эта функция будет накапливать не проверки, а _печать_ для отобранных чисел.\r\n\r\n- Техническое замечание: Функция без параметров, которая ничего не возвращает, описывается так:\r\n\r\nAction f\r\n\r\nИ вот примеры лямбда выражений, у которых нет параметров, и которые ничего не возвращают:\r\n\r\n() => { Console.WriteLine(); }\r\n() => { f(); g(); } \r\n        \r\n        ',1),(110,2,52,'*Доп. задача на C#, до 3.12*\r\n\r\na. Написать на C# функцию Find, которая в данном массиве целых чисел ищет элемент, удовлетворяющий данному логическому условию. При этом функция должна использовать failure continuation, чтобы обрабатывать случай, когда ничего не найден.\r\n\r\nб. Привести пример, как с помощью Find можно решить пример с занятий: \r\n\"Найти в массиве число <10, а если его нет, найти число <20, а если и его нет, вернуть 20\".\r\n\r\nТехнические замечания про failure continuation на C# см. тут: \r\nhttp://msimuni.wikidot.com/fp-failure-continuation \r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Можете, если хотите, попробовать решить эту задачу на C++ или Java.\r\n- Эта задача, на самом деле, очень простая, надо только понять, о чем вообще речь. \r\n        \r\n        ',1),(111,3,35,'а. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:\r\n\r\nAdd (Var \"x\") (Mult (Var \"y\") (Num 3))\r\n\r\n(И это должно соответствовать x+y*3 в обычном языке.) \r\n\r\nб. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).\r\n\r\nПример вызова:\r\n\r\neval (Add (Var \"x\") (Mult (Var \"y\") (Num 3))) [(\"x\", 5), (\"y\", 8)]\r\n\r\nРезультат должен быть равен 29\r\n\r\nЗамечание:\r\n- Не очень понятно что делать, если для какой-то переменной значение не задано. Вы можете задать любое поведение в этом случае, или вообще не рассматривать такой случай. В тестах такого не будет.\r\n        ',1),(112,2,38,'а. К типу Expr добавить еще возможность описывать что-то похожее на let выражения. Вот пример такого выражения\r\n\r\nAdd (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (N 1)\r\n\r\n(И это должно соответствовать (let x = 10 in x*y) + 1 в обычном языке.) \r\n\r\nб. Дописать функцию eval из задачи 30-1, чтобы она вычисляла let выражения. \r\n\r\nПример вызова:\r\n\r\neval Add (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (N 1) [(\"y\", 2)]\r\n\r\nРезультат должен быть равен 21\r\n        ',1),(113,3,53,'Опишите функцию sum_cps которая ищет сумму элементов данного списка, используя continuation-passing style.\r\n\r\nПримеры вызова:\r\n\r\nsum_cps [1,2,3] id \r\nРезультат дб равен 6\r\n\r\nsum_cps [1,2,3] (^2)\r\nРезультат дб равен (1+2+3)^2=36\r\n\r\nДополнительные условия:\r\n- Нельзя определять никакие новые функции, кроме sum_cps.\r\n- Нельзя использовать никакие стандартные функции для работы со списками.\r\n- Определение sum_cps должно быть tail recursive\r\n(Эти все условия следуют из того что функция должна  использовать continuation passing style, я их выписал просто для тех, кто мб не был на занятии).  \r\n        \r\n        ',1),(114,4,53,'*Простое упражнение на использование >>= и do нотации*\r\n\r\nОпишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:\r\n\r\n[1, \r\n 1, 2, \r\n 1, 2, 3,\r\n  ...\r\n 1, 2, 3, ..., n]\r\n\r\nДополнительные условия:\r\n- triangle1 надо написать с помощью оператора >>= и функции return\r\n- triangle2 надо написать с помощью do нотации\r\n\r\nПримеры вызова:\r\n\r\ntriangle1 3\r\ntriangle2 3\r\n\r\nВ обоих случаях должно получиться:\r\n[1,1,2,1,2,3] \r\n        ',1),(115,2,35,'Пусть функция find описана так:\r\n\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n(Т.е. для того, чтобы сообщить о том, что ничего не найдено, мы используем пустой список).\r\n\r\nС помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает []\r\n- если все числа найдены, возвращает список из одного элемента - их суммы.\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен [30], потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен [], потому что один из трех поисков ничего не находит.\r\n\r\nЗамечания: \r\n- Это просто упражнение, на то, как удобнее работать с несколькими вызовами функции, которая может завершиться неудачно. (К сожалению, забыл обсудить ее на занятии).\r\n- Задачу можно решить очень коротко, в одну строку.  \r\n- Если коротко не получиться, вы можете присылать любое решение.\r\n        ',1),(116,5,35,'Написать функцию toInt, которая по данному числу Черча возвращает обычное число.\r\n\r\nПример вызова:\r\n\r\ntoInt (\\ f x -> f (f (f x)))\r\n\r\nРезультат должен быть равен 3.\r\n\r\nЗамечание: \r\n- Задача очень простая, пишется в одну строку.\r\n        ',1),(117,6,35,'Написать функцию inc, которая прибавляет 1 к числу Черча.\r\n\r\nНапример, вызов inc (\\ f x -> f (f (f x))) должен вернуть \\ f x -> f (f (f (f x))). \r\n\r\nПример вызова:\r\ntoInt (inc (\\ f x -> f (f (f x))))\r\nРезультат д.б. равен 4.\r\n\r\nЗамечание: \r\n- Это тоже очень простая задача.\r\n        ',1),(158,1,36,'Функция putChar имеет тип Char -> IO() и выводит на консоль данный символ. Пример вызова:\r\n\r\ndo\r\n  putChar `a`\r\n  putChar `b`\r\n  putChar `\n`\r\n  putChar `c`\r\n\r\nВыводит букву `a`, потом букву `b`, потом переходит на следующую строку, потом выводит букву `c`. \r\n\r\nОписать функцию, которая c использованием putChar для данного числа n печатает квадрат со стороной n, из символов `*`. Например, для n = 4 надо напечатать:\r\n\r\n****\r\n****\r\n****\r\n****\r\n        ',1),(118,8,53,'Пусть мы описали функцию find вот так:\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).\r\n\r\nТ.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. Мы бы хотели написать оператор, немного похожий на оператор композиции (.), Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, полученного в результате первого вызова.\r\n\r\nЗадача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:\r\n\r\nf = find (>3) >>> find (>3)  \r\n-- f - это функция, которая ищет в списке второй элемент, больший 3.\r\nf  [1, 3, 5, 2, 20, 25, 2]\r\n-- Должно получиться (20, [25, 2])\r\n        \r\n        ',1),(119,1,54,'*Доп.задача, до 9.12*\r\n\r\nРеализовать функцию dec, которая вычитает 1 из числа Черча.\r\n\r\nПример вызова: \r\ndec (f x -> f (f (f x))) \r\nдолжен вернуть f x -> f (f x). \r\n\r\nДля проверки имеет смысл вызвать так:\r\ntoInt (dec (f x -> f (f (f x)))) \r\nи ответ д.б. равен 2.\r\n\r\nЗамечания:\r\n- Как обычно, в условии не хватает расставленных в нужном месте символов обратной косой черты.\r\n- Имеется в виду, что в этой задаче нельзя использовать встроенные функции и вообще нельзя использовать настоящие целые числа (потому что глобальная задача - показать, что встроенные целые числа теоретически не очень нужны, их можно моделировать). Например, нельзя перевести число Черча в обычное, вычесть 1 и перевести обратно.\r\n- *Дополнение к первоначальному условию*. Кроме этого, давайте считать, что никакие структуры данных (списки, пары) использовать нельзя. Мы же ставим себя на место Черча и Клини у которыъ были только лямбда выражения, и больше ничего.\r\n- Эта задача не очень простая. Сам Черч не смог ее решить, ему помог его студент (С.Клини). Так что если у вас не получится, не расстраивайтесь:)\r\n- Вы, безусловно, можете найти решение этой задачи в сети. Это не запрещается, но имейте в виду, что тех, кто сдал эту задачу я могу на зачете попросить ее воспроизвести или обьяснить.\r\n        \r\n        \r\n        \r\n        ',1),(120,2,54,'*Доп.задача, до 9.12*\r\n\r\nПусть нас интересуют формулы исчисления высказываний, которые можно составить из переменных и символа следования ->. Вот примеры таких формул:\r\n\r\nA -> A\r\n(A -> B) -> ((B -> C) -> (A -> C))\r\n(A -> B) -> (B -> A)\r\n((A -> B) -> C) -> D\r\n\r\nа. Описать тип данных (data) позволяющий описывать такие формулы (примерно так же, как с помощью Expr мы описывали арифметические формулы).\r\n\r\nб. Написать функцию isTautology, которая по данной формуле определяет, является ли она тавтологией, т.е. верно ли, что она истина при любых значениях входящих в нее переменных, и возвращает True или False. Например, их приведенных выше формул первая и вторая - это тавтологии, а остальные - нет.\r\n\r\nЗамечания:\r\n- Тестов к этой задаче в системе нет, потому что я не знаю, какое представление данных вы выберете. \r\n        \r\n        \r\n        ',1),(121,1,55,'*Доп. задача на C# - до 10.12*\r\n\r\nВ этот раз задача наверное не очень полезная и не очень осмысленная:( Ну, рассматривайте ее, пожалуйста, просто как техническое упражнение (и как возможность заработать баллы:)\r\n\r\nЗадание простое: написать функцию fact_cps, которая вычисляет факториал, с использованием рекурсии и continuation apssing style. Ну и привести пример вызова - ввести целое число и, с помощью вызова fact_cps напечатать результат.\r\n\r\nТ.е., фактически, надо просто переписать пример с занятий на C# (или, если хотите, на любой другой `обычный` язык программирования).\r\n        \r\n        ',1),(122,1,56,'а. Добавить в тип Expr конструкции, позволяющие определять свои функции и вызывать их. Для простоты мы рассматриваем только функции с одним параметром, параметр и результат функции - целые числа.\r\nб. Добавить в функцию eval реализацию для этих конструкций.\r\n\r\nПример вызова:\r\n\r\neval (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"X\")) (Add (Num 1) (Call \"F\" (Num 5)))) [] []\r\n\r\nДолжно получиться 26, потому что мы тут записали на нашем языке выражение:\r\nlet f x = x*x in 1 + f 5\r\n\r\nЗамечания:\r\n- Задача не очень простая, но, в общем то, тут надо придумать представление данных (как хранить функции) и дальше все, в общем, не сложно.\r\n- Я бы предложил завести отдельный параметр - список для хранения функций. Поэтому в примере вызова у меня в конце два пустых списка - для переменных и для функций. Но, если хотите, можете немного изменить список для хранения значений переменных, чтобы в нем можно было хранить и функции. Тесты тогда не пройдут, ну и ладно, я так проверю. \r\n- Можно считать, что не надо поддерживать замыкания (т.е. в функциях не используются нелокальные переменные).\r\n        \r\n        \r\n        ',1),(123,1,38,'а. Описать функцию find с двумя параметрами - условие (логическая функция) и список. Функция должна искать первый элемент в списка, удовлетворяющий условию, и возвращать Just элемент или Nothing, если ничего не найдено. \r\n\r\nПримеры вызова find:\r\n\r\nfind (>6) [1, 2, 8, 3]\r\nРезультат должен быть Just 8\r\n\r\nfind (>6) [1, 2, 5, 3]\r\nРезультат должен быть Nothing\r\n\r\nб. С помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает Nothing\r\n- если все числа найдены, возвращает Just для их суммы.\r\n\r\nДополнительное условие:\r\nОбязательно надо использовать конструкцию do (как это можно сделать, мы обсуждали на последнем занятии).\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен Just 30, потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен Nothing, потому что один из трех поисков ничего не находит.\r\n\r\nЗамечание: \r\n- Это очень, очень простое упражнение, абсолютно все решение есть в конспекте.. Просто балл в подарок :)\r\n        ',1),(124,4,35,'Описать функцию downUp, которая для данного параметра n печатает числа:\r\nn n-1 n-2 … 3 2 1 2 3 … n-2 n-1 n\r\nпо одному в столбик.\r\n\r\nДополнительное условие:\r\n- Надо обязательно использовать функцию print и do нотацию\r\n\r\nПример вызова:\r\n\r\ndownUp 3\r\n\r\nДолжно напечататься:\r\n3\r\n2\r\n1\r\n2\r\n3\r\n        ',1),(125,3,38,'Я сказал на занятии примерно следующее:\r\nВыражение\r\n(\\x -> E) a\r\nвсегда можно без изменения смысла выражения заменить на Е в котором все вхождения x заменены на a\r\n\r\nНапример,\r\n(x->x*x)5\r\nэто то же, что\r\n5*5\r\n\r\nНа самом деле я немного ошибся. Для более сложных выражений это правило не всегда верно, его надо как-то уточнить.\r\n\r\nа. Приведите пример, когда это не так\r\nб. Напишите, как сформулировать правило бета редукции более корректно.\r\n\r\nЗамечания:\r\n- Это не задача на программирование. Ответом д.б. текст, что-то вроде: \"Вот пример, когда ваше правило дает неправильные результаты: … какой-то пример … . Его можно исправить так: … правильная формулировка … .\r\n- На самом деле в определении две ошибки, вы можете указать любую.\r\n- Одна из ошибок совсем очевидная (да и вторая, в общем-то, то же), и то, что требуется указать, как исправление, может быть кажется вам само собой разумеющимся. Т.е., если вы придумали ответ на эту задачу, но он кажется вам слишком простым - выкладывайте его в систему, очень может быть это как раз то, что имеется в виду.\r\n        ',1),(126,5,56,'Черч и Россер доказали теорему: бета-редукция для лямбда исчисления обладает свойством конфлюентности.\r\n\r\nИспользуя эту теорему, докажите, что если для лямбда выражения существует нормальная форма, то она единственна.\r\n \r\nЗамечания:\r\n- Тут, понятно, надо написать текст, а именно доказательство этого утверждение, более-менее строгое.\r\n- Это, на самом деле очень простое следствие, практически очевидное. М.б. в этом некоторая трудность, бывает не так просто доказать, что одно следует из другого, если это очевидно. Но вы попробуйте:)\r\n        \r\n        ',1),(127,6,56,'У функции >>>, мы которую мы описали на последнем занятии, есть принципиальный недостаток - она никак не использует результат, найденный первой функцией - только хвост. \r\n\r\nВ результате, такие задачи, например с ее помощью записать не удастся:\r\n- Найти в списке элемент x, больший 3, а потом первый элемент, больший x.\r\nили\r\n- Найти в списке элемент x, больший 3, а потом первый элемент y, меньший x, а потом первый элемент, не равный сумме x и у\r\n\r\nКакую бы написать функцию, чтобы решить эту проблему?\r\n\r\nОпишите какой-то оператор, который как-то дозволяет это делать.\r\n\r\nПримера вызова не будет, потому что оператор вы должны придумать сами, но по идее что-то такое\r\n\r\nf = find (>3) ... какие-то заклинания ... find (>x) \r\n\r\nИ потом:\r\nf [1,6,5,7,1,2]\r\nдолжно вернуться (7, [1,2])\r\n\r\nЗамечания:\r\n- На занятии мы еще говорили про функцию, которая возвращает сумму двух найденных чисел, но про это давайте мы решим задачу в следующий раз.\r\n- Ответ очень короткий (почти не длиннее чем решение для >>>), надо только понять, что бы тут хотелось иметь.\r\n- Подсказка: я бы назвал нужную нам функцию >>>=. (Я бы еще лучше назвал ее >>=, но тут есть некоторые технические сложности, с которыми неохота разбираться..)\r\n- Если вам не придумать решение, напоминающее >>=, вы можете предложить любое другое. Все что угодно, только не списывайте:) Все, что будет немного похоже на решение, я зачту:)\r\n- Если совсем непонятно о чем речь, вы можете написать мне, и я немного подскажу.\r\n        \r\n        \r\n        ',1),(134,1,10,'*Доп.задача до 10.10, очень простая*\r\n\r\nНаписать функцию minTree, которая для данного дерева поиска возвращает минимальное содержащееся в нем число.\r\n\r\nПример вызова:\r\nminTree(Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty))\r\nРезультат должен быть равен 2.\r\n\r\nЗамечание:\r\n- Решение должно обязательно использовать то, что наше дерево - это дерево поиска.',1),(135,2,10,'*Доп.задача до 10.10, посложнее*\r\n\r\nНаписать функцию minPosTree, которая для данного дерева поиска возвращает минимальное содержащееся в нем _положительное_ число.\r\n\r\nПример вызова:\r\nminPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))\r\nРезультат должен быть равен 5.\r\n\r\nЗамечание:\r\n- Решение должно обязательно использовать то, что наше дерево - это дерево поиска. Тут получается не так просто, как с нахождением просто минимального числа, но тоже есть очень эффективный алгоритм.\r\n        ',1),(136,1,11,'*Дополнительная задача на C# или на любом обычном языке, до 11.10 включительно*\r\n\r\nС помощью функции Any решить такую задачу: для данного массива положительных целых чисел проверить, есть ли в нем число 7 и напечатать Да или Нет.',1),(137,1,13,'\"Шахматная доска\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле двумерные массивы. Описать функцию chessboard n m, которая возвращает список списков, размером m*n и каждый из внутренних списков тоже имеет размер m*n. Cписки состоят из 0 и 1. \r\nЭтот список списков должен изображать шахматную доску из n на n клеток, а каждая клетка имеет размер m на m и состоит из всех 0 или всех 1. \"Левая верхняя\" клетка состоит из 0.\r\n\r\nПример вызова:\r\nchessboard 2 2\r\nДолжно получиться:\r\n[[0,0,1,1],\r\n [0,0,1,1],\r\n [1,1,0,0],\r\n [1,1,0,0]]\r\n - доска 2 на 2 из клеток размера 2\r\n\r\nchessboard 3 1\r\nДолжно получиться:\r\n[[0,1,0],\r\n [1,0,1],\r\n [0,1,0]]\r\n - доска 3 на 3 из клеток размера 1\r\n\r\nЗамечание:\r\n- Если хотите, вы можете прислать решение для m == 1 (т.е. просто списки длины n, и в них 0 и 1 идут в шахматном порядке). А я тогда подскажу, как это обобщить для любых клеток.\r\n- Если есть вопросы по условию - пишите!\r\n        ',1),(138,2,15,'Используя _только_ функцию foldr и лямбда выражения опишите функцию mymap, которая делает точно то же, что и стандартная функция map.\r\nПример вызова:\r\nmymap (*3) [1, 2, 3]\r\nРезультат д.б. равен [3, 6, 9].\r\n\r\nДополнительные условия:\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.',1),(139,4,15,'\"Транспонирование матрицы\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию transpose xss, которая для данной квадратной матрицы возвращает транспонированную матрицу.\r\n\r\nПример вызова:\r\ntranspose [[1,2,3],[4,5,6],[7,8,9]]\r\nРезультат должен быть равен [[1,4,7],[2,5,8],[3,6,9]].\r\n\r\nЗамечания:\r\n- Можно считать, что мы точно знаем, что матрица квадратная. Если список не соответствует квадратной матрице (содержит строки разной длины и т.д.), то функция может вести себя как угодно.\r\n- Задача не такая простая (но и не очень сложная - средняя..). Т.е. если не получится - не расстраивайтесь:)',1),(140,1,16,'*Доп.задача, до 24.10*\r\nТреугольник\r\n\r\nПусть мы представляем точки на плоскости с помощью пар целых чисел. Описать функцию triangle n, которая возвращает список из всех точек с целыми координатами, которые принадлежат треугольнику с вершинами (0, 0), (0, n) и (n, 0).\r\n\r\nПример вызова:\r\n   triangle 3\r\nРезультатом должно быть что-то вроде [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(2,0),(2,1),(3,0)] (но пары могут идти и в другом порядке).\r\n\r\nЗамечания:\r\n- Чтобы задача была немного посложнее, давайте считать, что n может быть и отрицательным.\r\n        ',1),(141,1,17,'*Задача на \"обычном\" языке (дополнительная, до 24.10 включительно*\r\n\r\nАналогом foldr в C# является метод Aggregate, мы про это говорили на занятии. Задача такая: \r\n\r\nИспользуя Aggregate и лямбда выражения, cосчитать для данного массива строк (или, если хотите, для списка строк), сколько в нем строк, начинающихся на букву a.\r\n\r\nТ.е. должно быть написано что-то вроде:\r\n\r\nstring [] arr = new [] {\"a\", \"beautiful\", \"apple\", \"and\", \"orange\"};\r\nvar n = arr.Aggregate(...какие-то параметры...);\r\nConsole.WriteLine(n);\r\n\r\nЗамечания:\r\n- Если для кого-то задача кажется слишком сложной, можно решить задачу попроще: \"Дан массив чисел. Используя Aggregate, найти произведение синусов всех чисел в этом массиве.\"\r\n- Как обычно в задачах на C#, текст программы должен быть приведен полностью, чтобы его можно было скомпилировать.\r\n        ',1),(147,2,23,'*Доп.задача до 8.11, на Haskell, с контрольной*\r\n\r\nОпределить функцию corner n, которая для данного числа n создает список длиной n, элементы которого списки чисел длиной n. И в нем содержатся числа от 1 до n расположенные уголком (см. пример ниже) \r\n\r\nПример вызова:\r\n corner 4\r\nОтвет д.б. равен:\r\n [[1,2,3,4],\r\n  [2,2,3,4],\r\n  [3,3,3,4]\r\n  [4,4,4,4]]\r\n        ',1),(142,1,19,'*Доп. задача, до 31.10, очень простая*\r\n\r\nНаписать функцию myTake, c тем же интерфейсом что и у стандартной функции take. Т.е. myTake n xs должна возвращать список их первых n элементов списка xs. Если в списке меньше, чем n элементов, то myTake должна возвращать весь список.\r\n\r\nПример вызова:\r\n  myTake 4 [2,3,5,7,11,13,15]\r\nРезультат должен быть равен [2,3,5,7]\r\n\r\nЗамечания:\r\n- В этой задаче, конечно, нельзя использовать стандартную функцию take. Но в остальном можно использовать что угодно.\r\n- Это не задача на какую-то тему, которую мы проходили в этот раз. Просто простое упражнение.        \r\n        ',1),(143,2,21,'Описать функцию alternatingSum, которая для данного списка xs = [x1,x2,x3,x4,x5,...] возвращает значение суммы  x1-x2+x3-x4+x5-... . Т.е. слагаемые должны по очереди браться с плючсли м с минусом.\r\n\r\nДополнительное условие:\r\n- Эту задачу надо обязательно решить с помощью бесконечного списка plusMinus из последнего занятия. Т.е. вам надо скопировать в программу определение plusMinus из слайдов, и как-то его использовать. (Если совсем непонятно, как использовать, пишите, я подскажу. Но вообще это очень просто).\r\n\r\nПример вызова:\r\n\r\n  alternatingSum [2,5,3,7,8,2,3]\r\nРезультат лолжен быть равен 2, потому что 2-5+3-7+8-2+3 = 2.\r\n        \r\n        ',1),(144,3,21,'Описать бесконечный список facts, состоящий из факториалов целых положительных чисел [1!, 2!, 3!, 4!, ...]. \r\n\r\nПро этом в этой задаче довольно строгие дополнительные условия - см ниже. Особенно обратите, пожалуйста, внимание, на первое условие - тут надо обязательно применить именно этот прием. \r\n\r\nПример вызова:\r\ntake 5 facts\r\nРезультат должен быть равен [1, 2, 6, 24, 120].\r\n\r\nДополнительные условия:\r\n- В этой задаче _обязательно_ надо применить прием \"завязывание в узел\" (tying the knot).\r\n- Нельзя определять свои функции (кроме facts, конечно)\r\n- Можно использовать любые стандартные функции.',1),(145,4,21,'Описать бесконечный список  pyramid = [[1],[2,1],[3,2,1],[4,3,2,1],...].\r\n\r\nТо-есть:\r\n- элементы этого списка - списки длины 1,2,3 и т.д.\r\n- внутренний список длины n содержит числа от n до 1 в порядке убывания.\r\n\r\nПример вызова:\r\ntake 3 pyramid\r\nРезультат должен быть равен [[1],[2,1],[3,2,1]].\r\n\r\nДополнительные условия:\r\n- В этой задаче _обязательно_ надо применить прием \"завязывание в узел\" (tying the knot).',1),(146,1,22,'*Дополнительная задача, до 7.11*\r\n\r\nОпишите функцию digits n, которая возвращает бесконечный список из цифр дроби 1/n. \r\n\r\nПример вызова:\r\n  take 25 (digits 7)\r\nДолжно получится [1,4,2,8,5,7,1,4,2,8,5,7,1,4,2, 8,5,7,1,4,2,8,5,7,1]\r\n\r\nЗамечание:\r\n- Если нет идей, как это можно сделать - пишите, я подскажу. ',1),(148,3,23,'*Доп.задача до 8.11, на Haskell, с контрольной*\r\n\r\nОписать функцию anyMore c двумя параматрами xs и ys - списками целых чисел. Функция должна проверить, верно ли, что в первом списке каждый элемент больше хотя бы одного элемента из второго списка, и вернуть True или False.\r\n\r\nПримеры вызова:\r\n anyMore [3,2,8] [7,1,2,9]\r\nОтвет д.б. равен True.\r\n anyMore [5,2,8] [4,9]\r\nОтвет д.б. равен False (для 2 условие не выполняется).\r\n\r\nДополнительное условие:\r\nВ этой задаче надо придумать решение, которое просматривает каждый список не больше одного раза. (Это, на самом деле, очень просто, надо только понять, когда, собственно, выполняется условие, описанное в этой задаче. Если нет идей - пишите, я подскажу).\r\n        \r\n        ',1),(150,2,25,'*Доп.задача до 14.11*\r\n\r\nОпишите функцию merge, у которой два параметра - списки, причем мы точно знаем, что эти значения в этих списках строго возрастают. Функция должна вернуть строго возрастающий список, содержащий значения из обеих списков. Если элемент встречается в обеих списках, в результате он должен встречаться только один раз. \r\n\r\nПример вызова:\r\n\r\nmerge [1,4,8] [2,4,5,10,20]\r\n\r\nДолжно получиться\r\n\r\n[1,2,4,5,8,10,20]\r\n\r\nЗамечания:\r\n- Списки могут быть и бесконечными\r\n- Эта задаче особо ни какой теме не относится - просто полезная функция, которую полезно уметь писать, и которая вполне часто используется на практике\r\n        ',1),(149,5,24,'superMap\r\n\r\nОписать функцию superMap, похожую на map, но только она умеет заменять один элемент на несколько.\r\n\r\nПример вызова:\r\n\r\nsuperMap (\\x -> [x*x, 100*x]) [1,2,3]\r\n\r\nОтвет должен быть равен [1, 100, 4, 200, 9, 300].\r\n\r\nЗамечания:\r\n- Из примера, мне кажется, ясно, что делает эта функция. Но если не очень ясно - напишите, я поясню.\r\n- На самом деле, в Хаскеле есть стандартная функция, которая делает именно это. И даже две:) Вы можете какую-нибудь их них найти и вызвать. Но м.б. и не имеет смысла это делать, эту функцию и так очень просто написать.\r\n        ',1),(151,1,26,'*Доп. задача на C#, до 15.11 (очень простая, мне кажется)*\r\n\r\nДля определения IEnumerable на C# тоже можно использовать прием tying the knot. Например, так можно определить геометрическую прогрессию:\r\n\r\npublic static IEnumerable<int> Geom()\r\n{\r\nyield return 1;\r\nforeach (int i in geom())\r\n{\r\nyield return 3*i;\r\n}\r\n}\r\n\r\nПолучится, видимо, не так эффективно, как на Хаскеле (из-за того, что нет запоминания уже вычисленных значений), но вполне работоспособно.\r\n\r\nЗадача (очень простая, скорее упражнение):\r\nС помощью приема tying the knot описать блок итератора Ones(), который по очереди возвращает числа 1, 11, 111, 1111, 11111, и т.д. \r\n\r\nЗамечание:\r\n- При обращении к Ones() довольно скоро, конечно же, наступит переполнение, и вы результаты будут странные.. Ну и ладно, неважно, будем считать, что в этой задаче мы не будем получать очень много элементов последовательности.',1),(152,2,27,'*Доп.задача, до 21.11*\r\n\r\nПусть наш начальник дал нам несколько похожих задач про бесконечные списки.\r\n\r\n- Сначала он попросил нас описать бесконечный список [1, sin 1, sin (sin 1), sin( sin (sin 1)), ...]\r\n- Потом он попросил описать список [2, 2^2, (2^2)^2,  ((2^2)^2)^2, ...]\r\n- Потом он попросил описать список [1, 11, 111, 1111, 11111, ...]\r\n\r\nИ тут мы подумали, что может быть уже пришла пора придумать функцию высшего порядка, такую, чтобы с ее помощью можно было описать все эти списки.\r\n\r\nТ.е. задача:\r\n- описать функцию высшего порядка, с помощью которой можно описать все эти списки.\r\n- привести 2-3 примера вызова этой фунцкии (например, перечисленные выше списки. Но, если хотите, можете привети и другие примеры).\r\n\r\nЗамечание:\r\n- Тестов в этой задаче не будет, я ее проверю вручную.\r\n        ',1),(153,3,29,'*Снова lst367*\r\n\r\nОписать бесконечный список lst367, содержащий все целые положительные числа, состоящие только из цифр 3,6 и 7. (Числа должны идти в порядке возрастания).\r\n\r\nПример вызова:\r\n\r\ntake 15 lst367\r\n\r\nДолжно получиться:\r\n[3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]\r\n\r\nДополнительное условие: \r\n- Решите, пожалуйста, эту задачу с использованием завязывания в узел и оператора >>=. (Это очень просто, практически решение уже есть в слайдах, надо просто его записать).\r\n        ',1),(154,2,30,'*Доп.задача до 28.11*\r\n\r\nПусть строчка содержит только символы ‘(‘ и ‘)‘. Опишите функцию checkBrackets, которая для данной строчки проверяет, что в ней находится правильная скобочная последовательность, и возвращает True или False. \r\n\r\nПримеры вызова:\r\n\r\ncheckBrackets \"(()())()\"\r\nРезультат должен быть равен True.\r\n\r\ncheckBrackets \"())()\"\r\ncheckBrackets \"(()\"\r\ncheckBrackets \"(()))(()\"\r\nРезультат должен быть равен False.',1),(155,1,31,'*И снова дополнительная задача про цифры, теперь до 29.11, немного измененная*\r\n\r\nОпишите функцию digits m n, которая возвращает бесконечный список из цифр дроби m/n. Будем считать, что мы точно знаем, что m < n. \r\n\r\nПример вызова:\r\ntake 25 (digits 1 7)\r\nДолжно получится [1,4,2,8,5,7,1,4,2,8,5,7,1,4,2, 8,5,7,1,4,2,8,5,7,1]\r\n\r\nЗамечания:\r\n- _Нельзя_ делить n/m и получать. Вещественное число. Ведь мы так получим _приближенное_ вещественное число (вещественные числа всегда приближенные). И значит, мы не сможем получить больше 16 правильных цифр (у double точность - 15-16 цифр).\r\n- Значит, надо как-то работать с целыми цифрами.\r\n- Подсказка: Пусть там надо найти первую цифру дроби 1/7. Ясно, что это то же, что целая часть дроби 10/7. Т.е. 10/7 - это 1 3/7. Это, на самом деле, означает, что первая цифра равна 1, а остальные цифры можно получить, из дроби 3/7. C ней мы поступаем так же. Рассматриваем дробь 30/7 = 4 2/7. Это означает, что вторая цифра равна 4, а остальные мы можем получить из дроби 2/7.\r\n- Попробуйте сделать эту задачу, пожалуйста! Мне кажется, она важная (и не очень сложная). ',1),(156,1,32,'Опишите класс Shape и типы Circle и Rect, как мы это делали на занятии. \r\n\r\nа. Добавьте в оба типа еще два вещественных поля -координаты центра фигуры.\r\n\r\nб. Добавьте в Shape функцию contains c двумя вещественными параметрами, которая проверяет, принадлежит ли точка с данными координатами фигуре, и возвращает True или False. Напишите определение этой функции для Circle и Rect.\r\n\r\nПримеры вызова:\r\n\r\n  contains (Circle 10 0 0) 6 5\r\n\r\nОтвет должен быть True, потому что точка  с координатами 6 5 принадлежит кругу радиуса 10 с центром 1 2.\r\n\r\n  contains (Rect 6 8 0 0) 5 5\r\n\r\nОтвет должен быть равен False, потому что точка 5 5 не принадлежит прямоугольнику со сторонами 6 и 8 и центром 0 0.        \r\n\r\nЗамечание:\r\n- Будем считать, что у прямоугольников стороны всегда параллельны осям координат.        ',1),(157,2,32,'*Простое упражнение на использование >>= и do нотации*\r\n\r\nОпишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:\r\n\r\n[1, \r\n 1, 4, \r\n 1, 4, 9,\r\n  ...\r\n 1, 4, 9, ..., n*n]\r\n\r\nТ.е. сначала выписан квадрат 1, потом квадраты чисел от 1 до 2, потом квадраты чисел от 1 до 3 и т.д.\r\n\r\nДополнительные условия:\r\n- triangle1 надо написать с помощью оператора >>= и функции return\r\n- triangle2 надо написать с помощью do нотации\r\n\r\nПримеры вызова:\r\n\r\ntriangle1 3\r\ntriangle2 3\r\n\r\nВ обоих случаях должно получиться:\r\n[1,1,4,1,4,9]\r\n        ',1),(160,4,38,'Приведите пример лямбда выражения, вычисление которого дает нормальном порядке применения редукций находит нормальную форму, а при аппликативном порядке - зацикливается.\r\n\r\nЗамечания:\r\n- Это простая задача (если понимать все иностранные слова в ее формулировке:)\r\n- Тут, естественно не надо писать никакой программы, надо просто написать пример. \r\n- Поскольку система не показывает мне символ  (это ее известный но неисправленный баг), пишите  вместо \\, пожалуйста, или \\\\ или lambda или что-то в таком роде.',1),(159,2,36,'Опишите функцию chirchToList, которая для числа Черча возвращает список из чисел 1 соответствующей длины. \r\n\r\nПример вызова:\r\n\r\nchurchToList ( f x -> f(f(f x)))\r\n\r\nРезультат д.б. равен [1,1,1].\r\n\r\nДополнительное условие:\r\nВ этой задаче нельзя использовать toInt, чтобы получить обычное число и дальше уже что-то с ним делать. Надо просто вызвать число Черча (это же на самом деле функция от двух параметров) с подходящими параметрами, чтобы в результате получился список из 1 нужной длины. просто.\r\n        ',1),(161,1,39,'Описать фунцкию containsX, которая для данного выражения проверяет, содержит ли оно хотя бы одну переменную X и возвращает True или False.\r\n\r\nПримеры вызова:\r\n\r\ncontainsX (Mult (Num 2)(Num 2))\r\nРезультат должен быть равен False\r\n\r\ncontainsX (Mult (Num 2)(Add X (Num 1)))\r\nРезультат должен быть равен True\r\n\r\nЗамечание:\r\n- в этой задаче имеется в виду первый вариант Expr, в котором была одна переменная X',1),(162,2,39,'а. Добавить в тип Expr конструкции, позволяющие определять свои функции и вызывать их. Для простоты мы рассматриваем только функции с одним параметром, параметр и результат функции - целые числа.\r\nб. Добавить в функцию eval реализацию для этих конструкций.\r\n\r\nПример вызова:\r\n\r\neval (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"X\")) (Add (Num 1) (Call \"F\" (Num 5)))) [] []\r\n\r\nДолжно получиться 26, потому что мы тут записали на нашем языке выражение:\r\nlet f x = x*x in 1 + f 5\r\n\r\nЗамечания:\r\n- Задача не очень простая, но, в общем то, тут надо придумать представление данных (как хранить функции) и дальше все, в общем, не сложно.\r\n- Я бы предложил завести отдельный параметр - список для хранения функций. Поэтому в примере вызова у меня в конце два пустых списка - для переменных и для функций. Но, если хотите, можете немного изменить список для хранения значений переменных, чтобы в нем можно было хранить и функции. Тесты тогда не пройдут, ну и ладно, я так проверю. \r\n- Можно считать, что не надо поддерживать замыкания (т.е. в функциях не используются нелокальные переменные).',3),(163,11,1,'test \"фис\"',1),(164,6,61,'Пример\r\n\r\nЯ\r\n  не  \r\n    знаю\r\nкак лучше     это\r\n\r\nсделаь\r\n        \r\n        \r\n        ',1);

/*Table structure for table `test` */

DROP TABLE IF EXISTS `test`;

CREATE TABLE `test` (
  `TestID` int(11) NOT NULL AUTO_INCREMENT,
  `Expression` varchar(100) DEFAULT NULL,
  `Result` varchar(255) DEFAULT NULL,
  `TaskID` int(11) DEFAULT NULL,
  `Smart` int(11) NOT NULL DEFAULT '0',
  `TestForTaskID` int(11) NOT NULL,
  `SmartHelp` varchar(300) DEFAULT NULL,
  PRIMARY KEY (`TestID`),
  UNIQUE KEY `TestForTaskID` (`TestForTaskID`,`TaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=320 DEFAULT CHARSET=utf8;

/*Data for the table `test` */

insert  into `test`(`TestID`,`Expression`,`Result`,`TaskID`,`Smart`,`TestForTaskID`,`SmartHelp`) values (31,'f 1','2',18,0,1,''),(35,'g 6','False',22,0,1,''),(36,'g 7','True',22,0,2,''),(37,'let phi = f 100 in (phi > 1.618) && (phi < 1.619)','True',18,1,2,'При больших f получается замечательное число (первое описание - Евклид, примерно 300 г. до н.э.)'),(38,'b 3','0.7',24,0,1,''),(39,'let res = b 100 in res > 0.69777 && res < 0.69778','True',24,1,2,'При больших n должно получаться примерно 0.697'),(40,'sumsin 1','1',19,0,1,''),(41,'let { x = sumsin 3; y = sin 6 / (sin 1 + sin 2 + sin 3) } in abs(x - y) < 0.001','True',19,1,2,'Для 3 что-то не так '),(42,'sumfact 1','1',20,0,1,''),(43,'sumfact 2','3',20,0,2,''),(44,'sumfact 3','9',20,1,3,'В условии же приведен пример вызова :( '),(45,'sumfact 4','33',20,0,4,''),(46,'nseq 1','1',21,0,1,''),(47,'nseq 2','1',21,0,2,''),(48,'nseq 3','2',21,0,3,''),(49,'nseq 9','8',21,0,4,''),(50,'g 40','True',22,0,3,''),(51,'g 1000','True',22,0,4,''),(52,'g 3','False',22,1,5,'1 - это не простое число'),(53,'g 11','False',22,0,6,''),(251,'b 17','True',23,0,3,''),(56,'minlist [3,2,7]','2',25,0,1,''),(57,'minsum [1,8,3,2,7]','5',27,0,1,''),(58,'check (\\ x->x>5) [3,2,7,4]','True',28,0,1,''),(59,'check (\\x->x>5) [3,2,1,4]','False',28,0,2,''),(60,'check (\\x->x>5) []','False',28,1,3,'Как вы думаете, что правильно будет вернуть, если список пустой?'),(61,'checkDifferent [3,2,7]','True',29,0,1,''),(62,'checkDifferent [3,2,7,5,2,8]','False',29,0,2,''),(250,'b 22','False',23,0,2,''),(249,'b 10','True',23,0,1,''),(65,'rev [1,2,3] == [3,2,1]','True',26,0,1,''),(66,'rev [1]','[1]',26,0,2,''),(67,'rev []','[]',26,0,3,''),(68,'parts [1, 2, 8, 2, 5, 6]','True',30,0,1,''),(69,'parts [1, 2, 3, 4, 5]','True',30,0,2,''),(70,'parts [1, 2, 1, 2, 3, 4]','True',30,0,3,''),(71,'parts [4, 6, 3, 5, 7]','False',30,0,4,''),(72,'parts [1, 2, 3, 4, 1, 2, 3, 4, 5, 6]','True',30,1,5,'Длина, о которой идет речь в условии, это вовсе не обязательно длина самого короткого куска, она может быть и короче. '),(267,'identity 4','[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]',133,0,1,''),(266,'f [2, 3, 1, 4, 1, 8]','[2,3,-1,4,-1,8]',132,0,1,''),(76,'parts [1, 2, 3, 4, 5, 6, 1, 2, 3, 4]','True',30,0,6,''),(77,'isosc (0, 2) (2, 0) (2,2)','True',35,0,1,''),(78,'isosc (0, 2) (2,2) (2, 0)','True',35,0,2,''),(79,'isosc (2,2) (0, 2) (2, 0)','True',35,0,3,''),(80,'isosc (0, 0) (10, 10) (10, -10)','True',35,0,4,''),(81,'isosc (-3, 2) (2, 0) (2,2)','False',35,0,5,''),(82,'cubeTable 4','[(1,1),(2,8),(3,27),(4,64)]',36,0,1,''),(83,'minsum [1,8,3,2,7] ','5',37,0,1,''),(84,'minsum [1,1]','2',37,0,2,''),(85,'height (Node 1 Empty Empty)','0',38,0,1,''),(86,'height (Node 1 (Node 1 Empty Empty) Empty)','1',38,0,2,''),(87,'height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)','2',38,0,3,''),(88,'minHeight (Node 1 Empty Empty)','0',39,0,1,''),(89,'minHeight (Node 1  (Node 2  (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))','1',39,0,2,''),(90,'frame 4','[[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]]',40,0,1,''),(91,'frame 2','[[1,1],[1,1]]',40,0,2,''),(92,'countOdd [2, 3, 4, 8, 5, 33, 9]','4',41,0,1,''),(93,'countOdd1 [2, 3, 4, 8, 5, 33, 9]','4',41,0,2,''),(94,'countOdd []','0',41,1,3,'А если список пустой?'),(95,'countOdd1 []','0',41,1,4,'А если список пустой?'),(96,'myfoldl (+) 0 [1,2,3]','6',42,0,1,''),(97,'myfoldl (+) 10 []','10',42,0,2,''),(98,'myfoldl (^) 2 [3]','8',42,0,3,''),(99,'let f x y = 2*x+y in myfoldl f 2 [3,5]','19',42,0,4,''),(100,'minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))','2',39,0,3,''),(259,'isArithm [1, 2, 3, 2]','False',31,0,5,''),(258,'isArithm [1, 2]','True',31,0,4,''),(104,'let (x,y) = euclid 3 5 in 3*x+5*y','1',43,0,1,''),(105,'let (x,y) = euclid 1 1 in 1*x+1*y','1',43,0,2,''),(106,'let (x,y) = euclid 33 25 in 33*x+25*y','1',43,0,3,''),(264,'let x = len [(1,1), (1,2), (2,1)] in x > 2.40 && x < 2.42','True',129,0,1,''),(265,'findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 2','True',130,0,1,''),(263,'g 171','False',22,0,7,''),(262,'let x = averageForLeaves (Node 1 Empty Empty) in x > 0.99 && x < 1.01','True',44,0,2,''),(257,'isArithm [3, 3, 3]','True',31,0,3,''),(261,'let x = averageForLeaves (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) in x > 2.49 && x < 2.51','True',44,0,1,''),(116,'minHeight (Node 1 Empty (Node 2 Empty Empty)) ','1',39,0,4,''),(117,'minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)','2',39,0,5,''),(256,'isArithm [10, 5, 0]','True',31,0,2,''),(255,'isArithm [1, 2, 3, 4]','True',31,0,1,''),(120,'myreverse [1,2,3,4]','[4,3,2,1]',48,0,1,''),(121,'length (powerset [1,2,3])','8',47,0,1,''),(122,'powerset []','[[]]',47,0,2,''),(123,'myreverse [1,2,3]','[3,2,1]',48,0,2,''),(124,'elem [1,3] (powerset [1,2,3])','True',47,0,3,''),(125,'elem [3,1] (powerset [1,2,3])','False',47,1,4,'Элементы в подсписках из powerset должны идти в том же порядке, что и в исходном списке.'),(126,'minsum [2,9,1,3]','4',37,0,3,''),(127,'isosc (0,5) (3,4) (5,0)','False',35,0,6,''),(128,'(repeatFunc (*2) 3) 1','8',51,0,1,''),(129,'repeatFunc id 10 1','1',51,0,2,''),(130,'repeatFunc (*2) 3 10','80',52,0,1,''),(131,'coins 2','[[1,0,0]]',53,0,1,''),(132,'length (coins 10)','4',53,0,2,''),(133,'elem [1,1,1] (coins 10)','True',53,0,3,''),(134,'allLists 1 1','[[1]]',56,0,1,''),(135,'length (allLists 3 3)','27',56,0,2,''),(136,'elem [3,2,3] (allLists 3 3)','True',56,0,3,''),(137,'canMakeScheme [4,4,5] 7','True',57,0,1,''),(138,'canMakeScheme [4,4,5] 1','False',57,0,2,''),(139,'canMakeScheme [13, 7, 2, 3] 6','True',57,0,3,''),(140,'sumDiv 10','8',61,0,1,''),(141,'perfects 100','[6,28]',61,0,2,''),(142,'amicables 300','[(220,284)]',62,0,1,''),(143,'take 4 ones','[1,11,111,1111]',63,0,1,''),(144,'canMakeScheme [13, 7, 2, 3] 7','True',57,0,4,''),(145,'canMakeScheme [50,13,2,3,7] 56','True',57,0,5,''),(146,'canMakeScheme [13,10, 2, 1000, 1000] 506','True',57,0,6,''),(147,'length(filter(==(3,2))(take 100 cantor))','1',65,0,1,''),(148,'length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))','1',66,0,1,''),(149,'length[x|(x,y)<-take 100 cantor, x<=0||y<=0]','0',65,0,2,''),(150,'(bigSin 0.99) < 0.991','True',69,0,1,''),(151,'myFilter (>0) [1,-2,3,-5]','[1,3]',70,0,1,''),(152,'z>1.64 && z<1.65','True',71,0,1,''),(153,'weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]','28',72,0,1,''),(154,'take 10 fibs','[1,1,2,3,5,8,13,21,34,55]',73,0,1,''),(155,'sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))','7',74,0,1,''),(156,'perimeter (Circle 0)','0',76,0,1,''),(157,'perimeter (Rect 3 7)','20',76,0,2,''),(158,'let x = approxSum [sin i/i | i<-[1..]] in x < 1.1','True',71,1,2,'Последовательность может содержать и отрицательные числа'),(159,'length(filter(==[6,3])(take 100 (generalizedCantor 2)))','1',66,0,2,''),(160,'length (allLists 2 5)','32',56,0,4,''),(161,'canMakeScheme [13,2,30,3,7] 6','True',58,0,1,''),(162,'canMakeScheme [13,2,30,3,7] 6','True',57,0,7,''),(163,'take 20 sqrt2','[1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]',77,0,1,''),(164,'take 6 pascal','[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]',78,0,1,''),(165,'canMakeScheme [13,2,10] 30','False',57,0,8,''),(166,'sqrt2 !! 98','7',77,0,2,''),(167,'sqrt2 !! 99','2',77,0,3,''),(168,'sumPos (Node (-5) (Node 2 Empty Empty) Empty)','2',74,0,2,''),(169,'take 15 lst367','[3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]',81,0,1,''),(170,'countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]','1',82,0,1,''),(171,'countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]','2',82,0,2,''),(173,'countDifferentVars [(1,2),(2,3), (4,5)] [1,7,2,3,1,4,5]','3',82,0,3,''),(174,'countDifferentVars [(1,3),(2,3), (3,4)] [1,2,3,1,4,5,6]','3',82,0,4,''),(175,'countDifferentVars [(1,2),(2,1)] [1,2,3]','2',82,0,5,''),(176,'countDifferentVars [] [1,2,3]','3',82,1,6,'Списки могут быть и пустыми..'),(177,'countDifferentVars [(1,2),(2,3), (4,5)] []','0',82,1,7,'Списки могут быть и пустыми..'),(178,'length(filter(==[4,1,1])(take 100 (generalizedCantor 5)))','1',66,0,3,''),(179,'countDifferentVars [(1,2),(2,1),(2,1)] [1,2,3]','2',82,0,8,''),(180,'countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9]','3',82,0,9,''),(181,'countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]','1',82,0,10,''),(182,'Rat 1 2 + Rat 1 7','9/14',85,0,1,''),(183,'Rat 1 3 < Rat 4 5','True',85,0,2,''),(184,'Rat 1 (-3) < Rat 4 5','True',85,1,3,'Числа ведь могут быть и отрицательными...'),(185,'allNondivisible [2, 7, 6, 5]','False',86,0,1,''),(186,'allNondivisible [4, 7, 6, 5]','True',86,0,2,''),(187,'eval (Add (Num 3) (Mult X X)) 10','103',87,0,1,''),(188,'diff (Mult X X)','Add (Mult (Num 1) X) (Mult X (Num 1))',88,0,1,''),(189,'flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))','[1,2,3]',89,0,1,''),(190,'merge [1,4,8] [2,4,5,10,20]','[1,2,4,5,8,10,20]',91,0,1,''),(191,'allNondivisible [4,2]','False',86,0,3,'Делимость - это '),(192,'take 10 ham','[1,2,3,4,6,8,9,12,16,18]',93,0,1,''),(305,'take 25 (digits 1 7)','[1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1]',155,0,1,''),(194,'countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]','1',82,0,11,''),(195,'checkBrackets [\'(\',\'[\',\']\',\')\']','True',97,0,1,''),(196,'checkBrackets [\'(\',\'[\',\')\',\']\']','False',97,0,2,''),(197,'checkBrackets [\'(\',\'[\',\']\']','False',97,0,3,''),(198,'checkBrackets [\'(\',\'[\',\']\',\')\',\')\']','False',97,0,4,''),(199,'fromStr(toStr (Node \'a\' (Node \'b\' Empty Empty) Empty))','Node \'a\' (Node \'b\' Empty Empty) Empty',98,0,1,''),(200,'checkBrackets [\'(\',\')\',\'[\',\']\']','True',97,0,5,''),(201,'checkBrackets [\'(\',\'(\']','False',97,0,6,''),(202,'countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]','1',82,0,12,''),(203,'fromStr(toStr(Node \'a\' (Node \'b\'  Empty Empty) (Node \'b\'  Empty Empty) ))','Node \'a\' (Node \'b\' Empty Empty) (Node \'b\' Empty Empty)',98,0,2,''),(204,'merge [1,2] [3,4]','[1,2,3,4]',91,0,2,''),(205,'length (allDiffLists 3 3)','6',100,0,1,''),(206,'simplify (Mult X (Mult X (Num 0)))','Num 0',101,0,1,''),(207,'findMajor [2,3,15,2,2,2]','Just 15',102,0,1,''),(208,'findMajor [2,3,5,2,4]','Nothing',102,0,2,''),(209,'findInLists [[1,2], [2,8,7]] (>5) 0','8',103,0,1,''),(210,'findInLists [[1,8,2], [2,7]] (>10) 0','0',103,0,2,''),(211,'doubleEven [1,2,6,3]','[1,2,2,6,6,3]',104,0,1,''),(212,'cartesian [1,2] [3,4]','[(1,3),(1,4),(2,3),(2,4)]',105,0,1,''),(213,'simplify (Mult X X)','Mult X X',101,0,2,''),(214,'checkBrackets [\')\',\'(\']','False',97,0,7,''),(215,'checkBrackets [\'[\',\'(\',\')\',\'(\',\']\',\')\']','False',97,0,8,''),(216,'findMajor [1,2,3,2,2,2,1]','Just 2',106,0,1,''),(217,'findMajor [1,2,3,2,1]','Nothing',106,0,2,''),(218,'findMajor [1,2]','Nothing',106,0,3,''),(219,'Or X (Not X) == T','True',107,0,1,''),(220,'Or X (And X (Not X)) == T','False',107,0,2,''),(221,'length(queens 3 2)','2',108,0,1,''),(222,'length (queens 4 4)','2',108,0,2,''),(223,'length (queens 8 8)','92',108,0,3,''),(224,'eval (Add (Var [\'x\']) (Mult (Var [\'y\']) (Num 3))) [([\'x\'], 5), ([\'y\'], 8)]','29',111,0,1,''),(225,'eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'y\'], 2)]','20',112,0,1,''),(226,'sum_cps [1,2,3] (^2)','36',113,0,1,''),(227,'triangle1 3','[1,1,2,1,2,3]',114,0,1,''),(228,'triangle2 3','[1,1,2,1,2,3]',114,0,2,''),(229,'triangle2 1','[1]',114,0,3,''),(230,'f [7, 6, 4, 3, 20, 15, 9] ','[30]',115,0,1,''),(234,'let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]','(20,[25,2])',118,0,1,''),(233,'let c3 f x = f (f x) in toInt (inc c3)','3',117,0,2,''),(235,'let c3 f x = f (f (f x)) in toInt c3','3',116,0,1,''),(236,'let c3 f x = f (f (f x)) in toInt (inc c3)','4',117,0,3,''),(237,'let three f x = f (f (f x)) in toInt (dec three)','2',119,0,1,''),(238,'eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'x\'], 0),([\'y\'], 2)]','20',112,0,2,''),(239,'checkBrackets [\'[\',\'[\',\']\',\']\']','True',97,0,9,''),(240,'findMajor [3,3,1,2,1,2,1,3,3]','Nothing',106,0,4,''),(241,'f [7, 6, 4, 3, 20, 15, 9] ','Just 30',123,0,1,''),(242,'f [7, 6, 4, 3, 9]','Nothing',123,0,2,''),(243,'eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []','5',122,0,1,''),(244,'Not X == Not X','True',107,0,3,''),(245,'Not X == X','False',107,0,4,''),(246,'And (Or X X) (Not X) == Not X','False',107,0,5,''),(247,'F == X','False',107,0,6,''),(248,'eval (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"X\")) (Call \"F\" (Add (Num 1) (Num 1)))) [] []','4',122,0,2,''),(252,'b (1024+64)','True',23,0,4,''),(253,'b 16','True',23,1,5,'степени двойки могут быть и одинаковыми'),(254,'b 1','False',23,0,6,''),(268,'findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 5','True',130,0,2,''),(269,'findTree (Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty)) 0','False',130,0,3,''),(270,'minTree(Node 5 (Node 2 Empty Empty) (Node 7 Empty Empty))','2',134,0,1,''),(271,'minPosTree(Node 5 (Node (-2) Empty Empty) (Node 7 Empty Empty))','5',135,0,1,''),(272,'minPosTree (Node 3 (Node (-2) Empty (Node (-1) Empty Empty)) Empty)','3',135,0,2,''),(273,'let x=averageForLeaves (Node 3 (Node (2) Empty Empty) Empty) in x > 1.99 && x < 2.01','True',44,0,3,''),(274,'minPosTree (Node 5 (Node (-2) Empty (Node 3 Empty Empty)) (Node 7 Empty Empty))','3',135,0,3,''),(275,'chessboard 2 2','[[0,0,1,1],[0,0,1,1],[1,1,0,0],[1,1,0,0]]',137,0,1,''),(276,'chessboard 3 1','[[0,1,0],[1,0,1],[0,1,0]]',137,0,2,''),(277,'mymap (*3) [1,2,3]','[3,6,9]',138,0,1,''),(278,'mymap (*3) []','[]',138,0,2,''),(279,'transpose [[1,2,3],[4,5,6],[7,8,9]]','[[1,4,7],[2,5,8],[3,6,9]]',139,0,1,''),(280,'length (triangle 3)','10',140,0,1,''),(281,'length (triangle (-3))','10',140,0,2,''),(282,'elem (2,1) (triangle 3)','True',140,0,3,''),(283,'elem (2,2) (triangle 3)','False',140,0,4,''),(284,'myTake 4 [2,3,5,7,11,13,15]','[2,3,5,7]',142,0,1,''),(285,'alternatingSum [2,5,3,7,8,2,3]','2',143,0,1,''),(286,'take 5 facts','[1,2,6,24,120]',144,0,1,''),(287,'take 3 pyramid','[[1],[2,1],[3,2,1]]',145,0,1,''),(288,'filter (==(2,3)) (take 1000 cantor)','[(2,3)]',65,0,3,''),(289,'filter (==(2,10)) (take 1000 cantor)','[(2,10)]',65,0,4,''),(290,'corner 4','[[1,2,3,4],[2,2,3,4],[3,3,3,4],[4,4,4,4]]',147,0,1,''),(291,'anyMore [3,2,8] [7,1,2,9]','True',148,0,1,''),(292,'anyMore [3,2,8] [2,9]','False',148,0,2,''),(293,'let f x = [x*x,100*x] in superMap f [1,2,3]','[1,100,4,200,9,300]',149,0,1,''),(294,'length (traingle (-1))','3',140,0,5,''),(295,'myTake 3 [1..]','[1,2,3]',142,0,2,''),(296,'merge [1,4,8] [2,4,5,10,20]','[1,2,4,5,8,10,20]',150,0,1,''),(297,'merge [1,2] [3,4]','[1,2,3,4]',150,0,2,''),(298,'merge [1,2] []','[1,2]',150,0,3,''),(299,'merge [] [3,4]','[3,4]',150,0,4,''),(300,'take 15 lst367','[3,6,7,33,36,37,63,66,67,73,76,77,333,336,337]',153,0,1,''),(301,'checkBrackets [\'(\',\')\',\')\',\')\']','False',154,0,1,''),(302,'checkBrackets [\'(\',\'(\',\'(\',\')\']','False',154,0,2,''),(303,'checkBrackets [\'(\',\')\',\')\',\'(\',\'(\',\')\']','False',154,0,3,''),(304,'checkBrackets [\'(\',\'(\',\')\',\'(\',\')\',\')\']','True',154,0,4,''),(306,'triangle1 3','[1,1,4,1,4,9]',157,0,1,''),(307,'triangle2 3','[1,1,4,1,4,9]',157,0,2,''),(308,'triangle2 1','[1]',157,0,3,''),(309,'take 4 (digits 2 3)','[6,6,6,6]',155,0,2,''),(310,'flatten Empty','[]',89,0,2,''),(311,'flatten (Node 1 Empty (Node 2 Empty Empty))','[1,2]',89,0,3,''),(312,'checkBrackets [\'(\',\']\']','False',97,0,10,''),(313,'simplify (Mult X (Mult X X))','Mult X (Mult X X)',101,0,3,''),(314,'let ch3 f x= f (f (f x)) in churchToList ch3','[1,1,1]',159,0,1,''),(315,'containsX (Mult (Num 2)(Num 2))','False',161,0,1,''),(316,'containsX (Mult (Num 2)(Add X (Num 1)))','True',161,0,2,''),(317,'eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []','5',162,0,1,''),(318,'simplify (Mult (Num 3) (Num 4))','Mult (Num 3) (Num 4)',101,0,4,''),(319,'test \"фис\"','1',163,0,1,'');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `UserID` varchar(32) NOT NULL,
  `Password` varchar(32) NOT NULL,
  `Name` varchar(30) NOT NULL,
  `Surname` varchar(30) NOT NULL,
  `RoleID` int(11) NOT NULL DEFAULT '1',
  `GroupNumber` int(11) DEFAULT NULL,
  PRIMARY KEY (`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`UserID`,`Password`,`Name`,`Surname`,`RoleID`,`GroupNumber`) values ('alexey.solovyew@gmail.com','Phoenix','Alexey','Solovyew',1,541),('msimuni','12345','Michael','Simuni',2,NULL),('17954442','haloween','Максим','',1,0),('41863862','haloween','Вика','',1,0),('211643007','haloween','Другие','',1,0),('170482213','haloween','Никита','',1,0),('25446179','haloween','Елена','Иванова',1,361),('5337814','haloween','Никита','Бобров',1,361),('3598995','haloween','Ольга','',1,0),('6205237','haloween','Марина','',1,0),('4169333','haloween','Диметрио','',1,0),('21743638','haloween','Ольга','',1,0),('23959','haloween','Мария','',1,0),('16436579','haloween','Серёга','',1,0),('tori','db10rf','Vika','Iskanderova',1,361),('SMakarov','warfolomei','Сергей','Макаров',1,361),('57304539','haloween','Сева','',1,361),('7475152','haloween','Анна','Иванова',1,361),('shkuratov.ilya','434513','Илья','Шкуратов',1,361),('419892','haloween','Алекс&','',1,0),('517309','haloween','Михаил','',1,0);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
