/*
SQLyog Ultimate v11.11 (64 bit)
MySQL - 5.6.16-log : Database - simuni
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`simuni` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `simuni`;

/*Table structure for table `generalinfo` */

DROP TABLE IF EXISTS `generalinfo`;

CREATE TABLE `generalinfo` (
  `GeneralInfoID` int(11) NOT NULL AUTO_INCREMENT,
  `Name` varchar(30) NOT NULL,
  `Value` varchar(30) NOT NULL,
  PRIMARY KEY (`GeneralInfoID`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `generalinfo` */

insert  into `generalinfo`(`GeneralInfoID`,`Name`,`Value`) values (1,'CurrentHometaskID','40');

/*Table structure for table `hometask` */

DROP TABLE IF EXISTS `hometask`;

CREATE TABLE `hometask` (
  `HometaskID` int(11) NOT NULL AUTO_INCREMENT,
  `Topic` varchar(200) NOT NULL,
  `Date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `Deadline` date NOT NULL,
  PRIMARY KEY (`HometaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=52 DEFAULT CHARSET=utf8;

/*Data for the table `hometask` */

insert  into `hometask`(`HometaskID`,`Topic`,`Date`,`Deadline`) values (1,'Знакомство с Haskell, рекурсия, накапливающие параметры','2012-03-09 00:00:00','2013-09-10'),(2,'Дополнительные задачи к заданию 1','0000-00-00 00:00:00','2013-09-20'),(3,'Списки, функции высшего порядка','2012-05-02 13:53:52','2013-09-17'),(4,'Доп. задачи про списки','2012-09-16 22:24:39','2013-09-27'),(5,'Простые задачи про функции высшего порядка на ','2012-09-17 23:03:33','2013-09-28'),(6,'Пары, стандартные функции высш.порядка, деревья','2012-09-20 18:33:06','2013-09-24'),(7,'Доп. задачи про пары и просто посложнее','2012-09-21 15:27:01','2013-10-04'),(8,'any для С# и С++','2012-09-24 15:46:00','2013-10-05'),(9,'map, foldr, repeatFunc','2012-09-29 15:59:40','2013-10-01'),(10,'Доп. задачи про fold','2012-10-01 15:23:01','2013-10-11'),(11,'Карринг на C#','2012-10-03 19:40:10','2013-10-12'),(12,'list comprehension, резисторы и т.д.','2012-10-05 17:16:13','2013-10-07'),(13,'Дополнительные задачи - наборы, резисторы','2012-10-08 16:12:46','2013-10-20'),(14,'filter и map на C#','2012-10-11 20:44:02','2013-10-20'),(15,'list comprehension, lazy, foldTree','2012-10-14 12:08:24','2013-10-14'),(16,'Кантор','2012-10-15 22:26:49','2013-10-25'),(17,'Замыкания','2012-10-18 22:42:45','2013-10-26'),(18,'Завязывание в узел, катаморфизм','2012-10-21 01:12:17','2013-10-21'),(19,'Доп. задачи про бесконечные списки','2012-10-22 12:41:24','2013-11-01'),(20,'генераторы на c#','2012-10-27 18:53:56','2013-11-02'),(21,'knot, Hindley Milner etc','2012-10-27 18:54:48','2013-10-28'),(22,'knot и унификация','2012-11-01 19:04:58','2013-11-08'),(23,'knot на C#','2012-11-03 12:43:10','2013-11-09'),(24,'классы, set, diff, findsame, supermap','2012-11-05 10:32:11','2013-11-12'),(25,'Доп.задачи про классы и set','2012-11-09 11:30:23','2013-11-15'),(26,'C# Множество как функция и merge','2012-11-13 00:19:53','2013-11-16'),(27,'шахматы, show схемы','2012-11-15 17:21:29','2013-11-23'),(28,'C# AllDiffLists','2012-11-17 17:16:59','2013-11-23'),(45,'29 C# размещения и failure continuation','2013-11-12 22:45:06','2012-09-16'),(29,'>>=, failure continuation, eval, diff','2012-11-18 23:40:05','2013-11-18'),(30,'доп: скобки Major','2012-11-22 23:09:33','2013-11-29'),(31,'c# failurecontinuation','2012-11-25 23:52:19','2013-11-30'),(32,'do нотация 3 поиска >>> evalVar simplify','2012-11-27 01:37:33','2013-11-26'),(33,'доп с контрольной logexpr','2012-11-30 00:04:47','2013-12-06'),(34,'доп c# cps expr','2013-09-17 16:44:17','2013-12-07'),(35,'>>>= lambda1 let letfunc','2013-09-24 17:28:31','2013-12-02'),(36,'доп dec тавтология','2013-09-27 22:47:24','2013-12-13'),(37,'доп c# continuation','2013-10-08 16:26:38','2013-12-14'),(38,'предпоследнее','2013-10-15 22:39:55','2013-12-10'),(39,'последнее доп','2013-10-16 16:47:18','2013-12-23'),(40,'последенее - Карри Ховард и y комбинатор','2013-10-23 14:30:00','2013-12-23'),(41,'31 Черч - 1 и еще','2013-10-23 14:30:26','2011-10-01'),(42,'C++ замыкания','2013-10-31 21:02:29','2011-10-01'),(43,'26 Expr на C#','2013-11-01 08:44:50','2011-10-01'),(50,'27 Failure continuation и т.д.','2013-12-03 22:57:13','2011-10-01'),(44,'28 Чаще всех других, упростить, ферзи','2013-11-06 12:38:59','2011-10-01'),(46,'32 C# continuation','2013-11-19 18:40:55','2012-10-12'),(47,'33 Предпоследнее','2013-11-20 14:00:20','2012-10-12'),(48,'10 any tree','2013-11-20 14:04:37','2012-10-12'),(49,'17 Много простых задач','2013-11-28 08:49:04','2012-09-16'),(51,'21 генераторы','2013-12-05 18:17:18','2012-10-12');

/*Table structure for table `result` */

DROP TABLE IF EXISTS `result`;

CREATE TABLE `result` (
  `ResultID` int(11) NOT NULL AUTO_INCREMENT,
  `Text` varchar(30) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`ResultID`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

/*Data for the table `result` */

insert  into `result`(`ResultID`,`Text`) values (0,'Не проверено'),(1,'Зачтено'),(2,'Не зачтено'),(3,'СПИСАНО');

/*Table structure for table `role` */

DROP TABLE IF EXISTS `role`;

CREATE TABLE `role` (
  `RoleID` int(11) NOT NULL AUTO_INCREMENT,
  `RoleName` varchar(30) NOT NULL,
  PRIMARY KEY (`RoleID`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

/*Data for the table `role` */

insert  into `role`(`RoleID`,`RoleName`) values (1,'student'),(2,'teacher');

/*Table structure for table `solution` */

DROP TABLE IF EXISTS `solution`;

CREATE TABLE `solution` (
  `SolutionID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskID` int(11) NOT NULL,
  `UserID` varchar(30) NOT NULL,
  `LoadTimestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `ResultID` int(11) NOT NULL,
  `Code` mediumtext NOT NULL,
  `TestResult` varchar(150) NOT NULL,
  PRIMARY KEY (`SolutionID`)
) ENGINE=MyISAM AUTO_INCREMENT=8419 DEFAULT CHARSET=utf8;

/*Data for the table `solution` */

insert  into `solution`(`SolutionID`,`TaskID`,`UserID`,`LoadTimestamp`,`ResultID`,`Code`,`TestResult`) values (8329,107,'nomeansno','2013-12-05 23:31:07',2,'--- Не совсем правильно, вот так у вас программа циклится:\r\n--- X == Not (Not X)\r\n--- Попробуйте исправить, пожалуйста, желательно до субботы включительно, чтобы если что можно было еще исправить.\r\ndata LogExpr = T | F | X | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	T == T = True\r\n\r\n	F == F = True\r\n\r\n	X == X = True\r\n\r\n	T == X = False\r\n\r\n	Not X == Not X = True\r\n\r\n	X == T = False\r\n\r\n	T == F = False\r\n\r\n	F == T = False\r\n\r\n	X == F = False\r\n\r\n	F == X = False\r\n\r\n	Not X == X = False\r\n\r\n	Not X == T = False\r\n\r\n	Not X == F = False\r\n\r\n	X == Not X = False\r\n\r\n	T == Not X = False\r\n\r\n	F == Not X = False \r\n\r\n	e1 == e2 = eval e1 == eval e2\r\n\r\n\r\n\r\neval T = T\r\n\r\neval F = F\r\n\r\neval X = X\r\n\r\neval (Not F) = T\r\n\r\neval (Not T) = F\r\n\r\neval (Not X) = Not X\r\n\r\neval (Not e) = Not (eval e)\r\n\r\neval (Or T e) = T\r\n\r\neval (Or e T) = T\r\n\r\neval (Or F e) = eval e\r\n\r\neval (Or e F) = eval e\r\n\r\neval (Or X X) = X\r\n\r\neval (Or X (Not X)) = T\r\n\r\neval (Or (Not X) X) = T\r\n\r\neval (Or e1 e2) = eval (Or (eval e1) (eval e2))\r\n\r\neval (And T e) = eval e\r\n\r\neval (And e T) = eval e\r\n\r\neval (And F e) = F\r\n\r\neval (And e F) = F\r\n\r\neval (And X X) = X\r\n\r\neval (And X (Not X)) = F\r\n\r\neval (And (Not X) X) = F \r\n\r\neval (And e1 e2) = eval (And (eval e1) (eval e2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8328,107,'nomeansno','2013-12-05 23:16:22',0,'data LogExpr = T | F | X | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\n\n\n\ninstance Eq LogExpr where\n\n	T == T = True\n\n	F == F = True\n\n	X == X = True\n\n	T == X = False\n\n	X == T = False\n\n	T == F = False\n\n	F == T = False\n\n	X == F = False\n\n	F == X = False\n\n	e1 == e2 = eval e1 == eval e2\n\n\n\neval T = T\n\neval F = F\n\neval X = X\n\neval (Not F) = T\n\neval (Not T) = F\n\neval (Not X) = (Not X)\n\neval (Or T e) = T\n\neval (Or e T) = T\n\neval (Or F e) = eval e\n\neval (Or e F) = eval e\n\neval (Or X X) = X\n\neval (Or X (Not X)) = T\n\neval (Or (Not X) X) = T\n\neval (Or e1 e2) = eval (Or (eval e1) (eval e2))\n\neval (And T e) = eval e\n\neval (And e T) = eval e\n\neval (And F e) = F\n\neval (And e F) = F\n\neval (And X X) = X\n\neval (And X (Not X)) = F\n\neval (And (Not X) X) = F \n\neval (And e1 e2) = eval (And (eval e1) (eval e2))\n\n\n','Не удалось вычислить выражение \"Not X == Not X\", проверьте правильность синтаксиса'),(8326,98,'5247795','2013-12-05 22:45:33',1,'data Tree a = Empty|Node a (Tree a) (Tree a) deriving Show\r\n\r\n\r\n\r\ntoStr t = toStr\' t []\r\n\r\ntoStr\' Empty = (\'e\':)\r\n\r\ntoStr\' (Node c l r) = (\'n\':).(c:) . toStr\' l . toStr\' r\r\n\r\nfromStr s = fst (fromStr\' s)\r\n\r\nfromStr\' [x] = (Empty, [])\r\n\r\nfromStr\' (x:y:xs) =\r\n\r\n	if x == \'e\' then (Empty, (y:xs))\r\n\r\n	else \r\n\r\n	if x == \'n\' then\r\n\r\n	let\r\n\r\n		(l, a) = fromStr\' xs\r\n\r\n		(r, b) = fromStr\' a\r\n\r\n		in (Node y l r, b)\r\n\r\n	else \r\n\r\n	let\r\n\r\n		(l, a) = fromStr\' (y:xs)\r\n\r\n		(r, b) = fromStr\' a\r\n\r\n		in (Node x l r, b) \r\n','<br/>Тесты успешно пройдены!'),(8325,121,'6053606','2013-12-05 22:33:27',1,'from __future__ import print_function\r\n\r\ndef fact_cps(n, f):\r\n    if not n:\r\n        return f(1)\r\n    return fact_cps(n - 1, lambda res: f(res * n))\r\n\r\nfact_cps(4, lambda res: print(res))\r\n','<br/>Тесты успешно пройдены!'),(8324,98,'6053606','2013-12-05 22:18:24',1,'data Tree = Node Char Tree Tree\r\n          | Empty\r\n          deriving Show\r\n\r\ntoStr :: Tree -> String\r\ntoStr t = go t \"\" where\r\n  go Empty = (\'e\':)\r\n  go (Node c l r) = (acc -> \'n\':(c:acc)) . go l . go r\r\n    --- или вместо (acc -> \'n\':(c:acc)) можно написать (\'n\':).(c:). \r\n\r\nfromStr :: String -> Tree\r\nfromStr = fst . go where\r\n  go (\'e\':rest) = (Empty, rest)\r\n  go (\'n\':c:rest) =\r\n    let (l, rest1) = go rest\r\n        (r, rest2) = go rest1\r\n    in (Node c l r, rest2)\r\n','<br/>Тесты успешно пройдены!'),(8323,107,'6053606','2013-12-05 21:55:22',1,'data LogExpr = T\r\n             | F\r\n             | X\r\n             | Not LogExpr\r\n             | And LogExpr LogExpr\r\n             | Or LogExpr LogExpr\r\n             deriving Show\r\n\r\nlogEval :: LogExpr -> Bool -> Bool\r\nlogEval e x = go e where\r\n  go T = True\r\n  go F = False\r\n  go X = x\r\n  go (Not e) = not $ go e\r\n  go (And e1 e2) = go e1 && go e2\r\n  go (Or e1 e2) = go e1 || go e2\r\n\r\ninstance Eq LogExpr where\r\n  e1 == e2 = and [logEval e1 x == logEval e2 x | x <- [True, False]]\r\n','<br/>Тесты успешно пройдены!'),(8322,98,'62628590','2013-12-05 21:06:44',1,'data Tree a = Empty|Node a (Tree a) (Tree a) deriving Show\r\n\r\ntoStr t = toStr\' t []\r\ntoStr\' Empty = (\'e\':)\r\ntoStr\' (Node c l r) = (\'n\':).(c:) . toStr\' l . toStr\' r\r\n\r\nfromStr\' [x] = (Empty, [])\r\nfromStr\' (x:y:xs) =\r\n    if x==\'e\' then (Empty, (y:xs))\r\n    else \r\n	if x==\'n\' then\r\n		let\r\n			(l, a) = fromStr\' xs\r\n			(r, b) = fromStr\' a\r\n        in (Node y l r, b)\r\n	else \r\n		let\r\n			(l, a) = fromStr\' (y:xs)\r\n			(r, b) = fromStr\' a\r\n        in (Node x l r, b)		\r\nfromStr s = fst (fromStr\' s)','<br/>Тесты успешно пройдены!'),(8321,138,'6053606','2013-12-05 20:45:02',1,'---  У Вас опечатка во второй строчке того, что мы хотим написать:\r\n--- >>= вместо >>>=\r\n--- И в ответе в примере появляется число 20, которого нет в списке\r\n\r\nreturn1 x = xs -> (x, xs)\r\n','<br/>Тесты успешно пройдены!'),(8327,107,'nomeansno','2013-12-05 23:09:38',0,'data LogExpr = T | F | X | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\n\n\n\ninstance Eq LogExpr where\n\n	T == T = True\n\n	F == F = True\n\n	X == X = True\n\n	_ == X = False\n\n	X == _ = False\n\n	T == _ = False\n\n	_ == T = False\n\n	F == _ = False\n\n	_ == F = False\n\n	e1 == e2 = eval e1 == eval e2\n\n\n\neval T = T\n\neval F = F\n\neval X = X\n\neval (Not F) = T\n\neval (Not T) = F\n\neval (Not X) = (Not X)\n\neval (Or T e) = T\n\neval (Or e T) = T\n\neval (Or F e) = eval e\n\neval (Or e F) = eval e\n\neval (Or X X) = X\n\neval (Or X (Not X)) = T\n\neval (Or (Not X) X) = T\n\neval (Or e1 e2) = eval (Or (eval e1) (eval e2))\n\neval (And T e) = eval e\n\neval (And e T) = eval e\n\neval (And F e) = F\n\neval (And e F) = F\n\neval (And X X) = X\n\neval (And X (Not X)) = F\n\neval (And (Not X) X) = F \n\neval (And e1 e2) = eval (And (eval e1) (eval e2))\n\n\n','Выражение имеет неправильное значение: Or X (Not X) == T'),(8320,138,'3226573','2013-12-05 15:22:01',1,'find f [] = (0, [])\r\nfind f (x:xs) = if f x then (x, xs) else find f xs\r\n\r\nf >>>= g = xs -> let\r\n                    (x, xs1) = f xs\r\n                  in g x xs1\r\n\r\nreturn1 val rest = (val, rest)\r\n\r\nf = find (>3) >>>= x -> \r\n    find (>x) >>>= y ->\r\n    return1 (x + y)','<br/>Тесты успешно пройдены!'),(8319,127,'3226573','2013-12-05 14:34:18',1,'find condFunc condVal (x:xs) = if (condFunc condVal x) then (x,xs) else find condFunc condVal xs\r\n\r\nf1 >>>= f2 = xs -> let\r\n                      (res1, tail1) = f1 xs\r\n                      (res2, tail2) = f2 res1 tail1\r\n                    in (res2, tail2)\r\n\r\n\r\nmore  :: Ord a => a -> a -> Bool\r\nmore  = x y -> y > x\r\n\r\nless  :: Ord a => a -> a -> Bool\r\nless  = x y -> y < x\r\n\r\nequal :: Eq a => a -> a -> Bool\r\nequal = x y -> x == y\r\n\r\nnoneq :: Eq a => a -> a -> Bool\r\nnoneq = x y -> x /= y\r\n\r\n\r\n--f = find more 3 >>>= find more >>>= find more\r\nf = find more 3 >>>= find more','<br/>Тесты успешно пройдены!'),(8318,119,'toskira','2013-12-05 14:29:03',2,'--- Очент хорошо, но не совсем корректно. Из-за того, что у вас используется 0, получается,\r\n--- что результат dec беред на вход не любую фунцеию и значение, а только числовую функцию и числовое значение\r\n--- Ниже тест, который это подтверждает:\r\nc3 = f x -> f(f(f x))\r\nc2 = dec c3\r\n\r\ntest3 = c3 (1:) []\r\ntest2 = c2 (1:) []\r\n---  test3 норамально срабатывает, и выдает [1,1,1] а вот test2 не работает, а в принципе должен работать\r\n--- Попробуйте исправить, пожалуйста\r\n\r\ntoInt f = f (+1) 0\r\n\r\nfirst a _ = a\r\nsecond _ b = b\r\n\r\nnext f pair = (e -> e (pair second) (f (pair second)))\r\ndec g = (f x -> (g (next f) (e -> e 0 x)) first)\r\n','<br/>Тесты успешно пройдены!'),(8317,107,'617015','2013-12-05 00:00:03',1,'data LogExpr = X | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr | T | F\r\n\r\n\r\n\r\neval T var = True\r\n\r\neval F var = False\r\n\r\neval X var = var\r\n\r\neval (Not e) var = not (eval e var)\r\n\r\neval (Or e1 e2) var = (eval e1 var) || (eval e2 var)\r\n\r\neval (And e1 e2) var = (eval e1 var) && (eval e2 var)\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	(e1) == (e2) = eval e1 True == eval e2 True && eval e1 False == eval e2 False\r\n','<br/>Тесты успешно пройдены!'),(8316,98,'62628590','2013-12-04 23:01:24',2,'--- Нет, это не совсем по условию. Обратите пожалуйста внимание:\r\n--- - В функции toStr используйте, пожалуйста, прием описанный в слайдах 11 занятия для flatten. Т.е. используйте, пожалуйста, оператор композиции.\r\n\r\ndata Tree a = Empty|Node a (Tree a) (Tree a) deriving Show\r\ntoStr Empty = \"e\"\r\ntoStr (Node c l r) = [\'n\']++[c] ++ toStr l ++ toStr r\r\nfromStr\' [x] = (Empty, [])\r\nfromStr\' (x:y:xs) =\r\n    if x==\'e\' then (Empty, (y:xs))\r\n    else \r\n	if x==\'n\' then\r\n		let\r\n			(l, a) = fromStr\' xs\r\n			(r, b) = fromStr\' a\r\n        in (Node y l r, b)\r\n	else \r\n		let\r\n			(l, a) = fromStr\' (y:xs)\r\n			(r, b) = fromStr\' a\r\n        in (Node x l r, b)		\r\nfromStr s = fst (fromStr\' s)','<br/>Тесты успешно пройдены!'),(8315,139,'ilia','2013-12-04 20:01:19',1,'data Expr = \r\n\r\n		Num Integer |\r\n\r\n		Var String |\r\n\r\n		Add Expr Expr |\r\n\r\n		Mult Expr Expr |\r\n\r\n		Let String Expr Expr |\r\n\r\n		LetFunc String String Expr Expr |\r\n\r\n		Call String Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Num n) _ _ = n\r\n\r\neval (Var v) defs fdefs = let\r\n\r\n		y = snd (head (filter (d -> fst d == v) defs))\r\n\r\n	in eval y defs fdefs\r\n\r\neval (Add e1 e2) defs fdefs = eval e1 defs fdefs + eval e2 defs fdefs\r\n\r\neval (Mult e1 e2) defs fdefs = eval e1 defs fdefs * eval e2 defs fdefs\r\n\r\neval (Let v y e) defs fdefs = eval e ((v, y) : defs) fdefs\r\n\r\neval (LetFunc f x y e) defs fdefs = eval e defs ((f, (x, y)) : fdefs)\r\n\r\neval (Call f v) defs fdefs = let\r\n\r\n		xy = snd (head (filter (fd -> fst fd == f) fdefs))\r\n\r\n	in eval (snd xy) ((fst xy, v) : defs) fdefs\r\n\r\n\r\n\r\nmain = do\r\n\r\n		print (eval (\r\n\r\n				LetFunc \"F\" \"X\"\r\n\r\n					(Mult (Var \"X\") (Var \"X\"))\r\n\r\n					(Add (Num 1) (Call \"F\" (Num 5)))\r\n\r\n					)\r\n\r\n				[ ] [ ]\r\n\r\n				)\r\n\r\n		print (eval (\r\n\r\n				LetFunc \"F\" \"X\"\r\n\r\n					(Mult (Var \"X\") (Var \"X\"))\r\n\r\n					(Call \"F\" (Add (Num 1) (Num 1)))\r\n\r\n					)\r\n\r\n				[ ] [ ]\r\n\r\n				)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8314,107,'8519021','2013-12-04 01:02:39',1,'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr deriving Show\r\n\r\n\r\n\r\neval (X) bConst = bConst\r\n\r\neval (Not a) bConst = if (eval a bConst) == T then F else T\r\n\r\neval (T) _ = T\r\n\r\neval (F) _ = F\r\n\r\neval (And a b) bConst = if (eval a bConst) == T && (eval b bConst) == T then T else F\r\n\r\neval (Or a b) bConst = if (eval a bConst) == T || (eval b bConst) == T then T else F\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n  T == T = True\r\n\r\n  T == F = False\r\n\r\n  F == F = True\r\n\r\n  F == T = False\r\n\r\n  a == b = (eval a T) == (eval b T) && (eval a F) == (eval b F)\r\n','<br/>Тесты успешно пройдены!'),(8313,107,'2156724','2013-12-03 22:34:06',1,'data LogExpr = 	 T\r\n\r\n              	|F\r\n\r\n		|X\r\n\r\n		|Or LogExpr LogExpr\r\n\r\n		|And LogExpr LogExpr\r\n\r\n		|Not LogExpr\r\n\r\n\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	T == T = True\r\n\r\n	F == F = True\r\n\r\n	F == T = False\r\n\r\n	T == F = False\r\n\r\n	e1 == e2 = if (eval e1 T == eval e2 T) &&  (eval e1 F == eval e2 F) then True\r\n\r\n			else False\r\n\r\n	 \r\n\r\n\r\n\r\neval (Or e1 e2) b = if (eval e1 b == F && eval e2 b == F) then F else T \r\n\r\neval (And e1 e2) b = if (eval e1 b == T && eval e2 b == T) then T else F\r\n\r\neval (X) b = b \r\n\r\neval (Not e1) b = if (e1 == T) then F else T \r\n\r\neval (F) b = F\r\n\r\neval (T) b = T ','<br/>Тесты успешно пройдены!'),(8312,121,'115753099','2013-12-03 16:43:18',1,'using System;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n		static void fact_cps(int n, Action <int> ret)\r\n		{\r\n			if ( n == 0 )\r\n				ret(1);\r\n			else\r\n				fact_cps(n - 1, t => ret(t * n));\r\n		} \r\n		 \r\n		public static void Main (string[] args)\r\n		{\r\n			fact_cps ( 3, (int x) => {Console.WriteLine(x);});\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(8311,119,'3226573','2013-12-02 20:37:41',1,'toInt g = g (+1) 0\r\n\r\ninc g = f x -> f (g f x)\r\n\r\n-- Признаюсь, придумал решение не сам. Но полностью в нем разобрался\r\n  --- ОК, хорошо. Это тоже вполне существенное достижение:)\r\ndec n = f x -> ( n (g h -> h (g f)) (u -> x) ) id','<br/>Тесты успешно пройдены!'),(8310,119,'toskira','2013-12-02 15:22:51',2,' --- Нет, это не по условию, обратите внимание, что пары по условию использовать нельзя.\r\n --- Но, могу подсказать, можно попробовать имитировать пары с помошью функций\r\ntoInt f = f (+1) 0\r\n\r\nnext f (a, b) = (b, f a)\r\ndec g = (f x -> snd (g (next f) (0, x)))','<br/>Тесты успешно пройдены!'),(8309,107,'1595828','2013-12-02 14:40:02',1,'data LogExpr = X | T | F | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr  deriving (Show)\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	l1 == l2 = (eval l1 True == eval l2 True) &&(eval l1 False == eval l2 False)\r\n\r\n\r\n\r\neval T _= True\r\n\r\neval F _= False\r\n\r\neval X b = b\r\n\r\neval (Not e) b= not (eval e b)	\r\n\r\neval (And a1 a2) b= eval a1 b && eval a2 b\r\n\r\neval (Or a1 a2) b= eval a1 b || eval a2 b\r\n\r\n \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8308,121,'toskira','2013-12-02 14:34:56',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace _34_1 {\r\n\r\n	class Program {\r\n\r\n		static Func<int, Func<int, int>, Func<int, int>> FactCps = (n, f) => {\r\n			if (n > 0) {\r\n				return FactCps(n - 1, x => f(x * n));\r\n			} else {\r\n				return f;\r\n			}\r\n		};\r\n\r\n		static int Fact(int n) {\r\n			return FactCps(n, x => x)(1);\r\n		}\r\n\r\n		static void Main(string[] args) {\r\n			Console.WriteLine(Fact(5));\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(8306,116,'ip','2013-12-02 14:11:22',1,'toInt g = g (+1) 0 \r\n','<br/>Тесты успешно пройдены!'),(8307,107,'toskira','2013-12-02 14:13:48',1,'data LogExpr = And LogExpr LogExpr\r\n             | Or LogExpr LogExpr\r\n             | Not LogExpr\r\n             | T\r\n             | F\r\n             | X\r\n\r\ninstance Eq LogExpr where\r\n  e1 == e2 = ((eval e1 True) == (eval e2 True)) && ((eval e1 False) == (eval e2 False))\r\n\r\neval (And e1 e2) v = (eval e1 v) && (eval e2 v)\r\neval (Or e1 e2) v = (eval e1 v) || (eval e2 v)\r\neval (Not e) v = not (eval e v)\r\neval T v = True\r\neval F v = False\r\neval X v = v\r\n','<br/>Тесты успешно пройдены!'),(8305,98,'toskira','2013-12-02 14:03:20',1,'data Tree a = Empty |\r\n              Node Char (Tree a) (Tree a)\r\n  deriving (Show)\r\n\r\ntoStr t = toStr\' t \"\"\r\n\r\ntoStr\' Empty s = (\'e\':s)\r\ntoStr\' (Node c l r) s0 = let s1 = toStr\' r s0\r\n                             s2 = toStr\' l s1\r\n                         in \'n\':c:s2\r\n\r\nfromStr s = fst (fromStr\' s)\r\n\r\nfromStr\' (\'e\':s) = (Empty, s)\r\nfromStr\' (\'n\':c:s0) = let (l, s1) = fromStr\' s0\r\n                          (r, s2) = fromStr\' s1\r\n                      in  ((Node c l r), s2)','<br/>Тесты успешно пройдены!'),(8304,122,'toskira','2013-12-02 13:46:37',1,'data Expr = Num Int\r\n          | Var String\r\n          | Let String Int Expr\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n          | LetFunc String String Expr Expr\r\n          | Call String Expr\r\n\r\nfind v ((a, b):t) = if(v == a) then b else find v t\r\nfind_f name ((f, v, e):t) = if(f == name) then (v, e) else find_f name t\r\n\r\neval (Num a) _ _ = a\r\neval (Var v) l _ = find v l\r\neval (Let s v e) l lf = eval e ((s, v):l) lf\r\neval (Add e1 e2) l lf = (eval e1 l lf) + (eval e2 l lf)\r\neval (Mult e1 e2) l lf = (eval e1 l lf) * (eval e2 l lf)\r\neval (LetFunc f v e1 e2) l lf = eval e2 l ((f, v, e1):lf)\r\neval (Call f e) l lf = let (v, ie) = find_f f lf\r\n                       in eval ie [(v, eval e l lf)] lf','<br/>Тесты успешно пройдены!'),(8303,122,'MaryK','2013-12-02 13:36:49',1,'{-- ####### --}\r\n\r\ndownUp n = if n == 1\r\n\r\n           then print n\r\n\r\n           else\r\n\r\n               do\r\n\r\n                   print n\r\n\r\n                   downUp (n - 1)\r\n\r\n                   print n\r\n\r\n\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n    x <- find (<5) xs\r\n\r\n    y <- find (>10) xs\r\n\r\n    z <- find (/=7) xs\r\n\r\n    return (x + y + z)\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nf >>>= g = xs ->\r\n\r\n    let\r\n\r\n        (x, xs1) = f xs\r\n\r\n    in g x xs1\r\n\r\n\r\n\r\nfind1 cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then (x, xs)\r\n\r\n   else find1 cond xs\r\n\r\n\r\n\r\nff = find1 (>3) >>>= (x -> find1 (>x))\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr\r\n\r\neval (Num i) _ _ = i\r\n\r\neval (Var name) env _ = getValue name env\r\n\r\neval (Add x y) env fenv = eval x env fenv + eval y env fenv\r\n\r\neval (Mult x y) env fenv = eval x env fenv * eval y env fenv\r\n\r\neval (Let x val e) env fenv = eval e ((x, val) : env) fenv\r\n\r\n\r\n\r\neval (LetFunc name parameter body expr) env fenv = eval expr env ((name, (parameter, body)) : fenv)\r\n\r\neval (Call name expr) env fenv = \r\n\r\n    let\r\n\r\n        argumentValue = eval expr env fenv\r\n\r\n        (parameter, body) = getValue name fenv\r\n\r\n    in eval body ((parameter, argumentValue) : env) fenv\r\n\r\n\r\n\r\ngetValue name env = \r\n\r\n     head \r\n\r\n           [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8302,127,'MaryK','2013-12-02 13:36:29',1,'{-- ####### --}\r\n\r\ndownUp n = if n == 1\r\n\r\n           then print n\r\n\r\n           else\r\n\r\n               do\r\n\r\n                   print n\r\n\r\n                   downUp (n - 1)\r\n\r\n                   print n\r\n\r\n\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n    x <- find (<5) xs\r\n\r\n    y <- find (>10) xs\r\n\r\n    z <- find (/=7) xs\r\n\r\n    return (x + y + z)\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nf >>>= g = xs ->\r\n\r\n    let\r\n\r\n        (x, xs1) = f xs\r\n\r\n    in g x xs1\r\n\r\n\r\n\r\nfind1 cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then (x, xs)\r\n\r\n   else find1 cond xs\r\n\r\n\r\n\r\nff = find1 (>3) >>>= (x -> find1 (>x))\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr\r\n\r\neval (Num i) _ _ = i\r\n\r\neval (Var name) env _ = getValue name env\r\n\r\neval (Add x y) env fenv = eval x env fenv + eval y env fenv\r\n\r\neval (Mult x y) env fenv = eval x env fenv * eval y env fenv\r\n\r\neval (Let x val e) env fenv = eval e ((x, val) : env) fenv\r\n\r\n\r\n\r\neval (LetFunc name parameter body expr) env fenv = eval expr env ((name, (parameter, body)) : fenv)\r\n\r\neval (Call name expr) env fenv = \r\n\r\n    let\r\n\r\n        argumentValue = eval expr env fenv\r\n\r\n        (parameter, body) = getValue name fenv\r\n\r\n    in eval body ((parameter, argumentValue) : env) fenv\r\n\r\n\r\n\r\ngetValue name env = \r\n\r\n     head \r\n\r\n           [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8301,124,'MaryK','2013-12-02 13:36:15',1,'{-- ####### --}\r\n\r\ndownUp n = if n == 1\r\n\r\n           then print n\r\n\r\n           else\r\n\r\n               do\r\n\r\n                   print n\r\n\r\n                   downUp (n - 1)\r\n\r\n                   print n\r\n\r\n\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n    x <- find (<5) xs\r\n\r\n    y <- find (>10) xs\r\n\r\n    z <- find (/=7) xs\r\n\r\n    return (x + y + z)\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nf >>>= g = xs ->\r\n\r\n    let\r\n\r\n        (x, xs1) = f xs\r\n\r\n    in g x xs1\r\n\r\n\r\n\r\nfind1 cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then (x, xs)\r\n\r\n   else find1 cond xs\r\n\r\n\r\n\r\nff = find1 (>3) >>>= (x -> find1 (>x))\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr\r\n\r\neval (Num i) _ _ = i\r\n\r\neval (Var name) env _ = getValue name env\r\n\r\neval (Add x y) env fenv = eval x env fenv + eval y env fenv\r\n\r\neval (Mult x y) env fenv = eval x env fenv * eval y env fenv\r\n\r\neval (Let x val e) env fenv = eval e ((x, val) : env) fenv\r\n\r\n\r\n\r\neval (LetFunc name parameter body expr) env fenv = eval expr env ((name, (parameter, body)) : fenv)\r\n\r\neval (Call name expr) env fenv = \r\n\r\n    let\r\n\r\n        argumentValue = eval expr env fenv\r\n\r\n        (parameter, body) = getValue name fenv\r\n\r\n    in eval body ((parameter, argumentValue) : env) fenv\r\n\r\n\r\n\r\ngetValue name env = \r\n\r\n     head \r\n\r\n           [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8300,123,'MaryK','2013-12-02 13:36:01',1,'{-- ####### --}\r\n\r\ndownUp n = if n == 1\r\n\r\n           then print n\r\n\r\n           else\r\n\r\n               do\r\n\r\n                   print n\r\n\r\n                   downUp (n - 1)\r\n\r\n                   print n\r\n\r\n\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n    x <- find (<5) xs\r\n\r\n    y <- find (>10) xs\r\n\r\n    z <- find (/=7) xs\r\n\r\n    return (x + y + z)\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\nf >>>= g = xs ->\r\n\r\n    let\r\n\r\n        (x, xs1) = f xs\r\n\r\n    in g x xs1\r\n\r\n\r\n\r\nfind1 cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then (x, xs)\r\n\r\n   else find1 cond xs\r\n\r\n\r\n\r\nff = find1 (>3) >>>= (x -> find1 (>x))\r\n\r\n\r\n\r\n{-- ####### --}\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr\r\n\r\neval (Num i) _ _ = i\r\n\r\neval (Var name) env _ = getValue name env\r\n\r\neval (Add x y) env fenv = eval x env fenv + eval y env fenv\r\n\r\neval (Mult x y) env fenv = eval x env fenv * eval y env fenv\r\n\r\neval (Let x val e) env fenv = eval e ((x, val) : env) fenv\r\n\r\n\r\n\r\neval (LetFunc name parameter body expr) env fenv = eval expr env ((name, (parameter, body)) : fenv)\r\n\r\neval (Call name expr) env fenv = \r\n\r\n    let\r\n\r\n        argumentValue = eval expr env fenv\r\n\r\n        (parameter, body) = getValue name fenv\r\n\r\n    in eval body ((parameter, argumentValue) : env) fenv\r\n\r\n\r\n\r\ngetValue name env = \r\n\r\n     head \r\n\r\n           [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8299,117,'54411321','2013-12-02 13:35:05',1,'toInt ch = ch (+1) 0\r\n\r\n\r\n\r\ninc ch = f x -> f (ch f x)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8297,117,'1835693','2013-12-02 13:17:24',1,'toInt wrap = wrap (x -> x + 1) 0\r\n\r\ninc wrap f x = f $ wrap f x\r\n','<br/>Тесты успешно пройдены!'),(8298,112,'toskira','2013-12-02 13:31:57',1,'data Expr = Num Int                                                                 \r\n          | Var String                                                              \r\n          | Let String Int Expr                                                     \r\n          | Add Expr Expr                                                           \r\n          | Mult Expr Expr                                                          \r\n                                                                                    \r\nfind v ((a, b):t) = if(v == a) then b else find v t                                 \r\n                                                                                    \r\neval (Num a) _ = a                                                                  \r\neval (Var v) l = find v l\r\neval (Let s v e) l = eval e ((s, v):l)\r\neval (Add e1 e2) l = (eval e1 l) + (eval e2 l)\r\neval (Mult e1 e2) l = (eval e1 l) * (eval e2 l)','<br/>Тесты успешно пройдены!'),(8295,116,'54411321','2013-12-02 13:05:51',1,'toInt ch = ch (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(8296,116,'1835693','2013-12-02 13:12:42',1,'toInt f = f (x -> x + 1) 0\r\n','<br/>Тесты успешно пройдены!'),(8293,117,'480387','2013-12-02 12:58:30',1,'toInt num = num (+1) 0\r\n\r\ninc num = (f -> f.(num f))\r\n','<br/>Тесты успешно пройдены!'),(8294,117,'toskira','2013-12-02 12:59:15',1,'toInt f = f (+1) 0\r\n\r\ninc g = (f x -> g f $ f x)','<br/>Тесты успешно пройдены!'),(8292,124,'1835693','2013-12-02 12:57:34',1,'downUp n = do\r\n  down n\r\n  up (n - 2) n\r\n  \r\ndown 1 = print 1\r\ndown n = do\r\n  print n\r\n  down (n - 1)\r\n\r\nup 0 n = print n\r\nup k n = do\r\n  print (n - k)\r\n  up (k - 1) n\r\n','<br/>Тесты успешно пройдены!'),(8291,112,'54411321','2013-12-02 12:55:02',1,'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | Var String | Let String Integer Expr\r\n\r\n\r\n\r\neval (Num i) _ = i\r\n\r\neval (Add x y) xs = eval x xs + eval y xs\r\n\r\neval (Mult x y) xs = eval x xs * eval y xs\r\n\r\neval (Var x) xs = getVar x xs\r\n\r\neval (Let x i e) xs = eval e ((x,i):xs)\r\n\r\n\r\n\r\ngetVar x xs = snd (head (filter ((==x).fst) xs))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8290,124,'54411321','2013-12-02 12:54:32',1,'downUp 1 = print 1\r\n\r\ndownUp n = do \r\n\r\n        print n\r\n\r\n        downUp (n-1)\r\n\r\n        print n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8289,123,'54411321','2013-12-02 12:54:08',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x \r\n\r\n                       else find cond xs\r\n\r\n                       \r\n\r\nf xs = do\r\n\r\n           x <- find (<5) xs\r\n\r\n           y <- find (>10) xs\r\n\r\n           z <- find (/=7) xs\r\n\r\n           return (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(8288,123,'1835693','2013-12-02 12:53:53',1,'find cond xs = getFirst $ [ x | x <- xs, cond x ]\r\n\r\ngetFirst [] = Nothing\r\ngetFirst xs = Just $ head xs\r\n\r\nf xs = do\r\n  x <- find (<5) xs\r\n  y <- find (>10) xs\r\n  z <- find (/=7) xs\r\n  return (x + y + z)\r\n  ','<br/>Тесты успешно пройдены!'),(8286,116,'480387','2013-12-02 12:47:30',0,'toInt num = num (+1) 0','<br/>Тесты успешно пройдены!'),(8287,116,'480387','2013-12-02 12:47:32',1,'toInt num = num (+1) 0','<br/>Тесты успешно пройдены!'),(8285,116,'toskira','2013-12-02 12:46:51',1,'toInt f = f (+1) 0','<br/>Тесты успешно пройдены!'),(8284,18,'p.ekaterina','2013-12-02 12:38:26',2,'data TV = Films String String | Series String Integer;\r\n\r\n\r\n\r\nmfunc ( Series n p) =p;\r\n\r\nmfunc t=0;\r\n\r\n\r\n\r\nfunc []=False;\r\n\r\nfunc (x:xs)= if mfunc x ==1 then True else funk xs;\r\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(8282,117,'12828920','2013-12-02 12:31:01',1,'toInt church = church (+1) 0\r\n\r\ninc church = f x -> f (church f x)\r\n','<br/>Тесты успешно пройдены!'),(8283,124,'480387','2013-12-02 12:38:20',1,'downUp n = f ([n-k|k<-[0..(n-1)]]++[0..n]) (2*n+1)\r\nf [x] 1 = print x\r\nf (x:xs) k = do\r\n				print x\r\n				f xs (k-1)','<br/>Тесты успешно пройдены!'),(8281,122,'nomeansno','2013-12-02 12:24:38',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr deriving (Show, Eq)\r\n\r\n\r\n\r\ntovalue _ [] = 0\r\n\r\ntovalue var ((var\',val):xs) = if var == var\' then val else tovalue var xs\r\n\r\n\r\n\r\nfind cond ((name,(var,def)):xs) = \r\n\r\n   if cond name \r\n\r\n   then (var,def)\r\n\r\n   else find cond xs\r\n\r\n\r\n\r\neval (Num i) = (\\_ _ -> i)\r\n\r\neval (Var var) = (vlist _ -> tovalue var vlist)\r\n\r\neval (Add e1 e2) = (vlist flist -> eval e1 vlist flist + eval e2 vlist flist)\r\n\r\neval (Mult e1 e2) = (vlist flist -> eval e1 vlist flist * eval e2 vlist flist)\r\n\r\neval (Let var value e) = (vlist flist -> eval e ((var,value):vlist) flist)\r\n\r\neval (LetFunc name var def expr) = (vlist flist -> eval expr vlist ((name,(var,def)):flist))\r\n\r\neval (Call name expr) = (vlist flist -> let (var,def) = find (==name) flist in eval def ((var,(eval expr vlist flist)):vlist) flist)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8279,124,'12828920','2013-12-02 12:02:05',1,'downUp 1= do\r\n\r\n			print 1\r\n  --- тут do писать не обязательно\r\n\r\ndownUp n = do\r\n\r\n			print n\r\n\r\n			downUp (n - 1)\r\n\r\n			print n\r\n','<br/>Тесты успешно пройдены!'),(8280,116,'12828920','2013-12-02 12:08:04',1,'toInt church = church (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(8278,123,'12828920','2013-12-02 11:45:58',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs)= if cond x\r\n\r\n				   then Just x\r\n\r\n				   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n		x <- find (< 5) xs\r\n\r\n		y <- find (> 10) xs\r\n\r\n		z <- find (/= 7) xs\r\n\r\n		return (x + y + z)\r\n','<br/>Тесты успешно пройдены!'),(8277,112,'MaryK','2013-12-02 10:35:09',1,'data Expr = Var String | Num Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr \r\n\r\n\r\n\r\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\n\r\ngetValue [] _ = 0\r\n\r\n\r\n\r\neval (Var x) vars = getValue vars x\r\n\r\neval (Num n) _ = n\r\n\r\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\n\r\neval (Mult m1 m2) n = eval m1 n * eval m2 n\r\n\r\neval (Let x val e) vars = eval e ((x, val) : vars)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8276,117,'MaryK','2013-12-02 10:23:27',1,'toInt churchNum = churchNum (+1) 0\r\n\r\ninc churchNum = f x -> f (churchNum f x)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8274,117,'ip','2013-12-02 07:04:14',1,'inc g = (f x -> f.g x)\r\n   --- Идея использовать композицию хорошая, но записывается не совсем так. \r\n   --- Например потому что x - это второй параметр g и мы не можем использовать x\r\n   --- для параметризации\r\n   --- Но ОК, засчитано ','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(8275,122,'617015','2013-12-02 09:37:20',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr \r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Let str int (Num k))  func xs = k\r\n\r\neval (Let str int (Var c)) func xs = if str == c then int else eval (Var c) func xs \r\n\r\neval (Let str int (Mult e1 e2)) func xs = (eval(Let str int e1)func xs) *  (eval(Let str int e2) func xs)\r\n\r\neval (Let str int (Add e1 e2)) func xs = (eval(Let str int e1) func xs) + (eval(Let str int e2) func xs) \r\n\r\n\r\n\r\neval (Num k) func xs = k\r\n\r\neval (Var c) func xs = getValue c xs\r\n\r\neval (Add e1 e2) func xs = (eval e1 func xs) + (eval e2 func xs)\r\n\r\neval (Mult e1 e2) func xs = (eval e1 func  xs) * (eval e2 func xs) \r\n\r\n\r\n\r\neval (LetFunc f var e1 e2) func xs =  eval e2 ((f,var, e1):func) xs\r\n\r\n\r\n\r\neval (Call str e) func xs = eval (evalf (getExpr str func) e) func xs\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ngetValue var values = head [val| (v,val)<-values, v==var]\r\n\r\ngetExpr funcName functions = head [expr| (function, var, expr)<- functions, function==funcName]\r\n\r\n\r\n\r\nevalf (Num k) e = (Num k)\r\n\r\nevalf (Var c) e = (e)\r\n\r\nevalf (Add e1 e2) e = (Add(evalf e1  e) (evalf e2 e))\r\n\r\nevalf (Mult e1 e2) e = (Mult(evalf e1  e) (evalf e2 e)) \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8273,116,'egeorge','2013-12-02 05:52:03',1,'toInt ch_num = ch_num (+1) 0','<br/>Тесты успешно пройдены!'),(8272,122,'ip','2013-12-02 05:40:34',1,'--- Не совсем правильно (см замечание в конце). Но идея в общем, правильная, засчитано.\r\ndata Expr = Num Integer | Var String\r\n\r\n                        | Add Expr Expr \r\n\r\n                        | Mult Expr Expr \r\n\r\n                        | Let String Expr Expr\r\n\r\n                        | LetFunc String String Expr Expr\r\n\r\n                        | Call String Expr \r\n\r\n                        deriving Show\r\n\r\n\r\n\r\neval (Num i) xs fs = i\r\n\r\neval (Var x) xs  fs = eval (last( xs >>= ((a,b) -> if (a==x)\r\n\r\n                                    	            then [b]\r\n\r\n                                  	            else [] )))\r\n\r\n \r\n\r\neval (Add a b) xs fs = (eval a xs fs) + (eval b xs fs) \r\n\r\neval (Mult a b) xs fs = (eval a xs fs) * (eval b xs fs)\r\n\r\neval (Let x i a) xs fs = eval a (xs++[(x,i)]) fs\r\n\r\neval (LetFunc f x e out) xs fs = eval out xs (fs ++ [(f,x,e)])\r\n\r\neval (Call f value) xs fs =let \r\n\r\n			   new = let\r\n\r\n                                 (vari,exp) = last( fs >>= ((g,x,e) -> if (f==g)\r\n\r\n                                    	                       then [(x,e)]\r\n\r\n                                  	                       else [] ))\r\n\r\n                                 in (eval exp [(vari,value)] fs)\r\n--- Вот тут не совсем то (надо сначала вычислить value и потом уже результат положить в xs)\r\n\r\n                           in (eval new xs fs)\r\n\r\n\r\n\r\n\r\n','Не удалось вычислить выражение \"eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []\", проверьте правильность синтаксиса'),(8271,117,'bazhutin','2013-12-02 04:54:24',1,'toInt a = a (+1) 0 \r\n\r\ninc = m -> func -> a -> func (m func a)','<br/>Тесты успешно пройдены!'),(8269,117,'2260659','2013-12-02 04:45:06',1,'toInt expr = expr (+1) 0\r\n\r\ninc = \r\n -> f -> x -> f (n f x)\r\n','<br/>Тесты успешно пройдены!'),(8270,116,'2260659','2013-12-02 04:46:13',1,'toInt expr = expr (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(8268,112,'ip','2013-12-02 04:42:39',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\n                                                       deriving Show\r\n\r\n\r\n\r\n\r\n\r\neval (Num i) xs = i\r\n\r\neval (Var x) xs = last( xs >>= ((a,b) -> if (a==x)\r\n\r\n                                    	  then [b]\r\n\r\n                                  	  else [] ))\r\n\r\n \r\n\r\neval (Add a b) xs = (eval a xs) + (eval b xs) \r\n\r\neval (Mult a b) xs = (eval a xs) * (eval b xs)\r\n\r\neval (Let x i a) xs = eval a (xs++[(x,i)])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8267,127,'ip','2013-12-02 04:28:14',1,'--- Ну, мне хотелось увидеть, что вы можете придумать и я увидел, замечательно.\r\n--- (Но сам я, действительно, имел в виду не совсем такое решение, оно есть в слайдах)\r\n{-\r\n\r\nЧестно говоря, не смог придумать способа чтобы парсер разабрал выражение с неопределенным x\r\n\r\nкак в примере f = find (>3) ... какие-то заклинания ... find (>x) \r\n\r\n\r\n\r\nСмог сделать так, но это наверное не то что Вам хотелось бы увидеть(\r\n\r\n\r\n\r\n\r\n\r\nПример ищет сначала число >3 потом число большее x\r\n\r\ncompose (find (>3)) find (<) [5,4,10]\r\n\r\n\r\n\r\n-}\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncompose a b f = (xs -> let \r\n\r\n                        (x,ys) = a xs\r\n\r\n                         in b (f x) ys  )\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8266,116,'bazhutin','2013-12-02 04:22:51',1,'toInt a =  a (+1) 0','<br/>Тесты успешно пройдены!'),(8265,124,'2260659','2013-12-02 04:13:37',1,'downUp 1 = print 1\r\n\r\ndownUp n = \r\n\r\n	if n > 0\r\n\r\n	then do \r\n\r\n		print n\r\n\r\n		downUp (n-1)\r\n\r\n		print n\r\n\r\n	else print 0\r\n','<br/>Тесты успешно пройдены!'),(8264,123,'bazhutin','2013-12-02 04:10:29',1,'find cond [] = Nothing\r\nfind cond (x:xs) = \r\n   if cond x \r\n   then Just x\r\n   else find cond xs\r\n\r\n\r\nf xs = do\r\nx <- find (<5) xs\r\ny <- find (>10) xs\r\nz <- find (/=7) xs\r\nreturn (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(8263,123,'bazhutin','2013-12-02 04:08:37',0,'find cond [] = Nothing\r\nfind cond (x:xs) = \r\n   if cond x \r\n   then Just x\r\n   else find cond xs\r\n\r\n\r\nf xs = do\r\nx <- find (<5) xs\r\ny <- find (>10) xs\r\nz <- find (/=7) xs\r\nreturn (x+y+z)\r\n','Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),(8262,123,'2260659','2013-12-02 04:08:37',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n	if cond x \r\n\r\n	then Just x \r\n\r\n	else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n	x <- find (<5) xs\r\n\r\n	y <- find (>10) xs\r\n\r\n	z <- find (/=7) xs\r\n\r\n	return (x + y + z)\r\n','<br/>Тесты успешно пройдены!'),(8258,117,'Artur','2013-12-02 03:51:43',0,'','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(8259,117,'Artur','2013-12-02 03:52:02',0,'toInt g = g incr (0)\r\n\nincr x = x+1\r\n\n\r\n\ninc g = f x -> g (f x)\r\n\n\n','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(8260,117,'Artur','2013-12-02 03:52:22',1,'toInt g = g incr (0)\r\n\r\nincr x = x+1\r\n\r\n\r\n\r\ninc g = f x -> g (f x)\r\n\r\n\r\n','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(8261,122,'Artur','2013-12-02 03:54:45',2,'--- Я не уверен, что правильно вас понял, но вроде бы это совсем недописанная версия?\r\n--- Те все таки наверное не засчитано. Но если вы считаете, что ее надо засчитать - напишите, обсудим\r\n--- см некоторые замечания ниже \r\nfind cond (x:xs) = if cond x then (snd x) else find cond xs\r\n\r\n\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr | Call String Expr\r\n\r\n	deriving (Show,Eq)\r\n\r\n\r\n\r\n\r\n\r\neval (Num i) xs ys = i\r\n\r\neval (Var s ) xs ys = getValue s xs\r\n\r\neval (Add  expr1 expr2) xs ys = (eval expr1 xs) + (eval expr2 xs)\r\n\r\neval (Mult expr1 expr2) xs ys = (eval expr1 xs) * (eval expr2 xs)\r\n --- Тут при рекурсивных вызовах тоже дб ys\r\n\r\neval (Let s val expr) xs ys = eval expr ((s,val):xs)\r\n --- И тут тоже ys\r\n\r\neval (LetFunc f x expr1 expr2) xs ys = eval expr\r\n  --- Тут вообще непонятно, что имелось в виду\r\n\r\neval (Call f expr) = \r\n\r\n\r\n\r\ngetValue name env = head [v | (n, v) <- env, n == name]\r\n\r\ngetFunc func env \r\n\r\n\r\n','Не удалось вычислить выражение \"eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []\", проверьте правильность синтаксиса'),(8256,124,'bazhutin','2013-12-02 03:34:09',1,'downUp 1 = print 1\r\n\r\ndownUp n = do \r\n	print n\r\n	downUp (n-1) \r\n	print n\r\n','<br/>Тесты успешно пройдены!'),(8257,116,'Artur','2013-12-02 03:39:44',1,'\r\ntoInt g = g incr (0)\r\n\r\n\r\n\r\nincr x = x+1\r\n','<br/>Тесты успешно пройдены!'),(8255,112,'Artur','2013-12-02 03:18:21',1,'find cond (x:xs) = if cond x then (snd x) else find cond xs\r\n\r\n\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\n	deriving (Show,Eq)\r\n\r\n\r\n\r\n\r\n\r\neval (Num i) xs = i\r\n\r\neval (Var s ) xs = getValue s xs\r\n\r\neval (Add  expr1 expr2) xs = (eval expr1 xs) + (eval expr2 xs)\r\n\r\neval (Mult expr1 expr2) xs = (eval expr1 xs) * (eval expr2 xs)\r\n\r\neval (Let s val expr) xs = eval expr ((s,val):xs)\r\n\r\n\r\n\r\ngetValue name env = head [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8254,124,'ip','2013-12-02 03:17:39',1,'downUp 1 = print 1 \r\n\r\ndownUp n = do \r\n\r\n           print n\r\n\r\n           downUp (n-1)\r\n\r\n           print n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8253,124,'toskira','2013-12-02 03:17:05',1,'downUp n\r\n  | n > 0 = do pd n\r\n               pu n 2\r\n  | otherwise = return ()\r\n\r\npd 1 = do print 1\r\npd n = do print n\r\n          pd (n - 1)\r\n\r\npu n k\r\n  | n == k = do print k\r\n  | n > k = do print k\r\n               pu n (k + 1)\r\n  | otherwise = return ()\r\n','<br/>Тесты успешно пройдены!'),(8252,123,'ip','2013-12-02 03:08:15',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then (Just x) else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n x <- find (<5) xs\r\n\r\n y <- find (>10) xs\r\n\r\n z <- find (/=7) xs\r\n\r\n return (x+y+z)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8251,127,'Artur','2013-12-02 03:03:12',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n\r\n\r\nh >>>= g = xs -> let\r\n\r\n			(x, xs1) = h xs\r\n\r\n			(y, xs2) = (g x) xs1\r\n\r\n	in (y, xs2)\r\n\r\n\r\n\r\nf = find (>3) >>>= x -> find (>x)  \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8250,123,'toskira','2013-12-02 03:02:17',1,'find predicate [] = Nothing                                                         \r\nfind predicate (h:t) = if(predicate h)                                              \r\n                       then Just h                                                  \r\n                       else find predicate t                                        \r\n                                                                                    \r\nf l = do x <- find (<5) l                                                           \r\n         y <- find (>10) l                                                          \r\n         z <- find (/=7) l                                                          \r\n         return (x + y + z)','<br/>Тесты успешно пройдены!'),(8249,124,'Artur','2013-12-02 02:33:08',1,'pr 1 = print 1 \r\n\r\npr n = do\r\n\r\n		print n\r\n\r\n		pr (n-1)\r\n\r\n		print n\r\n','<br/>Тесты успешно пройдены!'),(8247,127,'3320654','2013-12-02 02:22:35',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>=)		:: ([a] -> (a, [a])) -> (a -> [a] -> (a, [a])) -> ([a] -> (a, [a]))\r\nf >>>= g	= list -> g (fst (f list)) (snd (f list))\r\n --- Просто как замечание, на самом деле тип функции более общий: [a] -> (b, [a]) и тд  \r\n\r\nf = find (>3) >>>= x -> find (>x) ','<br/>Тесты успешно пройдены!'),(8248,123,'Artur','2013-12-02 02:29:18',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\n\r\n\r\nf xs = do\r\n\r\n	x <- find (<5)   xs\r\n\r\n	y <- find (>10)  xs\r\n\r\n	z <- find (/= 7) xs\r\n\r\n	return (x + y + z)\r\n','<br/>Тесты успешно пройдены!'),(8246,124,'1990147','2013-12-02 02:01:38',1,'downUp 1 = print 1\r\n\r\ndownUp n = do \r\n\r\n	   print n\r\n\r\n           downUp (n-1) \r\n\r\n           print n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8243,124,'nomeansno','2013-12-02 01:58:44',1,'downUp n = downUp\' xn\r\n\r\n	where xn = reverse [1..n] ++ [2..n] \r\n\r\n\r\n\r\ndownUp\' [x] = print x \r\n\r\ndownUp\' (x:xs) = do\r\n\r\n	print x\r\n\r\n	downUp\' xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8244,123,'nomeansno','2013-12-02 01:58:52',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\nf s = do\r\n\r\n	x <- find (<5) s\r\n\r\n	y <- find (>10) s\r\n\r\n	z <- find (/=7) s\r\n\r\n	return (x+y+z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8245,112,'nomeansno','2013-12-02 02:00:35',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr deriving (Show, Eq)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ntovalue _ [] = 0\r\n\r\n\r\n\r\ntovalue var ((var\',val):xs) = if var == var\' then val else tovalue var xs\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\neval (Num i) = (\\_ -> i)\r\n\r\n\r\n\r\neval (Var var) = (vlist -> tovalue var vlist)\r\n\r\n\r\n\r\neval (Add e1 e2) = (vlist -> eval e1 vlist + eval e2 vlist)\r\n\r\n\r\n\r\neval (Mult e1 e2) = (vlist -> eval e1 vlist * eval e2 vlist)\r\n\r\n\r\n\r\neval (Let var value e) = (vlist -> eval e ((var,value):vlist))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8242,123,'1990147','2013-12-02 01:50:49',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs\r\n\r\n   return (x+y+z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8241,124,'nomeansno','2013-12-02 01:43:56',0,'downUp n = downUp\' xn\n\n	where xn = reverse [1..n] ++ [2..n] \n\n\n\ndownUp\' [x] = print x \n\ndownUp\' (x:xs) = do\n\n	print x\n\n	downUp\' xs\n\n\n','<br/>Тесты успешно пройдены!'),(8240,124,'nomeansno','2013-12-02 01:42:42',0,'downUp n = downUp\' xn\n\n	where xn = reverse [1..n] ++ [2..n] \n\n\n\ndownUp\' [x] = print x \n\ndownUp\' (x:xs) = do\n\n	print x\n\n	downUp\' xs\n\n\n','<br/>Тесты успешно пройдены!'),(8239,123,'nomeansno','2013-12-02 01:41:27',0,'find cond [] = Nothing\n\nfind cond (x:xs) = if cond x then Just x else find cond xs\n\nf s = do\n\n	x <- find (<5) s\n\n	y <- find (>10) s\n\n	z <- find (/=7) s\n\n	return (x+y+z)\n\n\n','<br/>Тесты успешно пройдены!'),(8238,127,'nomeansno','2013-12-02 01:40:43',1,'f1 >>>= f2 = s -> let (x,xs) = f1 s in f2 x xs\r\n...\r\nlet f = find (>3) >>>= (x -> find (>x))','<br/>Тесты успешно пройдены!'),(8237,121,'8519021','2013-12-02 01:16:22',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace Fact_cps\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int Fact_cps(int n, Func<int, int> f)\r\n\r\n        {\r\n\r\n            if (n == 0)\r\n\r\n                return f(1);\r\n\r\n\r\n\r\n            return Fact_cps((n-1), (t => f(t*n)));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine(Fact_cps(5, t => t));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8236,122,'artem.gomerman','2013-12-02 00:01:58',1,'data Expr = Num Integer | Var String | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ngetValue name vars = head [v | (n, v) <- vars, n == name]\r\n\r\n\r\n\r\ncalculateFunction (argument, behavior) expr = eval behavior [(argument, (eval expr [] []))] []\r\n\r\n\r\n\r\neval (Num a) _ _ = a\r\n\r\neval (Var x) vars functions = getValue x vars\r\n\r\neval (Add expr1 expr2) vars functions = (eval expr1 vars functions) + (eval expr2 vars functions)\r\n\r\neval (Mult expr1 expr2) vars functions = (eval expr1 vars functions) * (eval expr2 vars functions)\r\n\r\neval (Let name val expr) vars functions = eval expr ((name, val):vars) functions\r\n\r\neval (LetFunc functionName argument behavior expr) vars functions = eval expr vars ((functionName, (argument, behavior)):functions)\r\n\r\neval (Call functionName expr) vars functions = calculateFunction (getValue functionName functions) expr\r\n','<br/>Тесты успешно пройдены!'),(8235,112,'artem.gomerman','2013-12-01 23:15:16',1,'data Expr = Num Integer | Var String | Let String Integer Expr | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ngetValue name vars = head [v | (n, v) <- vars, n == name] \r\n\r\n\r\n\r\neval (Num a) _ = a\r\n\r\neval (Var x) vars = getValue x vars\r\n\r\neval (Add expr1 expr2) vars = (eval expr1 vars) + (eval expr2 vars)\r\n\r\neval (Mult expr1 expr2) vars = (eval expr1 vars) * (eval expr2 vars)\r\n\r\neval (Let name val expr) vars = eval expr ((name, val):vars)\r\n','<br/>Тесты успешно пройдены!'),(8233,117,'anna','2013-12-01 22:21:13',1,'toInt churchNum = churchNum (+1) 0\r\ninc churchNum = f x -> f (churchNum f x)','<br/>Тесты успешно пройдены!'),(8234,98,'SNNatalieS','2013-12-01 22:59:50',2,'--- toStr у вас не совсем по условию, там надо было обязательно использовать прием который в 11 слайдах мы разбирали на примере flatten\r\n--- Попробуйте так сделать, пожалуйста\r\ndata Tree = Empty | Node Char Tree Tree\r\n              deriving Show\r\n\r\ntoStr (Empty) = \"e\"\r\ntoStr (Node c l r) = [\'n\', c] ++ (toStr l) ++ (toStr r)\r\n\r\nfromStr tree = let (tr, x) = df tree\r\n				in tr\r\n\r\ndf str = if(head(str) == \'n\')\r\n         then let (l, xs) = df (tail(tail(str)))\r\n                  (r, ys) = df xs\r\n              in (Node (head(tail(str))) l r, ys)\r\n         else (Empty, tail(str))','<br/>Тесты успешно пройдены!'),(8232,116,'anna','2013-12-01 22:17:45',1,'toInt churchNum = churchNum (+1) 0','<br/>Тесты успешно пройдены!'),(8230,116,'SNNatalieS','2013-12-01 21:56:01',1,'toInt f = f(+1) 0','<br/>Тесты успешно пройдены!'),(8231,117,'SNNatalieS','2013-12-01 22:17:29',1,'toInt f = f(+1) 0\r\ninc t = (f x -> f(t f x))','<br/>Тесты успешно пройдены!'),(8229,127,'6053606','2013-12-01 21:53:19',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf >>>= g = xs -> (uncurry g) $ f xs\r\n\r\nf = find (>3) >>>= x -> find (>x)\r\n','<br/>Тесты успешно пройдены!'),(8228,118,'6053606','2013-12-01 21:43:39',2,'--- Это, к сожалению, прислано очень сильно после срока сдачи\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\nf >>> g = xs -> g . snd $ f xs\r\n','<br/>Тесты успешно пройдены!'),(8226,127,'8519021','2013-12-01 21:32:18',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>=) f1 f2 xs = let (x, ys) = f1 xs in ((f2 x) ys)\r\n\r\n	\r\n\r\nf = find (>3) >>>= (x -> find (>x))\r\n','<br/>Тесты успешно пройдены!'),(8227,118,'6053606','2013-12-01 21:41:50',0,'f >>> g = xs -> g . snd $ f xs','Не удалось вычислить выражение \"let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]\", проверьте правильность синтаксиса'),(8225,106,'480387','2013-12-01 21:29:15',1,'h ls = f (h\' [] ls 0 0 1) ls\r\nh\' ps [] candidate  test i = (candidate,  i-1, test)\r\nh\' ps (l:ls) candidate  test i = \r\n									if test == 0\r\n									then h\' (ps++[l]) ls  l (test+1) (i+1)\r\n									else \r\n										if l == candidate\r\n											then h\' (ps++[l]) ls candidate (test+1) (i+1)\r\n											else h\' (ps++[l]) ls candidate (test-1) (i+1)\r\nf (c, n, test) ls = if test>0 && 2*(count\' ls c 0)>n then Just c else Nothing\r\ncount\' [] c k = k\r\ncount\' (l:ls) c k = count\' ls c (k + (if l==c then 1 else 0))\r\nfindMajor = h','<br/>Тесты успешно пройдены!'),(8224,106,'480387','2013-12-01 21:28:45',0,'h ls = f (h\' [] ls 0 0 1) ls\r\nh\' ps [] candidate  test i = (candidate,  i-1, test)\r\nh\' ps (l:ls) candidate  test i = \r\n									if test == 0\r\n									then h\' (ps++[l]) ls  l (test+1) (i+1)\r\n									else \r\n										if l == candidate\r\n											then h\' (ps++[l]) ls candidate (test+1) (i+1)\r\n											else h\' (ps++[l]) ls candidate (test-1) (i+1)\r\nf (c, n, test) ls = if test>0 && 2*(count\' ls c 0)>n then Just c else Nothing\r\ncount\' [] c k = k\r\ncount\' (l:ls) c k = count\' ls c (k + (if l==c then 1 else 0))\r\nfindMajir = h','Не удалось вычислить выражение \"findMajor [1,2,3,2,2,2,1]\", проверьте правильность синтаксиса'),(8223,122,'6053606','2013-12-01 21:26:23',1,'data Expr = Var String\r\n          | Num Int\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n          | Let String Int Expr\r\n          | LetFunc String String Expr Expr\r\n          | Call String Expr\r\n          deriving Show\r\n\r\neval :: Expr -> [(String, Int)] -> [(String, (String, Expr))]-> Int\r\neval e ctxv ctxf = go e  where\r\n  go (Var v) = case lookup v ctxv of\r\n    Just x -> x\r\n    Nothing -> undefined\r\n  go (Num x) = x\r\n  go (Add e1 e2) = go e1 + go e2\r\n  go (Mult e1 e2)  = go e1  * go e2\r\n  go (Let v x body)  = eval body ((v, x):ctxv) ctxf\r\n  go (LetFunc f v body scope) =\r\n    eval scope ctxv ((f, (v, body)):ctxf)\r\n  go (Call f e) = case lookup f ctxf of\r\n    Just (v, body) -> eval (Let v (go e) body) ctxv ctxf\r\n    Nothing -> undefined\r\n','<br/>Тесты успешно пройдены!'),(8222,112,'6053606','2013-12-01 21:03:12',1,'data Expr = Var String\r\n          | Num Int\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n          | Let String Int Expr\r\n          deriving Show\r\n\r\neval :: Expr -> [(String, Int)] -> Int\r\neval e ctx = go e where\r\n  go (Var v) = case lookup v ctx of\r\n    Just x -> x\r\n    Nothing -> 42\r\n  go (Num x) = x\r\n  go (Add e1 e2) = go e1 + go e2\r\n  go (Mult e1 e2) = go e1 * go e2\r\n  go (Let v x body) = eval body ((v, x):ctx)\r\n','<br/>Тесты успешно пройдены!'),(8220,124,'6053606','2013-12-01 20:35:55',1,'downUp n = do\r\n    countDown n\r\n    countUp 1\r\n  where\r\n    countDown 1 = return ()\r\n    countDown i = do\r\n      print i\r\n      countDown (pred i)\r\n    countUp i = if i == n + 1\r\n                then return ()\r\n                else do\r\n                  print i\r\n                  countUp (succ i)\r\n','<br/>Тесты успешно пройдены!'),(8221,111,'6053606','2013-12-01 20:49:01',2,'--- Это, к сожалению, прислано очень сильно после срока сдачи\r\n\r\ndata Expr = Var String\r\n          | Num Int\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n          deriving Show\r\n\r\neval :: Expr -> [(String, Int)] -> Int\r\neval e ctx = go e where\r\n  go (Var v) = case lookup v ctx of\r\n    Just x -> x\r\n    Nothing -> 42\r\n  go (Num x) = x\r\n  go (Add e1 e2) = go e1 + go e2\r\n  go (Mult e1 e2) = go e1 * go e2\r\n','<br/>Тесты успешно пройдены!'),(8218,123,'6053606','2013-12-01 20:20:14',1,'find :: (a -> Bool) -> [a] -> Maybe a\r\nfind p = go where\r\n  go [] = Nothing\r\n  go (x:xs) = if p x then Just x else go xs\r\n\r\nf xs = do\r\n  a <- find (< 5) xs\r\n  b <- find (> 10) xs\r\n  c <- find (/= 7) xs\r\n  return $ a + b + c\r\n','<br/>Тесты успешно пройдены!'),(8219,127,'3301494','2013-12-01 20:22:03',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\na >>>= b = xs -> (let (x,z) = a xs in let y = b x xs in y)\r\n\r\nf = find (>3) >>>= x -> find (>x) \r\n','<br/>Тесты успешно пройдены!'),(8217,124,'3301494','2013-12-01 20:18:07',1,'downUp n = f (g n) n\r\n\r\ng n = (reverse [1..n])++(tail [1..(n-1)])\r\n\r\nf [] n = print n\r\n\r\nf (x:xs) n = do \r\n\r\n				print x\r\n\r\n				f xs n\r\n','<br/>Тесты успешно пройдены!'),(8216,117,'5247795','2013-12-01 20:17:38',1,'toInt e = e (+1) 0\r\n\r\ninc e = f x -> f (e f x)\r\n','<br/>Тесты успешно пройдены!'),(8215,117,'5247795','2013-12-01 20:17:10',0,'','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(8213,117,'8519021','2013-12-01 20:07:30',1,'toInt churchNumerals = churchNumerals (+1) 0\r\n\r\n\r\n\r\ninc churchNumerals = (f x -> f (churchNumerals f x))\r\n','<br/>Тесты успешно пройдены!'),(8214,116,'5247795','2013-12-01 20:12:12',1,'toInt f = f (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(8212,116,'8519021','2013-12-01 20:06:56',1,'toInt churchNumerals = churchNumerals (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(8211,116,'5247795','2013-12-01 20:06:55',0,'toInt f = f (+1) 0\n','Не удалось вычислить выражение \"let c3 f x = f (f (f x)) in toInt c3\", проверьте правильность синтаксиса'),(8210,123,'3301494','2013-12-01 20:05:29',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\nf xs = do\r\n\r\n		   x <- find (<5) xs\r\n\r\n		   y <- find (>10) xs\r\n\r\n		   z <- find (/=7) xs\r\n\r\n		   return (x + y + z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8206,112,'5247795','2013-12-01 19:44:03',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\neval (Var x) ((y, n):xs) = if (y == x) then n else (eval (Var x) xs)\r\n\r\neval (Num n) _ = n \r\n\r\neval (Add s1 s2) xs = (eval s1 xs) + (eval s2 xs)\r\n\r\neval (Mult m1 m2) xs = (eval m1 xs) * (eval m2 xs)\r\n\r\neval (Let x n exp) xs = eval exp ((x, n) : xs)\r\n','<br/>Тесты успешно пройдены!'),(8207,124,'SNNatalieS','2013-12-01 19:44:52',1,'pr 1 = print 1\r\n	   	\r\npr n = do \r\n		print n \r\n		pr (n-1)\r\n			\r\npr1 n 0 = do \r\n            print n\r\npr1 n k = do\r\n			print (n - k) \r\n			pr1 n (k - 1)\r\n\r\ndownUp n = do\r\n             pr n\r\n             pr1 n (n - 2)','<br/>Тесты успешно пройдены!'),(8208,112,'3301494','2013-12-01 19:48:30',1,'data Expr = Num Integer | Let String Integer Expr | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nf cond ((x,y):xs) = if cond x then y else f cond xs\r\n\r\neval (Let x y expr) xs = eval expr ((x, y):xs)\r\n\r\neval (Num i) xs = i\r\n\r\neval (Var x) xs = f (==x) xs \r\n\r\neval (Add x y) xs = (eval x xs) + (eval y xs)\r\n\r\neval (Mult x y) xs = (eval x xs) * (eval y xs)\r\n','<br/>Тесты успешно пройдены!'),(8209,122,'3301494','2013-12-01 20:02:03',1,'data Expr = Num Integer | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nf cond ((x,y):xs) = if cond x then y else f cond xs\r\n\r\naddVariable name expr xs ys = let value = eval expr xs ys in ((name, value):xs)\r\n\r\neval (Let x y expr) xs ys = eval expr ((x, y):xs) ys\r\n\r\neval (LetFunc name x body continuation) xs ys = eval continuation xs ((name, (x, body)):ys)  \r\n\r\neval (Num i) xs ys = i\r\n\r\neval (Var x) xs ys = f (==x) xs \r\n\r\neval (Call func argValue) xs ys = let (name, body) = (f (==func) ys) in let xs\' = addVariable name argValue xs ys in eval body xs\' ys \r\n\r\neval (Add x y) xs ys = (eval x xs ys) + (eval y xs ys)\r\n\r\neval (Mult x y) xs ys = (eval x xs ys) * (eval y xs ys)\r\n','<br/>Тесты успешно пройдены!'),(8205,117,'3301494','2013-12-01 19:43:51',1,'toInt l = l (x -> x + 1) 0\r\n\r\n\r\n\r\ninc l = f x -> l f (f x)\r\n','<br/>Тесты успешно пройдены!'),(8204,116,'3301494','2013-12-01 19:42:36',1,'toInt l = l (x -> x + 1) 0\r\n','<br/>Тесты успешно пройдены!'),(8202,98,'3301494','2013-12-01 19:40:27',1,'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\nf Empty = (\'e\':)\r\n\r\nf (Node x l r) = (\'n\':).(x:).f l.f r\r\n\r\n\r\n\r\ntoStr tree = (f tree) \"\"\r\n\r\n\r\n\r\ng (\'e\':xs) = (Empty, xs)\r\n\r\ng (\'n\':xs) = let temp = g(tail xs) in let l = fst temp in let rTemp = g (snd temp) in let r = fst rTemp in let t = snd rTemp in ((Node (head xs) l r), t)   \r\n\r\n\r\n\r\nfromStr xs = fst (g xs)\r\n','<br/>Тесты успешно пройдены!'),(8203,117,'3301494','2013-12-01 19:41:47',0,'toInt l = l (x -> x + 1) 0\n','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(8201,122,'8519021','2013-12-01 19:17:23',1,'data Expr = Num Integer | Var String | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ngetValue name envX = head [v | (n, v) <- envX, n == name] \r\n\r\ngetArgF name envF = head [a | (n, a, v) <- envF, n == name] \r\n\r\ngetValF name envF = head [v | (n, a, v) <- envF, n == name] \r\n\r\n\r\n\r\neval (Var name) envX _ = getValue name envX\r\n\r\neval (Num z) _ _ = z \r\n\r\neval (Add x y) envX envF = eval x envX envF + eval y envX envF\r\n\r\neval (Mult x y) envX envF = eval x envX envF * eval y envX envF\r\n\r\neval (Let name value expr) envX envF = eval expr ((name, value) : envX) envF\r\n\r\neval (Call f expr) envX envF = eval (getValF f envF) (((getArgF f envF), eval expr envX envF) : envX) envF\r\n\r\neval (LetFunc f arg val expr) envX envF = eval expr envX ((f, arg, val) : envF)\r\n','<br/>Тесты успешно пройдены!'),(8200,123,'SNNatalieS','2013-12-01 18:52:44',1,'find cond [] = Nothing\r\nfind cond (x:xs) = if (cond x) then Just x\r\n					else find cond xs\r\n					\r\nf xs = do  \r\n		x <- find (<5) xs\r\n		y <- find (>10) xs\r\n		z <- find (/=7) xs\r\n		return (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(8199,112,'8519021','2013-12-01 18:13:44',1,'data Expr = Num Integer | Var String | Let String Integer Expr | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ngetValue name env = head [v | (n, v) <- env, n == name] \r\n\r\n\r\n\r\neval (Var name) env = getValue name env\r\n\r\neval (Num z) _ = z \r\n\r\neval (Add x y) env = eval x env + eval y env\r\n\r\neval (Mult x y) env = eval x env * eval y env\r\n\r\neval (Let name value expr) env = eval expr ((name, value) : env) \r\n','<br/>Тесты успешно пройдены!'),(8197,117,'617015','2013-12-01 17:27:31',1,'toInt func  =  func (x-> x+1) 0  \r\n\r\n\r\n\r\ninc func = (f x -> f (func f x) )\r\n','<br/>Тесты успешно пройдены!'),(8198,117,'artem.gomerman','2013-12-01 17:33:34',1,'toInt churchNum = churchNum (x -> x + 1) 0\r\n\r\n\r\n\r\ninc churchNum = f x -> churchNum f (f x)\r\n','<br/>Тесты успешно пройдены!'),(8196,116,'artem.gomerman','2013-12-01 17:16:55',1,'toInt churchNum = churchNum (x -> x + 1) 0\r\n','<br/>Тесты успешно пройдены!'),(8193,127,'artem.gomerman','2013-12-01 17:09:06',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nf >>>= g = xs -> let\r\n\r\n	(x, xs1) = f xs\r\n\r\n	(y, xs2) = (g x) xs1\r\n\r\n	in (y, xs2)\r\n\r\n	\r\n\r\nf = find (>3) >>>= x -> find (>x)\r\n','<br/>Тесты успешно пройдены!'),(8194,124,'5247795','2013-12-01 17:09:27',1,'downUp n = downUp\' n n False\r\n\r\ndownUp\' n 1 True = print n\r\n\r\ndownUp\' n k True = do\r\n\r\n	print n\r\n\r\n	downUp\' (n+1) (k-1) True\r\n\r\ndownUp\' n k False = do\r\n\r\n	print n\r\n\r\n	if n/=1 then downUp\' (n-1) k False else downUp\' (n+1) (k-1) True\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8195,116,'617015','2013-12-01 17:11:48',1,'toInt func  =  func (x-> x+1) 0  \r\n','<br/>Тесты успешно пройдены!'),(8192,123,'5247795','2013-12-01 17:09:01',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n	x <- find (<5) xs\r\n\r\n	y <- find (>10) xs\r\n\r\n	z <- find (/=7) xs\r\n\r\n	return (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(8191,124,'artem.gomerman','2013-12-01 16:45:53',1,'downUp n = down n n\r\n\r\n\r\n\r\nup x n = if x == n then print n else do\r\n\r\n	print x\r\n\r\n	up (x + 1) n\r\n\r\n\r\n\r\ndown 1 n = up 1 n\r\n\r\ndown x n = do\r\n\r\n	print x\r\n\r\n	down (x - 1) n\r\n','<br/>Тесты успешно пройдены!'),(8189,117,'6053606','2013-12-01 16:22:51',1,'toInt n = n (+ 1) 0\r\n\r\ninc n = f x -> n f $ f x\r\n','<br/>Тесты успешно пройдены!'),(8190,123,'artem.gomerman','2013-12-01 16:32:49',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n	x <- find (<5) xs\r\n\r\n	y <- find (>10) xs\r\n\r\n	z <- find (/=7) xs\r\n\r\n	return (x + y + z)\r\n','<br/>Тесты успешно пройдены!'),(8188,116,'6053606','2013-12-01 16:19:10',1,'toInt n = n (+ 1) 0','<br/>Тесты успешно пройдены!'),(8187,117,'62628590','2013-12-01 15:28:15',1,'toInt n = n (+1) 0\r\ninc n = f x -> f (n f x)','<br/>Тесты успешно пройдены!'),(8186,116,'62628590','2013-12-01 15:27:26',1,'toInt n = n (+1) 0','<br/>Тесты успешно пройдены!'),(8184,124,'62628590','2013-12-01 15:10:12',1,'pr n 0 = print (n*(-1))\r\npr n k = do\r\n	print (abs n)\r\n	if n/=1 then pr (n-1) (k-1) else pr (n-2) (k-2)\r\n\r\ndownUp n = pr n (2*n)','<br/>Тесты успешно пройдены!'),(8185,112,'62628590','2013-12-01 15:27:02',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\ngetValue [] _ = 0\r\n\r\neval (Var x) vars = getValue vars x\r\neval (Num n) _ = n\r\neval (Add a b) n = eval a n + eval b n\r\neval (Mult a b) n = eval a n * eval b n\r\neval (Let x val e) vars = eval e ((x, val) : vars)','<br/>Тесты успешно пройдены!'),(8183,123,'62628590','2013-12-01 13:41:01',1,'find cond [] = Nothing\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\nf xs = do\r\n	x <- find (<5) xs\r\n	y <- find (>10) xs\r\n	z <- find (/=7) xs\r\n	return (x+y+z)','<br/>Тесты успешно пройдены!'),(8182,123,'115753099','2013-12-01 13:36:40',1,'find cond [] = Nothing\r\nfind cond (x:xs) = \r\n	if cond x \r\n	then Just x\r\n	else find cond xs\r\n\r\nf xs =\r\n	do\r\n		x <- find (< 5) xs\r\n		y <- find (> 10) xs\r\n		z <- find (/= 7) xs\r\n		fmap sum $ sequence [x, y, z]\r\n  --- Засчитано но это не совсем то. Тут нужен просто return суммы ','Не удалось вычислить выражение \"f [7, 6, 4, 3, 20, 15, 9] \", проверьте правильность синтаксиса'),(8180,116,'nbumakov','2013-12-01 10:16:29',1,'toInt ch = ch (+1) 0','<br/>Тесты успешно пройдены!'),(8181,117,'nbumakov','2013-12-01 11:56:07',1,'toInt ch = ch (+1) 0\r\n\r\n{-- inc ch =  f x -> f (ch f x) --}\r\ninc ch f x = f (ch f x)','<br/>Тесты успешно пройдены!'),(8179,112,'nbumakov','2013-12-01 10:04:34',1,'data Expr = Var String | Num Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\r\nvalue vs x = snd (head (filter (v -> fst v == x) vs))\r\nvalue [] _ = 0\r\n\r\neval (Num n) _ = n\r\neval (Var x) vs = value vs x\r\neval (Add s1 s2) vs = eval s1 vs + eval s2 vs\r\neval (Mult m1 m2) vs = eval m1 vs * eval m2 vs\r\neval (Let x v e) vs = eval e ((x, v) : vs)','<br/>Тесты успешно пройдены!'),(8178,121,'nomeansno','2013-12-01 02:50:48',1,'#include <iostream>\r\n\r\n#include <functional>\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\ntypedef std::function<double(double)> FuncType;\r\n\r\n\r\n\r\ndouble fact_cps(int n, FuncType f) {\r\n\r\n    if (n==0)\r\n\r\n        return f(1);\r\n\r\n    return fact_cps(n-1, [n, &f] (int x) {\r\n\r\n        return f(x*n);\r\n\r\n    });\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n    std::cout << fact_cps(2, [] (double x) {\r\n\r\n        return sin(M_PI/x);\r\n\r\n    });\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8177,117,'nomeansno','2013-12-01 01:32:54',1,'toInt ch_num = ch_num (+1) 0\r\ninc ch_num = (f x -> f (ch_num f x))','<br/>Тесты успешно пройдены!'),(8176,117,'nomeansno','2013-12-01 01:26:30',0,'toInt ch_num = ch_num (+1) 0\r\ninc ch_num = (f x -> f (ch_num f x))','<br/>Тесты успешно пройдены!'),(8175,117,'3320654','2013-12-01 01:22:28',1,'toInt fx = fx (+1) 0\r\n\r\ninc fx = f x -> f (fx f x)','<br/>Тесты успешно пройдены!'),(8173,116,'nomeansno','2013-12-01 01:12:06',1,'toInt ch_num = ch_num (+1) 0','<br/>Тесты успешно пройдены!'),(8174,116,'3320654','2013-12-01 01:21:45',1,'toInt fx = fx (+1) 0','<br/>Тесты успешно пройдены!'),(8172,124,'8519021','2013-12-01 01:11:11',1,'downUp n = downUp\' n []\r\n\r\n\r\n\r\ndownUp\' 0 (x:xs) = mapM print xs\r\n\r\ndownUp\' n xs = do \r\n\r\n	print n\r\n\r\n    	downUp\' (n-1) (n:xs)\r\n','<br/>Тесты успешно пройдены!'),(8171,112,'3320654','2013-12-01 01:07:09',1,'data Expr = Num Integer | Let String Integer Expr | Var String | Add Expr Expr | Mult Expr Expr \r\n		deriving (Show, Eq)\r\n\r\neval (Num t) _	= t\r\neval (Let z t x) list	= eval x ((z,t):list)\r\neval (Var z) list	= getVar z list\r\neval (Add x y) list	= eval x list + eval y list\r\neval (Mult x y) list	= eval x list * eval y list\r\n\r\ngetVar _ []		= 0\r\ngetVar z (x:xs) 	= if (fst x) == z\r\n		   then snd x\r\n		   else getVar z xs','<br/>Тесты успешно пройдены!'),(8170,124,'3320654','2013-12-01 00:50:52',1,'downUp 1	= do\r\n		print 1\r\n   --- Тут do писать не надо\r\ndownUp n 	= do\r\n		print n\r\n		downUp (n - 1)\r\n		print n','<br/>Тесты успешно пройдены!'),(8168,97,'480387','2013-12-01 00:03:28',2,'--- пустой текст - это вы случайно послали? А у вас было решение этой задачи, я не помню? Если было, выложите его еще раз, пожалуйста','Не удалось вычислить выражение \"checkBrackets [\'(\',\'[\',\']\',\')\']\", проверьте правильность синтаксиса'),(8169,123,'3320654','2013-12-01 00:45:52',1,'find _ [] 		= Nothing\r\nfind cond (x:xs)	= if cond x\r\n		   then Just x\r\n		   else find cond xs\r\n\r\nf list = do\r\n	x <- find (< 5) list\r\n	y <- find (> 10) list\r\n	z <- find (/= 7) list\r\n	return (x + y + z)','<br/>Тесты успешно пройдены!'),(8167,119,'55363692','2013-11-30 23:49:32',2,'--- Вообще идея хорошая (и примерно та же, что у Клини)\r\n--- Но это не совсем корректно Потому что вы используете ==, и значит функция\r\n--- (число Черча) которое получится в результате, будет работать только с теми параметрами\r\n--- для которых определено ==\r\n--- Вот тест, на котором видна проблема:\r\n\r\nch3 = f x -> f(f(f x))\r\nch2 = dec ch3\r\n  --- получаем число Черча для 2\r\n\r\ndbl f = f . f\r\n\r\ntestFunc = ch2 dbl (*2)\r\n  --- но если мы пытаемся вызвать ch2 c параметрами для которых не задано == (например для функций)\r\n  --- то получаем ошибку\r\ntest = testFunc 2\r\n\r\ntoInt g = g (x -> x + 1) 0\r\n\r\n\r\n\r\ndec g f x = let \r\n\r\n	res = g f x\r\n\r\n	find cur = if f cur == res then cur else find (f cur)\r\n\r\n	in find x\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8166,124,'nbumakov','2013-11-30 22:48:39',1,'downUp 1 = print 1   \r\ndownUp n = do print n \r\n              downUp (n-1)\r\n              print n ','<br/>Тесты успешно пройдены!'),(8165,123,'nbumakov','2013-11-30 22:45:13',1,'find cond [] = Nothing\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\nf xs = do\r\n   x <- find (<5) xs\r\n   y <- find (>10) xs\r\n   z <- find (/=7) xs\r\n   return (x+y+z)','<br/>Тесты успешно пройдены!'),(8164,120,'115753099','2013-11-30 20:16:13',1,'import Data.List\r\n\r\ndata Logic = LL Logic Logic | C Char\r\n\r\n\r\n\r\ngetParams (C x) xs =\r\n\r\n	if elem x xs then xs\r\n\r\n	else x:xs\r\n\r\ngetParams (LL l1 l2) xs =\r\n\r\n	getParams l2 ys\r\n\r\n	where\r\n\r\n		ys = getParams l1 xs\r\n\r\n\r\n\r\nisTautology l =\r\n\r\n	isTautology2 l xs\r\n\r\n	where xs = getParams l []\r\n\r\n\r\n\r\nisTautology2 l [] = isTrue l []\r\n\r\nisTautology2 l xs =\r\n\r\n	fst $ mapAccumL (acc ys -> (acc && isTrue l ys, ys)) True (powerset xs)\r\n\r\n\r\n\r\nisTrue (C x) xs =\r\n\r\n	elem x xs\r\n\r\nisTrue (LL l1 l2) xs\r\n\r\n	| b1 == False = True\r\n\r\n	| b1 == True && b2 == True = True\r\n\r\n	| otherwise = False\r\n\r\n	where\r\n\r\n		b1 = isTrue l1 xs\r\n\r\n		b2 = isTrue l2 xs\r\n\r\n\r\n\r\n---powerset\r\n\r\npowerset2 [] = []\r\n\r\npowerset2 (x:xs) =\r\n\r\n	(map (y -> x:y) (powerset2 xs)) ++  ([x] : powerset2(xs))\r\n\r\n\r\n\r\npowerset xs = [] : (powerset2 xs)\r\n\r\n\r\n\r\n---examples\r\n\r\nexaples =\r\n\r\n	isTautology (LL (C \'a\') (C \'a\')) &&\r\n\r\n	isTautology (LL (LL (C \'a\') (C \'b\')) (LL (LL (C \'b\') (C \'c\')) (LL (C \'a\') (C \'c\')))) &&\r\n\r\n	(not $ isTautology (LL (LL (C \'a\') (C \'b\')) (LL (C \'b\') (C \'a\')))) &&\r\n\r\n	(not $ isTautology (LL (LL (LL (C \'a\') (C \'b\')) ( C \'c\')) (C \'d\')))\r\n','<br/>Тесты успешно пройдены!'),(8163,121,'artem.gomerman','2013-11-30 18:37:16',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    static private int fact_cps(int n, Func<int, int> f)\r\n\r\n    {\r\n\r\n        if (n == 0)\r\n\r\n            return f(1);\r\n\r\n        return fact_cps(n - 1, x => n * f(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Console.Write(\"Testing fact_cps\r\nInput for factorial computation:\");\r\n\r\n        int value = int.Parse(Console.ReadLine());\r\n\r\n        Console.Write(\"Factorial value: {0}\r\n\", fact_cps(value, x => x));\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(8162,98,'artem.gomerman','2013-11-30 18:22:57',1,'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr tree = toStr\' tree \"\"\r\n\r\ntoStr\' Empty = (\'e\':)\r\n\r\ntoStr\' (Node c l r) = (\'n\':).(c:).toStr\' l.toStr\' r\r\n\r\n\r\n\r\nfromStr str = fst (fromStr\' str)\r\n\r\nfromStr\' (\'n\':c:str) = let\r\n\r\n	(l, str1) = fromStr\' str\r\n\r\n	(r, str2) = fromStr\' str1 in (Node c l r, str2)\r\n\r\nfromStr\' (\'e\':str) = (Empty, str)\r\n\r\nfromStr\' (c:str) = (Node c Empty Empty, str)\r\n','<br/>Тесты успешно пройдены!'),(8161,107,'artem.gomerman','2013-11-30 17:41:50',1,'data LogExpr = T | F | X | Not LogExpr | Or LogExpr LogExpr | And LogExpr LogExpr deriving Show\r\n\r\n\r\n\r\ntoFunction T = const True\r\n\r\ntoFunction F = const False\r\n\r\ntoFunction X = id\r\n\r\ntoFunction (Not expr) = not.(toFunction expr)\r\n\r\ntoFunction (Or expr1 expr2) = x -> (||) ((toFunction expr1) x) ((toFunction expr2) x)\r\n\r\ntoFunction (And expr1 expr2) = x -> (&&) ((toFunction expr1) x) ((toFunction expr2) x)\r\n\r\n\r\n\r\nf = toFunction (And X X)\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	expr1 == expr2 = let\r\n\r\n		f1 = toFunction expr1\r\n\r\n		f2 = toFunction expr2 in f1 True == f2 True && f1 False == f2 False\r\n','<br/>Тесты успешно пройдены!'),(8160,117,'3270666','2013-11-30 17:18:34',1,'toInt church = church (+1) 0\r\n\r\ninc church f = church f . f','<br/>Тесты успешно пройдены!'),(8159,119,'115753099','2013-11-30 15:30:11',1,'--dec num =\r\n--	f x -> snd $ num ((a, _) -> (f a, a)) (x, x)\r\ntoInt f = f (+1) 0\r\n\r\ntrue = 	 f -> t\r\nfalse = 	 f -> f\r\npair =  f s b -> b f s\r\nfirst = p -> p true\r\nsecond = p -> p false\r\nplus = m n s z -> m s (n s z)\r\nc0 = f x -> x\r\nc1 = f x -> f x\r\nzz = pair c0 c0\r\nss = p -> pair (second p) (plus c1 (second p))\r\ndec = m -> first (m ss zz)','<br/>Тесты успешно пройдены!'),(8158,119,'115753099','2013-11-30 15:29:58',0,'--dec num =\r\n--	f x -> snd $ num ((a, _) -> (f a, a)) (x, x)\r\ntoInt f = f (+1) 0\r\n\r\ntrue = 	 f -> t\r\nfalse = 	 f -> f\r\npair =  f s b -> b f s\r\nfirst = p -> p true\r\nsecond = p -> p false\r\nplus = m n s z -> m s (n s z)\r\nc0 = f x -> x\r\nc1 = f x -> f x\r\nzz = pair c0 c0\r\nss = p -> pair (second p) (plus c1 (second p))\r\ndec2 = m -> first (m ss zz)','Не удалось вычислить выражение \"let three f x = f (f (f x)) in toInt (dec three)\", проверьте правильность синтаксиса'),(8157,119,'115753099','2013-11-30 15:28:53',0,'--dec num =\r\n--	f x -> snd $ num ((a, _) -> (f a, a)) (x, x)\r\n\r\ntrue = 	 f -> t\r\nfalse = 	 f -> f\r\npair =  f s b -> b f s\r\nfirst = p -> p true\r\nsecond = p -> p false\r\nplus = m n s z -> m s (n s z)\r\nc0 = f x -> x\r\nc1 = f x -> f x\r\nzz = pair c0 c0\r\nss = p -> pair (second p) (plus c1 (second p))\r\ndec = m -> first (m ss zz)','Не удалось вычислить выражение \"let three f x = f (f (f x)) in toInt (dec three)\", проверьте правильность синтаксиса'),(8153,123,'anna','2013-11-30 13:53:01',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs\r\n\r\n   return (x+y+z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8154,116,'55363692','2013-11-30 14:17:19',1,'toInt f = f (x -> x + 1) 0\r\n','<br/>Тесты успешно пройдены!'),(8155,117,'55363692','2013-11-30 14:25:23',1,'toInt f = f (x -> x + 1) 0\r\n\r\n\r\n\r\ninc g f = f . (g f)\r\n','<br/>Тесты успешно пройдены!'),(8156,98,'284427','2013-11-30 15:12:23',1,'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr t = toStr1 t []\r\n\r\ntoStr1 Empty = (\"e\"++)\r\n\r\ntoStr1 (Node str l r) = ((\"n\"++[str])++) . toStr1 l . toStr1 r\r\n\r\n\r\n\r\nfromStr [] = Empty\r\n\r\nfromStr xs = let (res, tree) = (fromStr1 xs) in res\r\n\r\nfromStr1 (x:xs)   \r\n\r\n	| x == \'e\' = (Empty, xs)\r\n\r\n	| otherwise = \r\n\r\n		let \r\n\r\n			(y:ys) = xs\r\n\r\n			(l,rs1) = fromStr1 ys\r\n\r\n			(r,rs2) = fromStr1 rs1\r\n\r\n		in (Node y l r, rs2)\r\n','<br/>Тесты успешно пройдены!'),(8152,107,'3320654','2013-11-30 05:09:26',1,'data LogExpr = T | F | X | Not LogExpr | Or LogExpr LogExpr | And LogExpr LogExpr \r\n		deriving (Show)\r\n\r\ninstance Eq LogExpr where\r\n  x == y = (help x False == help y False) && (help x True == help y True)\r\n\r\nhelp (T) _		= True\r\nhelp (F) _		= False\r\nhelp (X) t 		= t\r\nhelp (Not e) t	= help e (not t)\r\nhelp (Or a b) t	= help a t || help b t\r\nhelp (And a b) t	= help a t && help b t','<br/>Тесты успешно пройдены!'),(8151,123,'8519021','2013-11-30 00:14:08',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n   \r\n\r\nf xs =\r\n\r\n do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs\r\n\r\n   return (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(8150,110,'toskira','2013-11-29 23:38:09',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace _31_1 {\r\n\r\n	class Program {\r\n\r\n		public static int Find(Predicate<int> predicate, int[] array, Func<int> error)  {\r\n			for (int i = 0; i < array.Length; i++) {\r\n				if (predicate(array[i])) {\r\n					return array[i];\r\n				}\r\n			}\r\n			return error();\r\n		}\r\n\r\n		public static int CustomFind(int[] array) {\r\n			return Find(x => x > 1000, array, () => { return Find(x => x > 500, array, () => { return Find(x => x > 100, array, () => { return 0; }); }); });\r\n		}\r\n\r\n		static void Main(string[] args) {\r\n			// a)\r\n			Console.WriteLine(Find(x => x % 2 == 0, new int[] { 1, 2, 3 }, () => -1));\r\n			Console.WriteLine(Find(x => x % 2 == 0, new int[] { 1, 3, 5 }, () => -1));\r\n			// b)\r\n			Console.WriteLine(CustomFind(new int[] { 10, 20, 30, 40, 50, 60 }));\r\n			Console.WriteLine(CustomFind(new int[] { 100, 200, 300, 400, 500, 600 }));\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(8149,110,'SNNatalieS','2013-11-29 23:25:12',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _31_1\r\n{\r\n    class Program\r\n    {\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err) \r\n        {\r\n            for (int i = 0; i < a.Length; i++)\r\n            {\r\n                if(func(a[i])) return a[i];\r\n            }\r\n            return err();         \r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = { 10, 2, 3, 50 };\r\n            //var res = find(x => x > 2, arr, () => { Console.WriteLine(\"Not found\"); return 0; });\r\n            //Console.WriteLine(res);\r\n            var ress = find(x => x > 1000, arr, () => { return find(x => x > 500, arr, () => { return find(x => x > 100, arr, () => { return 0; }); }); });\r\n            Console.WriteLine(ress);       \r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(8148,110,'anna','2013-11-29 22:58:34',1,'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace ConsoleApplication1\r\n\r\n{\r\n\r\n    class FindExT\r\n\r\n    {\r\n\r\n        public static int Find(Predicate<int> f, int[] a, Func<int> err)\r\n\r\n        {\r\n\r\n            foreach (int x in a)\r\n\r\n            {\r\n\r\n                if (f(x))\r\n\r\n                {\r\n\r\n                    return x;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static int FindEx(int[] a)\r\n\r\n		{\r\n\r\n			return Find(x => x > 1000, a, () => Find(x => x > 500, a, () => Find(x => x > 100, a, () => 0)));\r\n\r\n		}\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] arr1 = { 1001, 54, 241, 31 };\r\n\r\n            int[] arr2 = { 66, 503, 22, 11 };\r\n\r\n            int[] arr3 = { 1, 2, 3, 121 };\r\n\r\n            int[] arr4 = { 1, 2, 3, 10 };\r\n\r\n\r\n\r\n            Console.WriteLine(\"{0}\", FindEx(arr1));\r\n\r\n            Console.WriteLine(\"{0}\", FindEx(arr2));\r\n\r\n            Console.WriteLine(\"{0}\", FindEx(arr3));\r\n\r\n            Console.WriteLine(\"{0}\", FindEx(arr4));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n        \r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(8147,110,'6053606','2013-11-29 21:39:58',1,'# Python\r\n\r\ndef find(xs, pred, f):\r\n    for x in xs:\r\n        if pred(x):\r\n            return x\r\n    return f()\r\n\r\nxs = range(50)\r\nprint(find(xs, lambda x: x > 1000,\r\n           lambda: find(xs, lambda x: x > 500,\r\n                        lambda: find(xs, lambda x: x > 100,\r\n                                     lambda: 0))))\r\n','<br/>Тесты успешно пройдены!'),(8146,122,'3270666','2013-11-29 21:28:27',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Num n) _ _ = n\r\n\r\n\r\n\r\neval (Add expr1 expr2) vals funcs = \r\n\r\n	eval expr1 vals funcs + eval expr2 vals funcs\r\n\r\n\r\n\r\neval (Mult expr1 expr2) vals funcs = \r\n\r\n	eval expr1 vals funcs * eval expr2 vals funcs\r\n\r\n\r\n\r\neval (Let var val expr) vals funcs = \r\n\r\n	eval expr ((var, val):vals) funcs\r\n\r\n\r\n\r\neval (LetFunc f param func expr) vals funcs = \r\n\r\n	eval expr vals ((f, (param, func)):funcs)\r\n\r\n\r\n\r\neval (Call func arg) vals (f:funcs) = \r\n\r\n	if (fst f == func)\r\n\r\n		then eval (funcToLet f arg) vals funcs\r\n\r\n		else eval (Call func arg) vals funcs\r\n\r\neval (Call _ _) _ [] = 0\r\n\r\n\r\n\r\neval (Var x) (v:vals) funcs = \r\n\r\n	if (fst v == x)\r\n\r\n		then snd v\r\n\r\n		else eval (Var x) (vals) funcs\r\n\r\neval (Var _) [] _ = 0\r\n\r\n\r\n\r\nfuncToLet f arg = (Let (fst (snd f)) (eval arg [] []) (snd (snd f)))\r\n','<br/>Тесты успешно пройдены!'),(8144,124,'617015','2013-11-29 20:43:37',1,'downUp n = do\r\n\r\n			print n\r\n\r\n			dUp (n-1) n\r\n\r\n			\r\n\r\ndUp 0 n = upDown 2 n \r\n\r\ndUp x n = do\r\n\r\n			print x \r\n\r\n			dUp (x-1) n\r\n\r\n			\r\n\r\n\r\n\r\nupDown x n  = if x==n then  do\r\n\r\n							print n  \r\n\r\n					else\r\n\r\n							do\r\n\r\n							print x\r\n\r\n							upDown (x+1) n\r\n\r\n			\r\n','<br/>Тесты успешно пройдены!'),(8145,112,'617015','2013-11-29 20:44:07',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr  \r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Let str int (Num k)) xs = k\r\n\r\neval (Let str int (Var c)) xs = if str == c then int else eval (Var c) xs \r\n\r\neval (Let str int (Mult e1 e2)) xs = (eval(Let str int e1) xs) *  (eval(Let str int e2) xs)\r\n\r\neval (Let str int (Add e1 e2)) xs = (eval(Let str int e1) xs) + (eval(Let str int e2) xs) \r\n\r\n\r\n\r\neval (Num k) xs = k\r\n\r\neval (Var c) xs = getValue c xs\r\n\r\neval (Add e1 e2) xs = (eval e1 xs) + (eval e2 xs)\r\n\r\neval (Mult e1 e2) xs = (eval e1 xs) * (eval e2 xs) \r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\ngetValue var values = head [val| (v,val)<-values, v==var]\r\n','<br/>Тесты успешно пройдены!'),(8143,123,'617015','2013-11-29 20:43:10',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\n\r\n\r\nf xs = do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs\r\n\r\n   return  (x+y+z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8141,116,'3270666','2013-11-29 15:20:40',1,'toInt church = church (+1) 0','<br/>Тесты успешно пройдены!'),(8142,110,'8519021','2013-11-29 17:39:17',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace Find\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int Find(Predicate<int> func, int[] a, Func<int> err)\r\n\r\n        {\r\n\r\n            foreach (int number in a)\r\n\r\n            {\r\n\r\n                if (func(number))\r\n\r\n                    return number;\r\n\r\n            }\r\n\r\n\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 77, 107, 507, 1007 };\r\n\r\n            int[] b = { 77, 107, 507 };\r\n\r\n            int[] c = { 77, 107 };\r\n\r\n            int[] d = { 77 };\r\n\r\n\r\n\r\n            Console.WriteLine(Find(x => x > 1000, a, () =>  Find(x => x > 500, a, () => Find(x => x > 100, a, () => 0))));\r\n\r\n            Console.WriteLine(Find(x => x > 1000, b, () => Find(x => x > 500, b, () => Find(x => x > 100, b, () => 0))));\r\n\r\n            Console.WriteLine(Find(x => x > 1000, c, () => Find(x => x > 500, c, () => Find(x => x > 100, c, () => 0))));\r\n\r\n            Console.WriteLine(Find(x => x > 1000, d, () => Find(x => x > 500, d, () => Find(x => x > 100, d, () => 0))));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8140,112,'3270666','2013-11-29 14:50:37',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n            | Let String Integer Expr\r\n	deriving Show\r\n\r\neval (Num n) vals = n\r\neval (Add expr1 expr2) vals = eval expr1 vals + eval expr2 vals\r\neval (Mult expr1 expr2) vals = eval expr1 vals * eval expr2 vals\r\neval (Let var val expr) vals = eval expr ((var, val):vals)\r\neval (Var x) (v:vals) = \r\n	if (fst v == x)\r\n		then snd v\r\n		else eval (Var x) (vals)\r\neval (Var x) [] = 0','<br/>Тесты успешно пройдены!'),(8139,107,'2156724','2013-11-29 14:48:31',0,'data LogExpr = 	 T\r\n\n              	|F\r\n\n		|X\r\n\n		|Or LogExpr LogExpr\r\n\n		|And LogExpr LogExpr\r\n\n		|Not LogExpr\r\n\n\r\n\n\r\n\ninstance Eq LogExpr where\r\n\n	T == T = True\r\n\n	F == F = True\r\n\n	F == T = False\r\n\n	T == F = False\r\n\n	e1 == e2 = if (eval e1 T == eval e2 T) &&  (eval e1 F == eval e2 F) then True\r\n\n			else False\r\n\n	 \r\n\n\r\n\neval (Or e1 e2) b = if (eval e1 b == F && eval e2 b == F) then F else T \r\n\neval (And e1 e2) b = if (eval e1 b == T && eval e2 b == T) then T else F\r\n\neval (X) b = b \r\n\neval (Not e1) b = if (e1 == T) then F else T \r\n\neval (F) b = F\r\n\neval (T) b = T \n','<br/>Тесты успешно пройдены!'),(8138,124,'3270666','2013-11-29 14:22:20',1,'downUp 1 = print 1\r\ndownUp n = do\r\n	print n\r\n	downUp (n-1)\r\n	print n','<br/>Тесты успешно пройдены!'),(8137,123,'3270666','2013-11-29 14:20:14',1,'find cond [] = Nothing\r\nfind cond (x:xs) = \r\n   if cond x \r\n     then Just x\r\n     else find cond xs\r\n\r\nf xs = do\r\n   x <- find (<5) xs\r\n   y <- find (>10) xs\r\n   z <- find (/=7) xs\r\n   return (x+y+z)','<br/>Тесты успешно пройдены!'),(8136,117,'deripaska','2013-11-29 11:07:45',1,'{--\r\n\r\n	task 35-07\r\n\r\nНаписать функцию inc, которая прибавляет 1 к числу Черча.\r\n\r\n\r\n\r\nНапример, вызов inc ( f x -> f (f (f x))) должен вернуть  f x -> f (f (f (f x))). \r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntoInt (inc ( f x -> f (f (f x))))\r\n\r\nРезультат д.б. равен 4.\r\n\r\n--}\r\n\r\n\r\n\r\ntoInt num = num (+ 1) 0\r\n\r\ninc num = f x -> f (num f x)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8135,116,'deripaska','2013-11-29 11:02:26',1,'{--\r\n\r\n	task 35-06\r\n\r\nНаписать функцию toInt, которая по данному числу Черча возвращает обычное число.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ntoInt (f x -> f (f (f x)))\r\n\r\n\r\n\r\nРезультат должен быть равен 3.\r\n\r\n--}\r\n\r\n\r\n\r\ntoInt num = num (+ 1) 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8134,124,'deripaska','2013-11-29 10:58:15',1,'{--\r\n\r\n	task 35-02\r\n\r\nОписать функцию downUp, которая для данного параметра n печатает числа:\r\n\r\nn n-1 n-2 … 3 2 1 2 3 … n-2 n-1 n\r\n\r\nпо одному в столбик.\r\n\r\n\r\n\r\nДополнительное условие:\r\n\r\n- Надо обязательно использовать функцию print и do нотацию\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ndownUp 3\r\n\r\n\r\n\r\nДолжно напечататься:\r\n\r\n3\r\n\r\n2\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n--}\r\n\r\n\r\n\r\ndownUp 1 = print 1\r\n\r\ndownUp n = do \r\n\r\n	downUp_help n 2\r\n\r\n	print 1\r\n\r\n	downUp_help 2 n\r\n\r\n	\r\n\r\ndownUp_help begin end\r\n\r\n	| begin < end = do \r\n\r\n			print begin\r\n\r\n			downUp_help (begin + 1) end\r\n\r\n	| begin > end = do \r\n\r\n			print begin\r\n\r\n			downUp_help (begin - 1) end\r\n\r\n	| otherwise = print end\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8133,123,'deripaska','2013-11-29 10:57:59',1,'{--\r\n\r\n	task 35-01\r\n\r\nа. Описать функцию find с двумя параметрами - условие (логическая функция) и список. Функция должна искать первый элемент в списка, удовлетворяющий условию, и возвращать Just элемент или Nothing, если ничего не найдено. \r\n\r\n\r\n\r\nПримеры вызова find:\r\n\r\n\r\n\r\nfind (>6) [1, 2, 8, 3]\r\n\r\nРезультат должен быть Just 8\r\n\r\n\r\n\r\nfind (>6) [1, 2, 5, 3]\r\n\r\nРезультат должен быть Nothing\r\n\r\n\r\n\r\nб. С помощью этого варианта find описать функцию f, которая делает вот что:\r\n\r\nВ данном списке f ищет:\r\n\r\n- первое число, меньшее 5\r\n\r\n- первое число, большее 10\r\n\r\n- первое число, не равное 7\r\n\r\nи возвращает:\r\n\r\n- если хотя бы один поиск был неудачным, возвращает Nothing\r\n\r\n- если все числа найдены, возвращает Just для их суммы.\r\n\r\n\r\n\r\nДополнительное условие:\r\n\r\nОбязательно надо использовать конструкцию do (как это можно сделать, мы обсуждали на последнем занятии).\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\n\r\nРезультат должен быть равен Just 30, потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\n\r\n\r\nf [7, 6, 4, 3, 9]\r\n\r\nРезультат должен быть равен Nothing, потому что один из трех поисков ничего не находит.\r\n\r\n--}\r\n\r\n\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then Just x \r\n\r\n   else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n   x <- find (< 5) xs\r\n\r\n   y <- find (> 10) xs\r\n\r\n   z <- find (/= 7) xs\r\n\r\n   return (x + y + z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8131,119,'anlun','2013-11-29 01:01:24',1,'toInt = flip uncurry ((+1), 0)\r\ninc num f = f . (num f)\r\n\r\ndec num f x = (num (p -> let x = p fst in pair (f x) x) $ pair x x) snd\r\n	where\r\n		pair a b f = f a b\r\n		fst  a _ = a\r\n		snd  _ b = b','<br/>Тесты успешно пройдены!'),(8132,120,'5543298','2013-11-29 03:54:09',1,'--reuse of task 33.1 with some generalization (implement variables)\r\n\r\ndata LogExpr = T | F | Var String | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr | Impl LogExpr LogExpr deriving Show\r\n\r\n\r\n\r\nfind cond ((a,b):xs) = if cond a then b else find cond xs\r\n\r\n\r\n\r\neval (Var x) xs = find (==x) xs \r\n\r\neval T xs = True\r\n\r\neval F xs = False\r\n\r\neval (And x y) xs = (eval x xs) && (eval y xs)\r\n\r\neval (Or x y) xs = (eval x xs) || (eval y xs)\r\n\r\neval (Not x) xs = not (eval x xs)\r\n\r\neval (Impl x y) xs = not (eval x xs) || (eval y xs)\r\n\r\n\r\n\r\n--reuse of task 13.1 with change for generation bool means\r\n\r\nallLists\' 0 _= [[]]	\r\n\r\nallLists\' n ys = [x:xs | x <- [True, False], xs <- allLists\' (n - 1) (x:ys)]\r\n\r\nallLists n = allLists\' n []\r\n\r\n\r\n\r\n--itself task 36.2\r\n\r\nisTautology x xs = foldr (ys res -> res && (eval x ys)) True (map (ys -> zip xs ys) (allLists (length xs)))\r\n\r\n\r\n\r\n--tests\r\n\r\ntest1 = isTautology (Impl (Var \"A\") (Var \"A\")) [\"A\"]\r\n\r\ntest2 = isTautology (Impl (Impl (Var \"A\") (Var \"B\")) (Impl (Impl (Var \"B\") (Var \"C\")) (Impl (Var \"A\") (Var \"C\")))) [\"A\", \"B\", \"C\"]\r\n\r\ntest3 = isTautology (Impl (Impl (Var \"A\") (Var \"B\")) (Impl (Var \"B\") (Var \"A\"))) [\"A\", \"B\"]\r\n\r\ntest4 = isTautology (Impl (Impl (Impl (Var \"A\") (Var \"B\")) (Var \"C\")) (Var \"D\")) [\"A\", \"B\", \"C\", \"D\"]\r\n\r\n\r\n\r\ntest = [test1, test2, test3, test4] --out [True,True,False,False]\r\n','<br/>Тесты успешно пройдены!'),(8130,117,'2156724','2013-11-29 00:31:32',1,'inc n = f x -> f(n f x)\r\n\r\ntoInt n = n (f ->f + 1) 0\r\n','<br/>Тесты успешно пройдены!'),(8129,116,'2156724','2013-11-29 00:31:06',1,'toInt n = n (f ->f + 1) 0 \r\n','<br/>Тесты успешно пройдены!'),(8128,112,'2156724','2013-11-29 00:30:08',1,'data Expr = Num Integer \r\n          | Var String\r\n	  | Let String Integer Expr \r\n          | Add Expr Expr \r\n          | Mult Expr Expr \r\n\r\n     deriving Show\r\n\r\n\r\n\r\neval (Add e1 e2) (x:xs) = (eval e1 (x:xs)) + (eval e2 (x:xs)) \r\n\r\neval (Mult e1 e2) (x:xs) = (eval e1 (x:xs)) * (eval e2 (x:xs))\r\n\r\neval (Var a) ((x,y):xs) = \r\n\r\n         if (x == a) then y else eval (Var a) xs\r\n\r\neval (Num a) (x:xs) = a   \r\n\r\neval (Let x n e) (y:xs) = eval e ((x,n):y:xs)','<br/>Тесты успешно пройдены!'),(8127,124,'2156724','2013-11-29 00:29:45',1,'pr2 k n = if k==n then print n\r\n\r\n          else do\r\n\r\n                 print k\r\n\r\n                 pr2 (k+1) n\r\n\r\n\r\n\r\npr 1 n = do\r\n\r\n           print 1\r\n\r\n           pr2 2 n\r\n\r\n     \r\n\r\npr a n = do \r\n\r\n	print a\r\n\r\n    	pr (a-1) n \r\n\r\n\r\n\r\ndownUp n = pr n n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8126,124,'2156724','2013-11-29 00:29:12',0,'data Expr = Num Integer \r\n          | Var String\r\n	  | Let String Integer Expr \r\n          | Add Expr Expr \r\n          | Mult Expr Expr \r\n\r\n     deriving Show\r\n\r\n\r\n\r\neval (Add e1 e2) (x:xs) = (eval e1 (x:xs)) + (eval e2 (x:xs)) \r\n\r\neval (Mult e1 e2) (x:xs) = (eval e1 (x:xs)) * (eval e2 (x:xs))\r\n\r\neval (Var a) ((x,y):xs) = \r\n\r\n         if (x == a) then y else eval (Var a) xs\r\n\r\neval (Num a) (x:xs) = a   \r\n\r\neval (Let x n e) (y:xs) = eval e ((x,n):y:xs)','<br/>Тесты успешно пройдены!'),(8125,127,'ilia','2013-11-29 00:08:30',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf = find (>3) >>>= x -> find (>x)\r\n\r\n\r\n\r\ne1 >>>= e2 = x -> let e1x = e1 x in e2 (fst e1x) (snd e1x)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (f [1,6,5,7,1,2])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8124,127,'ilia','2013-11-29 00:02:50',0,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\n\nf = find (>3) >>>= (find, (>))\n\n\n\ne1 >>>= e2 = let\n\n		e2e = fst e2\n\n		e2t = snd e2\n\n	in x -> let e1x = e1 x in e2e (y -> e2t y (fst e1x)) (snd e1x)\n\n\n\nmain = do\n\n	print (f [1,6,5,7,1,2])\n\n\n','<br/>Тесты успешно пройдены!'),(8123,124,'2156724','2013-11-28 23:49:02',0,'pr2 k n = if k==n then print n\r\n\n          else do\r\n\n                 print k\r\n\n                 pr2 (k+1) n\r\n\n\r\n\npr 1 n = do\r\n\n           print 1\r\n\n           pr2 2 n\r\n\n     \r\n\npr a n = do \r\n\n	print a\r\n\n    	pr (a-1) n \r\n\n\r\n\ndownUp n = pr n n\r\n\n\n','<br/>Тесты успешно пройдены!'),(8117,122,'284427','2013-11-28 22:51:27',0,'','Не удалось вычислить выражение \"eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []\", проверьте правильность синтаксиса'),(8118,122,'284427','2013-11-28 22:54:27',1,'ok','Не удалось вычислить выражение \"eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []\", проверьте правильность синтаксиса'),(8119,116,'284427','2013-11-28 23:10:30',1,'toInt churchNumber = churchNumber (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(8120,117,'284427','2013-11-28 23:13:24',1,'toInt churchNumber = churchNumber (+1) 0\r\n\r\ninc churchNumber = f x -> f (churchNumber f x)\r\n','<br/>Тесты успешно пройдены!'),(8121,117,'ilia','2013-11-28 23:24:00',1,'toInt c = c (+1) 0\r\n\r\n\r\n\r\ninc c = g x -> g (c g x)\r\n\r\n\r\n\r\nmain = print (toInt (inc (f x -> f (f (f x)))))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8122,123,'2156724','2013-11-28 23:48:36',1,'find f [] = Nothing\r\n\r\nfind f (x:xs) = if (f x) then Just x\r\n\r\n                         else find f xs\r\n\r\nf xs = do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs\r\n\r\n   return (x+y+z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8115,124,'284427','2013-11-28 20:55:02',1,'downUp 1 = print 1\r\n\r\ndownUp n = do\r\n\r\n	du n\r\n\r\n	ud 2 n\r\n\r\n\r\n\r\ndu 1 = print 1\r\n\r\ndu n = do\r\n\r\n	print n\r\n\r\n	du (n-1)\r\n\r\nud n k = \r\n\r\n	if n == k then print k \r\n\r\n	else do\r\n\r\n		print n\r\n\r\n		ud (n+1) k\r\n','<br/>Тесты успешно пройдены!'),(8116,112,'284427','2013-11-28 22:20:30',1,'data Expr = Var String | Num Integer | Let String Integer Expr | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ngetVal [] _ = 0\r\n\r\ngetVal ((s, v):values) x = if (x == s) then v else (getVal values x)\r\n\r\n\r\n\r\neval (Let var value expr) values = eval expr ((var, value) : values)\r\n\r\neval (Var x) values = getVal values x\r\n\r\neval (Num n) _ = n\r\n\r\neval (Add a1 a2) values = eval a1 values + eval a2 values\r\n\r\neval (Mult m1 m2) values = eval m1 values * eval m2 values\r\n','<br/>Тесты успешно пройдены!'),(8114,119,'anlun','2013-11-28 20:00:21',2,'toInt = flip uncurry ((+1), 0)\r\ninc num f = f . (num f)\r\n\r\ndec num f x = snd $ num ((a, _) -> (f a, a)) (x, x)\r\n --- Идея правильная, конечно, но пары тут нельзя использовать, это есть в условии. Те эту идею надо как-то записать без пар.','<br/>Тесты успешно пройдены!'),(8113,123,'284427','2013-11-28 19:55:33',1,'find _ [] = Nothing\r\n\r\nfind f (x:xs) = if (f x) then Just x else find f xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n	x <- find (<5) xs\r\n\r\n	y <- find (>10) xs\r\n\r\n	z <- find (/=7) xs\r\n\r\n	return (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(8112,97,'nbumakov','2013-11-28 19:31:33',1,'pop []  = (\'f\', [])\r\npop xs = (last xs, init xs)\r\npush x xs = xs ++ [x]\r\n\r\ncheckBrackets xs = checkBrackets2 xs []\r\n\r\ncheckBrackets2 [] [] = True\r\ncheckBrackets2 [] _ = False\r\ncheckBrackets2 (x:xs) stack \r\n        | x == \'(\' || x == \'[\' = checkBrackets2 xs (push x stack) \r\n        | x == \')\' = let (y, ys) = pop stack in ((y == \'(\') && checkBrackets2 xs ys)\r\n        | x == \']\' = let (y, ys) = pop stack in ((y == \'[\') && checkBrackets2 xs ys)\r\n        | otherwise = False\r\n        \r\ntest (x:xs) = x','<br/>Тесты успешно пройдены!'),(8111,123,'ilia','2013-11-28 19:09:27',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\nf m = do\r\n\r\n	r1 <- find (<5) m\r\n\r\n	r2 <- find (>10) m\r\n\r\n	r3 <- find (/=7) m\r\n\r\n	return (r1 + r2 + r3)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (f [7, 6, 4, 3, 9])\r\n\r\n	print (f [7, 6, 4, 3, 20, 15, 9])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8110,116,'ilia','2013-11-28 19:01:07',1,'toInt f = f (+1) 0\r\n\r\n\r\n\r\nmain = print (toInt (f x -> f (f (f x))))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8109,124,'ilia','2013-11-28 18:55:39',1,'downUp 1 = print 1\r\n\r\ndownUp n = do\r\n\r\n	print n\r\n\r\n	downUp (n - 1)\r\n\r\n	print n\r\n\r\n\r\n\r\nmain = downUp 3\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8108,123,'ilia','2013-11-28 18:52:55',2,'--- Нет, это не совсем то.. В этой задаче имеется в виду, что надо написать фунцкцию f c помощью\r\n--- do. Как это можно сделать, написано в слайдах.\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\nf m = let\r\n\r\n		t = [ find (<5) m, find (>10) m, find (/=7) m ]\r\n\r\n	in\r\n\r\n		if any (	i -> ti == Nothing) t then Nothing\r\n\r\n		else Just (sum (foldr ((Just ti) r -> ti : r) [ ] t))\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (f [7, 6, 4, 3, 9])\r\n\r\n	print (f [7, 6, 4, 3, 20, 15, 9])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8107,106,'1835693','2013-11-28 16:52:59',1,'findMajor xs = recheckMajor (findMajorH 0 0 xs) xs\r\n\r\n-- первый проход - нахождение возможного элемента\r\nfindMajorH 0 b []     = Nothing\r\nfindMajorH _ b []     = Just b\r\nfindMajorH 0 _ (x:xs) = findMajorH 1 x xs\r\nfindMajorH a b (x:xs) = if (x == b)\r\n                        then findMajorH (a + 1) b xs\r\n                        else findMajorH (a - 1) b xs\r\n\r\n-- второй проход - проверка, что элемент действительно подходит\r\nrecheckMajor Nothing  _  = Nothing\r\nrecheckMajor (Just a) xs = recheckMajorH 0 0 a xs\r\n\r\nrecheckMajorH eq neq a [] = if (eq > neq)\r\n                            then Just a\r\n                            else Nothing\r\nrecheckMajorH eq neq a (x:xs) = if (x == a)\r\n                                then recheckMajorH (eq + 1) neq a xs\r\n                                else recheckMajorH eq (neq + 1) a xs\r\n','<br/>Тесты успешно пройдены!'),(8106,97,'1835693','2013-11-28 16:19:35',1,'checkBrackets = checkBracketsH []\r\n\r\ncheckBracketsH [] []        = True\r\ncheckBracketsH _  []        = False\r\ncheckBracketsH stack (x:xs) = if (x == \'(\' || x == \'[\')\r\n                              then checkBracketsH (x:stack) xs\r\n                              else if (x == \')\')\r\n                                   then if (stack == [] || head stack /= \'(\')\r\n                                        then False\r\n                                        else checkBracketsH (tail stack) xs\r\n                                   else if (x == \']\')\r\n                                        then if (stack == [] || head stack /= \'[\')\r\n                                             then False\r\n                                             else checkBracketsH (tail stack) xs\r\n                                        else False\r\n','<br/>Тесты успешно пройдены!'),(8105,121,'115753099','2013-11-28 15:23:52',2,'--- нет, это не continuation pasing style..\r\n\r\nusing System;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n		static void fact_cps(int n, Action<int> ret)\r\n		{\r\n			tail_fact(n,1,ret);\r\n		} \r\n		 \r\n		static void tail_fact(int n, int a, Action<int> ret)\r\n		{\r\n			if (n == 0)\r\n				ret(a) ;\r\n			else\r\n				tail_fact(n-1,n*a,ret) ;\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			fact_cps ( 3, (int x) => {Console.WriteLine(x);});\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(8104,127,'anlun','2013-11-28 15:04:15',1,'\r\n\r\nf1 >>>= f2 = (uncurry f2) . f1\r\nuseEx = findOld (> 3) >>>= (x -> findOld (> x))','<br/>Тесты успешно пройдены!'),(8103,98,'1595828','2013-11-28 14:49:34',1,'data Tree a = Empty | Node a (Tree a) (Tree a) deriving Show\r\n\r\ntoStr s =toStr\' s []\r\n\r\ntoStr\' Empty = (\'e\':).id\r\n\r\ntoStr\' (Node c l r) = (\'n\':).(c:).toStr\' l.toStr\' r\r\n\r\n\r\n\r\n\r\n\r\nfromStr\' (x:s) =\r\n\r\n    if x == \'n\' then \r\n\r\n        let\r\n\r\n          (l,a1) = fromStr\' (tail s)  \r\n\r\n          (r,a2) = fromStr\' a1\r\n\r\n        in (Node (head s) l r,a2)\r\n\r\n	else\r\n\r\n		(Empty,s)\r\n\r\n\r\n\r\nfromStr s = fst(fromStr\' s) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8102,123,'anlun','2013-11-28 14:47:41',1,'find :: (a -> Bool) -> [a] -> Maybe a\r\nfind _ [] = Nothing\r\nfind f (x:xs) = if f x then Just x else find f xs\r\n\r\nf :: [Integer] -> Maybe Integer\r\nf l =\r\n	do\r\n		l5  <- find (< 5) l\r\n		g10 <- find (>10) l\r\n		n7  <- find (/=7) l\r\n		return $ l5 + g10 + n7','<br/>Тесты успешно пройдены!'),(8101,97,'1595828','2013-11-28 13:34:22',1,'checkBrackets xs =  checkBrackets\' xs []\r\n\r\ncheckBrackets\' [] ys = null ys\r\n\r\ncheckBrackets\' (x:xs) (ys) = if (x == \'(\')||(x == \'[\') then \r\n\r\n		checkBrackets\' (xs) (x:ys)\r\n\r\n		else\r\n\r\n			if not (null ys) && (head ys == ans_h x) then checkBrackets\' (xs) (tail ys) else False\r\n\r\n\r\n\r\nans_h ch = if ch==\')\' then \'(\' else \'[\'\r\n','<br/>Тесты успешно пройдены!'),(8100,117,'115753099','2013-11-28 10:43:35',1,'toInt f = f (+1) 0\r\n\r\ninc f =  g x -> g (f g x)\r\n','<br/>Тесты успешно пройдены!'),(8099,117,'115753099','2013-11-28 10:42:34',0,'inc f =  g x -> g (f g x)','Не удалось вычислить выражение \"let c3 f x = f (f x) in toInt (inc c3)\", проверьте правильность синтаксиса'),(8098,116,'115753099','2013-11-28 10:42:21',1,'toInt f = f (+1) 0','<br/>Тесты успешно пройдены!'),(8097,112,'115753099','2013-11-28 10:41:28',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n		deriving Show\r\n\r\neval (Let x value expr) xs =\r\n	eval expr ((x, value) : xs)\r\neval (Num a) _ = a\r\neval (Var x) xs\r\n	| null nameList	= 0\r\n	| otherwise		= eq\r\n	where\r\n		nameList = filter ((name, eq) -> name == x) xs\r\n		(_, eq) = head nameList\r\neval (Add ex1 ex2) xs = eval ex1 xs + eval ex2 xs\r\neval (Mult ex1 ex2) xs = eval ex1 xs * eval ex2 xs','<br/>Тесты успешно пройдены!'),(8096,127,'115753099','2013-11-28 10:41:09',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf1 >>> g =\r\n	ys -> (((x, xs) -> g x ys) . f1) ys\r\n\r\nf = find (>3) >>> x -> find (>x)','<br/>Тесты успешно пройдены!'),(8095,124,'115753099','2013-11-28 10:40:50',1,'downUp 1 = print 1\r\ndownUp n = \r\n	do \r\n		print n\r\n		downUp (n-1)\r\n		print n','<br/>Тесты успешно пройдены!'),(8093,124,'1595828','2013-11-28 02:15:20',1,'downUp  1 = print 1;\r\n\r\ndownUp n =  do {	print n; downUp (n-1); print n; }\r\n\r\n \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8094,122,'5543298','2013-11-28 02:19:51',1,'sent by mail','Не удалось вычислить выражение \"eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []\", проверьте правильность синтаксиса'),(8092,122,'ilia','2013-11-28 01:33:31',1,'data Expr = \r\n\r\n		Num Integer |\r\n\r\n		Var String |\r\n\r\n		Add Expr Expr |\r\n\r\n		Mult Expr Expr |\r\n\r\n		Let String Integer Expr |\r\n\r\n		LetFunc String String Expr Expr |\r\n\r\n		Call String Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Num n) _ = n\r\n\r\neval (Var v) defs = eval (snd (head (filter (d -> fst d == v) defs))) defs\r\n\r\neval (Add e1 e2) defs = eval e1 defs + eval e2 defs\r\n\r\neval (Mult e1 e2) defs = eval e1 defs * eval e2 defs\r\n\r\neval (Let v n e) defs = eval e ((v, n) : defs)\r\n\r\neval (LetFunc f x y e) defs = eval e ((f, (x, y)) : defs)\r\n\r\neval (Call f v) defs = let\r\n\r\n		xy = snd (head (filter (d -> fst d == f) defs))\r\n\r\n	in eval (snd xy) ((fst xy, v) : defs)\r\n\r\n\r\n\r\nmain = print (eval (\r\n\r\n				LetFunc \"F\" \"X\"\r\n\r\n					(Mult (Var \"X\") (Var \"X\"))\r\n\r\n					(Add (Num 1) (Call \"F\" (Num 5)))\r\n\r\n					)\r\n\r\n				[ ]\r\n\r\n				)\r\n\r\n\r\n','Не удалось вычислить выражение \"eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []\", проверьте правильность синтаксиса'),(8091,112,'1595828','2013-11-28 01:28:56',1,'data Expr = Var String|Num Integer | Env String Int Expr | Add Expr Expr | Mult Expr Expr| Let String Integer Expr  deriving Show\r\n\r\neval (Num n) _ = n\r\n\r\neval (Add a1 a2) n = eval a1 n +eval a2 n\r\n\r\neval (Mult m1 m2) n = eval m1 n *eval m2 n\r\n\r\neval (Var str) ((x,y):xs) = if (x ==str) then y else eval (Var str) xs\r\n\r\neval  (Let x y e) xs = eval e ((x,y):xs)\r\n','<br/>Тесты успешно пройдены!'),(8090,97,'480387','2013-11-28 01:07:55',1,'checkBrackets ls = c\' ls []\r\nc\' [] [] = True\r\nc\' [] ls = False\r\nc\' (l:ls) st = if (l == \'(\' || l == \'[\') then c\' ls (l:st) else if not (null st) && ((st!!0 == \'(\' && l == \')\') || (st!!0 == \'[\' && l == \']\'))\r\n																	then c\' ls (tail st) else False','<br/>Тесты успешно пройдены!'),(8089,112,'ilia','2013-11-28 00:58:53',1,'data Expr = \r\n\r\n		Num Integer |\r\n\r\n		Var String |\r\n\r\n		Add Expr Expr |\r\n\r\n		Mult Expr Expr |\r\n\r\n		Let String Integer Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Num n) _ = n\r\n\r\neval (Var v) defs = snd (head (filter (d -> fst d == v) defs))\r\n\r\neval (Add e1 e2) defs = eval e1 defs + eval e2 defs\r\n\r\neval (Mult e1 e2) defs = eval e1 defs * eval e2 defs\r\n\r\neval (Let v n e) defs = eval e ((v, n) : defs)\r\n\r\n\r\n\r\nmain = print (eval (Add (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (Num 1)) [ (\"y\", 2) ])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8087,117,'1595828','2013-11-28 00:46:46',1,'toInt f= f (+1) 0\r\n\r\ninc g= f x -> f (g f x)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8088,106,'480387','2013-11-28 00:57:05',2,'--- идея алгоритма у вас совершенно правильная, но если в решении используется\r\n--- оператор !! то оно арядли может быть O(n), пототы что сама операция !! уже O(n),\r\n--- она последовательно просматривест список.\r\n--- Те перепишите, пожалуйста, без использования !!,  это просто\r\nfindMajor ls = decide ls (f ls 0 (length ls) 0 0)\r\ndecide ls (c,t,n) = if t==0 then Nothing\r\n							else if (2*(sum (map (x->if x==c then 1 else 0) ls))) > n then Just c else Nothing\r\nf ls i n c test = if i==n then (c,test,n)  else\r\n					if test==0\r\n						then f ls (i+1) n (ls!!i) (test+1)\r\n						else if c == (ls!!i)\r\n								then f ls (i+1) n c (test+1)\r\n								else f ls (i+1) n c (test-1)\r\n','<br/>Тесты успешно пройдены!'),(8085,123,'1595828','2013-11-27 23:50:51',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs	\r\n\r\nf xs = do\r\n\r\n   x <- find (<5) xs\r\n\r\n   y <- find (>10) xs\r\n\r\n   z <- find (/=7) xs \r\n\r\n   return  (x+y+z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8086,116,'1595828','2013-11-28 00:38:56',1,'toInt f= f (+1) 0\r\n','<br/>Тесты успешно пройдены!'),(8084,117,'3226573','2013-11-27 23:49:06',1,'toInt g = g (+1) 0\r\n\r\ninc g = f x -> f (g f x)','<br/>Тесты успешно пройдены!'),(8083,116,'romos2007','2013-11-27 23:18:10',1,'{--\r\n\r\nЗадача 35-6\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ntoInt nChurch = nChurch (	->t+1) 0\r\n\r\n\r\n\r\ninc nChurch = f x -> f(nChurch f x)\r\n\r\n{-\r\n\r\n f x -> f (f (f x))	==>		 f x -> f (f (f (f x)))\r\n\r\n-}\r\n','<br/>Тесты успешно пройдены!'),(8082,117,'romos2007','2013-11-27 23:16:11',1,'{--\r\n\r\nЗадача 35-6\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ntoInt nChurch = nChurch (	->t+1) 0\r\n\r\n\r\n\r\ninc nChurch = f x -> f(nChurch f x)\r\n\r\n{-\r\n\r\n f x -> f (f (f x))	==>		 f x -> f (f (f (f x)))\r\n\r\n-}\r\n','<br/>Тесты успешно пройдены!'),(8080,124,'romos2007','2013-11-27 22:55:25',1,'{--\r\n\r\nЗадача 35-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndownUp n \r\n\r\n	|n > 1 = do\r\n\r\n				print n\r\n\r\n				downUp (n-1)\r\n\r\n				print n\r\n\r\n	|n == 1 = print 1\r\n\r\n	|otherwise = \r\n\r\n		print \"Error! Your N must be >=1\"\r\n','<br/>Тесты успешно пройдены!'),(8081,112,'romos2007','2013-11-27 23:04:00',1,'{--\r\n\r\nЗадача 35-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = Var String |\r\n\r\n			Num Integer |\r\n\r\n			Add Expr Expr |\r\n\r\n			Mult Expr Expr |\r\n\r\n			Let String Integer Expr\r\n\r\n			deriving (Show, Eq)\r\n\r\n\r\n\r\nget v [] = 0\r\n\r\nget v ((var, val):variables) = if v == var\r\n\r\n							  then val\r\n\r\n							  else get v variables\r\n\r\n\r\n\r\neval (Mult e1 e2) variables = (eval e1 variables) * (eval e2 variables)\r\n\r\neval (Add e1 e2) variables = (eval e1 variables) + (eval e2 variables)\r\n\r\neval (Num i) variables = i\r\n\r\neval (Var v) variables = get v variables\r\n\r\neval (Let x v e) variables = eval e ((x, v):variables)\r\n\r\n\r\n\r\n--diff X = Num 1\r\n\r\n--diff (Num i) = Num 0\r\n\r\n--diff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\n--diff (Mult e1 e2) = Add (Mult (diff e1) (e2)) (Mult (e1) (diff e2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8079,123,'romos2007','2013-11-27 22:39:22',1,'{--\r\n\r\nЗадача 35-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\nf xs = 	do\r\n\r\n			x <- find (<5) xs\r\n\r\n			y <- find (>10) xs\r\n\r\n			z <- find (/=7) xs\r\n\r\n			return (x+y+z)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8078,124,'anlun','2013-11-27 19:52:23',1,'downUp n =\r\n	do\r\n		mapM_ (mapM_ print) [[n, n-1..1], [2..n]]','<br/>Тесты успешно пройдены!'),(8076,117,'anlun','2013-11-27 19:37:26',1,'toInt = flip uncurry ((+1), 0)\r\ninc num f = f . (num f)','<br/>Тесты успешно пройдены!'),(8077,124,'anlun','2013-11-27 19:46:27',0,'downUp n =\r\n	do\r\n		printList $ reverse [1..n]\r\n		printList [2..n]\r\n	where\r\n		printList = mapM_ (putStrLn . show)','<br/>Тесты успешно пройдены!'),(8075,116,'anlun','2013-11-27 19:37:06',1,'toInt = flip uncurry ((+1), 0)','<br/>Тесты успешно пройдены!'),(8074,127,'5543298','2013-11-27 16:39:26',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nsearch1 >>>= search2 = xs -> (let x = fst (search1 xs) in let y = search2 x xs in y)\r\n\r\n\r\n\r\nf = find (>3) >>>= x -> find (>x) \r\n','<br/>Тесты успешно пройдены!'),(8073,122,'3226573','2013-11-27 15:09:23',1,'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | Var String |\r\n\r\n            Let String Integer Expr | LetFunc String String Expr Expr | Call String Expr deriving Show\r\n\r\n\r\n\r\ngetFuncValue name [] = (\"\", (Num 0))\r\n\r\ngetFuncValue name ((funcName, varName, funcExpr):funcs) = if name == funcName \r\n\r\n	                                                      then (varName, funcExpr) \r\n\r\n	                                                      else getFuncValue name funcs\r\n\r\n\r\n\r\ngetVarValue name [] = 0\r\n\r\ngetVarValue name ((varName, varVal):vars) = if name == varName then varVal else getVarValue name vars\r\n\r\n\r\n\r\neval (Num val) _ _ = val\r\n\r\neval (Add e1 e2) vars funcs = (eval e1 vars funcs) + (eval e2 vars funcs)\r\n\r\neval (Mult e1 e2) vars funcs = (eval e1 vars funcs) * (eval e2 vars funcs)\r\n\r\neval (Var name) vars _ = getVarValue name vars\r\n\r\neval (Let varName varVal e) vars funcs = eval e ((varName, varVal) : vars) funcs\r\n\r\neval (LetFunc funcName varName funcExpr e) vars funcs = eval e vars ((funcName, varName, funcExpr) : funcs)\r\n\r\neval (Call funcName e) vars funcs = let\r\n\r\n                                      (varName, funcExpr) = getFuncValue funcName funcs\r\n\r\n                                      varVal = eval e vars funcs\r\n\r\n                                    in eval funcExpr ((varName, varVal) : vars) funcs\r\n','Не удалось вычислить выражение \"eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []\", проверьте правильность синтаксиса'),(8072,112,'3226573','2013-11-27 14:33:02',1,'data Expr = Num Integer | Let String Integer Expr | Add Expr Expr | Mult Expr Expr | Var String deriving Show\r\n\r\ngetValue name [] = 0\r\ngetValue name ((varName, varVal):vars) = if name == varName then varVal else getValue name vars\r\n\r\neval (Num val) _ = val\r\neval (Add e1 e2) vars = (eval e1 vars) + (eval e2 vars)\r\neval (Mult e1 e2) vars = (eval e1 vars) * (eval e2 vars)\r\neval (Var name) vars = getValue name vars\r\neval (Let varName varVal e) vars = eval e ((varName, varVal) : vars)','<br/>Тесты успешно пройдены!'),(8069,116,'MaryK','2013-11-27 13:26:40',1,'toInt churchNum = churchNum (+1) 0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8070,116,'3226573','2013-11-27 13:50:31',1,'toInt g = g (+1) 0','<br/>Тесты успешно пройдены!'),(8071,106,'ilia','2013-11-27 13:52:14',1,'count f = length . filter f -- in one pass!\r\n\r\n\r\n\r\nfindMajor m = let\r\n\r\n		p = fst (make_predict m)\r\n\r\n	in\r\n\r\n		if p /= Nothing && check_predict m p then p\r\n\r\n		else Nothing\r\n\r\n\r\n\r\nmake_predict [ ] = (Nothing, 0)\r\n\r\nmake_predict (mh:m) = let\r\n\r\n		r = make_predict m\r\n\r\n		rf = fst r\r\n\r\n		rs = snd r\r\n\r\n	in\r\n\r\n		if rf == Nothing || rf == Just mh then\r\n\r\n			(Just mh, rs + 1)\r\n\r\n		else if rs == 1 then\r\n\r\n			(Nothing, 0)\r\n\r\n		else\r\n\r\n			(rf, rs - 1)\r\n\r\ncheck_predict m p = (count (mi -> Just mi == p) m) * 2 > length m\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (findMajor [1, 2, 3, 2, 2, 2, 1])\r\n\r\n	print (findMajor [1, 2, 3, 2, 2, 1])\r\n\r\n	print (findMajor [1, 2, 3, 2, 1])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8067,124,'3226573','2013-11-27 13:04:40',1,'up n m = if n <= m then do\r\n		                  print n\r\n		                  up (n + 1) m\r\n		           else return()\r\n\r\n\r\ndown 0 m = up 2 m\r\ndown n m = do\r\n	print n\r\n	down (n - 1) m	\r\n\r\ndownUp n = down n n','<br/>Тесты успешно пройдены!'),(8068,116,'MaryK','2013-11-27 13:26:19',0,'','Не удалось вычислить выражение \"let c3 f x = f (f (f x)) in toInt c3\", проверьте правильность синтаксиса'),(8066,123,'3226573','2013-11-27 12:53:07',1,'find f [] = Nothing\r\nfind f (x:xs) = if f x then Just x else find f xs\r\n\r\nf xs = do\r\n	x <- find (<5) xs\r\n	y <- find (>10) xs\r\n	z <- find (/=7) xs\r\n	return (x + y + z)','<br/>Тесты успешно пройдены!'),(8065,106,'ilia','2013-11-27 11:51:37',0,'findMajor m = fst (findMajor\' m)\n\nfindMajor\' [ ] = (Nothing, 0)\n\nfindMajor\' (mh:m) = let\n\n		r = findMajor\' m\n\n		rf = fst r\n\n		rs = snd r\n\n		mhj = Just mh\n\n	in\n\n		if rf == Nothing || rf == mhj then\n\n			(mhj, rs + 1)\n\n		else if rs == 1 then\n\n			(Nothing, 0)\n\n		else\n\n			(rf, rs - 1)\n\n\n\nmain = do\n\n	print (findMajor [1, 2, 3, 2, 2, 2, 1])\n\n	print (findMajor [1, 2, 3, 2, 2, 1])\n\n\n','Выражение имеет неправильное значение: findMajor [1,2,3,2,1]'),(8064,123,'5543298','2013-11-27 05:17:42',1,'find cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\nf xs = do\r\n\r\n		   x <- find (<5) xs\r\n\r\n		   y <- find (>10) xs\r\n\r\n		   z <- find (/=7) xs\r\n\r\n		   return (x + y + z)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8063,124,'5543298','2013-11-27 04:56:03',1,'downUp n = down n n\r\n\r\n\r\n\r\ndown 1 m = up 1 m   \r\n\r\ndown n m = do \r\n\r\n			print n\r\n\r\n			down (n - 1) m \r\n\r\nup n m = if n == m then print n else do \r\n\r\n										print n\r\n\r\n										up (n + 1) m  \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8062,112,'5543298','2013-11-27 04:01:28',1,'data Expr = Num Integer | Let String Integer Expr | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfind cond ((a,b):xs) = if cond a then b else find cond xs\r\n\r\n\r\n\r\neval (Let var val expr)  xs = eval expr ((var, val):xs)\r\n\r\n\r\n\r\neval (Num a) xs = a\r\n\r\n\r\n\r\neval (Var v) xs = find (==v) xs \r\n\r\n\r\n\r\neval (Add x y) xs = eval x xs + eval y xs\r\n\r\n\r\n\r\neval (Mult x y) xs = eval x xs * eval y xs\r\n','<br/>Тесты успешно пройдены!'),(8060,116,'5543298','2013-11-27 03:35:23',1,'toInt lambda = lambda (x -> x + 1) 0\r\n','<br/>Тесты успешно пройдены!'),(8061,117,'5543298','2013-11-27 03:39:13',1,'toInt lambda = lambda (x -> x + 1) 0\r\n\r\n\r\n\r\ninc lambda = f x -> lambda f (f x)\r\n','<br/>Тесты успешно пройдены!'),(8059,97,'617015','2013-11-26 22:17:46',1,'checkBrackets (x:xs) = cB xs [x]\r\n\r\n\r\n\r\ncB [] stack = stack==[]\r\n\r\ncB (x:xs) [] = cB xs [x]\r\n\r\ncB (x:xs) stack  = if ispair x (head stack) then cB xs (tail stack) else cB xs (x:stack)\r\n\r\n\r\n\r\nispair x y = (x==\')\' && y==\'(\') || (x==\']\' && y==\'[\') \r\n','<br/>Тесты успешно пройдены!'),(8058,106,'5543298','2013-11-26 18:53:34',1,'findMajor\' [] = Nothing\r\n\r\nfindMajor\' (x:xs) = f xs x 1\r\n\r\n\r\n\r\nfindMajor xs = let n = length xs in let r = findMajor\' xs in if (r == Nothing) then Nothing else if checkCond r xs n  then r else Nothing\r\n\r\n\r\n\r\ncheckCond (Just r) xs n = length (filter (==r) xs) * 2 > n\r\n\r\n\r\n\r\nf [] r c = if c > 0 then Just r else Nothing\r\n\r\nf (x:xs) r c = if (x /= r) then if c > 1 then f xs r (c - 1) else findMajor\' xs else f xs r (c + 1)\r\n','<br/>Тесты успешно пройдены!'),(8057,97,'2260659','2013-11-26 02:37:36',1,'bracket s\r\n\r\n	| s == \'(\' = \')\'\r\n\r\n	| s == \'[\' = \']\'\r\n\r\n	| s == \'{\' = \'}\'\r\n\r\n	| s == \'<\' = \'>\'\r\n\r\ncheckBrackets str = checkBr str []\r\n\r\ncheckBr [] [] = True\r\n\r\ncheckBr [] xs = False\r\n\r\ncheckBr str stack \r\n\r\n	| (not (elem (head(str)) \"[]()<>{}\")) = False\r\n\r\n	| (elem (head(str)) \"([{<\") = checkBr (tail(str)) ((bracket (head(str))):stack)\r\n\r\n	| ((elem (head(str)) \")]}>\") && ((stack) /= [])) = ((head(str)) == (head(stack))) && (checkBr (tail(str)) (tail(stack)))\r\n\r\n	| otherwise = False\r\n','<br/>Тесты успешно пройдены!'),(8056,110,'1170660','2013-11-25 18:04:50',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace task_29_2\r\n{\r\n	class Task\r\n	{\r\n		public static int find(Predicate<int> f, int[] a, Func<int> err) \r\n		{\r\n			foreach (int x in a)\r\n			{\r\n				if (f(x))\r\n				{\r\n					return x;\r\n				}\r\n			}\r\n			return err();\r\n		}\r\n		\r\n		public static int find1(int[] a)\r\n		{\r\n			return find(x => x > 1000, a, () => find(x => x > 500, a, () => find(x => x > 100,a,()=>0)));\r\n		}\r\n\r\n		static void Main(string[] args)\r\n		{\r\n			int [] a = { 1, 1, 1, 1};\r\n			int [] b = { 3100, 2133, 2121, 11231};\r\n			int [] c = { 221, 321, 421, 521};\r\n			int [] d = { 1, 1, 121, 1};\r\n			Console.WriteLine(\"{0}\", find1(a));\r\n			Console.WriteLine(\"{0}\", find1(b));\r\n			Console.WriteLine(\"{0}\", find1(c));\r\n			Console.WriteLine(\"{0}\", find1(d));\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(8054,113,'nbumakov','2013-11-25 12:55:14',1,'---Нет, это не CPS стиль.. Например, потому что второе правило не tail revursive\r\n--- Те засчитано (так как неправильные решения тоже засчитываются, но \r\n--- на зачете, например, это будет -. Я бы советовал посмотреть решение с слайдах,\r\n--- которые я завтра выложу - там вроде все более-менее понятно.  \r\nsum_cps [] f = f 0\r\nsum_cps (x:xs) f = f (sum_cps xs (+x))','<br/>Тесты успешно пройдены!'),(8055,111,'nbumakov','2013-11-25 13:16:18',1,'data Expr = Var String | Num Integer | Add Expr Expr | Mult Expr Expr\r\n\r\nvalue vs x = snd (head (filter (v -> fst v == x) vs))\r\nvalue [] _ = 0\r\n\r\neval (Num n) _ = n\r\neval (Var x) vs = value vs x\r\neval (Add s1 s2) vs = eval s1 vs + eval s2 vs\r\neval (Mult m1 m2) vs = eval m1 vs * eval m2 vs','<br/>Тесты успешно пройдены!'),(8053,101,'nbumakov','2013-11-25 12:46:05',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Eq, Show)\r\n\r\nsimplify (Add s1 s2) = Add (simplify s1) (simplify s2)\r\nsimplify (Mult m1 m2) =\r\n    let s1 = simplify m1\r\n        s2 = simplify m2\r\n    in if s1 == Num 0 || s2 == Num 0 then Num 0 else Mult s1 s2\r\nsimplify e = e','<br/>Тесты успешно пройдены!'),(8052,118,'nbumakov','2013-11-25 12:37:10',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 xs = f2 (snd (f1 xs))','<br/>Тесты успешно пройдены!'),(8049,115,'ip','2013-11-25 10:20:17',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\n\r\n\r\nf xs = let a =  ([(<5),(>10),(/=7)] >>= (g -> find g xs)) \r\n\r\n       in if ((length  a) < 3)\r\n\r\n          then []\r\n\r\n          else sum (([(<5),(>10),(/=7)] >>= (g -> find g xs)) ) : []\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8050,114,'nbumakov','2013-11-25 11:44:23',1,'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return (y*y)\r\ntriangle2 n = do x <- [1..n]\r\n                 y <- [1..x]\r\n                 return (y*y)','<br/>Тесты успешно пройдены!'),(8051,115,'nbumakov','2013-11-25 12:22:58',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = let x1 = find (<5) xs\r\n           x2 = find (>10) xs\r\n           x3 = find (/=7) xs \r\n        in if null x1 then x1\r\n           else if null x2 then x2\r\n           else if null x3 then x3\r\n           else return (sum (concat [x1, x2, x3]))\r\n     ','<br/>Тесты успешно пройдены!'),(8048,113,'ip','2013-11-25 10:10:00',1,'sum_cps (x:[]) f = f x\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8047,101,'ip','2013-11-25 10:09:37',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n                                                       deriving Show\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncheck (Num x) = (x == 0)\r\n\r\ncheck z = False\r\n\r\n\r\n\r\nsimplify (Num i) = (Num i)\r\n\r\nsimplify X = X\r\n\r\nsimplify (Add a b) = (Add (simplify a) (simplify b)  ) \r\n\r\nsimplify (Mult a (Num 0)) = (Num 0)\r\n\r\nsimplify (Mult (Num 0) b) = (Num 0)\r\n\r\nsimplify (Mult a b) = let x = (simplify a) \r\n\r\n                          y = (simplify b) \r\n\r\n                      in if (check x || check y)\r\n\r\n                         then ( simplify (Mult x y  ) )\r\n\r\n                         else (Mult x y  )\r\n\r\n \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8046,101,'ip','2013-11-25 10:00:27',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \n\n                                                       deriving Show\n\n\n\n\n\nsimplify (Num i) = (Num i)\n\nsimplify X = X\n\nsimplify (Add a b) = (Add (simplify a) (simplify b)  ) \n\nsimplify (Mult a (Num 0)) = (Num 0)\n\nsimplify (Mult (Num 0) b) = (Num 0)\n\nsimplify (Mult a b) = let x = (simplify a) \n\n                          y = (simplify b) \n\n                      in simplify (Mult x y  )\n\n \n\n\n\n\n','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(8045,101,'ip','2013-11-25 09:57:04',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \n\n                                                       deriving Show\n\n\n\n\n\nsimplify (Num i) = (Num i)\n\nsimplify X = X\n\nsimplify (Add a b) = (Add (simplify a) (simplify b)  ) \n\nsimplify (Mult a (Num 0)) = (Num 0)\n\nsimplify (Mult (Num 0) b) = (Num 0)\n\nsimplify (Mult a b) = simplify (Mult (simplify a) (simplify b)  )\n\n\n','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(8044,101,'ip','2013-11-25 09:54:03',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \n\n                                                       deriving Show\n\n\n\n\n\nsimplify (Num i) = (Num i)\n\nsimplify X = X\n\nsimplify (Add a b) = (Add (simplify a) (simplify b)  ) \n\nsimplify (Mult a (Num 0)) = (Num 0)\n\nsimplify (Mult (Num 0) b) = (Num 0)\n\nsimplify (Mult a b) = (Mult (simplify a) (simplify b)  )\n\n\n','Выражение имеет неправильное значение: simplify (Mult X (Mult X (Num 0)))'),(8043,111,'ip','2013-11-25 09:53:29',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n\r\n                                                       deriving Show\r\n\r\n\r\n\r\n\r\n\r\neval (Num i) xs = i\r\n\r\neval (Var x) xs = last( xs >>= ((a,b) -> if (a==x)\r\n\r\n                                    	  then [b]\r\n\r\n                                  	  else [] ))\r\n\r\n \r\n\r\neval (Add a b) xs = (eval a xs) + (eval b xs) \r\n\r\neval (Mult a b) xs = (eval a xs) * (eval b xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8039,114,'ip','2013-11-25 09:49:29',1,'\r\ntriangle1 n = [1..n] >>= (x -> ([1..x] >>= (	 -> return (t*t) )))\r\n\r\n\r\n\r\ntriangle2 n = do x <- [1..n]\r\n\r\n    		 t <- [1..x]\r\n\r\n    		 return (t*t)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8040,115,'ip','2013-11-25 09:50:00',0,'find cond [] = []\n\nfind cond (x:xs) = if cond x then [x] else find cond xs\n\n\n\n\n\nf xs = sum ([(<5),(>10),(/=7)] >>= (g -> find g xs))\n\n\n','Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),(8041,115,'ip','2013-11-25 09:52:42',0,'find cond [] = []\n\nfind cond (x:xs) = if cond x then [x] else find cond xs\n\n\n\n\n\nf xs = (sum ([(<5),(>10),(/=7)] >>= (g -> find g xs)) ) :[]\n\n\n','<br/>Тесты успешно пройдены!'),(8042,118,'ip','2013-11-25 09:53:02',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n\r\n\r\na >>> b = (xs -> b(snd(a xs)))\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8038,111,'1595828','2013-11-25 08:42:35',1,'data Expr = Var String|Num Integer | Env String Int Expr | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (Num n) _ = n\r\n\r\neval (Add a1 a2) n = eval a1 n +eval a2 n\r\n\r\neval (Mult m1 m2) n = eval m1 n *eval m2 n\r\n\r\neval (Var str) ((x,y):xs) = if (x ==str) then y else eval (Var str) xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8036,113,'1990147','2013-11-25 04:34:11',2,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs f1 where f1 i = f (x + i)\r\n','<br/>Тесты успешно пройдены!'),(8037,101,'1595828','2013-11-25 08:23:46',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Show,Eq)\r\n\r\nsimplify (Add a1 a2) = Add (simplify a1) (simplify a2)\r\n\r\nsimplify (Mult m1 m2) = if (((simplify m1) == Num 0) || ((simplify m2) == Num 0))  then Num 0 else Mult (simplify m1) (simplify m2)\r\n   ---Так у вас неэффективно, вы по два раза вызываете simplify. Лучше, конечно, воспользоваться let \r\n\r\nsimplify e = e \r\n','<br/>Тесты успешно пройдены!'),(8035,101,'1990147','2013-11-25 04:25:06',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nsimplify (X) = X\r\n\r\nsimplify (Num x) = Num x\r\n\r\nsimplify (Add l r) = (Add (simplify l) (simplify r))\r\n\r\nsimplify (Mult (Num 0) r) = (Num 0)\r\n\r\nsimplify (Mult l (Num 0)) = (Num 0)\r\n\r\nsimplify (Mult l r) = let l\' = (simplify l) \r\n\r\n                          r\' = (simplify r)\r\n\r\n                       in if(l\'==Num 0 || r\'==Num 0) then Num 0\r\n\r\n                                                   else Mult l\' r\'\r\n\r\ninstance Eq Expr where\r\n\r\n         X == Num y = False\r\n\r\n         Num x == Num y = x==y\r\n\r\n         Mult _ _==Num x = False\r\n\r\n         Add _ _==Num x = False\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8033,111,'1990147','2013-11-25 04:03:54',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n\r\n\r\n\r\ninstance Show Expr where\r\n\r\n         show (Num a) = show a \r\n\r\n         show (Var x) = x\r\n\r\n         show (Add l r) = show l ++\"+\"++ show r\r\n\r\n         show (Mult l r) = show l ++\"*\"++ show r\r\n\r\n\r\n\r\nfindval x (val:xsval) =  if (x==fst val) then snd val\r\n\r\n                                         else findval x xsval\r\n\r\n\r\n\r\neval (Var x) val = (findval x val)\r\n\r\neval (Num x) val = x\r\n\r\neval (Add a b) val = (eval a val) + (eval b val)\r\n\r\neval (Mult a b) val = (eval a val) * (eval b val)\r\n','<br/>Тесты успешно пройдены!'),(8034,101,'1990147','2013-11-25 04:21:02',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\nsimplify (X) = X\r\n\nsimplify (Num x) = Num x\r\n\nsimplify (Add l r) = (Add (simplify l) (simplify r))\r\n\nsimplify (Mult (Num 0) r) = (Num 0)\r\n\nsimplify (Mult l (Num 0)) = (Num 0)\r\n\nsimplify (Mult l r) = let l\' = (simplify l) \r\n\n                          r\' = (simplify r)\r\n\n                       in if(l\'==Num 0 || r\'==Num 0) then Num 0\r\n\n                                                   else Mult l\' r\'\r\n\ninstance Eq Expr where\r\n\n         X == Num y = False\r\n\n         Num x == Num y = x==y\r\n\n\r\n\n\n','Не удалось вычислить выражение \"simplify (Mult (Mult X X) (Mult X X))\", проверьте правильность синтаксиса'),(8030,118,'641524','2013-11-25 03:40:03',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nf1 >>> f2 = f2.snd.f1\r\n\r\n\r\n\r\nf = find (>3) >>> find (>3) \r\n','<br/>Тесты успешно пройдены!'),(8031,113,'641524','2013-11-25 03:54:45',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n','<br/>Тесты успешно пройдены!'),(8032,111,'SNNatalieS','2013-11-25 03:55:45',1,'data Expr = Num Int | Var String | Add Expr Expr | Mult Expr Expr\r\n				deriving (Show, Eq)\r\n\r\neval (Num i) _ = i\r\neval (Var t) (x:xs) = if (fst x) == t \r\n						then snd x \r\n						else eval (Var t) xs\r\neval (Add x y) n = (eval x n) + (eval y n)\r\neval (Mult x y) n = (eval x n) * (eval y n)\r\n','<br/>Тесты успешно пройдены!'),(8027,113,'toskira','2013-11-25 03:05:14',1,'sum_cps [] f = f 0\r\nsum_cps (h:t) f = sum_cps t (f.(h+))','<br/>Тесты успешно пройдены!'),(8028,113,'SNNatalieS','2013-11-25 03:18:56',1,'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps  xs (	 -> f (t + x))','<br/>Тесты успешно пройдены!'),(8029,118,'1990147','2013-11-25 03:38:16',1,'a >>> b = (a.snd.b)\r\n\r\n\r\n\r\n\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8026,106,'MaryK','2013-11-25 03:00:37',1,'ch\' [] _ counter = counter > 0\r\n\r\nch\' (x:xs) y counter = if x == y then ch\' xs y (counter + 1) else ch\' xs y (counter - 1)\r\n\r\n\r\n\r\nch _ Nothing = Nothing\r\n\r\nch xs (Just x) = if ch\' xs x 0 then Just x else Nothing\r\n\r\n\r\n\r\nfindMajor\' [] res _ = res\r\n\r\nfindMajor\' (x:xs) Nothing 0 = findMajor\' xs (Just x) 1\r\n\r\nfindMajor\' (x:xs) (Just y) k = if x == y\r\n\r\n                               then findMajor\' xs (Just y) (k + 1)\r\n\r\n                               else if k > 1\r\n\r\n                                    then findMajor\' xs (Just y) (k - 1)\r\n\r\n                                    else findMajor\' xs Nothing 0\r\n\r\n\r\n\r\nfindMajor xs = ch xs (findMajor\' xs Nothing 0)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8025,106,'MaryK','2013-11-25 02:58:56',0,'ch\' [] _ counter = counter > 0\r\n\nch\' (x:xs) y counter = if x == y then ch\' xs y (counter + 1) else \r\n\nch\' xs y (counter - 1)\r\n\n\r\n\nch _ Nothing = Nothing\r\n\nch xs (Just x) = if ch\' xs x 0 then Just x else Nothing\r\n\n\r\n\nfindMajor\' [] res _ = res\r\n\nfindMajor\' (x:xs) Nothing 0 = findMajor\' xs (Just x) 1\r\n\nfindMajor\' (x:xs) (Just y) k =if x == y\r\n\n                               then findMajor\' xs (Just y) (k + 1)\r\n\n                               else if k > 1\r\n\n                                    then findMajor\' xs (Just y) (k - 1)\r\n\n                                    else findMajor\' xs Nothing 0\r\n\n\r\n\nfindMajor xs = ch xs (findMajor\' xs Nothing 0)\r\n\n\n','Не удалось вычислить выражение \"findMajor [1,2,3,2,2,2,1]\", проверьте правильность синтаксиса'),(8013,114,'MaryK','2013-11-25 02:08:06',1,'concat1 xss = xss >>= id\r\n\r\n\r\n\r\ntriangle1 n = concat1 ([1..n] >>= i -> return ([1..i] >>= i -> [i * i]) )\r\n\r\n\r\n\r\ntriangle2 n = \r\n\r\n    do \r\n\r\n        i <- [1..n]\r\n\r\n        j <- [1..i]\r\n\r\n        [j * j]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8014,113,'480387','2013-11-25 02:13:01',1,'sum_cps (l:[]) f = f l\r\nsum_cps (l:ls) f = sum_cps ls (i->f(i+l))','<br/>Тесты успешно пройдены!'),(8015,118,'1990147','2013-11-25 02:13:09',0,'','Не удалось вычислить выражение \"let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]\", проверьте правильность синтаксиса'),(8016,115,'toskira','2013-11-25 02:22:01',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf l = let res = ([(<5), (>10), (/=7)] >>= c -> find c l)\r\n      in  if (length res) /= 3\r\n          then []\r\n          else [sum res]','<br/>Тесты успешно пройдены!'),(8017,111,'MaryK','2013-11-25 02:30:57',0,'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr\r\n\n\r\n\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\n\ngetValue [] _ = 0\r\n\n\r\n\neval (Var x) vars = getValue vars x\r\n\neval (N n) _ = n\r\n\neval (Add str1 str2) n = eval str1 n + eval str2 n\r\n\neval (Mult ex1 ex2) n = eval ex1 n * eval ex2 n\r\n\neval (Let x val e) vars = eval e ((x, val) : vars)\r\n\n\r\n\n\r\n\n\r\n\n\n','Не удалось вычислить выражение \"eval (Add (Var [\'x\']) (Mult (Var [\'y\']) (Num 3))) [([\'x\'], 5), ([\'y\'], 8)]\", проверьте правильность синтаксиса'),(8018,118,'toskira','2013-11-25 02:33:08',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\na >>> b = b.snd.a','<br/>Тесты успешно пройдены!'),(8019,111,'toskira','2013-11-25 02:44:24',1,'data Expr = Num Int\r\n          | Var String\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n\r\nfind v ((a, b):t) = if(v == a) then b else find v t\r\n\r\neval (Num a) _ = a\r\neval (Var v) l = find v l\r\neval (Add e1 e2) l = (eval e1 l) + (eval e2 l)\r\neval (Mult e1 e2) l = (eval e1 l) * (eval e2 l)','<br/>Тесты успешно пройдены!'),(8020,111,'MaryK','2013-11-25 02:49:01',0,'data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr \r\n\n\r\n\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\n\ngetValue [] _ = 0\r\n\n\r\n\neval (Var x) vars = getValue vars x\r\n\neval (N n) _ = n\r\n\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\n\neval (Mult m1 m2) n = eval m1 n * eval m2 n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\n','Не удалось вычислить выражение \"eval (Add (Var [\'x\']) (Mult (Var [\'y\']) (Num 3))) [([\'x\'], 5), ([\'y\'], 8)]\", проверьте правильность синтаксиса'),(8021,111,'MaryK','2013-11-25 02:50:57',1,'data Expr = Var String | Num Integer | Add Expr Expr | Mult Expr Expr \r\n\r\n\r\n\r\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\n\r\ngetValue [] _ = 0\r\n\r\n\r\n\r\neval (Var x) vars = getValue vars x\r\n\r\neval (Num n) _ = n\r\n\r\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\n\r\neval (Mult m1 m2) n = eval m1 n * eval m2 n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8022,114,'641524','2013-11-25 02:52:03',1,'triangle1 n = \r\n\r\n   [1..n] >>= x ->\r\n\r\n      [1..x] >>= y ->\r\n\r\n         return (y*y)\r\n\r\n\r\n\r\ntriangle2 n =\r\n\r\n   do x <- [1..n]\r\n\r\n      y <- [1..x]\r\n\r\n      [y*y]\r\n','<br/>Тесты успешно пройдены!'),(8023,113,'MaryK','2013-11-25 02:52:15',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = f (sum_cps xs (+x))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8024,101,'toskira','2013-11-25 02:58:07',1,'data Expr = Num Int\r\n          | Var String\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n          | X\r\n    deriving Show\r\n\r\nfind v ((a, b):t) = if(v == a) then b else find v t\r\n\r\n\r\nsimplifyMult (Mult (Num 0) e) = Num 0\r\nsimplifyMult (Mult e (Num 0)) = Num 0\r\nsimplifyMult a = a\r\n\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\nsimplify (Mult e1 e2) = let se1 = simplify e1\r\n                            se2 = simplify e2\r\n                        in  simplifyMult (Mult se1 se2)\r\nsimplify a = a','<br/>Тесты успешно пройдены!'),(8000,114,'MaryK','2013-11-25 00:24:03',0,'concat1 xss = xss >>= id\r\n\n\r\n\ntriangle1 n = concat1 ([1..n] >>= i -> return [1..i])\r\n\ntriangle2 n = concat1 (do i <- [1..n] return [1..i])\r\n\n\r\n\n\n','Не удалось вычислить выражение \"triangle1 3\", проверьте правильность синтаксиса'),(8001,114,'MaryK','2013-11-25 00:24:45',0,'concat1 xss = xss >>= id\r\n\n\r\n\ntriangle1 n = concat1 ([1..n] >>= i -> return [1..i])\r\n\ntriangle2 n =\r\n\n    concat1 (do i <- [1..n]\r\n\n                return [1..i])\r\n\n\r\n\n\r\n\n\n','Выражение имеет неправильное значение: triangle1 3'),(8002,118,'MaryK','2013-11-25 00:46:48',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>) f1 f2 xs = let (y, ys) = f1 xs in f2 ys\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8003,111,'MaryK','2013-11-25 01:01:04',0,'data Expr = Var String |N Integer |Add Expr Expr |Mult Expr Expr\r\n\ngetValue ((v, val):vars) x = if x == v then val else getValue vars x\r\n\ngetValue [] _ = 0\r\n\n\r\n\neval (Var x) vars = getValue vars x\r\n\neval (N n) _ = n\r\n\neval (Add str1 str2) n = eval str1 n + eval str1 n\r\n\neval (Mult ex1 ex2) n = eval ex1 n * eval ex2 n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\n','Не удалось вычислить выражение \"eval (Add (Var [\'x\']) (Mult (Var [\'y\']) (Num 3))) [([\'x\'], 5), ([\'y\'], 8)]\", проверьте правильность синтаксиса'),(8004,114,'1990147','2013-11-25 01:08:50',1,'triangle1 n = [1..n] >>= x-> [1..x] >>= i -> return (i*i)\r\n\r\ntriangle2 n = do x<-[1..n]\r\n\r\n                 i<-[1..x]\r\n\r\n                 return (i*i)\r\n','<br/>Тесты успешно пройдены!'),(8005,101,'anna','2013-11-25 01:13:50',0,'data Expr = X | Num Integer | Add Expr Expr | Mult Expr Expr deriving (Eq, Show)\n\nsimplify (Add x1 x2) = Add (simplify x1) (simplify x2)\n\nsimplify (Mult x1 x2) =\n\n    let\n\n      expr1 = simplify x1\n\n      expr2 = simplify x2\n\n    in if x1 == Num 0 || x2 == Num 0 then Num 0 else Mult x1 x2\n\nsimplify x = x\n\n\n','Выражение имеет неправильное значение: simplify (Mult X (Mult X (Num 0)))'),(8006,114,'480387','2013-11-25 01:40:57',1,'triangle1 n = [1..n] >>= (i -> ([1..i] >>= (p->[p^2])))\r\ntriangle2 n = do\r\n		 i<-[1..n]\r\n		 p<-[1..i]\r\n		 [p^2]','<br/>Тесты успешно пройдены!'),(8007,101,'anna','2013-11-25 01:41:59',1,'data Expr = X | Num Integer | Add Expr Expr | Mult Expr Expr deriving (Eq, Show)\r\n\r\nsimplify (Add x1 x2) = Add (simplify x1) (simplify x2)\r\n\r\nsimplify (Mult x1 x2) =\r\n\r\n    let\r\n\r\n      expr1 = simplify x1\r\n\r\n      expr2 = simplify x2\r\n\r\n    in if expr1 == Num 0 || expr2 == Num 0 then Num 0 else Mult x1 x2\r\n\r\nsimplify e = e\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8008,114,'MaryK','2013-11-25 01:48:44',0,'concat1 xss = xss >>= id\r\n\ntriangle1 n = concat1([1..n] >>= i -> return([1..i] >>= i -> [i*i]))\r\n\ntriangle2 n = concat1 (do\r\n\n		i <- [1..n] \r\n\n		return (concat1 (do \r\n\n		i <- [1..i] \r\n\n		return [i * i]\r\n\n		)))\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\n','<br/>Тесты успешно пройдены!'),(8009,115,'480387','2013-11-25 01:54:50',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf ls = let rs = find (<5) ls ++ (find (>10) ls) ++ (find (/=7) ls) in if (length rs /= 3) then [] else ([sum rs])\r\n        ','<br/>Тесты успешно пройдены!'),(8010,113,'anna','2013-11-25 01:58:28',1,'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = f (sum_cps xs (+x))','<br/>Тесты успешно пройдены!'),(8011,114,'toskira','2013-11-25 02:01:53',1,'triangle1 n = [1..n] >>= a -> [1..a] >>=  -> return (b*b)\r\n\r\ntriangle2 n = do a <- [1..n]\r\n                 b <- [1..a]\r\n                 [b*b]','<br/>Тесты успешно пройдены!'),(8012,115,'1990147','2013-11-25 02:03:07',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let a = find (<5) xs\r\n\r\n           b = find (>10) xs\r\n\r\n           c = find (/=7) xs\r\n\r\n       in if(a/=[] && b/=[] && c/=[]) then [head a + head b + head c]\r\n\r\n                                      else []\r\n','<br/>Тесты успешно пройдены!'),(7996,111,'anna','2013-11-25 00:19:05',1,'data Expr = Var String | Num Integer | Add Expr Expr | Mult Expr Expr\r\nf ((var, val):vars) x = if x == var then val else f vars x\r\nf [] _ = 0\r\n\r\neval (Var x) vars = f vars x\r\neval (Num n) _ = n\r\neval (Add x1 x2) n = eval x1 n + eval x2 n\r\neval (Mult x1 x2) n = eval x1 n * eval x2 n','<br/>Тесты успешно пройдены!'),(7997,115,'MaryK','2013-11-25 00:20:59',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let res = concat [find (<5) xs, find (>10) xs, find (/=7) xs] in if length res == 3 then return (sum res) else []\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7998,114,'MaryK','2013-11-25 00:22:45',0,'','Не удалось вычислить выражение \"triangle1 3\", проверьте правильность синтаксиса'),(7999,114,'MaryK','2013-11-25 00:23:10',0,'concat1 xss = xss >>= id\r\n\n\r\n\ntriangle1 n = concat1 ([1..n] >>= i -> return [1..i])\r\n\ntriangle2 n = concat1 (do i <- [1..n] return [1..i])\r\n\n\r\n\n\n','Не удалось вычислить выражение \"triangle1 3\", проверьте правильность синтаксиса'),(7986,115,'62628590','2013-11-24 23:31:04',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = let res = concat [find (<5) xs, find (>10) xs, find (/=7) xs] in if length res == 3 then return (sum res) else []','<br/>Тесты успешно пройдены!'),(7987,118,'62628590','2013-11-24 23:31:31',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 xs = let (y, ys) = f1 xs in f2 ys','<br/>Тесты успешно пройдены!'),(7988,111,'62628590','2013-11-24 23:31:56',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\r\ngetValue [] _ = 0\r\ngetValue ((v, val) : vars) x = if x==v then val else getValue vars x\r\n\r\neval (Num n) _ = n\r\neval (Var x) vars = getValue vars x\r\neval (Add a b) n = eval a n + eval b n\r\neval (Mult a b) n = eval a n * eval b n','<br/>Тесты успешно пройдены!'),(7989,101,'62628590','2013-11-24 23:32:57',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimplify X = X\r\nsimplify (Num n) = Num n \r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult a b) = simplify (Mult (simplify a) (simplify b))','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(7990,101,'62628590','2013-11-24 23:35:38',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimplify X = X\r\nsimplify (Num n) = Num n \r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult X X) = Mult X X\r\nsimplify (Mult a b) = simplify (Mult (simplify a) (simplify b))','Не удалось вычислить выражение \"simplify (Mult (Mult X X) (Mult X X))\", проверьте правильность синтаксиса'),(7991,113,'62628590','2013-11-24 23:37:48',1,'sum_cps [] f= f 0\r\nsum_cps (x:xs) f = f (sum_cps xs (+x))','<br/>Тесты успешно пройдены!'),(7992,101,'62628590','2013-11-24 23:40:44',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimplify X = X\r\nsimplify (Num n) = Num n \r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult X X) = Mult X X\r\nsimplify (Mult a b) = simp (Mult (simplify a) (simplify b))\r\nsimp (Mult a b) = Mult (simplify a) (simplify b)','Выражение имеет неправильное значение: simplify (Mult X (Mult X (Num 0)))'),(7993,101,'62628590','2013-11-24 23:43:43',1,'--- ОК, очень хорошо, но см замечание ниже.\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\nsimpli€fy X = X\r\nsimplify (Num n) = Num n \r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult X X) = Mult X X\r\n  --- Это правило, мне кажется, следует из следующего.\r\nsimplify (Mult a b) = simp (Mult (simplify a) (simplify b))\r\nsimp X = X\r\nsimp (Num n) = Num n \r\nsimp (Add a b) = Add (simplify a) (simplify b)\r\nsimp (Mult _ (Num 0)) = Num 0\r\nsimp (Mult (Num 0) _) = Num 0\r\nsimp (Mult X X) = Mult X X\r\nsimp (Mult a b) = Mult (simplify a) (simplify b)\r\n   --- Последние два правила можно заменить просто на simp a = a\r\n   --- Вызывать simplify тут не надо, потому что перед вызоваом simp мы уде заранее упростили. ','<br/>Тесты успешно пройдены!'),(7994,113,'SNNatalieS','2013-11-24 23:58:37',0,'sum_cps  [] f = f\r\nsum_cps (x:xs) f = sum_cps xs (	 -> f (t + x))','Не удалось вычислить выражение \"sum_cps [1,2,3] (^2)\", проверьте правильность синтаксиса'),(7995,106,'1990147','2013-11-25 00:01:15',1,'findMajor [] = Nothing\r\n\r\nfindMajor (i:xs) = let x = finder i 1 xs\r\n\r\n                   in trymax x (i:xs) 0\r\n\r\n\r\n\r\nfinder x _ [] = x\r\n\r\nfinder now col (i:xs) = if (col == 0) then finder i 1 xs\r\n\r\n                        else if (i==now) then finder now (col+1) xs\r\n\r\n                             else finder now (col-1) xs\r\n\r\n\r\n\r\ntrymax x [] col= if (col>0) then Just x else Nothing\r\n\r\ntrymax x (i:xs) col= if (x==i) then trymax x xs (col+1) else trymax x xs (col-1)\r\n','<br/>Тесты успешно пройдены!'),(7985,114,'62628590','2013-11-24 23:30:16',1,'xF\' xss = xss>>= xs -> xs >>= x -> [x*x]\r\ntriangle1 n = xF\' ([1..n] >>= i -> return [1..i])\r\ntriangle2 n = \r\n	xF\' (do i <- [1..n]\r\n		return [1..i])','<br/>Тесты успешно пройдены!'),(7984,99,'5543298','2013-11-24 23:16:01',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        enum ExpressionType\r\n\r\n        {\r\n\r\n            Num,\r\n\r\n            Add,\r\n\r\n            Mult,\r\n\r\n            X\r\n\r\n        }\r\n\r\n\r\n\r\n        abstract class Expression\r\n\r\n        {\r\n\r\n            public ExpressionType Type { get; private set; }\r\n\r\n\r\n\r\n            protected Expression(ExpressionType type)\r\n\r\n            {\r\n\r\n                Type = type;\r\n\r\n            }\r\n\r\n\r\n\r\n            public abstract Expression Diff();\r\n\r\n\r\n\r\n            public new abstract String ToString();\r\n\r\n        }\r\n\r\n\r\n\r\n        class X : Expression\r\n\r\n        {\r\n\r\n            public X() : base(ExpressionType.X)\r\n\r\n            {\r\n\r\n                \r\n\r\n            }\r\n\r\n\r\n\r\n            public override Expression Diff()\r\n\r\n            {\r\n\r\n                return new Num(1);\r\n\r\n            }\r\n\r\n\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return \"X\";\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class Num : Expression\r\n\r\n        {\r\n\r\n            public int Value { get; private set; }\r\n\r\n\r\n\r\n            public Num(int value)\r\n\r\n                : base(ExpressionType.Num)\r\n\r\n            {\r\n\r\n                Value = value;\r\n\r\n            }\r\n\r\n\r\n\r\n            public override Expression Diff()\r\n\r\n            {\r\n\r\n                return new Num(0);\r\n\r\n            }\r\n\r\n\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return String.Format(\"Num {0}\", Value);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class Mult : Expression\r\n\r\n        {\r\n\r\n            public Expression Left { get; private set; }\r\n\r\n            \r\n\r\n            public Expression Right { get; private set; }\r\n\r\n\r\n\r\n            public Mult(Expression left, Expression right)\r\n\r\n                : base(ExpressionType.Mult)\r\n\r\n            {\r\n\r\n                Left = left;\r\n\r\n                Right = right;\r\n\r\n            }\r\n\r\n\r\n\r\n            public override Expression Diff()\r\n\r\n            {\r\n\r\n                return new Add(new Mult(Left.Diff(), Right), new Mult(Left, Right.Diff()));\r\n\r\n            }\r\n\r\n\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return String.Format(\"Mult ({0}) ({1})\", Left.ToString(), Right.ToString());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        class Add : Expression\r\n\r\n        {\r\n\r\n            public Expression Left { get; private set; }\r\n\r\n            \r\n\r\n            public Expression Right { get; private set; }\r\n\r\n\r\n\r\n            public Add(Expression left, Expression right)\r\n\r\n                : base(ExpressionType.Add)\r\n\r\n            {\r\n\r\n                Left = left;\r\n\r\n                Right = right;\r\n\r\n            }\r\n\r\n\r\n\r\n            public override Expression Diff()\r\n\r\n            {\r\n\r\n                return new Add(Left.Diff(), Right.Diff());\r\n\r\n            }\r\n\r\n\r\n\r\n            public override string ToString()\r\n\r\n            {\r\n\r\n                return String.Format(\"Add ({0}) ({1})\", Left.ToString(), Right.ToString());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"34.2\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(\"diff (Mult X X) = {0}\", new Mult(new X(), new X()).Diff().ToString());\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"34.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(\"facts_cps(3, x => x * x) = {0}\", fact_cps(3, x => x * x));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"31.1\":\r\n\r\n                    {\r\n\r\n                        var arr1 = new int[] { 1, 2, 3, 5, 6, 20, 21 };\r\n\r\n                        var arr2 = new int[] { 1, 2, 3, 5, 6, 20, 21 };\r\n\r\n                        var arr3 = new int[] { 1, 2, 3, 5, 6, 20, 21, 101 };\r\n\r\n                        var res1 = find(x => x > 20, arr1, () => 0);\r\n\r\n                        // Ищем число >20, а если не найдем, возвращаем 0\r\n\r\n                        var res2 = find(x => x > 20, arr2, () =>\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(\"Not found\");\r\n\r\n                            return 0;\r\n\r\n                        });\r\n\r\n                        // Ищем число >20, а если не найдем, печатаем сообщение и возвращаем 0\r\n\r\n                        var res3 = find (x => x > 1000, arr3, () => find (x => x > 500, arr3, () => find(x => x > 100, arr3, () => 0)));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"28.1\":\r\n\r\n                    {\r\n\r\n                        allDiffLists(3, 2)();\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"26.1\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8, 9, 10 };\r\n\r\n                        int[] b = { 3, 5, 9, 5, 6 };\r\n\r\n                        Console.WriteLine(allDifferent(a));\r\n\r\n                        Console.WriteLine(allDifferent(b));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"26.2\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8 };\r\n\r\n                        int[] b = { 3, 5, 9 };\r\n\r\n                        foreach (int i in Merge(a, b))\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"23.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var num in Lst137())\r\n\r\n                        {\r\n\r\n                            Console.Write(\"{0}, \", num);\r\n\r\n                            k++;\r\n\r\n                            if (k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"20.2\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var pair in cantor())\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(pair);\r\n\r\n                            k++;\r\n\r\n                            if (k == 50)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int fact_cps(int i, Func<int, int> f)\r\n\r\n        {\r\n\r\n            if (i == 0)\r\n\r\n                return f(1);\r\n\r\n            return fact_cps(i-1, x => f(x * i));\r\n\r\n        }\r\n\r\n\r\n\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err) \r\n\r\n        {\r\n\r\n            foreach (var i in a)\r\n\r\n            {\r\n\r\n                if (func(i))\r\n\r\n                    return i;\r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static Action allDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            Action print = () => { };\r\n\r\n            Predicate<int> set = t => true;\r\n\r\n            allDiffLists(print, set, 1, n, k);\r\n\r\n            return print;\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void allDiffLists(Action print, Predicate<int> set, int current, int n, int k)\r\n\r\n        {\r\n\r\n            \r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (a.Length == from)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            var x = a[from];\r\n\r\n            if (!cond(x))\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            return allDifferent1(a, ++from, t => cond(t) && t != x);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var result = new List<int>();\r\n\r\n            var aen = a.GetEnumerator();\r\n\r\n            var ben = b.GetEnumerator();\r\n\r\n            var isAEmpty = !aen.MoveNext();\r\n\r\n            var isBEmpty = !ben.MoveNext();\r\n\r\n            int x, y;\r\n\r\n            while (!isAEmpty && !isBEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                y = ben.Current;\r\n\r\n                if (x < y)\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                }\r\n\r\n                else if (y < x)\r\n\r\n                {\r\n\r\n                    result.Add(y);\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                } \r\n\r\n                else\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            while (!isAEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                result.Add(x);\r\n\r\n                isAEmpty = !aen.MoveNext();\r\n\r\n            }\r\n\r\n            while (!isBEmpty)\r\n\r\n            {\r\n\r\n                y = ben.Current;\r\n\r\n                result.Add(y);\r\n\r\n                isBEmpty = !ben.MoveNext();\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                var next = i * 10;\r\n\r\n                yield return next + 1;\r\n\r\n                yield return next + 3;\r\n\r\n                yield return next + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var resPowN = new BigInteger(0);\r\n\r\n            var left = new BigInteger(1);\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                left *= 10;\r\n\r\n                var min = left - resPowN * 10 * n;\r\n\r\n                var minIndex = 0;\r\n\r\n                for (int j = 1; j < 10; j++)\r\n\r\n                {\r\n\r\n                    var current = left - (resPowN * 10 + j) * n;\r\n\r\n                    if (current < min && current > 0)\r\n\r\n                    {\r\n\r\n                        min = current;\r\n\r\n                        minIndex = j;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                resPowN = resPowN * 10 + minIndex;\r\n\r\n                yield return minIndex;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4900,23,'62628590','2013-09-13 00:07:17',1,'nod x y\r\n	|x<y = nod y x\r\n	|x==y = x\r\n	|otherwise = nod y (x-y)\r\nc n = c0 n n 1\r\nc0 n m l\r\n	|n==0 = 1\r\n	|m==0 = 0\r\n	|n<m = c0 n n l\r\n	|nod m l==1 =c0 n (m-1) l + c0 (n-m) (m-1) (m*l)\r\n	|otherwise = c0 n (m-1) l','<br/>Тесты успешно пройдены!'),(4899,30,'romos2007','2013-09-13 00:05:08',1,'{--\r\n\r\nЗадача 4-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nparts [x] = True 	-- очевидно, один элемент сам по себе упорядоченный\r\n\r\nparts xs = p 2 xs (length xs) --начинаем с шагом 2 идти по массиву и проверять двойки элементов на упорядоченность.\r\n\r\n\r\n\r\n-- Потом шаг увеличиваем след.образом:\r\n\r\n\r\n\r\np c xs len_xs = if (c*2 > len_xs) then chkGrowth len_xs len_xs xs else -- Если шаг стал больше половины,\r\n\r\n												--то уже не найдем одинаковые части массива. Есть смысл рассмотреть лишь его целиком\r\n\r\n					if (mod len_xs c /= 0) then p (c+1) xs len_xs -- Если длина массива не делится на шаг, то сразу увеличиваем шаг на 1\r\n\r\n						else chkGrowth c c xs || p (c+1) xs len_xs -- Если можно разделить массив, то проверяем упорядоченность с текущим шагом\r\n\r\n																	-- и не забываем учесть возможность успеха в следующих разложениях\r\n\r\n\r\n\r\n--ф-ция проверки упорядоченности кусков массива длины step.\r\n\r\nchkGrowth _ _ [] = True\r\n\r\nchkGrowth s step (xs) = if (s > 1) then --на текущем этапе s - сколько осталось элементов текущего кусочка. Step - хранит начальный размер кусочка. \r\n\r\n														-- xs - остаток массива, который надо перебрать.\r\n\r\n							if ((head xs) < head(tail xs)) then\r\n\r\n								chkGrowth (s-1) step (tail xs)\r\n\r\n							else False\r\n\r\n						else chkGrowth step step (tail xs) -- когда s = 1, остался лишь один элемент, который сравнили с предыдущим на прошлом шаге\r\n\r\n															-- Т.о. начинаем новый кусочек и отсчет опять начинается со step (со след.элемента)\r\n\r\n\r\n\r\n{-\r\n\r\nchkGrowth [] = True\r\n\r\nchkGrowth (x:xs) = chkGr x xs\r\n\r\nchkGr x [] = True\r\n\r\nchkGr x xs = if xs==[] then True else\r\n\r\n				if x < head(xs) then chkGr (head xs) (tail xs)\r\n\r\n				else False\r\n\r\n-}				\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4898,22,'62628590','2013-09-12 23:13:37',1,'prime 1 = False\r\nprime 2 = True\r\nprime x = prime0 x 2\r\nprime0 x y\r\n	|y==x-1 = True\r\n	|mod x y/=0 = prime0 x (y+1)\r\n	|otherwise = False\r\ng x = g0 x 1\r\ng0 x y\r\n	|x==y = False\r\n	|2*y/=x && prime y && prime (x-y) = True\r\n	|otherwise = g0 x (y+1)','<br/>Тесты успешно пройдены!'),(4897,27,'62628590','2013-09-12 22:36:40',1,'minsum(x:y:xs)=minsum0 (x+y) (y:xs)\r\nminsum0 sum (x:y:xs)\r\n	|x+y>sum = minsum0 sum (y:xs)\r\n	|otherwise = minsum0 (x+y) (y:xs)\r\nminsum0 sum [] = sum\r\n   --- Небольшое замечание, о это правило теперь не нужно..\r\n   --- Список с самого начала точно не пустой, и не может стать пустым (когда он будет длины 1, прграмма завершится\r\nminsum0 sum [x] = sum','<br/>Тесты успешно пройдены!'),(4896,30,'1835693','2013-09-12 16:53:17',1,'parts [] = False\r\nparts (x:[]) = False\r\nparts (x:y:xs) = partsh 0 1 x (y:xs)\r\n\r\n-- для каждой возрастающей подпоследовательности считается ее длина, а для их длин считается НОД. Если он будет >1, то возможно разбить последовательность на возрастающей подпоследовательности такой длины.\r\n-- 1 аргумент - текущий НОД всех длин\r\n-- 2 аргумент - длина текущей подпоследовательности\r\n-- 3 аргумент - последний просмотренный элемент (для проверки на то, что подпоследовательность кончилась)\r\n-- 4 аргумент - остаток списка\r\npartsh curgcd curlen _ [] = if (gcd curgcd curlen == 1)\r\n                            then False\r\n						    else True\r\npartsh curgcd curlen lastelem (x:xs) = if (x > lastelem)\r\n                                       then partsh curgcd (curlen + 1) x xs\r\n									   else if (gcd curgcd curlen == 1)\r\n									        then False\r\n											else partsh (gcd curgcd curlen) 1 x xs','<br/>Тесты успешно пройдены!'),(4895,27,'517309','2013-09-12 10:36:59',2,'minsum(x:y:xs)=minsum0 (x+y) xs\r\nminsum0 sum (x:y:xs)\r\n	|x+y>sum = minsum0 sum (y:xs)\r\n	|otherwise = minsum0 (x+y) xs\r\nminsum0 sum [] = sum','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(4894,27,'517309','2013-09-12 10:36:25',0,'minsum(x:y:xs)=minsum0 (x+y) xs\r\nminsum0 sum (x:y:xs)\r\n	|x+y>sum = minsum0 sum (y:xs)\r\n	|otherwise = minsum0 (x+y) xs\r\nminsum0 sum [] = sum\r\nminsum0 sum [x] = sum','Выражение имеет неправильное значение: minsum [5,4,3]'),(4893,22,'5543298','2013-09-12 01:55:08',1,'isPrimeNumber\' _ 1 = True\r\n\r\nisPrimeNumber\' a b = if ((a `mod` b) == 0) then False else isPrimeNumber\' a (b - 1)\r\n\r\nisPrimeNumber 0 = False\r\n\r\nisPrimeNumber 1 = False\r\n\r\nisPrimeNumber 2 = True\r\n\r\nisPrimeNumber a = isPrimeNumber\' a (a - 1)\r\n\r\n\r\n\r\ng\' n a = let b = n - a in if (a /= b && isPrimeNumber a && isPrimeNumber b) then True else if (a == n) then False else g\' n (a + 1)\r\n\r\ng n = g\' n 1\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4892,23,'115753099','2013-09-12 01:49:26',1,'import Data.List\r\n\r\ncoprime :: Int -> Int -> Bool\r\ncoprime a 0 | a == 1 = True \r\n			| a < 1 || a > 1 = False\r\ncoprime a b = coprime b (rem a b)\r\n\r\ncoprimeList a [] = True\r\ncoprimeList a (x:xs) = coprime a x && coprimeList a xs\r\n\r\nfunc n next list res\r\n	| sum list + next == n && coprimeList next list = if (list == []) then res + 1 else func n (head list +1) (tail list) (res+1) \r\n	| sum list + next == n = func n (head list +1) (tail list) res\r\n	| sum list + next < n && coprimeList next list = func n (next+1) (next:list) res\r\n	| sum list + next < n = func n (next+1) list res\r\n	| sum list + next > n = func n (head list +1) (tail list) res\r\n\r\nc n = func n 1 [] 0','<br/>Тесты успешно пройдены!'),(4890,28,'5543298','2013-09-12 01:29:43',1,'check\' _ [] = False\r\n\r\ncheck\' cond xs = if (cond (head xs)) then True else check\' cond (tail xs)\r\n\r\ncheck cond xs = check\' cond xs\r\n','<br/>Тесты успешно пройдены!'),(4891,29,'5543298','2013-09-12 01:37:57',1,'check\' _ [] = False\r\n\r\ncheck\' cond xs = if (cond (head xs)) then True else check\' cond (tail xs)\r\n\r\ncheck cond xs = check\' cond xs\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent xs = let \r\n\r\n						h = (head xs)\r\n\r\n						t = (tail xs)\r\n   --- просто как замечание, можно без скобок  h = head xs\r\n					in if (check (x->x==h) t) then False else checkDifferent t\r\n   --- А тут после if скобки не нужны','<br/>Тесты успешно пройдены!'),(4889,26,'5543298','2013-09-12 01:22:27',1,'﻿--исходный список пуст - возвращаем результат\r\n\r\nrev\' [] xs = xs \r\n\r\n--берем голову списка O(1), приписываем к голове списка результата O(1), вызываемся от хвоста исходного списка O(1), и пополненного результата. Итого, вроде как, O(n).\r\n\r\nrev\' (xs) ys = rev\' (tail xs) ((head xs):ys)  \r\n\r\n--заводим пустой список - результат\r\n\r\nrev (xs) = rev\' (xs) []\r\n','<br/>Тесты успешно пройдены!'),(4887,25,'5543298','2013-09-12 00:56:17',1,'minpair a b = if a <= b then a else b\r\n\r\nminlist [x] = x\r\n\r\nminlist (x:xs) = minpair x (minlist xs)\r\n\r\n\r\n\r\n--mysum [] = 0\r\n\r\n--mysum (x:xs) = x + mysum xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4888,27,'5543298','2013-09-12 00:59:47',1,'minpair a b = if a <= b then a else b\r\n\r\nminsum  [x] = x\r\n\r\nminsum  [x, y] = x + y\r\n\r\nminsum  (x:y:xs) = minpair (x + y) (minsum (y:xs))\r\n','<br/>Тесты успешно пройдены!'),(4884,26,'62628590','2013-09-11 23:52:57',1,'rev xs = rev0 xs []\r\nrev0 (x:xs) ys = rev0 xs (x:ys)\r\nrev0 [] ys = ys','<br/>Тесты успешно пройдены!'),(4885,28,'62628590','2013-09-11 23:57:01',1,'check cond(x:xs)\r\n	|cond x = True\r\n	|otherwise = check cond xs\r\ncheck cond [] = False','<br/>Тесты успешно пройдены!'),(4886,29,'62628590','2013-09-12 00:07:11',1,'checkDifferent (x:xs)\r\n	|check (y->y==x) xs = False\r\n	|otherwise = checkDifferent xs\r\ncheckDifferent [] = True\r\ncheck cond(x:xs)\r\n	|cond x = True\r\n	|otherwise = check cond xs\r\ncheck cond [] = False','<br/>Тесты успешно пройдены!'),(4880,29,'romos2007','2013-09-11 23:11:31',1,'{--\r\n\r\nЗадача 3-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent [_] = True\r\n\r\ncheckDifferent (x:xs) = c\' x xs\r\n\r\n\r\n\r\n{-\r\n\r\nДвойной цикл. Сравниваем элементы каждый с каждым.\r\n\r\n\r\n\r\nХорошо было бы с использованием какого-нибудь типа данных решить. \r\n\r\n(Добавлять в него с правилом уникальности и потом выдать количество элементов.\r\n\r\nЕсли не сойдется с длиной массива, то есть повторы в массиве.)\r\n   --- Ну в принципе, да, в Хаскеле есть тип Set, можно было бы им воспользоваться. \r\n   --- Или самим описать двоичное дерево поиска, например \r\n-}\r\n\r\nc\' x [] = True\r\n\r\nc\' x (y:ys) = if x == y then False else c\' x ys && checkDifferent (y:ys) --c\' y ys\r\n','<br/>Тесты успешно пройдены!'),(4881,25,'62628590','2013-09-11 23:40:26',1,'minlist(x:xs)=minlist0 x xs\r\nminlist0 min (x:xs)\r\n	|x>min = minlist0 min xs\r\n	|otherwise = minlist0 x xs\r\nminlist0 min [] = min','<br/>Тесты успешно пройдены!'),(4882,27,'62628590','2013-09-11 23:46:10',2,'  --- Не совсем правильно.. Например, для minsum [5,6,4,3,1,8]\r\n  --- у вас дает неправильный результат.\r\n  --- Я добавил этот тест (и еще несколько). Попробуйте исправить, пожалуйста.\r\nminsum(x:y:xs)=minsum0 (x+y) xs\r\nminsum0 sum (x:y:xs)\r\n	|x+y>sum = minsum0 sum (y:xs)\r\n	|otherwise = minsum0 (x+y) xs\r\nminsum0 sum [] = sum\r\nminsum0 sum [x] = sum','<br/>Тесты успешно пройдены!'),(4883,26,'62628590','2013-09-11 23:52:13',0,'rev (x:xs) = rev0 xs [x]\r\nrev0 (x:xs) ys = rev0 xs (x:ys)\r\nrev0 [] ys = ys','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(4879,29,'romos2007','2013-09-11 23:10:42',0,'{--\r\n\nЗадача 3-5\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\n\r\n\nc [] = True\r\n\nc [_] = True\r\n\nc (x:xs) = c\' x xs\r\n\n\r\n\n{-\r\n\nДвойной цикл. Сравниваем элементы каждый с каждым.\r\n\n\r\n\nХорошо было бы с использованием какого-нибудь типа данных решить. \r\n\n(Добавлять в него с правилом уникальности и потом выдать количество элементов.\r\n\nЕсли не сойдется с длиной массива, то есть повторы в массиве.)\r\n\n-}\r\n\nc\' x [] = True\r\n\nc\' x (y:ys) = if x == y then False else c\' x ys && c (y:ys) --c\' y ys\n','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(4875,28,'115753099','2013-09-11 19:45:45',1,'import Data.List\r\ncheck cond xs = s where (s,_) = mapAccumL ( acc x -> if cond x then (acc || True,x) else (acc ,x)) False xs\r\n  --- ??? acc x -> (cond x || acc, x) ','<br/>Тесты успешно пройдены!'),(4876,29,'115753099','2013-09-11 20:02:20',1,'import Data.List\r\nimport Data.Set\r\nchekDifferent2 set xs 0 = True\r\nchekDifferent2 set [] listSize = (listSize == size set)\r\nchekDifferent2 set (x:xs) listSize = chekDifferent2 (Data.Set.insert x set) xs listSize\r\ncheckDifferent xs = chekDifferent2 empty xs (length xs)','<br/>Тесты успешно пройдены!'),(4877,26,'115753099','2013-09-11 20:02:54',1,'import Data.List\r\n\r\nrev [] = []\r\nrev (x:xs) = s where (s,_) = mapAccumL ( acc x -> (x:acc,x)) [x] xs','<br/>Тесты успешно пройдены!'),(4878,23,'romos2007','2013-09-11 22:19:31',1,'--- OK, засчитано, но на самом деле так не очень эффективно. Потому что\r\n--- лучше, видимо, проверять числа сразу, по мере добавления в список.\r\n--- Ну например, пусть у вас скажем n = 20 и в какой-то момент вы возьмете первое число 2, потом второе число 4\r\n--- Потом вы будете пытаться подобрать числа с суммой 20 ( 2 4 5 9, 2 4 6 8 ) и проверить\r\n--- их на взаимную простоту. Но лучше остановиться раньше - уже 4 не имеет смысла пробовать, \r\n--- раз оно не взаимно простое).\r\n\r\n\r\n\r\n{--\r\n\r\nЗадача 2-2*	\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nc n = f 1 n []\r\n\r\n\r\n\r\n{-\r\n\r\n	f s n xs - функция, считающая количество разложений числа n \r\n\r\n				на взаимнопростые слагаемые\r\n\r\n	s - элемент, который претендует на то, чтобы быть очередным в разложении\r\n\r\n	n - сколько нам осталось разложить (без учета s).\r\n\r\n	xs- набор предыдущих слагаемых в разложении.\r\n\r\n-}\r\n\r\n\r\n\r\nf s n xs = if s*2 < n 		\r\n\r\n				--пока слагаемое меньше половины остатка,есть шанс на вз.-простое\r\n\r\n				--разложение со след.слагаемым (s+1) :\r\n\r\n				-- 1: начать со след.слагаемого или\r\n\r\n				-- 2: продолжить по возрастанию дальше\r\n\r\n			then (f (s+1) n xs) + (f (s+1) (n-s) (s:xs))\r\n\r\n\r\n\r\n			else --если слагаемое стало >= половине остатка, то верно, что разложение не будет\r\n\r\n				 --упорядоченным по возрастанию (что противоречит перебору). Т.о. надо \r\n\r\n				 --добавить в разложение весь остаток, как единственно возможный вариант\r\n\r\n				if primeList (n:xs) then 1 else 0 -- и проверить на простоту.\r\n\r\n\r\n{-\r\n\r\n	Проверка взаимной простоты элементов списка:\r\n\r\n		Сначала проверить \"голову\"\" с \"остатком\", а потом проверить остаток рекурсивно.\r\n\r\n	Проверка \"головы\"\" с \"остатком\":\r\n\r\n		Сначала проверить со вторым элементом, а потом с оставшимися рекурсивно.\r\n\r\n-}\r\n\r\nprimeList [] = True\r\n\r\nprimeList (l:ls) = primeList\' l ls && primeList ls\r\n\r\nprimeList\' _ [] = True\r\n\r\nprimeList\' l (x:xs) = primes l x && primeList\' l xs\r\n\r\n\r\n\r\nprimes a b = if (gcd a b == 1) then True else False\r\n  --- Ну или просто primes a b = gcd a b == 1\r\n\r\n\r\n\r\n\r\n{- Не думал, что есть стандартный \'gcd\' :-)\r\n\r\n\r\n\r\n-- Функция, находящая НОД двух чисел.\r\n\r\n-- НОД = 1 => TRUE (взаимно просты)\r\n\r\nmy_gcd 0 a = a\r\n\r\nmy_gcd a 0 = a\r\n\r\nmy_gcd a b = if (a < b) then my_gcd b a\r\n\r\n			else\r\n\r\n				if (mod a b == 0) then b\r\n\r\n				else\r\n\r\n					my_gcd b (mod a b)\r\n\r\n-}\r\n','<br/>Тесты успешно пройдены!'),(4874,26,'115753099','2013-09-11 19:34:33',0,'import Data.List\r\n\r\nrev [] = []\r\nrev (x:xs) = s where (s,_) = mapAccumL ( acc x -> (x:acc,x)) [x] xs','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(4871,27,'115753099','2013-09-11 19:29:38',0,'minsum3 (x:y:xs) = s where ((s,_),_) = mapAccumL ( (acc, x) y -> ((min acc (x+y), y),y)) ((y+x),x) (y:xs)','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(4872,27,'115753099','2013-09-11 19:30:48',1,'import Data.List\r\nminsum (x:y:xs) = s where ((s,_),_) = mapAccumL ( (acc, x) y -> ((min acc (x+y), y),y)) ((y+x),x) (y:xs)','<br/>Тесты успешно пройдены!'),(4873,26,'115753099','2013-09-11 19:33:49',0,'import Data.List\r\n\r\nrev (x:xs) = s where (s,_) = mapAccumL ( acc x -> (x:acc,x)) [x] xs','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(4870,27,'115753099','2013-09-11 19:20:41',0,'import Data.List\r\nminsum (x:y:xs) = s where ((s,_),_) = mapAccumL ( (acc, x) y -> ((min acc (acc-x+y), y),y)) ((y+x),x) (y:xs)','Выражение имеет неправильное значение: minsum [1,8,3,2,7]'),(4869,22,'4604056','2013-09-11 19:14:13',1,'element x [] _ = False\r\nelement x (y:ys) size = if (size > 0)\r\n	then (x == y) || (element x ys (size - 1))\r\n	else False\r\n\r\nprimeNums = 2 : [n | n <- [3..], isPrime n]\r\nisPrime n = foldr (p r-> p*p>n || (rem n p /= 0 && r)) True primeNums\r\n\r\ng x = g\' x x x\r\n\r\ng\' x 1 _ = False\r\ng\' x s _ = if ((element s primeNums x) && (element (x-s) primeNums x) && (s /= (x - s)))\r\n	then True\r\n	else g\' x (s-1) x','<br/>Тесты успешно пройдены!'),(4866,29,'3320654','2013-09-11 17:17:10',0,'checkDifferent []	= True\r\ncheckDifferent (x:xs)	= checkDifferent\' (x:xs) (x:xs)\r\n\r\ncheckDifferent\' _ []		= True\r\ncheckDifferent\' [y] (x:xs)	= checkDifferent\' (x:xs) xs\r\ncheckDifferent\' (x:s:xs) (y:ys)	= if x == s\r\n			   then False\r\n			   else checkDifferent\' (x:xs) (y:ys)','<br/>Тесты успешно пройдены!'),(4867,29,'3320654','2013-09-11 17:19:37',1,'checkDifferent list	= checkDifferent\' list list\r\n\r\ncheckDifferent\' _ []		= True\r\ncheckDifferent\' [y] (x:xs)	= checkDifferent\' (x:xs) xs\r\ncheckDifferent\' (x:s:xs) (y:ys)	= if x == s\r\n			   then False\r\n			   else checkDifferent\' (x:xs) (y:ys)\r\n\r\n--убрал одно правило:)','<br/>Тесты успешно пройдены!'),(4868,25,'115753099','2013-09-11 18:30:58',1,'import Data.List\r\nminlist [] 	 = 0\r\nminlist (x:xs) = s where (s,_) = mapAccumL ( acc x -> (min acc x,x)) x xs\r\n  --- Это как-то уж искусственно.. Я бы просто вызвал foldr ','<br/>Тесты успешно пройдены!'),(4854,25,'3226573','2013-09-11 10:53:53',1,'minlist\' [] m = m\r\nminlist\' (x:xs) m = minlist\' xs (min x m)\r\n\r\nminlist (x:xs) = minlist\' xs x','<br/>Тесты успешно пройдены!'),(4855,27,'3226573','2013-09-11 10:58:02',0,'minsum\' [x1,x2] m = min (x1 + x2) m\r\nminsum\' (x1:x2:xs) m = minsum\' x2:xs (min (x1 + x2) m)\r\n\r\nminsum (x1:x2:xs) = minsum\' x2:xs (x1 + x2)','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(4856,27,'3226573','2013-09-11 10:58:36',1,'minsum\' [x1,x2] m = min (x1 + x2) m\r\nminsum\' (x1:x2:xs) m = minsum\' (x2:xs) (min (x1 + x2) m)\r\n\r\nminsum (x1:x2:xs) = minsum\' (x2:xs) (x1 + x2)','<br/>Тесты успешно пройдены!'),(4857,26,'3226573','2013-09-11 11:00:58',1,'rev\' [] ls = ls\r\nrev\' (x:xs) ls = rev\' xs (x:ls)\r\n\r\nrev xs = rev\' xs []','<br/>Тесты успешно пройдены!'),(4858,28,'3226573','2013-09-11 11:14:25',1,'check _ [] = False\r\ncheck cond (x:xs) = cond x || check cond xs','<br/>Тесты успешно пройдены!'),(4859,29,'3226573','2013-09-11 11:21:23',1,'checkNoSame x [] = True\r\ncheckNoSame x (s:xs) = (x /= s) && (checkNoSame x xs)\r\n\r\ncheckDifferent [x] = True\r\ncheckDifferent (x:xs) = (checkNoSame x xs) && (checkDifferent xs)','<br/>Тесты успешно пройдены!'),(4860,23,'3226573','2013-09-11 11:48:44',0,'isPrime x s = (gcd x s) == 1\r\n\r\ncheckOneAgainRest _ [] = True\r\ncheckOneAgainRest x (s:xs) = (isPrime x s) && (checkOneAgainRest x xs)\r\n\r\ncheckSet [_] = True\r\ncheckSet (x:xs) = (checkOneAgainRest x xs) && (checkSet xs)\r\n\r\nnseq n m xs = if n == m then checkSet (m:xs)\r\n              else if n < m then 0\r\n              else (nseq n (m + 1) xs) + (nseq (n - m) (m + 1) (m:xs))\r\n\r\nc n = nseq n 1 []','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(4861,23,'3226573','2013-09-11 11:54:10',1,'isPrime x s = (gcd x s) == 1\r\n\r\ncheckOneAgainRest _ [] = True\r\ncheckOneAgainRest x (s:xs) = (isPrime x s) && (checkOneAgainRest x xs)\r\n\r\ncheckSet\' [_] = True\r\ncheckSet\' (x:xs) = (checkOneAgainRest x xs) && (checkSet\' xs)\r\n\r\ncheckSet xs = if (checkSet\' xs) then 1 else 0\r\n\r\nnseq n m xs = if n == m then checkSet (m:xs)\r\n              else if n < m then 0\r\n              else (nseq n (m + 1) xs) + (nseq (n - m) (m + 1) (m:xs))\r\n\r\nc n = nseq n 1 []','<br/>Тесты успешно пройдены!'),(4862,25,'3320654','2013-09-11 16:43:40',1,'minlist [] 		= 0\r\nminlist (x:xs) 	= minlist\' (x:xs) x\r\nminlist\' [] p 	= p\r\nminlist\' (x:xs) p 	= if x < p\r\n		   then minlist\' xs x\r\n		   else minlist\' xs p','<br/>Тесты успешно пройдены!'),(4863,27,'3320654','2013-09-11 16:48:51',1,'minsum [] 		= 0\r\nminsum [x] 	= x\r\nminsum (x:xs) 		= minsum\' (xs) (x) (x + head xs)\r\nminsum\' [] _ curmin 		= curmin\r\nminsum\' (x:xs) prev curmin 	= let p = prev + x\r\n		            	   in if (p < curmin)\r\n			       then minsum\' xs x p	\r\n			       else minsum\' xs x curmin','<br/>Тесты успешно пройдены!'),(4864,26,'3320654','2013-09-11 16:54:16',1,'rev [] 	= []\r\nrev [x]	= [x]\r\n  --- Первые два правила можно не писать, и без них будет работать\r\nrev (x:xs)	= rev\' (x:xs) []\r\n\r\nrev\' [] list 		= list\r\nrev\' [x] list 		= x:list\r\nrev\' (x:xs) list	= rev\' xs (x:list)','<br/>Тесты успешно пройдены!'),(4865,28,'3320654','2013-09-11 17:01:24',1,'check cond []	= False\r\ncheck cond (x:xs)	= if (cond x)\r\n		   then True\r\n		   else check cond xs','<br/>Тесты успешно пройдены!'),(4853,29,'4604056','2013-09-11 02:27:47',1,'checkDifferent [] = True\r\ncheckDifferent (x:[]) = True\r\ncheckDifferent (x:xs) = \r\n	(checkDifferent\' x xs) && (checkDifferent xs)\r\n\r\n\r\ncheckDifferent\' x [] = True\r\ncheckDifferent\' x (y:xs) = \r\n	if (x==y) \r\n		then False\r\n		else True && checkDifferent\' x xs\r\n','<br/>Тесты успешно пройдены!'),(4852,28,'4604056','2013-09-11 02:13:38',1,'check cond [] = False\r\ncheck cond (x:[]) = cond x\r\n  --- это правило можно не писать, оно следует из остальных\r\ncheck cond (x:xs) = cond x || appendige\r\n	where appendige = check cond (xs)','<br/>Тесты успешно пройдены!'),(4851,28,'4604056','2013-09-11 02:13:18',0,'check cond [] = True\r\ncheck cond (x:[]) = cond x\r\ncheck cond (x:xs) = cond x || appendige\r\n	where appendige = check cond (xs)','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Как вы думаете, что правильно будет вернуть, если список пустой?'),(4849,26,'4604056','2013-09-11 02:00:48',1,'rev [] = []\r\nrev (x:[]) = x:[]\r\nrev (xs) = rev\' xs []\r\n\r\nrev\' [] accs = accs\r\nrev\' (x:xs) accs = rev\' xs (x:accs)','<br/>Тесты успешно пройдены!'),(4850,28,'4604056','2013-09-11 02:12:22',0,'check cond (x:[]) = cond x\r\ncheck cond (x:xs) = cond x || appendige\r\n	where appendige = check cond (xs)\r\n--Мне кажется, что на странице с условиями\r\n--неправильно оформлены примеры вызова\r\n--WinHugs понимает задание лямбды только как (x->x<1)','Не удалось вычислить выражение \"check (x->x>5) []\", проверьте правильность синтаксиса'),(4848,27,'4604056','2013-09-11 01:54:56',1,'minsum (x:y:[]) = x + y\r\nminsum (x:y:xs) = let\r\n	appendige = minsum(y:xs)\r\n	in if (x+y) < appendige\r\n		then (x + y)\r\n		else appendige','<br/>Тесты успешно пройдены!'),(4847,25,'4604056','2013-09-11 01:39:17',1,'minlist (x:[]) = x\r\nminlist (x:xs) = let \r\n	min = minlist xs\r\n	in if x < min then x\r\n		else min','<br/>Тесты успешно пройдены!'),(4846,28,'romos2007','2013-09-11 00:19:08',1,'{--\r\n\r\nЗадача 3-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n{-\r\n\r\nСКАЖИТЕ, ПОЖАЛУЙСТА, НЕЛЬЗЯ ЛИ КАК-ТО \"ПАРСИТЬ\" СТРОКУ, СОДЕРЖАЩУЮ ЛЯМБДА-ВЫРАЖЕНИЕ?\r\n\r\nТ.Е. МНЕ ОЧЕНЬ ХОТЕЛОСЬ ВПИХНУТЬ IF-THEN-ELSE В ТОТ ЖЕ MAP, КОТОРЫЙ ДАН НА ВХОДЕ. МОЖНО ЛИ ЭТО СДЕЛАТЬ? \r\n\r\n*Очень лень было второй map писать :-)\r\n\r\n\r\n\r\nКонечно, можно было руками написать рекурсию, перебрать значения true/false и остановиться там,\r\n\r\nгде выполнялось бы условие (или не выполнялось), но, на мой взгляд, так прикольнее :-)\r\n\r\n-}\r\n\r\n--- ОК, хорошее решение, замечательно! И действительно прикольно:)\r\n--- Но только зря вы пишете if (x == True) - это то же, что if (x)\r\n--- И зря вы пишете if (выражение) then True else False - это ведь просто _выражение_ - понято, да?\r\n--- Те можно написать \r\n---   check cond xs = product (map (x-> if (x) then 0 else 1) (map cond xs)) == 0\r\n--- А насчет одного map - ну, можно же написать так:\r\n---   check cond xs = product (map (x-> if (cond x) then 0 else 1)) == 0\r\n--- Я честно говоря не очень понял, что вы имели в виду \"парсить строку\". Но наверное я ответил\r\n--- на ваш вопрос? Если не совсем - напишите или подходите, обсудим.\r\n\r\n\r\ncheck cond xs = if (product (map (x-> if (x==True) then 0 else 1) (map cond xs)) == 0) then True else False\r\n\r\n\r\n\r\n{-\r\n\r\n1. внутренний map - сопоставление условия элементам массива.\r\n\r\n2. внешний map - сопоставление противоположных ЧИСЛОВЫХ значений булевским\r\n\r\n3. Перемножение этих значений - если в результате 0, то был хотя бы один 0. Следовательно, было хотя бы одно True. Т.е. был искомый элемент.\r\n\r\n-}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4845,26,'romos2007','2013-09-10 23:51:43',1,'{--\r\n\r\nЗадача 3-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nrev [] = []\r\n   --- И тут это правило можно не писать\r\nrev (x:xs) = rev\' (x:xs) []\r\n\r\n\r\n\r\nrev\' [] a = a\r\n\r\nrev\' (x:xs) outs = rev\' xs (x:outs)\r\n\r\n\r\n\r\n--NOTE: если не ошибаюсь, довольно быстрый способ получился.\r\n','<br/>Тесты успешно пройдены!'),(4844,26,'romos2007','2013-09-10 23:50:57',0,'{--\r\n\nЗадача 3-3\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\nrev (x:xs) = rev\' (x:xs) []\r\n\n\r\n\nrev\' [] a = a\r\n\nrev\' (x:xs) outs = rev\' xs (x:outs)\r\n\n\r\n\n--NOTE: если не ошибаюсь, довольно быстрый способ получился.\n','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(4843,27,'romos2007','2013-09-10 23:38:43',1,'{--\r\n\r\nЗадача 3-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\nminsum [x] = x\r\n\r\nminsum [x1,x2] = x1+x2\r\n  --- И тут тоже, первые два правила можно и не писать\r\n\r\nminsum (x1:x2:xs) = minsum\' (x1+x2) (x2:xs)\r\n\r\n\r\n\r\n--функция, исполняющая поиск минимума перебором, запоминая очередной минимум суммы 2-х соседних эл-тов\r\n\r\nminsum\' s [xlast] = s\r\n\r\nminsum\' x1x2 (x2:x3:xs) = minsum\' (minEl x1x2 (x2+x3)) (x3:xs)\r\n\r\n\r\n\r\n\r\n\r\n--функция, определяющая минимум между двумя числами\r\n\r\nminEl a b = if (a <= b) then a else b\r\n','<br/>Тесты успешно пройдены!'),(4842,27,'romos2007','2013-09-10 23:37:32',0,'{--\r\n\nЗадача 3-2\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\n\r\n\nminlist [x] = x\r\n\nminlist [x1,x2] = x1+x2\r\n\nminlist (x1:x2:xs) = minlist\' (x1+x2) (x2:xs)\r\n\n\r\n\n--функция, исполняющая поиск минимума перебором, запоминая очередной минимум суммы 2-х соседних эл-тов\r\n\nminlist\' s [xlast] = s\r\n\nminlist\' x1x2 (x2:x3:xs) = minlist\' (minEl x1x2 (x2+x3)) (x3:xs)\r\n\n\r\n\n\r\n\n--функция, определяющая минимум между двумя числами\r\n\nminEl a b = if (a <= b) then a else b\n','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(4841,25,'romos2007','2013-09-10 23:25:57',1,'{--\r\n\r\nЗадача 3-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\nminlist [x] = x\r\n  --- Это правило можно и не писать - если оставить только второе, \r\n  --- все будет работать\r\n\r\nminlist (x1:x2:xs) = minlist\' x1 (x2:xs)\r\n   --- Или проще minlist (x:xs) = minlist\' x1 (x:xs)\r\n   --- Все равно вас x2 не интеересует\r\n\r\n\r\n--функция, исполняющая поиск минимума перебором, запоминая очередной минимум\r\n\r\nminlist\' x (h:xs) = minlist\' (minEl x h) xs\r\n\r\nminlist\' a [] = a\r\n\r\n\r\n\r\n\r\n\r\n--функция, определяющая минимум между двумя числами\r\n\r\nminEl a b = if (a <= b) then a else b','<br/>Тесты успешно пройдены!'),(4840,25,'romos2007','2013-09-10 23:24:37',0,'{--\r\n\nЗадача 3-1\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\nminlist [] = \"empty list!\"\r\n\nminlist [x] = x\r\n\nminlist (x1:x2:xs) = minlist\' x1 (x2:xs)\r\n\n\r\n\n--функция, исполняющая поиск минимума перебором, запоминая очередной минимум\r\n\nminlist\' x (h:xs) = minlist\' (minEl x h) xs\r\n\nminlist\' a [] = a\r\n\n\r\n\n\r\n\n--функция, определяющая минимум между двумя числами\r\n\nminEl a b = if (a <= b) then a else b\n','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(4839,29,'55363692','2013-09-10 23:14:51',1,'check cond [] = False\r\n\r\ncheck cond (x:xs) = if cond x then True else check cond xs\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent (x:xs) = not (check (y -> y == x) xs) && checkDifferent xs\r\n','<br/>Тесты успешно пройдены!'),(4837,26,'55363692','2013-09-10 23:00:50',1,'rev\' [] xs = xs\r\n\r\nrev\' (y:xs) z = rev\' xs (y:z)\r\n\r\n\r\n\r\nrev xs = rev\' xs []\r\n','<br/>Тесты успешно пройдены!'),(4838,28,'55363692','2013-09-10 23:07:34',1,'check cond [] = False\r\n\r\ncheck cond (x:xs) = if cond x then True else check cond xs\r\n','<br/>Тесты успешно пройдены!'),(4836,27,'55363692','2013-09-10 22:49:32',1,'minsum\' min _ [] = min\r\n\r\nminsum\' min cur (x:xs) = if cur + x < min then minsum\' (cur + x) x xs else minsum\' min x xs\r\n\r\n\r\n\r\nminsum (x:y:xs) = minsum\' (x + y) y xs\r\n','<br/>Тесты успешно пройдены!'),(4835,29,'anlun','2013-09-10 22:45:16',1,'import Data.Set\r\n\r\ncheckDifferent l = size s == len\r\n	where\r\n		(s, len) = Prelude.foldl ((x, len) v -> (insert v x, len + 1)) (empty, 0) l\r\n','<br/>Тесты успешно пройдены!'),(4833,29,'87635585','2013-09-10 22:15:11',1,'check cond [] = False \r\ncheck cond (hd : tl) = cond hd || check cond tl\r\ncheckDifferent a = checkDifferent\' [] a\r\ncheckDifferent\' _ [] = True\r\ncheckDifferent\' l (hd : tl) = not (check (x -> x == hd) l) && checkDifferent\' (hd : l) tl','<br/>Тесты успешно пройдены!'),(4834,25,'55363692','2013-09-10 22:42:28',1,'minlist\' min [] = min\r\n\r\nminlist\' min (x:xs) = if x < min then minlist\' x xs else minlist\' min xs\r\n\r\n\r\n\r\nminlist (x:xs) = minlist\' x xs\r\n','<br/>Тесты успешно пройдены!'),(4830,27,'87635585','2013-09-10 22:00:49',1,'minsum [] = 0\r\nminsum [_] = 0\r\nminsum (hd : hd\' : tl) = minsum\' (hd + hd\') hd\' tl\r\nminsum\' m l [] = m\r\nminsum\' m l (hd : tl) = minsum\' (min m (hd + l)) hd tl','<br/>Тесты успешно пройдены!'),(4831,26,'87635585','2013-09-10 22:04:21',1,'rev a = rev\' [] a \r\nrev\' l [] = l\r\nrev\' l (hd : tl) = rev\' (hd : l) tl','<br/>Тесты успешно пройдены!'),(4832,28,'87635585','2013-09-10 22:08:38',1,'check cond [] = False \r\ncheck cond (hd : tl) = cond hd || check cond tl','<br/>Тесты успешно пройдены!'),(4829,25,'87635585','2013-09-10 21:56:59',1,'minlist [] = 0\r\nminlist [a] = a\r\nminlist (hd : tl) = minlist\' hd tl\r\nminlist\' m [] = m\r\nminlist\' m (hd : tl) = minlist\' (min m hd) tl','<br/>Тесты успешно пройдены!'),(4828,25,'nomeansno','2013-09-10 21:45:31',1,'minlist (x:xs) = minlist\' xs x\r\n\r\n\r\n\r\nminlist\' [] min = min\r\n\r\n\r\n\r\nminlist\' (x:xs) min = if x < min then minlist\' xs x\r\n\r\n\r\n\r\nelse minlist\' xs min\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4827,28,'nomeansno','2013-09-10 21:44:29',1,'check cond [] = False\r\n\r\ncheck cond (x:xs) = if cond x then True\r\n\r\nelse check cond xs\r\n','<br/>Тесты успешно пройдены!'),(4826,25,'nomeansno','2013-09-10 21:44:09',0,'check cond [] = False\r\n\ncheck cond (x:xs) = if cond x then True\r\n\nelse check cond xs\n','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(4825,29,'anlun','2013-09-10 21:38:43',0,'import Data.Set\r\n\r\ncheckDiffent l = size s == len\r\n	where\r\n		(s, len) = Prelude.foldl ((x, len) v -> (insert v x, len + 1)) (empty, 0) l','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(4824,29,'anlun','2013-09-10 21:37:32',0,'import Data.Set\r\n\r\ncheckDiffent l = size s == len\r\n	where\r\n		(s, len) = Prelude.foldl ((x, len) v -> (insert v x, len + 1)) (empty, 0) l\r\n\r\n--- Without set\r\n--checkDiffert []     = True\r\n--checkDiffert (x:xs) = (notElem x xs) && (checkDifference_ xs)','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(4822,28,'anlun','2013-09-10 21:32:18',1,'check :: (a -> Bool) -> [a] -> Bool\r\ncheck cond l = foldl (x v -> x || cond v) False l\r\n','<br/>Тесты успешно пройдены!'),(4823,29,'anlun','2013-09-10 21:32:53',0,'import Data.Set\r\n\r\ncheckDifference l = size s == len\r\n	where\r\n		(s, len) = Prelude.foldl ((x, len) v -> (insert v x, len + 1)) (empty, 0) l\r\n\r\n--- Without set\r\ncheckDifference_ []     = True\r\ncheckDifference_ (x:xs) = (notElem x xs) && (checkDifference_ xs)','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(4821,25,'nomeansno','2013-09-10 21:30:17',1,'minlist (x:xs) = minlist\' xs x\r\n\r\nminlist\' [] min = min\r\n\r\nminlist\' (x:xs) min = if x < min then minlist\' xs x\r\n\r\nelse minlist\' xs min\r\n','<br/>Тесты успешно пройдены!'),(4820,28,'anlun','2013-09-10 21:30:13',0,'check :: (a -> Bool) -> [a] -> Bool\r\ncheck cond l = foldl (x v -> x && cond v) True l','Выражение имеет неправильное значение: check ( x->x>5) [3,2,7,4]'),(4819,26,'anlun','2013-09-10 21:25:38',1,'rev :: [a] -> [a]\r\nrev l = foldl (x v -> v:x) [] l\r\n  --- Или просто rev = foldl (:) []','<br/>Тесты успешно пройдены!'),(4818,27,'nomeansno','2013-09-10 21:24:48',1,'min\' x y = if x < y then x\r\n\r\nelse y\r\n\r\n\r\n\r\nminsum (x:y:xs) = minsum\' xs (x+y)\r\n\r\nminsum\' [] min = min\r\n\r\nminsum\' (x:y:z:[]) min = min\' min (y + min\' x z)\r\n\r\nminsum\' (x:y:xs) min = if x + y < min then minsum\' xs  (x + y)\r\n\r\nelse minsum\' xs min \r\n','<br/>Тесты успешно пройдены!'),(4817,27,'anlun','2013-09-10 21:23:41',1,'minsum :: (Num a, Ord a) => [a] -> a\r\nminsum []  = error \"empty list\"\r\nminsum [x] = error \"single element list\"\r\nminsum (x1:x2:xs) = snd $ foldl ((x, ms) v -> (v, ms `min` (x + v))) (x2, x1 + x2) xs','<br/>Тесты успешно пройдены!'),(4816,25,'anlun','2013-09-10 21:21:43',1,'minlist :: Ord a => [a] -> a\r\nminlist []     = error \"empty list\"\r\nminlist (x:xs) = foldl (min) x xs','<br/>Тесты успешно пройдены!'),(4815,24,'517309','2013-09-10 21:12:16',1,'-- upd: Почему-то \'b 3\' не засчитано в тестовой системе, хоть и дает результат 0.7 - еще одна попытка на случай бага\r\n\r\n-- Решение с использованием аккумулятора\r\nb n = bh n n\r\n\r\n-- первый аргумент (n) - количество оставшихся шагов (дробей)\r\n-- второй аргумент (p) - текущее значение аккумулятора\r\nbh 0 p = p\r\nbh n p = bh (n - 1) ((1 / p) + n - 1)','<br/>Тесты успешно пройдены!'),(4814,22,'1835693','2013-09-10 21:03:49',1,'-- Решение немного странное, но требует лишь o(n^2) для построения списка простых чисел, после чего проверка занимает один проход по нему\r\n   --- ОК, вовсе не странное, отличное решение!\r\ng n = gh (primesRev n) (primes n) n\r\n\r\n-- Проверка условия путем прохода по списку простых чисел с двух сторон\r\ngh (p:ps) (q:qs) n = if (p >= q)\r\n                     then False\r\n                     else if (p + q == n)\r\n                          then True\r\n					      else if (p + q > n)\r\n						       then gh (p:ps) qs n\r\n							   else gh ps (q:qs) n\r\n\r\nprimesRev n = reverse (primes n)\r\n\r\n-- Построение списка простых чисел, не превосходящих n\r\nprimes n = primesh [] 2 n\r\nprimesh res p n = if (p > n)\r\n                  then res\r\n				  else if (isPrime res p)\r\n				       then primesh (p:res) (p + 1) n\r\n					   else primesh res (p + 1) n\r\n\r\n-- Проверка того, делится ли p на какое-либо число из списка\r\nisPrime [] p     = True\r\nisPrime (x:xs) p = if (mod p x == 0)\r\n                    then False\r\n					else isPrime xs p\r\n','<br/>Тесты успешно пройдены!'),(4813,22,'1835693','2013-09-10 21:01:54',0,'g n = gh (primesRev n) (primes n) n\r\n\r\n-- Проверка условия путем прохода по списку простых чисел с двух сторон\r\ngh (p:ps) (q:qs) n = if (p >= q)\r\n                     then False\r\n                     else if (p + q == n)\r\n                          then True\r\n					      else if (p + q > n)\r\n						       then gh (p:ps) qs n\r\n							   else gh ps (q:qs) n\r\n\r\nprimesRev n = reverse (primes n)\r\n\r\n-- Построение списка простых чисел, не превосходящих n\r\nprimes n = primesh [] 2 n\r\nprimesh res p n = if (p > n)\r\n                  then res\r\n				  else if (isPrime res p)\r\n				       then primesh (p:res) (p + 1) n\r\n					   else primesh res (p + 1) n\r\n\r\n-- Проверка того, делится ли p на какое-либо число из списка\r\nisPrime [] p     = True\r\nisPrime (x:xs) p = if (mod p x == 0)\r\n                    then False\r\n					else isPrime xs p\r\n','<br/>Тесты успешно пройдены!'),(4812,26,'nomeansno','2013-09-10 20:57:55',1,'rev xs = rev\' xs []\r\n\r\nrev\' [] xs = xs\r\n\r\nrev\' (x:xs) ys = rev\' xs (x:ys) \r\n','<br/>Тесты успешно пройдены!'),(4811,23,'1835693','2013-09-10 20:43:20',1,'c n = ch 1 n 1\r\n\r\n-- Функция-помощник - по аналогии с 5 задачей 1 ДЗ\r\n-- 3 параметр - текущее НОК элементов последовательности\r\n-- Проверка взаимной простоты всех элементов (считается НОД последнего элемента с НОК всех предыдущих)\r\nch m n p = if (gcf m p == 1)\r\n              then if (n == m)\r\n                   then 1\r\n			       else if (m > n)\r\n			            then 0\r\n						-- Поскольку старое НОК и новый элемент взаимно просты, то их новое НОК - это их произведение\r\n				        else ch (m + 1) (n - m) (p * m) + ch (m + 1) n p\r\n			   -- Если взаимной простоты нет, то нужно смотреть следующий возможный элемент последовательности (увеличение на 1)\r\n               else ch (m + 1) n p\r\n\r\n-- наибольший общий делитель (по алгоритму Евклида)\r\ngcf 0 n = n\r\ngcf m 0 = m\r\ngcf 1 n = 1\r\ngcf m 1 = 1			\r\ngcf m n = if (m > n)\r\n          then gcf (mod m n) n\r\n		  else gcf m (mod n m)\r\n','<br/>Тесты успешно пройдены!'),(4810,29,'1835693','2013-09-10 20:34:59',1,'checkDifferent []     = True\r\ncheckDifferent (x:xs) = if (checkh x xs)\r\n                        then checkDifferent xs\r\n						else False\r\n\r\ncheckh _ []       = True\r\ncheckh res (x:xs) = if (res == x)\r\n                    then False\r\n                    else checkh res xs','<br/>Тесты успешно пройдены!'),(4809,22,'1835693','2013-09-10 20:34:45',0,'checkDifferent []     = True\r\ncheckDifferent (x:xs) = if (checkh x xs)\r\n                        then checkDifferent xs\r\n						else False\r\n\r\ncheckh _ []       = True\r\ncheckh res (x:xs) = if (res == x)\r\n                    then False\r\n                    else checkh res xs','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4807,25,'1835693','2013-09-10 20:25:52',1,'minlist [] = 0\r\nminlist (x:xs) = minlisth x xs\r\n\r\nminlisth m [] = m\r\nminlisth m (x:xs) = minlisth (min m x) xs','<br/>Тесты успешно пройдены!'),(4808,28,'1835693','2013-09-10 20:28:13',1,'check cond []     = False\r\ncheck cond (x:xs) = if (cond x)\r\n                    then True\r\n					else check cond xs','<br/>Тесты успешно пройдены!'),(4806,26,'1835693','2013-09-10 20:25:48',1,'rev xs = revh [] xs\r\n\r\nrevh result []     = result\r\nrevh result (x:xs) = revh (x:result) xs','<br/>Тесты успешно пройдены!'),(4805,26,'1835693','2013-09-10 20:25:39',0,'rev xs = revh [] xs\r\n\r\nrevh result []     = result\r\nrevh result (x:xs) = revh (x:result) xs','<br/>Тесты успешно пройдены!'),(4804,27,'1835693','2013-09-10 20:21:40',1,'minsum xs = minsumh (-1) xs\r\n  --- Но только -1 вообще говоря не очень корректно, числа мб и отрицательные\r\nminsumh m []           = m\r\nminsumh m (x : [])     = m\r\nminsumh m (x : y : xs) = if (m == -1)\r\n                         then minsumh (x + y) (y : xs)\r\n						 else minsumh (min (x + y) m) (y : xs)\r\n','<br/>Тесты успешно пройдены!'),(4803,29,'nomeansno','2013-09-10 20:08:11',1,'in\' _ [] = False\r\n\r\nin\' x\' (x:xs) = if x==x\' then True\r\n\r\nelse in\' x\' xs\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent (x:xs) = if x `in\'` xs then False\r\n\r\nelse checkDifferent xs\r\n','<br/>Тесты успешно пройдены!'),(4801,25,'1835693','2013-09-10 19:51:57',0,'minlist [] = 0\r\nminlist (x:xs) = minlisth x xs\r\n\r\nminlisth m [] = m\r\nminlisth m (x:xs) = minlisth (min m x) xs','<br/>Тесты успешно пройдены!'),(4802,25,'1835693','2013-09-10 19:52:04',0,'minlist [] = 0\r\nminlist (x:xs) = minlisth x xs\r\n\r\nminlisth m [] = m\r\nminlisth m (x:xs) = minlisth (min m x) xs','<br/>Тесты успешно пройдены!'),(4800,29,'deripaska','2013-09-10 18:07:11',1,'﻿{--\r\n\r\n    task 03-05\r\n\r\nОписать функцию checkDifferent, которая возвращает True, если все элементы в списке разные, и False, если среди них есть одинаковые.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\ncheckDifferent [3,2,7]\r\n\r\nОтвет должен быть равен True.\r\n\r\ncheckDifferent [3,2,7,5,7,8]\r\n\r\nОтвет должен быть равен False (два раза встречается число 7).\r\n\r\n--}\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent (x:xs)\r\n\r\n	| any (element -> x == element) xs = False\r\n\r\n	| otherwise = checkDifferent xs\r\n','<br/>Тесты успешно пройдены!'),(4799,28,'deripaska','2013-09-10 18:06:17',1,'﻿{--\r\n\r\n    task 03-04\r\n\r\nОписать функцию check cond xs, которая для данного списка xs и логической функции cond проверяет, верно ли, что в списке есть элемент, для которого cond возвращает True. Результат должен быть равен True, если такой элемент есть, и False, если его нет.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\ncheck (x -> x > 5) [3,2,7,4]\r\n\r\nОтвет должен быть равен True, потому что в списке есть число, большее 5 (это число 7). \r\n\r\n\r\n\r\ncheck (x -> x < 1) [3,2,7,4]\r\n\r\nОтвет должен быть равен False, потому что в списке нет чисел, меньших 1. \r\n\r\n--}\r\n\r\n\r\n\r\ncheck cond [] = False\r\n\r\ncheck cond (x:xs)\r\n\r\n	| cond x = True\r\n\r\n	| otherwise = check cond xs\r\n','<br/>Тесты успешно пройдены!'),(4798,26,'deripaska','2013-09-10 18:05:32',1,'﻿{--\r\n\r\n    task 03-03\r\n\r\nОписать фунццию rev, которая для списка возвращает список из тех же элементов, но идуших в обратном порядке.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nrev [1, 3, 7] \r\n\r\n- должен получиться список [7, 3, 1].\r\n\r\n--}\r\n\r\n\r\n\r\n{-- first\r\n\r\nrev [] = []\r\n\r\nrev [x, y] = [y, x]\r\n\r\nrev (x:xs) = (rev xs) ++ [x]\r\n\r\n--}\r\n\r\n\r\n\r\n--second \r\n\r\nrev xs = rev1 xs []\r\n\r\nrev1 [] result = result\r\n\r\nrev1 (x:xs) result = rev1 xs (x:result)\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4797,27,'deripaska','2013-09-10 18:04:36',1,'﻿{--\r\n\r\n	task 03-02\r\n\r\nОписать функцию minsum, которая ищет минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nminsum [1,8,3,2,7]\r\n\r\nОтвет должен быть равен 5 (3+2).\r\n\r\n--}\r\n\r\n\r\n\r\nminsum [x, y] = x + y\r\n\r\nminsum (x:y:xs) \r\n\r\n	| (x + y ) < minCurSum = x + y \r\n  --- тут я мб использовал бы let, чтобы два разане считать сумму\r\n\r\n	| otherwise = minCurSum\r\n\r\n	where minCurSum = minsum (y:xs)\r\n','<br/>Тесты успешно пройдены!'),(4795,25,'517309','2013-09-10 16:04:07',2,'min','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(4796,25,'deripaska','2013-09-10 18:04:10',1,'﻿{--\r\n\r\n    task 03-01\r\n\r\nОписать функцию minlist, которая ищет минимальный элемент в данном списке.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nminlist [3,2,7]\r\n\r\nОтвет должен быть равен 2.\r\n\r\n--}\r\n\r\n\r\n\r\nminlist [x] = x\r\n\r\nminlist (x:xs) \r\n\r\n	| x < minX = x\r\n\r\n	| otherwise = minX\r\n\r\n	where minX = minlist xs\r\n\r\n	 \r\n','<br/>Тесты успешно пройдены!'),(4794,22,'1595828','2013-09-10 11:54:03',1,'g n = g\' n 1\r\n\r\ng\' n fn\r\n\r\n |fn ==n =False \r\n\r\n |(is_p fn)&&is_p (n-fn)&&((n-fn)/=fn) = True \r\n\r\n |otherwise = g\' n (fn+1)\r\n\r\nis_p 1 = False\r\n\r\nis_p 2 = True\r\n\r\nis_p numb = is_p\' numb 2\r\n\r\nis_p\' n del\r\n\r\n |(del == (n-1)) = True\r\n\r\n |n `mod` del /= 0  = is_p\' n (del+1)\r\n\r\n |otherwise =  False\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4793,22,'6053606','2013-09-09 17:16:04',1,'g n = any (isPrimeSum n) [2..div n 2 - 1]\r\n\r\nisPrimeSum n a = isPrime a && isPrime (n - a)\r\n\r\nisPrime n =\r\n    if n <= 1\r\n    then False\r\n    else not $ any (divisibleBy n) [2..div n 2]\r\n\r\ndivisibleBy n d = mod n d == 0\r\n','<br/>Тесты успешно пройдены!'),(4791,24,'517309','2013-09-09 17:14:09',0,'b n = bh n n\r\n\r\nbh 0 p = p\r\nbh n p = bh (n - 1) ((1 / p) + n - 1)','Выражение имеет неправильное значение: b 3'),(4792,22,'6053606','2013-09-09 17:15:56',0,'g n = any (isPrimeSum n) [2..div n 2 - 1]\r\n\r\nisPrimeSum n a = isPrime a && isPrime (n - a)\r\n\r\nisPrime n =\r\n    if n <= 1\r\n    then False\r\n    else not $ any (divisibleBy n) [2..div n 2]\r\n\r\ndivisibleBy n d = mod n d == 0\r\n','<br/>Тесты успешно пройдены!'),(4790,24,'517309','2013-09-09 17:12:53',0,'-- upd: Почему-то \'b 3\' не засчитано в тестовой системе, хоть и дает результат 0.7 - еще одна попытка на случай бага\r\n\r\n-- Решение с использованием аккумулятора\r\nb n = bh n n\r\n\r\n-- первый аргумент (n) - количество оставшихся шагов (дробей)\r\n-- второй аргумент (p) - текущее значение аккумулятора\r\nbh 0 p = p\r\nbh n p = bh (n - 1) ((1 / p) + n - 1)','Выражение имеет неправильное значение: b 3'),(4789,21,'MaryK','2013-09-09 15:14:05',2,'nseq::Int->Int \r\n\r\nnseq n = f n 0 0 1 0 \r\n\r\n\r\n\r\nf 0 min pmin res flag = res\r\n\r\n\r\n\r\nf max min pmin res flag = if (max - (min + 1)) > min \r\n\r\n                          then if (flag == 0)\r\n\r\n                               then f (max - (min + 1)) (min + 1) (pmin) (res + 1) 1\r\n\r\n                               else f (max - (min + 1)) (min + 1) (pmin + 1) (res + 1) 1\r\n\r\n                          else if (flag > 0) && ((max - 1) > min)\r\n\r\n                               then f (max + (min - 1)) (pmin + 1) (pmin) (res + 1) 0\r\n\r\n                               else if (max - 1) <= (min + 1)\r\n\r\n                                    then f 0 min pmin res flag\r\n\r\n                                    else if (max <= min) || (flag == 0)\r\n\r\n                                         then f (max - 1) (min + 1) (pmin + 1) (res + 1) 0\r\n\r\n                                         else 0\r\n\r\n			 \r\n\r\n\r\n','Выражение имеет неправильное значение: nseq 2'),(4788,21,'641524','2013-09-09 14:50:39',2,'nseq n = f1 n 1 1 (n-1)\r\n  --- Идея в общем-то правильная, но все таки не засчитано \r\n  --- (те задачи, которые со * должны давать правильные результаты, чтобы они были засчитаны)\r\nf1 0 s a b = s\r\nf1 n s a b = f1 (n-1) (s+f (a+1) (b-1)) (a+1) (b-1)\r\nf a b = if b < a\r\n           then 0\r\n           else if b < (2*a)\r\n                   then 1\r\n                   else f1 (b-a) 0 (a+1) (b-a-1)','Выражение имеет неправильное значение: nseq 3'),(4787,21,'1835693','2013-09-09 13:50:20',1,'nseq n = nseqh 1 n\r\n\r\n-- Функция-помощник:\r\n-- 1 параметр - текущий первый элемент последовательности\r\n-- 2 параметр - число, которое требуется получить\r\nnseqh m n = if (n == m)\r\n            -- если первый элемент равен результату, то есть только один способ построить последовательность (n = n)\r\n            then 1\r\n			else if (m > n)\r\n			     -- если первый элемент больше результата, то построить последовательность невозможно\r\n			     then 0\r\n				 -- два способа построения цепочек:\r\n				 -- 1. попробовать построить цепочку с текущим первым элементом: тогда следующий должен быть хотя бы на 1 больше, а результат - меньше на этот элемент (m)\r\n				 -- 2. попробовать построить цепочку с большим первым элементом - будем увеличивать пошагово на 1\r\n				 else nseqh (m + 1) (n - m) + nseqh (m + 1) n','<br/>Тесты успешно пройдены!'),(4785,22,'2156724','2013-09-09 13:38:07',1,'\r\nfunc n a =\r\n\r\n     if a > (quot n 2) then True\r\n\r\n       else    \r\n\r\n         if mod n a == 0 then False\r\n\r\n           else func n (a+1)\r\n\r\n\r\n\r\nispr 1 = False\r\n\r\nispr k = func k 2\r\n\r\n\r\n\r\nfunc2 n a = \r\n\r\n   if a >= n then False\r\n\r\n      else \r\n\r\n         if ((ispr a) && (ispr n) == True) then True\r\n\r\n      else func2 (n-1) (a+1)\r\n\r\n\r\n\r\ng 1 = False    \r\n\r\ng n = func2 (n-1) 1\r\n\r\n \r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(4786,21,'641524','2013-09-09 13:40:19',0,'nseq n = f1 n 1 1 (n-1)\r\nf1 0 s a b = s\r\nf1 n s a b = f1 (n-1) (s+f (a+1) (b-1)) (a+1) (b-1)\r\nf a b = if b<a then 0 else if b<(2*a) then 1 else f1 (b-a) 0 (a+1) (b-a-1)','Выражение имеет неправильное значение: nseq 3'),(4783,22,'2156724','2013-09-09 13:34:26',0,'\r\n\nfunc n a =\r\n\n     if a > (quot n 2) then True\r\n\n       else    \r\n\n         if mod n a == 0 then False\r\n\n           else True\r\n\n\r\n\nispr 1 = False\r\n\nispr k = func k 2\r\n\n\r\n\nfunc2 n a = \r\n\n   if a >= n then False\r\n\n      else \r\n\n         if ((ispr a) && (ispr n) == True) then True\r\n\n      else func2 (n-1) (a+1)\r\n\n\r\n\ng 1 = False    \r\n\ng n = func2 (n-1) 1\r\n\n \r\n\n \n','Выражение имеет неправильное значение: g 11'),(4784,20,'1835693','2013-09-09 13:37:29',1,'sumfact n = sumfacth n 1\r\n\r\n-- Функция-помощник:\r\n-- 1 параметр - количество оставшихся шагов\r\n-- 2 параметр - аккамулятор для значения-результата\r\nsumfacth 1 p = p\r\nsumfacth n p = sumfacth (n - 1) (p * n + 1)\r\n','<br/>Тесты успешно пройдены!'),(4779,21,'641524','2013-09-09 13:26:10',0,'nseq n = f1 n 1 1 (n-1)\r\nf1 0 s a b = s\r\nf1 n s a b = f1 (n-1) (s+f (a+1) (b-a-1)) (a+1) (b-a-1)\r\nf a b = if b<a then 0 else if b<(2*a) then 1 else f1 (b-a) 0 (a+1) (b-a-1)','Выражение имеет неправильное значение: nseq 3'),(4780,20,'nbumakov','2013-09-09 13:26:13',1,'fact 1 = 1\r\nfact n = fact (n-1)*n\r\n\r\nsumfact n = sumfact2 n 1\r\nsumfact2 1 sum = sum\r\nsumfact2 n sum = sumfact2 (n - 1) (sum + fact n)','<br/>Тесты успешно пройдены!'),(4781,19,'1835693','2013-09-09 13:28:58',1,'sumsin n = sumsinh n 0 0\r\n\r\n-- Функция-помощник:\r\n-- 1 параметр - количество оставшихся шагов\r\n-- 2 параметр - аккумулятор для числителя (1 + ... + n), синус будет вызван на последнем шаге\r\n-- 3 параметр - аккумулятор для знаменателя (sin(1) + ... + sin(n))\r\nsumsinh 0 num denom = (sin num) / denom\r\nsumsinh n num denom = sumsinh (n - 1) (num + n) (denom + (sin n))','<br/>Тесты успешно пройдены!'),(4782,21,'641524','2013-09-09 13:30:02',0,'nseq n = f1 n 1 1 n\r\nf1 0 s a b = s\r\nf1 n s a b = f1 (n-1) (s+f (a+1) (b-a-1)) (a+1) (b-a-1)\r\nf a b = if b<a then 0 else if b<(2*a) then 1 else f1 (b-a) 0 (a+1) (b-a-1)','Выражение имеет неправильное значение: nseq 3'),(4775,24,'1835693','2013-09-09 13:08:11',1,'-- upd: Почему-то \'b 3\' не засчитано в тестовой системе, хоть и дает результат 0.7 - еще одна попытка на случай бага\r\n   --- Да, там тест был не совсем корректно написан, а у вас все конечно было правильно\r\n-- Решение с использованием аккумулятора\r\nb n = bh n n\r\n\r\n-- первый аргумент (n) - количество оставшихся шагов (дробей)\r\n-- второй аргумент (p) - текущее значение аккумулятора\r\nbh 0 p = p\r\nbh n p = bh (n - 1) ((1 / p) + n - 1)','Выражение имеет неправильное значение: b 3'),(4776,21,'62628590','2013-09-09 13:14:17',1,'nseq n = nseq1 n 1 0\r\nnseq0 n a\r\n  | a==1 = 1\r\n  | n>a = nseq0 (n-a) a + nseq0 (n-a) (a-1)\r\n  | otherwise = 0\r\nnseq1 n a b\r\n  | a<=n = nseq1 n (a+1) (b + nseq0 n a)\r\n  | otherwise = b','<br/>Тесты успешно пройдены!'),(4777,21,'641524','2013-09-09 13:24:04',0,'nseq n = f1 n 1 1 (b-1)\r\nf1 0 s a b = s\r\nf1 n s a b = f1 (n-1) (s+f (a+1) (b-a-1)) (a+1) (b-a-1)\r\nf a b = if b<a then 0 else if b<(2*a) then 1 else f1 (b-a) 0 (a+1) (b-a-1)','Не удалось вычислить выражение \"nseq 1\", проверьте правильность синтаксиса'),(4778,20,'nbumakov','2013-09-09 13:25:01',0,'sumfact n = sumfact2 n 1\r\nsumfact2 1 sum = sum\r\nsumfact2 n sum = sumfact2 (n - 1) (sum + fact n)','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса'),(4774,24,'1835693','2013-09-09 13:05:05',0,'-- Решение с использованием аккумулятора\r\nb n = bh n n\r\n\r\n-- первый аргумент (n) - количество оставшихся шагов (дробей)\r\n-- второй аргумент (p) - текущее значение аккумулятора\r\nbh 0 p = p\r\nbh n p = bh (n - 1) ((1 / p) + n - 1)','Выражение имеет неправильное значение: b 3'),(4773,24,'1835693','2013-09-09 13:04:35',0,'-- Решение с использованием аккумулятора\r\nf n = fh n n\r\n\r\n-- первый аргумент (n) - количество оставшихся шагов (дробей)\r\n-- второй аргумент (p) - текущее значение аккумулятора\r\nfh 0 p = p\r\nfh n p = fh (n - 1) ((1 / p) + n - 1)','Не удалось вычислить выражение \"b 3\", проверьте правильность синтаксиса'),(4772,18,'1835693','2013-09-09 12:47:55',1,'-- Предложены два решения:\r\n-- 1. Обычная рекурсия (f)\r\n-- 2. Хвостовая рекурсия с аккумулятором (f2)\r\n\r\n-- Обычная рекурсия\r\nf 0 = 1\r\nf n = (1 / f (n - 1)) + 1\r\n\r\n-- Аккумулятор\r\nf2 n = fh n 1\r\nfh 0 p = p\r\nfh n p = fh (n - 1) ((1 / p) + 1)\r\n','<br/>Тесты успешно пройдены!'),(4771,18,'1835693','2013-09-09 12:46:34',0,'-- Предложены два решения:\r\n\n-- 1. Обычная рекурсия (f)\r\n\n-- 2. Хвостовая рекурсия с аккамулятором (f2)\r\n\n\r\n\n-- Обычная рекурсия\r\n\nf 0 = 1\r\n\nf n = (1 / f (n - 1)) + 1\r\n\n\r\n\n-- Аккамулятор\r\n\nf2 n = fh n 1\r\n\nfh 0 p = p\r\n\nfh n p = fh (n - 1) ((1 / p) + 1)\r\n\n\r\n\nmain = f 3\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4770,18,'1835693','2013-09-09 12:46:12',0,'-- Предложены два решения:\r\n\n-- 1. Обычная рекурсия (f)\r\n\n-- 2. Хвостовая рекурсия с аккамулятором (f2)\r\n\n\r\n\n-- Обычная рекурсия\r\n\nf 0 = 1\r\n\nf n = (1 / f (n - 1)) + 1\r\n\n\r\n\n-- Аккамулятор\r\n\nf2 n = fh n 1\r\n\nfh 0 p = p\r\n\nfh n p = fh (n - 1) ((1 / p) + 1)\r\n\n\r\n\nmain = f 3\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4767,24,'62628590','2013-09-09 11:40:07',1,'b n = b0 n 0\r\nb0 0 n = n\r\nb0 l p = p + 1 / b0 (l - 1) (p + 1)','<br/>Тесты успешно пройдены!'),(4768,19,'62628590','2013-09-09 11:52:01',1,'sumsin n = sumsin0 n 0 0\r\nsumsin0 0 a b = sin a/b\r\nsumsin0 n a b = sumsin0 (n-1) (a+n) (b+sin n)','<br/>Тесты успешно пройдены!'),(4769,20,'62628590','2013-09-09 12:12:31',1,'fact 1 = 1\r\nfact n = n * fact (n-1)\r\nsumfact n = sumfact0 n 1\r\nsumfact0 1 b = b\r\nsumfact0 a b = sumfact0 (a-1) (b+fact a)','<br/>Тесты успешно пройдены!'),(4766,18,'62628590','2013-09-09 11:16:31',1,'f 1 = 2.0\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4764,21,'SNNatalieS','2013-09-09 03:24:38',1,'nseq n = f n n\r\nf 0 0 = 1\r\nf 2 2 = 1\r\nf n 0 = 0\r\nf a b = f a (b - 1) + f (a - b) (b - 1)','<br/>Тесты успешно пройдены!'),(4765,19,'517309','2013-09-09 06:22:55',1,'ssin 0 = 0\r\n\r\nssin n = ssin (n - 1) + sin n\r\n\r\nsumsin n = sin (sum [1..n]) / ssin n\r\n','<br/>Тесты успешно пройдены!'),(4761,24,'5247795','2013-09-09 02:29:26',1,'b n = f n 0\r\n\r\nf 0 p = p\r\n\r\nf n p = f (n-1) (1/(n+p))\r\n','<br/>Тесты успешно пройдены!'),(4762,18,'5247795','2013-09-09 02:30:21',1,'f 1 = 2\r\n\r\nf n = 1 + 1 / f (n - 1)\r\n','<br/>Тесты успешно пройдены!'),(4763,22,'toskira','2013-09-09 02:41:15',1,'g n = g\' n (floor ((fromIntegral (n - 1)) / 2))\r\n\r\ng\' _ 1 = False\r\ng\' n k = ((prime k) && (prime (n - k))) ||  g\' n (k - 1)\r\n\r\nprime n = prime\' n ((floor . sqrt . fromIntegral) n)\r\n\r\nprime\' _ 1 = True \r\nprime\' n k = (mod n k) /= 0 && prime\' n (k - 1)\r\n','<br/>Тесты успешно пройдены!'),(4759,20,'5247795','2013-09-09 02:28:31',1,'fact n = fact\' n 1\r\n\r\nfact\' 1 p  = p\r\n\r\nfact\' n p = fact\' (n-1) (n*p)\r\n\r\nsumfact n = sumfact\' n 1\r\n\r\nsumfact\' 1 s = s\r\n\r\nsumfact\' n s = sumfact\' (n-1) (s+fact n)\r\n','<br/>Тесты успешно пройдены!'),(4760,19,'5247795','2013-09-09 02:28:56',1,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 s p = sin s / p\r\n\r\nsumsin\' n s p = sumsin\' (n-1) (s+n) (p + sin n)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4758,21,'15309342','2013-09-09 00:44:08',1,'nseq n = nseq2 n n 1\r\nnseq1 n k | n <= 0 = 0\r\nnseq1 n 1 = 1\r\nnseq1 n k = (nseq1 (n - k) (k - 1)) + (nseq1 (n - k) k)\r\nnseq2 n 1 s = s\r\nnseq2 n k s = nseq2 n (k - 1) (s + (nseq1 n k))','<br/>Тесты успешно пройдены!'),(4755,24,'3301494','2013-09-09 00:11:34',1,'step 1 n = n - 1 + 1 / n\r\n\r\nstep n s = s - 1 + 1 / (step (n - 1) (s + 1))\r\n\r\nb 1  = 1\r\n\r\nb n = step n 1\r\n','<br/>Тесты успешно пройдены!'),(4756,20,'3301494','2013-09-09 00:18:50',1,'sumfact\' 1 step mult summ = summ + step * mult\r\n\r\nsumfact\' n step mult summ = sumfact\' (n-1) (step + 1) (step * mult) (summ + step * mult)\r\n\r\nsumfact n = sumfact\' n 1 1 0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4757,22,'55363692','2013-09-09 00:32:30',1,'import System.Environment\r\n\r\nisPrime\' k n = if (2 * k > n) then True else (mod n k /= 0) && isPrime\' (k + 1) n\r\n  --- Лучше, конечно if (k*k > n) then True (если число составное, то один из делителей точно меньше квадратного корня\r\nisPrime n = isPrime\' 2 n\r\n\r\ng\' k n = if (2 * k > n) then False else ((k /= (n - k)) && isPrime k && isPrime (n - k)) || g\' (k + 1) n\r\ng n = g\' 2 n','<br/>Тесты успешно пройдены!'),(4754,19,'nbumakov','2013-09-09 00:07:10',1,'sumsin n = sumsin2 n 0 0\r\nsumsin2 0 sum sinus_sum = sin sum / sinus_sum\r\nsumsin2 n sum sinus_sum = sumsin2 (n - 1) (sum + n) (sinus_sum + sin n)','<br/>Тесты успешно пройдены!'),(4753,24,'nbumakov','2013-09-08 23:59:06',1,'b n = b2 0 n\r\nb2 n 0 = n\r\nb2 x y = x + 1 / b2 (x + 1) (y - 1)\r\n \r\nmain = print (b 3)','<br/>Тесты успешно пройдены!'),(4752,18,'nbumakov','2013-09-08 23:49:38',1,'f 1 = 1+1/1\r\nf n = 1+1/f (n - 1)\r\n \r\nmain = print (f 3)','<br/>Тесты успешно пройдены!'),(4751,20,'Yaro_t','2013-09-08 23:33:48',1,'{--Описать функцию sumfact n: \r\n\r\nsumfact n = 1!+2!+...+n!\r\n\r\n--}\r\n\r\nsumfact n = sumfact\' n 0   \r\n\r\nsumfact\' 1 p = 1+p\r\n\r\nsumfact\' n p = p + sumfact\' (n-1) (product[1..n])\r\n','<br/>Тесты успешно пройдены!'),(4750,19,'Yaro_t','2013-09-08 23:27:20',1,'{--Описать функцию \r\n\r\nsumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\n\r\n--}\r\n\r\nsumsin n = sumsin\' n 0 0  \r\n\r\nsumsin\' 0 p q = (sin p)/q\r\n\r\nsumsin\' n p q = sumsin\' (n-1) (p+n) ((sin n)+q)\r\n','<br/>Тесты успешно пройдены!'),(4749,19,'Yaro_t','2013-09-08 23:20:30',0,'{--Описать функцию \r\n\nsumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\n\n--}\r\n\nsumsin n = sumsin\' n 0 0  \r\n\nsumsin\' 1 p q = sin ((p+1)/(q+1))\r\n\nsumsin\' n p q = sumsin\' (n-1) (p+n-1) ((sin n)+q-1)\n','Выражение имеет неправильное значение: sumsin 1'),(4748,19,'Yaro_t','2013-09-08 23:20:17',0,'{--Описать функцию \r\n\nsumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\n\n--}\r\n\nsumsin n = sumsin\' n 0 0  \r\n\nsumsin\' 1 p q = sin ((p+1)/(q+1))\r\n\nsumsin\' n p q = sumsin\' (n-1) (p+n-1) ((sin n)+q-1)\n','Выражение имеет неправильное значение: sumsin 1'),(4745,19,'Yaro_t','2013-09-08 22:53:51',0,'{--Описать функцию \r\n\nsumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\n\n--}\r\n\nsumsin n = sin((sum [1..n]))/(sum [sin 1..sin n])\n','Хитрый тест номер 1 не пройден :(<br/>Подсказка: Для 3 что-то не так '),(4746,21,'Valentina Guleva','2013-09-08 23:13:48',1,'nseq 0 = 0\r\n\r\nnseq 1 = 1\r\n\r\nnseq n = nseq\' n 0\r\n\r\n--nseq\' 1 1 = 1\r\n\r\nnseq\' x y = if x <= y \r\n\r\n		then 0\r\n\r\n		else 1 + sum[nseq\' (x - i) i | i <- [(y+1)..x]]\r\n','<br/>Тесты успешно пройдены!'),(4747,19,'Yaro_t','2013-09-08 23:13:55',0,'{--Описать функцию \r\n\nsumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\n\n--}\r\n\nsumsin n = sumsin\' n 0 0  \r\n\nsumsin\' 1 p q = sin (p/q)\r\n\nsumsin\' n p q = sumsin\' (n-1) (p+n) ((sin n)+q)\n','Выражение имеет неправильное значение: sumsin 1'),(4743,24,'Yaro_t','2013-09-08 22:44:41',1,'{--Описать функцию b n, которая вычисляет \r\n\r\n0+1/(1+1/(2+1/(3+ ...+1/n))) - n дробей\r\n\r\n--}\r\n\r\nb n = b\' n 0\r\n\r\nb\' 1 p = p+1/(p+1)\r\n\r\nb\' n p= p+1/(b\'(n-1)(p+1))\r\n','<br/>Тесты успешно пройдены!'),(4744,20,'641524','2013-09-08 22:44:56',1,'sumfact n = sumfact\' n 1 1 0\r\nsumfact\' 0 i f s = s\r\nsumfact\' n i f s = sumfact\' (n-1) (i+1) (f*i) (s+f*i)','<br/>Тесты успешно пройдены!'),(4742,19,'3301494','2013-09-08 22:43:00',1,'  --- Вообще все правильно, почему система выдала ошибку - не знаю :(\r\nssin 0 = 0\r\n\r\nssin n = ssin (n - 1) + sin n\r\n\r\nsumsin n = sin (sum [1..n]) / ssin n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','Не удалось вычислить выражение \"sumsin 1\", проверьте правильность синтаксиса'),(4739,18,'anna','2013-09-08 22:33:41',1,'f 1 = 2;\r\n\r\nf n = 1 + 1/(f (n-1));\r\n  --- Точку с запятой всюду можно не писать\r\n','<br/>Тесты успешно пройдены!'),(4740,20,'641524','2013-09-08 22:34:09',0,'sumfact n = sumfact\' n 1 1 0\r\nsumfact\' 0 i f s\r\nsumfact\' n i f s = sumfact\' (n-1) (i+1) (f*i) (s+f)','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса'),(4741,20,'641524','2013-09-08 22:36:08',0,'sumfact n = sumfact\' n 1 1 0\r\nsumfact\' 0 i f s = s\r\nsumfact\' n i f s = sumfact\' (n-1) (i+1) (f*i) (s+f)','Выражение имеет неправильное значение: sumfact 2'),(4735,19,'641524','2013-09-08 22:22:47',1,'sumsin n = sumsin\' n 0 0\r\nsumsin\' 0 s1 s2 = sin s1 / s2\r\nsumsin\' n s1 s2 = sumsin\' (n-1) (n+s1) (sin n+s2)','<br/>Тесты успешно пройдены!'),(4736,20,'ip','2013-09-08 22:27:44',1,'sumfact n = sumfact2 n n 1 0\r\nsumfact2 m 0 p q = q\r\nsumfact2 m n p q = sumfact2 m (n-1) (p*(m+1-n)) (p*        (m+1-n)+q)','<br/>Тесты успешно пройдены!'),(4737,19,'ip','2013-09-08 22:30:15',1,'sumsin n = sin(n*(n+1)/2)/sumsin2 n 0\r\nsumsin2 0 p = p\r\nsumsin2 n p = sumsin2 (n-1) (p + sin n)','<br/>Тесты успешно пройдены!'),(4738,18,'anna','2013-09-08 22:32:57',0,'h1 1 = 2;\r\n\nh1 n = 1 + 1/(h1 (n-1));\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4733,19,'ip','2013-09-08 22:21:08',0,'sumsin n = sin(n*(n+1)/2)/sumsin2 n 0\r\nsumsin2 o p = p\r\nsumsin2 n p = sumsin2 (n-1) (p + sin n)','Выражение имеет неправильное значение: sumsin 1'),(4734,19,'ip','2013-09-08 22:22:28',0,'sumsin n = sin(n*(n+1)/2)/sumsin2 n 0\r\nsumsin2 o p = p\r\nsumsin2 n p = sumsin2 (n-1) (p + sin n)','Выражение имеет неправильное значение: sumsin 1'),(4732,24,'641524','2013-09-08 22:17:34',1,'b n = b\' n 1\r\nb\' 0 p = 0\r\nb\' n p = 1 / (p + b\' (n-1) (p+1))','<br/>Тесты успешно пройдены!'),(4731,18,'3301494','2013-09-08 22:16:22',1,'f 0 = 1\r\n\r\nf n = 1 + 1 / (f (n - 1))\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4729,19,'ip','2013-09-08 22:08:12',0,'sumsin n = sin(n*(n+1)/2)/sumsin2 n 0\r\nsumsin2 o p = p\r\nsumsin2 n p = sumsin2 (n-1) (p + sin n)','Выражение имеет неправильное значение: sumsin 1'),(4730,19,'ip','2013-09-08 22:16:07',0,'sumsin n = sin(n*(n+1)/2)/sumsin2 n 0\r\nsumsin2 o p = p\r\nsumsin2 n p = sumsin2 (n-1) (p + sin n)','Выражение имеет неправильное значение: sumsin 1'),(4728,24,'ip','2013-09-08 22:04:40',1,'b n = b2 n 0\r\nb2 0 k = k\r\nb2 n k = k + 1/b2 (n-1) (k+1)','<br/>Тесты успешно пройдены!'),(4726,18,'ip','2013-09-08 22:00:15',1,'f 0 = 1\r\nf n = 1 + 1/f (n-1)','<br/>Тесты успешно пройдены!'),(4727,24,'ip','2013-09-08 22:02:58',0,'b` 0 k = k\r\nb` n k = k + 1/b` (n-1) (k+1)\r\nb n = b` n 0','Не удалось вычислить выражение \"b 3\", проверьте правильность синтаксиса'),(4722,20,'617015','2013-09-08 21:33:18',1,'sumfact n = sumfact\' n 1 2 0 \r\n\r\nsumfact\' 1 fact count sum = sum + fact\r\n\r\nsumfact\' n fact count sum = sumfact\' (n-1) (fact*count) (count+1) (sum+fact)\r\n','<br/>Тесты успешно пройдены!'),(4723,21,'1595828','2013-09-08 21:36:41',1,'nseq n = nseq\' n 1 0\r\n\r\nnseq\' n ind ssum = if (ind <= n) \r\n\r\n then nseq\' n (ind + 1) (ssum + nseq\'\' n ind) \r\n\r\n  else ssum\r\n\r\nnseq\'\' n 1 = 1\r\n\r\nnseq\'\' n k =  if n > k \r\n\r\n then nseq\'\' (n - k) k + nseq\'\' (n - k) (k - 1) \r\n\r\n  else 0\r\n','<br/>Тесты успешно пройдены!'),(4724,21,'ArtemK','2013-09-08 21:45:31',1,'nseq n = nseq\' 1 n\r\nnseq\' x 0 = 1\r\nnseq\' x n = if x > n\r\n        then 0\r\n        else (nseq\' (x+1) n) + (nseq\' (x+1) (n-x))','<br/>Тесты успешно пройдены!'),(4725,18,'ip','2013-09-08 22:00:12',0,'f 0 = 1\r\nf n = 1 + 1/f (n-1)','<br/>Тесты успешно пройдены!'),(4721,21,'ArtemK','2013-09-08 21:24:21',0,'nseq n = nseq\' 1 n\r\nnseq\' x 0 = 1\r\nnseq\' x n = if n < 0 || x > n\r\n        then 0\r\n        else (nseq\' (x+1) n) + (nseq\' (x+1) (n-x))','Выражение имеет неправильное значение: nseq 20'),(4720,18,'641524','2013-09-08 21:24:21',1,'f 0 = 1\r\nf n = 1 + 1 / f (n-1)','<br/>Тесты успешно пройдены!'),(4719,23,'55363692','2013-09-08 20:23:45',1,'  --- Была опечатка в тесте, извините...\r\nimport System.Environment\r\n\r\n\r\n\r\nisCoprime\' k n m  = if (2 * k > n && 2 * k > m) \r\n\r\n    then True \r\n\r\n    else (not (mod n k == 0 && mod m k == 0)) && isCoprime\' (k + 1) n m\r\n\r\nisCoprime n m = isCoprime\' 2 n m\r\n\r\n\r\n\r\nc\' 0 k prod = 1\r\n\r\nc\' n k prod = if k > n \r\n\r\n    then 0 \r\n\r\n    else (if (isCoprime k prod) then c\' (n - k) (k + 1) (prod * k) else 0) + c\' n (k + 1) prod\r\n\r\nc n = c\' n 1 1','Не удалось вычислить выражение \"с 11\", проверьте правильность синтаксиса'),(4717,23,'55363692','2013-09-08 20:20:16',0,'import System.Environment\r\n\n\r\n\nisCoprime\' k n m  = if (2 * k > n && 2 * k > m) \r\n\n    then True \r\n\n    else (not (mod n k == 0 && mod m k == 0)) && isCoprime\' (k + 1) n m\r\n\nisCoprime n m = isCoprime\' 2 n m\r\n\n\r\n\nc\' 0 k prod = 1\r\n\nc\' n k prod = if k > n \r\n\n    then 0 \r\n\n    else (if (isCoprime k prod) then c\' (n - k) (k + 1) (prod * k) else 0) + c\' n (k + 1) prod\r\n\nc n = c\' n 1 1\r\n\n\r\n\nmain = print (c 10)\n','Не удалось вычислить выражение \"с 11\", проверьте правильность синтаксиса'),(4718,23,'55363692','2013-09-08 20:22:55',0,'','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(4711,23,'55363692','2013-09-08 20:13:48',0,'import System.Environment\r\n\r\nisCoprime\' k n m  = if (2 * k > n && 2 * k > m) \r\n    then True \r\n    else (not (mod n k == 0 && mod m k == 0)) \r\n    && isCoprime\' (k + 1) n m\r\nisCoprime n m = isCoprime\' 2 n m\r\n\r\nc\' 0 k prod = 1\r\nc\' n k prod = if k > n \r\n    then 0 \r\n    else (if (isCoprime k prod) \r\n    then c\' (n - k) (k + 1) (prod * k) else 0) + \r\n        c\' n (k + 1) prod\r\nc n = c\' n 1 1','Не удалось вычислить выражение \"с 11\", проверьте правильность синтаксиса'),(4712,18,'artem.gomerman','2013-09-08 20:14:26',1,'f n = f\' n 1\r\n\r\nf\' 1 p = p + 1\r\n\r\nf\' n p = f\' (n - 1) (1 / (1 + p))\r\n','<br/>Тесты успешно пройдены!'),(4713,24,'artem.gomerman','2013-09-08 20:15:27',1,'b n = b\' n 1 0\r\n\r\nb\' 0 p q = q\r\n\r\nb\' n p q = b\' (n - 1) (p + 1) (1 / (n + q))\r\n','<br/>Тесты успешно пройдены!'),(4714,19,'artem.gomerman','2013-09-08 20:15:51',1,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 p q = (sin p) / q\r\n\r\nsumsin\' n p q = sumsin\' (n - 1) (n + p)  (sin n + q)\r\n','<br/>Тесты успешно пройдены!'),(4715,20,'artem.gomerman','2013-09-08 20:16:18',1,'sumfact n = sumfact\' n 2 1 0\r\n\r\nsumfact\' 0 c p q = q\r\n\r\nsumfact\' n c p q = sumfact\' (n - 1) (c + 1) (p * c) (q + p)\r\n','<br/>Тесты успешно пройдены!'),(4716,21,'1595828','2013-09-08 20:20:03',0,'nseq n = nseq\' n 1 0\r\n\nnseq\' n ind ssum = if (ind <= n) \r\n\n then nseq\' n (ind + 1) (ssum + nseq\'\' n ind) \r\n\n  else ssum\r\n\nnseq\'\' 0 k = 1\r\n\nnseq\'\' n k =  if n > k \r\n\n then nseq\'\' n (k+1) + nseq\'\' (n - k) (k + 1) \r\n\n  else 0\r\n\n\n','Выражение имеет неправильное значение: nseq 1'),(4710,23,'55363692','2013-09-08 20:09:21',0,'import System.Environment\r\n\r\nisCoprime\' k n m  = if (2 * k > n && 2 * k > m) then True else (not (mod n k == 0 && mod m k == 0)) && isCoprime\' (k + 1) n m\r\nisCoprime n m = isCoprime\' 2 n m\r\n\r\nnseq\' 0 k prod = 1\r\nnseq\' n k prod = if k > n then 0 else (if (isCoprime k prod) then nseq\' (n - k) (k + 1) (prod * k) else 0) + nseq\' n (k + 1) prod\r\n\r\nc n = nseq\' n 1 1','Не удалось вычислить выражение \"с 11\", проверьте правильность синтаксиса'),(4709,23,'55363692','2013-09-08 20:06:49',0,'import System.Environment\r\n\r\nisCoprime\' k n m  = if (2 * k > n && 2 * k > m) then True else \r\n    (not (mod n k == 0 && mod m k == 0)) && isCoprime\' (k + 1) n m\r\nisCoprime n m = isCoprime\' 2 n m\r\n\r\nnseq\' 0 k prod = 1\r\nnseq\' n k prod = if k > n \r\n    then 0 \r\n    else (if (isCoprime k prod) then nseq\' (n - k) (k + 1) (prod * k) else 0) + \r\n    nseq\' n (k + 1) prod\r\n\r\nc n = nseq\' n 1 1','Не удалось вычислить выражение \"с 11\", проверьте правильность синтаксиса'),(4708,23,'55363692','2013-09-08 20:06:06',0,'import System.Environment\r\n\r\nisCoprime\' k n m  = if (2 * k > n && 2 * k > m) then True else \r\n    (not (mod n k == 0 && mod m k == 0)) && isCoprime\' (k + 1) n m\r\nisCoprime n m = isCoprime\' 2 n m\r\n\r\nnseq\' 0 k prod = 1\r\nnseq\' n k prod = if k > n \r\n    then 0 \r\n    else (if (isCoprime k prod) then nseq\' (n - k) (k + 1) (prod * k) else 0) + \r\n    nseq\' n (k + 1) prod\r\n\r\nnseq n = nseq\' n 1 1','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(4707,23,'1048693','2013-09-08 19:48:53',1,'  --- Была опечатка в тесте, извините...\r\nimport Control.Monad (when)\r\n\r\n--import Control.DeepSeq (deepseq)\r\n\r\n--import Control.Exception.Base (evaluate)\r\n\r\n\r\n\r\nimport qualified Data.Set as S\r\n\r\nimport qualified Data.Map as M\r\n\r\n\r\n\r\nmain = do\r\n\r\n--    evaluate $ foldr deepseq () $ map c [1..100]\r\n\r\n    putStrLn \"Done.\"\r\n\r\n\r\n\r\nc = length . decompose\r\n\r\n\r\n\r\n-- may be it is possible to implement simpler with just counting sum of any primes\r\n\r\ndecompose :: Integer -> [[Integer]]\r\n\r\ndecompose n | n > 1 = nseq\r\n\r\n    where\r\n\r\n        primes\'     = primes n\r\n\r\n        isPrime   p = p `elem` primes\'\r\n\r\n\r\n\r\n        -- should be optimized to produce every production only once =/\r\n\r\n        productions = M.fromList $ map ((m,ps) -> (m,S.fromList ps)) $ load 1 []\r\n\r\n            where\r\n\r\n                load m acc | m <= n = do\r\n\r\n                    p  <- primes\'\r\n\r\n                    (m,acc):(load (m*p) $ p:acc)\r\n\r\n                load m acc = []\r\n\r\n\r\n\r\n        nseq = work 0 n $ S.empty\r\n\r\n            where\r\n\r\n                work s n used | s < n = do\r\n\r\n                    x  <- [(s+1)..n]\r\n\r\n                    let ds = productions M.! x\r\n\r\n                    when (not $ S.null $ ds `S.intersection` used) []\r\n\r\n                    xs <- work x (n-x) $ ds `S.union`        used \r\n\r\n                    return $ x:xs\r\n\r\n                work _ 0 _ = [[]]\r\n\r\n                work _ _ _ = []\r\n\r\ndecompose 1 = [[1]]\r\n\r\ndecompose 0 = []\r\n\r\n\r\n\r\n-- profiling:\r\n\r\n--     with -O3:\r\n\r\n--         total time  =       38.29 secs   (38292 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 1,524,267,460 bytes  (excludes profiling overheads)\r\n\r\n--     with -threaded -O3 and -N2:\r\n\r\n--         total time  =       19.21 secs   (38424 ticks @ 1000 us, 2 processors)\r\n\r\n-- 	       total alloc = 1,524,267,780 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\nprimes :: Integer -> [Integer]\r\n\r\nprimes n | n > 1 = 2 : sieve [3,5..n]\r\n\r\n    where\r\n\r\n        sieve    []  = []\r\n\r\n        sieve (p:xs) = p : sieve (xs `minus` [p*p,p*p+2*p..n])\r\n\r\n\r\n\r\n        minus []              _            =      []\r\n\r\n        minus xs              []           =      xs\r\n\r\n        minus    (x:xt)    (y:yt) | x == y =      xt `minus` yt\r\n\r\n        minus xs@(x:xt)    (y:yt) | x >  y =      xs `minus` yt\r\n\r\n        minus    (x:xt) ys@(y:yt) | x <  y = x : (xt `minus` ys)\r\n\r\nprimes n = []','Не удалось вычислить выражение \"с 11\", проверьте правильность синтаксиса'),(4706,22,'55363692','2013-09-08 19:23:56',0,'import System.Environment\r\n\r\nisPrime\' k n = if (2 * k > n) then True else (mod n k /= 0) && isPrime\' (k + 1) n\r\nisPrime n = isPrime\' 2 n\r\n\r\ng\' k n = if (2 * k > n) then False else ((k /= (n - k)) && isPrime k && isPrime (n - k)) || g\' (k + 1) n\r\ng n = g\' 2 n','<br/>Тесты успешно пройдены!'),(4705,18,'Yaro_t','2013-09-08 19:00:09',1,'{--Описать функцию f n, которая вычисляет:\r\n\r\n1+1/(1+1/(1+ ...+1/1)) - всего n дробей \r\n\r\n--}\r\n\r\n\r\n\r\nf 1 = 2\r\n\r\nf n | n>0 = 1 + 1/f(n-1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4704,18,'Yaro_t','2013-09-08 18:58:09',0,'{--Описать функцию f n, которая вычисляет:\r\n\n1+1/(1+1/(1+ ...+1/1)) - всего n дробей \r\n\n--}\r\n\n\r\n\nf 1 = 1\r\n\nf 2 = 1.5\r\n\nf n | n>0 = 1 + 1/f(n-1)\r\n\n\n','Выражение имеет неправильное значение: f 1'),(4703,18,'Yaro_t','2013-09-08 18:53:40',0,'{--Описать функцию f n, которая вычисляет:\r\n\n1+1/(1+1/(1+ ...+1/1)) - всего n дробей \r\n\n--}\r\n\n\r\n\nf 1 = 1\r\n\nf n | n>0 = 1 + 1/(1+1/f(n-1)) \r\n\n\n','Выражение имеет неправильное значение: f 1'),(4700,21,'55363692','2013-09-08 18:44:12',1,'import System.Environment\r\n\r\nnseq\' 0 k = 1\r\nnseq\' n k = if k > n then 0 else nseq\' (n - k) (k + 1) + nseq\' n (k + 1)\r\nnseq n = nseq\' n 1','<br/>Тесты успешно пройдены!'),(4701,18,'Yaro_t','2013-09-08 18:51:02',0,'{--Описать функцию f n, которая вычисляет:\r\n\n1+1/(1+1/(1+ ...+1/1)) - всего n дробей \r\n\n--}\r\n\n\r\n\nf 1 = 1\r\n\nf n | n>0 = 1 + 1/f(n-1) \r\n\n\n','Выражение имеет неправильное значение: f 1'),(4702,18,'Yaro_t','2013-09-08 18:53:23',0,'{--Описать функцию f n, которая вычисляет:\r\n\n1+1/(1+1/(1+ ...+1/1)) - всего n дробей \r\n\n--}\r\n\n\r\n\nf 1 = 1\r\n\nf n | n>0 = 1 + 1/(1+1/f(n-1)) \r\n\n\n','Выражение имеет неправильное значение: f 1'),(4699,20,'55363692','2013-09-08 17:58:07',1,'import System.Environment\r\n\r\nsumfact\' k n sum prod = if k == n then sum + prod else sumfact\' (k + 1) n (sum + prod) (prod * (k + 1))\r\nsumfact n = sumfact\' 1 n 0 1','<br/>Тесты успешно пройдены!'),(4696,20,'480387','2013-09-08 17:28:17',1,'sumfact n= f n 1 1 0\r\n\r\nf 0 k prev count = count\r\n\r\nf m k prev count = f (m-1) (k+1) (prev*k) (count + prev*k)\r\n','<br/>Тесты успешно пройдены!'),(4697,19,'55363692','2013-09-08 17:34:48',1,'import System.Environment\r\n\r\nsumsin\' 0 sum sinsum = sin sum / sinsum\r\nsumsin\' n sum sinsum = sumsin\' (n - 1) (sum + n) (sinsum + sin n)\r\nsumsin n = sumsin\' n 0 0','<br/>Тесты успешно пройдены!'),(4698,23,'nomeansno','2013-09-08 17:47:06',1,'  --- Была опечатка в тесте, извините...\r\ngcd\' a 0 = a\r\n\r\n\r\n\r\ngcd\' a b = if a >= b then gcd\' b (a `mod` b)\r\n\r\n\r\n\r\nelse gcd\' b a\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nboth_prime a b = gcd\' a b == 1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nc n = g 0 n 1 True\r\n\r\n\r\n\r\ng i 0 m True = 1\r\n\r\n\r\n\r\ng i k m False = 0\r\n\r\n\r\n\r\ng i k m l = if i >= k then 0\r\n\r\n\r\n\r\nelse g (i+1) (k-i-1) (m*(i+1)) (l && both_prime m (i+1)) + g (i+1) k m l\r\n\r\n','Не удалось вычислить выражение \"с 11\", проверьте правильность синтаксиса'),(4695,19,'480387','2013-09-08 17:01:03',1,'sum n = sum\' n 0\r\n\r\nsum\' 0 count = count\r\n\r\nsum\' k count = sum\' (k-1) (count + k)\r\n\r\n\r\n\r\nsum_ n = sum_\' n 0\r\n\r\nsum_\' 0 count = count\r\n\r\nsum_\' k count = sum_\' (k-1) (count + sin(k))\r\n\r\n\r\n\r\nsumsin n = sin (Main.sum n) / sum_ n\r\n','<br/>Тесты успешно пройдены!'),(4694,22,'1048693','2013-09-08 17:00:58',1,'-- import Control.DeepSeq\r\n\r\n-- import Control.Exception.Base\r\n\r\n\r\n\r\nmain = do\r\n\r\n--    evaluate $ foldr deepseq () $ map goldbach [1..2000]\r\n\r\n    putStrLn \"Done.\"\r\n\r\n\r\n\r\ng = simple\'\r\n\r\n\r\n\r\nprimes :: Integer -> [Integer]\r\n\r\nprimes n | n > 1 = 2 : sieve [3,5..n]\r\n\r\n    where\r\n\r\n        sieve    []  = []\r\n\r\n        sieve (p:xs) = p : sieve (xs `minus` [p*p,p*p+2*p..n])\r\n\r\n\r\n\r\n        minus []              _            =      []\r\n\r\n        minus xs              []           =      xs\r\n\r\n        minus    (x:xt)    (y:yt) | x == y =      xt `minus` yt\r\n\r\n        minus xs@(x:xt)    (y:yt) | x >  y =      xs `minus` yt\r\n\r\n        minus    (x:xt) ys@(y:yt) | x <  y = x : (xt `minus` ys)\r\n\r\nprimes n = []\r\n\r\n\r\n\r\nsimple  n = let ps = primes n\r\n\r\n            in not $ null [ () | p <- ps, p < n `div` 2 + 1, p /= n - p, n-p `elem` ps ]\r\n\r\n\r\n\r\n-- profiling:\r\n\r\n--     total time  =        5.36 secs   (5361 ticks @ 1000 us, 1 processor)\r\n\r\n--     total alloc = 285,300,276 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n-- tiny boost because of little heuristic (search from the end of primes)\r\n\r\nsimple\' n = let ps  = primes n\r\n\r\n                ps\' = reverse [ p | p <- ps, p > n `div` 2 ]\r\n\r\n            in not $ null [ () | p <- ps\', p > n `div` 2, p /= n - p, n-p `elem` ps ]\r\n\r\n\r\n\r\n-- profiling:\r\n\r\n--     total time  =        5.11 secs   (5106 ticks @ 1000 us, 1 processor)\r\n\r\n--     total alloc = 294,296,568 bytes  (excludes profiling overheads)\r\n','<br/>Тесты успешно пройдены!'),(4692,18,'55363692','2013-09-08 16:08:01',1,'import System.Environment\r\n\r\nf 0 = 1\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4693,24,'55363692','2013-09-08 16:27:31',1,'import System.Environment\r\n\r\nf k n = if k == n then n else k + 1 / f (k + 1) n\r\nb n = f 0 n','<br/>Тесты успешно пройдены!'),(4691,22,'romos2007','2013-09-08 16:06:35',1,'{--\r\n\r\nЗадача 2-1*\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\nЦель: последовательный перебор возможных слагаемых, начиная с 2 и заканчивая n/2 (т.к. сумма коммутативна).\r\n\r\n	На каждом шаге проверять, являются ли слагаемые простыми.\r\n\r\n-}\r\n\r\n\r\n\r\ng n = g\' 2 (n-2)\r\n\r\ng\' a1 a2 = if (a1>=a2)		-- если первое слагаемое больше второго (либо равно ему), то заведомо False, \r\n\r\n						-- т.к. сумма коммутативна. Следовательно, мы уже 0перебрали все возможные варианты и не нашли подходящего\r\n\r\n			then False\r\n\r\n			else\r\n\r\n				if (prime a1 && prime a2)	-- проверяем, являются ли слагаемые простыми.\r\n\r\n				then True					-- Если да, то возвращаем True\r\n\r\n				else g\' (a1+1) (a2-1)		-- Если нет, то переходим к следующей паре слагаемых.\r\n  --- Просто как вариант оптимизации, можно отдельно рассмотреть случаи когда n четное, и когда нечетное. Если нечетное, то одно число точно равно 2 и задача упрощается. Если четное, то можно в этом месте увеличивать и уменьшать на 2\r\n\r\n\r\n--Функция, проверяющая простоту числа\r\n\r\nprime 1 = True\r\n\r\nprime 2 = True\r\n\r\nprime a = prime\' 2 a 	--последовательно ищем разложение на множители (начиная с 2) и проверяем их на простоту\r\n\r\nprime\' a b = if (a==b) 	-- в этом случае мы дошли до самого числа, т.е. нашли разложение a = a * 1. Значит, a - простое.\r\n\r\n			 then True\r\n\r\n			 else \r\n\r\n			 	if (mod b a == 0) 	-- если a делится на b, то это признак \"непростоты\" числа\r\n\r\n				then False\r\n\r\n				else prime\' (a+1) b	-- если не делится, то продолжаем поиск\r\n','<br/>Тесты успешно пройдены!'),(4690,21,'6053606','2013-09-08 15:58:47',1,'nseq n = sum (map (nseq\' n 0) [1..n])\r\nnseq\' n acc i = if acc + i == n\r\n                then 1\r\n                else if acc + i < n\r\n                     then sum (map (nseq\' n (acc + i)) [i + 1..n])\r\n                     else 0','<br/>Тесты успешно пройдены!'),(4689,23,'nomeansno','2013-09-08 15:54:50',0,'gcd\' a 0 = a\r\n\n\r\n\ngcd\' a b = if a >= b then gcd\' b (a `mod` b)\r\n\n\r\n\nelse gcd\' b a\r\n\n\r\n\n\r\n\n\r\n\nboth_prime a b = a == b || gcd\' a b == 1\r\n\n\r\n\n\r\n\n\r\n\nc n = g 0 n 1 True\r\n\n\r\n\ng i 0 m True = 1\r\n\n\r\n\ng i 0 m False = 0\r\n\n\r\n\ng i k m l = if i >= k then 0\r\n\n\r\n\nelse g (i+1) (k-i-1) (m*(i+1)) (l && both_prime m (i+1)) + g (i+1) k m l\r\n\n\n','Выражение имеет неправильное значение: c 20'),(4686,24,'6053606','2013-09-08 14:33:00',1,'b n = b\' 0 n\r\nb\' i 0 = i\r\nb\' i n = i + 1/b\'(i+1) (n-1)\r\n','<br/>Тесты успешно пройдены!'),(4687,19,'6053606','2013-09-08 14:52:37',1,'sumsin n = sin (sum [1..n]) / sumsin\' n 0\r\nsumsin\' 0 acc = acc\r\nsumsin\' n acc = sumsin\' (n - 1) (sin n + acc)','<br/>Тесты успешно пройдены!'),(4688,20,'6053606','2013-09-08 15:02:58',1,'sumfact n = sumfact\' n 0\r\nsumfact\' 0 acc = acc\r\nsumfact\' n acc = sumfact\' (n - 1)(fact n + acc)\r\nfact n = fact\' n 1\r\nfact\' 1 acc = acc\r\nfact\' n acc = fact\' (n - 1) (n * acc)\r\n','<br/>Тесты успешно пройдены!'),(4683,20,'5543298','2013-09-08 14:04:37',1,'fact\' 1 p m s = s + p * m\r\n\r\nfact\' n p m s = fact\' (n-1) (p + 1) (p * m) (s + p * m)\r\n\r\nsumfact n = fact\' n 1 1 0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4684,20,'SNNatalieS','2013-09-08 14:07:11',1,'sumfact n = f n 2 1 0\r\nf 1 m g s = s + g\r\nf n m g s = f (n - 1) (m + 1) (g * m) (s + g)','<br/>Тесты успешно пройдены!'),(4685,18,'6053606','2013-09-08 14:21:13',1,'f 0 = 1\r\nf n = 1 + 1/f(n-1)','<br/>Тесты успешно пройдены!'),(4682,21,'1048693','2013-09-08 13:36:49',1,'  --- ОК, засчитано, но тут ваше решение, видимо, очень неэффективное - нет смысла\r\n  --- генерировать списки, если задача стоит только их сосчитать..  \r\nmain = print $ nseq 80\r\n\r\n\r\n\r\nnseq = length . plain\r\n\r\n\r\n\r\n\r\n\r\nplain :: Int -> [[Int]]\r\n\r\nplain n = work 0 n\r\n\r\n    where\r\n\r\n        work p n | p < n = do\r\n\r\n            x  <- [(p+1)..n]\r\n\r\n            xs <- work x (n-x)\r\n\r\n            return $ x:xs\r\n\r\n        work _ 0 = [[]]\r\n\r\n        work _ _ = []\r\n\r\n\r\n\r\n-- without options:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.000s 0m0.008s\r\n\r\n--         0m5.524s 0m1.692s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        2.19 secs   (2190 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 217,882,272 bytes  (excludes profiling overheads)\r\n\r\n-- with -O3:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.008s 0m0.000s\r\n\r\n--         0m3.412s 0m0.060s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        0.94 secs   (941 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 129,358,772 bytes  (excludes profiling overheads)\r\n','<br/>Тесты успешно пройдены!'),(4681,20,'5543298','2013-09-08 13:06:22',0,'fact\' 1 p r = r + p\r\n\nfact\' n p r = fact\' (n-1) (p * (p + 1)) (r + p)\r\n\nsumfact n = fact\' n 1 0\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\n','Выражение имеет неправильное значение: sumfact 4'),(4679,20,'Valentina Guleva','2013-09-08 10:50:49',0,'sumfact n = fact n + (sumfact (n - 1))\r\n\nfact 0 = 1\r\n\nfact 1 = 1\r\n\nfact n = n * (fact (n - 1))\n','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса'),(4680,20,'Valentina Guleva','2013-09-08 10:53:44',1,'--sumfact 0 = 1\r\n\r\nsumfact 1 = 1\r\n\r\nsumfact n = fact n + (sumfact (n - 1))\r\n\r\nfact 0 = 1\r\n\r\nfact 1 = 1\r\n\r\nfact n = n * (fact (n - 1))\r\n','<br/>Тесты успешно пройдены!'),(4678,19,'Valentina Guleva','2013-09-08 10:49:43',1,'sumsin n = sin (sumint n)/sumsin\' n\r\n\r\nsumint 0 = 0\r\n\r\nsumint n = n + (sumint (n - 1))\r\n\r\nsumsin\' 0 = 0\r\n\r\nsumsin\' n = sin n + (sumsin\' (n - 1))\r\n','<br/>Тесты успешно пройдены!'),(4676,18,'Valentina Guleva','2013-09-08 10:47:41',1,'f 1 = 2\r\n\r\nf n = 1 + (1/f (n - 1))\r\n','<br/>Тесты успешно пройдены!'),(4677,24,'Valentina Guleva','2013-09-08 10:49:05',1,'b 0 = 0\r\n\r\nb n = 0 + (1/frac\'(n - 1) n)\r\n\r\nfrac\' 0 a = a\r\n\r\nfrac\' x y = (y - x) + 1/frac\' (x - 1) y \r\n','<br/>Тесты успешно пройдены!'),(4675,18,'Valentina Guleva','2013-09-08 10:46:29',0,'f 1 = 2\r\n\nf n = 1 + (1/frac (n - 1))\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4674,18,'Valentina Guleva','2013-09-08 10:44:44',0,'frac 1 = 2\r\n\nfrac n = 1 + (1/frac (n - 1))\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4673,19,'5543298','2013-09-08 03:10:26',1,'--ssin 0 r = r\r\n\r\n--ssin n r = ssin (n - 1) (r + sin n)\r\n\r\n\r\n\r\nssin 0 = 0\r\n\r\nssin n = ssin (n - 1) + sin n\r\n\r\nsins 0 r = sin r\r\n\r\nsins n r = sins (n - 1) (r + n)\r\n\r\nsumsin n = (sins n 0) / ssin n\r\n\r\n\r\n\r\n{--sins 0 r = sin r\r\n\r\nsins n r = sins (n - 1) (r + n)\r\n\r\nsumsin n = (sins n 0) / sin n--}\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4672,24,'5543298','2013-09-08 02:46:23',1,'b\' 1 n = n - 1 + 1 / n\r\n\r\nb\' n p = p - 1 + 1 / (b\' (n - 1) (p + 1))\r\n\r\nb 1  = 1\r\n\r\nb n = b\' n 1\r\n','<br/>Тесты успешно пройдены!'),(4671,18,'5543298','2013-09-08 02:12:24',1,'f 1 = 2\r\n\r\nf n = 1 + 1 / (f (n - 1))\r\n','<br/>Тесты успешно пройдены!'),(4669,19,'SNNatalieS','2013-09-08 02:01:53',1,'sumsin n = f n 1 (sin 1)\r\nf 1 ds ss = sin  ds / ss\r\nf n ds ss = f (n - 1) (ds + n) (ss + sin n)','<br/>Тесты успешно пройдены!'),(4670,24,'5543298','2013-09-08 02:09:33',0,'b\' 1 n = n - 1 + 1 / n\r\n\nb\' n p = 1 + 1 / (b\' (n - 1) (p + 1))\r\n\nb n = b\' n 1 - 1\n','Хитрый тест номер 1 не пройден :(<br/>Подсказка: При больших n должно получаться примерно 0.697'),(4667,24,'SNNatalieS','2013-09-08 01:05:31',0,'b n = f n 1\r\nf 0 p = 0\r\nf n p = 1 / (p + f (n -1) (p + 1))','<br/>Тесты успешно пройдены!'),(4668,24,'SNNatalieS','2013-09-08 01:05:43',1,'b n = f n 1\r\nf 0 p = 0\r\nf n p = 1 / (p + f (n -1) (p + 1))','<br/>Тесты успешно пройдены!'),(4665,18,'5543298','2013-09-07 23:30:54',0,'f 1 = 2\r\n\nf n = 1 + 1 / (f (n - 1))\n','<br/>Тесты успешно пройдены!'),(4666,18,'SNNatalieS','2013-09-08 00:44:13',1,'f 1 = 2\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4661,18,'617015','2013-09-07 21:06:38',1,'f 0 = 1\r\n\r\nf n =  1 + (1/ f (n-1))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4662,24,'617015','2013-09-07 21:11:41',1,'b n = b\' n 0\r\n\r\nb\' 0 p = p\r\n\r\nb\' n p = p + 1/(b\' (n-1) (p + 1) )\r\n','<br/>Тесты успешно пройдены!'),(4663,19,'617015','2013-09-07 21:15:40',1,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 p k = sin p / k\r\n\r\nsumsin\' n p k = sumsin\' (n-1) (p+n) (k+ sin n)\r\n','<br/>Тесты успешно пройдены!'),(4664,20,'1170660','2013-09-07 21:37:30',1,'   --- ОК, засчитано, но можно написать эффективнее (сразу считать и произведение и сумму)\r\nsumfact n = sumfact\' n 0\r\n\r\nsumfact\' 0 p = p\r\n\r\nsumfact\' n p = sumfact\' (n-1)(p + fact n 1)\r\n\r\n\r\n\r\nfact 1 p  = p\r\n\r\nfact n p = fact (n-1) (n*p)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4659,19,'1170660','2013-09-07 20:07:37',1,'sumsin n = sin (sumparam n) / sumfunc n sin\r\n\r\n\r\n\r\nsumparam 1 = 1\r\n\r\nsumparam n = n + sumparam(n-1)\r\n\r\n\r\n\r\nsumfunc 0 p = p 0\r\n\r\nsumfunc n p = p n + sumfunc (n-1) p\r\n','<br/>Тесты успешно пройдены!'),(4660,22,'8519021','2013-09-07 20:32:57',1,'g n = g\' n 1\r\n\r\ng\' n i\r\n\r\n  | i == n = False\r\n\r\n  | i /= n - i && isPrime i 2 && isPrime (n - i) 2 = True\r\n\r\n  | otherwise = g\' n (i + 1)\r\n\r\nisPrime n i\r\n\r\n  | n == 1 = False\r\n\r\n  | i <= div n 2 = if mod n i /= 0 then isPrime n (i + 1) else False\r\n     --- Тут лучше, конечно, проверять i*i < n \r\n\r\n  | otherwise = True\r\n','<br/>Тесты успешно пройдены!'),(4655,18,'2501950','2013-09-07 17:45:19',1,'f 0 = 1\r\nf n = 1 + 1/ f(n-1)','<br/>Тесты успешно пройдены!'),(4656,19,'2501950','2013-09-07 18:55:04',1,'sumsin n = sumsin\' n 0 0\r\nsumsin\' 0 s p= sin s / p\r\nsumsin\' n s p = sumsin\' (n-1) (s+n) (p+sin n) ','<br/>Тесты успешно пройдены!'),(4657,20,'2501950','2013-09-07 19:54:24',0,'sumfact n = sumfact\' n 0 \r\nsumfact\' 0 s = s\r\nsumfact\' n s = sumfact\' (n-1) ((1+s)*n) ','<br/>Тесты успешно пройдены!'),(4658,20,'2501950','2013-09-07 19:54:36',1,'sumfact n = sumfact\' n 0 \r\nsumfact\' 0 s = s\r\nsumfact\' n s = sumfact\' (n-1) ((1+s)*n) ','<br/>Тесты успешно пройдены!'),(4654,18,'2501950','2013-09-07 17:44:02',0,'f 0 = 1\r\n\nf n = 1 + 1/ f(n-1)\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4653,21,'romos2007','2013-09-07 17:30:42',1,'{--\r\n\r\nЗадача 1-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\n{- Раскладываем в порядке убывания первого слагаемого.\r\n\r\n\r\n\r\n	f(s, e, n, c) - вспомогательная функция\r\n\r\n	s - с какого слагаемого хотим начать раскладывать\r\n\r\n	e - максимальное слагаемое, которое может быть первым в разложении n. \r\n\r\n		(Этот параметр, в принципе, лишний, т.к. может быть вычислен из n по ходу выполнения)\r\n\r\n	n - \"начальное число\", раскладываемое на слагаемые\r\n\r\n	c - счетчик количества разложений\r\n\r\n-}\r\n\r\n\r\n\r\nnseq n = f 1 (div (n-1) 2) n 1	{-- s = 1,\r\n\r\n									e = (n-1)/2), т.к. очевидно, что первое слагаемое может быть равно максимум (n-1)/2,\r\n\r\n												чтобы удовлетворять свойству возрастания последовательности разложения\r\n\r\n									n = n,\r\n\r\n									c = 1, учитываем сразу тривиальное разложение.\r\n\r\n								--}\r\n\r\n								\r\n\r\nf s e n c = if s>e 	-- если первое слагаемое больше половины числа, то это разложение уже не будет возрастающим, \r\n\r\n					-- следовательно, не считается (+0)\r\n\r\n			then c+0\r\n\r\n			else\r\n\r\n				\r\n\r\n				if s<e\r\n\r\n				then f (s+1) e n (c + f (s+1) (div (n-s-1) 2) (n-s) 1) \r\n\r\n													{-если все ОК с первым слагаемым, то идем дальше и раскладываем \r\n\r\n													остаток от исходного числа (n-start), начиная со след.слагаемого (start+1), \r\n\r\n													и считаем, сколькими способами получится сделать это.\r\n\r\n													В итоге, прибавим к имеющимся разложениям.-}\r\n\r\n				\r\n\r\n				else c+1 -- если s==e, то, очевидно, +1 к количеству разложений, \r\n\r\n						 -- т.к. дошли до макс. допустимого первого слагаемого больше из текущего n мы выжаить не сможем\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4652,20,'romos2007','2013-09-07 15:45:51',1,'{--\r\n\r\nЗадача 1-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nsumfact n = sf 1 1 n 0\r\n\r\nsf i a 1 summ = summ + a\r\n\r\nsf i a n summ = sf (i+1) (a*(i+1)) (n-1) (summ+a)\r\n\r\n\r\n\r\n{- sf - вспомогательная функция\r\n\r\n	i - счетчик для факториала i! на каждом i-ом шаге\r\n\r\n	a - запоминалка последнего вычисленного факториала (=> след. факториал вычисляется a*(i+1))\r\n\r\n	n - счетчик от n до 1, свидетельствующий об окончании программы при значении 1\r\n\r\n	summ - аккумулятор суммы факториалов;\r\n\r\n-}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4651,20,'romos2007','2013-09-07 15:35:07',0,'{--\r\n\nЗадача 1-4\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\nsumfact n = sf 1 n 0\r\n\nsf a 1 summ = summ + a\r\n\nsf a n summ = sf (a*(a+1)) (n-1) (summ+a)\r\n\n\r\n\n{- sf - вспомогательная функция\r\n\n	a - запоминалка последнего вычисленного факториала;\r\n\n	n - счетчик от n до 1\r\n\n	summ - аккумулятор суммы факториалов;\r\n\n-}\r\n\n\n','Выражение имеет неправильное значение: sumfact 4'),(4650,20,'romos2007','2013-09-07 15:34:36',0,'','Не удалось вычислить выражение \"sumfact 1\", проверьте правильность синтаксиса'),(4649,19,'romos2007','2013-09-07 15:30:35',1,'{--\r\n\r\nЗадача 1-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nsumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 summ sines = sin(summ) / sines\r\n\r\nsumsin\' a summ sines = sumsin\' (a-1) (summ + a) (sines + sin(a))\r\n\r\n\r\n\r\n{- sumsin\' - вспомогательная функция\r\n\r\n	a - счетчик от n до 1 для контроля количества слагаемых;\r\n\r\n	summ - аккумулятор суммы в числителе, от которой в итоге будет взят синус;\r\n\r\n	sines - аккумулятор синусов в знаменателе;\r\n\r\n-}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4647,18,'romos2007','2013-09-07 15:16:13',1,'{--\r\n\r\nЗадача 1-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nf 1 = 2\r\n\r\nf n = 1 + 1 / f(n-1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4648,24,'romos2007','2013-09-07 15:24:00',1,'{--\r\n\r\nЗадача 1-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nb 0 = 0\r\n\r\nb n = f 1 n \r\n\r\n-- f - вспомогательная функция со счетчиком в качестве первого аргумента (для хранения первого слагаемого в знаменателе дроби)\r\n\r\n-- когда доходим до последней дроби, получаем в первом счетчике начальное значение \'n\'.\r\n\r\n\r\n\r\nf a 1 = 1 / a\r\n\r\nf a n = 1 / (a + f (a+1) (n-1))\r\n','<br/>Тесты успешно пройдены!'),(4646,20,'MaryK','2013-09-07 14:59:55',1,'module Func where\r\n\r\nimport Prelude(Bool(..),Int(), Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<))\r\n\r\nf::Int->Int\r\n\r\nf 1 = 1\r\n\r\nf n = f(n-1)*n \r\n\r\nsumfact::Int->Int\r\n\r\nsumfact n = s\' n 0\r\n\r\ns\' 0 p = p\r\n\r\ns\' n p = s\'(n-1) (p + f n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4645,19,'MaryK','2013-09-07 14:39:01',1,'\r\nmodule Func where\r\n\r\nimport Prelude(Bool(..),Int(), Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<))\r\n\r\nsumsin::Int->Float\r\n\r\nsumsin n = s\' n 0 0 1\r\n\r\ns\' 0 s p k = sin(s)/p\r\n\r\ns\' n s p k = s\'(n-1) (s+k) (p+sin(k)) (k+1)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4644,23,'87635585','2013-09-07 14:17:27',1,'c n = c\' n 1 []\r\nc\' sum pred l = if 2 * pred >= sum then (if  all (f sum) l then 1 else 0) else c\' sum (pred + 1) l + if all (f pred) l then \r\n c\' (sum - pred) (pred + 1) (pred : l) else 0\r\nf a b = gcd a b == 1','<br/>Тесты успешно пройдены!'),(4643,23,'87635585','2013-09-07 13:48:24',0,'c n = c\' n 1\r\nc\' sum pred = if 2 * pred >= sum then 1 else c\' sum (pred + 1) + if gcd sum pred == 1 then \r\n c\' (sum - pred) (pred + 1) else 0','Выражение имеет неправильное значение: c 9'),(4642,22,'87635585','2013-09-07 13:39:06',1,'g n = g\' 1 (n - 1)\r\ng\' a b = if a >= b then False else if prime a && prime b then True else  g\' (a + 1) (b - 1)\r\nprime 1 = False\r\nprime n = prime\' n (div n 2)\r\nprime\' n n\' = if n\' == 1 then True else if mod n n\' == 0 then False else prime\' n (n\' - 1)   ','<br/>Тесты успешно пройдены!'),(4641,24,'MaryK','2013-09-07 12:13:14',1,'\r\nmodule Func where\r\n\r\nimport Prelude(Bool(..),Int(), Show(..), Eq(..), Float(..), Num(..), Fractional(..), (&&), (>), (<))\r\n\r\nb::Int->Float\r\n\r\nb n = b\' n 0\r\n\r\nb\' 0 p = p\r\n\r\nb\' n p = p + 1/(b\'(n-1)(p+1))\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4640,24,'MaryK','2013-09-07 12:11:21',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..), Float(..), Num(..), Fractional(..), (&&))\r\n\nb::Int->Float\r\n\nb n = b\' n 0\r\n\nb\' 0 p = p\r\n\nb\' n p = p + 1/(b\'(n-1)(p+1))\r\n\n\r\n\n\n','Не удалось вычислить выражение \"let res = b 100 in res > 0.69777 && res < 0.69778\", проверьте правильность синтаксиса'),(4637,24,'1595828','2013-09-07 10:07:26',1,'b n = b\' n n \r\n\r\nb\' 0 ans = if ans/= 0 then ans else 0\r\n\r\nb\' k ans = b\' (k-1) (k-1+(1/ans))  \r\n','<br/>Тесты успешно пройдены!'),(4638,20,'1595828','2013-09-07 10:24:46',1,'sumfact 0 = 1\r\n\r\nsumfact n = sumfact\'  n 0 1 n\r\n\r\nsumfact\' 0 ps pp n=ps\r\n\r\nsumfact\' pn ps pp n =sumfact\' (pn-1) (ps+pp) (pp*(n-pn+2)) n \r\n','<br/>Тесты успешно пройдены!'),(4639,24,'MaryK','2013-09-07 12:10:47',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..), Float(..), Num(..), Fractional(..))\r\n\nb::Int->Float\r\n\nb n = b\' n 0\r\n\nb\' 0 p = p\r\n\nb\' n p = p + 1/(b\'(n-1)(p+1))\r\n\n\r\n\n\n','Не удалось вычислить выражение \"let res = b 100 in res > 0.69777 && res < 0.69778\", проверьте правильность синтаксиса'),(4636,19,'1595828','2013-09-07 09:51:26',1,'sumsin n = sumsin\' 0 0 n\r\n\r\nsumsin\' sn ss 0= if ss/=0 then (sin(sn))/ss else 0\r\n\r\nsumsin\' sn ss pn = sumsin\'(pn+sn) (ss+(sin pn)) (pn-1)\r\n','<br/>Тесты успешно пройдены!'),(4635,21,'8519021','2013-09-07 01:38:32',1,'nseq n = nseq\' n 1 \r\n\r\nnseq\' n i\r\n\r\n  | i == n = 1\r\n\r\n  | i < n = nseq\' (n - i) (i + 1) + nseq\' n (i + 1) \r\n\r\n  | otherwise = 0\r\n','<br/>Тесты успешно пройдены!'),(4634,18,'MaryK','2013-09-07 00:01:31',1,'module Func where\r\n\r\nimport Prelude(Bool(..), Int(), Show(..), Eq(..),Float(..), Num(..), Fractional(..), Ord(..), (&&))\r\n\r\nf::Int->Float\r\n --- Первые три строчки можно и не писать\r\nf 0 = 1\r\n\r\nf n = 1 + (1/(f(n-1)))\r\n','<br/>Тесты успешно пройдены!'),(4632,18,'MaryK','2013-09-06 23:54:10',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..),Float(..), Num(..), Fractional(..))\r\n\nf::Int->Float\r\n\nf 0 = 1\r\n\nf n = 1 + (1/(f(n-1)))\n','Не удалось вычислить выражение \"let phi = f 100 in (phi > 1.618) && (phi < 1.619)\", проверьте правильность синтаксиса'),(4633,18,'MaryK','2013-09-06 23:54:50',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..),Float(..), Num(..), Fractional(..))\r\n\nf::Int->Float\r\n\nf 0 = 1\r\n\nf n = 1 + (1/(f(n-1)))\n','Не удалось вычислить выражение \"let phi = f 100 in (phi > 1.618) && (phi < 1.619)\", проверьте правильность синтаксиса'),(4630,18,'MaryK','2013-09-06 23:52:30',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..),Float(..), Num(..), Fractional(..))\r\n\nfunc::Int->Float\r\n\nfunc 0 = 1\r\n\nfunc n = 1 + (1/(func(n-1)))\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4631,18,'MaryK','2013-09-06 23:52:43',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..), Float(..), Num(..), Fractional(..))\r\n\nf::Int->Float\r\n\nf 0 = 1\r\n\nf n = 1 + (1/(func(n-1)))\r\n\n\r\n\n\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4629,18,'MaryK','2013-09-06 23:51:58',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..),Float(..), Num(..), Fractional(..))\r\n\nfunc::Int->Float\r\n\nfunc 0 = 1\r\n\nfunc n = 1 + (1/(func(n-1)))\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4626,20,'15309342','2013-09-06 20:30:44',1,'sumfact n = sumfact1 n 1 1 2\r\nsumfact1 1 x y z = y\r\nsumfact1 n x y z = sumfact1 (n - 1) (x * z) (y + x * z) (z + 1)','<br/>Тесты успешно пройдены!'),(4627,18,'MaryK','2013-09-06 23:50:27',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..),Float(..), Num(..), Fractional(..))\r\n\nfunc::Int->Float\r\n\nfunc 0 = 1\r\n\nfunc n = 1 + (1/(func(n-1)))\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4628,18,'MaryK','2013-09-06 23:50:45',0,'\r\n\nmodule Func where\r\n\nimport Prelude(Bool(..),Int(), Show(..), Eq(..),Float(..), Num(..), Fractional(..))\r\n\nfunc::Int->Float\r\n\nfunc 0 = 1\r\n\nfunc n = 1 + (1/(func(n-1)))\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4623,18,'15309342','2013-09-06 20:27:53',1,'f 0 = 1\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4624,24,'15309342','2013-09-06 20:29:14',1,'b n = b1 1 n\r\nb1 x 0 = 0\r\nb1 x y = 1 / (x + b1 (x + 1) (y - 1))','<br/>Тесты успешно пройдены!'),(4625,19,'15309342','2013-09-06 20:29:53',1,'sumsin n = sumsin1 n 1 (sin 1)\r\nsumsin1 1 x y = sin x / y\r\nsumsin1 n x y = sumsin1 (n - 1) (n + x) (y + sin n)','<br/>Тесты успешно пройдены!'),(4619,24,'1170660','2013-09-06 16:28:54',1,'b n = b\' n 0\r\n\r\nb\' 0 n = n\r\n\r\nb\' n p = p +1/b\'(n-1)(p+1) \r\n','<br/>Тесты успешно пройдены!'),(4620,23,'nomeansno','2013-09-06 20:21:51',0,'','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(4621,23,'nomeansno','2013-09-06 20:22:44',0,'gcd\' a 0 = a\r\n\ngcd\' a b = if a >= b then gcd\' b (a `mod` b)\r\n\nelse gcd\' b a\r\n\n\r\n\nboth_prime a b = a == b || gcd\' a b == 1\r\n\n\r\n\nf n = g 0 n 1\r\n\ng i 0 m = if both_prime (m `div` i) i then 1\r\n\nelse 0\r\n\ng i k m = if i >= k then 0\r\n\nelse g (i+1) (k-i-1) (m*(i+1)) + g (i+1) k m\r\n\n\r\n\n\r\n\n\n','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(4622,23,'nomeansno','2013-09-06 20:24:33',2,'  --- Вы, на самом деле, взаимную простоту проверяете только для последнего числа (то, что оно взаимно простое с остальными)\r\ngcd\' a 0 = a\r\n\r\ngcd\' a b = if a >= b then gcd\' b (a `mod` b)\r\n\r\nelse gcd\' b a\r\n\r\n\r\n\r\nboth_prime a b = a == b || gcd\' a b == 1\r\n\r\n\r\n\r\nc n = g 0 n 1\r\n\r\ng i 0 m = if both_prime (m `div` i) i then 1\r\n\r\nelse 0\r\n\r\ng i k m = if i >= k then 0\r\n\r\nelse g (i+1) (k-i-1) (m*(i+1)) + g (i+1) k m\r\n\r\n\r\n\r\n\r\n\r\n\r\n','Выражение имеет неправильное значение: c 20'),(4617,21,'3270666','2013-09-06 15:32:29',1,'nseq n = nseq\' n n\r\nnseq\' 0 0 = 1\r\nnseq\' 1 1 = 1\r\nnseq\' 2 2 = 1\r\nnseq\' n m = if (m * (m + 1) / 2) < n\r\n  then 0\r\n  else nseq\' (n - m) (min (n - m) (m - 1)) + nseq\' n (m - 1)','<br/>Тесты успешно пройдены!'),(4618,18,'1170660','2013-09-06 16:27:07',1,'f 0 = 1\r\n\r\nf n = 1 + 1/f(n-1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4614,21,'3226573','2013-09-06 14:28:35',1,'nseq\' n m = if n == m then 1\r\n            else if n < m then 0\r\n            else (nseq\' n (m + 1)) + (nseq\' (n - m) (m + 1))\r\nnseq n = nseq\' n 1','<br/>Тесты успешно пройдены!'),(4615,22,'3226573','2013-09-06 14:46:53',0,'is_prime\' 1 d = False\r\nis_prime\' n d = if n == d then True\r\n                        else if (n mod d) == 0 then False\r\n                        else is_prime\' n (d + 1)\r\nis_prime n = is_prime\' n 2\r\n\r\ng\' a b = if a >= b then False\r\n             else if (is_prime a) && (is_prime b) then True\r\n             else g\' (a + 1) (b - 1)\r\ng n = g\' 1 (n - 1)','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(4616,22,'3226573','2013-09-06 14:49:57',1,'is_prime\' 1 d = False\r\nis_prime\' n d = if n == d then True\r\n  --- Можно, конечно, остановить проверку гораздо раньше, не проверять до n\r\n                else if (mod n d) == 0 then False\r\n                else is_prime\' n (d + 1)\r\nis_prime n = is_prime\' n 2\r\n\r\ng\' a b = if a >= b then False\r\n         else if (is_prime a) && (is_prime b) then True\r\n         else g\' (a + 1) (b - 1)\r\ng n = g\' 1 (n - 1)','<br/>Тесты успешно пройдены!'),(4612,20,'3226573','2013-09-06 12:38:07',1,'sumfact\' 0 p = p\r\nsumfact\' n p = sumfact\' (n - 1) (n * (1 + p))\r\nsumfact n = sumfact\' n 0','<br/>Тесты успешно пройдены!'),(4613,21,'3226573','2013-09-06 14:09:27',0,'nseq\' n n = 1\r\nnseq\' n min = (nseq\' n (min + 1)) + (nseq\' (n - min) (min + 1))\r\nnseq n = nseq\' n 1','Не удалось вычислить выражение \"nseq 1\", проверьте правильность синтаксиса'),(4610,18,'1595828','2013-09-06 11:35:06',1,'f 0=1\r\n\r\nf n = 1+1/f (n-1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4611,23,'deripaska','2013-09-06 12:21:25',1,'﻿{--\r\n\r\n	task 02-02\r\n\r\n*Дополнительная задача*\r\n\r\nОпишите функцию c n, которая для данного целого числа n вычисляет, сколько есть способов представить данное число, как сумму нескольких различных положительных чисел, причем все числа должны быть попарно взаимно простыми.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nс 10 - должно получиться 6, потому что есть 6 таких последовательностей (1 2 7, 1 4 5, 1 9, 2 3 5, 3 7, 10).\r\n\r\n--}\r\n\r\n\r\n\r\nc n = nseq n n 1\r\n\r\n{--\r\n\r\nЧисла в последователньости называются попарно взаимно простыми, если любые два числа в ней взаимно просты.\r\n\r\nА целые числа называются взаимно простыми, если они не имеют никаких общих делителей, кроме ±1, т. е. НОД(этих чисел) = 1.\r\n\r\nТаким образом, очевидно, что при добавлении нового числа (пусть x) в \'последовательность попарно взаимно простых чисел\' необходимо проверять условие \'НОД(х, а) = 1 для любого числа a из последователньости\' или (что тут будет то же) \'НОД(x, product) = 1, где product --- это произведение всех чисел этой последовательности\'.  \r\n\r\n\'nseq\' считает количество \"искомых\" последовательностей, которые состоят из чисел <= \'maxElement\'. При этом, в \'sequenseProduct\' накапливается произведение чисел текущей последовательности.\r\n\r\nОчевидно, что при рассмотрении очередного числа мы должны сначала проверить То условие. \r\n\r\nИ если оно выполнено, то результатом будет следующая сумма: \r\n\r\n					= (количество \"искомых\" последовательностей, которые содержат этот подходящий элемент) \r\n\r\n					+ (количество \"искомых\" последовательностей, которые НЕ содержат его, даже хоть он и подходит).\r\n\r\nА если оно НЕ выполнено, то рассматриваемое число мы не будем брать в \"искомую\" последовательность, т.е. результатом будет только (количество \"искомых\" последовательностей, которые НЕ содержат это число).\r\n\r\nПри этом (хоть не всё это сразу стало ясно):\r\n\r\n	-> чтобы не уйти в отрицательные числа, нам нужно вовремя (n = 0) закончить выполнение, сказав при этом, что мы всё-таки смогли успешно разложить число n;\r\n\r\n	-> при maxElement = 0 и n != 0 будет тогда означать, что мы спустились до 0, пытаясь разложить число n в сумму различных попарно взаимно простых чисел;\r\n\r\n	-> чтобы опять же не уйти в отрицательные числа, но уже после вызова на предыдущем шаге метода с (n - maxElement) в качестве n, то нам нужно при maxElement > n перескакивать на n.\r\n\r\n--}\r\n\r\n\r\n\r\nnseq 0 maxElement sequenseProduct = 1\r\n\r\nnseq n 0 sequenseProduct = 0\r\n\r\nnseq n maxElement sequenseProduct\r\n\r\n	| maxElement > n = nseq n n sequenseProduct\r\n\r\n	| gcd maxElement sequenseProduct == 1 = nseq (n - maxElement) (maxElement - 1) (sequenseProduct * maxElement) + nseq n (maxElement - 1) sequenseProduct\r\n\r\n	| otherwise = nseq n (maxElement - 1) sequenseProduct\r\n','<br/>Тесты успешно пройдены!'),(4609,21,'toskira','2013-09-06 02:59:52',1,'nseq n = f\' n n\r\n\r\nf\' 0 0 = 1\r\nf\' _ 0 = 0\r\nf\' n k = f\' (n - k) (k - 1) + f\' n (k - 1)','<br/>Тесты успешно пройдены!'),(4608,20,'1048693','2013-09-06 00:10:12',1,'import Data.List (foldl\')\r\n\r\n\r\n\r\nmain = do\r\n\r\n    print $ sumfact 1800\r\n\r\n\r\n\r\nsumfact = simple\r\n\r\n\r\n\r\nsimple n = sum\' $ map fact [1..n]\r\n\r\n    where\r\n\r\n        fact k = product\' [1..k]\r\n\r\n\r\n\r\n        product\' = foldl\' (*) 1\r\n\r\n        sum\'     = foldl\' (+) 0\r\n\r\n\r\n\r\n-- without options:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.004s 0m0.000s\r\n\r\n--         0m8.628s 0m0.164s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        2.74 secs   (2744 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 1,160,125,816 bytes  (excludes profiling overheads)\r\n\r\n-- with -O3:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.000s 0m0.004s\r\n\r\n--         0m8.536s 0m0.144s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        2.73 secs   (2731 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 1,160,017,684 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n\r\n\r\ncps n = run id n 0\r\n\r\n    where\r\n\r\n        run after 0 acc = after acc\r\n\r\n        run after i acc = fact 1 i $ run after $ i - 1\r\n\r\n            where\r\n\r\n                fact acc\' 0 after\' =  after\' $! acc\' + acc\r\n\r\n                fact acc\' j after\' = (fact   $! acc\' *  j) (j - 1) after\'\r\n\r\n\r\n\r\n-- without options:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.000s 0m0.004s\r\n\r\n--         0m13.048s 0m0.200s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        4.21 secs   (4213 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 1,382,950,044 bytes  (excludes profiling overheads)\r\n\r\n-- with -O3:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.000s 0m0.004s\r\n\r\n--         0m8.568s 0m0.204s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        2.76 secs   (2756 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 1,285,472,764 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n\r\n\r\ntailrecursive n = run n 0\r\n\r\n    where\r\n\r\n        run 0 acc = acc\r\n\r\n        run i acc = fact 1 i\r\n\r\n            where\r\n\r\n                fact acc\' 0 = run (i - 1) $! acc\' + acc\r\n\r\n                fact acc\' j = (fact   $! acc\' *  j) $ j - 1\r\n\r\n\r\n\r\n-- without options:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.000s 0m0.004s\r\n\r\n--         0m13.888s 0m0.248s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        4.49 secs   (4491 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 1,415,317,644 bytes  (excludes profiling overheads)\r\n\r\n-- with -O3:\r\n\r\n--     time of 3 launches:\r\n\r\n--         0m0.000s 0m0.004s\r\n\r\n--         0m5.816s 0m2.964s\r\n\r\n--     profiling:\r\n\r\n--         total time  =        2.78 secs   (2781 ticks @ 1000 us, 1 processor)\r\n\r\n--         total alloc = 1,285,429,564 bytes  (excludes profiling overheads)\r\n','<br/>Тесты успешно пройдены!'),(4607,23,'anlun','2013-09-05 22:29:21',1,'c :: Integer -> Integer\r\nc n = c1 n [] 0 1\r\n\r\nc1 :: Integer -> [Integer] -> Integer -> Integer -> Integer\r\nc1 n l curSum curElem | n == curSum = 1\r\nc1 n l curSum curElem | n <  curSum || n < curElem = 0\r\nc1 n l curSum curElem =\r\n	if canCurElemBeUsed then t1 + t2 else t2\r\n	where\r\n		canCurElemBeUsed = foldl (f v -> if f then gcd curElem v == 1 else False) True l\r\n		t1 = c1 n (curElem:l) (curSum + curElem) (curElem + 1)\r\n		t2 = c1 n l           curSum             (curElem + 1)','<br/>Тесты успешно пройдены!'),(4606,22,'nomeansno','2013-09-05 21:11:06',1,'prime n = f n 2\r\n\r\n\r\n\r\nf 1 i = False\r\n\r\nf n i = if (i^2 > n) then True \r\n\r\nelse if n `mod` i == 0 then False\r\n\r\nelse f n (i+1)\r\n\r\n\r\n\r\ng n = if n == 0 || n == 1 || n == 2 then False\r\n\r\nelse h n 2\r\n\r\n\r\n\r\nh n i = if i == (n + 1) `div` 2 then False\r\n\r\nelse if prime i && prime (n-i) then True\r\n\r\nelse h n (i+1)\r\n','<br/>Тесты успешно пройдены!'),(4605,22,'nomeansno','2013-09-05 21:07:33',0,'prime n = f n 2\r\n\n\r\n\nf 1 i = False\r\n\nf n i = if (i^2 > n) then True \r\n\nelse if n `mod` i == 0 then False\r\n\nelse f n (i+1)\r\n\n\r\n\ng n = if n == 0 || n == 1 || n == 2 then False\r\n\nelse h n 2\r\n\n\r\n\nh n i = if i == (n + 1) `div` 2 then False\r\n\nelse if i /= n - i && prime i && prime (n-i) then True\r\n\nelse h n (i+1)\n','<br/>Тесты успешно пройдены!'),(4604,22,'nomeansno','2013-09-05 20:59:12',0,'prime n = f n 2\r\n\n\r\n\nf 1 i = False\r\n\nf n i = if (i^2 > n) then True \r\n\nelse if n `mod` i == 0 then False\r\n\nelse f n (i+1)\r\n\n\r\n\ng n = if n == 0 || n == 1 || n == 2 then False\r\n\nelse h n 2\r\n\n\r\n\nh n i = if i /= n - i && prime i && prime (n-i) then True\r\n\nelse if i == n `div` 2 then False\r\n\nelse h n (i+1)\n','Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),(4603,22,'nomeansno','2013-09-05 20:56:49',0,'prime n = f n 2\r\n\n\r\n\n-- f 1 i = False\r\n\nf n i = if (i^2 > n) then True \r\n\nelse if n `mod` i == 0 then False\r\n\nelse f n (i+1)\r\n\n\r\n\ng n = if n == 0 || n == 1 || n == 2 then False\r\n\nelse h n 2\r\n\n\r\n\nh n i = if i /= n - i && prime i && prime (n-i) then True\r\n\nelse if i == n `div` 2 then False\r\n\nelse h n (i+1)\n','Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),(4602,22,'nomeansno','2013-09-05 20:48:29',0,'prime n = f n 2\r\n\n\r\n\nf n i = if (i^2 > n) then True \r\n\nelse if n `mod` i == 0 then False\r\n\nelse f n (i+1)\r\n\n\r\n\ng n = h n 2\r\n\n\r\n\nh n i = if i /= n - i && prime i && prime (n-i) then True\r\n\nelse if i == n `div` 2 then False\r\n\nelse h n (i+1)\n','Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),(4600,20,'8519021','2013-09-05 19:59:32',1,'sumfact n = sumfact\' n 1 1 0\r\n\r\nsumfact\' 0 i p s = s\r\n\r\nsumfact\' n i p s = sumfact\' (n - 1) (i + 1) (p * i) (s + p * i)\r\n','<br/>Тесты успешно пройдены!'),(4601,24,'480387','2013-09-05 20:20:30',1,'b n = b\' 0 n\r\n\r\nb\' k n = if k < n then k + 1 / (b\' (k+1) n) else n\r\n','<br/>Тесты успешно пройдены!'),(4599,18,'480387','2013-09-05 19:51:40',1,'f 0 = 1\r\n\r\nf n = 1 + 1 / (f (n-1))\r\n','<br/>Тесты успешно пройдены!'),(4598,22,'deripaska','2013-09-05 19:10:19',1,'--- ОК, очень хорошо.\r\n--- Но немного можно оптимизировать.\r\n--- Во-первых, при проверке на простоту, можно проверять, что квадрат очередного делителя меньше n.\r\n--- Как только квадрат стал больше, то дальше можно уже не проверять.\r\n--- Во вторых для g n можно отдельно рассмотреть случай, когда n нечетное. В этом случае все проще (понятно почему, да?) \r\n﻿{--\r\n\r\n	task 02-01\r\n\r\n*Дополнительная задача*\r\n\r\nОпишите функцию g, которая для данного целого числа, проверяет, можно ли его представить в виде суммы двух различных простых чисел, и возвращает True или False.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\ng 6 должно быть равно False\r\n\r\ng 7 должно быть равно True (так как 7 = 2 + 5).\r\n\r\n--}\r\n\r\n\r\n\r\ng 1 = False\r\n\r\ng n = g1 n 2\r\n\r\n\r\n\r\n{--\r\n\r\nОчевидно, что второе слагаемое в искомой сумме = n - первое слагаемое.\r\n\r\nПри этом, по условию слагаемые в сумме должны быть различны (т.е. первое != (n - первое)).\r\n\r\ng1 проверяет, можно ли представить число n в виде искомой суммы, в которой первое слагаемое >= firstTerm. \r\n\r\nЕсли при поиске такой суммы мы дойдем уже до самого n (т.е. первое == n), то это будет означать, что искомой суммы нет. \r\n\r\n--}\r\n\r\ng1 n firstTerm\r\n\r\n	| firstTerm /= (n - firstTerm) && isPrimeNumber firstTerm && isPrimeNumber (n - firstTerm) = True\r\n\r\n	| firstTerm == n = False\r\n\r\n	| otherwise = g1 n (firstTerm + 1)\r\n\r\n\r\n\r\nisPrimeNumber 1 = False\r\n\r\nisPrimeNumber n = isNotDivisibleByAll n 2\r\n\r\n\r\n\r\n{-- \r\n\r\n\"isNotDivisibleByAll\" возвращает Истину, если данное число n НЕ делиться (т.е. остаток от деления не равен нулю) на каждое число от divisor до (n - 1), \r\n\r\n								и Ложь, в противном случае\r\n\r\nПри этом n является простым числом, если оно не делиться на каждое число от 2 до (n - 1)\r\n\r\n--}\r\n\r\nisNotDivisibleByAll n divisor\r\n\r\n	| divisor == n = True\r\n\r\n	| mod n divisor /= 0 = isNotDivisibleByAll n (divisor + 1)\r\n\r\n	| otherwise = False\r\n','<br/>Тесты успешно пройдены!'),(4595,22,'anlun','2013-09-05 18:19:27',1,'primes = sieve [2..]\r\nsieve (x:xs) = x : sieve [y | y <- xs, rem y x /= 0]\r\n\r\ng :: Integer -> Bool\r\ng x = x `elem` sums\r\n	where\r\n		l    = takeWhile (< x) primes\r\n		sums = [a + b | a <- l, b <- l, a /= b]','<br/>Тесты успешно пройдены!'),(4596,20,'toskira','2013-09-05 18:34:40',1,'sumfact n = f\' n 2 1 0\r\n\r\nf\' 0 _ _ result = result\r\nf\' n counter current result = f\' (n - 1) (counter + 1) (current * counter) (result + current)\r\n','<br/>Тесты успешно пройдены!'),(4597,19,'1048693','2013-09-05 18:50:53',1,'main = do\r\n\r\n    print $ sumsin 1000000\r\n\r\n\r\n\r\nsumsin = cps\r\n\r\n\r\n\r\n-- Don\'t know why, but these two functions have different precision.\r\n\r\n\r\n\r\nsimple n = (sin $! sum [1..n]) / (sum $! map sin [1..n])\r\n\r\n\r\n\r\n-- In WinHugs `sum\' is strict, so no stack overflows,\r\n\r\n-- but in GHC `sum\' is lazy, so you must set +RTS -K<size> -RTS for successful run.\r\n\r\n\r\n\r\n-- > time ./SumSin\r\n\r\n-- real	0m4.397s\r\n\r\n-- user	0m4.204s\r\n\r\n-- sys	0m0.168s\r\n\r\n\r\n\r\n-- without optimization:\r\n\r\n--    total time  =        2.38 secs   (2383 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 304,076,736 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n-- with O3:\r\n\r\n--    total time  =        2.22 secs   (2218 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 304,076,468 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n\r\n\r\ncps n = sum_nums 0 n (\r\nums -> sum_sins 0 n (sins -> (sin nums) / sins))\r\n\r\n    where\r\n\r\n        sum_nums acc 0 after = after acc\r\n\r\n        sum_nums acc i after = ((sum_nums $! acc +      i ) $! i - 1) after\r\n\r\n\r\n\r\n        sum_sins acc 0 after = after acc\r\n\r\n        sum_sins acc i after = ((sum_sins $! acc + (sin i)) $! i - 1) after\r\n\r\n\r\n\r\n-- Explicit tail recursive.\r\n\r\n\r\n\r\n-- > time ./SumSin\r\n\r\n--    real	0m2.057s\r\n\r\n--    user	0m2.016s\r\n\r\n--    sys	0m0.032s\r\n\r\n\r\n\r\n-- without optimization:\r\n\r\n--    total time  =        3.27 secs   (3265 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 320,075,824 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n-- with O3:\r\n\r\n--    total time  =        0.25 secs   (251 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc =      76,040 bytes  (excludes profiling overheads)\r\n','<br/>Тесты успешно пройдены!'),(4592,24,'toskira','2013-09-05 18:01:36',1,'b n = f\' n n\r\n\r\nf\' 0 a = a\r\nf\' n a = f\' (n - 1) (n - 1 + 1 / a)','<br/>Тесты успешно пройдены!'),(4593,19,'8519021','2013-09-05 18:07:32',1,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 s s\' = sin s / s\'\r\n\r\nsumsin\' n s s\' = sumsin\' (n - 1) (s + n) (s\' + sin n)\r\n','<br/>Тесты успешно пройдены!'),(4594,19,'toskira','2013-09-05 18:13:33',1,'sumsin n = f\' n 0 0\r\n\r\nf\' 0 sum1 sum2 = sin sum1 / sum2\r\nf\' n sum1 sum2 = f\' (n - 1) (sum1 + n) (sum2 + sin n)\r\n','<br/>Тесты успешно пройдены!'),(4589,18,'8519021','2013-09-05 17:43:50',1,'f 0 = 1\r\n\r\nf n = 1 + 1 / f (n - 1)\r\n','<br/>Тесты успешно пройдены!'),(4590,18,'toskira','2013-09-05 17:53:33',1,'f n = f\' n 1\r\n\r\nf\' 0 a = a\r\nf\' n a = f\' (n - 1) (1 + 1 / a)','<br/>Тесты успешно пройдены!'),(4591,24,'8519021','2013-09-05 17:56:39',1,'b n = b\' n 0\r\n\r\nb\' 0 n = n\r\n\r\nb\' n p = p + 1 / b\' (n - 1) (p + 1)\r\n','<br/>Тесты успешно пройдены!'),(4588,24,'1048693','2013-09-05 17:23:43',1,'main = do\r\n\r\n    print $ b 1000000\r\n\r\n\r\n\r\nb = combinators\r\n\r\n\r\n\r\ntailrecursive n = run n n\r\n\r\n    where\r\n\r\n        run acc 0 = acc\r\n\r\n        run acc n = (run $! ((n - 1) + (1 / acc))) $! n - 1\r\n\r\n\r\n\r\n-- > time ./QuasiGoldenRatio\r\n\r\n--    real	0m1.939s\r\n\r\n--    user	0m1.916s\r\n\r\n--    sys	0m0.016s\r\n\r\n\r\n\r\n-- without optimization:\r\n\r\n--    total time  =        3.14 secs   (3143 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 268,075,712 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n-- with -O3:\r\n\r\n--    total time  =        0.18 secs   (177 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc =      75,612 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\ncombinators n = foldl\' cons n $! reverse [1..n]\r\n\r\n    where\r\n\r\n        cons acc n = (n - 1) + (1 / acc)\r\n\r\n\r\n\r\n        -- Strict foldl\r\n\r\n        foldl\' _ acc    []  = acc\r\n\r\n        foldl\' f acc (x:xs) = (foldl\' f $! f acc x) xs\r\n\r\n\r\n\r\n-- > time ./QuasiGoldenRatio\r\n\r\n--    real	0m2.567s\r\n\r\n--    user	0m2.428s\r\n\r\n--    sys	0m0.128s\r\n\r\n\r\n\r\n-- without optimization:\r\n\r\n--    total time  =        2.84 secs   (2841 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 268,075,912 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n-- with -O3:\r\n\r\n--    total time  =        1.20 secs   (1202 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 116,075,776 bytes  (excludes profiling overheads)\r\n','<br/>Тесты успешно пройдены!'),(4587,24,'1048693','2013-09-05 17:23:21',0,'main = do\r\n\n    print $ b 1000000\r\n\n\r\n\nb = combinators\r\n\n\r\n\ntailrecursive n = run n n\r\n\n    where\r\n\n        run acc 0 = acc\r\n\n        run acc n = (run $! ((n - 1) + (1 / acc))) $! n - 1\r\n\n\r\n\n-- > time ./QuasiGoldenRatio\r\n\n--    real	0m1.939s\r\n\n--    user	0m1.916s\r\n\n--    sys	0m0.016s\r\n\n\r\n\n-- without optimization:\r\n\n--    total time  =        3.14 secs   (3143 ticks @ 1000 us, 1 processor)\r\n\n--    total alloc = 268,075,712 bytes  (excludes profiling overheads)\r\n\n\r\n\n-- with -O3:\r\n\n--    total time  =        0.18 secs   (177 ticks @ 1000 us, 1 processor)\r\n\n--    total alloc =      75,612 bytes  (excludes profiling overheads)\r\n\n\r\n\ncombinators n = foldl\' cons n $! reverse [1..n]\r\n\n    where\r\n\n        cons acc n = (n - 1) + (1 / acc)\r\n\n\r\n\n        -- Strict foldl\r\n\n        foldl\' _ acc    []  = acc\r\n\n        foldl\' f acc (x:xs) = (foldl\' f $! f acc x) xs\r\n\n\r\n\n-- > time ./QuasiGoldenRatio\r\n\n--    real	0m2.567s\r\n\n--    user	0m2.428s\r\n\n--    sys	0m0.128s\r\n\n\r\n\n-- without optimization:\r\n\n--    total time  =        2.84 secs   (2841 ticks @ 1000 us, 1 processor)\r\n\n--    total alloc = 268,075,912 bytes  (excludes profiling overheads)\r\n\n\r\n\n-- with -O3:\r\n\n--    total time  =        1.20 secs   (1202 ticks @ 1000 us, 1 processor)\r\n\n--    total alloc = 116,075,776 bytes  (excludes profiling overheads)\n','<br/>Тесты успешно пройдены!'),(4586,23,'3320654','2013-09-05 17:09:45',1,'c n = c\' 0 n []\r\n\r\nc\' maxleft k list =	if (k > maxleft) \r\n		then  (sum [c\' t (k - t) (t:list) | t <- [(maxleft + 1)..k]])	\r\n		else 	if k == 0 \r\n			then 	if (isCoprime list)\r\n  --- OK, но на самом деле так не очень эффективно, лучше сразу для каждого числа, которое добавляется в спискок,\r\n  --- проверять, что оно взаимно простое со всеми остальными - сразу.\r\n				then 1\r\n				else 0\r\n			else 0\r\n\r\nisCoprime [] = True\r\nisCoprime (x:s) = 	if (sum (map (gcd x) s) == length s)\r\n		then isCoprime s\r\n		else False','<br/>Тесты успешно пройдены!'),(4585,18,'1048693','2013-09-05 16:52:23',1,'main = do\r\n\r\n    print $ f 1000000\r\n\r\n\r\n\r\nf = tailrecursive\r\n\r\n\r\n\r\nnaive 0 = 1\r\n\r\nnaive n = 1 + (1 / (naive $ n - 1))\r\n\r\n\r\n\r\n-- Gives stack overflow on high parameters\r\n\r\n-- to change it run compiled program with \"+RTS -K<size> -RTS\" arguments\r\n\r\n\r\n\r\n-- > time ./GoldenRatio\r\n\r\n--    real	0m3.589s\r\n\r\n--    user	0m3.344s\r\n\r\n--    sys	0m0.224s\r\n\r\n\r\n\r\n-- without optimization:\r\n\r\n--    total time  =        2.35 secs   (2347 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 176,075,936 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n-- with -O3:\r\n\r\n--    total time  =        0.33 secs   (327 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc =   8,075,836 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\ntailrecursive n = run 1 n\r\n\r\n    where\r\n\r\n        run acc 0 = acc\r\n\r\n        run acc n = (run $! (1 + (1 / acc))) $! n - 1\r\n\r\n\r\n\r\n-- > time ./GoldenRatio\r\n\r\n--    real	0m1.625s\r\n\r\n--    user	0m1.604s\r\n\r\n--    sys	0m0.012s\r\n\r\n\r\n\r\n-- without optimization:\r\n\r\n--    total time  =        2.68 secs   (2683 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc = 192,075,944 bytes  (excludes profiling overheads)\r\n\r\n\r\n\r\n-- with -O3:\r\n\r\n--    total time  =        0.29 secs   (287 ticks @ 1000 us, 1 processor)\r\n\r\n--    total alloc =   8,075,836 bytes  (excludes profiling overheads)\r\n','<br/>Тесты успешно пройдены!'),(4579,24,'3270666','2013-09-05 16:21:35',1,'b n = b\' n n\r\nb\' n 0 = n\r\nb\' n m = (n - m) + (1 / b\' n (m - 1))','<br/>Тесты успешно пройдены!'),(4580,19,'3270666','2013-09-05 16:27:32',1,'  --- Просто как вариант, можно в одной фунцкии сосчитать и сумму и сумму синусов \r\n  --- (завести два накапливающих параметра)\r\nsumsin n = sin (sumsin1 n 0) / (sumsin2 n 0)\r\n\r\nsumsin1 1 p = p + 1\r\nsumsin1 n p = sumsin1 (n - 1) (p + n)\r\n\r\nsumsin2 1 p = (sin 1) + p\r\nsumsin2 n p = sumsin2 (n - 1) (p + (sin n))','<br/>Тесты успешно пройдены!'),(4581,20,'3270666','2013-09-05 16:38:27',1,'sumfact n = sumfact\' n 1 1 0\r\nsumfact\' n k p s = if k <= n\r\n	then sumfact\' n (k + 1) (p * k) (s + p * k)\r\n	else s','<br/>Тесты успешно пройдены!'),(4582,0,'1048693','2013-09-05 16:38:42',0,'','<br/>Тесты успешно пройдены!'),(4583,0,'1048693','2013-09-05 16:41:03',0,'','<br/>Тесты успешно пройдены!'),(4584,18,'1048693','2013-09-05 16:43:25',0,'\n\n<!-- saved from url=(0083)https://raw.github.com/kirillt/exercises/master/fp-simuni/2013-09-02/GoldenRatio.hs -->\n\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><style type=\"text/css\" style=\"display: none !important;\">object:not([type]),object[classid$=\":D27CDB6E-AE6D-11cf-96B8-444553540000\"],object[classid$=\":d27cdb6e-ae6d-11cf-96b8-444553540000\"],object[codebase*=\"swflash.cab\"],object[data*=\".swf\"],embed[type=\"application/x-shockwave-flash\"],embed[src*=\".swf\"],object[type=\"application/x-shockwave-flash\"],object[src*=\".swf\"],object[codetype=\"application/x-shockwave-flash\"],iframe[type=\"application/x-shockwave-flash\"],object[classid$=\":166B1BCA-3F9C-11CF-8075-444553540000\"],object[codebase*=\"sw.cab\"],object[data*=\".dcr\"],embed[type=\"application/x-director\"],embed[src*=\".dcr\"],object[type=\"application/x-director\"],object[src*=\".dcr\"],object[classid$=\":15B782AF-55D8-11D1-B477-006097098764\"],object[codebase*=\"awswaxf.cab\"],object[data*=\".aam\"],embed[type=\"application/x-authorware-map\"],embed[src*=\".aam\"],object[type=\"application/x-authorware-map\"],object[src*=\".aam\"],object[classid*=\"32C73088-76AE-40F7-AC40-81F62CB2C1DA\"],object[type=\"application/ag-plugin\"],object[type=\"application/x-silverlight\"],object[type=\"application/x-silverlight-2\"],object[source*=\".xaml\"],object[sourceelement*=\"xaml\"],embed[type=\"application/ag-plugin\"],embed[source*=\".xaml\"]{display: none !important;}</style><style type=\"text/css\">#lleo_dialog, #lleo_dialog * {\r\n\n    margin: 0 !important;\r\n\n	padding: 0 !important;\r\n\n	background: none !important;\r\n\n	border: none 0 !important;\r\n\n	position: static !important;\r\n\n	vertical-align: baseline !important;\r\n\n	font: normal 13px Arial, Helvetica !important;\r\n\n	line-height: 15px !important;\r\n\n	color: #000 !important;\r\n\n	overflow: visible !important;\r\n\n	width: auto !important;\r\n\n	height: auto !important;\r\n\n	float: none !important;\r\n\n	visibility: visible !important;\r\n\n	text-align: left !important;\r\n\n	border-collapse: separate !important;\r\n\n	border-spacing: 2px !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog iframe {\r\n\n	height: 0 !important;\r\n\n	width: 0 !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog {\r\n\n    position: absolute !important;\r\n\n    background: #fff !important;\r\n\n    border: solid 1px #ccc !important;\r\n\n    padding: 7px 0 0 !important;\r\n\n    left: -999px;\r\n\n    top: -999px;\r\n\n	/*max-width: 450px !important;*/\r\n\n    width: 440px !important;\r\n\n    overflow: hidden;\r\n\n    display: block !important;\r\n\n    z-index: 999999999 !important;\r\n\n    opacity: 0 !important;\r\n\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.18) !important;\r\n\n	-moz-border-radius: 3px !important;\r\n\n	-webkit-border-radius: 3px !important;\r\n\n	border-radius: 3px !important;\r\n\n}\r\n\n#lleo_dialog.lleo_show {\r\n\n    opacity: 1 !important;\r\n\n    -webkit-transition: opacity 0.3s !important;\r\n\n}\r\n\n#lleo_dialog input::-webkit-input-placeholder {\r\n\n    color: #aaa !important;\r\n\n}\r\n\n#lleo_dialog .lleo_has_pic #lleo_word {\r\n\n	margin-right: 80px !important;\r\n\n}\r\n\n#lleo_dialog #lleo_translationsCopntainer1 {\r\n\n	position: relative !important;\r\n\n}\r\n\n#lleo_dialog #lleo_translationsCopntainer2 {\r\n\n	padding: 7px 0 0 !important;\r\n\n	vertical-align: middle !important;\r\n\n}\r\n\n#lleo_dialog #lleo_word {\r\n\n    color: #000 !important;\r\n\n    margin: 0 5px 2px 0 !important;\r\n\n    /*float: left !important;*/\r\n\n}\r\n\n#lleo_dialog .lleo_has_sound #lleo_word {\r\n\n    margin-left: 17px !important;\r\n\n}\r\n\n#lleo_dialog #lleo_text {\r\n\n    font-weight: bold !important;\r\n\n    color: #d56e00 !important;\r\n\n    text-decoration: none !important;\r\n\n    cursor: default !important;\r\n\n}\r\n\n#lleo_dialog #lleo_text.lleo_known {\r\n\n    cursor: pointer !important;\r\n\n    text-decoration: underline !important;\r\n\n}\r\n\n#lleo_dialog #lleo_closeBtn {\r\n\n    position: absolute !important;\r\n\n    right: 6px !important;\r\n\n    top: 5px !important;\r\n\n    line-height: 1px !important;\r\n\n    text-decoration: none !important;\r\n\n    font-weight: bold !important;\r\n\n    font-size: 0 !important;\r\n\n    color: #aaa !important;\r\n\n    display: block !important;\r\n\n    padding: 2px !important;\r\n\n	z-index: 9999999999 !important;\r\n\n	width: 7px !important;\r\n\n	height: 7px !important;\r\n\n	padding: 0  !important;\r\n\n	margin: 0   !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_optionsBtn {\r\n\n    position: absolute !important; \r\n\n    right: 1px !important;\r\n\n    top: 12px !important;\r\n\n    line-height: 1px !important;\r\n\n    text-decoration: none !important;\r\n\n    font-weight: bold !important;\r\n\n    font-size: 13px !important;\r\n\n    color: #aaa !important;\r\n\n    padding: 2px !important;\r\n\n	display: none;\r\n\n}\r\n\n#lleo_dialog #lleo_optionsBtn img{\r\n\n	width: 12px !important;\r\n\n	height: 12px !important;\r\n\n}\r\n\n#lleo_dialog #lleo_sound {\r\n\n    float: left !important;\r\n\n    width: 16px !important;\r\n\n    height: 16px !important;\r\n\n    margin-left: 12px !important;\r\n\n    background: 0 0 no-repeat !important;\r\n\n    cursor: pointer !important;\r\n\n    display: none !important;\r\n\n}\r\n\n#lleo_dialog .lleo_has_sound #lleo_sound {\r\n\n    display: block !important;\r\n\n}\r\n\n#lleo_dialog #lleo_picOuter {\r\n\n    position: absolute !important;\r\n\n    float: right !important;\r\n\n    right: 29px;\r\n\n    top: 0;\r\n\n    display: none !important;\r\n\n    z-index: 9 !important;\r\n\n}\r\n\n#lleo_dialog .lleo_has_pic #lleo_picOuter {\r\n\n    display: block !important;\r\n\n}\r\n\n#lleo_dialog #lleo_picOuter:hover {\r\n\n    z-index: 11 !important;\r\n\n}\r\n\n#lleo_dialog #lleo_pic,\r\n\n#lleo_dialog #lleo_picBig {\r\n\n    position: absolute !important;\r\n\n    top: 0 !important;\r\n\n    right: 0 !important;\r\n\n    border: solid 2px #fff !important;\r\n\n    -moz-border-radius: 2px !important;\r\n\n	-webkit-border-radius: 2px !important;\r\n\n	border-radius: 2px !important;\r\n\n    z-index: 1 !important;\r\n\n}\r\n\n#lleo_dialog #lleo_pic {\r\n\n	position: relative !important;\r\n\n    border: none !important;\r\n\n	width: 34px !important;\r\n\n}\r\n\n#lleo_dialog #lleo_picBig {\r\n\n    box-shadow: -1px 2px 4px rgba(0,0,0,0.3);\r\n\n    z-index: 2 !important;\r\n\n    opacity: 0 !important;\r\n\n    visibility: hidden !important;\r\n\n}\r\n\n#lleo_dialog #lleo_picOuter:hover #lleo_picBig {\r\n\n    visibility: visible !important;\r\n\n    opacity: 1 !important;\r\n\n    -webkit-transition: opacity 0.3s !important;\r\n\n    -webkit-transition-delay: 0.3s !important;\r\n\n}\r\n\n#lleo_dialog #lleo_transcription {\r\n\n    color: #486D85 !important;\r\n\n    margin: 0 0 4px 29px !important;\r\n\n    color: #aaaaaa !important;\r\n\n}\r\n\n#lleo_dialog .lleo_no_trans {\r\n\n    color: #aaa !important;\r\n\n}\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n#lleo_dialog .ll-translation-counter {\r\n\n	float: right !important;\r\n\n    font-size: 11px !important;\r\n\n    color: #aaa !important;\r\n\n    padding: 2px 2px 1px 10px !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog .ll-translation-text {\r\n\n	float: left !important;\r\n\n	width: 80% !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_trans a {\r\n\n    color: #3F669F !important;\r\n\n    padding: 1px 4px !important;\r\n\n    text-decoration: none !important;\r\n\n    text-overflow: ellipsis !important;\r\n\n    overflow: hidden !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog .ll-translation-item {\r\n\n	width: 100% !important;\r\n\n	float: left !important; \r\n\n	padding:1px 4px;\r\n\n	color: #3F669F !important;\r\n\n	padding: 3px !important;\r\n\n	border: solid 1px white !important;\r\n\n	-moz-border-radius: 2px !important;\r\n\n	-webkit-border-radius: 2px !important;\r\n\n	border-radius: 2px !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog .ll-translation-item:hover {\r\n\n	border: solid 1px #9FC2C9 !important;\r\n\n    background: #EDF4F6 !important;\r\n\n	cursor: pointer !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog .ll-translation-marker {\r\n\n	margin: 0px 5px 2px 2px !important;\r\n\n}\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n#lleo_dialog #lleo_icons {\r\n\n    margin: 10px 0 7px !important;\r\n\n    color: #aaa !important;\r\n\n    line-height: 20px !important;\r\n\n    font-size: 11px !important;\r\n\n    clear: both !important;\r\n\n    padding-left: 16px !important;\r\n\n}\r\n\n#lleo_icons a {\r\n\n    display: inline-block !important;\r\n\n    width: 16px !important;\r\n\n    height: 16px !important;\r\n\n    margin: 0 0 -2px 3px !important;\r\n\n    text-decoration: none !important;\r\n\n    background: 0 0 no-repeat !important;\r\n\n    opacity: 0.5 !important;\r\n\n}\r\n\n#lleo_icons a:hover {\r\n\n    opacity: 1 !important;\r\n\n}\r\n\n#lleo_icons a.lleo_google     {background-position:-34px 0 !important;}\r\n\n#lleo_icons a.lleo_multitran  {background-position:-64px 0 !important;}\r\n\n#lleo_icons a.lleo_lingvo     {background-position:-51px 0 !important; width: 12px !important;}\r\n\n#lleo_icons a.lleo_dict       {background-position:-17px 0 !important;}\r\n\n#lleo_icons a.lleo_linguee    {background-position:-81px 0 !important;}\r\n\n#lleo_icons a.lleo_michaelis  {background-position:-98px 0 !important;}\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n#lleo_dialog #lleo_contextContainer {\r\n\n    margin: 0 !important;\r\n\n    padding: 3px 15px 3px 10px !important;\r\n\n    background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#eee)) !important;\r\n\n    border-bottom: solid 1px #ddd !important;\r\n\n    border-top-left-radius: 3px !important;\r\n\n    border-top-right-radius: 3px !important;\r\n\n    display: none !important;\r\n\n    overflow: hidden !important;\r\n\n}\r\n\n#lleo_dialog .lleo_has_context #lleo_contextContainer {\r\n\n    display: block !important;\r\n\n}\r\n\n#lleo_dialog #lleo_context {\r\n\n    color: #444 !important;\r\n\n    text-shadow: 1px 1px 0 #f4f4f4 !important;\r\n\n    line-height: 12px !important;\r\n\n    font-size: 11px !important;\r\n\n    margin-left: 2px !important;\r\n\n}\r\n\n#lleo_dialog #lleo_context b {\r\n\n    line-height: 12px !important;\r\n\n    color: #000 !important;\r\n\n    font-weight: bold !important;\r\n\n    font-size: 11px !important;\r\n\n}\r\n\n#lleo_dialog #lleo_gBrand {\r\n\n    color: #aaa !important;\r\n\n    font-size: 10px !important;\r\n\n    /*padding-right: 52px !important;*/\r\n\n    padding-bottom: 14px !important;\r\n\n    margin: -3px 4px 0 4px !important;\r\n\n    background: left bottom no-repeat !important;\r\n\n    display: inline-block !important;\r\n\n    float: right !important;\r\n\n}\r\n\n#lleo_dialog #lleo_gBrand.hidden {\r\n\n    display: none !important;\r\n\n}\r\n\n#lleo_dialog #lleo_translateContextLink {\r\n\n    color: #444 !important;\r\n\n    text-shadow: 1px 1px 0 #f4f4f4 !important;\r\n\n    background: -webkit-gradient(linear, left top, left bottom, from(#f4f4f4), to(#ddd)) !important;\r\n\n    border: solid 1px !important;\r\n\n    box-shadow: 1px 1px 0 #f6f6f6 !important;\r\n\n    border-color: #999 #aaa #aaa #999 !important;\r\n\n    -moz-border-radius: 2px !important;\r\n\n	-webkit-border-radius: 2px !important;\r\n\n	border-radius: 2px !important;\r\n\n    padding: 0 3px !important;\r\n\n    font-size: 11px !important;\r\n\n    text-decoration: none !important;\r\n\n    margin: 1px 5px 0 !important;\r\n\n    display: inline-block !important;\r\n\n    white-space: nowrap !important;\r\n\n}\r\n\n#lleo_dialog #lleo_translateContextLink:hover {\r\n\n    background: #f8f8f8 !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_setTransForm {\r\n\n    display: block !important;\r\n\n    margin-top: 3px !important;\r\n\n    padding-top: 5px !important;\r\n\n    /* Set position and background because the form might be overlapped by an image when no translations */\r\n\n    position: relative !important;\r\n\n    background: #fff !important;\r\n\n    z-index: 10 !important;\r\n\n    padding-bottom: 10px !important;\r\n\n    padding-left: 16px !important;\r\n\n}\r\n\n#lleo_dialog .lleo-custom-translation {\r\n\n    padding: 4px 5px !important;\r\n\n    border: solid 1px #ddd !important;\r\n\n    -moz-border-radius: 2px !important;\r\n\n	-webkit-border-radius: 2px !important;\r\n\n	border-radius: 2px !important;\r\n\n    width: 90% !important;\r\n\n    min-width: 270px !important;\r\n\n    background: -webkit-gradient(linear, 0 0, 0 20, from(#f1f1f1), to(#fff)) !important;\r\n\n	font: normal 13px Arial, Helvetica !important;\r\n\n	line-height: 15px !important;\r\n\n}\r\n\n#lleo_dialog .lleo-custom-translation:hover {\r\n\n    border: solid 1px #aaa !important;\r\n\n}\r\n\n#lleo_dialog .lleo-custom-translation:focus {\r\n\n    background: #FFFEC9 !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog *.hidden {\r\n\n    display: none !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog .infinitive{\r\n\n    color: #D56E00 !important;\r\n\n    text-decoration: none;\r\n\n    border-bottom: 1px dotted #D56E00 !important;\r\n\n}\r\n\n#lleo_dialog .infinitive:hover{\r\n\n    border: none !important;\r\n\n}\r\n\n\r\n\n\r\n\n#lleo_dialog #lleo_trans{\r\n\n    zoom: 1;\r\n\n    border-top: 1px solid #eeeeee !important;\r\n\n    margin: 10px 0 0 !important;\r\n\n    padding: 5px 30px 0 14px !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog .lleo_clearfix {\r\n\n	display: block !important;\r\n\n	clear: both !important;\r\n\n	visibility: hidden !important;\r\n\n	height: 0 !important;\r\n\n	font-size: 0 !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_markBlock {\r\n\n    background: #eeeeee !important;\r\n\n	cursor: pointer !important; \r\n\n	border-bottom-left-radius: 3px !important;\r\n\n	border-bottom-right-radius: 3px !important;\r\n\n	border-collapse: separate !important;\r\n\n	border-spacing: 2px !important; \r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_markBlock img{\r\n\n	width: 14px !important;\r\n\n	height: 14px !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_markBlock .icon-cell {\r\n\n	padding: 5px 2px 5px 16px !important;\r\n\n	height: 17px !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_markBlock .wide-cell {\r\n\n	width: 100% !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_markBlock .text-cell {\r\n\n	color: #999999 !important; \r\n\n    font: normal 13px Arial, Helvetica !important;\r\n\n    text-shadow: 0 1px #fff !important; \r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_markBlock td {\r\n\n	vertical-align: middle !important;\r\n\n	border-collapse: separate !important;\r\n\n	border-spacing: 2px !important;\r\n\n}\r\n\n\r\n\n\r\n\n#lleo_dialog #lleo_picOuter table{\r\n\n    width: 44px !important;\r\n\n    position: absolute !important;\r\n\n    right: 0 !important;\r\n\n    vertical-align: middle !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_picOuter td{\r\n\n    width: 38px !important;\r\n\n    height: 38px !important;\r\n\n    border: 1px solid #eeeeee !important;\r\n\n    vertical-align: middle !important;\r\n\n    text-align: center !important;\r\n\n}\r\n\n\r\n\n#lleo_dialog #lleo_picOuter td div {\r\n\n	height: 38px !important;\r\n\n	overflow: hidden !important;\r\n\n}</style><style type=\"text/css\">\r\n\n.ll-content-notification *{\r\n\n	letter-spacing: normal !important;\r\n\n	margin: 0 !important;\r\n\n    padding: 0 !important;\r\n\n	background: none !important;\r\n\n	border: 0 !important;\r\n\n	float: none !important;\r\n\n	text-align: left !important;\r\n\n	text-decoration: none !important;\r\n\n    font: normal 15px \'Lucida Grande\', \'Lucida Sans Unicode\', Lucida, Arial, Helvetica, sans-serif !important;\r\n\n}\r\n\n\r\n\n\r\n\n.ll-content-notification {\r\n\n    vertical-align: baseline !important;\r\n\n    color: #000 !important;\r\n\n    overflow: visible !important;\r\n\n    visibility: visible !important;\r\n\n    margin: 0 !important;\r\n\n    padding: 0 !important;\r\n\n    position: fixed !important;\r\n\n    background: #fff !important;\r\n\n    border: solid 1px #AAA !important;\r\n\n	/*\r\n\n    left: -999px;\r\n\n    top: -999px;\r\n\n	*/\r\n\n    width: auto;\r\n\n    /* width: 300px !important; */\r\n\n    display: block;\r\n\n    z-index: 999999999 !important;\r\n\n    -webkit-box-shadow: 0 2px 4px rgba(0, 0, 0, 0.18) !important;\r\n\n    -moz-box-shadow: 0 2px 4px rgba(0, 0, 0, 0.18) !important;\r\n\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.18) !important;\r\n\n    -webkit-border-radius: 3px !important;\r\n\n    -moz-border-radius: 3px !important;\r\n\n    border-radius: 3px !important;\r\n\n    overflow: hidden !important;\r\n\n    /* opacity: 0 !important; */\r\n\n    transition: opacity 0.8s !important;\r\n\n    -moz-transition: opacity 0.8s !important; /* Firefox 4 */\r\n\n    -webkit-transition: opacity 0.8s !important; /* Safari and Chrome */\r\n\n    -o-transition: opacity 0.8s !important; /* Opera */\r\n\n    cursor: default !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-shown {\r\n\n    opacity: 1 !important;\r\n\n    transition: opacity 0.8s !important;\r\n\n    -moz-transition: opacity 0.8s !important; /* Firefox 4 */\r\n\n    -webkit-transition: opacity 0.8s !important; /* Safari and Chrome */\r\n\n    -o-transition: opacity 0.8s !important; /* Opera */\r\n\n}\r\n\n\r\n\n.ll-content-notification-header {\r\n\n	border: 0 !important;\r\n\n	margin: 0 !important;\r\n\n    background: url(data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAIAAABsYngUAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjEwMPRyoQAAABJJREFUGFdjePHmCxw9e/UZjgAVYhYtk8xZqAAAAABJRU5ErkJggg==) !important;\r\n\n    border-bottom: solid 1px #CCC !important;\r\n\n    padding: 1px 4px !important;\r\n\n	min-height: 18px !important;\r\n\n	width: 100% !important;\r\n\n	-webkit-border-top-left-radius: 3px !important;\r\n\n    -webkit-border-top-right-radius: 3px !important;\r\n\n    -moz-border-radius-topleft: 3px !important;\r\n\n    -moz-border-radius-topright: 3px !important;\r\n\n    border-top-left-radius: 3px !important;\r\n\n    border-top-right-radius: 3px !important;\r\n\n	border-collapse: collapse !important;\r\n\n	border-spacing: 0 !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-header-pic {\r\n\n	border: 0 !important;\r\n\n	margin: 0 !important;\r\n\n	padding: 3px 0 0 3px !important;\r\n\n	width: 20px !important;\r\n\n	vertical-align: top !important;\r\n\n	line-height: 1px !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-header-pic img{\r\n\n	border: 0 !important;\r\n\n	padding: 0 !important;\r\n\n	margin: 0 !important;\r\n\n	line-height: 1px !important;\r\n\n}\r\n\n\r\n\n\r\n\n.ll-content-notification-header-caption {\r\n\n    font: normal 13px \'Lucida Grande\', \'Lucida Sans Unicode\', Lucida, Arial, Helvetica, sans-serif !important;\r\n\n	font-weight: bold !important;\r\n\n    line-height: 15px !important;\r\n\n    color: #555 !important;\r\n\n    float: left !important;\r\n\n    text-shadow: none !important;\r\n\n    letter-spacing: normal !important;\r\n\n	white-space: normal !important;\r\n\n	padding: 3px !important;\r\n\n	margin: 0 !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-header-close {\r\n\n    width: 15px !important;\r\n\n	vertical-align: top !important;\r\n\n	text-align: right !important;\r\n\n	padding: 6px 5px 0 0 !important;\r\n\n	margin: 0 !important;\r\n\n	line-height: 1px !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-header-close img {\r\n\n	border: 0 !important;\r\n\n    width: 7px !important;\r\n\n    height: 7px !important;\r\n\n    margin: 0 !important;\r\n\n	padding: 0 !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-content {\r\n\n    margin: 0 !important;\r\n\n    padding: 8px !important;\r\n\n    float: left !important;\r\n\n    overflow: hidden !important;\r\n\n    width: auto !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-content-logo {\r\n\n    float: left !important;\r\n\n	height: 48px !important;\r\n\n	width: 48px !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-content-main {\r\n\n    margin-left: 60px !important;\r\n\n    overflow: hidden !important;\r\n\n    padding: 0 0 2px 0 !important;\r\n\n    color: #333 !important;\r\n\n    text-align: left !important;\r\n\n    text-shadow: none !important;\r\n\n    letter-spacing: normal !important;\r\n\n    font: normal 13px \'Lucida Grande\', \'Lucida Sans Unicode\', Lucida, Arial, Helvetica, sans-serif !important;\r\n\n    line-height: 15px !important;\r\n\n    width: auto !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-content-header {\r\n\n	text-align: left !important;\r\n\n	text-decoration: none !important;\r\n\n    font: bold 15px \'Lucida Grande\', \'Lucida Sans Unicode\', Lucida, Arial, Helvetica, sans-serif !important;\r\n\n    line-height: 19px !important;\r\n\n    margin: 0 0 4px 0 !important;\r\n\n    padding: 0 !important;\r\n\n    border: 0 !important;\r\n\n    color: #333 !important;\r\n\n    text-shadow: none !important;\r\n\n    letter-spacing: normal !important;\r\n\n    display: block !important;\r\n\n    top: 0 !important;\r\n\n    left: 0 !important;\r\n\n}\r\n\n\r\n\n.ll-content-notification-word {\r\n\n    color: #d56e00 !important;\r\n\n    font-weight: bold !important;\r\n\n    font-size: 14px !important;\r\n\n}\r\n\n</style></head><body><pre style=\"word-wrap: break-word; white-space: pre-wrap;\">main = do\n\n    print $ f 1000000\n\n\n\nf = naive\n\n\n\nnaive 0 = 1\n\nnaive n = 1 + (1 / (naive $ n - 1))\n\n\n\n-- Gives stack overflow on high parameters\n\n-- to change it run compiled program with \"+RTS -K&lt;size&gt; -RTS\" arguments\n\n\n\n-- &gt; time ./GoldenRatio\n\n--    real	0m3.589s\n\n--    user	0m3.344s\n\n--    sys	0m0.224s\n\n\n\n-- without optimization:\n\n--    total time  =        2.35 secs   (2347 ticks @ 1000 us, 1 processor)\n\n--    total alloc = 176,075,936 bytes  (excludes profiling overheads)\n\n\n\n-- with -O3:\n\n--    total time  =        0.33 secs   (327 ticks @ 1000 us, 1 processor)\n\n--	  total alloc =   8,075,836 bytes  (excludes profiling overheads)\n\n\n\ntailrecursive n = run 1 n\n\n    where\n\n        run acc 0 = acc\n\n        run acc n = (run $! (1 + (1 / acc))) $! n - 1\n\n\n\n-- &gt; time ./GoldenRatio\n\n--    real	0m1.625s\n\n--    user	0m1.604s\n\n--    sys	0m0.012s\n\n\n\n-- without optimization:\n\n--    total time  =        2.68 secs   (2683 ticks @ 1000 us, 1 processor)\n\n--    total alloc = 192,075,944 bytes  (excludes profiling overheads)\n\n\n\n-- with -O3:\n\n--    total time  =        0.29 secs   (287 ticks @ 1000 us, 1 processor)\n\n--    total alloc =   8,075,836 bytes  (excludes profiling overheads)\n\n</pre></body></html>\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4572,1,'1048693','2013-09-05 13:25:25',0,'','<br/>Тесты успешно пройдены!'),(4573,0,'1048693','2013-09-05 13:27:13',0,'','<br/>Тесты успешно пройдены!'),(4574,22,'517309','2013-09-05 15:43:47',2,'g _ = False','Выражение имеет неправильное значение: g 7'),(4575,23,'517309','2013-09-05 15:44:16',2,'c _ = 6','Выражение имеет неправильное значение: c 3'),(4576,22,'3320654','2013-09-05 16:00:16',0,'isPrime 2 = True\r\nisPrime n = isPrime\' n 2\r\n\r\nisPrime\' n k = 	if (mod n k == 0)\r\n		then False\r\n		else 	if (div n 2 == k)\r\n			then True\r\n			else isPrime\' n (k + 1)\r\n\r\ng n = g\' n 2\r\n\r\ng\' n k =	if ((isPrime k) && (isPrime (n - k)))\r\n	then True\r\n	else 	if (div n 2 < k)\r\n		then False\r\n		else g\' n (k + 1)','Не удалось вычислить выражение \"g 3\", проверьте правильность синтаксиса'),(4577,22,'3320654','2013-09-05 16:06:35',1,'isPrime 1 = False\r\nisPrime 2 = True\r\nisPrime n = isPrime\' n 2\r\n\r\nisPrime\' n k = 	if (mod n k == 0)\r\n		then False\r\n		else 	if (div n 2 == k)\r\n			then True\r\n			else isPrime\' n (k + 1)\r\n\r\ng n = g\' n 2\r\n\r\ng\' n k =	if ((isPrime k) && (isPrime (n - k)))\r\n	then True\r\n	else 	if (div n 2 < k)\r\n		then False\r\n		else g\' n (k + 1)','<br/>Тесты успешно пройдены!'),(4578,18,'3270666','2013-09-05 16:14:15',1,'f 0 = 1\r\nf n = 1 + (1 / f(n - 1))','<br/>Тесты успешно пройдены!'),(4565,20,'3226573','2013-09-04 20:49:30',0,'fact\' 0 p = p\r\nfact\' n p = fact\' (n - 1) (n * p)\r\nfact n = fact\' n 0\r\nsumfact\' 0 p = p\r\nsumfact\' n p = sumfact\' (n - 1) (p + (fact n))\r\nsumfact n = sumfact\' n 0','Выражение имеет неправильное значение: sumfact 1'),(4566,20,'3226573','2013-09-04 20:50:52',1,'   --- Засчитано, но эту задачу можно сделать более эффективно, мы это обсудим\r\nfact\' 0 p = p\r\nfact\' n p = fact\' (n - 1) (n * p)\r\nfact n = fact\' n 1\r\nsumfact\' 0 p = p\r\nsumfact\' n p = sumfact\' (n - 1) (p + (fact n))\r\nsumfact n = sumfact\' n 0','<br/>Тесты успешно пройдены!'),(4567,18,'3226573','2013-09-04 20:56:07',1,'f 0 = 1\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4568,19,'3226573','2013-09-04 20:59:50',1,'sumsin\' 0 s p = (sin s) / p\r\nsumsin\' n s p = sumsin\' (n - 1) (s + n) (p + (sin n))\r\nsumsin n = sumsin\' n 0 0 ','<br/>Тесты успешно пройдены!'),(4569,21,'1545234','2013-09-05 01:08:14',0,'nseq n = nsq 1 [1..(n-1)] 0 n\n\n\n\nnsq ans [] s n = if (s == n) then ans+1\n\n                 else ans\n\nnsq ans (x:xs) sum n = if (sum == n) then ans+1\n\n                       else if (sum > n) then ans\n\n                            else nsq (nsq ans xs (sum) n) xs (sum+x) n \n\n                        \n\n\n\n\n\n\n','<br/>Тесты успешно пройдены!'),(4570,21,'1545234','2013-09-05 01:13:47',1,'nseq n = nsq 0 1 0 n\r\n\r\n\r\n\r\nnsq ans i sum n = if (sum == n) then ans+1\r\n\r\n                       else if ((i> n) || (sum > n)) then ans\r\n\r\n                            else nsq (nsq ans (i+1) sum n) (i+1) (sum+i) n \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4571,1,'1048693','2013-09-05 13:23:43',0,'','<br/>Тесты успешно пройдены!'),(4562,19,'ArtemK','2013-09-04 20:05:07',1,'sumsin n = sumsin\' 0  0 n\r\nsumsin\' ssum nsum 0 = (sin nsum) / ssum\r\nsumsin\' ssum nsum n = sumsin\' (ssum + (sin n)) (nsum + n) (n - 1)','<br/>Тесты успешно пройдены!'),(4563,20,'ArtemK','2013-09-04 20:20:42',1,'sumfact 1 = 1\r\nsumfact n = sumfact\' 2 n\r\nsumfact\' m n = 1 + if n == m\r\n         then n\r\n         else m * (sumfact\' (m+1) n)','<br/>Тесты успешно пройдены!'),(4564,18,'3226573','2013-09-04 20:47:24',0,'fact 0 p = p\r\nfact n p = fact (n - 1) (n * p)\r\nfact\' n = fact n 0\r\nsumfact 0 p = p\r\nsumfact n p = sumfact (n - 1) (p + (fact\' n)) ','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4556,18,'3226573','2013-09-04 17:46:34',1,'f 0 = 1\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4557,18,'3226573','2013-09-04 17:47:12',1,'f 0 = 1\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4558,24,'284427','2013-09-04 17:59:26',1,'b n = b1 n 0\r\n\r\nb1 1 p = 1/p\r\n\r\nb1 n 0 = b1 (n-1) (n-1 + 1/n)\r\n\r\nb1 n p = b1 (n-1) (n-1 + 1/p)\r\n','<br/>Тесты успешно пройдены!'),(4559,24,'3226573','2013-09-04 18:59:13',1,'f 0 p = p\r\nf n p = f (n - 1) (n - 1 + 1/p)\r\nb n = f n n','<br/>Тесты успешно пройдены!'),(4560,18,'ArtemK','2013-09-04 19:34:42',1,'f 1 = 2\r\nf n = 1 + 1 / f (n-1)','<br/>Тесты успешно пройдены!'),(4561,24,'ArtemK','2013-09-04 19:49:11',1,'b n = b\' 0 n\r\nb\' m n = if n == m\r\n         then n\r\n         else m + 1 / (b\' (m+1) n)','<br/>Тесты успешно пройдены!'),(4555,18,'3226573','2013-09-04 17:44:50',0,'f 0 = return(1)\r\nf n = 1 + 1 / f (n - 1)','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4553,21,'87635585','2013-09-04 16:54:00',1,'nseq n = nseq\'\' n 1\r\nnseq\'\' sum pred\' = if 2 * pred\' >= sum then 1 else \r\n nseq\'\' sum (pred\' + 1) + nseq\'\' (sum - pred\') (pred\' + 1) ','<br/>Тесты успешно пройдены!'),(4554,21,'deripaska','2013-09-04 16:59:47',1,'﻿{--\r\n\r\n    task 01-05\r\n\r\n* Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?\r\n\r\nНапример, для n = 9 существуют такие последовательности:\r\n\r\n1 2 6, 1 3 5, 1 8, 2 3 4, 2 7, 3 6, 4 5, 9\r\n\r\n, то есть ответ на вопрос равен 8\r\n\r\n\r\n\r\nОпишите функцию nseq n, которая вычисляет количество таких последовательностей.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nnseq 9\r\n\r\nРезультат должен быть равен 8\r\n\r\n--}\r\n\r\n\r\n\r\nnseq n = nseq1 n 1 0\r\n\r\n{--\r\n\r\n\'numbersCount\' - количество чисел в \"искомой\" последовательности (т.е. строго возрастающей, сотосящей из положительных целых чисел, сумма которых равна данному числу n). \r\n\r\nВ \'res\' накапливается итоговое количество всех \"искомых\" последовательностей, длина которых меньше или равна \'numbersCount\'.\r\n\r\nОчевидно, что максимальная длина \"искомой\" последовательности не может быть больше или равна самому числу n (кроме  n == 1). Следовательно, после подсчета количества последовательностей длины n можно будет уже вернуть ответ.\r\n\r\n--}\r\n\r\nnseq1 n numbersCount res\r\n\r\n	| numbersCount > n = res\r\n\r\n	| otherwise = nseq1 n (numbersCount + 1) (res + nseq2 n numbersCount)\r\n\r\n	\r\n\r\n{--\r\n\r\n\'nseq2\' подсчитывает количество \"искомых\" последовательностей, длина которых равна length (рекурсивно по известной формулке).\r\n\r\n--}\r\n\r\nnseq2 n 1 = 1\r\n\r\nnseq2 n length \r\n\r\n	| length >= n = 0\r\n\r\n	| otherwise = nseq2 (n - length) length + nseq2 (n - length) (length - 1)\r\n','<br/>Тесты успешно пройдены!'),(4550,19,'517309','2013-09-04 15:55:22',1,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 s1 s2 = sin s1 / s2\r\nsumsin\' n s1 s2 = sumsin\' (n-1) (s1+n) (s2+sin n)','<br/>Тесты успешно пройдены!'),(4551,21,'87635585','2013-09-04 16:44:31',0,'nseq n = nseq\'\' 1 n 2\r\nnseq\'\' pred sum pred\' = if 2 * pred\' <= sum then sum - pred\' + 1 else \r\n nseq\'\' pred sum (pred\' - 1) + nseq\'\' pred\' (sum - pred\') (pred\' + 1) ','Не удалось вычислить выражение \"nseq 1\", проверьте правильность синтаксиса'),(4552,21,'deripaska','2013-09-04 16:47:26',0,'﻿{--\r\n\n    task 01-05\r\n\n* Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?\r\n\nНапример, для n = 9 существуют такие последовательности:\r\n\n1 2 6, 1 3 5, 1 8, 2 3 4, 2 7, 3 6, 4 5, 9\r\n\n, то есть ответ на вопрос равен 8\r\n\n\r\n\nОпишите функцию nseq n, которая вычисляет количество таких последовательностей.\r\n\n\r\n\nПример вызова:\r\n\nnseq 9\r\n\nРезультат должен быть равен 8\r\n\n--}\r\n\n\r\n\nnseq n = nseq1 n 1 0\r\n\n{--\r\n\n\'numbersCount\' - количество чисел в \"искомой\" последовательности (т.е. строго возрастающей, сотосящей из положительных целых чисел, сумма которых равна данному числу n). \r\n\nВ \'res\' накапливается итоговое количество всех \"искомых\" последовательностей, длина которых меньше или равна \'numbersCount\'.\r\n\nОчевидно, что максимальная длина \"искомой\" последовательности не может быть больше или равна самому числу n. Следовательно, после подсчета количества последовательностей длины n можно будет уже вернуть ответ.\r\n\n--}\r\n\nnseq1 n numbersCount res\r\n\n	| numbersCount >= n = res\r\n\n	| otherwise = nseq1 n (numbersCount + 1) (res + nseq2 n numbersCount)\r\n\n	\r\n\n{--\r\n\n\'nseq2\' подсчитывает количество \"искомых\" последовательностей, длина которых равна length (рекурсивно по известной формулке).\r\n\n--}\r\n\nnseq2 n 1 = 1\r\n\nnseq2 n length \r\n\n	| length >= n = 0\r\n\n	| otherwise = nseq2 (n - length) length + nseq2 (n - length) (length - 1)\n','Выражение имеет неправильное значение: nseq 1'),(4548,24,'517309','2013-09-04 14:49:29',1,'b n = b1 n 0\r\nb1 1 p = 1/p\r\nb1 n 0 = b1 (n-1) (n-1 + 1/n)\r\nb1 n p = b1 (n-1) (n-1 + 1/p)','<br/>Тесты успешно пройдены!'),(4549,19,'517309','2013-09-04 15:53:23',0,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 s1 s1 = sin s1 / s2\r\nsumsin\' n s1 s2 = sumsin\' (n-1) (s1+n) (s2+sin n)','Не удалось вычислить выражение \"sumsin 1\", проверьте правильность синтаксиса'),(4546,24,'517309','2013-09-04 14:28:15',1,'b n = b\' 0 n\r\n\r\nb\' k n = if (k == n) then n\r\n         else k + 1 / b\' (k+1) n','<br/>Тесты успешно пройдены!'),(4547,25,'517309','2013-09-04 14:29:25',1,'f x = 1','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(4545,20,'284427','2013-09-04 12:59:16',1,'sumfact n = sf n 1 1 0\r\n\r\nsf 1 1 1 s = 1\r\n\r\nsf 1 f k s = s + f \r\n\r\nsf n f k s = sf (n-1) (f*(k+1)) (k+1) (s+f)\r\n','<br/>Тесты успешно пройдены!'),(4544,20,'deripaska','2013-09-04 12:52:33',1,'﻿{--\r\n\r\n    task 01-04\r\n\r\nОписать функцию sumfact n: \r\n\r\nsumfact n = 1!+2!+...+n!\r\n\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nsumfact 3\r\n\r\nРезультат должен быть равен 9.\r\n\r\n--}\r\n\r\n\r\n\r\nsumfact n = sumfact1 n 1 1 0\r\n\r\nsumfact1 0 begin fact res = res\r\n\r\nsumfact1 n begin fact res = sumfact1 (n - 1) (begin + 1) ((begin + 1) * fact) (res + fact)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4543,19,'deripaska','2013-09-04 12:51:36',1,'﻿{--\r\n\r\n    task 01-03\r\n\r\nОписать функцию \r\n\r\nsumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\n\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nsumsin 2\r\n\r\nДолжно получиться sin(1+2)/(sin 1+sin 2); это равно примерно 0.08 \r\n\r\n--}\r\n\r\n\r\n\r\n{-- first // \"в лоб\"\r\n\r\nsumsin n = sin (nsum n) / sinsum n\r\n\r\nnsum 1 = 1\r\n\r\nnsum n = n + nsum (n - 1)\r\n\r\nsinsum 1 = sin 1\r\n\r\nsinsum n = sin n + sinsum (n - 1)\r\n\r\n--}\r\n\r\n\r\n\r\n{--second // с хвостовой рекурсией\r\n\r\nsumsin n = sin (nsum n) / sinsum n\r\n\r\nnsum n = nsum1 n 0\r\n\r\nnsum1 0 res = res\r\n\r\nnsum1 n res = nsum1 (n - 1) (res + n)\r\n\r\nsinsum n = sinsum1 n 0\r\n\r\nsinsum1 0 res = res\r\n\r\nsinsum1 n res = sinsum1 (n - 1) (res + sin n)\r\n\r\n--}\r\n\r\n\r\n\r\n--third // с хвостовой рекурсией и с упрощением\r\n\r\nsumsin n = sumsin1 n 0 0\r\n\r\nsumsin1 0 firstSum secondSum = sin firstSum / secondSum\r\n\r\nsumsin1 n firstSum secondSum = sumsin1 (n - 1) (firstSum + n) (secondSum + sin n)\r\n\r\n--}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4537,20,'4604056','2013-09-03 23:04:20',1,'sumfact n = sumfact_acc n 1 1 0\r\nsumfact_acc 0 count acc_fact acc_sum = acc_sum\r\nsumfact_acc n count acc_fact acc_sum = sumfact_acc (n - 1) (count + 1) (acc_fact * count) (acc_sum + acc_fact * count)','<br/>Тесты успешно пройдены!'),(4538,21,'nomeansno','2013-09-04 10:21:57',1,'nseq n = g 0 n\r\n\r\ng i 0 = 1\r\n\r\ng i k = if i >= k then 0\r\n\r\nelse g (i+1) (k-i-1) + g (i+1) k \r\n','<br/>Тесты успешно пройдены!'),(4539,18,'284427','2013-09-04 12:28:25',0,'f 1 = 2\r\n\nf n = 1 + 1/(f (n-1))\n','<br/>Тесты успешно пройдены!'),(4540,18,'284427','2013-09-04 12:31:02',1,'f 1 = 2\r\n\r\nf n = 1 + 1/(f (n-1))\r\n','<br/>Тесты успешно пройдены!'),(4541,19,'284427','2013-09-04 12:41:35',1,'sumsin n = ss n 0 0\r\n\r\nss 0 p k = sin p / k\r\n\r\nss n p k = ss (n-1) (p+n) (k + sin n)\r\n','<br/>Тесты успешно пройдены!'),(4542,24,'deripaska','2013-09-04 12:51:05',1,'﻿{--\r\n\r\n	task 01-02\r\n\r\nОписать функцию b n, которая вычисляет \r\n\r\n0+1/(1+1/(2+1/(3+ ...+1/n))) - n дробей\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nb 3\r\n\r\nДолжно получиться 0+1/(1+1/(2+1/3)), то есть 0.7\r\n\r\n--}\r\n\r\n\r\n\r\nb n = b1 n 0\r\n\r\nb1 0 begin = begin\r\n\r\nb1 count begin = begin + 1 / b1 (count - 1) (begin + 1)\r\n','<br/>Тесты успешно пройдены!'),(4529,18,'4604056','2013-09-03 22:17:25',1,'f 1 = 2\r\nf n = f\' n 1\r\nf\' 0 acc = acc\r\nf\' n acc = f\' (n-1) (1+1/acc)','<br/>Тесты успешно пройдены!'),(4530,18,'1545234','2013-09-03 22:21:23',1,'f 0 = 1\r\n\r\nf n = 1+1/(f (n-1))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4531,24,'1545234','2013-09-03 22:26:54',1,'b n = b1 n 0\r\n\r\n\r\n\r\nb1 0 n = n\r\n\r\nb1 n i = i + 1 / (b1 (n-1) (i+1))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4532,24,'4604056','2013-09-03 22:27:43',0,'f 1 = 1\r\nf n = f\' n n\r\nf\' 0 acc = acc\r\nf\' n acc = f\' (n-1) (n-1+1/(acc))','Не удалось вычислить выражение \"b 3\", проверьте правильность синтаксиса'),(4533,24,'4604056','2013-09-03 22:28:24',1,'b 1 = 1\r\nb n = f\' n n\r\nf\' 0 acc = acc\r\nf\' n acc = f\' (n-1) (n-1+1/(acc))','<br/>Тесты успешно пройдены!'),(4534,19,'1545234','2013-09-03 22:36:10',1,'sumsin n = ss 0 0 n\r\n\r\n\r\n\r\nss c z 0 = (sin c)/z\r\n\r\nss c z n = ss (c + n) (z + sin n) (n-1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4535,20,'1545234','2013-09-03 22:42:46',1,'sumfact n = sf 0 1 1 n\r\n\r\n\r\n\r\nsf sum _ _ 0 = sum\r\n\r\nsf sum f i n = sf (sum + f*i) (f*i) (i+1) (n-1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4536,19,'4604056','2013-09-03 22:43:36',1,'sumsin n = sumsin_acc n 0 0\r\nsumsin_acc 0 acc_num acc_sin = (sin acc_num / acc_sin)\r\nsumsin_acc n acc_num acc_sin = sumsin_acc (n-1) (acc_num+n) (acc_sin+sin n)','<br/>Тесты успешно пройдены!'),(4528,21,'2156724','2013-09-03 22:00:14',1,'func n a1 =\r\n\r\n   if a1 > n then 0\r\n\r\n   else if a1 == n then 1\r\n\r\n   else func (n - a1) (a1 + 1) + func n (a1 + 1)\r\n\r\n\r\n\r\nnseq n = func n 1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	        \r\n','<br/>Тесты успешно пройдены!'),(4526,20,'87635585','2013-09-03 21:57:01',1,'sumfact n = sumfact\' n 0\r\nsumfact\' 0 t = t\r\nsumfact\' n t = sumfact\' (n - 1) (n * t + n)','<br/>Тесты успешно пройдены!'),(4527,21,'2156724','2013-09-03 21:58:55',0,'func n a1 =\r\n\n   if a1 > n then 0\r\n\n   else if a1 == n then 1\r\n\n   else func (n - a1) (a1 + 1) + func n (a1 + 1)\r\n\n\r\n\nnseq n = func n 1 - 1\r\n\n\r\n\n\r\n\n	        \n','Выражение имеет неправильное значение: nseq 1'),(4525,19,'87635585','2013-09-03 21:51:40',1,'sumsin n = sin (n * (n + 1) / 2) / sumsin\' n 0\r\nsumsin\' 0 t = t\r\nsumsin\' n t = sumsin\' (n - 1) (sin n + t)','<br/>Тесты успешно пройдены!'),(4522,18,'87635585','2013-09-03 21:39:14',1,'f n = f\' n 1\r\nf\' 0 t = t\r\nf\' n t = f\' (n - 1) (1 + 1 / t)','<br/>Тесты успешно пройдены!'),(4523,24,'87635585','2013-09-03 21:42:18',1,'b n = f\' (n - 1) (1 / n)\r\nf\' 0 t = t\r\nf\' n t = f\' (n - 1) (1 / (n + t))','<br/>Тесты успешно пройдены!'),(4524,19,'87635585','2013-09-03 21:47:47',1,'sumsin n = sumsin\' n 0 0\r\nsumsin\' 0 t t0 = sin t / t0\r\nsumsin\' n t t0 = sumsin\' (n - 1) (n + t) (sin n + t0)','<br/>Тесты успешно пройдены!'),(4521,20,'2156724','2013-09-03 21:05:54',1,'  --- Зачтено, но это у вас без хвостовой рекурсии, и не очень эффективно \r\nfact 1 = 1\r\n\r\nfact n = fact (n-1)*n\r\n\r\n\r\n\r\nsumfact n =\r\n\r\n  if n == 0 then 0\r\n\r\n            else fact n + sumfact (n-1) \r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(4520,20,'nomeansno','2013-09-03 19:13:02',1,'sumfact n = f n 1 1 0\r\n\r\nf 0 i x y = y\r\n\r\nf n i x y = f (n-1) (i+1) (i*x) (y+i*x) \r\n','<br/>Тесты успешно пройдены!'),(4516,18,'deripaska','2013-09-03 18:04:26',1,'f 1 = 1 + 1 / 1\r\nf n = 1 + 1 / f (n - 1)','<br/>Тесты успешно пройдены!'),(4517,24,'nomeansno','2013-09-03 18:42:08',0,'f n = f\' n n\r\n\nf\' 0 m = m\r\n\nf\' n m = f\' (n-1) (n-1+1/m)\r\n\n\r\n\ng n = g\' n 0\r\n\ng\' 1 m = m + 1 / (m + 1) \r\n\ng\' n m = m + 1 / g\' (n-1) (m+1) \r\n\n\r\n\n\n','Не удалось вычислить выражение \"b 3\", проверьте правильность синтаксиса'),(4518,24,'nomeansno','2013-09-03 18:43:21',1,'b n = f\' n n\r\n\r\nf\' 0 m = m\r\n\r\nf\' n m = f\' (n-1) (n-1+1/m)\r\n\r\n\r\n\r\ng n = g\' n 0\r\n\r\ng\' 1 m = m + 1 / (m + 1) \r\n\r\ng\' n m = m + 1 / g\' (n-1) (m+1) \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4519,19,'nomeansno','2013-09-03 18:52:03',1,'sumsin n = f n 0 0\r\n\r\nf 0 x y = sin x / y\r\n\r\nf n x y = f (n-1) (x+n) (y+sin n)\r\n','<br/>Тесты успешно пройдены!'),(4515,18,'nomeansno','2013-09-03 18:03:06',1,'f n = f\' n 2\r\n\r\nf\' 1 m = m\r\n\r\nf\' n m = f\' (n-1) (1+1/m)\r\n\r\n\r\n\r\ng 1 = 2\r\n\r\ng n = 1 + 1 / g (n-1)\r\n','<br/>Тесты успешно пройдены!'),(4514,21,'anlun','2013-09-03 17:00:36',1,'nseq :: Integer -> Integer\r\nnseq n = nseq1 n 0 1\r\n\r\nnseq1 n curSum curMax | n == curSum = 1\r\nnseq1 n curSum curMax | n <  curSum || n < curMax = 0\r\nnseq1 n curSum curMax = (nseq1 n curSum (curMax + 1)) + (nseq1 n (curSum + curMax) (curMax + 1))\r\n','<br/>Тесты успешно пройдены!'),(4501,18,'3320654','2013-09-03 13:48:30',0,'f 0 = 1\r\n\nf n = 1 + (1 / f (n - 1))\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4502,18,'3320654','2013-09-03 13:50:38',1,'f 0 = 1\r\nf n = 1 + (1 / f (n - 1))','<br/>Тесты успешно пройдены!'),(4503,24,'3320654','2013-09-03 13:59:18',1,'b n = b\' n n\r\nb\' 0 n = n\r\nb\' k n = (n - k) + (1 / (b\' (k - 1) n))','<br/>Тесты успешно пройдены!'),(4504,19,'3320654','2013-09-03 14:06:38',1,'sumsin n = sumsin\' n n 0\r\nsumsin\' 0 n den = sin (n * (n + 1) / 2) / den\r\nsumsin\' k n den = sumsin\' (k - 1) n (den + sin k) ','<br/>Тесты успешно пройдены!'),(4505,20,'3320654','2013-09-03 14:17:59',1,'sumfact n = sumfact\' n (n - 1) 1 0\r\nsumfact\' n 0 cur_fact acc = cur_fact + acc\r\nsumfact\' n k cur_fact acc = sumfact\' n (k - 1) (cur_fact * (n - k + 1)) (acc + cur_fact)','<br/>Тесты успешно пройдены!'),(4506,18,'2156724','2013-09-03 14:25:20',1,'f n = \r\n\r\n  if n == 0 then 1\r\n\r\n  else 1/(f (n-1)) + 1\r\n','<br/>Тесты успешно пройдены!'),(4507,24,'2156724','2013-09-03 14:52:05',1,'func n q = \r\n\r\n   if n == 0 then 0\r\n\r\n   else 1/(q + (func (n-1) (q+1))) \r\n\r\n        \r\n\r\nb n = \r\n\r\n  func n 1.0\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4508,19,'2156724','2013-09-03 15:09:13',1,'func n a1 a2 =\r\n\r\n   if n == 1 then sin (n + a1) / (a2 + (sin n))\r\n\r\n   else func (n-1) (a1 + n) (a2 + sin n)\r\n\r\nsumsin n = func n 0 0 \r\n','<br/>Тесты успешно пройдены!'),(4509,21,'3320654','2013-09-03 15:25:25',1,'nseq n = nseq\' 0 n\r\nnseq\' maxleft k =	if (k > maxleft) \r\n		then (sum [nseq\' t (k - t) | t <- [(maxleft + 1)..k]])	\r\n		else 	if k == 0 \r\n			then 1 \r\n			else 0','<br/>Тесты успешно пройдены!'),(4510,18,'anlun','2013-09-03 16:10:18',1,'f :: Integer -> Double\r\nf 0 = 1\r\nf n = 1 + 1 / (f (n - 1))\r\n','<br/>Тесты успешно пройдены!'),(4511,24,'anlun','2013-09-03 16:10:53',1,'b :: Integer -> Double\r\nb n = b1 0 n\r\nb1 n 0 = n\r\nb1 n m = n + 1 / (b1 (n + 1) (m - 1))\r\n','<br/>Тесты успешно пройдены!'),(4512,19,'anlun','2013-09-03 16:11:28',1,'sumsin :: (Enum a, Floating a) => a -> a\r\nsumsin n = (sin s) / ss\r\n	where\r\n		(s, ss) = foldl ((s, ss) x -> (s + x, ss + sin x)) (0, 0) [1..n]','<br/>Тесты успешно пройдены!'),(4513,20,'anlun','2013-09-03 16:12:09',1,'import Data.List\r\n\r\nsumfact :: Integer -> Integer\r\nsumfact n = sum $ snd $ mapAccumL (acc v -> (acc * v, acc * v)) 1 [1..n]\r\n','<br/>Тесты успешно пройдены!'),(4499,21,'517309','2013-09-03 08:07:14',1,'nseq n = nseq\' n 1\r\n\r\nnseq\' n k =\r\n  if k > n\r\n  then 0\r\n  else if k + k +1 > n\r\n  then 1\r\n  else nseq\' n (k+1) + nseq\' (n-k) (k+1)\r\n','<br/>Тесты успешно пройдены!'),(4500,18,'115753099','2013-09-03 12:01:13',2,'f n = 1 + func n\r\n\r\nfunc 0 = 1\r\nfunc n = 1 + 1 / ( func n )\r\n  --- Тут у вас программа зациклится, из за этого и ошибка (сообщение об ошибке не совсем адекватное..)','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(4498,21,'517309','2013-09-03 08:06:20',0,'nseq n = nseq\' n 1\r\n\r\nnseq\' n k =\r\n  if k > n\r\n  then 0\r\n  else if k + k +1 > n\r\n  then 1\r\n  else razl\' n (k+1) + razl\' (n-k) (k+1)\r\n','Не удалось вычислить выражение \"nseq 1\", проверьте правильность синтаксиса'),(4493,24,'517309','2013-09-03 07:48:27',0,'b n = b\' 0 n\r\n\r\nb\' k n = if (k == n) then n\r\n         else k + 1 / f (k+1) n ','Не удалось вычислить выражение \"b 3\", проверьте правильность синтаксиса'),(4494,24,'517309','2013-09-03 07:49:55',0,'b n = b\' 0 n\r\n\r\nb\' k n = if (k == n) then n\r\n         else k + 1 / b (k+1) n','Не удалось вычислить выражение \"b 3\", проверьте правильность синтаксиса'),(4495,24,'517309','2013-09-03 07:50:21',2,'b n = b\' 0 n\r\n\r\nb\' k n = if (k == n) then n\r\n         else k + 1 / b\' (k+1) n','<br/>Тесты успешно пройдены!'),(4496,19,'517309','2013-09-03 07:53:26',1,'sumsin n = sumsin\' n 0 0\r\n\r\nsumsin\' 0 s1 s1 = sin s1 / s2\r\nsumsin\' n s1 s2 = sumsin\' (n-1) (s1+n) (s2+sin n)','Не удалось вычислить выражение \"sumsin 1\", проверьте правильность синтаксиса'),(4497,20,'517309','2013-09-03 07:57:55',1,'sumfact n = sumfact\' n 1 1 0\r\n\r\nsumfact\' 0 _ _ s = s\r\nsumfact\' n i p s =\r\n  sumfact\' (n-1) (i+1) (p*i) (s+p*i)\r\n','<br/>Тесты успешно пройдены!'),(4490,24,'419892','2013-08-31 12:32:55',0,'f 1 = 2','Не удалось вычислить выражение \"b 3\", проверьте правильность синтаксиса'),(4491,24,'419892','2013-08-31 12:33:03',3,'b 3 = 1','Выражение имеет неправильное значение: b 3'),(4492,18,'517309','2013-09-03 07:45:19',1,'f 0 = 1\r\nf n = 1 + 1/f (n-1)','<br/>Тесты успешно пройдены!'),(7983,121,'5543298','2013-11-24 22:50:32',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"34.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(\"facts_cps(3, x => x * x) = {0}\", fact_cps(3, x => x * x));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"31.1\":\r\n\r\n                    {\r\n\r\n                        var arr1 = new int[] { 1, 2, 3, 5, 6, 20, 21 };\r\n\r\n                        var arr2 = new int[] { 1, 2, 3, 5, 6, 20, 21 };\r\n\r\n                        var arr3 = new int[] { 1, 2, 3, 5, 6, 20, 21, 101 };\r\n\r\n                        var res1 = find(x => x > 20, arr1, () => 0);\r\n\r\n                        // Ищем число >20, а если не найдем, возвращаем 0\r\n\r\n                        var res2 = find(x => x > 20, arr2, () =>\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(\"Not found\");\r\n\r\n                            return 0;\r\n\r\n                        });\r\n\r\n                        // Ищем число >20, а если не найдем, печатаем сообщение и возвращаем 0\r\n\r\n                        var res3 = find (x => x > 1000, arr3, () => find (x => x > 500, arr3, () => find(x => x > 100, arr3, () => 0)));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"28.1\":\r\n\r\n                    {\r\n\r\n                        allDiffLists(3, 2)();\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"26.1\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8, 9, 10 };\r\n\r\n                        int[] b = { 3, 5, 9, 5, 6 };\r\n\r\n                        Console.WriteLine(allDifferent(a));\r\n\r\n                        Console.WriteLine(allDifferent(b));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"26.2\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8 };\r\n\r\n                        int[] b = { 3, 5, 9 };\r\n\r\n                        foreach (int i in Merge(a, b))\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"23.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var num in Lst137())\r\n\r\n                        {\r\n\r\n                            Console.Write(\"{0}, \", num);\r\n\r\n                            k++;\r\n\r\n                            if (k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"20.2\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var pair in cantor())\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(pair);\r\n\r\n                            k++;\r\n\r\n                            if (k == 50)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int fact_cps(int i, Func<int, int> f)\r\n\r\n        {\r\n\r\n            if (i == 0)\r\n\r\n                return f(1);\r\n\r\n            return fact_cps(i-1, x => f(x * i));\r\n\r\n        }\r\n\r\n\r\n\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err) \r\n\r\n        {\r\n\r\n            foreach (var i in a)\r\n\r\n            {\r\n\r\n                if (func(i))\r\n\r\n                    return i;\r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static Action allDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            Action print = () => { };\r\n\r\n            Predicate<int> set = t => true;\r\n\r\n            allDiffLists(print, set, 1, n, k);\r\n\r\n            return print;\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void allDiffLists(Action print, Predicate<int> set, int current, int n, int k)\r\n\r\n        {\r\n\r\n            \r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (a.Length == from)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            var x = a[from];\r\n\r\n            if (!cond(x))\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            return allDifferent1(a, ++from, t => cond(t) && t != x);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var result = new List<int>();\r\n\r\n            var aen = a.GetEnumerator();\r\n\r\n            var ben = b.GetEnumerator();\r\n\r\n            var isAEmpty = !aen.MoveNext();\r\n\r\n            var isBEmpty = !ben.MoveNext();\r\n\r\n            int x, y;\r\n\r\n            while (!isAEmpty && !isBEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                y = ben.Current;\r\n\r\n                if (x < y)\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                }\r\n\r\n                else if (y < x)\r\n\r\n                {\r\n\r\n                    result.Add(y);\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                } \r\n\r\n                else\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            while (!isAEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                result.Add(x);\r\n\r\n                isAEmpty = !aen.MoveNext();\r\n\r\n            }\r\n\r\n            while (!isBEmpty)\r\n\r\n            {\r\n\r\n                y = ben.Current;\r\n\r\n                result.Add(y);\r\n\r\n                isBEmpty = !ben.MoveNext();\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                var next = i * 10;\r\n\r\n                yield return next + 1;\r\n\r\n                yield return next + 3;\r\n\r\n                yield return next + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var resPowN = new BigInteger(0);\r\n\r\n            var left = new BigInteger(1);\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                left *= 10;\r\n\r\n                var min = left - resPowN * 10 * n;\r\n\r\n                var minIndex = 0;\r\n\r\n                for (int j = 1; j < 10; j++)\r\n\r\n                {\r\n\r\n                    var current = left - (resPowN * 10 + j) * n;\r\n\r\n                    if (current < min && current > 0)\r\n\r\n                    {\r\n\r\n                        min = current;\r\n\r\n                        minIndex = j;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                resPowN = resPowN * 10 + minIndex;\r\n\r\n                yield return minIndex;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7982,98,'5543298','2013-11-24 22:44:10',1,'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr\' Empty = (\'e\':)\r\n\r\ntoStr\' (Node x l r) = (\'n\':).(x:).toStr\' l.toStr\' r\r\n\r\n\r\n\r\ntoStr t = (toStr\' t) \"\"\r\n\r\n\r\n\r\nfromStr\' (\'e\':ss) = (Empty, ss)\r\n\r\nfromStr\' (\'n\':ss) = let temp = fromStr\'(tail ss) in let l = fst temp in let rTemp = fromStr\' (snd temp) in let r = fst rTemp in let t = snd rTemp in ((Node (head ss) l r), t)   \r\n\r\n\r\n\r\nfromStr ss = fst (fromStr\' ss)\r\n','<br/>Тесты успешно пройдены!'),(7981,98,'5543298','2013-11-24 22:42:57',0,'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\n\r\n\ntoStr\' Empty = (\'e\':)\r\n\ntoStr\' (Node x l r) = (\'n\':).(x:).toStr\' l.toStr\' r\r\n\n\r\n\ntoStr t = (toStr\' t) \"\"\r\n\n\r\n\nfromStr (\'e\':ss) = (Empty, ss)\r\n\nfromStr (\'n\':ss) = let temp = fromStr(tail ss) in let l = fst temp in let rTemp = fromStr (snd temp) in let r = fst rTemp in let t = snd rTemp in ((Node (head ss) l r), t)   \n','Выражение имеет неправильное значение: fromStr(toStr (Node \'a\' (Node \'b\' Empty Empty) Empty))'),(7979,114,'SNNatalieS','2013-11-24 22:31:08',1,'triangle2 n = do  \r\n			x <- [1..n]\r\n			y <- [1..x]\r\n			return (y * y)\r\n\r\n\r\ntriangle1 n = [1..n] >>= x -> [1..x] >>= y -> return (y * y)','<br/>Тесты успешно пройдены!'),(7980,111,'5247795','2013-11-24 22:37:55',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\n\r\n\r\neval (Var x) ((y, n):xs) = if (y == x) then n else (eval (Var x) xs)\r\n\r\n\r\n\r\neval (Num n) _ = n \r\n\r\n\r\n\r\neval (Add s1 s2) xs = (eval s1 xs) + (eval s2 xs)\r\n\r\n\r\n\r\neval (Mult m1 m2) xs = (eval m1 xs) * (eval m2 xs)\r\n','<br/>Тесты успешно пройдены!'),(7978,106,'3320654','2013-11-24 22:29:00',1,'findMajor list = isMostOften list (help list Nothing 0) 0 (div (length list) 2)\r\n-- в третий параметр функции help будем записывать некий счётчик для \r\n-- второго параметра: если очередной элемент списка равен второму \r\n-- параметру, то +1, не равен, то -1\r\n-- так как нужный элемент встречается больше половины раз,\r\n-- то этого хватит, чтобы стать вторым параметром\r\nhelp [] t _		= t\r\nhelp (x:xs) Nothing 0	= help xs (Just x) 1\r\nhelp (x:xs) (Just t) n	= if t == x\r\n		   then help xs (Just t) (n + 1)\r\n		   else 	if n == 1\r\n			then help xs (Just x) 1\r\n			else help xs (Just t) (n - 1)\r\n\r\nisMostOften _ Nothing _ _	= Nothing\r\nisMostOften [] (Just t) k n	= if k > n\r\n		   	   then Just t\r\n			   else Nothing\r\nisMostOften (x:xs) (Just t) k n	= if t == x\r\n			   then isMostOften xs (Just t) (k + 1) n\r\n			   else isMostOften xs (Just t) k n','<br/>Тесты успешно пройдены!'),(7977,110,'Artur','2013-11-24 22:22:46',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace _29_11\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err) \r\n\r\n        {\r\n\r\n            for (int i = 0; i < a.Length; i++)\r\n\r\n            {\r\n\r\n                if (func(a[i]))\r\n\r\n                    return a[i]; \r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] arr = { 1, 2, 3, 4, 5 };\r\n\r\n            int[] arr1 = { 1, 2001, 3, 4, 5 };\r\n\r\n            int[] arr2 = { 1, 2, 3, 4, 503 };\r\n\r\n            int[] arr3 = { 105, 2, 3, 4, 5 };\r\n\r\n            var res = find(x => x > 20, arr, () => 0);\r\n\r\n            var res1 = find(x => x > 1000, arr1, \r\n\r\n                            ()=> find(x=> x > 500, arr1, \r\n\r\n                                () => find(x => x > 100 , arr1, () => 0) \r\n\r\n                                ) \r\n\r\n                        );\r\n\r\n            var res2 = find(x => x > 1000, arr2,\r\n\r\n                            () => find(x => x > 500, arr2,\r\n\r\n                                () => find(x => x > 100, arr2, () => 0)\r\n\r\n                                )\r\n\r\n                        );\r\n\r\n            var res3 = find(x => x > 1000, arr3,\r\n\r\n                            () => find(x => x > 500, arr3,\r\n\r\n                                () => find(x => x > 100, arr3, () => 0)\r\n\r\n                                )\r\n\r\n                        );\r\n\r\n            Console.WriteLine(res  );\r\n\r\n            Console.WriteLine(res1 );\r\n\r\n            Console.WriteLine(res2 );\r\n\r\n            Console.WriteLine(res3 );\r\n\r\n\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7976,113,'3301494','2013-11-24 21:57:08',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(a-> a + x))\r\n','<br/>Тесты успешно пройдены!'),(7975,101,'3301494','2013-11-24 21:56:53',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nsimplify (Num a) = Num a\r\n\r\nsimplify (X) = X \r\n\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\n\r\nsimplify (Mult x y) = f (Mult (simplify x) (simplify y))\r\n\r\n\r\n\r\nf (Mult (Num 0) y) = Num 0\r\n\r\nf (Mult x (Num 0)) = Num 0\r\n\r\nf (Mult (Num 0) (Num 0)) = Num 0\r\n\r\nf (Mult x y) = (Mult x y)\r\n','<br/>Тесты успешно пройдены!'),(7974,111,'3301494','2013-11-24 21:56:33',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nfind cond (x:xs) = if cond (fst x) then snd x else find cond xs\r\n\r\n\r\n\r\neval (Num a) xs = a\r\n\r\neval (Var var) xs = find (x -> x == var) xs \r\n\r\neval (Add a b) xs = eval a xs + eval b xs\r\n\r\neval (Mult a b) xs = eval a xs * eval b xs\r\n','<br/>Тесты успешно пройдены!'),(7973,118,'3301494','2013-11-24 21:56:18',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\ng >>> h = xs -> ((a, b) -> h b) (g xs)\r\n\r\nf = find (>3) >>> find (>3) \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7972,115,'3301494','2013-11-24 21:56:03',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let r1 = (find (<5) xs) in if length r1 /= 1 then [] else let r2 = (find (>10) xs) in if length r2 /= 1 then [] else let r3 = (find (/= 7) xs) in if length r3 /= 1 then [] else [head r1 + head r2 + head r3]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7971,114,'3301494','2013-11-24 21:55:44',1,'triangle1 n = [1..n] >>= k -> [1..k] >>= i -> return (i^2)\r\n\r\n\r\n\r\ntriangle2 n = do \r\n\r\n				k <- [1..n]\r\n\r\n				i <- [1..k]\r\n\r\n				[i^2]\r\n','<br/>Тесты успешно пройдены!'),(7967,113,'5247795','2013-11-24 21:21:32',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7968,118,'5543298','2013-11-24 21:44:02',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nsearch1 >>> search2 = xs -> search2 (snd (search1 xs)) \r\n\r\nf = find (>3) >>> find (>3) \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7969,114,'2156724','2013-11-24 21:47:00',1,'triangle1 n = [1..n] >>= k -> [1..k] >>= m -> return (m^2)\r\n\r\n\r\n\r\ntriangle2 n =	do \r\n\r\n			k <- [1..n]\r\n\r\n			m <- [1..k]\r\n\r\n			[(m^2)]\r\n','<br/>Тесты успешно пройдены!'),(7970,113,'3320654','2013-11-24 21:49:56',1,'sum_cps [] f	= f 0\r\nsum_cps (x:xs) f 	= sum_cps xs (	 -> f (x + t))','<br/>Тесты успешно пройдены!'),(7966,121,'ArtemK','2013-11-24 21:10:44',1,'# Почему-то стандартный print нельзя передать в качестве аргумента (:\r\ndef my_print(s):\r\n    print(s)\r\n\r\n\r\ndef fact_cps(n, f):\r\n    if n == 0:\r\n        return f(1)\r\n    return fact_cps(n - 1, lambda x: f(x*n))\r\n\r\nfact_cps(5, my_print)','<br/>Тесты успешно пройдены!'),(7965,97,'Artur','2013-11-24 21:08:03',1,'checkBrackets xs = checkBrackets\' xs [] \r\n\r\n\r\n\r\ncheckBrackets\' [] [] = True\r\n\r\ncheckBrackets\' [] _  = False\r\n\r\ncheckBrackets\' (x:xs) [] = if x == \')\' || (x == \']\') then False \r\n\r\n							else if x == \'(\' || (x == \'[\') then checkBrackets\' xs [x]\r\n\r\n								else False\r\n\r\ncheckBrackets\' (x:xs) (y:ys) = if x == \'(\' || (x == \'[\') then checkBrackets\' xs (x:y:ys)\r\n\r\n								else if x == \')\' && (y == \'(\') || (x == \']\' && (y == \'[\') ) then checkBrackets\' xs ys\r\n\r\n									else False\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7964,101,'5543298','2013-11-24 21:03:07',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nsimplify (Num a) = Num a\r\n\r\nsimplify (X) = X \r\n\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\n\r\nsimplify (Mult x y) = simplify\' (Mult (simplify x) (simplify y))\r\n\r\n\r\n\r\nsimplify\' (Mult (Num 0) y) = Num 0\r\n\r\nsimplify\' (Mult x (Num 0)) = Num 0\r\n\r\nsimplify\' (Mult (Num 0) (Num 0)) = Num 0\r\n\r\nsimplify\' (Mult x y) = (Mult x y)\r\n','<br/>Тесты успешно пройдены!'),(7962,111,'5543298','2013-11-24 20:35:46',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nfind cond ((a,b):xs) = if cond a then b else find cond xs\r\n\r\n\r\n\r\neval (Num a) xs = a\r\n\r\neval (Var v) xs = find (==v) xs \r\n\r\neval (Add x y) xs = eval x xs + eval y xs\r\n\r\neval (Mult x y) xs = eval x xs * eval y xs\r\n','<br/>Тесты успешно пройдены!'),(7963,113,'Artur','2013-11-24 20:38:53',1,'--fact_cps n f = fact_cps (n-1) (f.(*n))\r\n\r\n\r\n\r\nsum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x)) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7959,114,'5543298','2013-11-24 19:17:51',1,'triangle1 n = [1..n] >>= k -> [1..k] >>= i -> return (i^2)\r\n\r\ntriangle2 n = do \r\n\r\n				k <- [1..n]\r\n\r\n				i <- [1..k]\r\n\r\n				[i^2]\r\n','<br/>Тесты успешно пройдены!'),(7960,115,'5543298','2013-11-24 19:41:24',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let res = (find (<5) xs)++(find (>10) xs)++(find (/= 7) xs) in if length res /= 3 then [] else [sum res]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7961,113,'5543298','2013-11-24 20:21:57',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n','<br/>Тесты успешно пройдены!'),(7956,107,'5543298','2013-11-24 18:51:50',1,'data LogExpr = T | F | X | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr deriving Show\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n    x1 == x2 =  eval x1 True == eval x2 True && eval x1 False == eval x2 False\r\n\r\n\r\n\r\neval T v = True\r\n\r\neval F v = False\r\n\r\neval X v = v\r\n\r\neval (And x y) v = (eval x v) && (eval y v)\r\n\r\neval (Or x y) v = (eval x v) || (eval y v)\r\n\r\neval (Not x) v = not (eval x v)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7957,115,'8519021','2013-11-24 18:56:32',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let ys = (find (<5) xs) ++ (find (>10) xs) ++ (find (/=7) xs) in if length ys /= 3 then [] else return (sum ys)\r\n','<br/>Тесты успешно пройдены!'),(7958,114,'5543298','2013-11-24 19:17:28',0,'data LogExpr = T | F | X | And LogExpr LogExpr | Or LogExpr LogExpr | Not LogExpr deriving Show\r\n\n\r\n\ninstance Eq LogExpr where\r\n\n    x1 == x2 =  eval x1 True == eval x2 True && eval x1 False == eval x2 False\r\n\n\r\n\neval T v = True\r\n\neval F v = False\r\n\neval X v = v\r\n\neval (And x y) v = (eval x v) && (eval y v)\r\n\neval (Or x y) v = (eval x v) || (eval y v)\r\n\neval (Not x) v = not (eval x v)\r\n\n\n','Не удалось вычислить выражение \"triangle1 3\", проверьте правильность синтаксиса'),(7955,101,'nomeansno','2013-11-24 16:21:56',1,'--- На самом деле так неправильно (зациклится, например, при \r\n---   simplify (Mult (Mult X X) (Mult X X))\r\n--- ((  Но ОК, засчитано, не совсем правильные решения у нас тоже засчитываются. \r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\nsimplify (Mult (Num 0) e) = Num 0\r\n\r\nsimplify (Mult e (Num 0)) = Num 0\r\n\r\nsimplify (Mult X X) = Mult X X\r\n\r\nsimplify (Mult e1 e2) = simplify (Mult (simplify e1) (simplify e2))\r\n\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7954,111,'284427','2013-11-24 16:01:54',1,'data Expr = Var String | Num Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ngetVal [] _ = 0\r\n\r\ngetVal ((s, v):values) x = if (x == s) then v else (getVal values x)\r\n\r\n\r\n\r\neval (Var x) values = getVal values x\r\n\r\neval (Num n) _ = n\r\n\r\neval (Add a1 a2) values = eval a1 values + eval a2 values\r\n\r\neval (Mult m1 m2) values = eval m1 values * eval m2 values\r\n','<br/>Тесты успешно пройдены!'),(7953,111,'284427','2013-11-24 15:42:58',0,'data Expr = Var String | Num Integer | Add Expr Expr | Mult Expr Expr\r\n\n\r\n\ngetVal [] _ = 0\r\n\ngetVal ((s, v):values) x = if (x == s) then v else (getVal values x)\r\n\n\r\n\neval (Var x) values = getVal values x\r\n\neval (Num n) _ = n\r\n\neval (Add a1 a2) values = eval a1 values + eval a2 values\r\n\neval (Mult m1 m2) values = eval m1 values * eval m2 values\n','<br/>Тесты успешно пройдены!'),(7952,118,'284427','2013-11-24 15:29:20',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>) func1 func2 xs = let (r1, rs) = func1 xs in func2 rs\r\n','<br/>Тесты успешно пройдены!'),(7950,101,'nomeansno','2013-11-24 15:22:29',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\n\n\n\nsimplify (Mult (Num 0) e) = Num 0\n\nsimplify (Mult e (Num 0)) = Num 0\n\nsimplify (Mult e1 e2) = simplify (Mult (simplify e1) (simplify e2))\n\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\n\nsimplify X = X\n\n\n','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(7951,115,'284427','2013-11-24 15:23:52',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = \r\n\r\n	let ss = ([find (<5) xs, find (>10) xs, find (/=7) xs] >>= id) in\r\n\r\n	if (length ss) /= 3 then [] else [sum ss]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7948,118,'8519021','2013-11-24 14:58:10',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>) f1 f2 xs = let (y, ys) = f1 xs in f2 ys\r\n\r\nf = find (>3) >>> find (>3)\r\n','<br/>Тесты успешно пройдены!'),(7949,111,'nomeansno','2013-11-24 15:04:33',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\ntovalue _ [] = 0\r\n\r\ntovalue var ((var\',val):xs) = if var == var\' then val else tovalue var xs\r\n\r\n\r\n\r\neval (Num i) = (\\_ -> i)\r\n\r\neval (Var var) = (vlist -> tovalue var vlist)\r\n\r\neval (Add e1 e2) = (vlist -> eval e1 vlist + eval e2 vlist)\r\n\r\neval (Mult e1 e2) = (vlist -> eval e1 vlist * eval e2 vlist)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7947,114,'284427','2013-11-24 14:47:33',1,'triangle1 n = ([1..n] >>= x -> [1..x]) >>= y -> [y*y]\r\n\r\n\r\n\r\ntriangle2 n = do y <- (do x <- [1..n]; [1..x]); [y*y]\r\n\r\n{--\r\n\r\ntriangle1 n = ([1..n] >>= x -> return [1..x]) >>= id\r\n\r\n\r\n\r\ntriangle2 n = do x <- [1..n]  return [1..x]\r\n\r\n--}\r\n','<br/>Тесты успешно пройдены!'),(7946,111,'nomeansno','2013-11-24 14:17:25',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\ntovalue _ [] = 0\r\n\r\ntovalue var ((var\',val):xs) = if var == var\' then val else tovalue var xs\r\n\r\n\r\n\r\neval (Num i) = (\\_ -> i)\r\n\r\neval (Var var) = (vlist -> tovalue var vlist)\r\n\r\neval (Add e1 e2) = (vlist -> eval e1 vlist + eval e2 vlist)\r\n\r\neval (Mult e1 e2) = (vlist -> eval e1 vlist * eval e2 vlist)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7945,113,'284427','2013-11-24 13:44:48',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n','<br/>Тесты успешно пройдены!'),(7943,113,'nomeansno','2013-11-24 13:20:31',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(x+))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7944,101,'284427','2013-11-24 13:37:14',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n		deriving (Eq, Show)\r\n\r\n\r\n\r\nsimplify (Add a1 a2) = Add (simplify a1) (simplify a2)\r\n\r\nsimplify (Mult m1 m2) = let\r\n\r\n		sm1 = simplify m1\r\n\r\n		sm2 = simplify m2\r\n\r\n	in\r\n\r\n	if not (sm1 == Num 0) && not (sm2 == Num 0) then Mult sm1 sm2 else Num 0\r\n\r\nsimplify (Num a) = Num a\r\n\r\nsimplify X = X\r\n','<br/>Тесты успешно пройдены!'),(7940,115,'nomeansno','2013-11-24 13:19:09',0,'find cond [] = []\n\nfind cond (x:xs) = if cond x then [x] else find cond xs\n\n\n\nf s = let s\' = ((find (<5) s) ++ (find (>10) s) ++ (find (/= 7) s)) in if length s\' == 3 then return (sum s\') else []\n\n\n','<br/>Тесты успешно пройдены!'),(7941,115,'nomeansno','2013-11-24 13:19:42',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf s = let s\' = ((find (<5) s) ++ (find (>10) s) ++ (find (/= 7) s)) in if length s\' == 3 then return (sum s\') else []\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7942,118,'nomeansno','2013-11-24 13:20:09',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nf1 >>> f2 = ( s -> f1 (snd (f2 s)))\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7939,114,'nomeansno','2013-11-24 13:18:02',1,'triangle1 n = [1..n] >>= x -> ([1..x] >>= y -> return (y*y))\r\n\r\n\r\n\r\ntriangle2 n =\r\n\r\n	do n\' <- [1..n]\r\n\r\n	   do x <- [1..n\']\r\n\r\n	      return (x*x) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7937,114,'nomeansno','2013-11-24 13:01:59',0,'triangle1 n = [1..n] >>= x -> return (map (y -> y*y) [1..x])\n\n\n\ntriangle2 n =\n\n	do x <- [1..n]\n\n	   return (map (y -> y*y) [1..x])\n\n\n','Выражение имеет неправильное значение: triangle1 3'),(7938,97,'anlun','2013-11-24 13:13:36',1,'checkBrackets :: String -> Bool\r\ncheckBrackets s = check \"\" s\r\n	where\r\n		check l       (\'(\':s) = check (\'(\':l) s\r\n		check l       (\'[\':s) = check (\'[\':l) s\r\n		check (\'(\':l) (\')\':s) = check l       s\r\n		check (\'[\':l) (\']\':s) = check l       s\r\n		check \"\"      \"\"      = True\r\n		check _ _ = False','<br/>Тесты успешно пройдены!'),(7936,114,'nomeansno','2013-11-24 13:01:05',0,'triangle1 n = [1..n] >>= x -> return (map (y -> y*y) [1..x])\n\n\n\ntriangle2 n =\n\n	do x <- [1..n]\n\n	   return (map (y -> y*y) [1..x])\n\n\n','Выражение имеет неправильное значение: triangle1 3'),(7934,115,'anna','2013-11-24 12:46:48',0,'','Не удалось вычислить выражение \"f [7, 6, 4, 3, 20, 15, 9] \", проверьте правильность синтаксиса'),(7935,115,'anna','2013-11-24 12:47:27',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let a = concat [find (<5) xs, find (>10) xs, find (/=7) xs]\r\n\r\n               in if length a == 3 then return (sum a) else []\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7932,111,'8519021','2013-11-24 12:27:58',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Var y) ((x, value):xs) = if (y == x) then value else (eval (Var y) xs)\r\n\r\neval (Num z) xs = z \r\n\r\neval (Add a b) xs = (eval a xs) + (eval b xs)\r\n\r\neval (Mult a b) xs = (eval a xs) * (eval b xs)\r\n','<br/>Тесты успешно пройдены!'),(7933,114,'anna','2013-11-24 12:28:19',1,'triangle1 n = ([1..n] >>= i -> return [n*n | n <- [1..i]])>>=id\r\n\r\ntriangle2 n =  (do\r\n\r\n                i <- [1..n]\r\n\r\n  --как вывести список без return и стандартных функций?\r\n\r\n                return [n*n | n <- [1..i]])>>=id\r\n  --- Можно воспользоваться еще раз >>= - так же, как мы делали для cartesian\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7930,101,'8519021','2013-11-24 12:17:01',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Eq, Show)\r\n\r\n\r\n\r\nsimplify (Add a b) = Add (simplify a) (simplify b)\r\n\r\nsimplify (Mult a b) = \r\n\r\n  let \r\n\r\n	a1 = simplify a\r\n\r\n	b1 = simplify b\r\n\r\n  in if a1 == Num 0 || b1 == Num 0 then Num 0 else Mult a1 b1\r\n\r\nsimplify otherExpr = otherExpr\r\n','<br/>Тесты успешно пройдены!'),(7931,114,'anna','2013-11-24 12:26:16',0,'triangle1 n = ([1..n] >>= i -> return [n*n | n <- [1..i]])>>=id\r\ntriangle2 n =  (do\r\n                i <- [1..n]\r\n  --как вывести список без return и стандартных функций?\r\n               return [n*n | n <- [1..i]])>>=id\r\n','Не удалось вычислить выражение \"triangle1 3\", проверьте правильность синтаксиса'),(7928,114,'8519021','2013-11-24 10:21:02',1,'triangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j * j)\r\n\r\n\r\n\r\ntriangle2 n = \r\n\r\n  do \r\n\r\n	i <- [1..n]\r\n\r\n	j <- [1..i]\r\n\r\n	[(j * j)]\r\n','<br/>Тесты успешно пройдены!'),(7929,113,'8519021','2013-11-24 10:47:00',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n','<br/>Тесты успешно пройдены!'),(7926,115,'5247795','2013-11-23 22:26:17',0,'','Не удалось вычислить выражение \"f [7, 6, 4, 3, 20, 15, 9] \", проверьте правильность синтаксиса'),(7927,115,'5247795','2013-11-23 22:26:29',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = do x <- find (<5) xs\r\n\r\n	  y <- find (>10) xs\r\n\r\n	  z <- find (/=7) xs\r\n\r\n	  return (x+y+z)\r\n','<br/>Тесты успешно пройдены!'),(7924,113,'617015','2013-11-23 19:56:58',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (	->f(t+x))\r\n','<br/>Тесты успешно пройдены!'),(7925,114,'5247795','2013-11-23 20:56:56',1,'triangle1 n = triangle1\' [1..n]\r\n\r\ntriangle1\' xs = xs >>= x -> [1..x] >>= y -> return (y*y)\r\n\r\n\r\n\r\ntriangle2 n = triangle2\' [1..n]\r\n\r\ntriangle2\' xs = do x <- xs\r\n\r\n		   y <- [1..x]\r\n\r\n		   [y*y]\r\n','<br/>Тесты успешно пройдены!'),(7923,101,'617015','2013-11-23 19:56:28',2,'--- Так у вас циклится вот в таком примере:\r\n---   simplify (Mult (Mult X X) (Mult X X))\r\n--- Я сейчас его добавлю, а вы попробуйте исправить, пожалуйста. Но, если не получится,\r\n--- пришлите снова это же решение, и я его зачту\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving Show\r\n\r\n\r\n\r\nsimplify (Mult (Num 0) e) = Num 0\r\n\r\nsimplify (Mult e (Num 0)) = Num 0\r\n\r\nsimplify (Mult X X) = Mult X X\r\n\r\nsimplify (Mult (Num k) X) = Mult (Num k) X\r\n\r\nsimplify (Mult X (Num k)) = Mult X (Num k)\r\n\r\nsimplify (Mult (Num k) (Num p)) = Mult (Num k)(Num p)\r\n\r\nsimplify (Mult e1 e2) = simplify (Mult (simplify e1) (simplify e2))	\r\n\r\nsimplify (Add e1 e2) = simplify(Add (simplify e1) (simplify e2))	\r\n\r\nsimplify (Num k) = Num k\r\n\r\nsimplify (X) = X\r\n\r\n	\r\n','<br/>Тесты успешно пройдены!'),(7922,111,'617015','2013-11-23 19:56:07',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving Show\r\n\r\n	\r\n\r\neval (Num k) xs = k\r\n\r\neval (Var c) ((x,y):xs) = if x == c then y else eval (Var c) xs\r\n\r\neval (Add e1 e2) xs = (eval e1 xs) + (eval e2 xs)\r\n\r\neval (Mult e1 e2) xs = (eval e1 xs) * (eval e2 xs)  \r\n','<br/>Тесты успешно пройдены!'),(7920,115,'617015','2013-11-23 19:55:11',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = if length res <3 then [] else [sum res] \r\n\r\n		where res = (find(<5) xs)++(find(>10) xs)++(find(/=7) xs)  \r\n','<br/>Тесты успешно пройдены!'),(7921,118,'617015','2013-11-23 19:55:45',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nf1 >>> f2 = xs -> f2 (snd(f1 xs))\r\n\r\n\r\n\r\nf = find (>3) >>> find (>3) \r\n','<br/>Тесты успешно пройдены!'),(7919,114,'617015','2013-11-23 19:54:42',1,'triangle1 n = [1..n] >>= x -> [1..x] >>= y-> return(y*y)\r\n\r\n\r\n\r\ntriangle2 n = do \r\n\r\n	x <- [1..n]\r\n\r\n	y <- [1..x]\r\n\r\n	return (y*y)\r\n','<br/>Тесты успешно пройдены!'),(7917,118,'3226573','2013-11-23 16:56:50',1,'find cond (x:xs) = if cond x then (x,xs) else find cond xs\r\n\r\n(>>>) f1 f2 = f2 . snd . f1','<br/>Тесты успешно пройдены!'),(7918,98,'3226573','2013-11-23 17:07:17',1,'data Node = Node Char Node Node | Empty deriving Show\r\n\r\ntoStr\' Empty = (\'e\' :)\r\ntoStr\' (Node c l r) = (\'n\' :) . (c :) . toStr\' l . toStr\' r\r\ntoStr x = (toStr\' x) []\r\n\r\nfromStr\' (\'e\':line) = (Empty, line)\r\nfromStr\' (\'n\':c:line) = let\r\n                          (l, line1) = fromStr\' line\r\n                          (r, line2) = fromStr\' line1\r\n                        in ((Node c l r), line2)\r\nfromStr line = fst (fromStr\' line)','<br/>Тесты успешно пройдены!'),(7916,113,'3226573','2013-11-23 15:15:56',1,'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (	 -> f(t + x))','<br/>Тесты успешно пройдены!'),(7915,101,'3226573','2013-11-23 15:15:36',1,'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | X deriving Show\r\n  --- тут проще было бы написать  deriving (Showm, Eq) и тогда == сгенерировалось бы автоматически.\r\n\r\nsimplify (Num val) = Num val\r\nsimplify (X) = X\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\r\nsimplify (Mult e1 e2) = let\r\n                          se1 = simplify e1\r\n                          se2 = simplify e2\r\n                        in if (se1 == Num 0) || (se2 == Num 0)\r\n                           then Num 0\r\n                           else Mult se1 se2\r\n\r\ninstance Eq Expr where\r\n	(Num v1) == (Num v2) = v1 == v2\r\n	X == (Num v) = False\r\n	(Add e1 e2) == (Num v) = False\r\n	(Mult e1 e2) == (Num v) = False','<br/>Тесты успешно пройдены!'),(7914,111,'3226573','2013-11-23 15:15:12',1,'data Expr = Num Integer | Add Expr Expr | Mult Expr Expr | Var String deriving Show\r\n\r\ngetValue name [] = 0\r\ngetValue name ((varName, varVal):vars) = if name == varName then varVal else getValue name vars\r\n\r\neval (Num val) _ = val\r\neval (Add e1 e2) vars = (eval e1 vars) + (eval e2 vars)\r\neval (Mult e1 e2) vars = (eval e1 vars) * (eval e2 vars)\r\neval (Var name) vars = getValue name vars','<br/>Тесты успешно пройдены!'),(7912,114,'3226573','2013-11-23 15:13:52',1,'triangle1 n = [1..n] >>= (x -> [1..x] >>= (y -> return (y*y)))\r\n\r\ntriangle2 n = do x <- [1..n] \r\n                 y <- [1..x]\r\n                 [y*y]','<br/>Тесты успешно пройдены!'),(7913,115,'3226573','2013-11-23 15:14:16',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = let\r\n         res = (find (< 5) xs) ++ (find (> 10) xs) ++ (find (/= 7) xs)\r\n       in if length res < 3 then [] else [sum res]','<br/>Тесты успешно пройдены!'),(7904,121,'romos2007','2013-11-23 13:07:04',1,'﻿/*\r\n\r\n * Задача 34-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _34_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int fact_cps(int n, Func<int,int> f)\r\n\r\n        {\r\n\r\n            if (n == 0)\r\n\r\n            {\r\n\r\n                return f(1);\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                return fact_cps((n-1),t=>f(t*n));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine(fact_cps(5,x=>x+3));\r\n\r\n            Console.ReadLine(); \r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7905,114,'3270666','2013-11-23 14:25:20',1,'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return (y * y)\r\n\r\ntriangle2 n = \r\n	do x <- [1..n]\r\n	   y <- [1..x]\r\n	   return (y * y)','<br/>Тесты успешно пройдены!'),(7906,115,'3270666','2013-11-23 14:31:28',1,'f xs = zipWith (+) (zipWith (+) (find (<5) xs) (find (>10) xs)) (find (/=7) xs)\r\n\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs','<br/>Тесты успешно пройдены!'),(7907,118,'3270666','2013-11-23 14:37:25',1,'a >>> b = a . snd . b\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n--f = find (>3) >>> find (>3)','<br/>Тесты успешно пройдены!'),(7908,111,'3270666','2013-11-23 14:44:58',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n		deriving Show\r\n\r\neval (Num n) vals = n\r\neval (Add expr1 expr2) vals = eval expr1 vals + eval expr2 vals\r\neval (Mult expr1 expr2) vals = eval expr1 vals * eval expr2 vals\r\neval (Var x) (v:vals) = \r\n	if (fst v == x)\r\n		then snd v\r\n		else eval (Var x) (vals)\r\neval (Var x) [] = 0','<br/>Тесты успешно пройдены!'),(7909,101,'3270666','2013-11-23 14:58:07',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n	deriving Show\r\n\r\nsimplify (Num n) = (Num n)\r\nsimplify (X) = (X)\r\nsimplify (Add expr1 expr2) = (Add (simplify expr1) (simplify expr2))\r\nsimplify (Mult expr1 expr2) = \r\n	simplify\' (Mult (simplify expr1) (simplify expr2))\r\n\r\nsimplify\' (Mult (Num 0) _) = (Num 0)\r\nsimplify\' (Mult _ (Num 0)) = (Num 0)\r\nsimplify\' (Mult expr1 expr2) = (Mult expr1 expr2)','<br/>Тесты успешно пройдены!'),(7910,113,'3270666','2013-11-23 15:09:59',1,'sum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (f.(x +))','<br/>Тесты успешно пройдены!'),(7911,107,'3226573','2013-11-23 15:13:16',1,'--module ThirtyThreeDotOne where\r\n\r\n\r\n\r\ndata LogExpr = T | F | X | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\r\n\r\n\r\n\r\nsimplify (T) = T\r\n\r\nsimplify (F) = F\r\n\r\nsimplify (X) = X\r\n\r\nsimplify (Not X) = Not X\r\n\r\n\r\n\r\nsimplify (Not b) =     let\r\n\r\n                         sb = simplify b\r\n\r\n                       in      if sb == T then F\r\n\r\n                   	      else if sb == F then T\r\n\r\n                   	      else if sb == X then Not X\r\n\r\n                   	      else if sb == (Not X) then X\r\n\r\n                   	      else Not sb\r\n\r\n\r\n\r\nsimplify (And b1 b2) = let\r\n\r\n                         sb1 = simplify b1\r\n\r\n                         sb2 = simplify b2\r\n\r\n                       in      if (sb1 == T) && (sb2 == T) then T\r\n\r\n                       	  else if (sb1 == F) || (sb2 == F) then F\r\n\r\n                       	  else if (sb1 == sb2) then sb2\r\n\r\n                       	  else F\r\n\r\n\r\n\r\nsimplify (Or b1 b2) =  let\r\n\r\n                         sb1 = simplify b1\r\n\r\n                         sb2 = simplify b2\r\n\r\n                       in      if (sb1 == T) || (sb2 == T) then T\r\n\r\n                       	  else if (sb1 == F) && (sb2 == F) then F\r\n\r\n                       	  else if (sb1 == sb2) then sb2\r\n\r\n                       	  else if (sb1 == X) && (sb2 == (Not X)) then T\r\n\r\n                       	  else if (sb1 == (Not X)) && (sb2 == X) then T\r\n\r\n                       	  else F\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	(T) == (T) = True\r\n\r\n	(T) == (F) = False\r\n\r\n	(T) == (X) = False\r\n\r\n	(T) == (Not X) = False\r\n\r\n\r\n\r\n	(F) == (F) = True\r\n\r\n	(F) == (T) = False\r\n\r\n	(F) == (X) = False\r\n\r\n	(F) == (Not X) = False\r\n\r\n\r\n\r\n	(X) == (X) = True\r\n\r\n	(X) == (T) = False\r\n\r\n	(X) == (F) = False\r\n\r\n	(X) == (Not X) = False\r\n\r\n\r\n\r\n	(Not X) == (Not X) = True\r\n\r\n	(Not X) == (X) = False\r\n\r\n	(Not X) == (T) = False\r\n\r\n	(Not X) == (F) = False\r\n\r\n\r\n\r\n	b1 == b2 = (simplify b1) == (simplify b2)\r\n','<br/>Тесты успешно пройдены!'),(7903,99,'romos2007','2013-11-23 13:06:49',1,'--- ОК, но я бы наверное производную тоже сделал абстрактным методом \r\n--- Пусть вид выражения сам знает, как себя дифференецировать\r\n﻿/*\r\n\r\n * Задача 34-2\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _34_2\r\n\r\n{\r\n\r\n    abstract class Node\r\n\r\n    {\r\n\r\n        abstract public string Print();\r\n\r\n    }\r\n\r\n    class Variable:Node\r\n\r\n    {\r\n\r\n        override public string Print()\r\n\r\n        {\r\n\r\n            return \"X\";\r\n\r\n        }\r\n\r\n    }\r\n\r\n    class Number:Node\r\n\r\n    {\r\n\r\n        public int n;\r\n\r\n        public Number(int x)\r\n\r\n        {\r\n\r\n            this.n = x;\r\n\r\n        }\r\n\r\n        override public string Print()\r\n\r\n        {\r\n\r\n            return this.n.ToString();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    class Op:Node\r\n\r\n    {\r\n\r\n        public Node left;\r\n\r\n        public Node right;\r\n\r\n        public string operat;\r\n\r\n\r\n\r\n        public Op(Node l, Node r, string op)\r\n\r\n        {\r\n\r\n            this.left = l;\r\n\r\n            this.right = r;\r\n\r\n            this.operat = op;\r\n\r\n        }\r\n\r\n        override public string Print()\r\n\r\n        {\r\n\r\n            switch (operat)\r\n\r\n            {\r\n\r\n                case \"Add\":\r\n\r\n                    return \" (\" + left.Print() + \" \" + \"+\" + \" \" + right.Print() + \") \";\r\n\r\n                case \"Mult\":\r\n\r\n                    return \" (\" + left.Print() + \" \" + \"*\" + \" \" + right.Print() + \") \";\r\n\r\n            }\r\n\r\n            return \" (\" + left.Print() + \" \" + operat + \" \" + right.Print() + \") \";\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n\r\n\r\n        public static Node Diff(Node n)\r\n\r\n        {\r\n\r\n            if (n is Variable)\r\n\r\n            {\r\n\r\n                return new Number(1);\r\n\r\n            }\r\n\r\n            if (n is Number)\r\n\r\n            {\r\n\r\n                return new Number(0);\r\n\r\n            }\r\n\r\n            \r\n\r\n            if (n is Op)\r\n\r\n            {\r\n\r\n                Op expr = (Op) n;\r\n\r\n                if (expr.operat == \"Add\")\r\n\r\n                {\r\n\r\n                    return new Op(Diff(expr.left), Diff(expr.right),\"Add\");\r\n\r\n                }\r\n\r\n                if (expr.operat == \"Mult\")\r\n\r\n                {\r\n\r\n                    return new Op(new Op(expr.left, Diff(expr.right), \"Mult\"), new Op(Diff(expr.left), expr.right, \"Mult\"), \"Add\");\r\n\r\n                }\r\n\r\n                else\r\n\r\n                    return null;\r\n\r\n            }\r\n\r\n\r\n\r\n            \r\n\r\n            else return null;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Variable v = new Variable();\r\n\r\n            Number n = new Number(7);\r\n\r\n            Op expr = new Op(new Variable(), new Variable(), \"Mult\");\r\n\r\n\r\n\r\n            Console.WriteLine(Diff(v).Print());\r\n\r\n            Console.WriteLine(Diff(n).Print());\r\n\r\n            Console.WriteLine(Diff(expr).Print());\r\n\r\n\r\n\r\n            Console.ReadLine();\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7902,121,'1595828','2013-11-23 12:09:30',1,'--- ОК, спасибо, что написали, в следующий раз дам другую задачку! \r\n// что надо делать и почему почерпано из http://blogs.msdn.com/b/wesdyer/archive/2007/12/22/continuation-passing-style.aspx к несчастью там представлена реализация данной задачи.\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nclass zd\r\n\r\n{\r\n\r\n    static void fact_cps(int n, Action<int> a)\r\n\r\n    {\r\n\r\n        if (n == 0)\r\n\r\n            a(1);\r\n\r\n        else\r\n\r\n            fact_cps(n - 1, x => a(n * x));\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        int n = 3;\r\n\r\n        fact_cps(n, x => Console.WriteLine(x));\r\n\r\n        Console.ReadKey();\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7900,113,'1595828','2013-11-23 11:15:32',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n','<br/>Тесты успешно пройдены!'),(7901,110,'1595828','2013-11-23 11:34:25',1,'using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nclass zd\r\n\r\n{\r\n\r\n    public static int find(Predicate<int> f, int[] a, Func<int> err)\r\n\r\n    {\r\n\r\n        foreach (int x in a)\r\n\r\n        {\r\n\r\n            if (f(x))\r\n\r\n            {\r\n\r\n                return x;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return err();\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int [] a = { 101, 502, 1003, 2};\r\n\r\n\r\n\r\n            Console.WriteLine(find(x => x > 1000, a, () => find(x => x > 500, a, () => find(x => x > 100, a, () => 0))));\r\n\r\n			Console.ReadKey();\r\n\r\n		}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7898,118,'1595828','2013-11-23 10:51:42',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>) f1 f2 xs= f2 ys where (_,ys) = f1 xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7899,121,'deripaska','2013-11-23 11:06:03',1,'/*\r\n\r\n    task 34-01\r\n\r\nЗадание простое: написать функцию fact_cps, которая вычисляет факториал, с использованием рекурсии и continuation apssing style. Ну и привести пример вызова - ввести целое число и, с помощью вызова fact_cps напечатать результат.\r\n\r\nТ.е., фактически, надо просто переписать пример с занятий на C# (или на любой другой `обычный` язык программирования). \r\n\r\n */\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_34_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int fact_cps(int n, Func<int, int> f)\r\n\r\n        {\r\n\r\n            if (n == 0)\r\n\r\n            {\r\n\r\n                return f(1);\r\n\r\n            }\r\n\r\n\r\n\r\n            return fact_cps(n - 1, i => f(i * n));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n = int.Parse(Console.ReadLine());\r\n\r\n            Console.WriteLine(\"fact : \" + fact_cps(n, i => i));\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7897,115,'1595828','2013-11-23 10:25:31',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs = let str = (find (<5) xs ++ find (>10) xs++ find (/=7) xs) in if (length str ==3) then  [sum str] else []\r\n','<br/>Тесты успешно пройдены!'),(7895,114,'1595828','2013-11-23 10:10:14',1,'triangle1 n =[1..n]>>= x -> [1..x] >>= y -> return (y*y)\r\n\r\ntriangle2 n = do \r\n\r\n	x<-[1..n] \r\n\r\n	y<-[1..x] \r\n\r\n	return (y*y)\r\n','<br/>Тесты успешно пройдены!'),(7896,115,'1595828','2013-11-23 10:22:32',0,'find cond [] = []\r\n\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\nf xs = let str = (find (<5) xs ++ find (>10) xs++ find (/=7) xs) in if (length str ==3) then  str else []\n','Выражение имеет неправильное значение: f [7, 6, 4, 3, 20, 15, 9] '),(7893,121,'ilia','2013-11-23 01:27:14',1,'#!/usr/bin/env python\r\n\r\nimport math\r\n\r\n\r\n\r\ndef fact_cps(n, f = lambda x: x):\r\n\r\n	return f(1) if n == 0 else fact_cps(n - 1, lambda x: f(x) * n)\r\n\r\n\r\n\r\nprint fact_cps(5)\r\n\r\nprint fact_cps(5, math.sin)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7894,99,'ilia','2013-11-23 02:30:25',1,'#!/usr/bin/env python\r\n\r\nclass Expr:\r\n\r\n	def __init__(self, *vals):\r\n\r\n		self.vals = vals\r\n\r\n	def __str__(self):\r\n\r\n		return \"%s%s\" % (self.__class__.__name__,\r\n\r\n				\"\".join([ \" (%s)\" % val for val in self.vals ]))\r\n\r\nclass Num(Expr):\r\n\r\n	def diff(self):\r\n\r\n		return Num(0)\r\n\r\nclass X(Expr):\r\n\r\n	def diff(self):\r\n\r\n		return Num(1)\r\n\r\nclass Add(Expr):\r\n\r\n	def diff(self):\r\n\r\n		return Add(*tuple(map(lambda e: e.diff(), self.vals)))\r\n\r\nclass Mult(Expr):\r\n\r\n	def diff(self):\r\n\r\n		return Add(*tuple(\r\n\r\n			map(lambda i: Mult(*(self.vals[:i]\r\n\r\n					+ (self.vals[i].diff(),)\r\n\r\n					+ self.vals[i + 1:])), range(len(self.vals)))))\r\n\r\n\r\n\r\ndef diff(e): return e.diff()\r\n\r\n\r\n\r\nprint diff(Mult(X(), X(), X(), X()))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7890,113,'2156724','2013-11-23 00:36:52',1,'sum_cps [] f = f 0;\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7891,98,'ilia','2013-11-23 01:08:25',1,'data Tree =\r\n\r\n	Empty |\r\n\r\n	Node Char Tree Tree\r\n\r\n	deriving Show\r\n\r\n\r\n\r\ntoStr tree = toStr\' tree \"\"\r\n\r\ntoStr\' Empty = (\'e\':)\r\n\r\ntoStr\' (Node v l r) = (\'n\':) . (v:) . toStr\' l . toStr\' r\r\n\r\n\r\n\r\nfromStr s = fst (fromStr\' s)\r\n\r\nfromStr\' (c:s)\r\n\r\n	| c == \'e\' = (Empty, s)\r\n\r\n	| c == \'n\' = let\r\n\r\n			v = head s\r\n\r\n			l = fromStr\' (tail s)\r\n\r\n			r = fromStr\' (snd l)\r\n\r\n		in\r\n\r\n			(Node (head s) (fst l) (fst r), snd r)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (toStr (Node \'a\' Empty (Node \'b\' Empty Empty)))\r\n\r\n	print (fromStr \"naenbee\")\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7892,113,'ilia','2013-11-23 01:21:29',1,'sum_cps [ ] f = f 0\r\n\r\nsum_cps (mh:m) f = sum_cps m (f.(+mh))\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (sum_cps [1, 2, 3] id)\r\n\r\n	print (sum_cps [1, 2, 3] (^2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7889,101,'2156724','2013-11-23 00:36:28',1,'data Expr = Num Integer\r\n\r\n          | X	 \r\n\r\n          | Add Expr Expr \r\n\r\n          | Mult Expr Expr \r\n\r\n     deriving (Show, Eq)\r\n\r\n\r\n\r\neval (Add e1 e2) n = (eval e1 n) + (eval e2 n) \r\n\r\neval (Mult e1 e2) n = (eval e1 n) * (eval e2 n)\r\n\r\neval (X) n = n \r\n\r\neval (Num a) n = n \r\n\r\n\r\n\r\nsimplify (Add e1 e2)= Add (simplify e1) (simplify e2) \r\n\r\nsimplify (Mult e1 e2) = \r\n\r\n             let e11 = simplify e1\r\n\r\n                 e21 = simplify e2\r\n\r\n    in      if (e11 == Num 0 || e21 == Num 0) then Num 0\r\n\r\n     else Mult e11 e21\r\n\r\nsimplify (X)  = (X) \r\n\r\nsimplify (Num a) = Num a \r\n','<br/>Тесты успешно пройдены!'),(7887,115,'2156724','2013-11-23 00:35:03',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf (x:xs) =\r\n\r\n   let a = (find (<5) (x:xs)) ++ (find (>10) (x:xs)) ++ (find ( -> not (b==7)) (x:xs)) in\r\n\r\n   if (length a) < 3 then [] else ([sum a]) \r\n','<br/>Тесты успешно пройдены!'),(7888,111,'2156724','2013-11-23 00:35:34',1,'data Expr = Num Integer \r\n\r\n          | Var String \r\n\r\n          | Add Expr Expr \r\n\r\n          | Mult Expr Expr \r\n\r\n     deriving Show\r\n\r\n\r\n\r\neval (Add e1 e2) (x:xs) = (eval e1 (x:xs)) + (eval e2 (x:xs)) \r\n\r\neval (Mult e1 e2) (x:xs) = (eval e1 (x:xs)) * (eval e2 (x:xs))\r\n\r\neval (Var a) ((x,y):xs) = \r\n\r\n         if (x == a) then y else eval (Var a) xs\r\n   --- ОК, но это я вынес бы в вспомогательную функцию.\r\n\r\neval (Num a) (x:xs) = a \r\n','<br/>Тесты успешно пройдены!'),(7884,108,'8519021','2013-11-22 21:49:13',1,'queens n k = queens\' n k ( _ _ -> True)  \r\n\r\nqueens\' n 0 _ = [[]]\r\n\r\nqueens\' n k cond = [(k, i):xs | i<-[1..n], cond k i, xs<-queens\' n (k - 1) (col row -> cond col row && row /= i && abs (col - k) /= abs (row - i))]\r\n','<br/>Тесты успешно пройдены!'),(7885,108,'2156724','2013-11-22 23:52:03',0,'queens\' n 0 x cond = [[]]	\r\n\n\r\n\nqueens\' n k x cond =\r\n\n     [(x,y) : xs | y<-[1..n], k > 0, xs<-queens\' n (k-1) (x+1) ((t,z) -> cond (t,z)  && ( not (y==z)) && not(abs (x-t) == abs(y-z))), \r\n\n           cond (x,y)]\r\n\nqueens n k = queens\' n k 1 (	 -> True) \n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7886,108,'2156724','2013-11-22 23:59:02',1,'queens\' n 0 x cond = [[]]	\r\n\r\n\r\n\r\nqueens\' n k x cond =\r\n\r\n     [(x,y) : xs | y<-[1..n],cond (x,y), xs<-queens\' n (k-1) (x+1) ((t,z) -> cond (t,z)  && ( not (y==z)) && not(abs (x-t) == abs(y-z)))] \r\n\r\n         \r\n\r\nqueens n k = queens\' n k 1 (	 -> True) \r\n','<br/>Тесты успешно пройдены!'),(7882,113,'artem.gomerman','2013-11-22 18:42:56',1,'sum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n','<br/>Тесты успешно пройдены!'),(7883,97,'artem.gomerman','2013-11-22 18:56:45',1,'--- OK, но можно проще. На самом деле счетчики вообще не нужны, достаточно стека незакрытых скобок.\r\ncheckBrackets str = checkBrackets\' 0 0 (head str) (tail str)\r\n\r\n\r\n\r\ncheckBrackets\' _ _ \'(\' (\']\':str) = False\r\n\r\ncheckBrackets\' _ _ \'[\' (\')\':str) = False\r\n\r\ncheckBrackets\' countS countC \'(\' (\')\':str) = if str == [] then countS == 0 && countC == 0 else checkBrackets\' countS countC (head str) (tail str)\r\n\r\ncheckBrackets\' countS countC \'[\' (\']\':str) = if str == [] then countS == 0 && countC == 0 else checkBrackets\' countS countC (head str) (tail str)\r\n\r\ncheckBrackets\' countS countC \'(\' str = if str == [] then False else checkBrackets\' countS (countC + 1) (head str) (tail str)\r\n\r\ncheckBrackets\' countS countC \'[\' str = if str == [] then False else checkBrackets\' (countS + 1) countC (head str) (tail str)\r\n\r\ncheckBrackets\' countS countC \')\' str = if str == [] then countC == 1 && countS == 0 else checkBrackets\' countS (countC - 1) (head str) (tail str)\r\n\r\ncheckBrackets\' countS countC \']\' str = if str == [] then countC == 0 && countS == 1 else checkBrackets\' (countS - 1) countC (head str) (tail str)\r\n','<br/>Тесты успешно пройдены!'),(7881,101,'artem.gomerman','2013-11-22 18:35:33',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nfoldExpr f e (Num n) = f (Num n)\r\n\r\nfoldExpr f e (X) = f X\r\n\r\nfoldExpr f e (Add expr1 expr2) = let\r\n\r\n	res1 = foldExpr f e expr1\r\n\r\n	res2 = foldExpr f e expr2\r\n\r\n	in f (Add res1 res2)\r\n\r\nfoldExpr f e (Mult expr1 expr2) = let\r\n\r\n	res1 = foldExpr f e expr1\r\n\r\n	res2 = foldExpr f e expr2\r\n\r\n	in f (Mult res1 res2)\r\n\r\n\r\n\r\nsimplify expr = foldExpr simplify\' (Num 0) expr\r\n\r\n\r\n\r\nsimplify\' (Num a) = Num a\r\n\r\nsimplify\' (X) = X\r\n\r\nsimplify\' (Mult expr1 (Num 0)) = Num 0\r\n\r\nsimplify\' (Mult (Num 0) expr2) = Num 0\r\n\r\nsimplify\' (Add expr1 expr2) = Add (simplify\' expr1) (simplify\' expr2)\r\n\r\nsimplify\' (Mult expr1 expr2) = Mult (simplify\' expr1) (simplify\' expr2)\r\n','<br/>Тесты успешно пройдены!'),(7880,98,'deripaska','2013-11-22 11:07:02',1,'{--\r\n\r\n	task 33-02\r\n\r\n*Доп.задача до 5.12 (задача с контрольной, для конкретного формата)*\r\n\r\n\r\n\r\nПусть у нас есть двоичное дерево, элементы которого – символы ‘a` и ‘b‘. Написать две функции:\r\n\r\n- функция toStr по дереву строит его представление в виде строки.\r\n\r\n- функция fromStr должна по этой строке восстанавливать исходное дерево.\r\n\r\n\r\n\r\nДополнительные условия: \r\n\r\n- Формат строки используйте, пожалуйста, как описано в слайдах 11 занятия. То есть:\r\n\r\n. Для непустого дерева формат:`n`, потом символ, потом строка для левого поддерева, потом строка для правого поддерева\r\n\r\n. Для пустого дерева: `e`\r\n\r\n- В функции toStr используйте, пожалуйста, прием описанный в слайдах 11 занятия для flatten. Т.е. используйте, пожалуйста, оператор композиции.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\ntoStr (Node ‘a‘ Empty (Node ‘b‘ Empty Empty) )\r\n\r\nРезультат должен быть равен строке \"naenbee\"\r\n\r\n\r\n\r\nfromStr \"naenbee\"\r\n\r\nРезультат должен быть равен (Node ‘a‘ Empty (Node ‘b‘ Empty Empty) )\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr_help Empty = (\"e\" ++) . id\r\n\r\ntoStr_help (Node c l r) = ((\"n\" ++ [c]) ++) . toStr_help l . toStr_help r\r\n\r\ntoStr t = toStr_help t \"\"\r\n\r\n\r\n\r\nfromStr_help (x:xs) \r\n\r\n	| x == \'e\' = (Empty, xs)\r\n\r\n	| x == \'n\' = (Node (head xs) left right, tail_2)\r\n\r\n	where\r\n\r\n		(left, tail_1) = fromStr_help (tail xs)\r\n\r\n		(right, tail_2) = fromStr_help tail_1\r\n\r\nfromStr xs = fst (fromStr_help xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7878,108,'1990147','2013-11-22 02:51:58',1,'queens n k = queens\' k n k (	->True)\r\n\r\nqueens\' 0 b _ _= [[]]\r\n\r\nqueens\' a b a\' cond = [(i,j):p| let i=a\'-a + 1, j<-[1..b],cond (i,j),\r\n\r\n                                  p<-queens\' (a-1) b  a\' (	-> cond t && snd t/=j && ((fst t - i)/=(snd t - j)) && ((-fst t + i)/=(snd t - j)))]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7879,106,'1990147','2013-11-22 04:39:35',2,'--- Алгоритм правильный, замечательно.\r\n--- Но Just и Nothing - это такой стандартный тип в Haskell\r\n--- Вы можете посмотреть слайды, там написано\r\n\r\ndata Unswerer = N | J Integer\r\n\r\n\r\n\r\ninstance Show Unswerer where\r\n\r\n             show (N) = \"Nothing\"\r\n\r\n             show (J x) = \"Just \" ++ show x\r\n\r\n\r\n\r\nfindMajor [] = (N)\r\n\r\nfindMajor (i:xs) = let x = finder i 1 xs\r\n\r\n                   in trymax x (i:xs) 0\r\n\r\n\r\n\r\nfinder x _ [] = x\r\n\r\nfinder now col (i:xs) = if (col == 0) then finder i 1 xs\r\n\r\n                        else if (i==now) then finder now (col+1) xs\r\n\r\n                             else finder now (col-1) xs\r\n\r\n\r\n\r\ntrymax x [] col= if (col>0) then (J x) else (N)\r\n\r\ntrymax x (i:xs) col= if (x==i) then trymax x xs (col+1) else trymax x xs (col-1)\r\n','<br/>Тесты успешно пройдены!'),(7876,107,'ilia','2013-11-22 02:32:05',1,'data LogExpr =\r\n\r\n	T | F | X |\r\n\r\n	And LogExpr LogExpr |\r\n\r\n	Or LogExpr LogExpr |\r\n\r\n	Not LogExpr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	T == T = True\r\n\r\n	F == F = True\r\n\r\n	X == X = True\r\n\r\n	And lel1 lel2 == ler = lel1 == ler && lel2 == ler\r\n\r\n	lel == And ler1 ler2 = lel == ler1 && lel == ler2\r\n\r\n	Or lel1 lel2 == ler = lel1 == ler || lel2 == ler\r\n\r\n	lel == Or ler1 ler2 = lel == ler1 || lel == ler2\r\n\r\n	Not lel == ler = not (lel == ler)\r\n\r\n	_ == _ = False\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (Or X (Not X) == T)\r\n\r\n	print (Or X (And X (Not X)) == T)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7877,108,'1990147','2013-11-22 02:49:08',0,'queens n k = queens\' k n k (	->True) (	->True)\r\n\nqueens\' 0 b _ _ _= [[]]\r\n\nqueens\' a b a\' conddiag condj = [(i,j):p| let i=a\'-a + 1, j<-[1..b], condj j,conddiag (i,j),\r\n\n                                  p<-queens\' (a-1) b  a\' (	-> conddiag t && ((fst t - i)/=(snd t - j)) && ((-fst t + i)/=(snd t - j))) (	->condj t && t/=j)]\r\n\n\n','<br/>Тесты успешно пройдены!'),(7875,107,'ilia','2013-11-22 02:30:26',0,'data LogExpr =\n\n	T | F | X |\n\n	And LogExpr LogExpr |\n\n	Or LogExpr LogExpr |\n\n	Not LogExpr\n\n	deriving Show\n\n\n\ninstance Eq LogExpr where\n\n	T == T = True\n\n	T == F = False\n\n	F == T = False\n\n	F == F = True\n\n	X == X = True\n\n	X == _ = False\n\n	_ == X = False\n\n	And lel1 lel2 == ler = lel1 == ler && lel2 == ler\n\n	lel == And ler1 ler2 = lel == ler1 && lel == ler2\n\n	Or lel1 lel2 == ler = lel1 == ler || lel2 == ler\n\n	lel == Or ler1 ler2 = lel == ler1 || lel == ler2\n\n	Not lel == ler = not (lel == ler)\n\n\n\nmain = do\n\n	print (Or X (Not X) == T)\n\n	print (Or X (And X (Not X)) == T)\n\n\n','<br/>Тесты успешно пройдены!'),(7874,108,'1990147','2013-11-22 02:11:17',0,'queens k n = queens\' n k n (	->True)\r\n\nqueens\' 0 b _ _= [[]]\r\n\nqueens\' a b a\' cond = [(i,j):p| i<-[1..a\'], j<-[1..b], \r\n\n                                  p<-queens\' (a-1) b  a\' (	-> cond t && i<fst t && j/=snd t \r\n\n                                                            && ((fst t - i)/=(snd t - j)) \r\n\n                                                            && ((-fst t + i)/=(snd t - j))),\r\n\n                       cond (i,j)]\r\n\n\n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7873,108,'1990147','2013-11-22 02:01:22',0,'queens m n = queens\' m n m (	->True)\r\n\nqueens\' 0 n _ _= [[]]\r\n\nqueens\' m n m\' cond = [(i,j):k| i<-[1..m\'], j<-[1..n], \r\n\n                                  k<-queens\' (m-1) n  m\' (	-> cond t && i<fst t && j/=snd t \r\n\n                                                            && ((fst t - i)/=(snd t - j)) \r\n\n                                                            && ((-fst t + i)/=(snd t - j))),\r\n\n                       cond (i,j)]\r\n\n\n','Выражение имеет неправильное значение: length(queens 3 2)'),(7872,107,'romos2007','2013-11-22 01:08:29',1,'{--\r\n\r\nЗадача 33-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata LogExpr = 	And LogExpr LogExpr |\r\n\r\n				Or LogExpr LogExpr |\r\n\r\n				Not LogExpr |\r\n\r\n				T | F |\r\n\r\n				X\r\n\r\n\r\n\r\neval (And e1 e2) x = (eval e1 x) && (eval e2 x)\r\n\r\neval (Or e1 e2) x = (eval e1 x) || (eval e2 x)\r\n\r\neval (Not e1) x = not (eval e1 x)\r\n\r\neval T x = True\r\n\r\neval F x = False\r\n\r\neval X x = x\r\n\r\n\r\n\r\n{- 	Проверяем равенство обеих частей, как функций.\r\n\r\n	Т.е. на каждом значении из области определения.\r\n\r\n-}\r\n\r\ninstance Eq LogExpr where\r\n\r\n	e1 == e2 = (eval e1 True == eval e2 True) && (eval e1 False == eval e2 False)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7871,98,'ilia','2013-11-22 01:07:05',2,'--- Вообще замечательно, но у вас на выполняется дополнительное условме:\r\n--- \"В функции toStr используйте, пожалуйста, прием описанный в слайдах 11 занятия для flatten. \r\n--- Т.е. используйте, пожалуйста, оператор композиции\"\r\n--- Переделайте так, пожауйста.\r\n \r\ndata Tree =\r\n\r\n	Empty |\r\n\r\n	Node Char Tree Tree\r\n\r\n	deriving Show\r\n\r\n\r\n\r\ntoStr Empty = \"e\"\r\n\r\ntoStr (Node v l r) = \'n\' : v : (toStr l) ++ (toStr r)\r\n\r\n\r\n\r\nfromStr s = fst (fromStr\' s)\r\n\r\nfromStr\' (c:s)\r\n\r\n	| c == \'e\' = (Empty, s)\r\n\r\n	| c == \'n\' = let\r\n\r\n			v = head s\r\n\r\n			l = fromStr\' (tail s)\r\n\r\n			r = fromStr\' (snd l)\r\n\r\n		in\r\n\r\n			(Node (head s) (fst l) (fst r), snd r)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (toStr (Node \'a\' Empty (Node \'b\' Empty Empty)))\r\n\r\n	print (fromStr \"naenbee\")\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7869,98,'romos2007','2013-11-22 00:27:11',1,'{--\r\n\r\nЗадача 33-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\ndata Tree = Empty |\r\n\r\n			Node Char Tree Tree\r\n\r\n			deriving Show\r\n\r\n\r\n\r\ntoStr e = f e []\r\n\r\n\r\n\r\nfrmstr (n:xs)\r\n\r\n	|n == \'n\' = \r\n\r\n		let\r\n\r\n			(l,xs1)=frmstr (tail xs)\r\n\r\n			(r,xs2)=frmstr xs1\r\n\r\n		in\r\n\r\n			(Node (head xs) l r, xs2)\r\n\r\n	|otherwise = (Empty,xs)\r\n\r\n\r\n\r\nfromStr str = fst (frmstr str)\r\n\r\n\r\n\r\n\r\n\r\nf (Empty) = (\'e\':)\r\n\r\nf (Node x l r) = (\'n\':).(x:).(f l).(f r)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7870,118,'ilia','2013-11-22 00:46:05',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf = find (>3) >>> find (>3)\r\n\r\n\r\n\r\ne1 >>> e2 = x -> e2 (snd (e1 x))\r\n\r\n\r\n\r\nmain = print (f [1, 3, 5, 2, 20, 25, 2])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7868,115,'ilia','2013-11-22 00:11:02',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf m = let\r\n\r\n		r = find (<5) m ++ find (>10) m ++ find (/=7) m\r\n\r\n	in\r\n\r\n		if length r == 3 then\r\n\r\n			[ sum r ]\r\n\r\n		else\r\n\r\n			[ ]\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (f [7, 6, 4, 3, 20, 15, 9])\r\n\r\n	print (f [7, 6, 4, 3, 9])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7867,114,'ilia','2013-11-22 00:02:19',1,'triangle1 n = [1..n] >>= \r\ni -> [1..ni] >>= \r\nii -> return (nii * nii)\r\n\r\ntriangle2 n = do\r\n\r\n		ni <- [1..n]\r\n\r\n		nii <- [1..ni]\r\n\r\n		[ nii * nii ]\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (triangle1 3)\r\n\r\n	print (triangle2 3)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7865,111,'ilia','2013-11-21 23:18:33',1,'data Expr = \r\n\r\n		Num Integer |\r\n\r\n		Var String |\r\n\r\n		Add Expr Expr |\r\n\r\n		Mult Expr Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Num n) _ = n\r\n\r\neval (Var v) defs = snd (head (filter (d -> fst d == v) defs))\r\n\r\neval (Add e1 e2) defs = eval e1 defs + eval e2 defs\r\n\r\neval (Mult e1 e2) defs = eval e1 defs * eval e2 defs\r\n\r\n\r\n\r\nmain = print (eval (Add (Var \"x\") (Mult (Var \"y\") (Num 3))) [(\"x\", 5), (\"y\", 8)])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7866,113,'romos2007','2013-11-21 23:26:03',1,'{--\r\n\r\nЗадача 32-6\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nsum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+x))\r\n\r\n\r\n\r\n\r\n\r\n--sum_cps\' [] f = f 0\r\n\r\n--sum_cps\' (x:xs) f = f (sum_cps xs (+x))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7864,114,'romos2007','2013-11-21 23:15:46',1,'--- Все правильно, но в triangle2 достаточно одного do с двумя\r\n--- генераторами\r\n--- (Я явно не говорил, что можно писать много генераторов, но вроде бы это видно из примера, который был в слайдах)\r\n--- Те можно\r\n--- triangle2 n = \r\n---	do\r\n---  	  i <- [1..n]\r\n---	  i1 <- [1..i]\r\n---	  [i1*i1]\r\n\r\n\r\n\r\n-- Извините, не дочитал условие.\r\n\r\n-- Прочитал только *Простое упражнение на использование >>= и do нотации*,\r\n\r\n-- и сразу стало понятно, как делать :-)\r\n\r\n-- Надеюсь, сейчас я уложился в условие.\r\n\r\n\r\n\r\n{--\r\n\r\nЗадача 32-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ntriangle1 n = [1..n] >>= i -> ([1..i] >>= i1 -> return (i1*i1))\r\n\r\ntriangle1\' n = [1..n] >>= i -> ([1..i] >>= i1 -> [i1*i1])\r\n\r\n\r\n\r\ntriangle2 n = \r\n\r\n	do\r\n\r\n		i <- [1..n]\r\n\r\n		do\r\n\r\n			i1 <- [1..i]\r\n\r\n			[i1*i1]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7857,115,'Artur','2013-11-21 20:55:07',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\ng [] _ = []\r\n\r\ng _ [] = []\r\n\r\ng [x] [y] = [x+y]\r\n\r\n\r\n\r\nf xs = (find  (< 5)  xs)`g` (find (> 10) xs) `g`(find (/= 7) xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7858,114,'1170660','2013-11-21 21:05:21',1,'--- Засчитано, но вообще triangle2 пишется _гораздо_ проще\r\nconcat1 xss = xss >>= id\r\n\r\n\r\n\r\ntriangle1 n = ([1..n] >>= i -> return ([1..i] >>= x ->[x*x] ))>>=id\r\n\r\ntriangle2 n =\r\n\r\n    concat1 (do i <- [1..n]\r\n\r\n                (return ([1..i] >>= y -> [y*y])))\r\n','<br/>Тесты успешно пройдены!'),(7859,118,'Artur','2013-11-21 21:12:03',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nf >>> g = xs -> f (snd (g xs))\r\n\r\n\r\n\r\n--h = find (>3) >>> find (>3) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7860,115,'1170660','2013-11-21 21:16:06',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let list = concat [find (<5) xs, find (>10) xs, find (/=7) xs] in if length list == 3 then [sum list] else []\r\n','<br/>Тесты успешно пройдены!'),(7861,111,'Artur','2013-11-21 21:23:05',1,'find cond (x:xs) = if cond x then (snd x) else find cond xs\r\n\r\n\r\n\r\n\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving (Show,Eq)\r\n\r\n	\r\n\r\n	\r\n\r\neval (Num i) xs = i\r\n\r\neval (Var s ) xs = find ((var,val)-> var == s) xs\r\n\r\neval (Add  expr1 expr2) xs = (eval expr1 xs) + (eval expr2 xs)\r\n\r\neval (Mult expr1 expr2) xs = (eval expr1 xs) * (eval expr2 xs)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7862,101,'Artur','2013-11-21 21:32:26',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving (Show,Eq)\r\n\r\n	\r\n\r\neval (Num i) var = i\r\n\r\neval (X ) var = var\r\n\r\neval (Add  expr1 expr2) var = (eval expr1 var) + (eval expr2 var)\r\n\r\neval (Mult expr1 expr2) var = (eval expr1 var) * (eval expr1 var)\r\n\r\n\r\n\r\nsimplify X = X\r\n\r\nsimplify (Num i) = Num i\r\n\r\nsimplify (Add expr1 expr2) = Add (simplify expr1) (simplify expr2)\r\n\r\nsimplify (Mult expr1 expr2) = let s1 = simplify expr1 \r\n\r\n                                  s2 = simplify expr2\r\n\r\n							in if (s1 == (Num 0) || (s2 == (Num 0))) then (Num 0)\r\n\r\n								else Mult s1 s2\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7863,101,'ilia','2013-11-21 22:34:48',1,'data Expr = \r\n\r\n		Num Integer |\r\n\r\n		X |\r\n\r\n		Add Expr Expr |\r\n\r\n		Mult Expr Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\nis_zero (Num n) = n == 0\r\n\r\nis_zero _ = False\r\n\r\nsimplify\' (Add e1s e2s)\r\n\r\n	| is_zero e1s = e2s\r\n\r\n	| is_zero e2s = e1s\r\n\r\n	| otherwise = Add e1s e2s\r\n\r\nsimplify\' (Mult e1s e2s)\r\n\r\n	| is_zero e1s = Num 0\r\n\r\n	| is_zero e2s = Num 0\r\n\r\n	| otherwise = Mult e1s e2s\r\n\r\n\r\n\r\nsimplify (Num n) = Num n\r\n\r\nsimplify X = X\r\n\r\nsimplify (Add e1 e2) = simplify\' (Add (simplify e1) (simplify e2))\r\n\r\nsimplify (Mult e1 e2) = simplify\' (Mult (simplify e1) (simplify e2))\r\n\r\n\r\n\r\nmain = print (simplify (Add (Mult X (Num 0)) X))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7856,98,'115753099','2013-11-21 16:07:01',1,'data Tree = Node Char Tree Tree | Empty\r\n	deriving Show\r\n\r\ntoStr xs = toStr\' xs []\r\ntoStr\' (Empty) = (\'e\':)\r\ntoStr\' (Node x left right) = (\'n\':) . (x:) . (toStr\' left) . (toStr\' right)\r\n\r\nfromStr (\'n\':x:xs) =\r\n	Node x t1 t2\r\n	where\r\n		(t1, xs\') = getFirstNode xs\r\n		(t2, _) = getFirstNode xs\'\r\nfromStr xs = Empty\r\ngetFirstNode (\'e\':xs) =\r\n	(Empty, xs)\r\ngetFirstNode (\'e\':xs) =\r\n	(Empty, xs)\r\ngetFirstNode (\'n\':x:xs) =\r\n	(Node x t1 t2, xs\'\')\r\n	where\r\n		(t1, xs\') = getFirstNode xs\r\n		(t2, xs\'\') = getFirstNode xs\'\r\ngetFirstNode xs = (Empty, [])','<br/>Тесты успешно пройдены!'),(7855,98,'115753099','2013-11-21 16:01:23',0,'data Tree = Node Char Tree Tree | Empty\r\n	deriving Show\r\n\r\ntoStr (Empty) = (\'e\':)\r\ntoStr (Node x left right) = (\'n\':) . (x:) . (toStr left) . (toStr right)\r\n\r\nfromStr (\'n\':x:xs) =\r\n	Node x t1 t2\r\n	where\r\n		(t1, xs\') = getFirstNode xs\r\n		(t2, _) = getFirstNode xs\'\r\nfromStr xs = Empty\r\ngetFirstNode (\'e\':xs) =\r\n	(Empty, xs)\r\ngetFirstNode (\'e\':xs) =\r\n	(Empty, xs)\r\ngetFirstNode (\'n\':x:xs) =\r\n	(Node x t1 t2, xs\'\')\r\n	where\r\n		(t1, xs\') = getFirstNode xs\r\n		(t2, xs\'\') = getFirstNode xs\'\r\ngetFirstNode xs = (Empty, [])\r\n','Не удалось вычислить выражение \"fromStr(toStr (Node \'a\' (Node \'b\' Empty Empty) Empty))\", проверьте правильность синтаксиса'),(7854,107,'115753099','2013-11-21 16:01:13',1,'data LogExpr = X | And LogExpr LogExpr | Or LogExpr LogExpr  | Not LogExpr | T | F\r\n	deriving Show\r\n\r\nnil (T) (T) = True\r\nnil (F) (F) = True\r\nnil _ _ = False\r\n\r\ninstance Eq LogExpr where\r\n	ex1 == ex2 = eq ex1 ex2\r\n\r\neq ex1 ex2 =\r\n	nil (simplify ex1 True)	(simplify ex2 True) &&\r\n	nil (simplify ex1 False) (simplify ex2 False)\r\nsimplify (T) _ = T\r\nsimplify (F) _ = F\r\nsimplify (X) True = T\r\nsimplify (X) False = F\r\nsimplify (Or T _) _ = T\r\nsimplify (Or F ex) b = simplify ex b\r\nsimplify (Or ex F) b = simplify ex b\r\nsimplify (Or ex1 ex2) b = simplify (Or (simplify ex1 b) (simplify ex2 b)) b\r\nsimplify (And ex T) b = simplify ex b\r\nsimplify (And T ex) b = simplify ex b\r\nsimplify (And F ex) _ = F\r\nsimplify (And ex F) _ = F\r\nsimplify (And ex1 ex2) b = simplify (And (simplify ex1 b) (simplify ex2 b)) b\r\nsimplify (Not T) _ = F\r\nsimplify (Not F) _ = T\r\nsimplify (Not ex) b = simplify (Not (simplify ex b)) b\r\n','<br/>Тесты успешно пройдены!'),(7853,113,'deripaska','2013-11-21 15:08:07',1,'{--\r\n\r\n	task 32-06\r\n\r\nОпишите функцию sum_cps которая ищет сумму элементов данного списка, используя continuation-passing style.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nsum_cps [1,2,3] id \r\n\r\nРезультат дб равен 6\r\n\r\n\r\n\r\nsum_cps [1,2,3] (^2)\r\n\r\nРезультат дб равен (1+2+3)^2=36\r\n\r\n--}\r\n\r\n\r\n\r\nsum_cps [] f = f 0\r\n\r\nsum_cps (x:xs) f = sum_cps xs (f.(+ x))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7852,107,'115753099','2013-11-21 15:07:09',0,'data LogExpr = X | And LogExpr LogExpr | Or LogExpr LogExpr  | Not LogExpr | T | F\r\n	deriving Show\r\n\r\nnil (T) (T) = True\r\nnil (F) (F) = True\r\nnil _ _ = False\r\n\r\ninstance Eq LogExpr where\r\n	ex1 == ex2 = eq ex1 ex2\r\n\r\neq ex1 ex2 =\r\n	nil (simplify ex1 True)	(simplify ex2 True) &&\r\n	nil (simplify ex1 False) (simplify ex2 False)\r\nsimplify (T) _ = T\r\nsimplify (F) _ = F\r\nsimplify (X) True = T\r\nsimplify (X) False = F\r\nsimplify (Or T _) _ = T\r\nsimplify (Or F ex) b = simplify ex b\r\nsimplify (Or ex F) b = simplify ex b\r\nsimplify (Or ex1 ex2) b = simplify (Or (simplify ex1 b) (simplify ex2 b)) b\r\nsimplify (And ex T) b = simplify ex b\r\nsimplify (And T ex) b = simplify ex b\r\nsimplify (And F ex) _ = F\r\nsimplify (And ex F) _ = F\r\nsimplify (And ex1 ex2) b = simplify (And (simplify ex1 b) (simplify ex2 b)) b\r\nsimplify (Not T) _ = F\r\nsimplify (Not F) _ = T\r\nsimplify (Not ex) b = simplify (Not (simplify ex b)) b','<br/>Тесты успешно пройдены!'),(7851,107,'anlun','2013-11-21 14:30:57',1,'data LogExp =\r\n	T | F | X | And LogExp LogExp | Or LogExp LogExp | Not LogExp\r\n\r\neval :: LogExp -> Bool -> Bool\r\neval T _ = True\r\neval F _ = False\r\neval X v = v\r\neval (And e1 e2) v = (&&) (eval e1 v) $ eval e2 v\r\neval (Or  e1 e2) v = (||) (eval e1 v) $ eval e2 v\r\neval (Not e1) v = not $ eval e1 v\r\n\r\ninstance Eq LogExp where\r\n	(==) e1 e2 = (&&) (e1f == e2f) $ e1t == e2t\r\n		where\r\n			e1f = eval e1 False\r\n			e1t = eval e1 True\r\n			e2f = eval e2 False\r\n			e2t = eval e2 True','<br/>Тесты успешно пройдены!'),(7848,113,'115753099','2013-11-21 13:01:00',1,'sum_cps [] f 	 = f 0\r\nsum_cps (x:xs) f = sum_cps (xs) (f . (+x))','<br/>Тесты успешно пройдены!'),(7849,113,'anlun','2013-11-21 14:12:05',1,'sum_cps :: Num b => [b] -> (b -> a) -> a\r\nsum_cps [] f = f 0\r\nsum_cps (x:xs) f = sum_cps xs (f . (x +))','<br/>Тесты успешно пройдены!'),(7850,114,'anlun','2013-11-21 14:23:01',1,'triangle1 n = [1..n] >>= (x -> map (^ 2) [1..x])\r\n-- with return \r\n--triangle1 n = [1..n] >>= (x -> [1..n] >>= (y -> if x <= y then return x else fail \"\"))\r\n   --- Засчитано, но зачем так сложно?? Просто \r\n   --- [1..n] >>= \\x -> [1..n] >>= \\y -> y*y\r\n\r\ntriangle2 n =\r\n	do\r\n		x <- [1..n]\r\n		map (^ 2) [1..x]\r\n','<br/>Тесты успешно пройдены!'),(7847,109,'1170660','2013-11-21 12:06:41',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n \r\nnamespace task_28_1\r\n{\r\n	class Task\r\n	{\r\n		private static void AllDiffListsWrite(int n, int k, Func<int, bool> isInSet, Action print)\r\n		{\r\n			if (k == 0)\r\n			{\r\n				print();\r\n				Console.WriteLine();\r\n				return;\r\n			}\r\n \r\n			for (int i = 1; i < (n + 1); i++)\r\n			{\r\n				if (!isInSet(i))\r\n				{\r\n					AllDiffListsWrite(n, k - 1, x => isInSet(x) || x == i, () => { print(); Console.Write(\"{0} \", i); });\r\n				}\r\n			}\r\n		}\r\n \r\n		public static void AllDiffLists(int n, int k) \r\n		{\r\n			AllDiffListsWrite(n, k, x => false, () => {});\r\n		}\r\n \r\n		static void Main(string[] args)\r\n		{\r\n			AllDiffLists(3, 2);\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(7845,111,'romos2007','2013-11-21 00:43:13',1,'{--\r\n\r\nЗадача 32-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = Var String |\r\n\r\n			Num Integer |\r\n\r\n			Add Expr Expr |\r\n\r\n			Mult Expr Expr\r\n\r\n			deriving (Show, Eq)\r\n\r\n\r\n\r\nget v [] = 0\r\n\r\nget v ((var, val):variables) = if v == var\r\n\r\n							  then val\r\n\r\n							  else get v variables\r\n\r\n\r\n\r\neval (Mult e1 e2) variables = (eval e1 variables) * (eval e2 variables)\r\n\r\neval (Add e1 e2) variables = (eval e1 variables) + (eval e2 variables)\r\n\r\neval (Num i) variables = i\r\n\r\neval (Var v) variables = get v variables\r\n\r\n\r\n\r\n--diff X = Num 1\r\n\r\n--diff (Num i) = Num 0\r\n\r\n--diff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\n--diff (Mult e1 e2) = Add (Mult (diff e1) (e2)) (Mult (e1) (diff e2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7846,101,'romos2007','2013-11-21 00:43:33',1,'{--\r\n\r\nЗадача 32-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = X |\r\n\r\n			Num Integer |\r\n\r\n			Add Expr Expr |\r\n\r\n			Mult Expr Expr\r\n\r\n			deriving (Show, Eq)\r\n\r\n\r\n\r\nsimplify (Mult e1 e2) = let\r\n\r\n							simple1 = simplify e1\r\n\r\n							simple2 = simplify e2\r\n\r\n						in\r\n\r\n							if simple1 == Num 0 || simple2 == Num 0\r\n\r\n							then Num 0\r\n\r\n							else Mult simple1 simple2\r\n\r\nsimplify (Add e1 e2) = Add (simplify e1) (simplify e2)\r\n\r\nsimplify (Num i)= (Num i)\r\n\r\nsimplify X = X\r\n\r\n\r\n\r\n--eval (Mult e1 e2) x = (eval e1 x) * (eval e2 x)\r\n\r\n--eval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\n\r\n--eval (Num i) x= i\r\n\r\n--eval X x = x\r\n\r\n\r\n\r\n--diff X = Num 1\r\n\r\n--diff (Num i) = Num 0\r\n\r\n--diff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\n--diff (Mult e1 e2) = Add (Mult (diff e1) (e2)) (Mult (e1) (diff e2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7843,115,'romos2007','2013-11-21 00:41:43',1,'{--\r\n\r\nЗадача 32-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\nfind cond [] = []\r\n\r\nfind cond (x:xs) = 	if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let\r\n\r\n			result = ([(<5),(>10),(/=7)] >>= i -> find i xs)\r\n\r\n	   in\r\n\r\n			if length result == 3\r\n\r\n			then [sum result]\r\n\r\n			else []\r\n','<br/>Тесты успешно пройдены!'),(7844,118,'romos2007','2013-11-21 00:42:00',1,'{--\r\n\r\nЗадача 32-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>) find1 find2 xs = find2 (snd (find1 xs))\r\n\r\n\r\n\r\n-- f = find (>3) >>> find (>3) \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7841,114,'romos2007','2013-11-21 00:40:30',0,'{--\r\n\nЗадача 32-1\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\ntriangle1 n = [1..n] >>= i -> map (	->t*t) [1..i]\r\n\n\r\n\ntriangle2 n = \r\n\n	do\r\n\n		i <- [1..n]\r\n\n		map (	->t*t*t) [1..i]\n','Выражение имеет неправильное значение: triangle2 3'),(7842,114,'romos2007','2013-11-21 00:41:17',2,'--- Не совсем по условию. В первой задаче по условию надо использовать return. Во второй задаче\r\n--- на самом деле подразумавалось, что никакими функциями кроме [n..m] return и арифметики использовать нельзя.\r\n--- Исправьте пожалуйста triangle1 f если получиться triangle2 ижменить (это просто) то вообще будет замечательно.\r\n{--\r\n\r\nЗадача 32-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ntriangle1 n = [1..n] >>= i -> map (	->t*t) [1..i]\r\n\r\n\r\n\r\ntriangle2 n = \r\n\r\n	do\r\n\r\n		i <- [1..n]\r\n\r\n		map (	->t*t) [1..i]\r\n','<br/>Тесты успешно пройдены!'),(7840,101,'115753099','2013-11-21 00:09:09',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n	deriving Show\r\nnil (Num 0) = True\r\nnil expr 	= False\r\n\r\nsimplify (Mult (Num 0) _) = Num 0\r\nsimplify (Mult _ (Num 0)) = Num 0\r\nsimplify (Mult ex1 ex2)\r\n	| nil (simplify ex1) ||\r\n	  nil (simplify ex2)\r\n	  = Num 0\r\n	| otherwise = Mult (simplify ex1) (simplify ex2)\r\nsimplify (Add ex1 ex2) =\r\n	Add (simplify ex1) (simplify ex2)\r\nsimplify expr = expr','<br/>Тесты успешно пройдены!'),(7836,114,'115753099','2013-11-21 00:07:43',1,'triangle1 n =\r\n	[ [1..x] | x <- [1..n] ] >>= z -> z >>=  y -> return (y * y)\r\n\r\ntriangle2 n =\r\n	do	z <- [ [1..x] | x <- [1..n] ]\r\n		y <- z \r\n		return (y * y)','<br/>Тесты успешно пройдены!'),(7837,115,'115753099','2013-11-21 00:07:56',1,'find cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf xs\r\n	| length resList == 3	= [sum resList]\r\n	| otherwise				= []\r\n	where\r\n		resList = [(< 5), (> 10), (/= 7)] >>= func -> find func xs\r\n --- А, просто интересно, еще один человек мне присылал такое же решение, мне кажется оно довольно оригинальное.\r\n --- Вы обсуждали его с друзьями? то просто из любопытиства, обсуждать решения в общем не запрещается.','<br/>Тесты успешно пройдены!'),(7838,118,'115753099','2013-11-21 00:08:41',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf1 >>> g =\r\n	g . ((x, xs) -> xs) . f1\r\n\r\nf = find (>3) >>> find (>3)\r\n','<br/>Тесты успешно пройдены!'),(7839,111,'115753099','2013-11-21 00:08:56',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n		deriving Show\r\n\r\neval (Num a) _ = a\r\neval (Var x) xs\r\n	| null nameList	= 0\r\n	| otherwise		= eq\r\n	where\r\n		nameList = filter ((name, eq) -> name == x) xs\r\n		(_, eq) = head nameList\r\neval (Add ex1 ex2) xs = eval ex1 xs + eval ex2 xs\r\neval (Mult ex1 ex2) xs = eval ex1 xs * eval ex2 xs','<br/>Тесты успешно пройдены!'),(7835,94,'ip','2013-11-20 22:56:29',2,'--- Ну да, у вас все=так неправильно считаются символы\r\n--- например я ввожу Series (Series (Parallel (Parallel (Simple 1) (Simple 2)) (Simple 3)) (Simple 5))(Simple 6)\r\n--- и в ответе провода, которые идут после схем стоят не на воих местах. Если скопировато вывод в редактор\r\n--- и поставить там моноширинный шрифт тип Courier то видно, что гое где лишние пробелы, а в нижнем ряду не хватает\r\n--- несколько символов ==\r\n--- В общем я вам засчитаю ха эту задачу 1 балл (просто запишу себе в тетрадке), потому что все-таки не совсем то.\r\n--- Но если хотите, вы можете попроьовать ее исправить. Время практически не ограниено. раздирать ее мы все равно не будем..\r\n\r\n\r\n{-\r\n\r\nЕсли не изображается, то http://rghost.net/50316291\r\n\r\n\r\n\r\nПро show не знал, спасибо.Я, честно говоря, неочень понял, что не так во второй строке,разве что\r\n\r\nв целом все, что я вывожу неочень понятно и не совмещаются символы,что я не знаю как исправить((\r\n\r\nНо я добавил увеличенную ширину при параллельном соединении,должно быть понятнее\r\n\r\n\r\n\r\n.(Double) - резистор\r\n\r\n= ||   // - проводник\r\n\r\n\r\n\r\nПримеры:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n (Parallel               (Simple 4.23) (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     )\r\n\r\n\r\n\r\n (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3.33333))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n ( Parallel (Series     (Parallel               (Parallel ((Series (Simple 1.234) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2.342))) (Simple 3)))   )  (Simple 1))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2.34))) (Simple 3))     (Parallel ((Series (Simple 133) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel (Series   (Series  (Series  (Series  (Series  (Series  (Simple 1) (Simple 134) ) (Simple 1) ) (Simple 1) ) (Simple 13) ) (Simple 1) ) (Simple 1) )\r\n\r\n ((Series (Simple 1) (Simple 2))) ))   )\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndata Scheme = Simple Double |\r\n\r\n     Series Scheme Scheme |\r\n\r\n     Parallel Scheme Scheme\r\n\r\n\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n show a = printScheme2 (buildScheme a)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--вспомогательная структура\r\n\r\ndata Dt = Triple [String] Integer Integer\r\n\r\n\r\n\r\n--печатает схему\r\n\r\nprintScheme x = putStr (printScheme2 (buildScheme x) )\r\n\r\n\r\n\r\n--вспомогательная функция\r\n\r\nprintScheme2 [] = \"\"\r\n\r\nprintScheme2 (x:xs) = x ++ [\'\r\n\'] ++ (printScheme2 xs)\r\n\r\n\r\n\r\n--строит список строк рисунка по схеме\r\n\r\nbuildScheme x = let\r\n\r\n                Triple xs w h = electric x\r\n\r\n                in xs\r\n\r\n                 \r\n\r\n\r\n\r\nlOfInt i k = let\r\n\r\n             a = div i 10\r\n\r\n             in\r\n\r\n             if (a==0)\r\n\r\n             then (k+1)\r\n\r\n             else lOfInt a (k+1)         \r\n\r\n\r\n\r\n\r\n\r\nas i = toInteger (length (show i))\r\n\r\n\r\n\r\n--разбирает схему на каждом шаге составив \'рисунок\' снизу вверх\r\n\r\nelectric (Simple i) = Triple [\".(\" ++ (show i) ++ \")\"] ((as i)+1) 1\r\n\r\nelectric (Series x y) = let\r\n\r\n                        Triple xs w h = electric x\r\n\r\n                        Triple ys w2 h2 =  electric y\r\n\r\n                        in Triple (handleS w h w2 h2 xs ys) (w + w2 +1) (max h h2)\r\n\r\nelectric (Parallel x y) = let\r\n\r\n                          Triple xs w h = electric x\r\n\r\n                          Triple ys w2 h2 =  electric y\r\n\r\n                          in Triple (handleP w h w2 h2 xs ys) ((max w w2) + 2+2) (h + h2 + 1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--случай последовательного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\r\n\r\nhandleS w h w2 h2 xs ys = let\r\n\r\n		          \r\n\r\n                          hp = max h h2\r\n\r\n                          hdiff = div (abs(h - h2)) 2\r\n\r\n                          hshift = mod (abs(h - h2)) 2\r\n\r\n			  middle = (mod hp 2)  + (div hp 2)\r\n\r\n			  in\r\n\r\n                          if (h<h2)\r\n\r\n                          then concateBlocks (colums xs hdiff w hshift) ys middle [] 1 \r\n\r\n                          else concateBlocks xs (colums ys hdiff w2 hshift) middle [] 1 \r\n\r\n\r\n\r\n--склеивает два блока обеспечивая между ними промежуток\r\n\r\nconcateBlocks [] [] _ out i  = out\r\n\r\nconcateBlocks (x:xs) [] middle out i  = if (i == middle)\r\n\r\n       				        then concateBlocks xs [] middle (out ++ [(x ++ \"=\")]) (i+1) \r\n\r\n					else concateBlocks xs [] middle (out ++ [(x ++ \"  \")]) (i+1) \r\n\r\nconcateBlocks (x:xs) (y:ys) middle out i  = if (i == middle)\r\n\r\n     				  	    then concateBlocks xs ys middle (out ++ [(x ++ \"=\" ++ y)]) (i+1) \r\n\r\n					    else concateBlocks xs ys middle (out ++ [(x ++ \"  \" ++ y)]) (i+1) \r\n\r\n\r\n\r\n--добирает высоту меньшего из блоков\r\n\r\ncolums xs d w 1 = colums ([createStr \"  \" w] ++ xs) d w 0\r\n\r\ncolums xs 0 _ _ = xs\r\n\r\ncolums xs d w s = let\r\n\r\n                  str = createStr \"  \" w\r\n\r\n                  in\r\n\r\n                  colums ([str] ++ xs ++ [str]) (d-1) w s\r\n\r\n\r\n\r\n--вспомогательная функция\r\n\r\ncreateStr a 0 = \"\"\r\n\r\ncreateStr a 1 = a\r\n\r\ncreateStr a w = a ++ (createStr a (w-1)) \r\n\r\n\r\n\r\n\r\n\r\n--случай параллельного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\r\n\r\nhandleP w h w2 h2 xs ys = let\r\n\r\n		          wp = (max w w2) + 2+2\r\n\r\n                          hp = h + h2 + 1\r\n\r\n                          wdiff = (div (abs(w - w2)) 2 ) + 1\r\n\r\n                          wshift = (mod (abs(w - w2)) 2 )\r\n\r\n			  middle = (mod h 2)  + (div h 2)\r\n\r\n			  middle2 = (mod h2 2)  + (div h2 2)\r\n\r\n                          str = createStr \"  \" (wp-2)\r\n\r\n			  in\r\n\r\n                          if (w<w2)\r\n\r\n                          --склейка рисунков \'поверху\'\r\n\r\n                          then if (wshift==1)\r\n\r\n                               then let xs2 = concateBlocks xs [] middle [] 1\r\n\r\n                                    in (strings xs2 wdiff middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys 1 middle2 1 [])\r\n\r\n                               else (strings xs wdiff middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys 1 middle2 1 [])\r\n\r\n\r\n\r\n\r\n\r\n                          else if (wshift==1)\r\n\r\n                               then let ys2 = concateBlocks ys [] middle2 [] 1\r\n\r\n                                    in (strings xs 1 middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys2 wdiff middle2 1 [])\r\n\r\n                               else (strings xs 1 middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys wdiff middle2 1 [])\r\n\r\n\r\n\r\n--рисует вертикальные части \'проводника\' для верхнего блока (левого аргумента)\r\n\r\nstrings [] _ _ _ out = out\r\n\r\nstrings (x:xs) d middle i out = if (i<middle)\r\n\r\n                        	then let\r\n\r\n                             	     str = createStr \"  \" (d+1)\r\n\r\n                             	     in\r\n\r\n                             	     strings xs d middle (i+1) (out ++ [(str ++ x ++ str)])\r\n\r\n                                else if (i == middle)\r\n\r\n                                     then let\r\n\r\n                                          str = createStr \"=\" (d-1)\r\n\r\n                                          in\r\n\r\n                                          strings xs d middle (i+1) (out ++ [(\"//\" ++ str ++ \"=\" ++ x ++ \"=\" ++ str ++ \"\\\")])\r\n\r\n                                     else let\r\n\r\n                                          str = createStr \"  \" ((d-1)+1)\r\n\r\n                                          in\r\n\r\n                                          strings xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\r\n\r\n\r\n\r\n--рисует вертикальные части \'проводника\' для нижнего блока (правого аргумента)\r\n\r\nstrings2 [] _ _ _ out = out\r\n\r\nstrings2 (x:xs) d middle i out = if (i>middle)\r\n\r\n                              	 then let\r\n\r\n                             	      str = createStr \"  \"  (d+1)\r\n\r\n                             	      in\r\n\r\n                             	      strings2 xs d middle (i+1) (out ++ [(str ++ x ++ str)])\r\n\r\n                                 else if (i == middle)\r\n\r\n                                      then let\r\n\r\n                                           str = createStr \"=\" (d-1)\r\n\r\n                                           in\r\n\r\n                                           strings2 xs d middle (i+1) (out ++ [(\"\\\" ++ str ++ \"=\" ++ x ++ \"=\" ++ str ++ \"//\")])\r\n\r\n                                      else let\r\n\r\n                                           str = createStr \"  \" ((d-1)+1)\r\n\r\n                                           in\r\n\r\n                                           strings2 xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7834,114,'Artur','2013-11-20 22:55:35',1,'\r\ntriangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j*j)\r\n\r\n\r\n\r\ntriangle2 n =  do x <- [1..n]\r\n\r\n                  y <- [1..x]\r\n\r\n                  return (y*y)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7833,114,'Artur','2013-11-20 22:55:14',0,'\r\n\ntriangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j*j)\r\n\n\r\n\ntriangle2 n =  do x <- [1..n]\r\n\n                  y <- [1..x]\r\n\n                  return (y*y)\r\n\n\n','<br/>Тесты успешно пройдены!'),(7831,114,'Artur','2013-11-20 22:55:07',0,'\r\n\ntriangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j*j)\r\n\n\r\n\ntriangle2 n =  do x <- [1..n]\r\n\n                  y <- [1..x]\r\n\n                  return (y*y)\r\n\n\n','<br/>Тесты успешно пройдены!'),(7832,114,'Artur','2013-11-20 22:55:11',0,'\r\n\ntriangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j*j)\r\n\n\r\n\ntriangle2 n =  do x <- [1..n]\r\n\n                  y <- [1..x]\r\n\n                  return (y*y)\r\n\n\n','<br/>Тесты успешно пройдены!'),(7828,114,'Artur','2013-11-20 22:54:05',0,'\r\n\ntriangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j*j)\r\n\n\r\n\ntriangle2 n =  do x <- [1..n]\r\n\n                  y <- [1..x]\r\n\n                  return (x,y)\r\n\n\n','Выражение имеет неправильное значение: triangle2 3'),(7829,114,'Artur','2013-11-20 22:54:59',0,'\r\n\ntriangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j*j)\r\n\n\r\n\ntriangle2 n =  do x <- [1..n]\r\n\n                  y <- [1..x]\r\n\n                  return (y*y)\r\n\n\n','<br/>Тесты успешно пройдены!'),(7830,114,'Artur','2013-11-20 22:55:03',0,'\r\n\ntriangle1 n = [1..n] >>= i -> [1..i] >>= j -> return (j*j)\r\n\n\r\n\ntriangle2 n =  do x <- [1..n]\r\n\n                  y <- [1..x]\r\n\n                  return (y*y)\r\n\n\n','<br/>Тесты успешно пройдены!'),(7827,101,'deripaska','2013-11-20 17:54:31',1,'{--\r\n\r\n	task 32-05\r\n\r\nДля типа Expr написать функцию simplify. Эта функция должна упрощать выражение, используя только два очень простых правила:\r\n\r\n\r\n\r\nвыражение * 0 = 0\r\n\r\nи\r\n\r\n0 * выражение = 0\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nsimplify (Add (Mult X (Num 0)) X)\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\nAdd (Num 0) X\r\n\r\n\r\n\r\nsimplify (Mult X (Mult X (Num 0)))\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\nNum 0\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\nsimplify (Add x y) = Add (simplify x) (simplify y)\r\n\r\nsimplify (Mult x y)\r\n\r\n	| simpleX == (Num 0) || simpleY == (Num 0) = (Num 0)\r\n\r\n	| otherwise = Mult simpleX simpleY\r\n\r\n	where\r\n\r\n		simpleX = simplify x\r\n\r\n		simpleY = simplify y\r\n\r\nsimplify other = other\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7826,111,'deripaska','2013-11-20 17:54:11',1,'{--\r\n\r\n	task 32-04\r\n\r\nа. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:\r\n\r\n\r\n\r\nAdd (Var \"x\") (Mult (Var \"y\") (Num 3))\r\n\r\n\r\n\r\n(И это должно соответствовать x+y*3 в обычном языке.) \r\n\r\n\r\n\r\nб. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\neval (Add (Var \"x\") (Mult (Var \"y\") (Num 3))) [(\"x\", 5), (\"y\", 8)]\r\n\r\n\r\n\r\nРезультат должен быть равен 29\r\n\r\n--}\r\n\r\n\r\n\r\nfind cond [] err = err\r\n\r\nfind cond ((k, val):xs) err = if cond k then val else find cond xs err\r\n\r\n\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr\r\n\r\n\r\n\r\neval (Num i) list = i\r\n\r\neval (Var x) list = find (== x) list 0\r\n\r\neval (Add x y) list = eval x list + eval y list\r\n\r\neval (Mult x y) list = eval x list * eval y list\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7825,118,'deripaska','2013-11-20 17:53:52',1,'{--\r\n\r\n	task 32-03\r\n\r\nПусть мы описали функцию find вот так:\r\n\r\n\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).\r\n\r\n\r\n\r\nТ.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. Мы бы хотели написать оператор, немного похожий на оператор композиции (.), Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, полученного в результате первого вызова.\r\n\r\n\r\n\r\nЗадача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:\r\n\r\n\r\n\r\nf = find (>3) >>> find (>3) \r\n\r\n-- f - это функция, которая ищет в списке второй элемент, больший 3.\r\n\r\nf [1, 3, 5, 2, 20, 25, 2]\r\n\r\n-- Должно получиться (20, [25, 2])\r\n\r\n--}\r\n\r\n\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf = find (> 3) >>> find (> 3) \r\n\r\n\r\n\r\n(>>>) f1 f2 xs = f2 (snd (f1 xs))\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(7824,115,'deripaska','2013-11-20 17:53:28',1,'{--\r\n\r\n	task 32-02\r\n\r\nПусть функция find описана так:\r\n\r\n\r\n\r\nfind cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\n(Т.е. для того, чтобы сообщить о том, что ничего не найдено, мы используем пустой список).\r\n\r\n\r\n\r\nС помощью этого варианта find описать функцию f, которая делает вот что:\r\n\r\nВ данном списке f ищет:\r\n\r\n- первое число, меньшее 5\r\n\r\n- первое число, большее 10\r\n\r\n- первое число, не равное 7\r\n\r\nи возвращает:\r\n\r\n- если хотя бы один поиск был неудачным, возвращает []\r\n\r\n- если все числа найдены, возвращает список из одного элемента - их суммы.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\n\r\nРезультат должен быть равен [30], потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\n\r\n\r\nf [7, 6, 4, 3, 9]\r\n\r\nРезультат должен быть равен [], потому что один из трех поисков ничего не находит.\r\n\r\n--}\r\n\r\n\r\n\r\nfind cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = if (length res /= 3) then [] else [sum res]\r\n\r\n	where res = (find (< 5) xs) ++ (find (> 10) xs) ++ (find (/= 7) xs)\r\n','<br/>Тесты успешно пройдены!'),(7822,101,'artem.gomerman','2013-11-20 17:27:55',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nsimplify (Num a) = Num a\r\n\r\nsimplify (X) = X\r\n\r\nsimplify (Mult expr1 (Num 0)) = Num 0\r\n\r\nsimplify (Mult (Num 0) expr2) = Num 0\r\n\r\nsimplify (Add expr1 expr2) = Add (simplify expr1) (simplify expr2)\r\n\r\nsimplify (Mult expr1 expr2) = simplify (Mult (simplify expr1) (simplify expr2))\r\n    --- Вот тут у вас зацикливается если в правиле нечего сокращать','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(7823,114,'deripaska','2013-11-20 17:52:56',1,'{--\r\n\r\n	task 32-01\r\n\r\nОпишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:\r\n\r\n\r\n\r\n[1, \r\n\r\n1, 4, \r\n\r\n1, 4, 9,\r\n\r\n...\r\n\r\n1, 4, 9, ..., n*n]\r\n\r\n\r\n\r\nТ.е. сначала выписан квадрат 1, потом квадраты чисел от 1 до 2, потом квадраты чисел от 1 до 3 и т.д.\r\n\r\n\r\n\r\nДополнительные условия:\r\n\r\n- triangle1 надо написать с помощью оператора >>= и функции return\r\n\r\n- triangle2 надо написать с помощью do нотации\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\ntriangle1 3\r\n\r\ntriangle2 3\r\n\r\n\r\n\r\nВ обоих случаях должно получиться:\r\n\r\n[1,1,4,1,4,9]\r\n\r\n--}\r\n\r\n\r\n\r\ntriangle1 n = [1..n] >>= i -> ([1..i] >>= j -> return (j * j))\r\n\r\ntriangle2 n = \r\n\r\n			do \r\n\r\n				i <- [1..n]\r\n\r\n				j <- [1..i]\r\n\r\n				return (j * j)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7820,118,'artem.gomerman','2013-11-20 17:07:44',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\ncond1 >>> cond2 = xs -> cond2 (snd (cond1 xs))\r\n','<br/>Тесты успешно пройдены!'),(7821,111,'artem.gomerman','2013-11-20 17:17:14',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\nfind cond [] = 0\r\n\r\nfind cond (x:xs) = if cond x then snd x else find cond xs\r\n\r\n\r\n\r\neval (Num a) _ = a\r\n\r\neval (Var x) vars = find (y -> fst y == x) vars\r\n\r\neval (Add expr1 expr2) vars = (eval expr1 vars) + (eval expr2 vars)\r\n\r\neval (Mult expr1 expr2) vars = (eval expr1 vars) * (eval expr2 vars)\r\n','<br/>Тесты успешно пройдены!'),(7818,114,'artem.gomerman','2013-11-20 16:26:52',1,'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return (y*y)\r\n\r\ntriangle2 n = do \r\n\r\n	x <- [1..n]\r\n\r\n	y <- [1..x]\r\n\r\n	return (y*y)\r\n','<br/>Тесты успешно пройдены!'),(7819,115,'artem.gomerman','2013-11-20 16:40:11',1,'find cond [] = []\r\n\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n\r\n\r\nf xs = let\r\n\r\n	result = (find (<5) xs) ++ (find (>10) xs) ++ (find (/=7) xs)\r\n\r\n	in if length result /= 3 then [] else [sum result]\r\n','<br/>Тесты успешно пройдены!'),(7816,101,'3320654','2013-11-20 02:04:29',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving (Show, Eq)\r\n\r\nsimplify (Mult e (Num 0)) 	= Num 0\r\nsimplify (Mult (Num 0) e) 	= Num 0\r\nsimplify (Num t) 		= Num t\r\nsimplify (X) 		= X\r\nsimplify (Add x y)		= simplify (Add (simplify x) (simplify y))\r\nsimplify (Mult x y)		= simplify (Mult (simplify x) (simplify y))','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(7817,101,'3320654','2013-11-20 02:12:14',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving (Show, Eq)\r\n\r\nsimplify (Num t) 		= Num t\r\nsimplify (X) 		= X\r\nsimplify (Add x y)		= Add (simplify x) (simplify y)\r\nsimplify (Mult x y)		= let\r\n				k = (simplify x)\r\n				n = (simplify y)\r\n			   in	\r\n				if (k == Num 0) || (n == Num 0)\r\n				then Num 0\r\n				else Mult k n','<br/>Тесты успешно пройдены!'),(7813,115,'3320654','2013-11-20 01:29:26',1,'find cond [] 	= []\r\nfind cond (x:xs) 	= if cond x \r\n		   then [x] \r\n		   else find cond xs\r\n\r\nf l = zipWith (+) (zipWith (+) (find (< 5) l) (find (> 10) l)) (find (/= 7) l)','<br/>Тесты успешно пройдены!'),(7814,118,'3320654','2013-11-20 01:45:15',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(>>>)       	:: ([a] -> (a, [a])) -> ([a] -> (a, [a])) -> ([a] -> (a, [a]))\r\nf >>> g	= x -> f (snd (g x))\r\n\r\nf =  find (>3) >>> find (>3) ','<br/>Тесты успешно пройдены!'),(7815,111,'3320654','2013-11-20 01:57:37',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr \r\n		deriving (Show, Eq)\r\n\r\neval (Num t) _	= t\r\neval (Var z) list	= help z list\r\n   --- название help, мне кажется, не очень понятное, я бы назвал getVar или что-то в этом роде\r\neval (Add x y) list	= eval x list + eval y list\r\neval (Mult x y) list	= eval x list * eval y list\r\n\r\nhelp _ []		= 0\r\nhelp z (x:xs) 	= if (fst x) == z\r\n		   then snd x\r\n		   else help z xs','<br/>Тесты успешно пройдены!'),(7812,114,'3320654','2013-11-20 01:22:21',1,'triangle1 n = [1..n] >>= x -> [1..x] >>= y -> return (y * y)\r\n\r\ntriangle2 n = 	do	x <- [1..n]\r\n			y <- [1..x]\r\n			return (y * y)','<br/>Тесты успешно пройдены!'),(7811,109,'8519021','2013-11-19 23:08:28',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace AllDiffLists\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        private static void AllDifferent1(int n, int k, Predicate<int> cond, Action printAction)\r\n\r\n        {\r\n\r\n            if (k == 0)\r\n\r\n            {\r\n\r\n                printAction();\r\n\r\n                Console.WriteLine();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            \r\n\r\n            for (int i = 1; i <= n; i++)\r\n\r\n            {\r\n\r\n                if (cond(i))\r\n\r\n                {\r\n\r\n                    AllDifferent1(n, k - 1, t => cond(t) && t != i, () =>\r\n\r\n                    {\r\n\r\n                        printAction();\r\n\r\n                        Console.Write(\"{0} \", i);\r\n\r\n                    });\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void AllDifferent(int n, int k)\r\n\r\n        {\r\n\r\n            AllDifferent1(n, k, t => true, () => { });\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n = 3;\r\n\r\n            int k = 2;\r\n\r\n            AllDifferent(n, k);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7810,101,'anlun','2013-11-19 22:20:46',1,'import Data.Maybe\r\nimport Data.List\r\n\r\ndata Expr a = \r\n	Var String |\r\n	X |\r\n	Num a |\r\n	Mult (Expr a) (Expr a) |\r\n	Add  (Expr a) (Expr a)\r\n	deriving (Show, Eq)\r\n\r\nsimplify :: Expr Integer -> Expr Integer\r\nsimplify (Mult n@(Num 0) _) = n\r\nsimplify (Mult _ n@(Num 0)) = n\r\nsimplify (Mult l r) = if l1 == (Num 0) || r1 == (Num 0) then Num 0 else Mult l1 r1\r\n	where\r\n		l1 = simplify l\r\n		r1 = simplify r\r\nsimplify (Add  l r) = Add (simplify l) (simplify r)\r\nsimplify l = l\r\n','<br/>Тесты успешно пройдены!'),(7809,101,'anlun','2013-11-19 22:18:08',0,'import Data.Maybe\r\nimport Data.List\r\n\r\ndata Expr a = \r\n	Var String |\r\n	X |\r\n	Num a |\r\n	Mult (Expr a) (Expr a) |\r\n	Add  (Expr a) (Expr a)\r\n	deriving Show\r\n\r\nsimplify :: Expr Integer -> Expr Integer\r\nsimplify (Mult n@(Num 0) _) = n\r\nsimplify (Mult _ n@(Num 0)) = n\r\nsimplify (Mult l r) = simplify $ Mult (simplify l) (simplify r)\r\nsimplify (Add  l r) = Add (simplify l) (simplify r)\r\nsimplify l = l\r\n','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(7808,101,'anlun','2013-11-19 22:16:22',0,'import Data.Maybe\r\nimport Data.List\r\n\r\ndata Expr a = \r\n	Var String |\r\n	X |\r\n	Num a |\r\n	Mult (Expr a) (Expr a) |\r\n	Add  (Expr a) (Expr a)\r\n	deriving Show\r\n\r\nsimplify :: Expr Integer -> Expr Integer\r\nsimplify (Mult n@(Num 0) _) = n\r\nsimplify (Mult _ n@(Num 0)) = n\r\nsimplify (Mult l r) = simplify $ Mult (simplify l) (simplify r)\r\nsimplify (Add  l r) = Add (simplify l) (simplify r)\r\nsimplify l = l\r\n','Не удалось вычислить выражение \"simplify (Mult X X)\", проверьте правильность синтаксиса'),(7807,101,'anlun','2013-11-19 22:14:24',0,'import Data.Maybe\r\nimport Data.List\r\n\r\ndata Expr a = \r\n	Var String |\r\n	X |\r\n	Num a |\r\n	Mult (Expr a) (Expr a) |\r\n	Add  (Expr a) (Expr a)\r\n	deriving Show\r\n\r\nsimplify :: Expr Integer -> Expr Integer\r\nsimplify (Mult n@(Num 0) _) = n\r\nsimplify (Mult _ n@(Num 0)) = n\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify l = l','Выражение имеет неправильное значение: simplify (Mult X (Mult X (Num 0)))'),(7806,101,'anlun','2013-11-19 22:13:31',0,'import Data.Maybe\r\nimport Data.List\r\n\r\ndata Expr a = \r\n	Var String |\r\n	Num a |\r\n	Mult (Expr a) (Expr a) |\r\n	Add  (Expr a) (Expr a)\r\n	deriving Show\r\n\r\nsimplify :: Expr Integer -> Expr Integer\r\nsimplify (Mult n@(Num 0) _) = n\r\nsimplify (Mult _ n@(Num 0)) = n\r\nsimplify (Add l r) = Add (simplify l) (simplify r)\r\nsimplify l = l\r\n','Не удалось вычислить выражение \"simplify (Mult X (Mult X (Num 0)))\", проверьте правильность синтаксиса'),(7803,115,'anlun','2013-11-19 21:49:25',1,'find :: (a -> Bool) -> [a] -> [a]\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\nf l = (>>=) l1 $ x -> (>>=) l2 $ y -> (>>=) l3 $ (.) return (x + y +)\r\n	where\r\n		l1 = find (<  5) l\r\n		l2 = find (> 10) l\r\n		l3 = find (/= 7) l','<br/>Тесты успешно пройдены!'),(7804,118,'anlun','2013-11-19 21:57:37',1,'find :: (a -> Bool) -> [a] -> (a, [a])\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\nf1 >>> f2 = xs -> let (_, ys) = f1 xs in f2 ys','<br/>Тесты успешно пройдены!'),(7805,111,'anlun','2013-11-19 22:10:06',1,'import Data.Maybe\r\nimport Data.List\r\n\r\ndata Expr a = \r\n	Var String |\r\n	Num a |\r\n	Mult (Expr a) (Expr a) |\r\n	Add  (Expr a) (Expr a)\r\n\r\neval :: Expr Integer -> [(String, Integer)] -> Integer\r\neval (Var x) l = snd $ fromMaybe (x, 0) value\r\n	where\r\n		value = find ((y, _) -> y == x) l\r\neval (Num x) _ = x\r\neval (Mult x y) l = (*) (eval x l) $ eval y l\r\neval (Add  x y) l = (+) (eval x l) $ eval y l','<br/>Тесты успешно пройдены!'),(7802,108,'2156724','2013-11-19 20:53:32',2,'--- У вас для 8 считается слишком долго, поэтому тесты не проходят. Но это легко исправить.\r\n--- Вы просто наверное не обратили внимание на то что в у словии написано:\r\n--- `давайте считать, что первый ферзь в списке всегда стоит на первой вертикали, \r\n--- второй ферзь - на второй вертикали и т.д.`\r\n--- А это означает, что по x вам перебор не нужен, для каждого шага x просто на 1 больше предыдущего.\r\n--- Попроьуйте исправить, пожалуйста.\r\n\r\nqueens\' n 0 cond = [[]]	\r\n\r\n\r\n\r\nqueens\' n k cond =\r\n\r\n     [(x,y) : xs | y<-[1..k], x<-[1..n], xs<-queens\' n (k-1) ((t,z) -> cond (t,z) && (not (x==t)) && ( not (y==z)) && not(abs (x-t) == abs(y-z))), \r\n\r\n           cond (x,y)]\r\n\r\nqueens n k = queens\' n k (	 -> True) \r\n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7801,108,'2156724','2013-11-19 12:26:17',0,'queens\' n 0 cond = [[]]	\r\n\n\r\n\nqueens\' n k cond =\r\n\n     [(x,y) : xs | y<-[1..k], x<-[1..n], xs<-queens\' n (k-1) ((t,z) -> cond (t,z) && (not (x==t)) && ( not (y==z)) && not(abs (x-t) == abs(y-z))), \r\n\n           cond (x,y)]\r\n\nqueens n k = queens\' n k (	 -> True) \n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7800,94,'ip','2013-11-19 00:19:40',2,'--- Все-mfrb странно у вас исборажается.\r\n--- Во перых у вас выводятся кавычки, из-за того, что лишний раз вызывается show в printScheme - вроде бы я об этом писал\r\n--- Во втрых, вот я наьираю пример\r\n--- Series (Parallel (Parallel (Simple 1) (Simple 2))  (Simple 3)) (Simple 5)\r\n--- А во атрой строке в конце что-то непонятное. Типа двух линий, насколько японимаю ваши обозначения,\r\n--- из которых одна мне кажется никуда не идет.\r\n--- Попроьуйте исправить, пожалуйста.\r\n{-\r\n\r\nЕсли не изображается, то http://rghost.net/50270732\r\n\r\n\r\n\r\nИсправил 1 2 пункт.\r\n\r\nНе получается сделать изображение лучше из-за разной ширины символов(\r\n\r\nНо схема должна быть понятна.\r\n\r\n\r\n\r\n.(Double) - резистор\r\n\r\n= ||   // - проводник\r\n\r\n\r\n\r\nПримеры:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n (Parallel               (Simple 4.23) (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     )\r\n\r\n\r\n\r\n (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3.33333))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n ( Parallel (Series     (Parallel               (Parallel ((Series (Simple 1.234) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2.342))) (Simple 3)))   )  (Simple 1))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2.34))) (Simple 3))     (Parallel ((Series (Simple 133) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel (Series   (Series  (Series  (Series  (Series  (Series  (Simple 1) (Simple 134) ) (Simple 1) ) (Simple 1) ) (Simple 13) ) (Simple 1) ) (Simple 1) )\r\n\r\n ((Series (Simple 1) (Simple 2))) ))   )\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndata Scheme = Simple Double |\r\n\r\n     Series Scheme Scheme |\r\n\r\n     Parallel Scheme Scheme\r\n\r\n\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n show a = printScheme2 (buildScheme a)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--вспомогательная структура\r\n\r\ndata Dt = Triple [String] Integer Integer\r\n\r\n\r\n\r\n--печатает схему\r\n\r\nprintScheme x = putStr (printScheme2 (buildScheme x) )\r\n\r\n\r\n\r\n--вспомогательная функция\r\n\r\nprintScheme2 [] = \"\"\r\n\r\nprintScheme2 (x:xs) = (show x) ++ [\'\r\n\'] ++ (printScheme2 xs)\r\n\r\n\r\n\r\n--строит список строк рисунка по схеме\r\n\r\nbuildScheme x = let\r\n\r\n                Triple xs w h = electric x\r\n\r\n                in xs\r\n\r\n                 \r\n\r\n\r\n\r\nlOfInt i k = let\r\n\r\n             a = div i 10\r\n\r\n             in\r\n\r\n             if (a==0)\r\n\r\n             then (k+1)\r\n\r\n             else lOfInt a (k+1)         \r\n\r\n\r\n\r\n\r\n\r\nas i = toInteger (length (show i))\r\n\r\n\r\n\r\n--разбирает схему на каждом шаге составив \'рисунок\' снизу вверх\r\n\r\nelectric (Simple i) = Triple [\".(\" ++ (show i) ++ \")\"] ((as i)+1) 1\r\n\r\nelectric (Series x y) = let\r\n\r\n                        Triple xs w h = electric x\r\n\r\n                        Triple ys w2 h2 =  electric y\r\n\r\n                        in Triple (handleS w h w2 h2 xs ys) (w + w2 +1) (max h h2)\r\n\r\nelectric (Parallel x y) = let\r\n\r\n                          Triple xs w h = electric x\r\n\r\n                          Triple ys w2 h2 =  electric y\r\n\r\n                          in Triple (handleP w h w2 h2 xs ys) ((max w w2) + 2) (h + h2 + 1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--случай последовательного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\r\n\r\nhandleS w h w2 h2 xs ys = let\r\n\r\n		          \r\n\r\n                          hp = max h h2\r\n\r\n                          hdiff = div (abs(h - h2)) 2\r\n\r\n                          hshift = mod (abs(h - h2)) 2\r\n\r\n			  middle = (mod hp 2)  + (div hp 2)\r\n\r\n			  in\r\n\r\n                          if (h<h2)\r\n\r\n                          then concateBlocks (colums xs hdiff w hshift) ys middle [] 1 \r\n\r\n                          else concateBlocks xs (colums ys hdiff w2 hshift) middle [] 1 \r\n\r\n\r\n\r\n--склеивает два блока обеспечивая между ними промежуток\r\n\r\nconcateBlocks [] [] _ out i  = out\r\n\r\nconcateBlocks (x:xs) [] middle out i  = if (i == middle)\r\n\r\n       				        then concateBlocks xs [] middle (out ++ [(x ++ \"=\")]) (i+1) \r\n\r\n					else concateBlocks xs [] middle (out ++ [(x ++ \"  \")]) (i+1) \r\n\r\nconcateBlocks (x:xs) (y:ys) middle out i  = if (i == middle)\r\n\r\n     				  	    then concateBlocks xs ys middle (out ++ [(x ++ \"=\" ++ y)]) (i+1) \r\n\r\n					    else concateBlocks xs ys middle (out ++ [(x ++ \"  \" ++ y)]) (i+1) \r\n\r\n\r\n\r\n--добирает высоту меньшего из блоков\r\n\r\ncolums xs d w 1 = colums ([createStr \"  \" w] ++ xs) d w 0\r\n\r\ncolums xs 0 _ _ = xs\r\n\r\ncolums xs d w s = let\r\n\r\n                  str = createStr \"  \" w\r\n\r\n                  in\r\n\r\n                  colums ([str] ++ xs ++ [str]) (d-1) w s\r\n\r\n\r\n\r\n--вспомогательная функция\r\n\r\ncreateStr a 0 = \"\"\r\n\r\ncreateStr a 1 = a\r\n\r\ncreateStr a w = a ++ (createStr a (w-1)) \r\n\r\n\r\n\r\n\r\n\r\n--случай параллельного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\r\n\r\nhandleP w h w2 h2 xs ys = let\r\n\r\n		          wp = (max w w2) + 2\r\n\r\n                          hp = h + h2 + 1\r\n\r\n                          wdiff = (div (abs(w - w2)) 2 ) + 1\r\n\r\n                          wshift = (mod (abs(w - w2)) 2 )\r\n\r\n			  middle = (mod h 2)  + (div h 2)\r\n\r\n			  middle2 = (mod h2 2)  + (div h2 2)\r\n\r\n                          str = createStr \"  \" (wp-2)\r\n\r\n			  in\r\n\r\n                          if (w<w2)\r\n\r\n                          --склейка рисунков \'поверху\'\r\n\r\n                          then if (wshift==1)\r\n\r\n                               then let xs2 = concateBlocks xs [] middle [] 1\r\n\r\n                                    in (strings xs2 wdiff middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys 1 middle2 1 [])\r\n\r\n                               else (strings xs wdiff middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys 1 middle2 1 [])\r\n\r\n\r\n\r\n\r\n\r\n                          else if (wshift==1)\r\n\r\n                               then let ys2 = concateBlocks ys [] middle2 [] 1\r\n\r\n                                    in (strings xs 1 middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys2 wdiff middle2 1 [])\r\n\r\n                               else (strings xs 1 middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys wdiff middle2 1 [])\r\n\r\n\r\n\r\n--рисует вертикальные части \'проводника\' для верхнего блока (левого аргумента)\r\n\r\nstrings [] _ _ _ out = out\r\n\r\nstrings (x:xs) d middle i out = if (i<middle)\r\n\r\n                        	then let\r\n\r\n                             	     str = createStr \"  \" d\r\n\r\n                             	     in\r\n\r\n                             	     strings xs d middle (i+1) (out ++ [(str ++ x ++ str)])\r\n\r\n                                else if (i == middle)\r\n\r\n                                     then let\r\n\r\n                                          str = createStr \"=\" (d-1)\r\n\r\n                                          in\r\n\r\n                                          strings xs d middle (i+1) (out ++ [(\"//\" ++ str ++ x ++ str ++ \"\")])\r\n\r\n                                     else let\r\n\r\n                                          str = createStr \"  \" (d-1)\r\n\r\n                                          in\r\n\r\n                                          strings xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\r\n\r\n\r\n\r\n--рисует вертикальные части \'проводника\' для нижнего блока (правого аргумента)\r\n\r\nstrings2 [] _ _ _ out = out\r\n\r\nstrings2 (x:xs) d middle i out = if (i>middle)\r\n\r\n                              	 then let\r\n\r\n                             	      str = createStr \"  \"  d\r\n\r\n                             	      in\r\n\r\n                             	      strings2 xs d middle (i+1) (out ++ [(str ++ x ++ str)])\r\n\r\n                                 else if (i == middle)\r\n\r\n                                      then let\r\n\r\n                                           str = createStr \"=\" (d-1)\r\n\r\n                                           in\r\n\r\n                                           strings2 xs d middle (i+1) (out ++ [(\"\" ++ str ++ x ++ str ++ \"//\")])\r\n\r\n                                      else let\r\n\r\n                                           str = createStr \"  \" (d-1)\r\n\r\n                                           in\r\n\r\n                                           strings2 xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7799,88,'480387','2013-11-18 22:46:54',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\ndiff:: Expr->Expr\r\ndiff (Num n) = Num 0\r\ndiff X = Num 1\r\ndiff (Add e1 e2)  = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n','<br/>Тесты успешно пройдены!'),(7798,88,'42284313','2013-11-18 21:48:26',1,'{--\r\n\r\n\r\n\r\nДля типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\r\n\r\n\r\ndiff (Mult X X)\r\n\r\n\r\n\r\nДолжно получиться\r\n\r\n\r\n\r\nAdd (Mult(N 1) X) (Mult X (Num 1))\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- В описании типа надо обязательно в конце написать deriving Show. (На занятии я забыл это сделать :( ). Иначе не удастся вывести результат. \r\n\r\n- Упрощать выражение не надо. Т.е. не требуется, например, пытаться вместо Add (Mult(Num 1) X) (Mult X (Num 1)) получить Mult (Num 2) X.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = X | N Integer | Num Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff X = N 1\r\n\r\ndiff (N n) = Num 0\r\n\r\ndiff (Num n) = Num 0\r\n\r\ndiff (Add a b) = Add (diff a) (diff b)\r\n\r\ndiff (Mult a b) = Add(Mult (diff a) b) (Mult a (diff b))\r\n','Выражение имеет неправильное значение: diff (Mult X X)'),(7796,87,'42284313','2013-11-18 21:40:45',1,'{--\r\n\r\n\r\n\r\nДля типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\neval (Add (Num 3) (Mult X X)) 10\r\n\r\n\r\n\r\nДолжно получиться 103\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = X | Num Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval X n = n\r\n\r\neval (Num a) n = a\r\n\r\neval (Add a b) n = (eval a n) + (eval b n) \r\n\r\neval (Mult a b) n = (eval a n) * (eval b n)\r\n','<br/>Тесты успешно пройдены!'),(7797,88,'42284313','2013-11-18 21:47:53',0,'{--\r\n\n\r\n\nДля типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\n\r\n\ndiff (Mult X X)\r\n\n\r\n\nДолжно получиться\r\n\n\r\n\nAdd (Mult(N 1) X) (Mult X (Num 1))\r\n\n\r\n\nЗамечания:\r\n\n- В описании типа надо обязательно в конце написать deriving Show. (На занятии я забыл это сделать :( ). Иначе не удастся вывести результат. \r\n\n- Упрощать выражение не надо. Т.е. не требуется, например, пытаться вместо Add (Mult(Num 1) X) (Mult X (Num 1)) получить Mult (Num 2) X.\r\n\n\r\n\n--}\r\n\n\r\n\ndata Expr = X | N Integer | Num Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\ndiff X = N 1\r\n\ndiff (N n) = N 0\r\n\ndiff (Num n) = N 0\r\n\ndiff (Add a b) = Add (diff a) (diff b)\r\n\ndiff (Mult a b) = Add(Mult (diff a) b) (Mult a (diff b))\n','Выражение имеет неправильное значение: diff (Mult X X)'),(7794,87,'42284313','2013-11-18 21:32:12',0,'{--\r\n\n\r\n\nДля типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\n\r\n\nПример вызова:\r\n\n\r\n\neval (Add (Num 3) (Mult X X)) 10\r\n\n\r\n\nДолжно получиться 103\r\n\n\r\n\n--}\r\n\n\r\n\ndata Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\neval X n = n\n','Не удалось вычислить выражение \"eval (Add (Num 3) (Mult X X)) 10\", проверьте правильность синтаксиса'),(7795,88,'42284313','2013-11-18 21:35:18',0,'{--\r\n\n\r\n\nДля типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\n\r\n\ndiff (Mult X X)\r\n\n\r\n\nДолжно получиться\r\n\n\r\n\nAdd (Mult(N 1) X) (Mult X (Num 1))\r\n\n\r\n\nЗамечания:\r\n\n- В описании типа надо обязательно в конце написать deriving Show. (На занятии я забыл это сделать :( ). Иначе не удастся вывести результат. \r\n\n- Упрощать выражение не надо. Т.е. не требуется, например, пытаться вместо Add (Mult(Num 1) X) (Mult X (Num 1)) получить Mult (Num 2) X.\r\n\n\r\n\n--}\r\n\n\r\n\ndata Expr = X | N Integer | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\ndiff X = N 1\n','Не удалось вычислить выражение \"diff (Mult X X)\", проверьте правильность синтаксиса'),(7792,104,'42284313','2013-11-18 21:26:18',2,'{--\r\n\r\n\r\n\r\nПри помощи оператора >>= для списков описать функцию doubleEven, которая в данном списке все элементы, делящиеся на 2, повторяет два раза, а остальные оставляет, как есть.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ndoubleEven [1, 2, 6, 3]\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[1,2,2,6,6,3]\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ndoubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x, x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7793,105,'42284313','2013-11-18 21:28:43',2,'{--\r\n\r\n\r\n\r\nОписать функцию cartesian, которая для двух списков возвращает список из всех возможных пар элементов из первого и второго списка. Т.е. для списков [x1, x2, x3] и [y1, y2, y3] функция должна вернуть [(x1, y1), (x1, y2), (x1, y3), (x2, y1), (x2, y2), …] (всего 9 пар).\r\n\r\n\r\n\r\nПри этом желательно использовать только оператор >>= и лямбда выражения. Можно, но не очень нужно, определять вспомогательные функции. \r\n\r\n\r\n\r\nЕсли не получится сделать задачу с помощью >>=, можно написать любым способом, но только не используя list comprehension (с ним это уж слишком просто).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ncartesian [1,2] [3,4]\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[(1,3),(1,4),(2,3),(2,4)]\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ncartesian xs ys = xs >>= x -> ys >>= y -> [(x, y)]\r\n','<br/>Тесты успешно пройдены!'),(7791,103,'42284313','2013-11-18 21:24:19',1,'{--\r\n\r\n\r\n\r\nНа занятии мы разобрали функцию find, использующую failure continuation параметр, для того чтобы сообщить, что ничего не найдено. \r\n\r\n\r\n\r\nИспользуя только эту функцию, описать функцию findInLists, которая ищет элемент, удовлетворяющий данному условию в списке списков.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nfindInLists [[1,8,2], [2,7]] (>5) 0\r\n\r\n\r\n\r\nРезультат должен быть равен 8.\r\n\r\n\r\n\r\nfindInLists [[1,8,2], [2,7]] (>10) 0\r\n\r\n\r\n\r\nРезультат должен быть равен 0.\r\n\r\n\r\n\r\nЗамечание: \r\n\r\nЖелательно в программе не использовать оператор if. Потому что, как мы говорили, при использовании failure continuation он, как правило, не нужен. Функция find, в каком-то смысле, сама работает, как оператор if. \r\n\r\nНо, если так не получиться, в принципе использовать if можно.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nfind condition [] failure_continuation = failure_continuation\r\n\r\nfind condition (x:xs) failure_continuation = if condition x then x else find condition xs failure_continuation\r\n\r\n\r\n\r\nfindInLists [] _ failure_continuation = failure_continuation\r\n\r\nfindInLists (xs:xss) condition failure_continuation = find condition xs (findInLists xss condition failure_continuation)\r\n','<br/>Тесты успешно пройдены!'),(7790,102,'42284313','2013-11-18 21:18:51',1,'{--\r\n\r\n\r\n\r\nОпишите функцию findMajor, которая для данного списка определяет, есть ли в нем элемент, который больше суммы всех остальных, вместе взятых, и, если есть, возвращает его, как результат.\r\n\r\n\r\n\r\nДля того, чтобы сообщить, есть такой элемент или нет, используйте стандартный тип Maуbe, который мы проходили на последнем занятии.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nfindMajor [2,3,15,2,2,2] \r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\nJust 15\r\n\r\n\r\n\r\nfindMajor [2,3,5,2,4] \r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\nNothing\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- Тут никаких хитростей, это простое упражнение на использование Maybe\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nfindMajor\' [] _ = Nothing\r\n\r\nfindMajor\' (x:xs) s = if 2 * x > s then Just x else findMajor\' xs s\r\n\r\n\r\n\r\nfindMajor xs = findMajor\' xs (sum xs)\r\n','<br/>Тесты успешно пройдены!'),(7789,110,'3270666','2013-11-18 20:34:37',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FP31_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int Find(Predicate<int> func, int[] a, Func<int> err)\r\n\r\n        {\r\n\r\n            foreach (int x in a)\r\n\r\n            {\r\n\r\n                if (func(x))\r\n\r\n                {\r\n\r\n                    return x;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Func<int[], int> FindTest =\r\n\r\n                arr => Find(x => x > 1000, arr, () => Find(x => x > 500, arr, () => Find(x => x > 100, arr, () => 0)));\r\n\r\n            \r\n\r\n            int[] a1 = new int[] { 8, 100, 200, 300, 501, 502, 1100, 1200, 1300 };\r\n\r\n            Console.WriteLine(FindTest(a1));\r\n\r\n\r\n\r\n            int[] a2 = new int[] { 8, 100, 200, 300, 501, 502 };\r\n\r\n            Console.WriteLine(FindTest(a2));\r\n\r\n\r\n\r\n            int[] a3 = new int[] { 8, 100, 200, 300 };\r\n\r\n            Console.WriteLine(FindTest(a3));\r\n\r\n\r\n\r\n            int[] a4 = new int[] { 8, 9, 10 };\r\n\r\n            Console.WriteLine(FindTest(a4));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7787,106,'3270666','2013-11-18 17:37:07',1,'findMajor xs = 	let ans = guessMajor xs\r\n                    adsads = count xs ans 0\r\n                in  if (adsads > (length xs) `div` 2)\r\n    	               then Just ans\r\n    	               else Nothing\r\n\r\ncount [] m res = res\r\ncount (x:xs) m res = \r\n	let inc = if (x == m) then 1 else 0\r\n    in count xs m (res + inc)\r\n\r\nguessMajor xs = guess xs 0 0\r\n\r\nguess [] cur _ = cur\r\nguess (x:xs) cur n = if (n == 0)\r\n	then guess xs x 1\r\n	else if (x == cur)\r\n		then guess xs cur (n + 1)\r\n		else guess xs cur (n - 1)','<br/>Тесты успешно пройдены!'),(7788,109,'3270666','2013-11-18 20:23:17',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FP28_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void allDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            allDiffists1(n, k, t => true, () => { Console.WriteLine(); });\r\n\r\n        }\r\n\r\n\r\n\r\n        static void allDiffists1(int n, int k, Predicate<int> cond, Action print)\r\n\r\n        {\r\n\r\n            if (k == 0)\r\n\r\n            {\r\n\r\n                print();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            for (int i = 1; i <= n; i++)\r\n\r\n            {\r\n\r\n                if (cond(i))\r\n\r\n                {\r\n\r\n                    allDiffists1(n, k - 1, t => cond(t) && t != i, () => { print(); Console.Write(\" {0}\", i); });\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            allDiffLists(3, 2);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7785,108,'2156724','2013-11-18 16:08:14',0,'queens\' n 0 cond = [[]]	\r\n\n\r\n\nqueens\' n k cond =\r\n\n     [(x,y) : xs | x<-[1..k], y<-[1..n], xs<-queens\' n (k-1) ((t,z) -> cond (t,z) && (not (x==t)) && ( not (y==z)) && not(abs (x-t) == abs(y-z))), \r\n\n           cond (x,y)]\r\n\nqueens n k = queens\' n k (	 -> True) \n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7786,97,'3270666','2013-11-18 17:14:17',1,'checkBrackets s = brackets s []\r\n\r\nbrackets [] [] = True\r\nbrackets [] _ = False\r\nbrackets (x:xs) ys = \r\n	if (x == \'(\')\r\n		then brackets xs (\')\':ys)\r\n		else if (x == \'[\')\r\n			then brackets xs (\']\':ys)\r\n			else if (ys /= [])\r\n				then if (x == (head ys))\r\n					then brackets xs (tail ys)\r\n					else False\r\n				else False','<br/>Тесты успешно пройдены!'),(7784,102,'1835693','2013-11-18 13:28:13',1,'findMajor xs = findMajorH xs xs\r\n\r\nfindMajorH []       _  = Nothing\r\nfindMajorH (x:rest) xs = if (sumList xs > 2 * x)\r\n                         then findMajorH rest xs\r\n                         else Just x\r\n\r\nsumList = foldl (+) 0\r\n','<br/>Тесты успешно пройдены!'),(7781,87,'1170660','2013-11-18 10:52:06',1,'data Expr = X | Num Integer | Add Expr Expr | Mult Expr Expr deriving (Eq, Show)\r\n\r\n\r\n\r\neval(Add s1 s2) x = eval s1 x + eval s2 x\r\n\r\neval(Mult s1 s2) x = eval s1 x * eval s2 x\r\n\r\neval (Num s) x = s\r\n\r\neval X x =x\r\n','<br/>Тесты успешно пройдены!'),(7782,88,'1170660','2013-11-18 11:14:04',1,'data Expr = X | Num Integer | Add Expr Expr | Mult Expr Expr deriving (Eq, Show)\r\n\r\n\r\n\r\ndiff (Add s1 s2) = Add (diff s1) (diff s2)\r\n\r\ndiff (Mult s1 s2) = Add (Mult(diff s1) s2) (Mult s1 (diff s2))\r\n\r\ndiff (X) = Num 1\r\n','<br/>Тесты успешно пройдены!'),(7783,106,'romos2007','2013-11-18 12:39:18',1,'{--\r\n\r\nЗадача 30-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{--\r\n\r\nЗадача о поиске часто встречающихся элементах.\r\n\r\n\r\n\r\nВ общем случае можно реализовать поиск элементов,\r\n\r\nвстречающихся более N/k раз за O(k) памяти и O(n).\r\n\r\n\r\n\r\nсм. \r\n\r\nhttp://habrahabr.ru/post/167177/\r\n\r\nhttp://keithschwarz.com/interesting/code/?dir=majority-element\r\n\r\n--}\r\n\r\n\r\n\r\nfindMajor [] = Nothing\r\n\r\nfindMajor xs = 	let\r\n\r\n					temp = fm xs 0 0\r\n\r\n				in\r\n\r\n					if check xs temp 0 0\r\n\r\n					then Just temp\r\n\r\n					else Nothing\r\n\r\n\r\n\r\n\r\n\r\nfm [] stand candidate = candidate\r\n\r\nfm (x:xs) stand candidate =\r\n\r\n	if stand == 0\r\n\r\n	then fm xs (stand+1) x\r\n\r\n	else\r\n\r\n		if candidate == x\r\n\r\n		then fm xs (stand+1) candidate\r\n\r\n		else fm xs (stand-1) candidate\r\n\r\n\r\n\r\n\r\n\r\ncheck xs t count_t len_xs\r\n\r\n	|xs == [] = (count_t > (len_xs /2))\r\n\r\n	|otherwise =if head xs == t\r\n\r\n				then check (tail xs) t (count_t+1) (len_xs+1)\r\n\r\n				else check (tail xs) t (count_t) (len_xs+1)\r\n','<br/>Тесты успешно пройдены!'),(7771,105,'480387','2013-11-18 07:06:19',0,'cartesian xs ys = ys >>= (y -> ( xs >>= (x->[(x,y)])))\r\n','Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),(7772,105,'480387','2013-11-18 07:07:40',1,'cartesian ys xs = ys >>= (y -> ( xs >>= (x->[(y,x)])))\r\n','<br/>Тесты успешно пройдены!'),(7773,104,'480387','2013-11-18 07:09:22',1,'doubleEven xs = xs >>=(x->if mod x 2 == 0 then [x,x] else [x])','<br/>Тесты успешно пройдены!'),(7774,87,'480387','2013-11-18 07:18:10',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\neval:: Expr->Integer->Integer\r\neval (Num n) _ = n\r\neval X val = val\r\neval (Add e1 e2) val = eval e1 val + (eval e2 val)\r\neval (Mult e1 e2) val = eval e1 val * (eval e2 val)\r\n','<br/>Тесты успешно пройдены!'),(7775,88,'480387','2013-11-18 07:25:28',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\ndiff:: Expr->Expr\r\ndiff (Num n) = Num 0\r\ndiff X = Num 1\r\ndiff (Add e1 e2)  = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n','<br/>Тесты успешно пройдены!'),(7776,102,'1170660','2013-11-18 10:07:38',1,'findMajor xs = findMajor\' xs (sum xs)\r\n\r\nfindMajor\' [] _ = Nothing\r\n\r\nfindMajor\' (x:xs) s = if x > s-x then Just x else findMajor\' xs s\r\n','<br/>Тесты успешно пройдены!'),(7777,103,'1170660','2013-11-18 10:13:03',1,'find cond [] err = err\r\n\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\n\r\n\r\nfindInLists [] cond err = err\r\n\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err)\r\n','<br/>Тесты успешно пройдены!'),(7778,104,'1170660','2013-11-18 10:15:41',1,'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x, x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7779,105,'1170660','2013-11-18 10:23:05',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x, y)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7780,106,'romos2007','2013-11-18 10:41:51',0,'{--\r\n\nЗадача 30-2\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\nfindMajor [] = Nothing\r\n\nfindMajor xs = 	let\r\n\n					temp = fm xs 0 0\r\n\n				in\r\n\n					if check xs temp 0 0\r\n\n					then Just temp\r\n\n					else Nothing\r\n\n\r\n\n\r\n\nfm [] stand candidate = candidate\r\n\nfm (x:xs) stand candidate =\r\n\n	if stand == 0\r\n\n	then fm xs (stand+1) x\r\n\n	else\r\n\n		if candidate == x\r\n\n		then fm xs (stand+1) candidate\r\n\n		else fm xs (stand-1) candidate\r\n\n\r\n\n\r\n\ncheck xs t count_t len_xs\r\n\n	|xs == [] = (count_t > (len_xs /2))\r\n\n	|otherwise =if head xs == t\r\n\n				then check (tail xs) t (count_t+1) (len_xs+1)\r\n\n				else check (tail xs) t (count_t) (len_xs+1)\n','<br/>Тесты успешно пройдены!'),(7768,105,'Artur','2013-11-18 02:49:29',1,'cartesian xs ys = xs >>= (i -> ys >>= (j -> [(i,j)] ) )\r\n\r\n\r\n\r\n--\r\n','<br/>Тесты успешно пройдены!'),(7769,87,'Artur','2013-11-18 03:09:51',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving (Show,Eq)\r\n\r\n	\r\n\r\neval (Num i) var = i\r\n\r\neval (X ) var = var\r\n\r\neval (Add  expr1 expr2) var = (eval expr1 var) + (eval expr2 var)\r\n\r\neval (Mult expr1 expr2) var = (eval expr1 var) * (eval expr1 var)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7770,88,'Artur','2013-11-18 03:15:56',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving (Show,Eq)\r\n\r\n\r\n\r\ndiff (Num i) = (Num 0)\r\n\r\ndiff X = (Num 1) \r\n\r\ndiff (Add  expr1 expr2) = Add (diff expr1) (diff expr2) \r\n\r\ndiff (Mult expr1 expr2) = Add (Mult (diff expr1) expr2) (Mult expr1 (diff expr2) )  \r\n','<br/>Тесты успешно пройдены!'),(7764,102,'Artur','2013-11-18 02:28:04',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then Just x \r\n\r\n			    else find f xs err\r\n\r\n\r\n\r\nfindMajor  xs = findMajor\' xs (sum xs)\r\n\r\n\r\n\r\nfindMajor\' [] s = Nothing\r\n\r\nfindMajor\' (x:xs) s = if x > (s-x) then Just x \r\n\r\n			     else findMajor\' xs s\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7765,103,'Artur','2013-11-18 02:40:51',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n\r\n\r\n\r\nfindInLists [] f err = err\r\n\r\nfindInLists (xs:xss) f err = find f xs (findInLists xss f err)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7766,104,'Artur','2013-11-18 02:43:08',1,'doubleEven xs = xs >>= (i -> if even i then [i,i] else [i])\r\n','<br/>Тесты успешно пройдены!'),(7767,88,'641524','2013-11-18 02:43:15',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\n              deriving Show\r\n\r\ndiff (Num n) = Num 0\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Add e1 e2) = (diff e1) + (diff e2)\r\n   --- Почеиу + то тут?? Конечно, дб Add (diff e1) (diff e2)\r\n   --- Но ОК, засчитано.\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))','Выражение имеет неправильное значение: diff (Mult X X)'),(7760,105,'3301494','2013-11-18 02:21:50',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]\r\n','<br/>Тесты успешно пройдены!'),(7761,104,'2501950','2013-11-18 02:21:57',1,'doubleEven xs = xs>>= x -> if x `mod` 2 == 0 \r\n                            then [x,x]\r\n                            else  [x] ','<br/>Тесты успешно пройдены!'),(7762,87,'3301494','2013-11-18 02:22:07',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Num n) m = n\r\n\r\neval (X) m = m\r\n\r\neval (Add a b) m = eval a m + eval b m\r\n\r\neval (Mult a b) m = eval a m * eval b m\r\n','<br/>Тесты успешно пройдены!'),(7763,88,'3301494','2013-11-18 02:22:21',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff (Num n) = (Num 0)\r\n\r\ndiff (X) = (Num 1)\r\n\r\ndiff (Add a b) = (Add (diff a) (diff b))\r\n\r\ndiff (Mult a b) = (Add (Mult (diff a) b)  (Mult a (diff b)))\r\n','<br/>Тесты успешно пройдены!'),(7757,102,'3301494','2013-11-18 02:21:03',1,'findMajor [] = Nothing \r\n\r\nfindMajor xs = let x = maximum xs in if 2 * x > sum xs then Just x else Nothing\r\n','<br/>Тесты успешно пройдены!'),(7758,103,'3301494','2013-11-18 02:21:19',1,'find [] f err = err\r\n\r\nfind (x:xs) f err = if f x then x else find xs f err\r\n\r\n\r\n\r\nfindInLists [] cond def = def\r\n\r\nfindInLists (x:xs) cond def = find x cond (findInLists xs cond def)  \r\n','<br/>Тесты успешно пройдены!'),(7759,104,'3301494','2013-11-18 02:21:34',1,'doubleEven xs = xs >>= i -> if mod i 2 == 0 then [i,i] else [i]\r\n','<br/>Тесты успешно пройдены!'),(7752,104,'641524','2013-11-18 01:58:59',0,'','Не удалось вычислить выражение \"doubleEven [1,2,6,3]\", проверьте правильность синтаксиса'),(7753,104,'641524','2013-11-18 01:59:15',1,'doubleEven xs = xs >>= x -> if x `mod` 2 == 0\r\n\r\n                               then [x,x]\r\n\r\n                               else [x]\r\n','<br/>Тесты успешно пройдены!'),(7754,105,'641524','2013-11-18 02:04:19',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)] \r\n','<br/>Тесты успешно пройдены!'),(7755,103,'2501950','2013-11-18 02:16:18',1,'find f [] err=err\r\nfind f (x:xs) err = if f x \r\n                    then x\r\n                    else find f xs err \r\nfindInLists (xs:xss) cond = find cond xs \r\n                             (find xss cond 0) \r\n   --- если посмотреть пример в задании, то видно, что у findInList не два параметра, как у вас, а три.\r\n   --- (Еще параметр err, как для find)\r\n   --- ОК, засчитано. ','Не удалось вычислить выражение \"findInLists [[1,2], [2,8,7]] (>5) 0\", проверьте правильность синтаксиса'),(7756,87,'641524','2013-11-18 02:17:20',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n\r\n              deriving Show\r\n\r\neval (Num n) _ = n\r\n\r\neval X a = a\r\n\r\neval (Add e1 e2) a = (eval e1 a) + (eval e2 a)\r\n\r\neval (Mult e1 e2) a = (eval e1 a) * (eval e2 a)\r\n','<br/>Тесты успешно пройдены!'),(7748,106,'3226573','2013-11-18 01:18:06',1,'-- Буду честен: решение придумал не сам. Спасибо вот этой статье: http://habrahabr.ru/post/167177/\r\n   --- OK, все в порядке. Я же и сам честно написал, что это известная задача.\r\n\r\nfindCandidate [] candidate _ = candidate\r\nfindCandidate (x:xs) candidate cnt\r\n  | cnt == 0 = findCandidate xs x 1\r\n  | x == candidate = findCandidate xs candidate (cnt + 1)\r\n  | x /= candidate = findCandidate xs candidate (cnt - 1)\r\n\r\ncalcOccurences [] _ cnt = cnt\r\ncalcOccurences (x:xs) y cnt = if (x == y) \r\n	                          then calcOccurences xs y (cnt + 1)\r\n	                          else calcOccurences xs y cnt \r\n\r\nfindMajor [] = Nothing\r\nfindMajor xs = let\r\n                 candidate = findCandidate xs (head xs) 0\r\n                 candidateCnt = calcOccurences xs candidate 0\r\n               in if candidateCnt > (div (length xs) 2) then (Just candidate) else Nothing','<br/>Тесты успешно пройдены!'),(7749,102,'641524','2013-11-18 01:28:36',0,'findMajor xs = let s = sum xs\r\n\n                   res = filter (x -> x > s-x) xs\r\n\n               in if null res then Nothing\r\n\n                              else Just (head res) \n','<br/>Тесты успешно пройдены!'),(7750,102,'641524','2013-11-18 01:37:12',1,'import Data.List\r\n\r\n\r\n\r\nfindMajor xs = find (x -> x > (sum xs)-x) xs \r\n','<br/>Тесты успешно пройдены!'),(7751,103,'641524','2013-11-18 01:53:03',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n\r\n\r\n\r\nfindInLists [] _ err = err\r\n\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)  \r\n','<br/>Тесты успешно пройдены!'),(7746,97,'3226573','2013-11-18 00:27:31',1,'check [] xs = length xs == 0\r\ncheck (x:xs) stack\r\n  | x == \'(\' = check xs (1:stack)\r\n  | x == \'[\' = check xs (2:stack)\r\n  | x == \')\' = if (length stack > 0) && (head stack == 1) then check xs (tail stack) else False\r\n  | x == \']\' = if (length stack > 0) && (head stack == 2) then check xs (tail stack) else False\r\n\r\ncheckBrackets xs = (mod (length xs) 2) == 0 && check xs []','<br/>Тесты успешно пройдены!'),(7747,102,'2501950','2013-11-18 01:15:55',1,'findMajor (x:xs) = findMajor\' (x:xs) sum xs \r\n   --- Тут нужны скобки вокруг sum xs.\r\n   --- Но ОК, засчитано.\r\nfindMajor\' [] s = Nothing\r\nfindMajor\' (x:xs) s  = if x > (s - x) \r\n                       then Just x\r\n                       else findMajor\' xs s ','Не удалось вычислить выражение \"findMajor [2,3,15,2,2,2]\", проверьте правильность синтаксиса'),(7743,88,'3226573','2013-11-17 23:56:30',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff (Num val) = Num 0\r\ndiff (X) = Num 1\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))','<br/>Тесты успешно пройдены!'),(7744,88,'nbumakov','2013-11-18 00:05:30',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff (Num n) = Num 0\r\ndiff (X) = Num 1  \r\ndiff (Add expr1 expr2) = Add (diff expr1) (diff expr2)\r\ndiff (Mult expr1 expr2) = Add (Mult (diff expr1) expr2) (Mult expr1 (diff expr2)) ','<br/>Тесты успешно пройдены!'),(7745,108,'3226573','2013-11-18 00:15:23',1,'queens\' _ 0 _ = [[]]\r\nqueens\' n k cond = [(k,x):xs | x <- [1..n], cond (k, x), \r\n                           xs <- queens\' n (k - 1) ((col, row) -> cond (col, row) &&\r\n                           	                                       x /= row &&\r\n                           	                                       (col + row) /= (k + x) &&\r\n                           	                                       (col - row) /= (k - x))]\r\n\r\nqueens n k = queens\' n k (	 -> True)','<br/>Тесты успешно пройдены!'),(7740,103,'617015','2013-11-17 23:43:33',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f(x) then x \r\n\r\n			    else find f xs err\r\n\r\n\r\n\r\nfindInLists [] f err = err\r\n\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)\r\n\r\n\r\n\r\n\r\n\r\n							\r\n','<br/>Тесты успешно пройдены!'),(7741,87,'nbumakov','2013-11-17 23:46:12',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\neval (Num n) _ = n \r\neval (X) x = x \r\neval (Add expr1 expr2) x = eval expr1 x + eval expr2 x\r\neval (Mult expr1 expr2) x = eval expr1 x * eval expr2 x  ','<br/>Тесты успешно пройдены!'),(7742,87,'3226573','2013-11-17 23:49:02',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (Num val) x = val\r\neval (X) x = x\r\neval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\neval (Mult e1 e2) x = (eval e1 x) * (eval e2 x)','<br/>Тесты успешно пройдены!'),(7737,104,'3226573','2013-11-17 23:37:05',1,'doubleEven xs = xs >>= (x -> if (mod x 2) == 0 then [x,x] else [x])','<br/>Тесты успешно пройдены!'),(7738,105,'3226573','2013-11-17 23:40:49',1,'cartesian xs ys = xs >>= (x -> ys >>= (y -> [(x,y)]))','<br/>Тесты успешно пройдены!'),(7739,88,'anna','2013-11-17 23:43:05',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\ndiff X = Num 1\r\ndiff (Num _) = Num 0\r\ndiff (Add s1 s2) = Add (diff s1) (diff s2)\r\ndiff (Mult m1 m2) = Add (Mult (diff m1) m2) (Mult m1 (diff m2))','<br/>Тесты успешно пройдены!'),(7735,103,'3226573','2013-11-17 23:32:41',1,'find f [] err = err\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\nfindInLists [] _ err = err\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)','<br/>Тесты успешно пройдены!'),(7736,87,'anna','2013-11-17 23:34:28',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval X n = n\r\neval (Num n) _ = n\r\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\neval (Mult m1 m2) n = eval m1 n * eval m2 n','<br/>Тесты успешно пройдены!'),(7733,87,'ip','2013-11-17 23:23:04',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n                                               deriving Show\r\n\r\n\r\n\r\neval (Num i) x = i\r\n\r\neval X x = x\r\n\r\neval (Add a b) x = (eval a x) + (eval b x) \r\n\r\neval (Mult a b) x = (eval a x) * (eval b x)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7734,88,'ip','2013-11-17 23:29:31',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n                                               deriving Show\r\n\r\n\r\n\r\n\r\n\r\ndiff (Num i) = Num 0\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Add a b) = (Add (diff a) (diff b))\r\n\r\ndiff (Mult a b) = Add (Mult(diff a) b) (Mult a (diff b))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7732,102,'3226573','2013-11-17 23:18:18',1,'findMajor\' [] _ = Nothing\r\nfindMajor\' (x:xs) threshold = if x > threshold then Just x else findMajor\' xs threshold\r\n\r\nfindMajor xs = findMajor\' xs (div (sum xs) 2)','<br/>Тесты успешно пройдены!'),(7731,105,'ip','2013-11-17 23:12:02',1,'cartesian xs ys = xs >>= (x -> (ys >>= (y -> [(x,y)])) )\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7729,105,'nbumakov','2013-11-17 22:43:29',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x, y)]','<br/>Тесты успешно пройдены!'),(7730,104,'ip','2013-11-17 22:53:13',1,'doubleEven xs = xs >>= (x->if (mod x 2 == 0)\r\n                            then [x,x]\r\n                            else [x]) ','<br/>Тесты успешно пройдены!'),(7727,103,'nbumakov','2013-11-17 22:42:46',1,'find f [] err = err\r\nfind f (x:xs) err = if f x \r\n                    then x \r\n                    else find f xs err\r\n\r\nfindInLists [] cond err = err  \r\nfindInLists (x:xs) cond err = \r\n   find cond x\r\n   (\r\n      findInLists xs cond err\r\n   )\r\n   \r\n-- findInLists xs cond err = foldr (find cond) err xs\r\n  --- И правда, а я не замечал, здорово!','<br/>Тесты успешно пройдены!'),(7728,104,'nbumakov','2013-11-17 22:43:12',1,'doubleEven xs = xs >>= x -> if even x then [x, x] else [x]','<br/>Тесты успешно пройдены!'),(7726,102,'nbumakov','2013-11-17 22:42:26',1,'findMajor xs =\r\n  let\r\n  s = sum xs\r\n  f =  filter (x-> x > s-x) xs\r\n  in if not (null f)\r\n     then Just ( head f) \r\n     else Nothing','<br/>Тесты успешно пройдены!'),(7724,88,'artem.gomerman','2013-11-17 22:14:49',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff (Num a) = Num 0\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Add expr1 expr2) = Add (diff expr1) (diff expr2)\r\n\r\ndiff (Mult expr1 expr2) = Add (Mult (diff expr1) expr2) (Mult expr1 (diff expr2))\r\n','<br/>Тесты успешно пройдены!'),(7725,103,'ip','2013-11-17 22:17:20',1,'--- На самом деле можно проще (см слайды 11 занятия). Но ОК, засчитано.\r\nfind f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n                    else find f xs err\r\n\r\n\r\n\r\nfindInLists xs f err = head (findInLists2 xs f err)\r\n\r\n\r\n\r\nfindInLists2 [] f err = []\r\n\r\nfindInLists2 (x:xs) f err = [find (/=err) ([(find f x err)]++(findInLists2 xs f err)) err]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7723,88,'artem.gomerman','2013-11-17 22:14:01',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\ndiff (Num a) = Num 0\r\n\ndiff X = Num 1\r\n\ndiff (Add expr1 expr2) = Add (diff expr1) (diff expr2)\r\n\ndiff (Mult expr1 expr2) = Add (Mult (diff expr1) expr2) (Mult (diff expr2) expr1)\n','Выражение имеет неправильное значение: diff (Mult X X)'),(7722,87,'artem.gomerman','2013-11-17 22:11:08',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Num a) _ = a\r\n\r\neval X x = x\r\n\r\neval (Add expr1 expr2) x = (eval expr1 x) + (eval expr2 x)\r\n\r\neval (Mult expr1 expr2) x = (eval expr1 x) * (eval expr2 x)\r\n','<br/>Тесты успешно пройдены!'),(7721,105,'artem.gomerman','2013-11-17 22:07:07',1,'--- Зачтено, но вообще это не по условию. Там же написано: не использовать list comprehension.\r\ncartesian xs ys = xs >>= x -> [(x, y) | y <- ys]\r\n','<br/>Тесты успешно пройдены!'),(7719,103,'artem.gomerman','2013-11-17 22:02:36',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n					else find f xs err\r\n\r\n\r\n\r\nfindInLists [] _ err = err\r\n\r\nfindInLists xxs cond err = find cond (head xxs) (findInLists (tail xxs) cond err)\r\n','<br/>Тесты успешно пройдены!'),(7720,104,'artem.gomerman','2013-11-17 22:04:44',1,'doubleEven xs = xs >>= x -> if even x then [x, x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7718,102,'artem.gomerman','2013-11-17 21:56:17',1,'findMajor [] = Nothing\r\n\r\nfindMajor xs = findMajor\' (sum xs) (head xs) (tail xs)\r\n\r\nfindMajor\' _ _ [] = Nothing\r\n\r\nfindMajor\' s x xs = if s - 2 * x < 0 then Just x else findMajor\' s (head xs) (tail xs)\r\n','<br/>Тесты успешно пройдены!'),(7715,97,'3320654','2013-11-17 21:35:32',1,'checkBrackets list = help list []\r\n\r\nhelp [] [] = True\r\nhelp [] stack = False\r\nhelp (x:xs) stack = 	if x == \'[\'\r\n		then help xs (x:stack)\r\n		else	if x == \'(\'\r\n			then help xs (x:stack)\r\n			else	if (length stack == 0)\r\n				then False\r\n				else	if x == \']\'\r\n					then 	if (head stack) == \'[\'\r\n						then help xs (tail stack)\r\n						else False\r\n					else	if x == \')\'\r\n						then	if (head stack) == \'(\'\r\n							then help xs (tail stack)\r\n							else False\r\n						else False','<br/>Тесты успешно пройдены!'),(7716,103,'617015','2013-11-17 21:37:56',0,'find f [] err = err\r\n\nfind f (x:xs) err = if f(x) then x \r\n\n			    else find f xs err\r\n\n				\r\n\nfindInLists f (x:xs) 0 = find f x (findInLists f xs 0)\r\n\n{--\r\n\nОшибка компиляции:\r\n\n\r\n\nERROR - Type error in application\r\n\n*** Expression     : findInLists [[1,8,2],[2,7]] (flip (<) 5) 0\r\n\n*** Term           : flip (<) 5\r\n\n*** Type           : b -> Bool\r\n\n*** Does not match : [[a]]\r\n\n\r\n\n\r\n\nподскажите, пожалуйста, что не так, не могу понять\r\n\n--}\r\n\n\r\n\n							\n','Не удалось вычислить выражение \"findInLists [[1,2], [2,8,7]] (>5) 0\", проверьте правильность синтаксиса'),(7717,102,'ip','2013-11-17 21:44:38',1,'findMajor xs = findMajor2 xs (sum xs)\r\n\r\n\r\n\r\n\r\n\r\nfindMajor2 [] t = Nothing\r\n\r\nfindMajor2 (x:xs) t = if x > (t-x)\r\n\r\n                      then Just x\r\n\r\n                      else findMajor2 xs t\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7712,105,'617015','2013-11-17 21:33:39',1,'cartesian  xs ys = xs >>= x->  ys >>= y->[(x,y)]\r\n','<br/>Тесты успешно пройдены!'),(7713,87,'617015','2013-11-17 21:33:58',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving Show\r\n\r\n	\r\n\r\neval X x = x\r\n\r\neval (Num k) x = k\r\n\r\neval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\n\r\neval (Mult e1 e2) x = (eval e1 x) * (eval e2 x)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7714,88,'617015','2013-11-17 21:34:23',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n	deriving Show\r\n\r\n	\r\n\r\ndiff X = (Num 1)\r\n\r\ndiff (Num k) = (Num 0)\r\n\r\ndiff (Add e1 e2) = (Add (diff e1)  (diff e2) )\r\n\r\ndiff (Mult e1 e2) = (Add (Mult (diff e1)  e2)   (Mult e1 (diff e2)))\r\n','<br/>Тесты успешно пройдены!'),(7711,104,'617015','2013-11-17 21:33:08',1,'doubleEven xs= xs >>= x-> if x`mod`2==0 then [x,x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7710,102,'617015','2013-11-17 21:32:44',1,'\r\nfindMajor xs = findMajor\' xs (sum xs)\r\n\r\nfindMajor\' [] i = Nothing\r\n\r\nfindMajor\' (x:xs) i = if  x> (i-x) then Just x else findMajor\' xs i \r\n','<br/>Тесты успешно пройдены!'),(7707,105,'MaryK','2013-11-17 20:59:39',0,'cartesian xs ys = xs >>= (y->ys >>= x->[(x,y)])\n','Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),(7708,105,'MaryK','2013-11-17 21:01:01',1,'cartesian xs ys = xs >>= (x->ys >>= y->[(x,y)])\r\n','<br/>Тесты успешно пройдены!'),(7709,88,'3320654','2013-11-17 21:15:40',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving (Show, Eq)\r\n\r\ndiff (Num t)	= Num 0\r\ndiff (X)		= Num 1\r\ndiff (Add x y)	= Add (diff x) (diff y)\r\ndiff (Mult x y)	= Add (Mult (diff x) y) (Mult x (diff y))','<br/>Тесты успешно пройдены!'),(7706,103,'480387','2013-11-17 20:58:45',1,'find _ [] err = err\r\nfind f (x:xs) err = if f x then x \r\n			    else find f xs err\r\nfil [] _ err = err\r\nfil (xs:xss) cond err = \r\n	find cond xs (fil xss cond err) \r\n\r\nfindInLists = fil','<br/>Тесты успешно пройдены!'),(7701,102,'480387','2013-11-17 20:30:08',1,'findMajor ls = findMajor\' ls (sum ls)\r\nfindMajor\' [] n = Nothing\r\nfindMajor\' (l:ls) n = if (2*l > n) then Just l else findMajor\' ls n','<br/>Тесты успешно пройдены!'),(7702,105,'3320654','2013-11-17 20:31:24',1,'cartesian l1 l2 = l1 >>= x -> l2 >>= y -> [(x,y)]','<br/>Тесты успешно пройдены!'),(7703,103,'480387','2013-11-17 20:43:50',0,'fil _ 0 = 0\r\nfil cond (xs:xss) = \r\n	find cond xs (fil cond xss)','Не удалось вычислить выражение \"findInLists [[1,2], [2,8,7]] (>5) 0\", проверьте правильность синтаксиса'),(7704,103,'480387','2013-11-17 20:44:45',0,'findInLists = fil\r\nfil _ 0 = 0\r\nfil cond (xs:xss) = \r\n	find cond xs (fil cond xss)','Не удалось вычислить выражение \"findInLists [[1,2], [2,8,7]] (>5) 0\", проверьте правильность синтаксиса'),(7705,87,'3320654','2013-11-17 20:46:45',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving (Show, Eq)\r\n\r\neval (Num t) _	= t\r\neval (X) k		= k\r\neval (Add x y) k	= eval x k + eval y k\r\neval (Mult x y) k	= eval x k * eval y k','<br/>Тесты успешно пройдены!'),(7698,102,'3320654','2013-11-17 20:13:12',1,'findMajor list 	= help list (sum list)\r\n\r\nhelp [] _		= Nothing\r\nhelp (x:xs)	sl	= if 2 * x > sl\r\n		   then Just x\r\n		   else help xs sl','<br/>Тесты успешно пройдены!'),(7699,103,'3320654','2013-11-17 20:24:10',1,'find f [] err 	= err\r\nfind f (x:xs) err 	= if f x \r\n		   then x \r\n		   else find f xs err\r\n\r\nfindInLists [] _ err 	= err\r\nfindInLists (x:xs) f err	= find f x (findInLists xs f err)','<br/>Тесты успешно пройдены!'),(7700,104,'3320654','2013-11-17 20:27:37',1,'doubleEven list = list >>= x -> 	if mod x 2 == 0\r\n			then [x,x]\r\n			else [x]','<br/>Тесты успешно пройдены!'),(7692,103,'MaryK','2013-11-17 19:26:23',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n\r\n\r\n\r\nfindInLists [] _ err = err\r\n\r\n\r\n\r\nfindInLists (x:xs) cond err = \r\n\r\n	find (cond) x \r\n\r\n		(\r\n\r\n			findInLists xs cond err\r\n\r\n		)\r\n','<br/>Тесты успешно пройдены!'),(7693,87,'ArtemK','2013-11-17 19:48:16',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\neval (Num n) _ = n\r\neval (X) x = x\r\neval (Add l r) x = (eval l x) + (eval r x)\r\neval (Mult l r) x = (eval l x) * (eval r x)','<br/>Тесты успешно пройдены!'),(7694,104,'MaryK','2013-11-17 19:48:55',1,'doubleEven:: [Integer]->[Integer]\r\n\r\ndoubleEven xs = xs >>= x-> if ((x `mod` 2) == 0) then [x,x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7695,104,'ArtemK','2013-11-17 19:50:51',1,'doubleEven xs = xs >>= x -> if mod x 2 == 0 then [x, x] else [x]','<br/>Тесты успешно пройдены!'),(7696,103,'ArtemK','2013-11-17 19:56:58',0,'findInLists [] _ err = err\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)','Не удалось вычислить выражение \"findInLists [[1,2], [2,8,7]] (>5) 0\", проверьте правильность синтаксиса'),(7697,103,'ArtemK','2013-11-17 19:57:21',1,'find f [] err = err\r\nfind f (x:xs) err = if f x then x \r\n          else find f xs err\r\n\r\nfindInLists [] _ err = err\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)','<br/>Тесты успешно пройдены!'),(7690,102,'MaryK','2013-11-17 18:57:20',1,'findMajor [] = Nothing\r\n\r\nfindMajor (x:xs) = if length(ff (x:xs))>0 then Just k else Nothing where k = head(ff(x:xs))\r\n\r\nff (x:xs) = filter (x->(k-x)<x) (x:xs) where k = sum (x:xs)\r\n','<br/>Тесты успешно пройдены!'),(7691,110,'ArtemK','2013-11-17 19:23:24',1,'# Python\r\n\r\ndef find(predicate, xs, err):\r\n    for x in xs:\r\n        if predicate(x):\r\n            return x\r\n    return err()\r\n\r\n\r\ndef special_find(xs):\r\n    err100 = lambda: find(lambda x: x > 100, xs, lambda: 0)\r\n    err500 = lambda: find(lambda x: x > 500, xs, err100)\r\n    return find(lambda x: x > 1000, xs, err500)\r\n\r\nprint(special_find([1, 2, 3]))\r\n# 0\r\nprint(special_find([100, 200, 300]))\r\n# 200\r\nprint(special_find([1000, 200, 300]))\r\n# 1000\r\nprint(special_find([1000, 2000, 3000]))\r\n# 2000','<br/>Тесты успешно пройдены!'),(7689,109,'ArtemK','2013-11-17 18:54:05',1,'# Python\r\n\r\ndef all_diff_lists(n, k, to_string, is_used):\r\n    if k == 0:\r\n        print(to_string())\r\n        return\r\n\r\n    for cur in [x for x in xrange(1, n + 1) if not is_used(x)]:\r\n        all_diff_lists(n, k - 1, lambda: to_string() + \' \' + str(cur), lambda x: is_used(x) or x == cur)\r\n\r\n\r\ndef allDiffLists(n, k):\r\n    all_diff_lists(n, k, lambda: \'\', lambda x: False)\r\n\r\n\r\nallDiffLists(3, 2)','<br/>Тесты успешно пройдены!'),(7687,104,'anna','2013-11-17 17:05:32',1,'doubleEven xs = xs >>= x-> if  mod x 2 == 0 then [x,x] else [x]','<br/>Тесты успешно пройдены!'),(7688,105,'anna','2013-11-17 17:39:56',1,'cartesian xs ys = xs >>= x -> ys >>= y-> [(x,y)]','<br/>Тесты успешно пройдены!'),(7685,102,'anna','2013-11-17 15:59:26',1,'findMajor xs = findMajor\' xs (sum xs)\r\nfindMajor\' [] _ = Nothing\r\nfindMajor\' (x:xs) s = if 2*x > s then Just x else findMajor\' xs s','<br/>Тесты успешно пройдены!'),(7686,103,'anna','2013-11-17 16:40:28',1,'find cond [] err = err\r\nfind cond (x:xs) err = if cond x then x else find cond xs err\r\n\r\nfindInLists [] _ z = z\r\nfindInLists (x:xs) y z = find y x (findInLists xs y z)','<br/>Тесты успешно пройдены!'),(7683,87,'5247795','2013-11-17 14:31:00',1,'\r\n\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Num n) _ = n\r\n\r\neval X n = n\r\n\r\n\r\n\r\neval (Add x1 x2) n = eval x1 n + eval x2 n\r\n\r\n\r\n\r\neval (Mult x1 x2) n = eval x1 n * eval x2 n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7684,88,'5247795','2013-11-17 14:55:22',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff (Num _) = Num 0\r\n\r\ndiff X = Num 1\r\n\r\n\r\n\r\ndiff (Add x1 x2) = Add (diff x1) (diff x2)\r\n\r\n\r\n\r\ndiff (Mult x1 x2) = Add (Mult (diff x1) x2) (Mult x1 (diff x2))\r\n','<br/>Тесты успешно пройдены!'),(7678,103,'8519021','2013-11-17 14:00:44',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\n\r\n\r\nfindInLists [] f err = err\r\n\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7679,104,'8519021','2013-11-17 14:01:49',1,'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x, x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7680,105,'8519021','2013-11-17 14:02:41',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x, y)]\r\n','<br/>Тесты успешно пройдены!'),(7681,87,'8519021','2013-11-17 14:03:38',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval X x = x\r\n\r\neval (Num z) x = z\r\n\r\neval (Add a b) x = (eval a x) + (eval b x)\r\n\r\neval (Mult a b) x = (eval a x) * (eval b x)\r\n','<br/>Тесты успешно пройдены!'),(7682,88,'8519021','2013-11-17 14:05:00',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Num z) = Num 0\r\n\r\ndiff (Add a b) = Add (diff a) (diff b)\r\n\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))\r\n','<br/>Тесты успешно пройдены!'),(7674,102,'toskira','2013-11-17 13:42:45',1,'import Data.List \r\n\r\nfindMajor [] = Nothing\r\nfindMajor l = let (h:t) = sortBy (flip compare) l\r\n              in if h > sum t then Just h else Nothing','<br/>Тесты успешно пройдены!'),(7675,88,'284427','2013-11-17 13:46:27',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n		deriving Show\r\n\r\n\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Num _) = Num 0\r\n\r\ndiff (Add ex1 ex2) = Add (diff ex1) (diff ex2)\r\n\r\ndiff (Mult ex1 ex2) = Add (Mult (diff ex1) ex2) (Mult ex1 (diff ex2))\r\n','<br/>Тесты успешно пройдены!'),(7676,105,'5247795','2013-11-17 13:58:04',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]\r\n','<br/>Тесты успешно пройдены!'),(7677,108,'5543298','2013-11-17 13:58:53',1,'uniSet n 0 _ = [[]]	\r\n\r\nuniSet n k ys = [x:xs | x <- [1..n], not (elem x ys), xs <- uniSet n (k-1) (x:ys)]\r\n\r\nqueens\' _ [] s = s\r\n\r\nqueens\' cond (x:xs) s =  if cond x then queens\' cond xs (x:s) else queens\' cond xs s\r\n\r\nqueens n k = let all = map (xs -> zip [1..k] xs) (uniSet n k []) in queens\' (xs -> c n k (x y -> True) xs) all []\r\n\r\n\r\n\r\nc n k cond [] = True\r\n\r\nc n k cond ((x,y):xs) = if not (cond x y) then False else c n k (a b -> cond a b && not (elem (a,b) (f x y n k))) xs\r\n\r\nf x y n k = [(a,b)| a <- [1..k], b <-[1..n], a == x || b == y || (a - x) == (b - y) || (x - a) == (b - y)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7672,105,'284427','2013-11-17 13:34:40',1,'cartesian [] _ = []\r\n\r\ncartesian _ [] = []\r\n\r\ncartesian xs ys = xs >>= x -> (ys >>= y -> [(x,y)])\r\n','<br/>Тесты успешно пройдены!'),(7673,87,'284427','2013-11-17 13:42:12',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n\r\n		deriving Show\r\n\r\n\r\n\r\neval X num = num\r\n\r\neval (Num num) _ = num\r\n\r\neval (Add ex1 ex2) num = (eval ex1 num) + (eval ex2 num)\r\n\r\neval (Mult ex1 ex2) num = (eval ex1 num) * (eval ex2 num)\r\n','<br/>Тесты успешно пройдены!'),(7671,104,'284427','2013-11-17 13:30:56',1,'doubleEven xs = xs >>= x -> if (mod x 2) == 0 then [x,x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7668,104,'5247795','2013-11-17 13:11:45',1,'doubleEven xs = xs >>= x -> if (x `mod` 2 == 0) then [x,x] \r\n\r\n			else [x]\r\n','<br/>Тесты успешно пройдены!'),(7669,102,'284427','2013-11-17 13:20:03',1,'findMajor xs = findM xs (sum xs)\r\n\r\nfindM [] _ = Nothing\r\n\r\nfindM (x:xs) summ = if x > (summ - x) then Just x else findM xs summ\r\n','<br/>Тесты успешно пройдены!'),(7670,103,'284427','2013-11-17 13:27:47',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\n\r\n\r\nfindInLists [] _ err_res = err_res\r\n\r\nfindInLists (x:xs) f err_res = find f x (findInLists xs f err_res)\r\n','<br/>Тесты успешно пройдены!'),(7666,103,'nomeansno','2013-11-17 12:55:55',0,'find f [] err = err\n\nfind f (x:xs) err = if f x then x else find f xs err\n\n\n\nfindLists [] _ err = err\n\nfindLists (x:xs) cond err = find cond x (findLists xs cond err) \n\n\n','Не удалось вычислить выражение \"findInLists [[1,2], [2,8,7]] (>5) 0\", проверьте правильность синтаксиса'),(7667,103,'nomeansno','2013-11-17 12:57:27',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\n\r\n\r\nfindInLists [] _ err = err\r\n\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7663,87,'nomeansno','2013-11-17 12:54:00',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\neval (Num i) _ = i\r\n\r\neval X x = x\r\n\r\neval (Add e1 e2) x = eval e1 x + eval e2 x\r\n\r\neval (Mult e1 e2) x = eval e1 x * eval e2 x\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7664,105,'nomeansno','2013-11-17 12:54:20',1,'cartesian s1 s2 = s1 >>= x -> (s2 >>= y -> [(x,y)])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7665,104,'nomeansno','2013-11-17 12:54:39',1,'doubleEven s = s >>= x -> if x `mod` 2 == 0 then [x,x] else [x]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7660,102,'5247795','2013-11-17 12:37:37',1,'findMajor xs = findMajor\' 0 xs\r\n\r\nfindMajor\' _ [] = Nothing\r\n\r\nfindMajor\' sum (x:xs) = if x > (sum + foldr (+) 0 xs) then Just x\r\n\r\n			else findMajor\' (sum + x) xs\r\n','<br/>Тесты успешно пройдены!'),(7661,103,'5247795','2013-11-17 12:50:52',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n\r\nfindInLists [] cond 0 = 0\r\n\r\nfindInLists (xs:xss) cond 0 = find (cond) xs (findInLists xss cond 0)\r\n   --- Но только тут правильнее всюду не 0, а тоже err  \r\n','<br/>Тесты успешно пройдены!'),(7662,88,'nomeansno','2013-11-17 12:53:25',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving (Show, Eq)\r\n\r\n\r\n\r\ndiff (Num _) = (Num 0)\r\n\r\ndiff X = (Num 1)\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add e1\' e2\'\r\n\r\n	where e1\' = Mult (diff e1) e2; e2\' = Mult e1 (diff e2) \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7659,110,'5543298','2013-11-17 01:11:39',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"31.1\":\r\n\r\n                    {\r\n\r\n                        var arr1 = new int[] { 1, 2, 3, 5, 6, 20, 21 };\r\n\r\n                        var arr2 = new int[] { 1, 2, 3, 5, 6, 20, 21 };\r\n\r\n                        var arr3 = new int[] { 1, 2, 3, 5, 6, 20, 21, 101 };\r\n\r\n                        var res1 = find(x => x > 20, arr1, () => 0);\r\n\r\n                        // Ищем число >20, а если не найдем, возвращаем 0\r\n\r\n                        var res2 = find(x => x > 20, arr2, () =>\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(\"Not found\");\r\n\r\n                            return 0;\r\n\r\n                        });\r\n\r\n                        // Ищем число >20, а если не найдем, печатаем сообщение и возвращаем 0\r\n\r\n                        var res3 = find (x => x > 1000, arr3, () => find (x => x > 500, arr3, () => find(x => x > 100, arr3, () => 0)));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"28.1\":\r\n\r\n                    {\r\n\r\n                        allDiffLists(3, 2)();\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"26.1\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8, 9, 10 };\r\n\r\n                        int[] b = { 3, 5, 9, 5, 6 };\r\n\r\n                        Console.WriteLine(allDifferent(a));\r\n\r\n                        Console.WriteLine(allDifferent(b));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"26.2\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8 };\r\n\r\n                        int[] b = { 3, 5, 9 };\r\n\r\n                        foreach (int i in Merge(a, b))\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"23.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var num in Lst137())\r\n\r\n                        {\r\n\r\n                            Console.Write(\"{0}, \", num);\r\n\r\n                            k++;\r\n\r\n                            if (k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"20.2\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var pair in cantor())\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(pair);\r\n\r\n                            k++;\r\n\r\n                            if (k == 50)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err) \r\n\r\n        {\r\n\r\n            foreach (var i in a)\r\n\r\n            {\r\n\r\n                if (func(i))\r\n\r\n                    return i;\r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static Action allDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            Action print = () => { };\r\n\r\n            Predicate<int> set = t => true;\r\n\r\n            allDiffLists(print, set, 1, n, k);\r\n\r\n            return print;\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void allDiffLists(Action print, Predicate<int> set, int current, int n, int k)\r\n\r\n        {\r\n\r\n            \r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (a.Length == from)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            var x = a[from];\r\n\r\n            if (!cond(x))\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            return allDifferent1(a, ++from, t => cond(t) && t != x);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var result = new List<int>();\r\n\r\n            var aen = a.GetEnumerator();\r\n\r\n            var ben = b.GetEnumerator();\r\n\r\n            var isAEmpty = !aen.MoveNext();\r\n\r\n            var isBEmpty = !ben.MoveNext();\r\n\r\n            int x, y;\r\n\r\n            while (!isAEmpty && !isBEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                y = ben.Current;\r\n\r\n                if (x < y)\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                }\r\n\r\n                else if (y < x)\r\n\r\n                {\r\n\r\n                    result.Add(y);\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                } \r\n\r\n                else\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            while (!isAEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                result.Add(x);\r\n\r\n                isAEmpty = !aen.MoveNext();\r\n\r\n            }\r\n\r\n            while (!isBEmpty)\r\n\r\n            {\r\n\r\n                y = ben.Current;\r\n\r\n                result.Add(y);\r\n\r\n                isBEmpty = !ben.MoveNext();\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                var next = i * 10;\r\n\r\n                yield return next + 1;\r\n\r\n                yield return next + 3;\r\n\r\n                yield return next + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var resPowN = new BigInteger(0);\r\n\r\n            var left = new BigInteger(1);\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                left *= 10;\r\n\r\n                var min = left - resPowN * 10 * n;\r\n\r\n                var minIndex = 0;\r\n\r\n                for (int j = 1; j < 10; j++)\r\n\r\n                {\r\n\r\n                    var current = left - (resPowN * 10 + j) * n;\r\n\r\n                    if (current < min && current > 0)\r\n\r\n                    {\r\n\r\n                        min = current;\r\n\r\n                        minIndex = j;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                resPowN = resPowN * 10 + minIndex;\r\n\r\n                yield return minIndex;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7658,108,'5543298','2013-11-17 00:49:34',2,'--- У вас тесты не проходят из-за того, что программа для 8 8 слишком долго считает.\r\n--- Я бы вам советовал воспользоваться тем, что написано в условии - что мы считаем,\r\n--- что первый ферзь стоит на первой вертикали, второй - на второй и т.д.\r\n--- Это значит, что при рекурсии надо перебирать варианты только для горизонтали\r\n--- А вертикаль мы для каждого очередного ферзя просто можем вычилить.\r\n--- Тогда перебор получиться гораздо меньше.\r\nuniSet n 0 _ _ = [[]]	\r\n\r\nuniSet n k m ys = [(m, x):xs | x <- [1..n], xs <- uniSet n (k-1) (m + 1) (x:ys)]\r\n\r\nqueens\' _ [] s = s\r\n\r\nqueens\' cond (x:xs) s =  if cond x then queens\' cond xs (x:s) else queens\' cond xs s\r\n\r\nqueens n k = let all = uniSet n k 1 [] in queens\' (xs -> c n k (x y -> True) xs) all []\r\n\r\n\r\n\r\nc n k cond [] = True\r\n\r\nc n k cond ((x,y):xs) = if not (cond x y) then False else c n k (a b -> cond a b && not (elem (a,b) (f x y n k))) xs\r\n\r\nf x y n k = [(a,b)| a <- [1..k], b <-[1..n], a == x || b == y || (a - x) == (b - y) || (x - a) == (b - y)]\r\n\r\n\r\n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7654,104,'5543298','2013-11-16 23:04:19',0,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]\n','Не удалось вычислить выражение \"doubleEven [1,2,6,3]\", проверьте правильность синтаксиса'),(7655,104,'5543298','2013-11-16 23:07:53',1,'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x,x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7656,102,'nomeansno','2013-11-16 23:22:01',1,'findMajor\' [] _ = Nothing\r\n\r\nfindMajor\' (x:xs) y = if y<2*x then Just x else findMajor\' xs y\r\n\r\n\r\n\r\nfindMajor s = findMajor\' s y\r\n\r\n	where y = sum s \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7657,110,'ilia','2013-11-16 23:37:57',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\ndef Find(f, s, e):\r\n\r\n	for si in s:\r\n\r\n		if f(si): return si\r\n\r\n	return e()\r\n\r\n\r\n\r\ns = [ 1, 10, 102, 405, 503, 978 ]\r\n\r\nprint Find(lambda si: si > 1000, s, \r\n\r\n		lambda: Find(lambda si: si > 500, s,\r\n\r\n			lambda: Find(lambda si: si > 100, s, lambda: 0)))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7652,88,'55363692','2013-11-16 22:39:27',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff expr = case expr of\r\n\r\n	Num x -> Num 0\r\n\r\n	X -> Num 1\r\n\r\n	Add expr1 expr2 -> Add (diff expr1) (diff expr2)\r\n\r\n	Mult expr1 expr2 -> Add (Mult (diff expr1) expr2) (Mult expr1 (diff expr2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7653,88,'5543298','2013-11-16 22:40:37',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Num a) b = a\r\n\r\neval (X) b = b\r\n\r\neval (Add x y) b = eval x b + eval y b\r\n\r\neval (Mult x y) b = eval x b * eval y b\r\n\r\n\r\n\r\ndiff (Num a) = (Num 0)\r\n\r\ndiff (X) = (Num 1)\r\n\r\ndiff (Add x y) = (Add (diff x) (diff y))\r\n\r\ndiff (Mult x y) = (Add (Mult (diff x) x)  (Mult y (diff y)))\r\n','<br/>Тесты успешно пройдены!'),(7650,87,'55363692','2013-11-16 22:35:19',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval expr val = case expr of\r\n\r\n	Num x -> x\r\n\r\n	X -> val\r\n\r\n	Add expr1 expr2 -> (eval expr1 val) + (eval expr2 val)\r\n\r\n	Mult expr1 expr2 -> (eval expr1 val) * (eval expr2 val)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7651,88,'5543298','2013-11-16 22:39:12',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\neval (Num a) b = a\r\n\neval (X) b = b\r\n\neval (Add x y) b = eval x b + eval y b\r\n\neval (Mult x y) b = eval x b * eval y b\r\n\n\r\n\ndiff (Num a) = (Num 0)\r\n\ndiff (X) = (Num 1)\r\n\ndiff (Add x y) = (Add (diff x) (diff y))\r\n\ndiff (Mult x y) = (Add (Mult x (diff x))  (Mult y (diff y)))\n','Выражение имеет неправильное значение: diff (Mult X X)'),(7647,104,'55363692','2013-11-16 22:26:47',1,'doubleEven xs = xs >>= (x -> if x `mod` 2 == 0 then [x, x] else [x])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7648,105,'55363692','2013-11-16 22:31:29',1,'cartesian xs ys = xs >>= (x -> (ys >>= (y -> [(x, y)])))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7649,88,'5543298','2013-11-16 22:32:30',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\neval (Num a) b = a\r\n\neval (X) b = b\r\n\neval (Add x y) b = eval x b + eval y b\r\n\neval (Mult x y) b = eval x b * eval y b\r\n\n\r\n\ndiff (Num a) = Num 0\r\n\ndiff (X) = Num 1\r\n\ndiff (Add x y) = Add (diff x) (diff y)\r\n\ndiff (Mult x y) = Add ((diff x) * x)  ((diff y) * y)\n','Не удалось вычислить выражение \"diff (Mult X X)\", проверьте правильность синтаксиса'),(7644,87,'5543298','2013-11-16 22:07:38',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Num a) b = a\r\n\r\neval (X) b = b\r\n\r\neval (Add x y) b = eval x b + eval y b\r\n\r\neval (Mult x y) b = eval x b * eval y b\r\n','<br/>Тесты успешно пройдены!'),(7645,103,'55363692','2013-11-16 22:24:43',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\n\r\n\r\nfindInLists [] cond err = err\r\n\r\nfindInLists (xs:xss) cond err = find cond xs (findInLists xss cond err)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7646,106,'2156724','2013-11-16 22:25:34',1,'--- Если я правильно поняд вашу идею, то вы совершенно правильно находите\r\n--- число, которое встречается больше половины раз _если такое число есть_.\r\n--- Но если такого числа нет, то алгоритм все равно, что-то найдет, но неправильно.\r\n--- Решение тут, мне кажется, должно быть простое - добавить еще один проход,\r\n--- который проверяет, действительно ли мы нашди то, что надо. \r\nfindMajor (x:xs) = findMajor\' (xs) x 1\r\n\r\nfindMajor\' [] cand count = if count > 0 then Just cand else Nothing \r\n\r\nfindMajor\' (x:xs) candidate count =\r\n\r\n 		if candidate == x then findMajor\' xs candidate (count + 1)\r\n\r\n                else if (count == 0) then findMajor\' xs x 0\r\n\r\n					  else findMajor\' xs candidate (count - 1)\r\n\r\n\r\n\r\n  \r\n','Выражение имеет неправильное значение: findMajor [3,3,1,2,1,2,1,3,3]'),(7643,105,'5543298','2013-11-16 22:01:28',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]\r\n','<br/>Тесты успешно пройдены!'),(7642,102,'55363692','2013-11-16 21:58:11',1,'import Data.Maybe\r\n\r\n\r\n\r\nfindMajor\' _ [] = Nothing\r\n\r\nfindMajor\' sum (x:xs) = if (x > sum - x) then Just x else findMajor\' sum xs\r\n\r\n\r\n\r\nfindMajor xs = findMajor\' (sum xs) xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7641,103,'5543298','2013-11-16 21:54:02',1,'find [] f err = err\r\n\r\nfind (x:xs) f err = if f x then x else find xs f err\r\n\r\n\r\n\r\nfindInLists [] cond def = def\r\n\r\nfindInLists (x:xs) cond def = find x cond (findInLists xs cond def)  \r\n','<br/>Тесты успешно пройдены!'),(7640,102,'5543298','2013-11-16 21:39:04',1,'findMajor [] = Nothing \r\n\r\nfindMajor xs = let x = maximum xs in if x > sum xs - x then Just x else Nothing\r\n','<br/>Тесты успешно пройдены!'),(7638,97,'5543298','2013-11-16 21:17:19',1,'checkBrackets\' [] (s:ss)= False\r\n\r\ncheckBrackets\' [] [] = True\r\n\r\ncheckBrackets\' (x:xs) ss = if isOpen x then checkBrackets\' xs (x:ss) else if isClose x then if (length ss > 0 && eq (head ss) x) then checkBrackets\' xs (tail ss) else False else checkBrackets\' xs ss  \r\n\r\ncheckBrackets xs = checkBrackets\' xs [] \r\n\r\n\r\n\r\neq x y = x == \'[\' && y == \']\' || x == \'(\' && y == \')\'\r\n\r\nisOpen x = x == \'[\' || x == \'(\'\r\n\r\nisClose x = x == \']\' || x == \')\'\r\n','<br/>Тесты успешно пройдены!'),(7639,102,'5543298','2013-11-16 21:38:31',0,'findMajor xs = let x = maximum xs in if x > sum xs - x then Just x else Nothing\n','Не удалось вычислить выражение \"findMajor []\", проверьте правильность синтаксиса'),(7637,106,'115753099','2013-11-16 19:35:31',1,'findMajor xs = findMajor1 xs xs 0 Nothing\r\n\r\nfindMajor2 [] _ countEl size =\r\n	(countEl, size)\r\nfindMajor2 (x:xs) el countEl size\r\n	| x == el	= findMajor2 xs el (countEl + 1) (size + 1)\r\n	| otherwise = findMajor2 xs el countEl		 (size + 1)\r\nfindMajor1 [] ys confidence (Nothing) =\r\n	Nothing\r\nfindMajor1 [] ys confidence (Just x)\r\n	| confidence > 0 =\r\n		if countEl > size / 2 then (Just x)\r\n		else Nothing\r\n	| otherwise = Nothing\r\n	where\r\n		(countEl, size) = findMajor2 ys x 0 0\r\nfindMajor1 (x:xs) ys confidence candidate\r\n	| confidence == 0 = findMajor1 xs ys 1 (Just x)\r\n	| candidate == (Just x) = findMajor1 xs ys (confidence + 1) candidate\r\n	| otherwise = findMajor1 xs ys (confidence - 1) candidate','<br/>Тесты успешно пройдены!'),(7635,102,'SNNatalieS','2013-11-16 17:35:20',1,'findMajor [] = Nothing\r\nfindMajor xs = fm xs (sum xs)\r\nfm [] _ = Nothing\r\nfm (x:xs) s = if (s - x < x) then Just x \r\n				else fm xs s','<br/>Тесты успешно пройдены!'),(7636,97,'115753099','2013-11-16 18:43:38',1,'checkBrackets xs = checkBrackets1 xs []\r\ncheckBrackets1 [] [] = True\r\ncheckBrackets1 [] _  = False\r\ncheckBrackets1 (newBracket:bracketsList) []\r\n	= checkBrackets1 bracketsList (newBracket:[])\r\ncheckBrackets1 (newBracket:bracketsList) (lastOpenBracket:accList)\r\n	| newBracket == \'[\' || newBracket == \'(\'\r\n		= checkBrackets1 bracketsList (newBracket:lastOpenBracket:accList)\r\n	| newBracket == \')\' && lastOpenBracket == \'(\' ||\r\n	  newBracket == \']\' && lastOpenBracket == \'[\'\r\n		= checkBrackets1 bracketsList accList\r\n	| otherwise = False','<br/>Тесты успешно пройдены!'),(7633,103,'SNNatalieS','2013-11-16 16:26:20',1,'find f [] err = err\r\nfind f (x:xs) err = \r\n	if f x then x \r\n	else find f xs err\r\nfindInLists [] cond err = err\r\nfindInLists (x:xs) cond err = \r\n	find (\\t -> cond t) x (findInLists xs cond err)\r\n   --- Или просто find cond x  (findInLists xs cond err)','<br/>Тесты успешно пройдены!'),(7634,105,'SNNatalieS','2013-11-16 16:47:54',1,'cartesian xs ds = xs >>= (x -> (map (v -> (x, v)) ds))','<br/>Тесты успешно пройдены!'),(7632,110,'115753099','2013-11-16 16:12:53',1,'using System;\r\n\r\nnamespace _31_1\r\n{\r\n    class Program\r\n    {\r\n        public static int find(Predicate<int> func, int[] mas, Func<int> err) \r\n        {\r\n            foreach (var i in mas)\r\n            {\r\n                if (func(i))\r\n                {\r\n                    return i;\r\n                }\r\n            }\r\n            return err();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = { 1, 4, 2, 17, 4 };\r\n            System.Console.WriteLine(find(x => x > 20, arr, () => 0));\r\n            find(x => x > 20, arr, () => { Console.WriteLine(\"Not found\"); return 0; });\r\n\r\n            System.Console.WriteLine(find(x => x > 1000, arr, () => { return find(x => x > 500, arr, () => { return find(x => x > 100, arr, () => { return 0; }); }); }));\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7631,110,'115753099','2013-11-16 16:11:41',0,'using System;\r\n\r\nnamespace _31_1\r\n{\r\n    class Program\r\n    {\r\n        public static int find(Predicate<int> func, int[] mas, Func<int> err) \r\n        {\r\n            foreach (var i in mas)\r\n            {\r\n                if (func(i))\r\n                {\r\n                    return i;\r\n                }\r\n            }\r\n            return err();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = { 1, 4, 2, 17, 4 };\r\n            System.Console.WriteLine(find(x => x > 20, arr, () => 0));\r\n            find(x => x > 20, arr, () => { Console.WriteLine(\"Not found\"); return 0; });\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7630,110,'115753099','2013-11-16 16:11:28',0,'using System;\r\n\r\nnamespace _31_1\r\n{\r\n    class Program\r\n    {\r\n        public static int find(Predicate<int> func, int[] mas, Func<int> err) \r\n        {\r\n            foreach (var i in mas)\r\n            {\r\n                if (func(i))\r\n                {\r\n                    return i;\r\n                }\r\n            }\r\n            return err();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = { 1, 4, 2, 17, 4 };\r\n            System.Console.WriteLine(find(x => x > 20, arr, () => 0));\r\n            find(x => x > 20, arr, () => { Console.WriteLine(\"Not found\"); return 0; });\r\n\r\n            System.Console.WriteLine(find(x => x > 1000, arr, () => { return find(x => x > 500, arr, () => { return find(x => x > 100, arr, () => { return 0; }); }); }));\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7629,110,'115753099','2013-11-16 16:04:07',0,'using System;\r\n\r\nnamespace _31_1\r\n{\r\n    class Program\r\n    {\r\n        public static int find(Predicate<int> func, int[] mas, Func<int> err) \r\n        {\r\n            foreach (var i in mas)\r\n            {\r\n                if (func(i))\r\n                {\r\n                    return i;\r\n                }\r\n            }\r\n            return err();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = { 1, 4, 2, 17, 4 };\r\n            System.Console.WriteLine(find(x => x > 20, arr, () => 0));\r\n            find(x => x > 20, arr, () => { Console.WriteLine(\"Not found\"); return 0; });\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7628,110,'romos2007','2013-11-16 13:46:06',1,'﻿/*\r\n\r\n * Задача 31-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\n\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _31_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err)\r\n\r\n        {\r\n\r\n            foreach (int i in a)\r\n\r\n            {\r\n\r\n                if (func(i))\r\n\r\n                {\r\n\r\n                    return i;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n        public static int find1000500100(int[] a)\r\n\r\n        {\r\n\r\n            return find(x => x > 1000, a, () => find(x => x > 500, a, () => find(x => x > 100, a, () => { Console.Write(\"Not Found! \"); return 0; })));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a1001 = { 1001, 501, 101, 10, 5, 1 };\r\n\r\n            int[] a501 = { 499, 501, 101, 10, 5, 1 };\r\n\r\n            int[] a101 = { 99, 98, 101, 10, 5, 1 };\r\n\r\n            int[] aNotFound = { 1, 2, 3, 10, 5, 1 };\r\n\r\n            Console.WriteLine(\"{0}\", find1000500100(a1001));\r\n\r\n            Console.WriteLine(\"{0}\", find1000500100(a501));\r\n\r\n            Console.WriteLine(\"{0}\", find1000500100(a101));\r\n\r\n            Console.WriteLine(\"{0}\",find1000500100(aNotFound));\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7627,97,'romos2007','2013-11-16 13:21:23',1,'{--\r\n\r\nЗадача 30-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\nИдея в симуляции глобального стека для хранения открывающих скобок (здесь это второй параметр функции)\r\n\r\n\r\n\r\n-}\r\n\r\ncheckBrackets s = chBr s []\r\n\r\n\r\n\r\nchBr s stack\r\n\r\n	|s == [] && stack == [] = True\r\n\r\n	|s == [] && stack /= [] = False\r\n\r\n	|otherwise =\r\n\r\n				let\r\n\r\n					br = [head s]\r\n\r\n				in\r\n\r\n					if br == \")\" || br == \"]\"\r\n\r\n					then\r\n\r\n						if stack == []\r\n\r\n						then False\r\n\r\n						else\r\n\r\n							let\r\n\r\n								br_begin = head stack\r\n\r\n							in\r\n\r\n								if ((br_begin)++(br) == \"()\") || ((br_begin)++(br) == \"[]\")\r\n\r\n								then chBr (tail s) (tail stack)\r\n\r\n								else False\r\n\r\n					else\r\n\r\n						chBr (tail s) ((br):stack)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7626,110,'deripaska','2013-11-16 09:17:27',1,'﻿/*\r\n\r\n	task 31-01\r\n\r\n*Доп. задача на C#, до 29.11*\r\n\r\n\r\n\r\na. Написать на C# функцию Find, которая в данном массиве целых чисел ищет элемент, удовлетворяющий данному логическому условию. При этом функция должна использовать failure continuation, чтобы обрабатывать случай, когда ничего не найден.\r\n\r\n\r\n\r\nб. Привести пример, как с помощью Find можно решить пример с занятий: \r\n\r\n\"Найти в массиве первое число, большее 1000, а если его нет, то первое число большее 500, а если и его нет, то первое число большее 100 (а если и его нет, вернуть 0)\".\r\n\r\n\r\n\r\nТехнические замечания про failure continuation на C# см. тут: \r\n\r\nhttp://msimuni.wikidot.com/fp-failure-continuation \r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_31_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static int find(Predicate<int> func, int[] a, Func<int> err)\r\n\r\n        {\r\n\r\n            foreach (int currentElement in a)\r\n\r\n            {\r\n\r\n                if (func(currentElement))\r\n\r\n                {\r\n\r\n                    return currentElement;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return err();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static int example(int[] a)\r\n\r\n        {\r\n\r\n            return find(x => x > 1000, a, () => find(x => x > 500, a, () => find(x => x > 100, a, () => 0)));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a1 = new int[] { 1, 35, 1005, 56, 540, 480, 5, 630 };\r\n\r\n            int[] a2 = new int[] { 1, 35, 10, 56, 540, 480, 5, 630 };\r\n\r\n            int[] a3 = new int[] { 1, 35, 10, 56, 40, 480, 5, 163 };\r\n\r\n            int[] a4 = new int[] { 1, 35, 10, 56, 40, 48, 5, 63 };\r\n\r\n\r\n\r\n            Console.WriteLine(example(a1)); // 1005\r\n\r\n            Console.WriteLine(example(a2)); // 540\r\n\r\n            Console.WriteLine(example(a3)); // 480\r\n\r\n            Console.WriteLine(example(a4)); // 0\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7625,102,'SNNatalieS','2013-11-16 02:37:20',0,'findMajor [] = Nothing\r\nfindMajor (x:xs) = let s = sum xs\r\n					in if s - x < x then Just x\r\n						else findMajor xs','Выражение имеет неправильное значение: findMajor [2,3,5,2,4]'),(7623,104,'SNNatalieS','2013-11-16 02:31:24',0,'f xs = xs >>= x -> if (mod x 2 == 0) then [x, x] else [x]','Не удалось вычислить выражение \"doubleEven [1,2,6,3]\", проверьте правильность синтаксиса'),(7624,104,'SNNatalieS','2013-11-16 02:32:40',1,'doubleEven xs = xs >>= x -> if (mod x 2 == 0) then [x, x] else [x]','<br/>Тесты успешно пройдены!'),(7622,102,'8519021','2013-11-16 00:25:16',1,'findMajor xs = findMajor\' xs (sum xs)\r\n\r\nfindMajor\' [] sum = Nothing\r\n\r\nfindMajor\' (x:xs) sum = if x > sum - x then Just x else findMajor\' xs sum\r\n','<br/>Тесты успешно пройдены!'),(7621,105,'15309342','2013-11-15 23:57:12',1,'cartesian [] _ = []\r\ncartesian _ [] = []\r\ncartesian (x:xs) ys = (ys >>= (y -> [(x, y)])) ++ cartesian xs ys','<br/>Тесты успешно пройдены!'),(7620,88,'62628590','2013-11-15 23:54:33',1,'-- считаю N в условии опечаткой - должно быть Num\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\ndiff X = Num 1\r\ndiff (Num _) = Num 0\r\ndiff (Add a b) = Add (diff a) (diff b)\r\ndiff (Mult a b) = Add (Mult (diff a) b) (Mult a (diff b))','<br/>Тесты успешно пройдены!'),(7617,104,'62628590','2013-11-15 23:33:47',1,'doubleEven xs = xs >>= x -> if x `mod` 2 == 0 then [x, x] else [x]','<br/>Тесты успешно пройдены!'),(7618,105,'62628590','2013-11-15 23:37:59',1,'cartesian xs ys = xs >>= x -> ys >>= y -> [(x,y)]','<br/>Тесты успешно пройдены!'),(7619,87,'62628590','2013-11-15 23:48:27',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\neval X n = n\r\neval (Num n) _ = n\r\neval (Add s1 s2) n = eval s1 n + eval s2 n\r\neval (Mult m1 m2) n = eval m1 n * eval m2 n','<br/>Тесты успешно пройдены!'),(7615,104,'15309342','2013-11-15 23:22:33',1,'doubleEven xs = xs >>= (x -> if x `mod` 2 == 0 then [x, x] else [x])','<br/>Тесты успешно пройдены!'),(7616,103,'62628590','2013-11-15 23:31:13',1,'find f [] err = err\r\nfind f (x:xs) err = if f x then x \r\n			    else find f xs err\r\nfindInLists [] _ err = err\r\nfindInLists (xs:xss) f err = find f xs (findInLists xss f err)','<br/>Тесты успешно пройдены!'),(7614,103,'15309342','2013-11-15 23:15:41',1,'find f [] err = err\r\nfind f (x:xs) err = if f x then x \r\n    		    else find f xs err\r\n\r\nfindInLists [] f err = err \r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)','<br/>Тесты успешно пройдены!'),(7613,95,'nomeansno','2013-11-15 23:14:11',1,'--- Вообще замечательно, что вы написали на С++,очень хорошо!\r\n--- Но в задачах \"на обычном языке\" я прошу, чтобы быаа полная программа,\r\n--- с main и с каким-нибудь тестовым примером, чтобы я мог ее запустить.\r\n--- Пришлите такой вариант, пожалуйста!\r\n     \r\n#include <iostream>\r\n\r\n#include <functional>\r\n\r\n\r\n\r\nbool _allDifferent(std::function<bool (int)> cond, int *array, size_t size, size_t index) {\r\n\r\n    int t = array[index];\r\n\r\n    if (!cond(t))\r\n\r\n        return false;\r\n\r\n    if (!size || index==size-1)\r\n\r\n        return true;\r\n\r\n    return _allDifferent(([t, cond] (int x) {\r\n\r\n        return (cond(x) && x!=t);\r\n\r\n    }), array, size, index+1);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nbool allDifferent(int *array, size_t size) {\r\n\r\n    return _allDifferent(([] (int x) {\r\n\r\n        return true;\r\n\r\n    }), array, size , 0);\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n	int a[5] = {3,3,1,4,5};\r\n\r\n    	int b[3] = {1,2,3};\r\n\r\n	int c[0] = {};\r\n\r\n	std::cout << allDifferent(a,5);\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7612,96,'8519021','2013-11-15 23:12:28',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Merge\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> aEnumerator = a.GetEnumerator();\r\n\r\n            IEnumerator<int> bEnumerator = b.GetEnumerator();\r\n\r\n            bool aNext = aEnumerator.MoveNext();\r\n\r\n            bool bNext = bEnumerator.MoveNext();\r\n\r\n\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                if (!aNext && bNext)\r\n\r\n                {\r\n\r\n                    yield return bEnumerator.Current;\r\n\r\n                    while (bEnumerator.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return bEnumerator.Current;\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n\r\n\r\n                if (aNext && !bNext)\r\n\r\n                {\r\n\r\n                    yield return aEnumerator.Current;\r\n\r\n                    while (aEnumerator.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return aEnumerator.Current;\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n\r\n\r\n                if (aEnumerator.Current == bEnumerator.Current)\r\n\r\n                {\r\n\r\n                    yield return aEnumerator.Current;\r\n\r\n                    aNext = aEnumerator.MoveNext();\r\n\r\n                    bNext = bEnumerator.MoveNext();\r\n\r\n                } else if (aEnumerator.Current < bEnumerator.Current)\r\n\r\n                {\r\n\r\n                    yield return aEnumerator.Current;\r\n\r\n                    aNext = aEnumerator.MoveNext();\r\n\r\n                } else\r\n\r\n                {\r\n\r\n                    yield return bEnumerator.Current;\r\n\r\n                    bNext = bEnumerator.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7611,102,'15309342','2013-11-15 23:05:34',1,'findMajor [] = Nothing\r\nfindMajor (x:xs) = findMajor\' x x xs\r\n\r\nfindMajor\' e sum [] | e > sum = Just e\r\n                    | otherwise = Nothing\r\nfindMajor\' e sum (x:xs) | e <= sum || x > e = findMajor\' x (sum + e) xs\r\n                        | otherwise = findMajor\' e (sum + x) xs ','<br/>Тесты успешно пройдены!'),(7610,102,'62628590','2013-11-15 23:01:13',1,'findMajor xs = findMajor\' xs (sum xs)\r\nfindMajor\' [] _ = Nothing\r\nfindMajor\' (x:xs) a = if 2 * x > a then Just x else findMajor\' xs a','<br/>Тесты успешно пройдены!'),(7609,95,'1990147','2013-11-15 21:20:14',2,'--- В задачах на c# надо присылать не фрагмент программы, а полную программу,\r\n--- с тестовым примером, чтобы ее можно было скомпилировать, запустить и что-то увидеть.\r\n--- Пришлите такой вариант, пожалуйста.\r\npublic static bool allDifferent(int[] a)\r\n        {\r\n            return allDifferent1(a, 0, (t => true));\r\n        }\r\n        private static bool allDifferent1(int[] a, int b, Predicate<int> cond)\r\n        {\r\n            if (!cond(a[b])) return false;\r\n            if (b == a.Length - 1) return true;\r\n            return allDifferent1(a, b + 1, (t => cond(t) && a[b] != t));\r\n             \r\n        }','<br/>Тесты успешно пройдены!'),(7608,97,'ilia','2013-11-15 19:51:22',1,'--- Здорово, очень интересное решение!\r\ncheckBrackets s = check_seq s (s -> length s == 0)\r\n\r\n\r\n\r\ncheck_seq \"\" f = f \"\"\r\n\r\ncheck_seq (sh:s) f\r\n\r\n	| sh == \'[\' = check_seq s (s -> length s /= 0 && head s == \']\' && check_seq (tail s) f)\r\n\r\n	| sh == \'(\' = check_seq s (s -> length s /= 0 && head s == \')\' && check_seq (tail s) f)\r\n\r\n	| otherwise = f (sh : s)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (checkBrackets \"[()[]]()\")\r\n\r\n	print (checkBrackets \"([)]\")\r\n\r\n	print (checkBrackets \"())[]\")\r\n\r\n	print (checkBrackets \"([]\")\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7607,106,'deripaska','2013-11-15 19:16:26',1,'--- Но мне кажется, у вас сложность O(n*n), разве нет?  findMajor_help на каждом шагу вызывает\r\n--- check который тоже O(n).\r\n--- Если вы не согласны, напишите, пожалуйста, обсудим. \r\n{--\r\n\r\n	task 30-02\r\n\r\nОпишите функцию findMajor, которая проверяет, есть ли в списке элемент x, который встречается чаще всех других, вместе взятых, и возвращает Just x или Nothing, если такого элемента нет.\r\n\r\n\r\n\r\nДополнительное условие: Функция должна работать за линейное время от длины списка, и не должна использовать списки (кроме исходного списка, конечно) или любые другие структуры данных неограниченной длины. Другими словами, должна быть сложность по времени O(n) и сложность по памяти O(1).\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nfindMajor [1,2,3,2,2,2,1]\r\n\r\nРезультат должен быть равен Just 2\r\n\r\n\r\n\r\nfindMajor [1,2,3,2,2,1]\r\n\r\nРезультат должен быть равен Nothing\r\n\r\n--}\r\n\r\n\r\n\r\nfindMajor xs = totalResult xs (findMajor_help xs 0 Nothing)\r\n\r\n\r\n\r\nfindMajor_help [] confidence res\r\n\r\n	| confidence > 0 = res\r\n\r\n	| otherwise = Nothing\r\n\r\n	\r\n\r\nfindMajor_help (x:xs) confidence res\r\n\r\n	| confidence == 0 = findMajor_help xs (confidence + 1) (Just x)\r\n\r\n	| curCheck = res\r\n\r\n	| otherwise = findMajor_help xs 1 (Just x)\r\n\r\n	where curCheck = check (x:xs) confidence res\r\n\r\n	\r\n\r\ncheck [] confidence candidate = confidence > 0\r\n\r\ncheck (x:xs) confidence candidate\r\n\r\n	| candidate == (Just x) = check xs (confidence + 1) candidate\r\n\r\n	| otherwise = check xs (confidence - 1) candidate\r\n\r\n	\r\n\r\ntotalResult _ Nothing = Nothing\r\n\r\ntotalResult xs candidate\r\n\r\n	| curCheck = candidate\r\n\r\n	| otherwise = Nothing\r\n\r\n	where curCheck = check xs 0 candidate','<br/>Тесты успешно пройдены!'),(7606,97,'2156724','2013-11-15 18:31:21',1,'checkBrackets (x:xs) = if (x==\')\' || x== \']\') then False\r\n\r\n                         else  checkBrackets\' (xs) [x]\r\n\r\n\r\n\r\n\r\n\r\ncheckBrackets\' [][] = True;\r\n\r\ncheckBrackets\' [](y:ys) = False; \r\n\r\ncheckBrackets\' (x:xs)[] = if (x==\')\' || x== \']\') then False\r\n\r\n                         else  checkBrackets\' (xs) [x]\r\n\r\n\r\n\r\ncheckBrackets\' (x:xs) (y:ys) =\r\n\r\n            case x of\r\n\r\n                   \'(\' -> checkBrackets\' (xs) (x:y:ys)\r\n\r\n                   \'[\' -> checkBrackets\' (xs) (x:y:ys)\r\n\r\n                   \')\' -> if (y == \'(\' ) then checkBrackets\' (xs) (ys)\r\n\r\n				         else False\r\n\r\n                   \']\' -> if (y == \'[\' ) then checkBrackets\' (xs) (ys)\r\n\r\n				         else False\r\n','<br/>Тесты успешно пройдены!'),(7605,96,'anna','2013-11-15 18:07:31',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\n\r\n\r\nnamespace ConsoleApplication1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> one = a.GetEnumerator();\r\n\r\n            IEnumerator<int> two = b.GetEnumerator();\r\n\r\n            bool oneCanMove = one.MoveNext();\r\n\r\n            bool twoCanMove = two.MoveNext();\r\n\r\n\r\n\r\n            for (; ; )\r\n\r\n            {\r\n\r\n                if (oneCanMove && !twoCanMove)\r\n\r\n                {\r\n\r\n                    yield return one.Current;\r\n\r\n                    while (one.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return one.Current;\r\n\r\n                    }\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n                if (!oneCanMove && twoCanMove)\r\n\r\n                {\r\n\r\n                    yield return two.Current;\r\n\r\n                    while (two.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return two.Current;\r\n\r\n                    }\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n                if (oneCanMove)\r\n\r\n                {\r\n\r\n                    int x = one.Current;\r\n\r\n                    int y = two.Current;\r\n\r\n                    if (x == y)\r\n\r\n                    {\r\n\r\n                        oneCanMove = one.MoveNext();\r\n\r\n                        twoCanMove = two.MoveNext();\r\n\r\n                        yield return x;\r\n\r\n                    }\r\n\r\n                    else if (x > y)\r\n\r\n                    {\r\n\r\n                        twoCanMove = two.MoveNext();\r\n\r\n                        yield return y;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        oneCanMove = one.MoveNext();\r\n\r\n                        yield return x;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7604,88,'3270666','2013-11-15 17:59:37',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving Show\r\n\r\ndiff (Num x) = (Num 0)\r\ndiff (X) = (Num 1)\r\ndiff (Add expr1 expr2) = (Add (diff expr1) (diff expr2))\r\ndiff (Mult expr1 expr2) = \r\n	(Add (Mult (diff expr1) expr2) (Mult expr1 (diff expr2)))','<br/>Тесты успешно пройдены!'),(7601,104,'3270666','2013-11-15 17:41:14',1,'doubleEven xs = xs >>= x -> if even x then [x, x] else [x]','<br/>Тесты успешно пройдены!'),(7602,105,'3270666','2013-11-15 17:52:05',1,'cartesian xs ys = xs >>= x -> (ys >>= y -> [(x, y)])','<br/>Тесты успешно пройдены!'),(7603,87,'3270666','2013-11-15 17:55:51',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving Show\r\n\r\neval (Num i) x = i\r\neval (X) x = x\r\neval (Add expr1 expr2) x = eval expr1 x + eval expr2 x\r\neval (Mult expr1 expr2) x = eval expr1 x * eval expr2 x','<br/>Тесты успешно пройдены!'),(7600,103,'3270666','2013-11-15 17:38:37',1,'findInLists [] f err = err\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)\r\n\r\nfind f [] err = err\r\nfind f (x:xs) err = if f x \r\n	then x \r\n	else find f xs err','<br/>Тесты успешно пройдены!'),(7599,102,'3270666','2013-11-15 17:33:49',1,'findMajor [] = Nothing\r\nfindMajor xs = \r\n	let x = maximum xs \r\n	    s = sum xs\r\n	in if (x > s - x)\r\n		  then (Just x)\r\n		  else Nothing','<br/>Тесты успешно пройдены!'),(7598,102,'3270666','2013-11-15 17:33:28',0,'findMajor xs = \r\n	let x = maximum xs \r\n	    s = sum xs\r\n	in if (x > s - x)\r\n		  then (Just x)\r\n		  else Nothing','Не удалось вычислить выражение \"findMajor []\", проверьте правильность синтаксиса'),(7597,108,'1595828','2013-11-15 15:37:12',1,'queens\' _ 0 _=[[]]\r\n\r\nqueens\' xn k cond =[((y,x):xs)|x<-xn,let y = k,	 not (cond (y,x)), xs<-queens\' (filter (/=x) xn)  (k-1) (	(b,a)-> cond (b,a) ||abs(a-x)==abs(b-y) )]\r\n\r\nqueens n k =   (queens\' [1..n] k (const False)) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7595,108,'1595828','2013-11-15 15:00:21',0,'queens\' _ 0 _=[[]]\r\n\nqueens\' n k cond =[((y,x):xs)|x<-[1..n],y<-[1..k], not (cond (y,x)), xs<-queens\' n (k-1) (	(b,a)-> cond (b,a) || a == x||b==y||abs(a-x)==abs(b-y) )]\r\n\nqueens n k =  reverse(map (reverse) (queens\' n k (const False)))\n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7596,108,'1595828','2013-11-15 15:33:15',0,'queens\' _ 0 _=[[]]\r\n\nqueens\' xn k cond =[((y,x):xs)|y<-[1..k],x<-xn, not (cond (y,x)), xs<-queens\' (filter (/=x) xn) (k-1) (	(b,a)-> cond (b,a) || b==y||abs(a-x)==abs(b-y) )]\r\n\nqueens n k =   (queens\' [1..n] k (const False)) \r\n\n\n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7594,97,'deripaska','2013-11-15 13:29:17',1,'{--\r\n\r\n	task 30-01\r\n\r\nПусть строчка содержит только символы ‘[‘, ‘]‘, ‘(‘ и ‘)‘. Опишите функцию checkBrackets, которая для данной строчки проверяет, что в ней находится правильная скобочная последовательность, и возвращает True или False. \r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\ncheckBrackets \"[()[]]()\"\r\n\r\nРезультат должен быть равен True.\r\n\r\n\r\n\r\ncheckBrackets \"([)]\"\r\n\r\ncheckBrackets \"())[]\"\r\n\r\ncheckBrackets \"([]\"\r\n\r\nРезультат должен быть равен False.\r\n\r\n--}\r\n\r\n\r\n\r\n{--\r\n\r\ncheckBrackets xs = checkBrackets_help xs 0\r\n\r\ncheckBrackets_help [] count = (count == 0)\r\n\r\ncheckBrackets_help (x:xs) count\r\n\r\n	| count < 0 = False\r\n\r\n	| x == \'[\' || x == \'(\' = checkBrackets_help xs (count + 1)\r\n\r\n	| x == \']\' || x == \')\' = checkBrackets_help xs (count - 1)\r\n\r\n	| otherwise = checkBrackets_help xs count\r\n\r\n--}\r\n\r\n\r\n\r\ncheckBrackets xs = checkBrackets_help xs []\r\n\r\n\r\n\r\ncheckBrackets_help [] [] = True\r\n\r\ncheckBrackets_help [] brackets = False\r\n\r\ncheckBrackets_help (x:xs) brackets\r\n\r\n	| x == \'[\' || x == \'(\' || x == \']\' || x == \')\' = checkBrackets_help xs (addToBrackets brackets x)\r\n\r\n	| otherwise = checkBrackets_help xs brackets\r\n\r\n\r\n\r\naddToBrackets [] c = [c]\r\n\r\naddToBrackets (x:xs) c\r\n\r\n	| (c == \']\' && x == \'[\') || (c == \')\' && x == \'(\')= xs\r\n\r\n	| otherwise = (c:x:xs)\r\n','<br/>Тесты успешно пройдены!'),(7593,95,'8519021','2013-11-15 10:24:08',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace AllDifferent\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static bool AllDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (from == a.Length)\r\n\r\n                return true;\r\n\r\n\r\n\r\n            return cond(a[from]) && AllDifferent1(a, from + 1, t => cond(t) && t != a[from]);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool AllDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return AllDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = {3, 2, 7};\r\n\r\n            Console.WriteLine(AllDifferent(a));\r\n\r\n\r\n\r\n            int[] a1 = { 3, 2, 7, 5, 7, 8 };\r\n\r\n            Console.WriteLine(AllDifferent(a1));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7592,108,'ilia','2013-11-14 23:44:47',1,'queens n k = gen_pos [1..n] 1 k (const True)\r\n\r\n\r\n\r\ngen_pos si j 1 f = [ [ (j, i) ] | i <- si, f (j, i) ]\r\n\r\ngen_pos si j l f = [ (j, i) : gl | i <- si, f (j, i),\r\n\r\n			gl <- gen_pos si (j + 1) (l - 1) (ji -> let\r\n\r\n					jif = fst ji\r\n\r\n					jis = snd ji\r\n\r\n				in\r\n\r\n					f ji && jif /= j && jis /= i\r\n\r\n					&& jis - jif /= i - j && jis + jif /= i + j\r\n\r\n			)\r\n\r\n		]\r\n\r\n\r\n\r\nmain = print (queens 3 2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7591,94,'ilia','2013-11-14 23:43:27',1,'data Scheme = \r\n\r\n	Raw Integer |\r\n\r\n	Par Scheme Scheme |\r\n\r\n	Seq Scheme Scheme\r\n\r\n\r\n\r\nraw_width = 3 -- Raw value max width\r\n\r\ngen_str p n\r\n\r\n	| n == 0 = \"\"\r\n\r\n	| otherwise = p ++ gen_str p (n - 1)\r\n\r\npad_str s p n = let\r\n\r\n		sl = length s      -- string lingth\r\n\r\n		l = max (n - sl) 0 -- length for padding\r\n\r\n		ll = div l 2       -- length left for padding\r\n\r\n		lr = l - ll        -- length right for padding\r\n\r\n	in\r\n\r\n		gen_str p ll ++ s ++ gen_str p lr\r\n\r\ngen_arr f n = map f [1..n]\r\n\r\npad_arr a p n = let\r\n\r\n		al = length a      -- array length\r\n\r\n		l = max (n - al) 0 -- length for padding\r\n\r\n		lt = div l 2       -- length top for padding\r\n\r\n		lb = l - lt        -- length bottom for padding\r\n\r\n	in\r\n\r\n		gen_arr (const p) lt ++ a ++ gen_arr (const p) lb\r\n\r\njoin_arr [ ] _ = \"\"\r\n\r\njoin_arr (ah:a) s\r\n\r\n	| length a == 0 = ah\r\n\r\n	| otherwise = ah ++ s ++ join_arr a s\r\n\r\nshow_scheme (Raw i) = [\r\n\r\n		\"+\" ++ gen_str \"-\" (1 + raw_width + 1) ++ \"+\",\r\n\r\n		\"|\" ++ pad_str (show i) \" \" (1 + raw_width + 1) ++ \"|\",\r\n\r\n		\"+\" ++ gen_str \"-\" (1 + raw_width + 1) ++ \"+\"\r\n\r\n	]\r\n\r\nshow_scheme (Par s1 s2) = let\r\n\r\n		s1s = show_scheme s1      -- s1 scheme\r\n\r\n		s1sw = length (head s1s)  -- s1 scheme width\r\n\r\n		s1sh = length s1s         -- s1 scheme hight\r\n\r\n		s1sm = div (s1sh + 1) 2   -- s1 scheme middle\r\n\r\n		s2s = show_scheme s2 \r\n\r\n		s2sw = length (head s2s)\r\n\r\n		s2sh = length s2s\r\n\r\n		s2sm = div (s2sh + 1) 2\r\n\r\n		rsw = max s1sw s2sw       -- result scheme width\r\n\r\n		s1sp = div (rsw - s1sw) 2 -- s1 scheme pad (left and right)\r\n\r\n		s2sp = div (rsw - s2sw) 2\r\n\r\n		rsh = s1sh + 1 + s2sh     -- result scheme hight\r\n\r\n		rsm = div (rsh + 1) 2     -- result scheme middle\r\n\r\n		rsm1 = rsm - 0            -- result scheme middle for 1st scheme\r\n\r\n		rsm2 = rsm - s1sh - 1\r\n\r\n	in\r\n\r\n		zipWith3 (li s1si ri -> li ++ s1si ++ ri)\r\n\r\n				(gen_arr (i ->\r\n\r\n						if i < s1sm then\r\n\r\n							\"  \" ++ gen_str \" \" s1sp\r\n\r\n						else if i == s1sm then\r\n\r\n							\"+-\" ++ gen_str \"-\" s1sp\r\n\r\n						else if i /= rsm1 then\r\n\r\n							\"| \" ++ gen_str \" \" s1sp\r\n\r\n						else\r\n\r\n							\"+ \" ++ gen_str \" \" s1sp)\r\n\r\n					s1sh)\r\n\r\n				s1s\r\n\r\n				(gen_arr (i ->\r\n\r\n						if i < s1sm then\r\n\r\n							gen_str \" \" s1sp ++ \"  \"\r\n\r\n						else if i == s1sm then\r\n\r\n							gen_str \"-\" s1sp ++ \"-+\"\r\n\r\n						else if i /= rsm1 then\r\n\r\n							gen_str \" \" s1sp ++ \" |\"\r\n\r\n						else \r\n\r\n							gen_str \" \" s1sp ++ \" +\")\r\n\r\n					s1sh)\r\n\r\n			++ (if s1sh == s2sh then\r\n\r\n					[ \"+ \" ++ gen_str \" \" rsw ++ \" +\" ]\r\n\r\n				else\r\n\r\n				 	[ \"| \" ++ gen_str \" \" rsw ++ \" |\" ])\r\n\r\n			++ zipWith3 (li s2si ri -> li ++ s2si ++ ri)\r\n\r\n				(gen_arr (i ->\r\n\r\n						if i == rsm2 then\r\n\r\n							\"+ \" ++ gen_str \" \" s2sp\r\n\r\n						else if i < s2sm then\r\n\r\n							\"| \" ++ gen_str \" \" s2sp\r\n\r\n						else if i == s2sm then\r\n\r\n							\"+-\" ++ gen_str \"-\" s2sp\r\n\r\n						else\r\n\r\n							\"  \" ++ gen_str \" \" s2sp)\r\n\r\n					s2sh)\r\n\r\n				s2s\r\n\r\n				(gen_arr (i ->\r\n\r\n						if i == rsm2 then\r\n\r\n							gen_str \" \" s2sp ++ \" +\"\r\n\r\n						else if i < s2sm then\r\n\r\n							gen_str \" \" s2sp ++ \" |\"\r\n\r\n						else if i == s2sm then\r\n\r\n							gen_str \"-\" s2sp ++ \"-+\"\r\n\r\n						else\r\n\r\n							gen_str \" \" s2sp ++ \"  \")\r\n\r\n					s2sh)\r\n\r\nshow_scheme (Seq s1 s2) = let\r\n\r\n		s1s = show_scheme s1     -- s1 scheme\r\n\r\n		s1sh = length s1s        -- s1 scheme hight\r\n\r\n		s1sw = length (head s1s) -- s1 scheme width\r\n\r\n		s2s = show_scheme s2 \r\n\r\n		s2sh = length s2s\r\n\r\n		s2sw = length (head s2s) -- s1 scheme width\r\n\r\n		rsh = max s1sh s2sh      -- result scheme hight\r\n\r\n		rsm = div (rsh + 1) 2    -- result scheme middle\r\n\r\n	in\r\n\r\n		zipWith3 (s1i mi s2i -> s1i ++ mi ++ s2i)\r\n\r\n				(pad_arr s1s (gen_str \" \" s1sw) rsh)\r\n\r\n				(gen_arr (i ->\r\n\r\n						if i == rsm then\r\n\r\n							\"-\"\r\n\r\n						else\r\n\r\n							\" \") rsh)\r\n\r\n				(pad_arr s2s (gen_str \" \" s2sw) rsh)\r\n\r\n\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n	show (Raw i) = join_arr (show_scheme (Raw i)) \"\r\n\"\r\n\r\n	show (Par s1 s2) = join_arr (show_scheme (Par s1 s2)) \"\r\n\"\r\n\r\n	show (Seq s1 s2) = join_arr (show_scheme (Seq s1 s2)) \"\r\n\"\r\n\r\n\r\n\r\nmain = print (\r\n\r\n		Par (\r\n\r\n			Par (\r\n\r\n				Par (Seq (Raw 1) (Raw 2))\r\n\r\n					(Par (Raw 3) (Raw 4))\r\n\r\n				) (\r\n\r\n				Seq (Par (Raw 5) (Raw 6))\r\n\r\n					(Seq (Raw 7) (Raw 8))\r\n\r\n				)\r\n\r\n			) (\r\n\r\n			Seq (\r\n\r\n				Seq (Par (Raw 9) (Raw 10))\r\n\r\n					(Seq (Raw 11) (Raw 12))\r\n\r\n				) (\r\n\r\n				Par (Seq (Raw 13) (Raw 14))\r\n\r\n					(Par (Raw 15) (Raw 16))\r\n\r\n				)\r\n\r\n			)\r\n\r\n		)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7590,108,'ilia','2013-11-14 23:42:41',0,'data Scheme = \n\n	Raw Integer |\n\n	Par Scheme Scheme |\n\n	Seq Scheme Scheme\n\n\n\nraw_width = 3 -- Raw value max width\n\ngen_str p n\n\n	| n == 0 = \"\"\n\n	| otherwise = p ++ gen_str p (n - 1)\n\npad_str s p n = let\n\n		sl = length s      -- string lingth\n\n		l = max (n - sl) 0 -- length for padding\n\n		ll = div l 2       -- length left for padding\n\n		lr = l - ll        -- length right for padding\n\n	in\n\n		gen_str p ll ++ s ++ gen_str p lr\n\ngen_arr f n = map f [1..n]\n\npad_arr a p n = let\n\n		al = length a      -- array length\n\n		l = max (n - al) 0 -- length for padding\n\n		lt = div l 2       -- length top for padding\n\n		lb = l - lt        -- length bottom for padding\n\n	in\n\n		gen_arr (const p) lt ++ a ++ gen_arr (const p) lb\n\njoin_arr [ ] _ = \"\"\n\njoin_arr (ah:a) s\n\n	| length a == 0 = ah\n\n	| otherwise = ah ++ s ++ join_arr a s\n\nshow_scheme (Raw i) = [\n\n		\"+\" ++ gen_str \"-\" (1 + raw_width + 1) ++ \"+\",\n\n		\"|\" ++ pad_str (show i) \" \" (1 + raw_width + 1) ++ \"|\",\n\n		\"+\" ++ gen_str \"-\" (1 + raw_width + 1) ++ \"+\"\n\n	]\n\nshow_scheme (Par s1 s2) = let\n\n		s1s = show_scheme s1      -- s1 scheme\n\n		s1sw = length (head s1s)  -- s1 scheme width\n\n		s1sh = length s1s         -- s1 scheme hight\n\n		s1sm = div (s1sh + 1) 2   -- s1 scheme middle\n\n		s2s = show_scheme s2 \n\n		s2sw = length (head s2s)\n\n		s2sh = length s2s\n\n		s2sm = div (s2sh + 1) 2\n\n		rsw = max s1sw s2sw       -- result scheme width\n\n		s1sp = div (rsw - s1sw) 2 -- s1 scheme pad (left and right)\n\n		s2sp = div (rsw - s2sw) 2\n\n		rsh = s1sh + 1 + s2sh     -- result scheme hight\n\n		rsm = div (rsh + 1) 2     -- result scheme middle\n\n		rsm1 = rsm - 0            -- result scheme middle for 1st scheme\n\n		rsm2 = rsm - s1sh - 1\n\n	in\n\n		zipWith3 (li s1si ri -> li ++ s1si ++ ri)\n\n				(gen_arr (i ->\n\n						if i < s1sm then\n\n							\"  \" ++ gen_str \" \" s1sp\n\n						else if i == s1sm then\n\n							\"+-\" ++ gen_str \"-\" s1sp\n\n						else if i /= rsm1 then\n\n							\"| \" ++ gen_str \" \" s1sp\n\n						else\n\n							\"+ \" ++ gen_str \" \" s1sp)\n\n					s1sh)\n\n				s1s\n\n				(gen_arr (i ->\n\n						if i < s1sm then\n\n							gen_str \" \" s1sp ++ \"  \"\n\n						else if i == s1sm then\n\n							gen_str \"-\" s1sp ++ \"-+\"\n\n						else if i /= rsm1 then\n\n							gen_str \" \" s1sp ++ \" |\"\n\n						else \n\n							gen_str \" \" s1sp ++ \" +\")\n\n					s1sh)\n\n			++ (if s1sh == s2sh then\n\n					[ \"+ \" ++ gen_str \" \" rsw ++ \" +\" ]\n\n				else\n\n				 	[ \"| \" ++ gen_str \" \" rsw ++ \" |\" ])\n\n			++ zipWith3 (li s2si ri -> li ++ s2si ++ ri)\n\n				(gen_arr (i ->\n\n						if i == rsm2 then\n\n							\"+ \" ++ gen_str \" \" s2sp\n\n						else if i < s2sm then\n\n							\"| \" ++ gen_str \" \" s2sp\n\n						else if i == s2sm then\n\n							\"+-\" ++ gen_str \"-\" s2sp\n\n						else\n\n							\"  \" ++ gen_str \" \" s2sp)\n\n					s2sh)\n\n				s2s\n\n				(gen_arr (i ->\n\n						if i == rsm2 then\n\n							gen_str \" \" s2sp ++ \" +\"\n\n						else if i < s2sm then\n\n							gen_str \" \" s2sp ++ \" |\"\n\n						else if i == s2sm then\n\n							gen_str \"-\" s2sp ++ \"-+\"\n\n						else\n\n							gen_str \" \" s2sp ++ \"  \")\n\n					s2sh)\n\nshow_scheme (Seq s1 s2) = let\n\n		s1s = show_scheme s1     -- s1 scheme\n\n		s1sh = length s1s        -- s1 scheme hight\n\n		s1sw = length (head s1s) -- s1 scheme width\n\n		s2s = show_scheme s2 \n\n		s2sh = length s2s\n\n		s2sw = length (head s2s) -- s1 scheme width\n\n		rsh = max s1sh s2sh      -- result scheme hight\n\n		rsm = div (rsh + 1) 2    -- result scheme middle\n\n	in\n\n		zipWith3 (s1i mi s2i -> s1i ++ mi ++ s2i)\n\n				(pad_arr s1s (gen_str \" \" s1sw) rsh)\n\n				(gen_arr (i ->\n\n						if i == rsm then\n\n							\"-\"\n\n						else\n\n							\" \") rsh)\n\n				(pad_arr s2s (gen_str \" \" s2sw) rsh)\n\n\n\n\n\ninstance Show Scheme where\n\n	show (Raw i) = join_arr (show_scheme (Raw i)) \"\n\"\n\n	show (Par s1 s2) = join_arr (show_scheme (Par s1 s2)) \"\n\"\n\n	show (Seq s1 s2) = join_arr (show_scheme (Seq s1 s2)) \"\n\"\n\n\n\nmain = print (\n\n		Par (\n\n			Par (\n\n				Par (Seq (Raw 1) (Raw 2))\n\n					(Par (Raw 3) (Raw 4))\n\n				) (\n\n				Seq (Par (Raw 5) (Raw 6))\n\n					(Seq (Raw 7) (Raw 8))\n\n				)\n\n			) (\n\n			Seq (\n\n				Seq (Par (Raw 9) (Raw 10))\n\n					(Seq (Raw 11) (Raw 12))\n\n				) (\n\n				Par (Seq (Raw 13) (Raw 14))\n\n					(Par (Raw 15) (Raw 16))\n\n				)\n\n			)\n\n		)\n\n\n','Не удалось вычислить выражение \"length(queens 3 2)\", проверьте правильность синтаксиса'),(7589,100,'62628590','2013-11-14 22:27:03',1,'allDiffLists\' n 0 l = [[]]	\r\nallDiffLists\' n k l= [x:xs | x <- [1..n], xs <- allDiffLists\' n (k-1) (a -> (a==x)||(l a)), not (l x)]\r\nallDiffLists n k = allDiffLists\' n k (const False)','<br/>Тесты успешно пройдены!'),(7588,88,'romos2007','2013-11-14 21:53:42',1,'{--\r\n\r\nЗадача 29-6\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = Num Integer |\r\n\r\n			X |\r\n\r\n			Add Expr Expr |\r\n\r\n			Mult Expr Expr\r\n\r\n			deriving (Show, Eq)\r\n\r\n\r\n\r\neval (Mult e1 e2) x = (eval e1 x) * (eval e2 x)\r\n\r\neval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\n\r\neval (Num i) x= i\r\n\r\neval X x = x\r\n\r\n\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Num i) = Num 0\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) (e2)) (Mult (e1) (diff e2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7587,88,'romos2007','2013-11-14 21:49:28',0,'{--\r\n\nЗадача 29-6\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\ndata Expr = Num Integer |\r\n\n			X |\r\n\n			Add Expr Expr |\r\n\n			Mult Expr Expr\r\n\n			deriving (Show, Eq)\r\n\n\r\n\neval (Mult e1 e2) x = (eval e1 x) * (eval e2 x)\r\n\neval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\n\neval (Num i) x= i\r\n\neval X x = x\r\n\n\r\n\ndiff X = Num 1\r\n\ndiff (Num i) = Num 0\r\n\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\ndiff (Mult e1 e2) = Add (Mult (e1) (diff e2)) (Mult (diff e1) (e2))\r\n\n\n','Выражение имеет неправильное значение: diff (Mult X X)'),(7586,87,'romos2007','2013-11-14 21:49:13',1,'{--\r\n\r\nЗадача 29-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = Num Integer |\r\n\r\n			X |\r\n\r\n			Add Expr Expr |\r\n\r\n			Mult Expr Expr\r\n\r\n			deriving (Show, Eq)\r\n\r\n\r\n\r\neval (Mult e1 e2) x = (eval e1 x) * (eval e2 x)\r\n\r\neval (Add e1 e2) x = (eval e1 x) + (eval e2 x)\r\n\r\neval (Num i) x= i\r\n\r\neval X x = x\r\n','<br/>Тесты успешно пройдены!'),(7585,94,'ilia','2013-11-14 21:17:19',0,'data Scheme = \n\n	Raw Integer |\n\n	Par Scheme Scheme |\n\n	Seq Scheme Scheme\n\n\n\nraw_width = 1\n\ngen_str p n\n\n	| n == 0 = \"\"\n\n	| otherwise = p ++ gen_str p (n - 1)\n\npad_str s p n = let\n\n		sl = length s      -- string lingth\n\n		l = max (n - sl) 0 -- length for padding\n\n		lr = div l 2       -- length right for padding\n\n		ll = l - lr        -- length left for padding\n\n	in\n\n		gen_str p ll ++ s ++ gen_str p lr\n\ngen_arr f n = map f [1..n]\n\npad_arr a p n = let\n\n		al = length a      -- array length\n\n		l = max (n - al) 0 -- length for padding\n\n		lt = div l 2       -- length top for padding\n\n		lb = l - lt        -- length bottom for padding\n\n	in\n\n		gen_arr (const p) lt ++ a ++ gen_arr (const p) lb\n\njoin_arr [ ] _ = \"\"\n\njoin_arr (ah:a) s\n\n	| length a == 0 = ah\n\n	| otherwise = ah ++ s ++ join_arr a s\n\nshow_scheme (Raw i) = [\n\n		\"+\" ++ gen_str \"-\" (1 + raw_width + 1) ++ \"+\",\n\n		\"|\" ++ pad_str (show i) \" \" (1 + raw_width + 1) ++ \"|\",\n\n		\"+\" ++ gen_str \"-\" (1 + raw_width + 1) ++ \"+\"\n\n	]\n\nshow_scheme (Par s1 s2) = let\n\n		s1s = show_scheme s1      -- s1 scheme\n\n		s1sw = length (head s1s)  -- s1 scheme width\n\n		s1sh = length s1s         -- s1 scheme hight\n\n		s1sm = div (s1sh + 1) 2   -- s1 scheme middle\n\n		s2s = show_scheme s2 \n\n		s2sw = length (head s2s)\n\n		s2sh = length s2s\n\n		s2sm = div (s2sh + 1) 2\n\n		rsw = max s1sw s2sw       -- result scheme width\n\n		s1sp = div (rsw - s1sw) 2 -- s1 scheme pad (left and right)\n\n		s2sp = div (rsw - s2sw) 2\n\n	in\n\n		zipWith3 (li s1si ri -> li ++ s1si ++ ri)\n\n				(gen_arr (i ->\n\n						if i < s1sm then\n\n							\"  \" ++ gen_str \" \" s1sp\n\n						else if i == s1sm then\n\n							\"+-\" ++ gen_str \"-\" s1sp\n\n						else\n\n							\"| \" ++ gen_str \" \" s1sp)\n\n					s1sh)\n\n				s1s\n\n				(gen_arr (i ->\n\n						if i < s1sm then\n\n							gen_str \" \" s1sp ++ \"  \"\n\n						else if i == s1sm then\n\n							gen_str \"-\" s1sp ++ \"-+\"\n\n						else\n\n							gen_str \" \" s1sp ++ \" |\")\n\n					s1sh)\n\n			++ [ \"+ \" ++ gen_str \" \" rsw ++ \" +\" ]\n\n			++ zipWith3 (li s2si ri -> li ++ s2si ++ ri)\n\n				(gen_arr (i ->\n\n						if i < s2sm then\n\n							\"| \" ++ gen_str \" \" s2sp\n\n						else if i == s1sm then\n\n							\"+-\" ++ gen_str \"-\" s2sp\n\n						else\n\n							\"  \" ++ gen_str \" \" s2sp)\n\n					s2sh)\n\n				s2s\n\n				(gen_arr (i ->\n\n						if i < s2sm then\n\n							gen_str \" \" s2sp ++ \" |\"\n\n						else if i == s1sm then\n\n							gen_str \"-\" s2sp ++ \"-+\"\n\n						else\n\n							gen_str \" \" s2sp ++ \"  \")\n\n					s2sh)\n\nshow_scheme (Seq s1 s2) = let\n\n		s1s = show_scheme s1  -- s1 scheme\n\n		s1sh = length s1s     -- s1 scheme hight\n\n		s2s = show_scheme s2 \n\n		s2sh = length s2s\n\n		rsh = max s1sh s2sh   -- result scheme hight\n\n		rsm = div (rsh + 1) 2 -- result scheme middle\n\n	in\n\n		zipWith3 (s1i mi s2i -> s1i ++ mi ++ s2i)\n\n				(pad_arr s1s \" \" rsh)\n\n				(gen_arr (i ->\n\n						if i == rsm then\n\n							\"-\"\n\n						else\n\n							\" \") rsh)\n\n				(pad_arr s2s \" \" rsh)\n\n\n\n\n\ninstance Show Scheme where\n\n	show (Raw i) = join_arr (show_scheme (Raw i)) \"\n\"\n\n	show (Par s1 s2) = join_arr (show_scheme (Par s1 s2)) \"\n\"\n\n	show (Seq s1 s2) = join_arr (show_scheme (Seq s1 s2)) \"\n\"\n\n\n\nmain = print (\n\n		Par (\n\n			Par (Seq (Raw 1) (Raw 2))\n\n				(Seq (Raw 3) (Raw 4))) (\n\n			Seq (Par (Raw 5) (Raw 6))\n\n				(Par (Raw 7) (Raw 8)))\n\n		)\n\n\n','<br/>Тесты успешно пройдены!'),(7581,102,'anlun','2013-11-14 13:16:08',1,'findMajor :: (Num a, Ord a) => [a] -> Maybe a\r\nfindMajor [] = Nothing\r\nfindMajor l =\r\n	if m > s - m then Just m else Nothing\r\n	where\r\n		m = maximum l\r\n		s = sum l','<br/>Тесты успешно пройдены!'),(7582,104,'anlun','2013-11-14 13:16:32',1,'doubleEven = flip (>>=) (x -> if x `mod` 2 == 0 then [x, x] else [x])','<br/>Тесты успешно пройдены!'),(7583,103,'anlun','2013-11-14 13:23:25',1,'find :: (a -> Bool) -> [a] -> a -> a\r\nfind f [] err = err\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\nfindInLists :: [[a]] -> (a -> Bool) -> a -> a\r\nfindInLists []     f err = err\r\nfindInLists (x:xs) f err = find f x (findInLists xs f err)','<br/>Тесты успешно пройдены!'),(7584,136,'3320654','2013-11-14 17:25:29',1,'data Polynomial = Pol [Double]\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n  (Pol x) + (Pol y) = Pol (help x y)\r\n\r\n  (Pol x) * (Pol y) = Pol (help\' x y 0)\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n  (Pol x) == (Pol y) = (help\'\' x y)\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n  show (Pol x) = show\' x 0\r\n\r\n\r\n\r\nshow\' [x] k		= \"+\" ++ show x ++ \"x^\" ++ show k\r\n\r\nshow\' (x:xs) 0 	= show x ++ (show\' xs 1)\r\n\r\nshow\' (x:xs) k	= \"+\" ++ show x ++ \"x^\" ++ show k ++ (show\' xs (k + 1))\r\n\r\n\r\n\r\nhelp list []		= list\r\n\r\nhelp [] list		= list\r\n\r\nhelp (x:xs) (y:ys) 	= (x + y) : (help xs ys)\r\n\r\n\r\n\r\nhelp\' (x:xs) (y:ys) k	= let \r\n\r\n			lx = length (x:xs)\r\n\r\n			ly = length (y:ys)\r\n\r\n			maxDegree = lx + ly - 2\r\n\r\n		   in \r\n\r\n			(sum [((x:xs) !! z) * ((y:ys) !! w) | z <- [0..(lx - 1)], w <- [0..(ly - 1)], z + w == k]) :\r\n\r\n				if (k + 1) <= maxDegree\r\n\r\n				then (help\' (x:xs) (y:ys) (k + 1))\r\n\r\n				else []\r\n\r\n\r\n\r\nhelp\'\' list []		= all (== 0) list\r\n\r\nhelp\'\' [] list		= all (== 0) list\r\n\r\nhelp\'\' (x:xs) (y:ys)	= if x == y\r\n\r\n		   then help\'\' xs ys\r\n\r\n		   else False\r\n','<br/>Тесты успешно пройдены!'),(7578,105,'anlun','2013-11-14 13:13:26',0,'cartesian :: [a] -> [b] -> [(a, b)]\r\ncartesian as = flip (>>=) ( -> as >>= (a ->[(a, b)]))','Выражение имеет неправильное значение: cartesian [1,2] [3,4]'),(7579,105,'anlun','2013-11-14 13:15:19',1,'cartesian :: [a] -> [b] -> [(a, b)]\r\ncartesian as bs = as >>= (a -> bs >>= ( -> [(a, b)]))','<br/>Тесты успешно пройдены!'),(7580,102,'anlun','2013-11-14 13:15:37',0,'findMajor :: (Num a, Ord a) => [a] -> Maybe a\r\nfindMajor l =\r\n	if m > s - m then Just m else Nothing\r\n	where\r\n		m = maximum l\r\n		s = sum l\r\n','Не удалось вычислить выражение \"findMajor []\", проверьте правильность синтаксиса'),(7577,88,'anlun','2013-11-14 13:13:02',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n	deriving (Show, Eq)\r\n\r\neval :: Expr -> Integer -> Integer\r\neval X v = v\r\neval (Num a) _ = a\r\neval (Add  ex1 ex2) x = (+) (eval ex1 x) $ eval ex2 x\r\neval (Mult ex1 ex2) x = (*) (eval ex1 x) $ eval ex2 x\r\n\r\ndiff :: Expr -> Expr\r\ndiff X = Num 1\r\ndiff (Num a) = Num 0\r\ndiff (Add  ex1 ex2) = Add (diff ex1) (diff ex2)\r\ndiff (Mult ex1 ex2) = Add (Mult dx1 ex2) (Mult ex1 dx2)\r\n	where\r\n		dx1 = diff ex1\r\n		dx2 = diff ex2','<br/>Тесты успешно пройдены!'),(7575,87,'anlun','2013-11-14 13:11:49',1,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n	deriving (Show, Eq)\r\n\r\neval :: Expr -> Integer -> Integer\r\neval X v = v\r\neval (Num a) _ = a\r\neval (Add  ex1 ex2) x = (+) (eval ex1 x) $ eval ex2 x\r\neval (Mult ex1 ex2) x = (*) (eval ex1 x) $ eval ex2 x','<br/>Тесты успешно пройдены!'),(7576,88,'anlun','2013-11-14 13:12:09',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n	deriving (Show, Eq)\r\n\r\ndiff :: Expr -> Expr\r\ndiff X = Num 1\r\ndiff (Num a) = Num 0\r\ndiff (Add  ex1 ex2) = Add (diff ex1) (diff ex2)\r\ndiff (Mult ex1 ex2) = Add (Mult ex1 dx2) (Mult ex2 dx1)\r\n	where\r\n		dx1 = diff ex1\r\n		dx2 = diff ex2','Выражение имеет неправильное значение: diff (Mult X X)'),(7574,88,'anlun','2013-11-14 13:11:23',0,'data Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr\r\n	deriving Show\r\n\r\ndiff :: Expr -> Expr\r\ndiff X = Num 1\r\ndiff (Num a) = Num 0\r\ndiff (Add  ex1 ex2) = Add (diff ex1) (diff ex2)\r\ndiff (Mult ex1 ex2) = Add (Mult ex1 dx2) (Mult ex2 dx1)\r\n	where\r\n		dx1 = diff ex1\r\n		dx2 = diff ex2','Выражение имеет неправильное значение: diff (Mult X X)'),(7572,94,'ilia','2013-11-14 11:57:14',0,'\n','<br/>Тесты успешно пройдены!'),(7573,94,'ilia','2013-11-14 12:30:39',0,'data Scheme = \n\n	Raw Integer |\n\n	Par Scheme Scheme |\n\n	Seq Scheme Scheme\n\n\n\njoin_arr [ ] _ = \"\"\n\njoin_arr (mh:m) s\n\n	| length m == 0 = mh\n\n	| otherwise = mh ++ s ++ join_arr m s\n\nshow_scheme (Raw i) = [ \"+---+\", \"| \" ++ show i ++ \" |\", \"+---+\" ]\n\nshow_scheme (Par s1 s2) = zipWith3 (sbi s1i sai -> sbi ++ s1i ++ sai)\n\n			[ \"   \", \"  -\", \" / \" ] (show_scheme s1) [ \"   \", \"-  \", \" \\ \" ]\n\n		++ [ \"-         -\" ]\n\n		++ zipWith3 (sbi s2i sai -> sbi ++ s2i ++ sai)\n\n			[ \" \\ \", \"  -\", \"   \" ] (show_scheme s2) [ \" / \", \"-  \", \"   \" ]\n\nshow_scheme (Seq s1 s2) = zipWith3 (s1i si s2i -> s1i ++ si ++ s2i)\n\n			(show_scheme s1) [ \" \", \"-\", \" \" ] (show_scheme s2)\n\n\n\n\n\ninstance Show Scheme where\n\n	show (Raw i) = join_arr (show_scheme (Raw i)) \"\n\"\n\n	show (Par s1 s2) = join_arr (show_scheme (Par s1 s2)) \"\n\"\n\n	show (Seq s1 s2) = join_arr (show_scheme (Seq s1 s2)) \"\n\"\n\n\n\nmain = do\n\n	print (Raw 4)\n\n	print (Par (Raw 4) (Raw 4))\n\n	print (Seq (Raw 4) (Raw 4))\n\n\n','<br/>Тесты успешно пройдены!'),(7571,94,'ilia','2013-11-14 03:49:04',0,'data Scheme = \n\n	Raw Integer |\n\n	Par Scheme Scheme |\n\n	Seq Scheme Scheme\n\n\n\ninstance Show Scheme where\n\n	show (Raw i) = \"+---+\n| \" ++ show i ++ \" |\n+---+\";\n\n\n\nmain = do\n\n	print (Raw 4)\n\n	--print (Par (Raw 4) (Raw 4))\n\n	--print (Seq (Raw 4) (Raw 4))\n\n\n','<br/>Тесты успешно пройдены!'),(7570,108,'ilia','2013-11-14 03:33:25',0,'queens n k = gen_pos [1..n] 1 k (const True)\n\n\n\ngen_pos si j 1 f = [ [ (j, i) ] | i <- si, f (j, i) ]\n\ngen_pos si j l f = [ (j, i) : gl | i <- si, f (j, i),\n\n			gl <- gen_pos si (j + 1) (l - 1) (ji -> let\n\n					jif = fst ji\n\n					jis = snd ji\n\n				in\n\n					f ji && jif /= j && jis /= i\n\n					&& jis - jif /= i - j && jis + jif /= i + j\n\n			)\n\n		]\n\n\n\nmain = print (queens 3 2)\n\n\n','<br/>Тесты успешно пройдены!'),(7565,88,'deripaska','2013-11-14 01:19:03',1,'{--\r\n\r\n	task 29-06\r\n\r\nДля типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\r\n\r\n\r\ndiff (Mult X X)\r\n\r\n\r\n\r\nДолжно получиться\r\n\r\n\r\n\r\nAdd (Mult(N 1) X) (Mult X (Num 1))\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\ndiff (Num k) = Num 0\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7566,105,'ilia','2013-11-14 02:26:34',1,'cartesian x y = x >>= xi -> y >>= yi -> [ (xi, yi) ]\r\n\r\n\r\n\r\nmain = print (cartesian  [1, 2] [3, 4])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7567,87,'ilia','2013-11-14 02:35:43',1,'data Expr = \r\n\r\n		Num Integer |\r\n\r\n		X |\r\n\r\n		Add Expr Expr |\r\n\r\n		Mult Expr Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\neval (Num n) _ = n\r\n\r\neval X v = v\r\n\r\neval (Add e1 e2) v = eval e1 v + eval e2 v\r\n\r\neval (Mult e1 e2) v = eval e1 v * eval e2 v\r\n\r\n\r\n\r\nmain = print (eval (Add (Num 3) (Mult X X)) 10)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7568,88,'ilia','2013-11-14 02:42:30',1,'data Expr = \r\n\r\n		Num Integer |\r\n\r\n		X |\r\n\r\n		Add Expr Expr |\r\n\r\n		Mult Expr Expr\r\n\r\n	deriving Show\r\n\r\n\r\n\r\ndiff (Num _) = Num 0\r\n\r\ndiff X = Num 1\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n\r\n\r\n\r\nmain = print (diff (Mult X X))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7569,108,'ilia','2013-11-14 03:29:18',0,'queens n k = gen_pos [1..n] [1..k] k (const True)\n\n\n\ngen_pos si sj 1 f = [ [ (j, i) ] | j <- sj, i <- si, f (j, i) ]\n\ngen_pos si sj l f = [ (j, i) : gl | j <- sj, i <- si, f (j, i),\n\n			gl <- gen_pos si sj (l - 1) (ji -> let\n\n					jif = fst ji\n\n					jis = snd ji\n\n				in\n\n					f ji && jif /= j && jis /= i\n\n					&& jis - jif /= i - j && jis + jif /= i + j\n\n			)\n\n		]\n\n\n\nmain = print (queens 3 2)\n\n\n','Выражение имеет неправильное значение: length(queens 3 2)'),(7564,88,'deripaska','2013-11-14 01:17:42',0,'{--\r\n\n	task 29-06\r\n\nДля типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\n\r\n\ndiff (Mult X X)\r\n\n\r\n\nДолжно получиться\r\n\n\r\n\nAdd (Mult(N 1) X) (Mult X (Num 1))\r\n\n--}\r\n\n\r\n\ndata Expr = N Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\ndiff (N k) = N 0\r\n\ndiff X = N 1\r\n\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n\n\n','Выражение имеет неправильное значение: diff (Mult X X)'),(7563,87,'deripaska','2013-11-14 01:15:59',1,'{--\r\n\r\n	task 29-05\r\n\r\nДля типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\neval (Add (N 3) (Mult X X)) 10\r\n\r\n\r\n\r\nДолжно получиться 103\r\n\r\n--}\r\n\r\n\r\n\r\ndata Expr = Num Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\n\r\n\r\neval (Num k) n = k\r\n\r\neval X n = n\r\n\r\neval (Add e1 e2) n = eval e1 n + eval e2 n\r\n\r\neval (Mult e1 e2) n = eval e1 n * eval e2 n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7560,104,'deripaska','2013-11-14 01:13:33',1,'{--\r\n\r\n	task 29-03\r\n\r\nПри помощи оператора >>= для списков описать функцию doubleEven, которая в данном списке все элементы, делящиеся на 2, повторяет два раза, а остальные оставляет, как есть.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ndoubleEven [1, 2, 6, 3]\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[1,2,2,6,6,3]\r\n\r\n--}\r\n\r\n\r\n\r\ndoubleEven xs = xs >>= x -> if mod x 2 == 0 then [x, x] else [x] \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7561,105,'deripaska','2013-11-14 01:13:50',1,'{--\r\n\r\n	task 29-04\r\n\r\nОписать функцию cartesian, которая для двух списков возвращает список из всех возможных пар элементов из первого и второго списка. Т.е. для списков [x1, x2, x3] и [y1, y2, y3] функция должна вернуть [(x1, y1), (x1, y2), (x1, y3), (x2, y1), (x2, y2), …] (всего 9 пар).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ncartesian [1,2] [3,4]\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[(1,3),(1,4),(2,3),(2,4)]\r\n\r\n--}\r\n\r\n\r\n\r\ncartesian xs ys = xs >>= x -> (ys >>= y -> [(x, y)])\r\n','<br/>Тесты успешно пройдены!'),(7562,87,'deripaska','2013-11-14 01:14:11',0,'{--\r\n\n	task 29-05\r\n\nДля типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\n\r\n\nПример вызова:\r\n\n\r\n\neval (Add (N 3) (Mult X X)) 10\r\n\n\r\n\nДолжно получиться 103\r\n\n--}\r\n\n\r\n\ndata Expr = N Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\n\r\n\neval (N k) n = k\r\n\neval X n = n\r\n\neval (Add e1 e2) n = eval e1 n + eval e2 n\r\n\neval (Mult e1 e2) n = eval e1 n * eval e2 n\r\n\n\n','Не удалось вычислить выражение \"eval (Add (Num 3) (Mult X X)) 10\", проверьте правильность синтаксиса'),(7559,103,'deripaska','2013-11-14 01:13:13',1,'{--\r\n\r\n	task 29-02\r\n\r\nНа занятии мы разобрали функцию find, использующую failure continuation параметр, для того чтобы сообщить, что ничего не найдено. \r\n\r\n\r\n\r\nИспользуя только эту функцию, описать функцию findInLists, которая ищет элемент, удовлетворяющий данному условию в списке списков.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nfindInLists [[1,8,2], [2,7]] (>5) 0\r\n\r\n\r\n\r\nРезультат должен быть равен 8.\r\n\r\n\r\n\r\nfindInLists [[1,8,2], [2,7]] (>10) 0\r\n\r\n\r\n\r\nРезультат должен быть равен 0.\r\n\r\n--}\r\n\r\n\r\n\r\nfind f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x else find f xs err\r\n\r\n\r\n\r\nfindInLists [] _ err = err\r\n\r\nfindInLists (x:xs) cond err = find cond x (findInLists xs cond err)\r\n','<br/>Тесты успешно пройдены!'),(7558,105,'romos2007','2013-11-14 00:32:21',1,'{--\r\n\r\nЗадача 29-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\ncartesian xs ys = xs >>= x -> (ys >>= y -> [(x,y)])\r\n\r\n							 \r\n','<br/>Тесты успешно пройдены!'),(7557,104,'romos2007','2013-11-14 00:32:04',1,'{--\r\n\r\nЗадача 29-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\ndoubleEven xs = xs >>= x->	if mod x 2 == 0\r\n\r\n							then [x,x]\r\n\r\n							else [x]\r\n\r\n							 \r\n','<br/>Тесты успешно пройдены!'),(7556,103,'romos2007','2013-11-14 00:30:29',1,'{--\r\n\r\nЗадача 29-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\nfind f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n\r\n\r\n\r\nfindInLists [] cond err = err\r\n\r\nfindInLists (xs:xss) cond err = find cond xs (findInLists xss cond err) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7555,102,'romos2007','2013-11-14 00:30:10',1,'{--\r\n\r\nЗадача 29-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\nfindMajor xs = 	let\r\n\r\n					summ = sum xs\r\n\r\n				in\r\n\r\n					findMajor\' xs summ\r\n\r\n\r\n\r\nfindMajor\' [] _ = Nothing\r\n\r\nfindMajor\' (x:xs) summ = 	if x > summ-x \r\n\r\n							then Just x \r\n\r\n							else findMajor\' xs summ\r\n','<br/>Тесты успешно пройдены!'),(7554,136,'1990147','2013-11-14 00:22:15',1,'data Poly = Poly [(Integer,Integer)]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninstance Num Poly where \r\n\r\n\r\n\r\n         Poly xs + Poly ys = \r\n\r\n\r\n\r\n              Poly (deletezero (sumpol (podob (qsort xs)) (podob (qsort ys))))\r\n\r\n\r\n\r\n         Poly xs * Poly ys = Poly (deletezero (podob (qsort(mult (podob (qsort xs)) (podob (qsort ys))))))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndeletezero [] = []\r\n\r\ndeletezero (x:xs) = if (fst x == 0) then deletezero xs\r\n\r\n                     else (x:deletezero xs)\r\n\r\n\r\n\r\nqsort [] = []\r\n\r\n\r\n\r\nqsort (x:xs) = qsort [t | t<-xs, snd t<= snd x] ++ \r\n\r\n\r\n\r\n                            [x] ++ qsort [t | t<-xs, snd t>snd x]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npodob [] = []\r\n\r\n\r\n\r\npodob (y:[]) = [y]\r\n\r\n\r\n\r\npodob (x:y:xs) = if (snd x == snd y) then podob ((fst x + fst y,snd x):xs)\r\n\r\n\r\n\r\n               else (x: (podob (y:xs)))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nsumpol [] xs = xs\r\n\r\n\r\n\r\nsumpol xs [] = xs\r\n\r\n\r\n\r\nsumpol (x:xs) (y:ys) = if (snd x == snd y) then ((fst x + fst y,snd x):(sumpol xs ys))\r\n\r\n\r\n\r\n                       else if (snd x < snd y) then (x:(sumpol xs (y:ys)))\r\n\r\n\r\n\r\n                            else (y:(sumpol (x:xs) ys))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmult xs ys = [(i,j)|x<-xs,y<-ys,let i=(fst x)*(fst y),let j = (snd x)+(snd y)]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninstance Eq Poly where\r\n\r\n\r\n\r\n         Poly xs == Poly ys =  checker (deletezero (podob (qsort(xs)))) (deletezero (podob (qsort(ys))))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nchecker [] [] = True\r\n\r\n\r\n\r\nchecker [] ys = False\r\n\r\n\r\n\r\nchecker xs [] = False\r\n\r\n\r\n\r\nchecker (x:xs) (y:ys) = if ((fst x == fst y) && (snd x == snd y)) then checker xs ys\r\n\r\n\r\n\r\n                                                                  else False\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninstance Show Poly where \r\n\r\n\r\n\r\n         show (Poly []) = []\r\n\r\n\r\n\r\n         show (Poly (x:[])) = \"(\"++show (fst x) ++ \"x^\" ++ show (snd x) ++\")\"\r\n\r\n\r\n\r\n         show (Poly (x:xs)) = \"(\"++show (fst x) ++ \"x^\" ++ show (snd x) ++\")+\"++ show (Poly xs)\r\n','<br/>Тесты успешно пройдены!'),(7553,136,'1595828','2013-11-13 23:09:22',1,'data Polynomial = Pol [Int] \r\n\r\nmultiplyByX (Pol p1) = Pol (0:p1)\r\n\r\ndelz [] = []\r\n\r\ndelz p = if (last p /= 0) then p else delz (init p)\r\n\r\nshowpol [] _ = \"\"\r\n\r\nshowpol (x:xs) 0=(show x)++showpol xs 1\r\n\r\nshowpol (x:xs) deg=\"+\"++show x++\"x^\"++show deg++showpol (xs) (deg+1)\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	(Pol p1) + (Pol p2) = if (length p1 >= length p2) \r\n\r\n							then Pol (zipWith (+) p1 (p2 ++ repeat 0))\r\n\r\n							else Pol (zipWith (+) p2 (p1 ++ repeat 0))\r\n\r\n				\r\n\r\n	(Pol []) *(Pol p2) = Pol []\r\n\r\n	(Pol (p:p1)) * (Pol p2) = let   \r\n\r\n									a= map (p*) p2\r\n\r\n									b= multiplyByX(Pol p1 * Pol p2)\r\n\r\n							  in (Pol a) + b\r\n\r\n	\r\n\r\ninstance Eq Polynomial where\r\n\r\n    (Pol p1) == (Pol p2) =  delz p1 == delz p2\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n    show (Pol p1) = showpol (delz p1) 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7552,104,'ilia','2013-11-13 20:15:55',1,'doubleEven m = m >>=\r\n\r\n		mi -> if even mi then\r\n\r\n					[ mi, mi ]\r\n\r\n				else\r\n\r\n					[ mi ]\r\n\r\n\r\n\r\nmain = print (doubleEven [1, 2, 6, 3])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7551,103,'ilia','2013-11-13 20:06:22',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n\r\n	\r\n\r\nfindInLists [ ] _ e = e\r\n\r\nfindInLists (mh:m) f e = find f mh (findInLists m f e)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (findInLists [[1, 8, 2], [2, 7]] (>5) 0)\r\n\r\n	print (findInLists [[1, 8, 2], [2, 7]] (>10) 0)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7545,104,'115753099','2013-11-13 18:18:34',1,'doubleEven xs =\r\n	xs >>= x -> if x `rem` 2 == 0 then [x, x] else [x]','<br/>Тесты успешно пройдены!'),(7546,105,'115753099','2013-11-13 18:20:31',1,'cartesian xs ys =\r\n	xs >>= x -> map (y -> (x,y)) ys','<br/>Тесты успешно пройдены!'),(7547,87,'115753099','2013-11-13 18:25:52',1,'data Expr = N Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving Show\r\n\r\neval (N a) _ = a\r\neval (X) x = x\r\neval (Add ex1 ex2) x = eval ex1 x + eval ex2 x\r\neval (Mult ex1 ex2) x = eval ex1 x * eval ex2 x','<br/>Тесты успешно пройдены!'),(7548,88,'115753099','2013-11-13 18:31:27',1,'data Expr = N Integer | X | Add Expr Expr | Mult Expr Expr \r\n		deriving Show\r\ndiff (N a)			= N 0\r\ndiff (X) 			= N 1\r\ndiff (Add ex1 ex2)  = Add (diff ex1) (diff ex2)\r\ndiff (Mult ex1 ex2) = Add (Mult (diff ex1) ex2) (Mult ex1 (diff ex2))','<br/>Тесты успешно пройдены!'),(7549,102,'ilia','2013-11-13 19:46:27',1,'findMajor m = get_ge m (sum m)\r\n\r\n\r\n\r\nget_ge [ ] _ = Nothing\r\n\r\nget_ge (mh:m) s\r\n\r\n	| mh > s - mh = Just mh\r\n\r\n	| otherwise = get_ge m s\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (findMajor [2, 3, 15, 2, 2, 2])\r\n\r\n	print (findMajor [2, 3, 5, 2, 4])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7550,103,'ilia','2013-11-13 20:04:05',0,'findInLists [ ] _ e = e\n\nfindInLists (mh:m) f e = find f mh (findInLists m f e)\n\n\n\nmain = do\n\n	print (findInLists [[1, 8, 2], [2, 7]] (>5) 0)\n\n	print (findInLists [[1, 8, 2], [2, 7]] (>10) 0)\n\n\n','Не удалось вычислить выражение \"findInLists [[1,2], [2,8,7]] (>5) 0\", проверьте правильность синтаксиса'),(7544,103,'115753099','2013-11-13 18:15:28',1,'find f [] err = err\r\nfind f (x:xs) err = if f x then x \r\n			    else find f xs err\r\n\r\nfindInLists [] _ err = err\r\nfindInLists (x:xs) f err =\r\n	find f x (findInLists xs f err)','<br/>Тесты успешно пройдены!'),(7543,103,'115753099','2013-11-13 18:14:54',0,'find f [] err = err\r\nfind f (x:xs) err = if f x then x \r\n			    else find f xs err\r\n\r\nfindInLists (x:xs) f err =\r\n	find f x (findInLists xs f err)','Не удалось вычислить выражение \"findInLists [[1,8,2], [2,7]] (>10) 0\", проверьте правильность синтаксиса'),(7541,102,'115753099','2013-11-13 18:08:19',1,'findMajor xs\r\n	| sum xs - el < el = Just el\r\n	| otherwise = Nothing\r\n	where\r\n		el = maximum xs\r\n','<br/>Тесты успешно пройдены!'),(7542,102,'deripaska','2013-11-13 18:14:50',1,'{--\r\n\r\n	task 29-01\r\n\r\nОпишите функцию findMajor, которая для данного списка определяет, есть ли в нем элемент, который больше суммы всех остальных, вместе взятых, и, если есть, возвращает его, как результат.\r\n\r\n\r\n\r\nДля того, чтобы сообщить, есть такой элемент или нет, используйте стандартный тип Maуbe, который мы проходили на последнем занятии.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nfindMajor [2,3,15,2,2,2] \r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\nJust 15\r\n\r\n\r\n\r\nfindMajor [2,3,5,2,4] \r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\nNothing\r\n\r\n--}\r\n\r\n\r\n\r\nfindMajor xs = findMajor_help xs (sum xs)\r\n\r\n\r\n\r\nfindMajor_help [] _ = Nothing\r\n\r\nfindMajor_help (x:xs) curSum\r\n\r\n	| x > (curSum - x) = Just x\r\n\r\n	| otherwise = findMajor_help xs curSum\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7540,88,'1595828','2013-11-13 17:49:37',1,'{--судя по примеру \r\n\r\n		\"Add (Mult(N 1) X) (Mult X (N 1))\" \r\n\r\n	Num меняем на N\r\n\r\n--}\r\n\r\ndata Expr = N Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\ndiff (N x) =  N 0\r\n\r\ndiff X = N 1\r\n\r\ndiff (Add a1 a2) = Add (diff a1)  (diff a2)\r\n\r\ndiff (Mult m1 m2) =Add (Mult (diff m1) m2) (Mult m1 (diff m2))\r\n','<br/>Тесты успешно пройдены!'),(7538,88,'2156724','2013-11-13 17:37:42',1,'data Expr = N Integer \r\n\r\n          | X \r\n\r\n          | Add Expr Expr \r\n\r\n          | Mult Expr Expr \r\n\r\n      deriving (Show, Eq)\r\n\r\n\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult (diff e2) e1)\r\n\r\ndiff (X) = (N 1) \r\n\r\ndiff (N a) = N 0\r\n\r\n\r\n','Выражение имеет неправильное значение: diff (Mult X X)'),(7539,88,'2156724','2013-11-13 17:39:19',1,'data Expr = N Integer \r\n\r\n          | X \r\n\r\n          | Add Expr Expr \r\n\r\n          | Mult Expr Expr \r\n\r\n      deriving (Show, Eq)\r\n\r\n\r\n\r\ndiff (Add e1 e2) = Add (diff e1) (diff e2)\r\n\r\ndiff (Mult e1 e2) = Add (Mult (diff e1) e2) (Mult e1 (diff e2))\r\n\r\ndiff (X) = (N 1) \r\n\r\ndiff (N a) = N 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7537,87,'2156724','2013-11-13 17:37:18',1,'data Expr = N Integer \r\n\r\n          | X \r\n\r\n          | Add Expr Expr \r\n\r\n          | Mult Expr Expr \r\n\r\n     -- deriving Show\r\n\r\n\r\n\r\neval (Add e1 e2) n = (eval e1 n) + (eval e2 n) \r\n\r\neval (Mult e1 e2) n = (eval e1 n) * (eval e2 n)\r\n\r\neval (X) n = n\r\n\r\neval (N a) n = a \r\n','<br/>Тесты успешно пройдены!'),(7536,87,'1595828','2013-11-13 17:37:11',1,'{--судя по примеру \r\n\r\n		\"eval (Add (N 3) (Mult X X)) 10\" \r\n\r\n	Num меняем на N\r\n\r\n--}\r\n\r\ndata Expr = N Integer | X | Add Expr Expr | Mult Expr Expr deriving Show\r\n\r\neval (N n) _ = n\r\n\r\neval X n = n\r\n\r\neval (Add a1 a2) n = eval a1 n +eval a2 n\r\n\r\neval (Mult m1 m2) n = eval m1 n *eval m2 n\r\n','<br/>Тесты успешно пройдены!'),(7534,104,'2156724','2013-11-13 17:36:36',1,'doubleEven (x:xs) = (x:xs) >>= x -> if (rem x 2) == 0 then [x,x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7535,105,'2156724','2013-11-13 17:36:57',1,'cartesian  [x] (y:ys)  = (y:ys) >>= (z -> [(x,z)])\r\n\r\n\r\n\r\ncartesian (x:xs) (y:ys) = ((y:ys) >>= (z -> [(x,z)])) ++ (cartesian xs (y:ys))\r\n','<br/>Тесты успешно пройдены!'),(7533,103,'2156724','2013-11-13 17:36:12',1,'find f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n\r\n\r\n\r\n\r\n\r\nfindInLists [] f err = err\r\n\r\nfindInLists (x:xs) f err =\r\n\r\n    find f x (findInLists xs f err) \r\n','<br/>Тесты успешно пройдены!'),(7532,102,'2156724','2013-11-13 17:35:45',1,'findMajor\' [x] l = if x > l then Just x else Nothing\r\n\r\nfindMajor\' (x:xs) l = if x > ((sum xs) + l) then Just x\r\n\r\n			else findMajor\' xs (l + x)\r\n\r\n\r\n\r\nfindMajor (x:xs) = findMajor\' (x:xs) 0\r\n\r\n\r\n\r\n \r\n\r\n  \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7531,105,'1595828','2013-11-13 17:05:23',1,'cartesian xs ys = xs >>= x -> (ys >>= y -> [(x,y)])\r\n','<br/>Тесты успешно пройдены!'),(7528,102,'1595828','2013-11-13 11:26:41',1,'findMajor xs = findMajor\' xs (sum xs)\r\n\r\nfindMajor\' (x:xs) s = if ((s-x)<x) then Just x else findMajor\' xs s\r\n\r\nfindMajor\' [] _ =Nothing\r\n','<br/>Тесты успешно пройдены!'),(7529,103,'1595828','2013-11-13 16:54:06',1,'findInLists [] _ empt= empt\r\n\r\nfindInLists (ys:xs) cond empt = find cond ys (findInLists xs cond empt)\r\n\r\n\r\n\r\nfind f [] err = err\r\n\r\nfind f (x:xs) err = if f x then x \r\n\r\n			    else find f xs err\r\n','<br/>Тесты успешно пройдены!'),(7530,104,'1595828','2013-11-13 17:00:32',1,'doubleEven xs = xs>>= x-> if ( mod x 2 == 0) then [x,x] else [x]\r\n','<br/>Тесты успешно пройдены!'),(7527,100,'1990147','2013-11-13 02:07:03',1,'allDiffLists m n = allDiffLists\' m n (	->True)\r\nallDiffLists\' 0 n _ = [[]]\r\nallDiffLists\' m n cond= [i:j| i<-[1..n], j<-allDiffLists\' (m-1) n (	-> cond t && i/=t),cond i]','<br/>Тесты успешно пройдены!'),(7526,108,'romos2007','2013-11-11 23:27:05',1,'{--\r\n\r\nЗадача 27-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nqueens n k\r\n\r\n		| (k == 0 || n == 0) = [[]] -- если нечего расставлять, или негде расставлять, то пустой список\r\n\r\n		|otherwise = queens\' n k 1 (const False) -- если есть, что расставлять, то начинаем с первого ферзя\r\n\r\n\r\n\r\nqueens\' n k x conflict = if x> k then [[]] -- если расставили всех ферзей, то пусто\r\n\r\n					 else [ (x, y):xs | 	y <- [1..n],	-- иначе перебираем горизонтали\r\n\r\n									not (conflict (x, y)),\r\n\r\n									xs <- queens\' n k (x + 1) (	 -> conflict t || abs (fst t - x) == abs (snd t - y) || snd t == y) ]\r\n','<br/>Тесты успешно пройдены!'),(7525,108,'3270666','2013-11-11 18:48:49',1,'queens n k = if (n >= k)\r\n	then queens\' n k (const True)\r\n	else []\r\n\r\nqueens\' _ 0 _ = [[]]\r\nqueens\' n k cond = \r\n	[(k, y):xs | y <- [1..n], cond (k, y), \r\n	xs <- queens\' n (k - 1) ((x\', y\') -> cond (x\', y\') && \r\n		(x\' - y\' /= k - y) && (x\' + y\' /= k + y) && (y\' /= y))]','<br/>Тесты успешно пройдены!'),(7524,108,'3270666','2013-11-11 18:34:40',0,'queens n k = if (n >= k)\r\n	then queens\' n k (const True)\r\n	else []\r\n\r\nqueens\' _ 0 _ = [[]]\r\nqueens\' n k cond = \r\n	[(k, y):xs | y <- [1..n], cond (k, y), \r\n	xs <- queens\' n (k - 1) ((x\', y\') -> cond (x\', y\') && \r\n		(abs(x\' - y\') /= abs(k - y)) && (x\' + y\' /= k + y) &&\r\n		(x\' /= k) && (y\' /= y))]','Выражение имеет неправильное значение: length (queens 4 4)'),(7523,136,'3270666','2013-11-11 14:33:42',2,'  --- Не совсем правильно, вот такой тест не проходит:\r\n  ---   Poly [1,1]+Poly [1,-1] == Poly [2]\r\n  --- И еще исправьте пожалуйста небольшую ошибку в show (см ниже)\r\n\r\ndata Poly = Poly [Int]\r\n\r\n\r\n\r\ninstance Show Poly where\r\n	show (Poly xs) = show (showPolynome xs 0)\r\n           --- Тут show справа лишнее. Вам надо получить строчку, изоражающую многочлен и эту успешно делает\r\n           --- showPolynome. А если еще раз вызвать show, то вы увидите строчкуб издображающую строчку,\r\n           --- изображающую многочлен :) И это не сосвем то. Конкретно это выражается в том, что у вас\r\n           --- строка вываодится в кавычках.\r\n\r\ninstance Eq Poly where\r\n\r\n	(Poly xs) == (Poly ys) = xs == ys\r\n\r\n\r\n\r\ninstance Num Poly where\r\n\r\n	(Poly xs) + (Poly ys) = \r\n\r\n		let lx = length xs\r\n\r\n		    ly = length ys\r\n\r\n		in if (lx > ly) \r\n\r\n			then (Poly xs) + (Poly (ys ++ [0]))\r\n\r\n			else if (ly > lx)\r\n\r\n				then (Poly (xs ++ [0])) + (Poly ys)\r\n\r\n				else (Poly (zipWith (+) xs ys))\r\n\r\n\r\n\r\n	(Poly xs) * (Poly ys) = \r\n\r\n		polyMultPoly (Poly xs) ys 0 (Poly [0])\r\n\r\n\r\n\r\n-- вспомогательные функции для show\r\n\r\nshowPolynome [] _ = \"\"\r\n\r\nshowPolynome (x:xs) pow = \r\n\r\n	getSign x pow ++ getCoef x pow ++ getVar x pow ++ \" \" ++ showPolynome xs (pow + 1)\r\n\r\n\r\n\r\ngetCoef x pow = if (pow == 0)\r\n\r\n	then show (abs x)\r\n\r\n	else if (x == 1)\r\n\r\n		then \"\"\r\n\r\n		else show (abs x)\r\n\r\n\r\n\r\ngetVar x pow = if (pow > 0) \r\n\r\n	then if (pow == 1)\r\n\r\n		then \"x\"\r\n\r\n		else \"x^\" ++ show pow\r\n\r\n	else \"\"\r\n\r\n\r\n\r\ngetSign x pow = if (x >= 0) \r\n\r\n	then if (pow == 0) \r\n\r\n		then \"\" \r\n\r\n		else \"+ \" \r\n\r\n	else \"- \"		\r\n\r\n\r\n\r\n-- умножение многочлена на одночлен\r\n\r\npolyMultMono (Poly xs) a curPow multPow = \r\n\r\n	if (curPow < multPow)\r\n\r\n		then polyMultMono (Poly (0:xs)) a (curPow + 1) multPow\r\n\r\n		else Poly (map (a*) xs)\r\n\r\n\r\n\r\n-- умножение многочлена на многочлен\r\n\r\npolyMultPoly _ [] _ res = res\r\n\r\npolyMultPoly (Poly xs) (y:ys) curPow res =\r\n\r\n	let newRes = res + polyMultMono (Poly xs) y 0 curPow\r\n\r\n	in polyMultPoly (Poly xs) ys (curPow + 1) newRes','<br/>Тесты успешно пройдены!'),(7522,94,'deripaska','2013-11-11 14:07:41',1,'{--\r\n\r\n	task 27-02\r\n\r\nОпишите для типа \"электрическая схема\" функцию show так, чтобы она наглядно изображала схему в виде резисторов, соединенных проводами, с помощью символов псевдографики (например, с помощью -, |, +).\r\n\r\n\r\n\r\nСправка: В строках Haskell можно использовать символ backslash n для перехода на следующую строку. Можно, при желании, использовать запись backslash x шестнадцатиричное число для того, чтобы задавать любые символы. \r\n\r\n\r\n\r\n(Пояснение: backslash - это такой символ, после него надо писать n или x и цифры подряд. Просто система тестирования плохо относится к backslash в тексте :( ) \r\n\r\n--}\r\n\r\ndata Scheme = Resistance Integer\r\n\r\n				| ParallelConnection Scheme Scheme\r\n\r\n				| SerialConnection Scheme Scheme\r\n\r\n\r\n\r\nrealShow (Resistance i) curAnswer row w h =\r\n\r\n	map (k -> \r\n\r\n			let \r\n\r\n				currentRow = curAnswer !! (k - 1)\r\n\r\n			in \r\n\r\n				if k == row then currentRow ++ filling1 ++ currentShow ++ filling2\r\n\r\n				else if k > row && k < (row + h) then currentRow ++ nullFilling\r\n\r\n				else currentRow\r\n\r\n		) [1..length curAnswer]\r\n\r\n	where\r\n\r\n		(wR, hR) = countSize (Resistance i)\r\n\r\n		curWidth = w - wR\r\n\r\n		halfCurWidth = div curWidth 2\r\n\r\n		filling1 = fillString (fillList \"-\" halfCurWidth)\r\n\r\n		filling2 = fillString (fillList \"-\" (curWidth - halfCurWidth))\r\n\r\n		nullFilling = fillString (fillList \" \" w)\r\n\r\n		currentShow = \"-\" ++ show i ++ \"-\"\r\n\r\n\r\n\r\nrealShow (ParallelConnection s1 s2)	curAnswer row w h =\r\n\r\n	countBorderLines secondAnswer row (row + h1 + 1) (row + h) \"+-\" \"+ \" \"| \"\r\n\r\n	where\r\n\r\n		(w1, h1) = countSize s1\r\n\r\n		(w2, h2) = countSize s2\r\n\r\n		answerWithBound = countBorderLines curAnswer row (row + h1 + 1) (row + h) \"-+\" \" +\" \" |\"\r\n\r\n		firstAnswer = realShow s1 answerWithBound row (w - 4) (h1 + 1)\r\n\r\n		secondAnswer = realShow s2 firstAnswer (row + h1 + 1) (w - 4) (h - h1 - 1)\r\n\r\n\r\n\r\nrealShow (SerialConnection s1 s2) curAnswer row w h =\r\n\r\n	secondAnswer\r\n\r\n	where\r\n\r\n		(w1, h1) = countSize s1\r\n\r\n		firstAnswer = realShow s1 curAnswer row w1 h\r\n\r\n		secondAnswer = realShow s2 firstAnswer row (w - w1) h\r\n\r\n\r\n\r\ncountBorderLines curAnswer row firstStep secondStep begin end border =\r\n\r\n	map (k -> \r\n\r\n			let \r\n\r\n				currentRow = curAnswer !! (k - 1)\r\n\r\n			in \r\n\r\n				if k == row then currentRow ++ begin\r\n\r\n				else if k == firstStep then currentRow ++ end\r\n\r\n				else if k > row && k < firstStep then currentRow ++ border\r\n\r\n				else if k > firstStep && k < secondStep then currentRow ++ \"  \"\r\n\r\n				else currentRow\r\n\r\n		) [1..length curAnswer]\r\n\r\n\r\n\r\ncountWidth n\r\n\r\n	| n < 10 = 1\r\n\r\n	| otherwise = countWidth (div n 10) + 1\r\n\r\n\r\n\r\ncountSize (Resistance i) = (countWidth i + 2, 1)\r\n\r\ncountSize (ParallelConnection s1 s2) =\r\n\r\n	(max w1 w2 + 4, h1 + h2 + 1)\r\n\r\n	where\r\n\r\n		(w1, h1) = countSize s1\r\n\r\n		(w2, h2) = countSize s2\r\n\r\ncountSize (SerialConnection s1 s2) =\r\n\r\n	(w1 + w2, max h1 h2)\r\n\r\n	where\r\n\r\n		(w1, h1) = countSize s1\r\n\r\n		(w2, h2) = countSize s2\r\n\r\n\r\n\r\nfillList str len = [str | i <- [1..len]]\r\n\r\nfillString list = foldr (curStr res -> res ++ curStr) \"\" list\r\n\r\n\r\n\r\ninstance Show Scheme where\r\n\r\n	show s = foldr (curAnswer res -> res ++ \"\r\n\" ++ curAnswer) \"\" answer\r\n\r\n					where\r\n\r\n						(width, height) = countSize s\r\n\r\n						nullAnswer = fillList \"\" height\r\n\r\n						answer = realShow s nullAnswer 1 width height\r\n\r\n						\r\n\r\n-- SerialConnection (ParallelConnection (Resistance 135) (Resistance 3)) (ParallelConnection (Resistance 56352) (Resistance 95))\r\n\r\n-- SerialConnection (ParallelConnection (Resistance 135) (ParallelConnection (Resistance 47) (Resistance 8))) (ParallelConnection (Resistance 56352) (Resistance 95))\r\n\r\n-- SerialConnection (ParallelConnection (Resistance 135) (ParallelConnection (Resistance 47) (ParallelConnection (Resistance 5) (Resistance 13)))) (ParallelConnection (Resistance 56352) (Resistance 95))\r\n','<br/>Тесты успешно пройдены!'),(7521,96,'3270666','2013-11-11 13:09:27',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FP26_2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            List<int> res = new List<int>();\r\n\r\n\r\n\r\n            IEnumerator<int> a_enum = a.GetEnumerator();\r\n\r\n            IEnumerator<int> b_enum = b.GetEnumerator();\r\n\r\n            a_enum.MoveNext();\r\n\r\n            b_enum.MoveNext();\r\n\r\n\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                bool a_hasMore = true;\r\n\r\n                bool b_hasMore = true;\r\n\r\n\r\n\r\n                if (a_enum.Current < b_enum.Current)\r\n\r\n                {\r\n\r\n                    res.Add(a_enum.Current);\r\n\r\n                    a_hasMore = a_enum.MoveNext();\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    if (b_enum.Current < a_enum.Current)\r\n\r\n                    {\r\n\r\n                        res.Add(b_enum.Current);\r\n\r\n                        b_hasMore = b_enum.MoveNext();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        res.Add(a_enum.Current);\r\n\r\n                        a_hasMore = a_enum.MoveNext();\r\n\r\n                        b_hasMore = b_enum.MoveNext();\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                if (!a_hasMore)\r\n\r\n                {\r\n\r\n                    if (!b_hasMore)\r\n\r\n                    {\r\n\r\n                        return res;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        do\r\n\r\n                        {\r\n\r\n                            res.Add(b_enum.Current);\r\n\r\n                        }\r\n\r\n                        while (b_enum.MoveNext());\r\n\r\n                        return res;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    if (!b_hasMore)\r\n\r\n                    {\r\n\r\n                        do\r\n\r\n                        {\r\n\r\n                            res.Add(a_enum.Current);\r\n\r\n                        }\r\n\r\n                        while (a_enum.MoveNext());\r\n\r\n                        return res;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.Write(i);\r\n\r\n                Console.Write(\", \");\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine();\r\n\r\n            a = new int[] { 1, 4, 9 };\r\n\r\n            b = new int[] { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.Write(i);\r\n\r\n                Console.Write(\", \");\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine();\r\n\r\n            a = new int[] { 4, 5, 6 };\r\n\r\n            b = new int[] { 1, 2, 3 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.Write(i);\r\n\r\n                Console.Write(\", \");\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7514,135,'62628590','2013-11-11 11:33:33',1,'superMap f [] = []\r\n\r\nsuperMap f (x:xs) = f x ++ superMap f xs\r\n','<br/>Тесты успешно пройдены!'),(7515,90,'62628590','2013-11-11 11:35:13',1,'data Result a = None | Element a deriving Show\r\n\r\nfindSame\' [] _ = None\r\n\r\nfindSame\' (x:xs) acc = if elem x acc then Element x else findSame\' xs (x:acc)\r\n\r\nfindSame xs = findSame\' xs []\r\n','<br/>Тесты успешно пройдены!'),(7516,89,'62628590','2013-11-11 11:36:21',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nflatten\' Empty acc = acc\r\n\r\nflatten\' (Node n l r) acc = n : flatten\' l (flatten\' r acc)\r\n\r\nflatten t = flatten\' t []\r\n','<br/>Тесты успешно пройдены!'),(7517,85,'1545234','2013-11-11 12:19:30',1,'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n    (Rat c1 z1) + (Rat c2 z2) = Rat (c1*z2 + c2*z1) (z1*z2)\r\n\r\ninstance Ord Ration where\r\n    (Rat c1 z1) < (Rat c2 z2) = if (z1*z2 > 0) then c1*z2 < c2*z1 else c1*z2 > c2*z1\r\n\r\ninstance Eq Ration where\r\n    (Rat c1 z1) == (Rat c2 z2) = c1*z2 == c2*z1\r\n\r\ninstance Show Ration where\r\n    show (Rat c z) = show c ++ \"/\" ++ show z','<br/>Тесты успешно пройдены!'),(7518,86,'1545234','2013-11-11 12:22:00',1,'allNondivisible xs = allNondivisible\' xs (const True)\r\nallNondivisible\' [] c = True\r\nallNondivisible\' (x:xs) c = if not(c x) then False else allNondivisible\' xs (	 -> c t && t `mod` x /= 0 && x `mod` t /= 0)\r\n','<br/>Тесты успешно пройдены!'),(7519,76,'1545234','2013-11-11 12:37:34',0,'Class Shape a where\r\n    area :: a -> Double\r\n    perim :: a -> Double\r\n    contains :: a -> Double -> Double -> Bool\r\n\r\ninstance Shape Rect where\r\n    area (Rect x y cx cy) = x*y\r\n    perim (Rect x y cx cy) = 2*(x+y)\r\n    contains ((Rect x y cx cy) ax ay) = ((ax >= (cx - x/2)) && (ax <= (cx + x/2)))((ay <= (cy + y/2) ) && (ay > (cy - y /2))))\r\n\r\ninstance Shape Circle where\r\n    area (Circle r cx cy) = 3.14*r*r\r\n    perim (Circle r cx cy) = 2*3.14*r\r\n    contains ((Circle r cx cy) ax ay) = (ax - cx)^2 + (ay - cy)^2 <= r^2','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7520,76,'1545234','2013-11-11 12:47:23',1,'class Shape a where\r\n    area:: a -> Double\r\n    perim:: a -> Double\r\n    contains:: a -> Double -> Double -> Bool\r\n\r\ndata Rect = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Rect where\r\n    area (Rect x y cx cy) = x*y\r\n    perim (Rect x y cx cy) = 2*(x+y)\r\n    contains (Rect x y cx cy) ax ay = ((ax >= (cx - x/2)) && (ax <= (cx + x/2)) ) && ((ay <= (cy + y/2) ) && (ay > (cy - y /2)))\r\n\r\ninstance Shape Circle where\r\n    area (Circle r cx cy) = 3.14*r*r\r\n    perim (Circle r cx cy) = 2*3.14*r\r\n    contains (Circle r cx cy) ax ay = (ax - cx)^2 + (ay - cy)^2 <= r^2','<br/>Тесты успешно пройдены!'),(7513,86,'62628590','2013-11-11 11:32:00',1,'allNondivisible\' [] cond = True\r\n\r\nallNondivisible\' (x:xs) cond = if not(cond x) then False else allNondivisible\' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0)\r\n\r\nallNondivisible xs = allNondivisible\' xs (const True)\r\n','<br/>Тесты успешно пройдены!'),(7512,85,'62628590','2013-11-11 11:30:46',1,'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n    (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2 + n2*d1) (d1*d2)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n    (Rat n1 d1) < (Rat n2 d2) = if (d1*d2 > 0) then n1*d2 < n2*d1 else n1*d2 > n2*d1\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n    (Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat n d) = show n ++ \"/\" ++ show d\r\n','<br/>Тесты успешно пройдены!'),(7510,108,'15309342','2013-11-11 10:35:47',1,'queens n k = queens\' n 1 k (const True)\r\nqueens\' _  _ 0 _ = [[]]\r\nqueens\' 0 _ _  _ = [[]]\r\nqueens\' _ i k  _ | i > k = [[]]\r\nqueens\' n i k cond = [ (i, y2):xs | y2 <- [1..n], cond (i, y2), xs <- queens\' n (i + 1) k (	 -> let \r\n                                x1 = fst t\r\n                                x2 = snd t\r\n                            in cond t && x2 /= y2 && abs (x1 - i) /= abs (x2 - y2))]','<br/>Тесты успешно пройдены!'),(7511,76,'62628590','2013-11-11 11:28:08',1,'data Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	perim:: a -> Double\r\n\r\n	area:: a -> Double    \r\n\r\n	contains:: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n  	area (Rect a b x y) = x*y\r\n\r\n  	perim (Rect a b x y) = 2*(x+y)\r\n\r\n	contains (Rect a b x y) x1 y1 =  x1<=x+a/2 && x1>=x-a/2 && y1<=y+b/2 && y1>=y-b/2\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n  	area (Circle r a b) = 3.14*r*r\r\n\r\n  	perim (Circle r a b) = 2*3.14*r\r\n\r\n	contains (Circle r a b) x1 y1 =  (x1-a)*(x1-a)+(y1-b)*(y1-b) <= r*r\r\n','<br/>Тесты успешно пройдены!'),(7509,108,'15309342','2013-11-11 10:13:35',0,'queens n k = queens\' n k k (const True)\r\nqueens\' _ 0 _  _ = [[]]\r\nqueens\' 0 _ _  _ = [[]]\r\nqueens\' _ _ 0  _ = [[]]\r\nqueens\' n k s cond = [ (y1, y2):xs | y1 <- [1..k], y2 <- [1..n], cond (y1, y2), xs <- queens\' n k (s - 1) (	 -> let \r\n                                x1 = fst t\r\n                                x2 = snd t\r\n                            in cond t && x1 > y1 && x2 /= y2 && abs (x1 - y1) /= abs (x2 - y2))]','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7508,108,'15309342','2013-11-11 10:04:59',0,'queens n k = queens\' n k k (const True)\r\nqueens\' _ 0 _  _ = [[]]\r\nqueens\' 0 _ _  _ = [[]]\r\nqueens\' _ _ 0  _ = [[]]\r\nqueens\' n k s cond = [ (y1, y2):xs | y1 <- [1..k], y2 <- [1..n], cond (y1, y2), xs <- queens\' n k (s - 1) (	 -> cond t && fst t > y1 && snd t /= y2 && abs (fst t - y1) /= abs (snd t - y2))]','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7507,94,'ip','2013-11-11 07:43:54',2,'--- Не совсем то. Во первых, на схеме должны печататься значения сопротивлений,\r\n--- чтобы можно было их различать\r\n--- Во вторых надо, чтобы схема выводилась без printScheme. Просто мы вводим на консоли\r\n--- схему, и она красиво печатается. Как это сделать, мы проходили.\r\n--- Еще мне тоже кажется, что схема у вас печатается как-то некрасиво.\r\n--- Но это давайте потом обсудим, когда будут исправлены замечания 1 и 2 \r\n \r\n{-\r\n\r\nЗагружает странно, в просмотренном решении пол текста нет, если что http://rghost.net/50088161\r\n\r\n\r\n\r\n\r\n\r\nВроде должно сносно рисовать,хотя тяжело подобрать из-за разной ширины символов\r\n\r\n\r\n\r\no - резистор\r\n\r\n= ||   // - проводник\r\n\r\n\r\n\r\nПримеры:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nprintScheme (Parallel               (Simple 4) (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     )\r\n\r\n\r\n\r\nprintScheme (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nprintScheme ( Parallel (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))   )  (Simple 1))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nprintScheme (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel (Series   (Series  (Series  (Series  (Series  (Series  (Simple 1) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) )\r\n\r\n ((Series (Simple 1) (Simple 2))) ))   )\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndata Scheme = Simple Double |\r\n\r\n     Series Scheme Scheme |\r\n\r\n     Parallel Scheme Scheme\r\n\r\n\r\n\r\n--вспомогательная структура\r\n\r\ndata Dt = Triple [String] Integer Integer\r\n\r\n\r\n\r\n--печатает схему\r\n\r\nprintScheme x = putStr (printScheme2 (buildScheme x) )\r\n\r\n\r\n\r\n--вспомогательная функция\r\n\r\nprintScheme2 [] = \"\"\r\n\r\nprintScheme2 (x:xs) = (show x) ++ [\'\r\n\'] ++ (printScheme2 xs)\r\n\r\n\r\n\r\n--строит список строк рисунка по схеме\r\n\r\nbuildScheme x = let\r\n\r\n                Triple xs w h = electric x\r\n\r\n                in xs\r\n\r\n                 \r\n\r\n\r\n\r\n--разбирает схему на каждом шаге составив \'рисунок\' снизу вверх\r\n\r\nelectric (Simple _) = Triple [\"o\"] 1 1\r\n\r\nelectric (Series x y) = let\r\n\r\n                        Triple xs w h = electric x\r\n\r\n                        Triple ys w2 h2 =  electric y\r\n\r\n                        in Triple (handleS w h w2 h2 xs ys) (w + w2 +1) (max h h2)\r\n\r\nelectric (Parallel x y) = let\r\n\r\n                          Triple xs w h = electric x\r\n\r\n                          Triple ys w2 h2 =  electric y\r\n\r\n                          in Triple (handleP w h w2 h2 xs ys) ((max w w2) + 2) (h + h2 + 1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--случай последовательного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\r\n\r\nhandleS w h w2 h2 xs ys = let\r\n\r\n		          \r\n\r\n                          hp = max h h2\r\n\r\n                          hdiff = div (abs(h - h2)) 2\r\n\r\n			  middle = (mod hp 2)  + (div hp 2)\r\n\r\n			  in\r\n\r\n                          if (h<h2)\r\n\r\n                          then concateBlocks (colums xs hdiff w) ys middle [] 1 \r\n\r\n                          else concateBlocks xs (colums ys hdiff w2) middle [] 1 \r\n\r\n\r\n\r\n--склеивает два блока обеспечивая между ними промежуток\r\n\r\nconcateBlocks [] [] _ out i  = out\r\n\r\nconcateBlocks (x:xs) (y:ys) middle out i  = if (i == middle)\r\n\r\n       					   then concateBlocks xs ys middle (out ++ [(x ++ \"=\" ++ y)]) (i+1) \r\n\r\n					   else concateBlocks xs ys middle (out ++ [(x ++ \"    \" ++ y)]) (i+1) \r\n\r\n\r\n\r\n--добирает высоту меньшего из блоков\r\n\r\ncolums xs 0 _ = xs\r\n\r\ncolums xs d w = let\r\n\r\n                str = createStr \" \" w\r\n\r\n                in\r\n\r\n                colums ([str] ++ xs ++ [str]) (d-1) w\r\n\r\n\r\n\r\n--вспомогательная функция\r\n\r\ncreateStr a 0 = \"\"\r\n\r\ncreateStr a 1 = a\r\n\r\ncreateStr a w = a ++ (createStr a (w-1)) \r\n\r\n\r\n\r\n\r\n\r\n--случай параллельного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\r\n\r\nhandleP w h w2 h2 xs ys = let\r\n\r\n		          wp = (max w w2) + 2\r\n\r\n                          hp = h + h2 + 1\r\n\r\n                          wdiff = (div (abs(w - w2)) 2 ) + 1\r\n\r\n			  middle = (mod h 2)  + (div h 2)\r\n\r\n			  middle2 = (mod h2 2)  + (div h2 2)\r\n\r\n                          str = createStr \"  \" (wp-2)\r\n\r\n			  in\r\n\r\n                          if (w<w2)\r\n\r\n                          --склейка рисунков \'поверху\'\r\n\r\n                          then (strings xs wdiff middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys 1 middle2 1 [])\r\n\r\n                          else (strings xs 1 middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys wdiff middle2 1 [])\r\n\r\n\r\n\r\n--рисует вертикальные части \'проводника\' для верхнего блока (левого аргумента)\r\n\r\nstrings [] _ _ _ out = out\r\n\r\nstrings (x:xs) d middle i out = if (i<middle)\r\n\r\n                        	then let\r\n\r\n                             	     str = createStr \"  \" d\r\n\r\n                             	     in\r\n\r\n                             	     strings xs d middle (i+1) (out ++ [(str ++ x ++ str)])\r\n\r\n                                else if (i == middle)\r\n\r\n                                     then let\r\n\r\n                                          str = createStr \"=\" (d-1)\r\n\r\n                                          in\r\n\r\n                                          strings xs d middle (i+1) (out ++ [(\"//\" ++ str ++ x ++ str ++ \"\")])\r\n\r\n                                     else let\r\n\r\n                                          str = createStr \"  \" (d-1)\r\n\r\n                                          in\r\n\r\n                                          strings xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\r\n\r\n\r\n\r\n--рисует вертикальные части \'проводника\' для нижнего блока (правого аргумента)\r\n\r\nstrings2 [] _ _ _ out = out\r\n\r\nstrings2 (x:xs) d middle i out = if (i>middle)\r\n\r\n                              	 then let\r\n\r\n                             	      str = createStr \"  \"  d\r\n\r\n                             	      in\r\n\r\n                             	      strings2 xs d middle (i+1) (out ++ [(str ++ x ++ str)])\r\n\r\n                                 else if (i == middle)\r\n\r\n                                      then let\r\n\r\n                                           str = createStr \"=\" (d-1)\r\n\r\n                                           in\r\n\r\n                                           strings2 xs d middle (i+1) (out ++ [(\"\" ++ str ++ x ++ str ++ \"//\")])\r\n\r\n                                      else let\r\n\r\n                                           str = createStr \"  \" (d-1)\r\n\r\n                                           in\r\n\r\n                                           strings2 xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7505,94,'ip','2013-11-11 07:39:56',0,'{-\r\nВроде должно сносно рисовать,хотя тяжело подобрать из-за разной ширины символов\r\n\r\nprintScheme ( Parallel (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))   )  (Simple 1))\r\n\r\nprintScheme (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel (Series   (Series  (Series  (Series  (Series  (Series  (Simple 1) (Simple 1) ) (Simple','<br/>Тесты успешно пройдены!'),(7506,94,'ip','2013-11-11 07:40:44',0,'{-\n\nВроде должно сносно рисовать,хотя тяжело подобрать из-за разной ширины символов\n\n\n\no - резистор\n\n= || \\  // - проводник\n\n\n\nПримеры:\n\n\n\n\n\n\n\n\n\n\n\nprintScheme (Parallel               (Simple 4) (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     )\n\n\n\nprintScheme (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))\n\n\n\n\n\n\n\n\n\nprintScheme ( Parallel (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))   )  (Simple 1))\n\n\n\n\n\n\n\n\n\nprintScheme (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel (Series   (Series  (Series  (Series  (Series  (Series  (Simple 1) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) )\n\n ((Series (Simple 1) (Simple 2))) ))   )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-}\n\n\n\n\n\n\n\ndata Scheme = Simple Double |\n\n     Series Scheme Scheme |\n\n     Parallel Scheme Scheme\n\n\n\n--вспомогательная структура\n\ndata Dt = Triple [String] Integer Integer\n\n\n\n--печатает схему\n\nprintScheme x = putStr (printScheme2 (buildScheme x) )\n\n\n\n--вспомогательная функция\n\nprintScheme2 [] = \"\"\n\nprintScheme2 (x:xs) = (show x) ++ [\'\n\'] ++ (printScheme2 xs)\n\n\n\n--строит список строк рисунка по схеме\n\nbuildScheme x = let\n\n                Triple xs w h = electric x\n\n                in xs\n\n                 \n\n\n\n--разбирает схему на каждом шаге составив \'рисунок\' снизу вверх\n\nelectric (Simple _) = Triple [\"o\"] 1 1\n\nelectric (Series x y) = let\n\n                        Triple xs w h = electric x\n\n                        Triple ys w2 h2 =  electric y\n\n                        in Triple (handleS w h w2 h2 xs ys) (w + w2 +1) (max h h2)\n\nelectric (Parallel x y) = let\n\n                          Triple xs w h = electric x\n\n                          Triple ys w2 h2 =  electric y\n\n                          in Triple (handleP w h w2 h2 xs ys) ((max w w2) + 2) (h + h2 + 1)\n\n\n\n\n\n\n\n--случай последовательного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\n\nhandleS w h w2 h2 xs ys = let\n\n		          \n\n                          hp = max h h2\n\n                          hdiff = div (abs(h - h2)) 2\n\n			  middle = (mod hp 2)  + (div hp 2)\n\n			  in\n\n                          if (h<h2)\n\n                          then concateBlocks (colums xs hdiff w) ys middle [] 1 \n\n                          else concateBlocks xs (colums ys hdiff w2) middle [] 1 \n\n\n\n--склеивает два блока обеспечивая между ними промежуток\n\nconcateBlocks [] [] _ out i  = out\n\nconcateBlocks (x:xs) (y:ys) middle out i  = if (i == middle)\n\n       					   then concateBlocks xs ys middle (out ++ [(x ++ \"=\" ++ y)]) (i+1) \n\n					   else concateBlocks xs ys middle (out ++ [(x ++ \"    \" ++ y)]) (i+1) \n\n\n\n--добирает высоту меньшего из блоков\n\ncolums xs 0 _ = xs\n\ncolums xs d w = let\n\n                str = createStr \" \" w\n\n                in\n\n                colums ([str] ++ xs ++ [str]) (d-1) w\n\n\n\n--вспомогательная функция\n\ncreateStr a 0 = \"\"\n\ncreateStr a 1 = a\n\ncreateStr a w = a ++ (createStr a (w-1)) \n\n\n\n\n\n--случай параллельного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\n\nhandleP w h w2 h2 xs ys = let\n\n		          wp = (max w w2) + 2\n\n                          hp = h + h2 + 1\n\n                          wdiff = (div (abs(w - w2)) 2 ) + 1\n\n			  middle = (mod h 2)  + (div h 2)\n\n			  middle2 = (mod h2 2)  + (div h2 2)\n\n                          str = createStr \"  \" (wp-2)\n\n			  in\n\n                          if (w<w2)\n\n                          --склейка рисунков \'поверху\'\n\n                          then (strings xs wdiff middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys 1 middle2 1 [])\n\n                          else (strings xs 1 middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys wdiff middle2 1 [])\n\n\n\n--рисует вертикальные части \'проводника\' для верхнего блока (левого аргумента)\n\nstrings [] _ _ _ out = out\n\nstrings (x:xs) d middle i out = if (i<middle)\n\n                        	then let\n\n                             	     str = createStr \"  \" d\n\n                             	     in\n\n                             	     strings xs d middle (i+1) (out ++ [(str ++ x ++ str)])\n\n                                else if (i == middle)\n\n                                     then let\n\n                                          str = createStr \"=\" (d-1)\n\n                                          in\n\n                                          strings xs d middle (i+1) (out ++ [(\"//\" ++ str ++ x ++ str ++ \"\\\")])\n\n                                     else let\n\n                                          str = createStr \"  \" (d-1)\n\n                                          in\n\n                                          strings xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\n\n\n\n--рисует вертикальные части \'проводника\' для нижнего блока (правого аргумента)\n\nstrings2 [] _ _ _ out = out\n\nstrings2 (x:xs) d middle i out = if (i>middle)\n\n                              	 then let\n\n                             	      str = createStr \"  \"  d\n\n                             	      in\n\n                             	      strings2 xs d middle (i+1) (out ++ [(str ++ x ++ str)])\n\n                                 else if (i == middle)\n\n                                      then let\n\n                                           str = createStr \"=\" (d-1)\n\n                                           in\n\n                                           strings2 xs d middle (i+1) (out ++ [(\"\\\" ++ str ++ x ++ str ++ \"//\")])\n\n                                      else let\n\n                                           str = createStr \"  \" (d-1)\n\n                                           in\n\n                                           strings2 xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\n\n\n','<br/>Тесты успешно пройдены!'),(7504,94,'ip','2013-11-11 07:35:42',0,'{-\n\nВроде должно сносно рисовать,хотя тяжело подобрать из-за разной ширины символов\n\n\n\no - резистор\n\n= || \\  // - проводник\n\n\n\nПримеры:\n\n\n\n\n\n\n\n\n\n\n\nprintScheme (Parallel               (Simple 4) (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     )\n\n\n\nprintScheme (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))\n\n\n\n\n\n\n\n\n\nprintScheme ( Parallel (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))   )  (Simple 1))\n\n\n\n\n\n\n\n\n\nprintScheme (Series     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3)))     (Parallel               (Parallel ((Series (Simple 1) (Simple 2))) (Simple 3))     (Parallel (Series   (Series  (Series  (Series  (Series  (Series  (Simple 1) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) ) (Simple 1) )\n\n ((Series (Simple 1) (Simple 2))) ))   )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-}\n\n\n\n\n\n\n\ndata Scheme = Simple Double |\n\n     Series Scheme Scheme |\n\n     Parallel Scheme Scheme\n\n\n\n--вспомогательная структура\n\ndata Dt = Triple [String] Integer Integer\n\n\n\n--печатает схему\n\nprintScheme x = putStr (printScheme2 (buildScheme x) )\n\n\n\n--вспомогательная функция\n\nprintScheme2 [] = \"\"\n\nprintScheme2 (x:xs) = (show x) ++ [\'\n\'] ++ (printScheme2 xs)\n\n\n\n--строит список строк рисунка по схеме\n\nbuildScheme x = let\n\n                Triple xs w h = electric x\n\n                in xs\n\n                 \n\n\n\n--разбирает схему на каждом шаге составив \'рисунок\' снизу вверх\n\nelectric (Simple _) = Triple [\"o\"] 1 1\n\nelectric (Series x y) = let\n\n                        Triple xs w h = electric x\n\n                        Triple ys w2 h2 =  electric y\n\n                        in Triple (handleS w h w2 h2 xs ys) (w + w2 +1) (max h h2)\n\nelectric (Parallel x y) = let\n\n                          Triple xs w h = electric x\n\n                          Triple ys w2 h2 =  electric y\n\n                          in Triple (handleP w h w2 h2 xs ys) ((max w w2) + 2) (h + h2 + 1)\n\n\n\n\n\n\n\n--случай последовательного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\n\nhandleS w h w2 h2 xs ys = let\n\n		          \n\n                          hp = max h h2\n\n                          hdiff = div (abs(h - h2)) 2\n\n			  middle = (mod hp 2)  + (div hp 2)\n\n			  in\n\n                          if (h<h2)\n\n                          then concateBlocks (colums xs hdiff w) ys middle [] 1 \n\n                          else concateBlocks xs (colums ys hdiff w2) middle [] 1 \n\n\n\n--склеивает два блока обеспечивая между ними промежуток\n\nconcateBlocks [] [] _ out i  = out\n\nconcateBlocks (x:xs) (y:ys) middle out i  = if (i == middle)\n\n       					   then concateBlocks xs ys middle (out ++ [(x ++ \"=\" ++ y)]) (i+1) \n\n					   else concateBlocks xs ys middle (out ++ [(x ++ \"    \" ++ y)]) (i+1) \n\n\n\n--добирает высоту меньшего из блоков\n\ncolums xs 0 _ = xs\n\ncolums xs d w = let\n\n                str = createStr \" \" w\n\n                in\n\n                colums ([str] ++ xs ++ [str]) (d-1) w\n\n\n\n--вспомогательная функция\n\ncreateStr a 0 = \"\"\n\ncreateStr a 1 = a\n\ncreateStr a w = a ++ (createStr a (w-1)) \n\n\n\n\n\n--случай параллельного соединения w h w2 h2 ширина высота 1-го 2-го блока сответственно xs ys списки строк рисунка\n\nhandleP w h w2 h2 xs ys = let\n\n		          wp = (max w w2) + 2\n\n                          hp = h + h2 + 1\n\n                          wdiff = (div (abs(w - w2)) 2 ) + 1\n\n			  middle = (mod h 2)  + (div h 2)\n\n			  middle2 = (mod h2 2)  + (div h2 2)\n\n                          str = createStr \"  \" (wp-2)\n\n			  in\n\n                          if (w<w2)\n\n                          --склейка рисунков \'поверху\'\n\n                          then (strings xs wdiff middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys 1 middle2 1 [])\n\n                          else (strings xs 1 middle 1 []) ++ [\"||\" ++ str ++ \"||\"] ++ (strings2  ys wdiff middle2 1 [])\n\n\n\n--рисует вертикальные части \'проводника\' для верхнего блока (левого аргумента)\n\nstrings [] _ _ _ out = out\n\nstrings (x:xs) d middle i out = if (i<middle)\n\n                        	then let\n\n                             	     str = createStr \"  \" d\n\n                             	     in\n\n                             	     strings xs d middle (i+1) (out ++ [(str ++ x ++ str)])\n\n                                else if (i == middle)\n\n                                     then let\n\n                                          str = createStr \"=\" (d-1)\n\n                                          in\n\n                                          strings xs d middle (i+1) (out ++ [(\"//\" ++ str ++ x ++ str ++ \"\\\")])\n\n                                     else let\n\n                                          str = createStr \"  \" (d-1)\n\n                                          in\n\n                                          strings xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\n\n\n\n--рисует вертикальные части \'проводника\' для нижнего блока (правого аргумента)\n\nstrings2 [] _ _ _ out = out\n\nstrings2 (x:xs) d middle i out = if (i>middle)\n\n                              	 then let\n\n                             	      str = createStr \"  \"  d\n\n                             	      in\n\n                             	      strings2 xs d middle (i+1) (out ++ [(str ++ x ++ str)])\n\n                                 else if (i == middle)\n\n                                      then let\n\n                                           str = createStr \"=\" (d-1)\n\n                                           in\n\n                                           strings2 xs d middle (i+1) (out ++ [(\"\\\" ++ str ++ x ++ str ++ \"//\")])\n\n                                      else let\n\n                                           str = createStr \"  \" (d-1)\n\n                                           in\n\n                                           strings2 xs d middle (i+1) (out ++ [(\"||\" ++ str ++ x ++ str ++ \"||\")])\n\n\n','<br/>Тесты успешно пройдены!'),(7503,96,'3320654','2013-11-11 01:11:49',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace ConsoleApplication3\r\n\r\n{\r\n\r\n    class Program \r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> x = a.GetEnumerator();\r\n\r\n            IEnumerator<int> y = b.GetEnumerator();                     \r\n\r\n            bool checkX = x.MoveNext();\r\n\r\n            bool checkY = y.MoveNext();\r\n\r\n            bool check = true;\r\n\r\n            while (check)\r\n\r\n            {\r\n\r\n                if (x.Current < y.Current)\r\n\r\n                {\r\n\r\n                    yield return x.Current;\r\n\r\n                    checkX = x.MoveNext();\r\n\r\n                }\r\n\r\n                else if (x.Current > y.Current)\r\n\r\n                {\r\n\r\n                    yield return y.Current;\r\n\r\n                    checkY = y.MoveNext();\r\n\r\n                }\r\n\r\n                else if (x.Current == y.Current)\r\n\r\n                {\r\n\r\n                    yield return x.Current;\r\n\r\n                    checkX = x.MoveNext();\r\n\r\n                    checkY = y.MoveNext();\r\n\r\n                }\r\n\r\n                check = checkX && checkY;\r\n\r\n            }\r\n\r\n            while (checkX)\r\n\r\n            {\r\n\r\n                yield return x.Current;\r\n\r\n                checkX = x.MoveNext();\r\n\r\n            }\r\n\r\n            while (checkY)\r\n\r\n            {\r\n\r\n                yield return y.Current;\r\n\r\n                checkY = y.MoveNext();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7502,85,'MaryK','2013-11-11 01:05:49',1,'\r\ndata Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n    (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2 + n2*d1) (d1*d2)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n    (Rat n1 d1) < (Rat n2 d2) = if (d1*d2 > 0) then n1*d2 < n2*d1 else n1*d2 > n2*d1\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n    (Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat n d) = show n ++ \"/\" ++ show d\r\n\r\n        \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7501,95,'3320654','2013-11-11 00:41:49',1,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication3\r\n{\r\n    class Program \r\n    {\r\n        public static bool allDifferent(int[] a)\r\n        {\r\n            return allDifferent1(a, 0, t => true);\r\n        }\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n        {\r\n            if (a.Length == from)            \r\n                return true;            \r\n            else\r\n            {                                \r\n                if (!cond(a[from]))\r\n                    return false;\r\n                else return allDifferent1(a, from + 1, t => cond (t) && t != a[from]);   \r\n            }\r\n        }\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] a = { 1, 2, 3, 4, 5 };\r\n            Console.WriteLine(allDifferent(a));\r\n            a[4] = 2;\r\n            Console.WriteLine(allDifferent(a));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7499,90,'ip','2013-11-11 00:05:47',1,'findSame xs = findSame2 xs (	 ->True) (0,False)\r\n\r\n\r\n\r\nfindSame2 [] cond (a,b) = (a,b)\r\n\r\nfindSame2 (x:xs) cond (a,b) = if (cond x)  \r\n\r\n			      then findSame2 xs (	 -> ((cond t) && (x /= t)) ) (a,False)\r\n\r\n                              else (x,True)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7500,89,'ip','2013-11-11 00:23:29',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nflatten x = flatten2 x []\r\n\r\n\r\n\r\nflatten2 Empty xs = xs\r\n\r\nflatten2 (Node i Empty Empty) xs = i:xs \r\n\r\nflatten2 (Node i l r) xs = i:(flatten2 l (flatten2 r xs))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7498,108,'3320654','2013-11-10 23:52:58',1,'queens n k = queens\' n (k + 1) k ((k,x) -> True)\r\n\r\nqueens\' _ _ 0 _	= [[]]\r\nqueens\' n mK k cond	= [(mK - k, x) : kxs | x <- [1..n], cond (mK - k,x), kxs <- (queens\' n mK (k - 1) ((tk,tx) -> (cond (tk,tx) && (tx /= x) && (abs (tx - x) /= abs (tk - (mK - k))))))]','<br/>Тесты успешно пройдены!'),(7497,135,'ip','2013-11-10 23:46:08',1,'superMap f xs = foldl (x t -> x ++ (f t)) [] xs \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7494,90,'MaryK','2013-11-10 23:18:46',0,'findSame xs = findSame\' xs (-1)\r\n\nfindSame\' (x:xs) r = if (elem x xs) then findSame\' [] x else findSame\' xs r \r\n\nfindSame\' [] r = r\n','<br/>Тесты успешно пройдены!'),(7495,90,'MaryK','2013-11-10 23:27:00',1,'findSame xs = findSame\' xs (-1) 0\r\n\r\nfindSame\' (x:xs) r c = if (r == x) && (elem x xs) then findSame\' xs x (c+1) else if (elem x xs)&&(c==0) then (findSame\' xs x 1) else findSame\' xs r c\r\n\r\nfindSame\' [] r c = (r,c) \r\n','<br/>Тесты успешно пройдены!'),(7496,86,'ip','2013-11-10 23:38:08',1,'allNondivisible xs = allNondivisible2 xs (	 ->True) \r\n\r\n\r\n\r\nallNondivisible2 [] cond = True\r\n\r\nallNondivisible2 (x:xs) cond = if (cond x)  \r\n\r\n			       then allNondivisible2 xs (	 -> ((cond t) && (mod x t /= 0) && (mod t x /= 0)))\r\n\r\n                               else False\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7493,85,'ip','2013-11-10 22:57:43',1,'data Ration  = Rat  Integer Integer\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n (Rat x y) < (Rat a b) = if (x*y < 0)\r\n\r\n			 then if (a*b < 0)\r\n\r\n			      then abs(x*b) > abs(y*a)\r\n\r\n			      else True\r\n\r\n                         else if (a*b < 0)\r\n\r\n                              then False\r\n\r\n                              else abs(x*b) < abs(y*a)\r\n\r\ninstance Eq Ration where \r\n\r\n (Rat x y) == (Rat a b) = (x*b == y*a) \r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n (Rat x y) + (Rat a b) = Rat (x*b + y*a) (b*y)\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n show (Rat a b) = (show a) ++ \"/\" ++ (show b)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7492,136,'1595828','2013-11-10 22:45:49',2,'  --- Не совсем правильно, вот такой тест не проходит:\r\n  ---   Pol [1,1]+Pol [1,-1] == Pol [2]\r\n  --- Кроме того show должен не просто выводить список, а делать это более-мнее красиво, что-то вроде\r\n  --- 1+2*x+3*x^2\r\n\r\ndata Polynomial = Pol [Int] \r\n\r\nmultiplyByX (Pol p1) = Pol (0:p1)\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	(Pol p1) + (Pol p2) = if (length p1 >= length p2) \r\n\r\n							then Pol (zipWith (+) p1 (p2 ++ repeat 0))\r\n\r\n							else Pol (zipWith (+) p2 (p1 ++ repeat 0))\r\n\r\n				\r\n\r\n	(Pol []) *(Pol p2) = Pol []\r\n\r\n	(Pol (p:p1)) * (Pol p2) = let   \r\n\r\n									a= map (p*) p2\r\n\r\n									b= multiplyByX(Pol p1 * Pol p2)\r\n\r\n							  in (Pol a) + b\r\n\r\n	\r\n\r\ninstance Eq Polynomial where\r\n\r\n    (Pol p1) == (Pol p2) = p1 == p2\r\n\r\ninstance Show Polynomial where\r\n\r\n    show (Pol p1) =  show p1\r\n\r\n','<br/>Тесты успешно пройдены!'),(7491,76,'ip','2013-11-10 22:31:59',1,'data Circle = Circle Double Double Double\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n area:: a -> Double\r\n\r\n perim:: a -> Double\r\n\r\n contains:: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n area (Circle r _ _) = 3.14*r*r\r\n\r\n perim (Circle r _ _) = 2*3.14*r\r\n\r\n contains (Circle r x y) a b = if (sqrt ((x-a)^2+(y-b)^2)) <= r\r\n\r\n                                then True\r\n\r\n                                else False\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n area (Rect x y _ _) = x*y\r\n\r\n perim (Rect x y _ _) = 2*(x+y)\r\n\r\n contains (Rect w h x y) a b = if (abs(x-a)<=(w/2)) && (abs(y-b)<=(h/2))\r\n\r\n                                then True\r\n\r\n                                else False\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7490,76,'ip','2013-11-10 22:30:38',0,'data Circle = Circle Double Double Double\n\ndata Rect = Rect Double Double Double Double\n\n\n\nclass Shape a where\n\n area:: a -> Double\n\n perim:: a -> Double\n\n isInShape:: a -> Double -> Double -> Bool\n\n\n\ninstance Shape Circle where\n\n area (Circle r _ _) = 3.14*r*r\n\n perim (Circle r _ _) = 2*3.14*r\n\n isInShape (Circle r x y) a b = if (sqrt ((x-a)^2+(y-b)^2)) <= r\n\n                                then True\n\n                                else False\n\n\n\ninstance Shape Rect where\n\n area (Rect x y _ _) = x*y\n\n perim (Rect x y _ _) = 2*(x+y)\n\n isInShape (Rect w h x y) a b = if (abs(x-a)<=(w/2)) && (abs(y-b)<=(h/2))\n\n                                then True\n\n                                else False\n\n\n','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7488,135,'MaryK','2013-11-10 21:20:12',0,'','Не удалось вычислить выражение \"let f x = [x*x, 100*x] in superMap f [1,2,3]\", проверьте правильность синтаксиса'),(7489,135,'MaryK','2013-11-10 21:20:29',1,'superMap :: (a -> [b]) -> [a] -> [b]\r\n\r\nsuperMap f =  foldr ((++) . f) []\r\n','<br/>Тесты успешно пройдены!'),(7487,76,'MaryK','2013-11-10 20:38:20',1,'data Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where \r\n\r\n    area :: a->Double\r\n\r\n    perim :: a->Double\r\n\r\n    contains :: a ->Double->Double->Bool\r\n\r\n\r\n\r\ninstance Shape Rect where \r\n\r\n    area (Rect x y r1 r2) = x*y\r\n\r\n    perim (Rect x y r1 r2) = 2*(x+y)\r\n\r\n    contains (Rect x y r1 r2) t1 t2 = t1<(r1+x/2)&&t1>(r1-x/2)&&t2<(r2+y/2)&&t2>(r2-y/2) \r\n\r\n\r\n\r\ninstance Shape Circle where \r\n\r\n    area (Circle r r1 r2) = 3.14*r*r\r\n\r\n    perim (Circle r r1 r2) = 2*3.14*r\r\n\r\n    contains (Circle r r1 r2) t1 t2 = (t1 - r1)*(t1-r1)+(t2-r2)*(t2-r2)<= r*r\r\n','<br/>Тесты успешно пройдены!'),(7486,76,'MaryK','2013-11-10 20:35:57',0,'data Rect = Rect Double Double (Double,Double)\r\n\ndata Circle = Circle Double (Double,Double)\r\n\n\r\n\nclass Shape a where \r\n\n    area :: a->Double\r\n\n    perim :: a->Double\r\n\n    contains :: a ->Double->Double->Bool\r\n\n\r\n\ninstance Shape Rect where \r\n\n    area (Rect x y c) = x*y\r\n\n    perim (Rect x y c) = 2*(x+y)\r\n\n    contains (Rect x y c) t1 t2 = t1<(fst(c)+x/2)&&t1>(fst(c)-x/2)&&t2<(snd(c)+y/2)&&t2>(snd(c)-y/2) \r\n\n\r\n\ninstance Shape Circle where \r\n\n    area (Circle r c) = 3.14*r*r\r\n\n    perim (Circle r c) = 2*3.14*r\r\n\n    contains (Circle r c) t1 t2 = (t1 - fst(c))*(t1-fst(c))+(t2-snd(c))*(t2-snd(c))<= r*r\n','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7485,76,'MaryK','2013-11-10 20:32:19',0,'data Rect = Rect Double Double (Double,Double)\r\n\ndata Circle = Circle Double (Double,Double)\r\n\n\r\n\nclass Shape a where \r\n\narea :: a->Double\r\n\nperim :: a->Double\r\n\ncontains :: a ->Double->Double->Bool\r\n\n\r\n\ninstance Shape Rect where \r\n\narea (Rect x y c) = x*y\r\n\nperim (Rect x y c) = 2*(x+y)\r\n\ncontains (Rect x y c) t1 t2 = t1<(fst(c)+x/2)&&t1>(fst(c)-x/2)&&t2<(snd(c)+y/2)&&t2>(snd(c)-y/2) \r\n\n\r\n\ninstance Shape Circle where \r\n\narea (Circle r c) = 3.14*r*r\r\n\nperim (Circle r c) = 2*3.14*r\r\n\ncontains (Circle r c) t1 t2 = (t1 - fst(c))*(t1-fst(c))+(t2-snd(c))*(t2-snd(c))<= r*r\n','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7484,89,'8519021','2013-11-10 20:32:03',1,'data Tree = Empty | Node Int Tree Tree\r\n\r\n\r\n\r\nflatten tree = flatten\' tree []\r\n\r\nflatten\' Empty res = res\r\n\r\nflatten\' (Node num l r) res = num : (flatten\' l (flatten\' r res))\r\n','<br/>Тесты успешно пройдены!'),(7483,108,'Artur','2013-11-10 20:31:55',1,'  --- Вроде все правильно, даже не знаю, почему была ошибка.\r\nqueens n k = map ((xs,cond) -> zip [1..] xs ) (queens\' n k )\r\n\r\nqueens\' n 0 = [([],j-> const True)]\r\nqueens\' n (k+1) = [(x:xs,i j->cond i j && j /= x && i + j /= x +(length (x:xs)) && i - j /= (length (x:xs)) - x )| \r\n					(xs,cond) <- (queens\' n k), x<- [1..n], cond (length (x:xs)) x ] ','Не удалось вычислить выражение \"length(queens 3 2)\", проверьте правильность синтаксиса'),(7480,89,'MaryK','2013-11-10 19:23:23',1,'data Tree a = Node a (Tree a) (Tree a) | Empty\r\n\r\n\r\n\r\nflatten :: Tree a -> [a]\r\n\r\nflatten x = (flatten\' x) []\r\n\r\n\r\n\r\nflatten\' :: Tree a -> [a] -> [a]\r\n\r\nflatten\' (Node x left right) l = x:(flatten\' left ((flatten\' right l)))\r\n\r\nflatten\' Empty l = l\r\n','<br/>Тесты успешно пройдены!'),(7481,90,'8519021','2013-11-10 20:17:49',1,'data Result = None | Element Int\r\n\r\n\r\n\r\ninstance Show Result where\r\n\r\n   show (Element a) = show a ++ \" is found\"\r\n\r\n   show (None) = show \"Element is not found\"\r\n\r\n	\r\n\r\nfindSame xs = findSame\' xs []\r\n\r\nfindSame\' [] _ = None\r\n\r\nfindSame\' (x:xs) s = if elem x s then Element x else findSame\' xs (x:s)\r\n','<br/>Тесты успешно пройдены!'),(7482,108,'Artur','2013-11-10 20:30:53',0,'queens n k = map ((xs,cond) -> zip [1..] xs ) (queens\' n k )\r\n\n\r\n\nqueens\' n 0 = [([],j-> const True)]\r\n\nqueens\' n (k+1) = [(x:xs,i j->cond i j && j /= x && i + j /= x +(length (x:xs)) && i - j /= (length (x:xs)) - x )| \r\n\n					(xs,cond) <- (queens\' n k), x<- [1..n], cond (length (x:xs)) x ] \n','Не удалось вычислить выражение \"length(queens 3 2)\", проверьте правильность синтаксиса'),(7477,86,'MaryK','2013-11-10 19:05:53',0,'\r\n\n\r\n\nallNondivisible xs = allNondivisible\' xs (const False)\r\n\n\r\n\nallNondivisible\' (x:xs) check =\r\n\n    if (check x)\r\n\n    then True\r\n\n    else allNondivisible\' xs (	 -> (check t) && (x `mod` t == 0) && (t `mod` x == 0))\r\n\nallNondivisible\' [] _ = False\n','Выражение имеет неправильное значение: allNondivisible [4, 7, 6, 5]'),(7478,86,'MaryK','2013-11-10 19:09:25',1,'allNondivisible xs = allNondivisible\' xs (const False)\r\n\r\n\r\n\r\nallNondivisible\' (x:xs) check =\r\n\r\n    if (check x)\r\n\r\n    then False\r\n\r\n    else allNondivisible\' xs (	 -> (check t) || ((x `mod` t == 0) || (t `mod` x == 0)))\r\n\r\nallNondivisible\' [] _ = True\r\n','<br/>Тесты успешно пройдены!'),(7479,89,'MaryK','2013-11-10 19:20:39',0,'data Tree a = Node a (Tree a) (Tree a) | Empty\r\n\n\r\n\nflatten :: Tree a -> [a]\r\n\nflatten x = (flatten\' x) []\r\n\n\r\n\nflatten\' :: Tree a -> [a] -> [a]\r\n\nflatten\' (Node x left right) l = (flatten\' left (x:(flatten\' right l)))\r\n\nflatten\' Empty l = l\n','Выражение имеет неправильное значение: flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))'),(7475,136,'MaryK','2013-11-10 18:59:03',2,'  --- Вообще хорошо, но еще не совсем правильно, вот такой тест не проходит:\r\n  ---   Lin [1,1]+Lin [1,-1] == Lin [2]\r\n  --- Исправьте, пожалуйста.\r\n\r\nimport Data.List\r\n\r\n\r\n\r\ndata Lin = Lin [Int]\r\n\r\n\r\n\r\ninstance Num Lin where\r\n\r\n    (Lin (x1:xs1)) + (Lin (x2:xs2)) = \r\n\r\n        let\r\n\r\n            Lin ys = Lin xs1 + Lin xs2\r\n\r\n        in Lin ((x1 + x2):ys)\r\n\r\n\r\n\r\n    Lin xs1 + Lin [] = Lin xs1\r\n\r\n    Lin [] + Lin xs2 = Lin xs2\r\n\r\n\r\n\r\n    (Lin (x1:xs1)) * (Lin (x2:xs2)) =\r\n\r\n        let\r\n\r\n            Lin ys = (Lin [x1]) * Lin xs2 + Lin xs1 * Lin (x2:xs2)\r\n\r\n        in Lin ((x1*x2):ys)\r\n\r\n    _ * _ = Lin []\r\n\r\n\r\n\r\ninstance Eq Lin where\r\n\r\n    Lin [] == Lin [] = True\r\n\r\n    Lin xs1 == Lin [] = False\r\n\r\n    Lin [] == Lin xs2 = False\r\n\r\n    Lin (x1:xs1) == Lin (x2:xs2) = if (x1==x2) then (Lin xs1 == Lin xs2) else False\r\n\r\n\r\n\r\ninstance Show Lin where\r\n\r\n    show (Lin xs) =\r\n\r\n        let\r\n\r\n            len = length xs\r\n\r\n            ys = foldr (x res -> ((x, len - length res - 1):res)) [] xs\r\n\r\n            zs = map ((x, power) -> if (power == 0)\r\n\r\n                                     then show x\r\n\r\n                                     else (show x) ++ \"*x^\" ++ show power) ys \r\n\r\n        in foldl (\r\nes str -> if res /= \"\"\r\n\r\n                              then res ++ \" + \" ++ str\r\n\r\n                              else str) \"\" zs \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nallNondivisible xs = allNondivisible\' xs (const False)\r\n\r\n\r\n\r\nallNondivisible\' (x:xs) check =\r\n\r\n    if (check x)\r\n\r\n    then True\r\n\r\n    else allNondivisible\' xs (	 -> (check t) || (x `mod` t == 0) || (t `mod` x == 0))\r\n\r\nallNondivisible\' [] _ = False','<br/>Тесты успешно пройдены!'),(7476,86,'MaryK','2013-11-10 18:59:28',0,'import Data.List\r\n\n\r\n\ndata Lin = Lin [Int]\r\n\n\r\n\ninstance Num Lin where\r\n\n    (Lin (x1:xs1)) + (Lin (x2:xs2)) = \r\n\n        let\r\n\n            Lin ys = Lin xs1 + Lin xs2\r\n\n        in Lin ((x1 + x2):ys)\r\n\n\r\n\n    Lin xs1 + Lin [] = Lin xs1\r\n\n    Lin [] + Lin xs2 = Lin xs2\r\n\n\r\n\n    (Lin (x1:xs1)) * (Lin (x2:xs2)) =\r\n\n        let\r\n\n            Lin ys = (Lin [x1]) * Lin xs2 + Lin xs1 * Lin (x2:xs2)\r\n\n        in Lin ((x1*x2):ys)\r\n\n    _ * _ = Lin []\r\n\n\r\n\ninstance Eq Lin where\r\n\n    Lin [] == Lin [] = True\r\n\n    Lin xs1 == Lin [] = False\r\n\n    Lin [] == Lin xs2 = False\r\n\n    Lin (x1:xs1) == Lin (x2:xs2) = if (x1==x2) then (Lin xs1 == Lin xs2) else False\r\n\n\r\n\ninstance Show Lin where\r\n\n    show (Lin xs) =\r\n\n        let\r\n\n            len = length xs\r\n\n            ys = foldr (x res -> ((x, len - length res - 1):res)) [] xs\r\n\n            zs = map ((x, power) -> if (power == 0)\r\n\n                                     then show x\r\n\n                                     else (show x) ++ \"*x^\" ++ show power) ys \r\n\n        in foldl (\res str -> if res /= \"\"\r\n\n                              then res ++ \" + \" ++ str\r\n\n                              else str) \"\" zs \r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nallNondivisible xs = allNondivisible\' xs (const False)\r\n\n\r\n\nallNondivisible\' (x:xs) check =\r\n\n    if (check x)\r\n\n    then True\r\n\n    else allNondivisible\' xs (	 -> (check t) || (x `mod` t == 0) || (t `mod` x == 0))\r\n\nallNondivisible\' [] _ = False\n','Выражение имеет неправильное значение: allNondivisible [2, 7, 6, 5]'),(7473,100,'1990147','2013-11-10 18:55:36',0,'allDiffLists m n = allDiffLists\' m n []\r\nallDiffLists\' 0 n xs = [[]]\r\nallDiffLists\' m n xs = [i:j| i<-[1..n], j<-allDiffLists\' (m-1) n (i:xs), not (elem i xs)]','<br/>Тесты успешно пройдены!'),(7474,136,'1990147','2013-11-10 18:57:17',2,'  --- Не совсем правильно, вот такой тест не проходит:\r\n  --- Poly [(1,0),(1,1)]+Poly [(1,0),(-1,1)] == Poly [(2,0)]\r\n\r\ndata Poly = Poly [(Integer,Integer)]\r\n\r\n\r\n\r\ninstance Num Poly where \r\n\r\n         Poly xs + Poly ys = \r\n\r\n              Poly (sumpol (podob (qsort xs)) (podob (qsort ys)))\r\n\r\n         Poly xs * Poly ys = Poly (podob (qsort(mult (podob (qsort xs)) (podob (qsort ys)))))\r\n\r\n\r\n\r\n\r\n\r\nqsort [] = []\r\n\r\nqsort (x:xs) = qsort [t | t<-xs, snd t<= snd x] ++ \r\n\r\n                            [x] ++ qsort [t | t<-xs, snd t>snd x]\r\n\r\n\r\n\r\npodob [] = []\r\n\r\npodob (y:[]) = [y]\r\n\r\npodob (x:y:xs) = if (snd x == snd y) then podob ((fst x + fst y,snd x):xs)\r\n\r\n               else (x: (podob (y:xs)))\r\n\r\n\r\n\r\nsumpol [] xs = xs\r\n\r\nsumpol xs [] = xs\r\n\r\nsumpol (x:xs) (y:ys) = if (snd x == snd y) then ((fst x + fst y,snd x):(sumpol xs ys))\r\n\r\n                       else if (snd x < snd y) then (x:(sumpol xs (y:ys)))\r\n\r\n                            else (y:(sumpol (x:xs) ys))\r\n\r\n\r\n\r\n\r\n\r\nmult xs ys = [(i,j)|x<-xs,y<-ys,let i=(fst x)*(fst y),let j = (snd x)+(snd y)]\r\n\r\n\r\n\r\ninstance Eq Poly where\r\n\r\n         Poly xs == Poly ys =  checker xs ys\r\n\r\n\r\n\r\nchecker [] [] = True\r\n\r\nchecker [] ys = False\r\n\r\nchecker xs [] = False\r\n\r\nchecker (x:xs) (y:ys) = if ((fst x == fst y) && (snd x == snd y)) then checker xs ys\r\n\r\n                                                                  else False\r\n\r\n\r\n\r\ninstance Show Poly where \r\n\r\n         show (Poly []) = []\r\n\r\n         show (Poly (x:[])) = \"(\"++show (fst x) ++ \"x^\" ++ show (snd x) ++\")\"\r\n\r\n         show (Poly (x:xs)) = \"(\"++show (fst x) ++ \"x^\" ++ show (snd x) ++\")+\"++ show (Poly xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7469,86,'1990147','2013-11-10 18:48:31',2,'  --- Нет, это не тот прием, о котором шла речь в условии.  Посмотрите слайды, пожалуйста.\r\nallNondivisible (x:xs) = allNondivisible\' xs [x]\r\nallNondivisible\' [] xs = True\r\nallNondivisible\' (x:xs) a = if (any (i-> mod x i==0 || mod i x==0) a) then False\r\n                            else allNondivisible\' xs (x:a)','<br/>Тесты успешно пройдены!'),(7470,135,'1990147','2013-11-10 18:52:32',1,'superMap f xs = foldl (++) [] (map f xs)','<br/>Тесты успешно пройдены!'),(7471,90,'1990147','2013-11-10 18:53:59',1,'findSame xs = findSame\' xs []\r\nfindSame\' [] s = (-100500,False)\r\nfindSame\' (x:xs) s = if elem x s then (x,True)\r\n			               else findSame\' xs (x:s)\r\n','<br/>Тесты успешно пройдены!'),(7472,89,'1990147','2013-11-10 18:55:05',1,'data Tree= Empty | Node Integer Tree Tree \r\n\r\nflatten tree = flatten\' tree []\r\nflatten\' Empty xs = xs\r\nflatten\' (Node val l r) xs = let l1 = flatten\' r (xs) \r\n                                 l2 = flatten\' l (l1)\r\n                             in val:l2\r\n','<br/>Тесты успешно пройдены!'),(7468,85,'1990147','2013-11-10 18:47:27',1,'nod x 0 = x\r\n\r\nnod a b = nod b (mod a b)\r\n\r\n\r\n\r\ndata Rat = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Rat where\r\n\r\n         (Rat ch1 zn1) + (Rat ch2 zn2) = let n=nod a b\r\n\r\n                                             a=ch1*zn2+ch2*zn1\r\n\r\n                                             b=zn1*zn2\r\n\r\n                                         in  (Rat (div a n) (div b n))\r\n\r\n\r\n\r\ninstance Eq Rat where\r\n\r\n         (Rat ch1 zn1) == (Rat ch2 zn2) = let n=nod ch1 zn1\r\n\r\n                                              m=nod ch2 zn2\r\n\r\n                                          in  div ch1 n == div ch2 m && div zn1 n == div zn2 m\r\n\r\n\r\n\r\ninstance Show Rat where\r\n\r\n         show (Rat ch zn) = if (zn>0) then show ch ++ \"/\" ++ show zn\r\n\r\n                            else if (zn<0) then show (-ch) ++ \"/\" ++ show (-zn)\r\n\r\n                                 else \"error\"\r\n\r\n\r\n\r\ninstance Ord Rat where\r\n\r\n         (Rat ch1 zn1) < (Rat ch2 zn2) = let ch1\'= if (zn1<0) then -ch1\r\n\r\n                                                   else ch1\r\n\r\n                                             ch2\'= if (zn2<0) then -ch2\r\n\r\n                                                   else ch2\r\n\r\n                                          in ch1\'*(abs zn2) < ch2\'*(abs zn1)\r\n','<br/>Тесты успешно пройдены!'),(7467,85,'1990147','2013-11-10 18:25:47',0,'nod x 0 = x\r\nnod a b = nod b (mod a b)\r\n\r\ndata Rat = Rat Integer Integer\r\n\r\ninstance Num Rat where\r\n         (Rat ch1 zn1) + (Rat ch2 zn2) = let n=nod a b\r\n                                             a=ch1*zn2+ch2*zn1\r\n                                             b=zn1*zn2\r\n                                         in  (Rat (div a n) (div b n))\r\n\r\ninstance Eq Rat where\r\n         (Rat ch1 zn1) == (Rat ch2 zn2) = let n=nod ch1 zn1\r\n                                              m=nod ch2 zn2\r\n                                          in  div ch1 n == div ch2 m && div zn1 n == div zn2 m\r\n\r\ninstance Show Rat where\r\n         show (Rat ch zn) = show ch ++ \"/\" ++ show zn\r\n\r\ninstance Ord Rat where\r\n         (Rat ch1 zn1) < (Rat ch2 zn2) = ch1*zn2 < ch2*zn1','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7466,85,'1990147','2013-11-10 18:25:16',0,'nod x 0 = x\r\n\nnod a b = nod b (mod a b)\r\n\n\r\n\ndata Rat = Rat Integer Integer\r\n\n\r\n\ninstance Num Rat where\r\n\n         (Rat ch1 zn1) + (Rat ch2 zn2) = let n=nod a b\r\n\n                                             a=ch1*zn2+ch2*zn1\r\n\n                                             b=zn1*zn2\r\n\n                                         in  (Rat (div a n) (div b n))\r\n\n\r\n\ninstance Eq Rat where\r\n\n         (Rat ch1 zn1) == (Rat ch2 zn2) = let n=nod ch1 zn1\r\n\n                                              m=nod ch2 zn2\r\n\n                                          in  div ch1 n == div ch2 m && div zn1 n == div zn2 m\r\n\n\r\n\ninstance Show Rat where\r\n\n         show (Rat ch zn) = show ch ++ \"/\" ++ show zn\r\n\n\r\n\ninstance Ord Rat where\r\n\n         (Rat ch1 zn1) < (Rat ch2 zn2) = ch1*zn2 < ch2*zn1\n','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(7464,76,'1990147','2013-11-10 18:16:07',0,'','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7465,76,'1990147','2013-11-10 18:24:54',1,'class Shape a where\r\n   area:: a -> Double\r\n   perim:: a -> Double\r\n   contains:: a-> Double -> Double -> Bool\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n  	area (Circle r x0 y0) = 3.14*r*r\r\n  	perim (Circle r x0 y0) = 2*3.14*r\r\n        contains (Circle r x0 y0) x y = (x0-x)^2+(y0-y)^2<=r^2\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where\r\n  	area (Rect w h x0 y0) = w*h\r\n  	perim (Rect w h x0 y0) = 2*(w+h)\r\n        contains (Rect w h x0 y0) x y = (x-x0)<=(w/2) && (x-x0)>=(-w/2) && \r\n                                        (y-y0)<=(h/2) && (y-y0)>=(-h/2)\r\n\r\n','<br/>Тесты успешно пройдены!'),(7463,76,'1990147','2013-11-10 18:14:23',0,'class Shape a where\r\n\n   area:: a -> Double\r\n\n   perim:: a -> Double\r\n\n   contains:: a-> Double -> Double -> Bool\r\n\n\r\n\ndata Circle = Circle Double Double Double\r\n\n\r\n\ninstance Shape Circle where\r\n\n  	area (Circle r x0 y0) = 3.14*r*r\r\n\n  	perim (Circle r x0 y0) = 2*3.14*r\r\n\n        contains (Circle r x0 y0) x y = (x0-x)^2+(y0-y)^2<=r^2\r\n\n\r\n\ndata Rect = Rect Double Double Double Double\r\n\n\r\n\ninstance Shape Rect where\r\n\n  	area (Rect w h x0 y0) = w*h\r\n\n  	perim (Rect w h x0 y0) = 2*(w+h)\r\n\n        contains (Rect w h x0 y0) x y = (x-x0)<=(w/2) && (x-x0)>=(-w/2) && \r\n\n                                        (y-y0)<=(h/2) && (y-y0)>=(-h/2)\r\n\n\r\n\n\r\n\n\n','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7462,85,'2501950','2013-11-10 18:01:06',1,'  --- У вас в последней строчке опечатка, посмотрите внимательнее :)\r\ndata Rat = Rat Double Double\r\n\r\ninstance Num Rat where\r\n   (Rat n1 n2) + (Rat m1 m2) = Rat (n1 * m2 + m1 * n2) (n2 * m2)\r\n--у меня задача не компилируется\r\ninstance Eq Rat where\r\n    Rat n1 n2 == Rat m1 m2 = n1 == m1 && n2 == m2\r\n\r\ninstance Ord Rat where\r\n    Rat n1 n2 < Rat m1 m2 = (n1 * m2) < (m1 * n2) \r\n\r\ninstance Show Rat where\r\n    show (Rat n1 n2) == show n1 ++ \"/\" ++ show n2\r\n','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(7461,90,'42284313','2013-11-10 17:19:44',1,'{--\r\n\r\n\r\n\r\n    Пусть нас попросили написать функцию findSame, которая для данного списка возвращает элемент, который в нем встречается больше одного раза. Например, для [1,2,3,2,5] надо вернуть 2.\r\n\r\n\r\n\r\n    Мы, естественно, просим уточнить:\r\n\r\n        - Что делать, если таких элементов несколько?\r\n\r\n        - Что делать, если таких элементов вообще нет?\r\n\r\n\r\n\r\n    А нам сказали:\r\n\r\n        - Если из несколько, можно вернуть любой.\r\n\r\n        - Если вообще нет таких элементов - ну, нам сказали, придумайте что-нибудь.. Подойдет любое решение, но надо, чтобы пользователь мог понять, нашлось что-то или нет.\r\n\r\n\r\n\r\n    Задача: придумать интерфейс для findSame и реализовать эту функцию.\r\n\r\n\r\n\r\n    Примеры вызова:\r\n\r\n\r\n\r\n        findSame [1,2,3,2,5]\r\n\r\n\r\n\r\n    Должно получиться что-то на ваше усмотрение, но, видимо это должно быть число 2 и еще м.б. какая-то дополнительная информация.\r\n\r\n\r\n\r\n        findSame [1,3,2,5]\r\n\r\n\r\n\r\n    Должно получиться что-то на ваше усмотрение, но, видимо это должна быть какая-то информация о том, что мы ничего не нашли.\r\n\r\n\r\n\r\n    Замечания:\r\n\r\n        - Самый первый вариант, который лично мне приходит в голову - это вернуть пару (число, логическое значение). Это, на самом деле, видимо вовсе не лучший вариант, но вполне нормальный. Если хотите, можете его реализовать, а можете придумать что-то другое.\r\n\r\n        - Просто на всякий случай, в этой задаче _не_ требуется использовать прием с представлением множества, как функции. Тут подойдет любая простая реализация.\r\n\r\n\r\n\r\n--}\r\n\r\ndata Result a = None | Element a deriving Show\r\n\r\n\r\n\r\nsearch [] _ = None\r\n\r\nsearch (x:xs) acc = if elem x acc then Element x else search xs (x:acc)\r\n\r\nfindSame xs = search xs []\r\n','<br/>Тесты успешно пройдены!'),(7459,136,'ilia','2013-11-10 16:34:11',1,'zip_arr _ x [ ] = x\r\n\r\nzip_arr _ [ ] y = y\r\n\r\nzip_arr f (xh:x) (yh:y) = f xh yh : zip_arr f x y\r\n\r\nreduce_arr x = reverse (reduce_arr\' (reverse x))\r\n\r\nreduce_arr\' [ ] = [ ]\r\n\r\nreduce_arr\' (xh:x)\r\n\r\n	| xh == 0 = reduce_arr\' x\r\n\r\n	| otherwise = xh : x\r\n\r\nequal_pol x y = let\r\n\r\n		xr = reduce_arr x\r\n\r\n		yr = reduce_arr y\r\n\r\n	in\r\n\r\n		xr == yr\r\n\r\nsum_pol x y = zip_arr (+) x y\r\n\r\nmul_pol (xh:x) y = let\r\n\r\n		ri = map (*xh) y\r\n\r\n	in\r\n\r\n		if length x == 0 then\r\n\r\n			ri\r\n\r\n		else\r\n\r\n			zip_arr (+) (0 : mul_pol x y) ri\r\n\r\nshow_pol x = show_pol\' x 0\r\n\r\nshow_pol\' [ ] _ = \"\"\r\n\r\nshow_pol\' (xh:x) i\r\n\r\n	| i == 0 = show_pol\' x (i + 1)\r\n\r\n			++ show xh\r\n\r\n	| otherwise = show_pol\' x (i + 1)\r\n\r\n			++ show xh ++ \"*x^\" ++ show i ++ \"+\"\r\n\r\n\r\n\r\ndata Polynomial = Pol [ Integer ]\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	Pol x == Pol y = equal_pol x y\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	Pol x + Pol y = Pol (sum_pol x y)\r\n\r\n	Pol x * Pol y = Pol (mul_pol x y)\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Pol x) = show_pol (reduce_arr x)\r\n\r\n\r\n\r\ncall op op_str x y = show x ++ \" \" ++ op_str ++ \" \" ++ show y\r\n\r\n		++ \" = \" ++ show (op x y)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (call (+) \"+\" (Pol [1]) (Pol [2, 1]))\r\n\r\n	print (call (*) \"*\" (Pol [1, 2]) (Pol [3, 2, 1]))\r\n\r\n	print (call (*) \"*\" (Pol [1, 1] * Pol [1, 1])\r\n\r\n			(Pol [1, 1] * Pol [1, 1]))\r\n\r\n	print (call (x y -> x == y) \"==\" (Pol [1]) (Pol [1, 0]))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7460,89,'42284313','2013-11-10 17:12:30',1,'{--\r\n\r\n    Task 6\r\n\r\n    Опишите функцию flatten, которая для данного дерева возвращает список из всех значений, записанных в вершинах дерева.\r\n\r\n\r\n\r\n    Пожелание: \r\n\r\n    Было бы замечательно, если бы вы написали реализацию flatten, которая не использует операцию ++. Потому что ++, как мы знаем, работает медленно и flatten получится неэффективным. Но, если не придумаете, подойдет любая реализация, и с использованием ++.\r\n\r\n\r\n\r\n    Пример вызова:\r\n\r\n\r\n\r\n    flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n\r\n    Должно получиться\r\n\r\n\r\n\r\n    [1,2,3] \r\n\r\n\r\n\r\n    Замечание:\r\n\r\n    - Желательно, чтобы значения шли в в таком порядке, как в примере (вершина, потом левое поддерево, потом правое поддерево).\r\n\r\n--}\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\ngenerateList Empty result = result\r\n\r\ngenerateList (Node n l r) result = n : generateList l (generateList r result)\r\n\r\nflatten tree = generateList tree []\r\n','<br/>Тесты успешно пройдены!'),(7458,136,'3320654','2013-11-10 15:56:39',2,'  --- Не совсем правильно, вот такой тест не проходит:\r\n  ---   Pol [1,1]+Pol [1,-1] == Pol [2]\r\ndata Polynomial = Pol [Double]\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n  (Pol x) + (Pol y) = Pol (help x y)\r\n\r\n  (Pol x) * (Pol y) = Pol (help\' x y 0)\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n  (Pol x) == (Pol y) = x == y\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n  show (Pol x) = show\' x 0\r\n\r\n\r\n\r\nshow\' [x] k		= \"+\" ++ show x ++ \"x^\" ++ show k\r\n\r\nshow\' (x:xs) 0 	= show x ++ (show\' xs 1)\r\n\r\nshow\' (x:xs) k	= \"+\" ++ show x ++ \"x^\" ++ show k ++ (show\' xs (k + 1))\r\n\r\n\r\n\r\nhelp list []		= list\r\n\r\nhelp [] list		= list\r\n\r\nhelp (x:xs) (y:ys) 	= (x + y) : (help xs ys)\r\n\r\n\r\n\r\nhelp\' (x:xs) (y:ys) k	= let \r\n\r\n			lx = length (x:xs)\r\n\r\n			ly = length (y:ys)\r\n\r\n			maxDegree = lx + ly - 2\r\n\r\n		   in \r\n\r\n			(sum [((x:xs) !! z) * ((y:ys) !! w) | z <- [0..(lx - 1)], w <- [0..(ly - 1)], z + w == k]) :\r\n\r\n				if (k + 1) <= maxDegree\r\n\r\n				then (help\' (x:xs) (y:ys) (k + 1))\r\n\r\n				else []','<br/>Тесты успешно пройдены!'),(7457,100,'5543298','2013-11-10 13:27:02',2,'  --- Нет, это не совсем то, что имелось в виду. Имелось в виду, что _вместо_ вспомогательного параметра\r\n  --- списка, который был в примере на занятиях, надо использовать множество.\r\n  --- Точно так же как мы это делали в теме \"Представление множества с помощью логической функции\"\r\nallLists n 0 _= [[]]	\r\n\r\nallLists n k ys = [x:xs | x <- [1..n], xs <- allLists n (k-1) (x:ys)]\r\n\r\nallDiffLists\' [] _ _ _= []\r\n\r\nallDiffLists\' (x:xs) f n k = if f x n k then x:(allDiffLists\' xs f n k) else allDiffLists\' xs f n k \r\n\r\nallDiffLists n k = let xs = allLists n k [] in allDiffLists\' xs isElement n k \r\n\r\n\r\n\r\nisElement\' [] _ _ _ = True \r\n\r\nisElement\' (x:xs) cond n k = if not (cond x) || x > n || x < 1 then False else isElement\' xs (	 -> cond t && t /= x) n k\r\n\r\nisElement xs n k = isElement\' xs (	 -> True) n k \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7453,76,'MaryK','2013-11-10 01:33:15',0,'module Func where\r\n\n\r\n\nimport Prelude(Bool(..),instance,zipWith,Double(..),(!!),const,filter,RealFloat(),(&&),null,not,take,(<=),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\n\r\n\ndata Rect = Rect Double Double (Double,Double)\r\n\ndata Circle = Circle Double (Double,Double)\r\n\n\r\n\nclass Shape a where \r\n\narea:: a->Double\r\n\nperim:: a->Double\r\n\ncontains:: a ->Double->Double->Bool\r\n\n\r\n\ninstance Shape Rect where \r\n\narea (Rect x y c) = x*y\r\n\nperim (Rect x y c) = 2*(x+y)\r\n\ncontains (Rect x y c) t1 t2 = if t1<(fst(c)+x/2)&&t1>(fst(c)-x/2)&&t2<(snd(c)+y/2)&&t2>(snd(c)-y/2) \r\n\n\r\n\ninstance Shape Circle where \r\n\narea (Circle r c) = 3.14*r*r\r\n\nperim (Circle r c) = 2*3.14*r\r\n\ncontains (Circle r c) t1 t2 = if (t1 - fst(c))*(t1-fst(c))+(t2-snd(c))*(t2-snd(c))<= r*r then True else False \r\n\n\n','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7454,136,'MaryK','2013-11-10 01:40:49',2,' --- Не компилируется. А вы вообще отлаживали программу??\r\nmodule Func where\r\n\r\n\r\n\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),const,filter,RealFloat(),(&&),null,not,take,(<=),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ndata Lin = Lin [Int] \r\n\r\n\r\n\r\ninstance Num Lin where\r\n\r\n(x1:xs1) + (x2:xs2) = (x1+x2):(xs1+xs2)\r\n\r\nxs1 + [] = xs1\r\n\r\n[] + xs2 = xs2\r\n\r\n\r\n\r\n(x1:xs1) * (x2:xs2) = (x1*x2):[x1]*xs2 + xs1*(x2:xs2)\r\n\r\n_ * _ = []\r\n\r\n\r\n\r\nxs1 == [] = False\r\n\r\n[] == xs2 = False\r\n\r\n[] == [] = True\r\n\r\n(x1:xs1) == (x2:xs2) = if (x1==x2) then (xs1 == xs2) else False\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7455,136,'nomeansno','2013-11-10 04:36:19',1,'import Data.List\r\n\r\ndata Polynom = Polynom [(Int,Double)] -- список одночленов(степень,коэффициент) в произвольном порядке\r\n\r\n\r\n\r\ninstance Show Polynom where\r\n\r\n	show (Polynom p) = if p\'/=[] then foldr ((d,k) s -> s ++ show k ++  \"*x^\" ++ show d ++ \"+\") \"\" (tail p\') ++ show k_ ++ \"*x^\" ++ show d_ else \"empty\"\r\n\r\n		where p\' = filter ((d,k) -> k/=0) p; (d_,k_) = head p\'\r\n\r\n\r\n\r\ninstance Num Polynom where\r\n\r\n	(Polynom p1) + (Polynom p2) = (Polynom p)\r\n\r\n		where p = pgroup (sort p1++p2)\r\n\r\n		--where p = pmerge (sort p1) (sort p2) \r\n\r\n\r\n\r\n	(Polynom p1) * (Polynom p2) = (Polynom p)\r\n\r\n		where p = pgroup (sort p\')\r\n\r\n			where p\' = [(d1+d2,k1*k2) | (d1,k1)<-p1, (d2,k2)<-p2]\r\n\r\n\r\n\r\ninstance Eq Polynom where\r\n\r\n	(Polynom p1) == (Polynom p2) = length (filter ((d,k) -> k/=0) p\') == 0\r\n\r\n		where (Polynom p\') = (Polynom p1) + (Polynom p2\')\r\n\r\n			where p2\' = map ((d,k)->(d,-k)) p2\r\n\r\n\r\n\r\npgroup\' [] res (d,k) = res.((d,k):)\r\n\r\npgroup\' ((d1,k1):xs) res (d,k) = if (d1==d) then pgroup\' xs res (d,k+k1) else pgroup\' xs (res.((d,k):)) (d1,k1)\r\n\r\npgroup [] = []\r\n\r\npgroup s = (pgroup\' (tail s\') id (head s\')) []\r\n\r\n        where s\' = sort s\r\n\r\n\r\n\r\n--pmerge [] s = s\r\n\r\n--pmerge s [] = s\r\n\r\n--pmerge ((d1,k1):xs) ((d2,k2):ys) = if (d1>d2) then (d2,k2):pmerge ((d1,k1):xs) ys else if (d1<d2) then (d1,k1):pmerge xs ((d2,k2):ys) else (d1,k1+k2):pmerge xs ys\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7456,136,'5543298','2013-11-10 13:03:16',1,'import Data.List\r\n\r\n\r\n\r\ndata Polynom = Poly [(Double, Int)] \r\n\r\n\r\n\r\ninstance Num Polynom where \r\n\r\n (Poly xs) + (Poly ys) = Poly (merge (reduce (sort\' xs))  (reduce (sort\' ys)))\r\n\r\n (Poly xs) * (Poly ys) = let zs = reduce (sort\' xs) in let ws = reduce (sort\' ys) in foldr (x res -> res + x) (Poly [(0,0)]) (map ((yk, yi) -> Poly (map ((xk,xi) -> (xk * yk, xi + yi)) zs)) ws)\r\n\r\n  \r\n\r\nsort\' xs = sortBy ((x,y) (z,w) -> compare y w ) xs\r\n\r\n  \r\n\r\nreduce xs = filter ((a,b) -> a /= 0 || b == 0) (map (xs -> foldr ((x,y) (r1,r2) -> (r1 + x, y)) (0,0) xs) (groupBy ((x,y) (w,z) -> y == z) xs))\r\n\r\nreduce [] = []\r\n\r\n \r\n\r\nmerge ((xk, xi):xs) ((yk,yi):ys) = \r\n\r\n    if (xi < yi) then (xk,xi) : merge xs ((yk,yi):ys)\r\n\r\n    else if (xi > yi) then (yk,yi) : merge ((xk,xi):xs) ys\r\n\r\n    else (xk + yk,xi) : merge xs ys\r\n\r\n\r\n\r\nmerge xs ys = xs ++ ys\r\n\r\n \r\n\r\ninstance Eq Polynom where\r\n\r\n    Poly xs == Poly ys = let zs = reduce (sort\' xs) in let ws = reduce (sort\' ys) in (length zs == length ws)  && (comp zs ws)\r\n\r\n\r\n\r\ncomp [] [] = True 	\r\n\r\ncomp ((xk,xi):xs) ((yk,yi):ys) = xk == yk && xi == yi && comp xs ys  \r\n\r\n	\r\n\r\ninstance Show Polynom where\r\n\r\n    show (Poly xs) = let ys = (reduce (sort\' xs)) in if length ys == 0 then \"null\" else foldl (\r\nes x -> res ++ \" +\" ++ toString x) (toString (head ys)) (tail ys)\r\n\r\n	\r\n\r\ntoString (x,y) = \" \" ++ (if x /= 1 then (show x) ++ \" * \" else \"\") ++ (if (y /= 1 && y /= 0) then \"x^\" ++ (show y) else if y == 1 then \"x\" else \"1\")\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7451,108,'artem.gomerman','2013-11-09 23:44:36',1,'queens n k = queens\' n k 1 (const True) (const True)\r\n\r\nqueens\' n 0 _ _ _ = [[]]\r\n\r\nqueens\' n k x condY cond = [((x, y):xs) | y <- filter condY [1..n], cond (x, y), xs <- (queens\' n (k - 1) (x + 1) (v -> y /= v && condY v) ((u, v) -> abs (x - u) /= abs (y - v) && cond (u, v)))]\r\n','<br/>Тесты успешно пройдены!'),(7452,109,'artem.gomerman','2013-11-10 00:08:56',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    static void AllDiffLists1(int n, int k, Predicate<int> condition, Action printAction)\r\n\r\n    {\r\n\r\n        if (k == 0)\r\n\r\n        {\r\n\r\n            printAction();\r\n\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n        for (int i = 1; i <= n; i++)\r\n\r\n        {\r\n\r\n            if (condition(i))\r\n\r\n            {\r\n\r\n                AllDiffLists1(n, k - 1, x => condition(x) && x != i, () => { printAction(); Console.Write(\"{0} \", i); });\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    static void AllDiffLists(int n, int k)\r\n\r\n    {\r\n\r\n        AllDiffLists1(n, k, x => true, () => { /* empty action */ });\r\n\r\n    }\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Console.Write(\"AllDiffLists\r\nInput \'n\':\");\r\n\r\n        int n = int.Parse(Console.ReadLine());\r\n\r\n        Console.Write(\"Input \'k\':\");\r\n\r\n        int k = int.Parse(Console.ReadLine());\r\n\r\n        AllDiffLists(n, k);\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7450,95,'5543298','2013-11-09 23:35:54',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"26.1\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8, 9, 10 };\r\n\r\n                        int[] b = { 3, 5, 9, 5, 6 };\r\n\r\n                        Console.WriteLine(allDifferent(a));\r\n\r\n                        Console.WriteLine(allDifferent(b));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"26.2\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8 };\r\n\r\n                        int[] b = { 3, 5, 9 };\r\n\r\n                        foreach (int i in Merge(a, b))\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"23.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var num in Lst137())\r\n\r\n                        {\r\n\r\n                            Console.Write(\"{0}, \", num);\r\n\r\n                            k++;\r\n\r\n                            if (k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"20.2\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var pair in cantor())\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(pair);\r\n\r\n                            k++;\r\n\r\n                            if (k == 50)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (a.Length == from)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            var x = a[from];\r\n\r\n            if (!cond(x))\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            return allDifferent1(a, ++from, t => cond(t) && t != x);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var result = new List<int>();\r\n\r\n            var aen = a.GetEnumerator();\r\n\r\n            var ben = b.GetEnumerator();\r\n\r\n            var isAEmpty = !aen.MoveNext();\r\n\r\n            var isBEmpty = !ben.MoveNext();\r\n\r\n            int x, y;\r\n\r\n            while (!isAEmpty && !isBEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                y = ben.Current;\r\n\r\n                if (x < y)\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                }\r\n\r\n                else if (y < x)\r\n\r\n                {\r\n\r\n                    result.Add(y);\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                } \r\n\r\n                else\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            while (!isAEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                result.Add(x);\r\n\r\n                isAEmpty = !aen.MoveNext();\r\n\r\n            }\r\n\r\n            while (!isBEmpty)\r\n\r\n            {\r\n\r\n                y = ben.Current;\r\n\r\n                result.Add(y);\r\n\r\n                isBEmpty = !ben.MoveNext();\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                var next = i * 10;\r\n\r\n                yield return next + 1;\r\n\r\n                yield return next + 3;\r\n\r\n                yield return next + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var resPowN = new BigInteger(0);\r\n\r\n            var left = new BigInteger(1);\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                left *= 10;\r\n\r\n                var min = left - resPowN * 10 * n;\r\n\r\n                var minIndex = 0;\r\n\r\n                for (int j = 1; j < 10; j++)\r\n\r\n                {\r\n\r\n                    var current = left - (resPowN * 10 + j) * n;\r\n\r\n                    if (current < min && current > 0)\r\n\r\n                    {\r\n\r\n                        min = current;\r\n\r\n                        minIndex = j;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                resPowN = resPowN * 10 + minIndex;\r\n\r\n                yield return minIndex;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7448,100,'nomeansno','2013-11-09 22:43:08',1,'allDiffLists\' _ n 0 = [[]]	\r\n\r\nallDiffLists\' cond n k = [x:xs | x<-[1..n], cond x, xs<-allDiffLists\' (	 -> cond t && t/=x) n (k-1)]\r\n\r\nallDiffLists = allDiffLists\' (const True)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7449,96,'5543298','2013-11-09 23:24:08',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"26.2\":\r\n\r\n                    {\r\n\r\n                        int[] a = { 1, 5, 8 };\r\n\r\n                        int[] b = { 3, 5, 9 };\r\n\r\n                        foreach (int i in Merge(a, b))\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"23.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var num in Lst137())\r\n\r\n                        {\r\n\r\n                            Console.Write(\"{0}, \", num);\r\n\r\n                            k++;\r\n\r\n                            if (k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"20.2\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var pair in cantor())\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(pair);\r\n\r\n                            k++;\r\n\r\n                            if (k == 50)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            var result = new List<int>();\r\n\r\n            var aen = a.GetEnumerator();\r\n\r\n            var ben = b.GetEnumerator();\r\n\r\n            var isAEmpty = !aen.MoveNext();\r\n\r\n            var isBEmpty = !ben.MoveNext();\r\n\r\n            int x, y;\r\n\r\n            while (!isAEmpty && !isBEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                y = ben.Current;\r\n\r\n                if (x < y)\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                }\r\n\r\n                else if (y < x)\r\n\r\n                {\r\n\r\n                    result.Add(y);\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                } \r\n\r\n                else\r\n\r\n                {\r\n\r\n                    result.Add(x);\r\n\r\n                    isAEmpty = !aen.MoveNext();\r\n\r\n                    isBEmpty = !ben.MoveNext();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            while (!isAEmpty)\r\n\r\n            {\r\n\r\n                x = aen.Current;\r\n\r\n                result.Add(x);\r\n\r\n                isAEmpty = !aen.MoveNext();\r\n\r\n            }\r\n\r\n            while (!isBEmpty)\r\n\r\n            {\r\n\r\n                y = ben.Current;\r\n\r\n                result.Add(y);\r\n\r\n                isBEmpty = !ben.MoveNext();\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                var next = i * 10;\r\n\r\n                yield return next + 1;\r\n\r\n                yield return next + 3;\r\n\r\n                yield return next + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var resPowN = new BigInteger(0);\r\n\r\n            var left = new BigInteger(1);\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                left *= 10;\r\n\r\n                var min = left - resPowN * 10 * n;\r\n\r\n                var minIndex = 0;\r\n\r\n                for (int j = 1; j < 10; j++)\r\n\r\n                {\r\n\r\n                    var current = left - (resPowN * 10 + j) * n;\r\n\r\n                    if (current < min && current > 0)\r\n\r\n                    {\r\n\r\n                        min = current;\r\n\r\n                        minIndex = j;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                resPowN = resPowN * 10 + minIndex;\r\n\r\n                yield return minIndex;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7431,108,'artem.gomerman','2013-11-09 18:53:19',0,'queens n k = queens\' n k (const True)\r\n\nqueens\' n 0 cond = [[]]\r\n\nqueens\' n k cond = reverse [reverse ((x, y):xs) | x <- [1..k], y <- [1..n], cond (x, y), xs <- (queens\' n (k - 1) ((u, v) -> cond (u, v) && u /= x && v /= y && v /= u + y - x && v /= -u + y + x))]\n','Не удалось вычислить выражение \"length (queens 8 8)\", проверьте правильность синтаксиса'),(7432,76,'617015','2013-11-09 18:56:01',1,'class Shape a where \r\n\r\n	contains:: a->Double->Double->Bool\r\n\r\n\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	contains (Circle r x y) x1 y1 =   ((x1-x)^2+(y1-y)^2 ) <= r^2\r\n\r\n	\r\n\r\ninstance Shape Rect where\r\n\r\n	contains (Rect  a b x y) x1 y1 =  (x1>=x-a/2) && (x1<=x+a/2)&& (y1>=y- b/2) && (y1<=y+b/2)\r\n','<br/>Тесты успешно пройдены!'),(7433,85,'617015','2013-11-09 18:56:35',1,'data Ration = Rat Integer Integer\r\n\r\n	\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat n d) = show n ++ \"/\"++show d\r\n\r\n	\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat n1 d1) < (Rat n2 d2) = n1*d2<n2*d1\r\n\r\n	\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat n1 d1) == (Rat n2 d2) = n1*d2==n2*d1	\r\n\r\n	\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat n1 d1) + (Rat n2 d2) = Rat(n1*d2+ n2*d1) (d1*d2)\r\n\r\n	\r\n\r\n	\r\n\r\n	\r\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7434,90,'nomeansno','2013-11-09 18:59:49',0,'findSame\' _ [] = (0, False)\n\nfindSame\' f (x:xs) = if not (f x) then (x, True) else findSame\' (	 -> f t && t/=x) xs  \n\n\n\nfindSame [] = (0, False)\n\nfindSame (x:xs) = findSame\' (	 -> t/=x) xs\n\n-- return (0,False) : повторяющихся элементов нет вообще\n\n-- return (x,True) : x - первый повторяющийся элемент в списке\n\n \n\n\n','<br/>Тесты успешно пройдены!'),(7435,86,'617015','2013-11-09 19:04:59',0,'allNondivisible xs = allNondivisible\' xs (const True)\r\n\nallNondivisible\' [] _ = True\r\n\nallNondivisible\' (x:xs) cond = if not(cond x) then False else allNondivisible\' xs (	-> cond t && (x `mod` t /= 0 || t `mod` x /= 0 ))\n','Выражение имеет неправильное значение: allNondivisible [2, 7, 6, 5]'),(7436,135,'ArtemK','2013-11-09 19:10:40',1,'superMap f [] = []\r\nsuperMap f (x:xs) = (f x) ++ superMap f xs','<br/>Тесты успешно пройдены!'),(7437,86,'617015','2013-11-09 19:10:53',1,'allNondivisible xs = allNondivisible\' xs (const True)\r\n\r\nallNondivisible\' [] _ = True\r\n\r\nallNondivisible\' (x:xs) cond = if not(cond x) then False else allNondivisible\' xs (	-> cond t && (x `mod` t /= 0 && t `mod` x /= 0 ))\r\n','<br/>Тесты успешно пройдены!'),(7438,90,'617015','2013-11-09 19:11:23',1,'data Result = Res String Integer \r\n\r\n\r\n\r\ninstance Show Result where\r\n\r\n	show (Res  answer value) = show answer ++\" \"++ show value \r\n\r\n\r\n\r\nfindSame xs = findSame\' xs (const True)\r\n\r\nfindSame\' [] _ =  Res \"No same elements\" 0\r\n\r\nfindSame\' (x:xs) cond= if not(cond x) then Res \"The first element which repeats is\"   x else findSame\' xs (	-> cond t && t/=x) \r\n','<br/>Тесты успешно пройдены!'),(7439,89,'617015','2013-11-09 19:11:57',1,'data Tree = Empty| Node Integer Tree Tree\r\n\r\n\r\n\r\nflatten Empty = []\r\n\r\n\r\n\r\nflatten (Node v l r)= v: flatten l ++ flatten r\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7440,90,'ArtemK','2013-11-09 19:20:34',1,'findSame [] = (0, False)\r\nfindSame (x:xs) = findSame\' x xs xs\r\nfindSame\' _ _ [] = (0, False)\r\nfindSame\' _ [] (x:xs) = findSame\' x xs xs\r\nfindSame\' cur (x:xs) ys = if x == cur then (x, True)\r\n                          else findSame\' cur xs ys','<br/>Тесты успешно пройдены!'),(7441,89,'ArtemK','2013-11-09 19:30:01',0,'data Tree = Node Double Tree Tree | Empty\r\nflatten Empty = []\r\nflatten (Node v l r) = v:(flatten l) ++ (flatten r)','Выражение имеет неправильное значение: flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))'),(7442,89,'ArtemK','2013-11-09 19:33:56',1,'data Tree a = Node a (Tree a) (Tree a) | Empty\r\nflatten Empty = []\r\nflatten (Node v l r) = v:(flatten l) ++ (flatten r)','<br/>Тесты успешно пройдены!'),(7443,86,'ArtemK','2013-11-09 19:47:45',0,'allNondivisible xs = allNondivisible\' xs (	 -> False)\r\nallNondivisible\' [] _ = True\r\nallNondivisible\' (x:xs) isDivisible = if (isDivisible x) then False\r\n                                      else allNondivisible\' xs (	 -> isDivisible t || mod t x == 0)','Выражение имеет неправильное значение: allNondivisible [4,2]'),(7444,86,'ArtemK','2013-11-09 19:49:45',1,'allNondivisible xs = allNondivisible\' xs (	 -> False)\r\nallNondivisible\' [] _ = True\r\nallNondivisible\' (x:xs) isDivisible = if (isDivisible x) then False\r\n                                      else allNondivisible\' xs (	 -> isDivisible t || mod t x == 0 || mod x t == 0)\r\n','<br/>Тесты успешно пройдены!'),(7445,100,'ArtemK','2013-11-09 19:58:36',1,'allDiffLists n k = allDiffLists\' n k (	 -> True)\r\nallDiffLists\' n 0 _ = [[]]  \r\nallDiffLists\' n k f = [x:xs | x<-[1..n], f x, \r\n          xs <- allDiffLists\' n (k-1) (	 -> f t && t /= x)]','<br/>Тесты успешно пройдены!'),(7446,90,'nomeansno','2013-11-09 20:47:41',1,'findSame\' _ [] = (0, False)\r\n\r\nfindSame\' f (x:xs) = if not (f x) then (x, True) else findSame\' (	 -> f t && t/=x) xs  \r\n\r\n\r\n\r\nfindSame [] = (0, False)\r\n\r\nfindSame (x:xs) = findSame\' (	 -> t/=x) xs\r\n\r\n-- return (0,False) : повторяющихся элементов нет вообще\r\n\r\n-- return (x,True) : x - первый повторяющийся элемент в списке\r\n\r\n \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7447,89,'nomeansno','2013-11-09 21:49:07',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nflatten\' Empty = id\r\n\r\nflatten\' (Node value left right) = ((value:).sl.sr)\r\n\r\n	where sr = flatten\' right; sl = flatten\' left\r\n\r\n\r\n\r\nflatten tree  = flatten\' tree []\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7422,76,'ArtemK','2013-11-09 17:55:36',1,'class Shape a where\r\n   area:: a -> Double\r\n   perim:: a -> Double\r\n   contains:: a -> Double -> Double -> Bool\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where\r\n   area (Rect w h _ _) = w*h\r\n   perim (Rect w h _ _) = 2*(w+h)\r\n   contains (Rect w h x y) x0 y0 = ((x0 < x + w/2) && (x0 > x - w/2)) && ((y0 < y + h/2) && (y0 > y - h/2))\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n   area (Circle r _ _) = 3.14*r*r\r\n   perim (Circle r _ _) = 2*3.14*r\r\n   contains (Circle r x y) x0 y0 = let\r\n                                    x1 = x0 - x\r\n                                    y1 = y0 - y\r\n                                    in sqrt(x1*x1 + y1*y1) < r','<br/>Тесты успешно пройдены!'),(7423,85,'ArtemK','2013-11-09 18:09:56',0,'--24-2 Rational\r\ndata Rat = Rat Int Int\r\n\r\ninstance Num Rat where\r\n  (Rat a b) + (Rat c d) = Rat (a*d + c*b) (b*d)\r\n\r\ninstance Show Rat where\r\n  show (Rat a b) = show a ++ \"/\" ++ show b\r\n\r\ninstance Eq Rat where\r\n  (Rat a b) == (Rat c d) = a*d == c*b\r\n\r\ninstance Ord Rat where\r\n  (Rat a b) < (Rat c d) = a*d < c*b','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7424,109,'ilia','2013-11-09 18:12:53',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\nimport sys\r\n\r\n\r\n\r\ndef action(before, after, *after_args):\r\n\r\n	before()\r\n\r\n	after(*after_args)\r\n\r\n\r\n\r\ndef print_lists(s, l, f, a):\r\n\r\n	if (l == 0): a(); print \"\"; return\r\n\r\n	for si in [ si for si in s if f(si) ]:\r\n\r\n		print_lists(s, l - 1, lambda x: si != x and f(x),\r\n\r\n				lambda: action(a, sys.stdout.write, \" %s\" % si))\r\n\r\n\r\n\r\ndef allDiffLists(n, k):\r\n\r\n	print_lists(range(1, n + 1), k, lambda x: True,\r\n\r\n			lambda: None)\r\n\r\n\r\n\r\nallDiffLists(3, 2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7425,136,'ilia','2013-11-09 18:21:21',2,'  --- Вот так не совсем правильно:\r\n  --- Pol [2] == Pol [2,0]\r\n  --- у вас выдается False а дб видимо True\r\nzip_arr _ x [ ] = x\r\n\r\nzip_arr _ [ ] y = y\r\n\r\nzip_arr f (xh:x) (yh:y) = f xh yh : zip_arr f x y\r\n\r\nreduce_arr x = reverse (reduce_arr\' (reverse x))\r\n\r\nreduce_arr\' [ ] = [ ]\r\n\r\nreduce_arr\' (xh:x)\r\n\r\n	| xh == 0 = reduce_arr\' x\r\n\r\n	| otherwise = xh : x\r\n\r\nsum_pol x y = zip_arr (+) x y\r\n\r\nmul_pol (xh:x) y = let\r\n\r\n		ri = map (*xh) y\r\n\r\n	in\r\n\r\n		if length x == 0 then\r\n\r\n			ri\r\n\r\n		else\r\n\r\n			zip_arr (+) (0 : mul_pol x y) ri\r\n\r\nshow_pol x = show_pol\' x 0\r\n\r\nshow_pol\' [ ] _ = \"\"\r\n\r\nshow_pol\' (xh:x) i\r\n\r\n	| i == 0 = show_pol\' x (i + 1)\r\n\r\n			++ show xh\r\n\r\n	| otherwise = show_pol\' x (i + 1)\r\n\r\n			++ show xh ++ \"*x^\" ++ show i ++ \"+\"\r\n\r\n\r\n\r\ndata Polynomial = Pol [ Integer ]\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	Pol x == Pol y = x == y\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	Pol x + Pol y = Pol (reduce_arr (sum_pol x y))\r\n\r\n	Pol x * Pol y = Pol (reduce_arr (mul_pol x y))\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Pol x) = show_pol x\r\n\r\n\r\n\r\ncall op op_str x y = show x ++ \" \" ++ op_str ++ \" \" ++ show y\r\n\r\n		++ \" = \" ++ show (op x y)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (call (+) \"+\" (Pol [1]) (Pol [2, 1]))\r\n\r\n	print (call (*) \"*\" (Pol [1, 2]) (Pol [3, 2, 1]))\r\n\r\n	print (call (*) \"*\" (Pol [1, 1] * Pol [1, 1])\r\n\r\n			(Pol [1, 1] * Pol [1, 1]))\r\n\r\n	print (call (+) \"+\" (Pol [1, 2]) (Pol [1, -2]))\r\n\r\n','<br/>Тесты успешно пройдены!'),(7426,85,'ArtemK','2013-11-09 18:30:19',0,'data Rat = Rat Int Int\r\n\r\ninstance Num Rat where\r\n  (Rat a b) + (Rat c d) = Rat (a*d + c*b) (b*d)\r\n\r\ninstance Show Rat where\r\n  show (Rat a b) = if b < 0 then show (Rat (-a) (-b))\r\n                            else show a ++ \"/\" ++ show b\r\n\r\ninstance Eq Rat where\r\n  (Rat a b) == (Rat c d) = a*d == c*b\r\n\r\ninstance Ord Rat where\r\n  (Rat a b) < (Rat c d) = a*d < c*b','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7427,108,'artem.gomerman','2013-11-09 18:34:27',0,'queens n k = queens\' n k (const True)\r\n\nqueens\' n 0 cond = [[]]\r\n\nqueens\' n k cond = [((x, y):xs) | x <- [1..k], y <- [1..n], cond (x, y), xs <- (queens\' n (k - 1) ((u, v) -> cond (u, v) && u /= x && v /= y && v /= u + y && v /= -u + y))]\n','Выражение имеет неправильное значение: length (queens 4 4)'),(7428,85,'ArtemK','2013-11-09 18:34:30',0,'-- Не понимаю, в каком случае с отрицательными работает неправильно :(\r\n\r\ndata Rat = Rat Int Int\r\n\r\ninstance Num Rat where\r\n  (Rat a b) + (Rat c d) = Rat (a*d + c*b) (b*d)\r\n\r\ninstance Show Rat where\r\n  show (Rat a b) = if b < 0 then show (Rat (-a) (-b))\r\n                            else show a ++ \"/\" ++ show b\r\n\r\ninstance Eq Rat where\r\n  (Rat a b) == (Rat c d) = a*d == c*b\r\n\r\ninstance Ord Rat where\r\n  (Rat a b) < (Rat c d) = a*d < c*b','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7429,85,'ArtemK','2013-11-09 18:44:07',0,'data Rat = Rat Int Int\r\n\r\ninstance Num Rat where\r\n  (Rat a b) + (Rat c d) = let adcb = a*d + c*b\r\n                              bd = b*d\r\n                              g = gcd adcb bd\r\n                              in Rat (signum bd * div adcb g) (signum bd * div bd g)\r\n\r\ninstance Show Rat where\r\n  show (Rat a b) = show a ++ \"/\" ++ show b\r\n\r\ninstance Eq Rat where\r\n  (Rat a b) == (Rat c d) = a*d == c*b\r\n\r\ninstance Ord Rat where\r\n  (Rat a b) < (Rat c d) = a*d < c*b','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7430,85,'ArtemK','2013-11-09 18:51:13',1,'data Rat = Rat Int Int\r\n\r\ninstance Num Rat where\r\n  (Rat a b) + (Rat c d) = let adcb = a*d + c*b\r\n                              bd = b*d\r\n                              g = gcd adcb bd\r\n                              in Rat (signum bd * div adcb g) (signum bd * div bd g)\r\n\r\ninstance Show Rat where\r\n  show (Rat a b) = show a ++ \"/\" ++ show b\r\n\r\ninstance Eq Rat where\r\n  (Rat a b) == (Rat c d) = a*d == c*b\r\n\r\ninstance Ord Rat where\r\n  (Rat a b) < (Rat c d) = if b*d > 0 then a*d < c*b else a*d > c*b','<br/>Тесты успешно пройдены!'),(7420,95,'ilia','2013-11-09 17:01:42',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\nhead = lambda x: x[0]\r\n\r\ntail = lambda x: x[1:]\r\n\r\n\r\n\r\ndef allDifferent(x, f = lambda xi: True):\r\n\r\n	return True if len(x) == 0 else f(head(x)) and allDifferent(\r\n\r\n				tail(x), lambda xi: xi != head(x) and f(xi))\r\n\r\n\r\n\r\nprint allDifferent([1, 2, 3, 2, 5])\r\n\r\nprint allDifferent([1, 3, 2, 5])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7421,96,'artem.gomerman','2013-11-09 17:31:46',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    static Random mRandomizer = new Random((int)DateTime.Now.Ticks);\r\n\r\n    static private List<int> generateRandomSortedList(int listLength)\r\n\r\n    {\r\n\r\n        List<int> outputList = new List<int>();\r\n\r\n\r\n\r\n        int previousNumber = 0;\r\n\r\n        for (int i = 0; i < listLength; i++)\r\n\r\n        {\r\n\r\n            int newNumber = previousNumber + mRandomizer.Next(1, 10);\r\n\r\n            previousNumber = newNumber;\r\n\r\n            outputList.Add(newNumber);\r\n\r\n        }\r\n\r\n\r\n\r\n        return outputList;\r\n\r\n    }\r\n\r\n    static private IEnumerable<int> Merge(IEnumerable<int> list1, IEnumerable<int> list2)\r\n\r\n    {\r\n\r\n        // get enumerator of the given IEnumerables\r\n\r\n        IEnumerator<int> enum1 = list1.GetEnumerator();\r\n\r\n        IEnumerator<int> enum2 = list2.GetEnumerator();\r\n\r\n\r\n\r\n        // get first elements in lists\r\n\r\n        bool firstEmpty = enum1.MoveNext();\r\n\r\n        bool secondEmpty = enum2.MoveNext();\r\n\r\n\r\n\r\n        while (true)\r\n\r\n        {\r\n\r\n            // if no more elements in first list\r\n\r\n            if (!firstEmpty)\r\n\r\n            {\r\n\r\n                do\r\n\r\n                {\r\n\r\n                    yield return enum2.Current;\r\n\r\n                } while (enum2.MoveNext());\r\n\r\n                yield break;\r\n\r\n            }\r\n\r\n\r\n\r\n            // if no more elements in second list\r\n\r\n            if (!secondEmpty)\r\n\r\n            {\r\n\r\n                do\r\n\r\n                {\r\n\r\n                    yield return enum1.Current;\r\n\r\n                } while (enum1.MoveNext());\r\n\r\n                yield break;\r\n\r\n            }\r\n\r\n\r\n\r\n            // get current elements of the given IEnumerables\r\n\r\n            int currentFromList1 = enum1.Current;\r\n\r\n            int currentFromList2 = enum2.Current;\r\n\r\n\r\n\r\n            // compare current elements and move enumerator pointer to new position if needed\r\n\r\n            if (currentFromList1 < currentFromList2)\r\n\r\n            {\r\n\r\n                yield return currentFromList1;\r\n\r\n                firstEmpty = enum1.MoveNext();\r\n\r\n            }\r\n\r\n            else if (currentFromList1 > currentFromList2)\r\n\r\n            {\r\n\r\n                yield return currentFromList2;\r\n\r\n                secondEmpty = enum2.MoveNext();\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                yield return currentFromList1; // or currentFromList2. They\'re equal\r\n\r\n                firstEmpty = enum1.MoveNext();\r\n\r\n                secondEmpty = enum2.MoveNext();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Console.Write(\"Testing merge\r\n\");\r\n\r\n\r\n\r\n        int firstListLength = mRandomizer.Next(10, 15);\r\n\r\n        int secondListLength = mRandomizer.Next(15, 20);\r\n\r\n        \r\n\r\n        // generate two random and sorted lists\r\n\r\n        List<int> firstList = generateRandomSortedList(firstListLength);\r\n\r\n        List<int> secondList = generateRandomSortedList(secondListLength);\r\n\r\n\r\n\r\n        // output\r\n\r\n        firstList.ForEach(x => Console.Write(\"{0} \", x));\r\n\r\n        Console.WriteLine();\r\n\r\n        secondList.ForEach(x => Console.Write(\"{0} \", x));\r\n\r\n        Console.Write(\"\r\nMerged IEnumerable:\r\n\");\r\n\r\n        foreach (int x in Merge(firstList, secondList))\r\n\r\n        {\r\n\r\n            Console.Write(\"{0} \", x);\r\n\r\n        }\r\n\r\n        Console.WriteLine();\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7419,136,'ilia','2013-11-09 16:50:55',2,'  --- Не совсем еще правильно, вот такой тест не проходит\r\n  ---  Pol [1,1] + Pol [1,-1] == Pol [2]\r\nimport Debug.Trace\r\n\r\n\r\n\r\nzip_arr _ x [ ] = x\r\n\r\nzip_arr _ [ ] y = y\r\n\r\nzip_arr f (xh:x) (yh:y) = f xh yh : zip_arr f x y\r\n\r\nsum_pol x y = zip_arr (+) x y\r\n\r\nmul_pol (xh:x) y = let\r\n\r\n		ri = map (*xh) y\r\n\r\n	in\r\n\r\n		if length x == 0 then\r\n\r\n			ri\r\n\r\n		else\r\n\r\n			zip_arr (+) (0 : mul_pol x y) ri\r\n\r\nshow_pol x = show_pol\' x 0\r\n\r\nshow_pol\' [ ] _ = \"\"\r\n\r\nshow_pol\' (xh:x) i\r\n\r\n	| i == 0 = show_pol\' x (i + 1)\r\n\r\n			++ show xh\r\n\r\n	| otherwise = show_pol\' x (i + 1)\r\n\r\n			++ show xh ++ \"*x^\" ++ show i ++ \"+\"\r\n\r\n\r\n\r\ndata Polynomial = Pol [ Integer ]\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	Pol x == Pol y = x == y\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	Pol x + Pol y = Pol (sum_pol x y)\r\n\r\n	Pol x * Pol y = Pol (mul_pol x y)\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Pol x) = show_pol x\r\n\r\n\r\n\r\ncall op op_str x y = show x ++ \" \" ++ op_str ++ \" \" ++ show y\r\n\r\n		++ \" = \" ++ show (op x y)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (call (+) \"+\" (Pol [1]) (Pol [2, 1]))\r\n\r\n	print (call (*) \"*\" (Pol [1, 2]) (Pol [3, 2, 1]))\r\n\r\n	print (call (*) \"*\" (Pol [1, 1] * Pol [1, 1])\r\n\r\n			(Pol [1, 1] * Pol [1, 1]))\r\n\r\n','<br/>Тесты успешно пройдены!'),(7418,136,'MaryK','2013-11-09 15:52:13',2,'  --- Не совсем по условию, надо было опреденить именно операторы + * и == а не фунцкии summ b тд\r\n  --- Мы проходили, как это делать.\r\nmodule Func where\r\n\r\n\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),const,filter,RealFloat(),(&&),null,not,take,(<=),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ndata Lin = Lin [Int] deriving (Show)\r\n\r\nclass Mn a \r\n\r\nsumm::a->a->[Int]\r\n\r\nprod::a->a->[Int]\r\n\r\neqviv::a->a->Bool\r\n\r\n\r\n\r\ninstance Lin Mn where\r\n\r\nsumm (Lin (x1:xs1)) (Lin (x2:xs2)) = (x1+x2):(xs1+xs2)\r\n\r\nsumm (Lin xs1) (Lin []) = xs1\r\n\r\nsumm (Lin []) (Lin xs2) = xs2\r\n\r\n\r\n\r\nprod (Lin (x1:xs1)) (Lin (x2:xs2)) = (x1*x2):[x1]*xs2 + xs1*(x2:xs2)\r\n\r\n\r\n\r\neqviv (Lin xs1) (Lin []) = False\r\n\r\neqviv (Lin []) (Lin xs2) = False\r\n\r\neqviv (Lin []) (Lin []) = True\r\n\r\neqviv (Lin (x1:xs1)) (Lin (x2:xs2)) = if (x1==x2) then eqviv (Lin (xs1)) (Lin (xs2)) else False\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7417,136,'3320654','2013-11-09 13:58:19',2,'  --- Что то у вас при умножении совссем не то :( Например Pol [1,1] * Pol [1,1] попробуйте\r\ndata Polynomial = Pol [Double]\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n  (Pol x) + (Pol y) = Pol (help x y)\r\n\r\n  (Pol x) * (Pol y) = Pol (help\' x y 0)\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n  (Pol x) == (Pol y) = x == y\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n  show (Pol x) = show\' x 0\r\n\r\n\r\n\r\nshow\' [x] k		= \"+\" ++ show x ++ \"x^\" ++ show k\r\n\r\nshow\' (x:xs) 0 	= show x ++ (show\' xs 1)\r\n\r\nshow\' (x:xs) k	= \"+\" ++ show x ++ \"x^\" ++ show k ++ (show\' xs (k + 1))\r\n\r\n\r\n\r\nhelp list []		= list\r\n\r\nhelp [] list		= list\r\n\r\nhelp (x:xs) (y:ys) 	= (x + y) : (help xs ys)\r\n\r\n\r\n\r\nhelp\' (x:xs) (y:ys) k	= (sum [z * w | z <- (x:xs), w <- (y:ys), (position z (x:xs) 0) + (position w (y:ys) 0) == k]) :\r\n\r\n			if (k + 1) <= (length (x:xs) + length (y:ys) - 2)\r\n\r\n			then (help\' (x:xs) (y:ys) (k + 1))\r\n\r\n			else []\r\n\r\n\r\n\r\nposition k (x:xs) t	= if (k == x)\r\n\r\n		   then t\r\n\r\n		   else (position k xs (t + 1))','<br/>Тесты успешно пройдены!'),(7414,89,'3320654','2013-11-09 12:48:24',1,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nflatten t = reverse (help t [] [])\r\n\r\n--идея в том, что мы будем хранить точки \"углубления рекурсии\"\r\nhelp Empty [] list		= list\r\nhelp Empty (tx:txs) list		= help tx txs list\r\nhelp (Node val l r) listOfTree list 	= help l (r : listOfTree) (val : list)','<br/>Тесты успешно пройдены!'),(7415,100,'3320654','2013-11-09 13:07:03',0,'allDiffLists n k = allDiffLists\' n k (	 -> True)\r\n-- cond функция, которая проверяет, можно ли добавлять значение\r\nallDiffLists\' n 0 _ 	= [[]]	\r\nallDiffLists\' n k cond	= [x:xs | x<-[1..n], (cond x),  xs <- allDiffLists\' n (k - 1) (	 -> cond x && (not (t == x)))]','Выражение имеет неправильное значение: length (allDiffLists 3 3)'),(7416,100,'3320654','2013-11-09 13:21:58',1,'allDiffLists n k = allDiffLists\' n k (	 -> True)\r\n-- cond функция, которая проверяет, можно ли добавлять значение\r\nallDiffLists\' n 0 _ 	= [[]]	\r\nallDiffLists\' n k cond	= [x:xs | x <- [1..n], (cond x),  xs <- allDiffLists\' n (k - 1) (	 -> cond t && (not (t == x)))]','<br/>Тесты успешно пройдены!'),(7413,96,'1595828','2013-11-09 12:09:35',1,'using System.Collections.Generic;\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections;\r\n\r\nnamespace zd26_2\r\n\r\n{\r\n\r\n    class Task\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> enumerator_a = a.GetEnumerator();\r\n\r\n            IEnumerator<int> enumerator_b = b.GetEnumerator();\r\n\r\n            bool ea= enumerator_a.MoveNext();\r\n\r\n            bool eb=enumerator_b.MoveNext();\r\n\r\n\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                if (ea && !eb)\r\n\r\n                {\r\n\r\n                    yield return enumerator_a.Current;\r\n\r\n                    while (enumerator_a.MoveNext())\r\n\r\n                        yield return enumerator_a.Current;\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n                if (!ea && eb)\r\n\r\n                {\r\n\r\n                    yield return enumerator_b.Current;\r\n\r\n                    while (enumerator_b.MoveNext())\r\n\r\n                        yield return enumerator_b.Current;\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n                if (ea && eb)\r\n\r\n                {\r\n\r\n                    if (enumerator_a.Current == enumerator_b.Current)\r\n\r\n                    {\r\n\r\n                        yield return enumerator_a.Current;\r\n\r\n                        ea = enumerator_a.MoveNext();\r\n\r\n                        eb = enumerator_b.MoveNext();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        if (enumerator_a.Current > enumerator_b.Current)\r\n\r\n                        {\r\n\r\n                            yield return enumerator_b.Current;\r\n\r\n                            eb = enumerator_b.MoveNext();\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                        {\r\n\r\n                            yield return enumerator_a.Current;\r\n\r\n                            ea = enumerator_a.MoveNext();\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                { break; }\r\n\r\n\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 3, 5, 6 };\r\n\r\n            int[] b = { 1, 2, 4, 6, 8, 10, 12, 14 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7412,109,'115753099','2013-11-09 11:43:14',1,'using System;\r\n\r\nnamespace _28_1\r\n{\r\n    class Program\r\n    {\r\n        static void AllDiffLists2(int n, int k, Func<int, bool> f, Action print)\r\n        {\r\n            if (k == 0)\r\n            {\r\n                print();\r\n                Console.WriteLine(\"\");\r\n                return;\r\n            }\r\n            for (int x = 1; x <= n; x++)\r\n            {\r\n                if (f(x))\r\n                {\r\n                    AllDiffLists2(n, k - 1, t => f(t) && t != x, () => { print(); Console.Write(x + \" \"); });\r\n                }\r\n            }\r\n        }\r\n\r\n        static void AllDiffLists(int n, int k)\r\n        {\r\n            AllDiffLists2(n, k, x => true, () => { Console.WriteLine(); });\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            AllDiffLists(3, 2);\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7411,96,'ilia','2013-11-09 03:54:28',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\ndef Merge(a, b):\r\n\r\n	ai = a.__iter__()\r\n\r\n	bi = b.__iter__()\r\n\r\n	an = bn = None\r\n\r\n	while True:\r\n\r\n		try:\r\n\r\n			if an == None: an = next(ai)\r\n\r\n		except: an = None\r\n\r\n		try:\r\n\r\n			if bn == None: bn = next(bi)\r\n\r\n		except: bn = None\r\n\r\n		if an == None or bn == None: break\r\n\r\n		if an < bn: yield an; an = None\r\n\r\n		elif an == bn: yield an; an = bn = None\r\n\r\n		else: yield bn; bn = None\r\n\r\n	if an == None:\r\n\r\n		while True: yield next(bi)\r\n\r\n	while True: yield next(ai)\r\n\r\n\r\n\r\ndef take(n, s):\r\n\r\n	i = 0\r\n\r\n	ret = []\r\n\r\n	for x in s:\r\n\r\n		if (i == n): return ret\r\n\r\n		i += 1\r\n\r\n		ret.append(x)\r\n\r\n\r\n\r\nprint take(-1, Merge([1, 5, 8], [3, 5, 9]))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7409,136,'ilia','2013-11-09 02:57:12',0,'','<br/>Тесты успешно пройдены!'),(7410,136,'ilia','2013-11-09 02:57:38',2,'  --- Что-то не совсем правильно.\r\n  --- Попробуйте например Pol [1,1] * Pol [1,1]*Pol [1,1] * Pol [1,1]\r\ndata Polynomial = Pol [ Integer ]\r\n\r\n\r\n\r\nalign a 0 = a\r\n\r\nalign a l = 0 : align a (l - 1)\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	Pol x == Pol y = let\r\n\r\n			xl = length x\r\n\r\n			yl = length y\r\n\r\n			l = max xl yl\r\n\r\n			xa = align x (l - xl)\r\n\r\n			ya = align y (l - yl)\r\n\r\n		in xa == ya\r\n\r\n\r\n\r\nmyzip f x [] = x\r\n\r\nmyzip f [] y = y\r\n\r\nmyzip f (xh:x) (yh:y) = (f xh yh) : myzip f x y\r\n\r\n\r\n\r\nmul_pol (xh:x) y = let\r\n\r\n		ri = map (*xh) y\r\n\r\n	in\r\n\r\n		if length x == 0 then\r\n\r\n			ri\r\n\r\n		else\r\n\r\n			--mul_pol x y\r\n\r\n			--ri ++ [0]\r\n\r\n			reverse (myzip (+) (reverse (mul_pol x y)) (reverse (ri ++ [0])))\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	Pol x + Pol y = let\r\n\r\n			xl = length x\r\n\r\n			yl = length y\r\n\r\n			l = max xl yl\r\n\r\n			xa = align x (l - xl)\r\n\r\n			ya = align y (l - yl)\r\n\r\n		in Pol (zipWith (+) xa ya)\r\n\r\n	Pol x * Pol y = Pol (mul_pol x y)\r\n\r\n\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Pol x)\r\n\r\n		| length x == 1 = show (head x)\r\n\r\n		| otherwise = show (head x) ++ \"*x^\" ++ show (length x - 1)\r\n\r\n				++ \"+\" ++ show (Pol (tail x))\r\n\r\n\r\n\r\ncall op op_str x y = show x ++ \" \" ++ op_str ++ \" \" ++ show y\r\n\r\n		++ \" = \" ++ show (op x y)\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (call (+) \"+\" (Pol [1]) (Pol [2, 1]))\r\n\r\n	print (call (*) \"*\" (Pol [1, 2]) (Pol [3, 2, 1]))\r\n\r\n','<br/>Тесты успешно пройдены!'),(7408,100,'ilia','2013-11-08 21:17:13',1,'allDiffLists n k = gen_lists [1..n] k (const True)\r\n\r\n\r\n\r\ngen_lists s 1 f = [ [i] | i <- s, f i ]\r\n\r\ngen_lists s l f = [ i : gl | i <- s, f i, gl <- gen_lists s (l - 1) (j -> f j && i /= j) ]\r\n\r\n\r\n\r\nmain = print (allDiffLists 3 2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7407,109,'deripaska','2013-11-08 21:08:16',1,'/*\r\n\r\n	task 28-01\r\n\r\nОписать функцию AllDiffLists с двумя параметрами n и k, которая печатает все последовательности длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\n\r\n\r\nДополнительное условие: \r\n\r\n- В этой задаче нельзя использовать массивы и вообще никакие способы представления данных, кроме целых чисел и лямбда-выражений.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nallDiffLists 3 2\r\n\r\n\r\n\r\nДолжно быть напечатано:\r\n\r\n1 2\r\n\r\n1 3\r\n\r\n2 1\r\n\r\n\r\n\r\n... и т.д., всего 6 строчек(не обязательно именно в таком порядке).\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_28_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static void AllDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            AllDiffLists_Help(n, k, x => true, () => {});\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void AllDiffLists_Help(int n, int k, Func<int, bool> cond, Action writeResult)\r\n\r\n        {\r\n\r\n            if (k == 0)\r\n\r\n            {\r\n\r\n                writeResult();\r\n\r\n				Console.WriteLine();\r\n\r\n            } \r\n\r\n            else \r\n\r\n            {\r\n\r\n                for (int x = 1; x <= n; ++ x)\r\n\r\n                {\r\n\r\n				    if (cond(x))\r\n\r\n				    {\r\n\r\n					    AllDiffLists_Help(n, k - 1, t => cond(t) && t != x, () => { writeResult(); Console.Write(x + \" \"); });\r\n\r\n				    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            AllDiffLists(3, 2);\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7406,109,'romos2007','2013-11-08 19:47:31',1,'﻿/*\r\n\r\n * Задача 28-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _28_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        private static void AllLists(int n, int k, Func<int, bool> Used, Action Write)\r\n\r\n        {\r\n\r\n            if (k >= 1)\r\n\r\n            {\r\n\r\n                for (int x = 1; x <= n; x++)\r\n\r\n                {\r\n\r\n                    if (!Used(x))\r\n\r\n                    {\r\n\r\n                        AllLists(n, k - 1, t => Used(t) || t == x, () => { Write(); Console.Write(\"{0} \", x); });\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                Write();\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void AllDiffLists(int n, int k)\r\n\r\n        {\r\n\r\n            AllLists(n, k, x => false, () => { });\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string s_n, s_k;\r\n\r\n\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                Console.Write(\"\r\nEnter n (exit = hit ENTER): \");\r\n\r\n                s_n = Console.ReadLine();\r\n\r\n                if (s_n == \"\") { break; }\r\n\r\n\r\n\r\n                Console.Write(\"\r\nEnter k (exit = hit ENTER): \");\r\n\r\n                s_k = Console.ReadLine();\r\n\r\n                if (s_k == \"\") { break; }\r\n\r\n\r\n\r\n                int n = Convert.ToInt32(s_n);\r\n\r\n                int k = Convert.ToInt32(s_k);\r\n\r\n\r\n\r\n                AllDiffLists(n, k);\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine(\"\r\n\r\n---------\r\nHappy end. Now hit ENTER\");\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7405,83,'42284313','2013-11-08 19:22:31',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Task23_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Lst137()\r\n        {\r\n            yield return 1;\r\n            yield return 3;\r\n            yield return 7;\r\n            foreach (int i in Lst137())\r\n            {\r\n                yield return 10 * i + 1;\r\n                yield return 10 * i + 3;\r\n                yield return 10 * i + 7;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int count = 0;\r\n            foreach (int i in Lst137())\r\n            {\r\n                Console.Write(i + \" \");\r\n                count++;\r\n                if (count > 30)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7404,18,'5122688','2013-11-08 19:12:20',1,'--','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(7403,90,'ilia','2013-11-08 18:12:49',1,'  --- Очень хорошо, но зря вы мне кажется возвращаете строки. Если пользователю нужно именно значение\r\n  --- (например, он хочет вернуть синус от повторяющегося элемента), ему это будет не очень просто.\r\n  --- Я бы уж скорее просто вернул индекс повторяющегося элемента, или -1 если такого нет.\r\n  --- А дальше пускай пользователь делает с этим что хочет. \r\nfindSame xs = let\r\n\r\n		map = gen_map xs\r\n\r\n		imap = zip map [0..]\r\n\r\n		hmap = filter (i -> fst i /= 1) imap\r\n\r\n	in\r\n\r\n		if length hmap == 0 then\r\n\r\n			\"None\"\r\n\r\n		else\r\n\r\n			show (xs !! (snd (head hmap)))\r\n\r\n\r\n\r\ngen_map xs = [ length (filter (y -> x == y) xs) | x <- xs ]\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (findSame [1, 2, 3, 2, 5])\r\n\r\n	print (findSame [1, 3, 2, 5])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7402,95,'1595828','2013-11-08 17:45:42',1,'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\n    class zd\r\n\r\n    {\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (from == a.Length)  \r\n\r\n                return true;\r\n\r\n            int x = a[from];\r\n\r\n            if (!cond(x))\r\n\r\n                return false;\r\n\r\n            else\r\n\r\n                return allDifferent1(a, from + 1, t => cond(t) && t != x);     \r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 2, 3, 4};\r\n\r\n            int[] b = { 4, 2, 4, 2};\r\n\r\n            Console.WriteLine(allDifferent(a));\r\n\r\n            Console.WriteLine(allDifferent(b));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7401,96,'3270666','2013-11-08 16:58:29',2,'  --- Почему-то у вас конец программы потерялся. Попробуйте загрузить еще раз, пожалуйста.\r\n  --- Если не поучиться, просто пришлите мне ее по почте.\r\n  --- И еще, мне кажется, у вас программа будет неправильно работать, если одна из последовательностей - пустая.\r\n  --- Проверьте, пожалуйста. \r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FP26_2\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n        {\r\n            List<int> res = new List<int>();\r\n\r\n            IEnumerator<int> a_enum = a.GetEnumerator();\r\n            IEnumerator<int> b_enum = b.GetEnumerator();\r\n            a_enum.MoveNext();\r\n            b_enum.MoveNext();\r\n\r\n            while (true)\r\n            {\r\n                bool a_hasMore = true;\r\n                bool b_hasMore = true;\r\n\r\n                if (a_enum.Current < b_enum.Current)\r\n                {\r\n                    res.Add(a_enum.Current);\r\n                    a_hasMore = a_enum.MoveNext();\r\n                }\r\n                else\r\n                {\r\n                    if (b_enum.Current < a_enum.Current)\r\n                    {\r\n                        res.Add(b_enum.Current);\r\n                        b_hasMore = b_enum.MoveNext();\r\n                    }\r\n     ','<br/>Тесты успешно пройдены!'),(7398,89,'2156724','2013-11-08 14:31:27',1,'data Tree = Empty |\r\n\r\n           Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = f val (foldTree f e l) (foldTree f e r)\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nflatten t = foldTree (v l r -> (v:).(l).(r)) id t []\r\n','<br/>Тесты успешно пройдены!'),(7399,83,'3270666','2013-11-08 16:26:43',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FP23_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Lst137()\r\n        {\r\n            yield return 1;\r\n            yield return 3;\r\n            yield return 7;\r\n            foreach (int i in Lst137())\r\n            {\r\n                yield return 10 * i + 1;\r\n                yield return 10 * i + 3;\r\n                yield return 10 * i + 7;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int count = 0;\r\n            foreach (int i in Lst137())\r\n            {\r\n                count++;\r\n                Console.Write(i);\r\n                if (count < 20)\r\n                {\r\n                    Console.Write(\", \");\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            Console.ReadKey();  \r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7400,95,'3270666','2013-11-08 16:35:42',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FP26_1\r\n{\r\n    class Program\r\n    {\r\n        public static bool allDifferent(int[] a)\r\n        {\r\n            return allDifferent1(a, 0, t => true);\r\n        }\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n        {\r\n            if (from >= a.Length)\r\n            {\r\n                return true;\r\n            }\r\n            int x = a[from];\r\n            if (cond(x))\r\n            {\r\n                return allDifferent1(a, from + 1, t => cond(t) && t != x);\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.Write(\"allDifferent([1,2,3,4,5]) = \");\r\n            Console.WriteLine(allDifferent(new int[] {1,2,3,4,5}));\r\n\r\n            Console.Write(\"allDifferent([1,2,3,1,5]) = \");\r\n            Console.WriteLine(allDifferent(new int[] { 1, 2, 3, 1, 5 }));\r\n\r\n           ','<br/>Тесты успешно пройдены!'),(7397,108,'deripaska','2013-11-08 00:12:36',1,'{--\r\n\r\n	task 27-01\r\n\r\nПусть я хочу найти способы расставить ферзей на шахматной доске, чтобы они друг друга не били.\r\n\r\n\r\n\r\nДля представления позиции на шахматной доске я использую список пар чисел, каждое число >= 1. Первое число обозначает вертикаль, а второе - горизонталь.\r\n\r\n\r\n\r\nЕще для единообразия давайте считать, что первый ферзь в списке всегда стоит на первой вертикали, второй ферзь - на второй вертикали и т.д. (Т.е., вообще-то хранить вертикали в списке не очень то надо, но для наглядности мы их храним).\r\n\r\n\r\n\r\nИ вот задача:\r\n\r\n\r\n\r\nОписать функцию queens с двумя параметрами n и k, которая возвращает список из способов расставить k ферзей на доске с n горизонталями и k вертикалями, чтобы они не били друг друга.\r\n\r\n\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nqueens 3 2\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[[(1,1),(2,3)],[(1,3),(2,1)]]\r\n\r\n\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\n--}\r\n\r\n\r\n\r\nqueens n k = map (xs -> reverse xs) (queens_help n k (\\_ _ -> True))\r\n\r\n\r\n\r\nqueens_help _ 0 _ = [[]]	\r\n\r\nqueens_help n k cond = [((k, y) : xs) | y <- [1..n], cond k y, xs <- queens_help n (k - 1) (	1 t2 -> cond t1 t2 && t2 /= y && abs (t1 - k) /= abs (t2 - y))]\r\n','<br/>Тесты успешно пройдены!'),(7396,82,'nomeansno','2013-11-08 00:10:45',1,'import Data.List\r\n\r\n\r\n\r\nf\' _ res [] = res\r\n\r\nf\' cond res (x:xs) = if not (cond x) then f\' cond res xs else f\' (	 -> cond t && t/=x) (res.(x:)) xs\r\n\r\nf s = (f\' (const True) id s) []\r\n\r\n-- результат - список без повторяющихся элементов\r\n\r\n\r\n\r\nglue\' res [] = res\r\n\r\nglue\' res (y:ys) = if intersect res y /= [] then glue\' (union y res) ys else glue\' res ys\r\n\r\n\r\n\r\nglue res [] = res\r\n\r\nglue res (y:ys) = if length (intersect s\' y) == 1 then glue (union y res) ys else glue s\' ys\r\n\r\n	where s\' = glue\' res (y:ys) \r\n\r\n-- результат - список замен перменных из s1 по правилам s2\r\n\r\n\r\n\r\nnot_in _ [] = True\r\n\r\nnot_in x (y:ys) = if intersect x y /= [] then False else not_in x ys\r\n\r\n\r\n\r\nsplit\' res [] _ = res\r\n\r\nsplit\' res (x:xs) s = if x `not_in` res then split\' ((glue x s):res) xs s else split\' res xs s    \r\n\r\nsplit s = split\' [] s s\r\n\r\n-- результат - разбиение исходного списка (1ый аргумент) на классы различных переменных \r\n\r\n\r\n\r\ncountDifferentVars s1 s2 = length s2\' - (sum s) + (length s)\r\n\r\n	where modify1 = map ((x,y)->[x,y]); modify2 s = map f s; s = [g x | x<-s1\', g x > 0]; s2\' = f s2; s1\' = modify2 (split (modify1 s1)); g x = foldr (xn z -> if xn `elem` x then z+1 else z) 0 s2\'\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7395,82,'nomeansno','2013-11-07 23:49:21',0,'import Data.List\n\n\n\nf\' _ res [] = res\n\nf\' cond res (x:xs) = if not (cond x) then f\' cond res xs else f\' (	 -> cond t && t/=x) (res.(x:)) xs\n\nf s = (f\' (const True) id s) []\n\n-- результат - список без повторяющихся элементов\n\n\n\nglue\' _ [] res = res\n\nglue\' s (y:ys) res = if intersect res y /= [] then glue\' s ys (union y res) else glue\' s ys res\n\nglue\'\' s1 s2 = glue\' s1 s2 s1\n\n--	where s3 = glue\' s1 s2 s1\n\n-- результат - список замен перменных из s1 по правилам s2\n\n\n\nglue res [] = res\n\nglue res (y:ys) = if length (intersect s\' y) == 1 then glue (union y res) ys else glue s\' ys\n\n	where s\' = glue\'\' res (y:ys) \n\n--nglue s1 s2 = glue\'\' s2 s1\n\n\n\nnot_in _ [] = True\n\nnot_in x (y:ys) = if intersect x y /= [] then False else not_in x ys\n\n\n\nsplit\' res [] _ = res\n\nsplit\' res (x:xs) s = if x `not_in` res then split\' ((glue x s):res) xs s else split\' res xs s    \n\nsplit s = split\' [] s s\n\n-- результат - разбиение исходного списка (1ый аргумент) на классы различных переменных \n\n\n\ncountDifferentVars s1 s2 = length s2\' - (sum s) + (length s)\n\n	where modify1 = map ((x,y)->[x,y]); modify2 s = map f s; s = [g x | x<-s1\', g x > 0]; s2\' = f s2; s1\' = modify2 (split (modify1 s1)); g x = foldr (xn z -> if xn `elem` x then z+1 else z) 0 s2\'\n\n\n','<br/>Тесты успешно пройдены!'),(7394,82,'nomeansno','2013-11-07 22:15:58',0,'import Data.List\n\n\n\nf\' _ res [] = res\n\nf\' cond res (x:xs) = if not (cond x) then f\' cond res xs else f\' (	 -> cond t && t/=x) (res.(x:)) xs\n\nf s = (f\' (const True) id s) []\n\n-- результат - список без повторяющихся элементов\n\n\n\nglue\' _ [] res = res\n\nglue\' s (y:ys) res = if intersect res y /= [] then glue\' s ys (union y res) else glue\' s ys res\n\nglue s1 s2 = glue\' s1 s2 s1\n\n-- результат - список замен перменных из s1 по правилам s2\n\n\n\nnot_in _ [] = True\n\nnot_in x (y:ys) = if intersect x y /= [] then False else not_in x ys\n\n\n\nsplit\' res [] _ = res\n\nsplit\' res (x:xs) s = if x `not_in` res then split\' ((glue x s):res) xs s else split\' res xs s    \n\nsplit s = split\' [] s s\n\n-- результат - разбиение исходного списка (1ый аргумент) на классы различных переменных \n\n\n\nmysort s = sortBy f s\n\n    where f (x,y) (x\',y\') = x `compare` x\'\n\n\n\ncountDifferentVars s1 s2 = length s2\' - (sum s) + (length s)\n\n	where modify1 = map ((x,y)->[x,y]); modify2 s = map f s; s = [g x | x<-s1\', g x > 0]; s2\' = f s2; s1\' = modify2 (split (modify1 (mysort s1))); g x = foldr (xn z -> if xn `elem` x then z+1 else z) 0 s2\'\n\n\n','Выражение имеет неправильное значение: countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]'),(7393,93,'42284313','2013-11-07 21:22:47',1,'{--\r\n\r\n    Task 1\r\n\r\n    *Доп.задача, до 18.11*\r\n\r\n\r\n\r\n    Опишите ham - бесконечную последовательность, состоящую из целых чисел вида 3^i*10^j (где i, j - целые неотрицательные числа), расположенных в порядке возрастания.\r\n\r\n\r\n\r\n    Дополнительное условие: функция должна работать более-менее быстро. Скажем, надо, чтобы за 30 секунд можно было вычислить элемент с номером 10000.\r\n\r\n\r\n\r\n    Примеры вызова:\r\n\r\n\r\n\r\n    take 10 ham\r\n\r\n\r\n\r\n    Должно получиться \r\n\r\n\r\n\r\n    [1,3,9,10,27,30,81,90,100,243]\r\n\r\n\r\n\r\n    ham !! 10000\r\n\r\n\r\n\r\n    Должно получиться \r\n\r\n\r\n\r\n    8862938119652501095929000000000000000000000000000000000000000000000000000000000000000000000000000\r\n\r\n--}\r\n\r\nmyConcat [] ys = ys\r\n\r\nmyConcat xs [] = xs\r\n\r\nmyConcat (x:xs) (y:ys)\r\n\r\n    | x == y = x : myConcat xs ys\r\n\r\n    | x > y = y : myConcat (x:xs) ys\r\n\r\n    | otherwise = x : myConcat xs (y:ys)\r\n\r\n\r\n\r\nham = 1 : myConcat (map (*3) ham) (map (*10) ham)\r\n','<br/>Тесты успешно пройдены!'),(7392,93,'42284313','2013-11-07 21:21:07',0,'{--\r\n\n    Task 1\r\n\n    *Доп.задача, до 18.11*\r\n\n\r\n\n    Опишите ham - бесконечную последовательность, состоящую из целых чисел вида 3^i*10^j (где i, j - целые неотрицательные числа), расположенных в порядке возрастания.\r\n\n\r\n\n    Дополнительное условие: функция должна работать более-менее быстро. Скажем, надо, чтобы за 30 секунд можно было вычислить элемент с номером 10000.\r\n\n\r\n\n    Примеры вызова:\r\n\n\r\n\n    take 10 ham\r\n\n\r\n\n    Должно получиться \r\n\n\r\n\n    [1,3,9,10,27,30,81,90,100,243]\r\n\n\r\n\n    ham !! 10000\r\n\n\r\n\n    Должно получиться \r\n\n\r\n\n    8862938119652501095929000000000000000000000000000000000000000000000000000000000000000000000000000\r\n\n--}\r\n\nconcat [] ys = ys\r\n\nconcat xs [] = xs\r\n\nconcat (x:xs) (y:ys)\r\n\n    | x == y = x : concat xs ys\r\n\n    | x > y = y : concat (x:xs) ys\r\n\n    | otherwise = x : concat xs (y:ys)\r\n\n\r\n\nham = 1 : concat (map (*3) ham) (map (*10) ham)\n','Не удалось вычислить выражение \"take 10 ham\", проверьте правильность синтаксиса'),(7391,82,'42284313','2013-11-07 21:15:08',1,'{--\r\n\r\n    Task 2\r\n\r\n    *Доп. задача, до 07.11*\r\n\r\n\r\n\r\n    Пусть у нас есть система равенств вида:\r\n\r\n    <переменная1> = <переменная2>.\r\n\r\n    Мы представляем ее в Хаскеле, как список пар строк. Например, список [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] описывает систему равенств:\r\n\r\n    x = y\r\n\r\n    y = z\r\n\r\n    n = m\r\n\r\n    Кроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\r\n\r\n\r\n    Пример вызова:\r\n\r\n    countDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]\r\n\r\n\r\n\r\n    Результат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\r\n\r\n\r\n    Замечания:\r\n\r\n    - Это не упражнение на какую-то тему, которую мы проходили - тут надо просто написать более-менее нетривиальный алгоритм на Хаскеле.\r\n\r\n--}\r\n\r\naddUsedVars vars [] usedVars = vars ++ usedVars\r\n\r\naddUsedVars [] _ usedVars = usedVars\r\n\r\naddUsedVars (var:vars) pairs usedVars =\r\n\r\n    let\r\n\r\n      f (x, y) res =\r\n\r\n        if x == var && not(elem y vars) && not(elem y res) && not(elem y usedVars)\r\n\r\n        then y:res\r\n\r\n        else if y == var && not(elem x vars) && not(elem x res) && not(elem x usedVars)\r\n\r\n             then x:res\r\n\r\n             else res\r\n\r\n      newVars = foldr f [] pairs\r\n\r\n    in addUsedVars (newVars ++ vars) pairs (var:usedVars)\r\n\r\n\r\n\r\ndifVars [] pairs usedVars differentVars = length differentVars\r\n\r\ndifVars (var:vars) pairs usedVars differentVars =\r\n\r\n    if elem var usedVars\r\n\r\n    then difVars vars pairs usedVars differentVars\r\n\r\n    else difVars vars pairs (addUsedVars [var] pairs usedVars) (var:differentVars)\r\n\r\n\r\n\r\ncountDifferentVars pairs vars = difVars vars pairs [] []\r\n','<br/>Тесты успешно пройдены!'),(7388,108,'115753099','2013-11-07 17:26:42',0,'queens n k = queens\' n k k  (const True)\r\n\r\nqueens\' n 0 _ _ = [[]]\r\nqueens\' n k kReal fu =\r\n	[(x1, x):xs | x<-[1..n], (fu (x1, x)), xs <- queens\' n (k-1) kReal ((y1, y) -> fu (y1, y) && f x1 x y1 y)]\r\n	where x1 = kReal - k + 1\r\n\r\nf x1 x y1 y =\r\n	y /= x && (x1-y1) `rem` (x-y) /= 0','Выражение имеет неправильное значение: length (queens 4 4)'),(7389,108,'115753099','2013-11-07 17:33:54',1,'queens n k = queens\' n k k  (const True)\r\n\r\nqueens\' n 0 _ _ = [[]]\r\nqueens\' n k kReal fu =\r\n	[(x1, x):xs | x<-[1..n], (fu (x1, x)), xs <- queens\' n (k-1) kReal ((y1, y) -> fu (y1, y) && f x1 x y1 y)]\r\n	where x1 = kReal - k + 1\r\n\r\nf x1 x y1 y =\r\n	y /= x && abs((x1 - y1) / (x - y)) /= 1','<br/>Тесты успешно пройдены!'),(7390,82,'42284313','2013-11-07 21:11:11',0,'{--\r\n    Task 2\r\n\r\n    Пусть у нас есть система равенств вида:\r\n    <переменная1> = <переменная2>.\r\n    Мы представляем ее в Хаскеле, как список пар строк. Например, список [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] описывает систему равенств:\r\n    x = y\r\n    y = z\r\n    n = m\r\n    Кроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\r\n    Пример вызова:\r\n    countDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]\r\n\r\n    Результат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\r\n    Замечания:\r\n    - Это не упражнение на какую-то тему, которую мы проходили - тут надо просто написать более-менее нетривиальный алгоритм на Хаскеле.\r\n--}\r\naddUsedVars vars [] usedVars = vars ++ usedVars\r\naddUsedVars','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(7387,136,'2156724','2013-11-07 13:37:11',1,'data Polinom = Pol [Int]\r\n\r\n\r\n\r\ninstance Show Polinom where\r\n\r\n    show (Pol [a,b]) =\r\n\r\n                       case a of\r\n\r\n                           0 ->if b > 0 then \"+\"++ show (Pol [b])\r\n\r\n                                        else if b < 0 then show (Pol [b])\r\n\r\n                                             else \" \"\r\n\r\n                           _ ->if (b > 0) then show a ++ \"x+\" ++ show b\r\n\r\n                                  else if (b < 0) then show a ++ \"x\" ++ show b\r\n\r\n                                                  else show a ++\"x\"\r\n\r\n    show (Pol [x]) = show x\r\n\r\n    show (Pol (x:xs)) = case x of \r\n\r\n                             0 -> show (Pol xs)\r\n\r\n			     1 -> if ( head xs > 0) then \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n				  else \"x^\" ++ show (lxs-1)  ++ show (Pol xs)\r\n\r\n			     _ ->  if ( head xs > 0) then show x ++ \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n                                   else show x ++ \"x^\" ++ show (lxs-1) ++ show (Pol xs)\r\n\r\n 		where lxs = length (x:xs)	   \r\n\r\n\r\n\r\ninstance Num Polinom where\r\n\r\n   (Pol (x:xs)) + (Pol (y:ys)) =\r\n\r\n                 if (a > 0)   then (Pol ((take a (x:xs)) ++ (reverse (zipWith (+) revX revY)))) \r\n\r\n                             \r\n\r\n			      else( Pol ((take (-a) (y:ys)) ++ (reverse (zipWith (+) revX revY))))  \r\n\r\n                where a = length (x:xs) - length (y:ys)\r\n\r\n                      revX = reverse (x:xs)\r\n\r\n                      revY = reverse (y:ys)\r\n\r\n\r\n\r\n   (Pol (x:xs)) * (Pol (y:ys)) = Pol (reverse ([ l | k<-[0..stX + stY], \r\n\r\n                                                    let l = sum [z| n <-[0..stX], \r\n\r\n                                                                    m <-[0..stY] , \r\n\r\n								    let z = (reverse(x:xs)!!n) * (reverse(y:ys)!!m), \r\n\r\n								     m + n == k]]))\r\n\r\n 		where stX = length (x:xs) - 1\r\n\r\n 		      stY = length (y:ys) - 1 \r\n\r\n\r\n\r\nfunc (x:xs) (y:ys) =\r\n\r\n    if x == 0 then func (xs)(y:ys)\r\n\r\n              else if y == 0 then func (ys) (x:xs)\r\n\r\n                   else  (x:xs) == (y:ys)   \r\n\r\n\r\n\r\ninstance Eq Polinom where\r\n\r\n   (Pol (x:xs)) == (Pol (y:ys))  = func (x:xs) (y:ys)\r\n\r\n             \r\n\r\n             \r\n\r\n\r\n\r\n\r\n\r\n    \r\n','<br/>Тесты успешно пройдены!'),(7386,82,'nomeansno','2013-11-07 10:28:04',0,'import Data.List\n\n\n\nf\' _ res [] = res\n\nf\' cond res (x:xs) = if not (cond x) then f\' cond res xs else f\' (	 -> cond t && t/=x) (res.(x:)) xs\n\nf s = (f\' (const True) id s) []\n\n-- результат - список без повторяющихся элементов\n\n\n\nglue\' _ [] res = res\n\nglue\' s (y:ys) res = if intersect res y /= [] then glue\' s ys (union y res) else glue\' s ys res\n\nglue s1 s2 = glue\' s1 s2 s1\n\n-- результат - список замен перменных из s1 по правилам s2\n\n\n\nnot_in _ [] = True\n\nnot_in x (y:ys) = if intersect x y /= [] then False else not_in x ys\n\n\n\nsplit\' res [] _ = res\n\nsplit\' res (x:xs) s = if x `not_in` res then split\' ((glue x s):res) xs s else split\' res xs s    \n\nsplit s = split\' [] s s\n\n-- результат - разбиение исходного списка (1ый аргумент) на классы различных переменных \n\n\n\ncountDifferentVars s1 s2 = length s2\' - (sum s) + (length s)\n\n	where modify1 = map ((x,y)->[x,y]); modify2 s = map f s; s = [g x | x<-s1\', g x > 0]; s2\' = f s2; s1\' = modify2 (split (modify1 s1)); g x = foldr (xn z -> if xn `elem` x then z+1 else z) 0 s2\'\n\n\n','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(7385,136,'2156724','2013-11-07 00:39:24',2,' --- Еще две ошибки при печати нашел:\r\n --- Pol [2,0]\r\n --- Pol [1,0,2]\r\n --- Оба печатаются не совсем правильно.\r\n --- Исправьте, пожалуйста.\r\ndata Polinom = Pol [Int]\r\n\r\n\r\n\r\ninstance Show Polinom where\r\n\r\n    show (Pol [a,b]) = if (b > 0) then show a ++ \"x+\" ++ show b\r\n\r\n                                  else show a ++ \"x\" ++ show b\r\n\r\n    show (Pol [x]) = show x\r\n\r\n    show (Pol (x:xs)) = case x of \r\n\r\n                             0 -> show (Pol xs)\r\n\r\n			     1 -> if ( head xs > 0) then \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n				  else \"x^\" ++ show (lxs-1)  ++ show (Pol xs)\r\n\r\n			     _ ->  if ( head xs > 0) then show x ++ \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n                                   else show x ++ \"x^\" ++ show (lxs-1) ++ show (Pol xs)\r\n\r\n 		where lxs = length (x:xs)	   \r\n\r\n\r\n\r\ninstance Num Polinom where\r\n\r\n   (Pol (x:xs)) + (Pol (y:ys)) =\r\n\r\n                 if (a > 0)   then (Pol ((take a (x:xs)) ++ (reverse (zipWith (+) revX revY)))) \r\n\r\n                             \r\n\r\n			      else( Pol ((take (-a) (y:ys)) ++ (reverse (zipWith (+) revX revY))))  \r\n\r\n                where a = length (x:xs) - length (y:ys)\r\n\r\n                      revX = reverse (x:xs)\r\n\r\n                      revY = reverse (y:ys)\r\n\r\n\r\n\r\n   (Pol (x:xs)) * (Pol (y:ys)) = Pol (reverse ([ l | k<-[0..stX + stY], \r\n\r\n                                                    let l = sum [z| n <-[0..stX], \r\n\r\n                                                                    m <-[0..stY] , \r\n\r\n								    let z = (reverse(x:xs)!!n) * (reverse(y:ys)!!m), \r\n\r\n								     m + n == k]]))\r\n\r\n 		where stX = length (x:xs) - 1\r\n\r\n 		      stY = length (y:ys) - 1 \r\n\r\n\r\n\r\nfunc (x:xs) (y:ys) =\r\n\r\n    if x == 0 then func (xs)(y:ys)\r\n\r\n              else if y == 0 then func (ys) (x:xs)\r\n\r\n                   else  (x:xs) == (y:ys)   \r\n\r\n\r\n\r\ninstance Eq Polinom where\r\n\r\n   (Pol (x:xs)) == (Pol (y:ys))  = func (x:xs) (y:ys)\r\n\r\n             \r\n\r\n             \r\n\r\n\r\n\r\n\r\n\r\n    \r\n','<br/>Тесты успешно пройдены!'),(7383,76,'anna','2013-11-06 22:23:46',1,'data Rect = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\nclass Shape a where\r\n    contains :: a->Double->Double->Bool\r\ninstance Shape Rect where\r\n   contains (Rect m n x1 y1) x2 y2 = \r\n            ((x1-n/2) < x2) && ((x1+n/2)>x2) && ((y1-m/2) < y2) && ((y1+m/2)>y2)\r\n\r\ninstance Shape Circle where\r\n    contains (Circle r x1 y1) x2 y2 = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)<= r*r;','<br/>Тесты успешно пройдены!'),(7384,136,'2156724','2013-11-06 22:24:16',2,' --- Вообще хорошо, но вот еще ошибка:\r\n --- Pol [1,1]+Pol[-1,1] == Pol [0,2]\r\n --- при вычислении выдается сообщение об ошибке. Посмотрите пожалуйста.\r\ndata Polinom = Pol [Int]\r\n\r\n\r\n\r\ninstance Show Polinom where\r\n\r\n    show (Pol [a,b]) = if (b > 0) then show a ++ \"x+\" ++ show b\r\n\r\n                                  else show a ++ \"x\" ++ show b\r\n\r\n    show (Pol [x]) = show x\r\n\r\n    show (Pol (x:xs)) = case x of \r\n\r\n                             0 -> show (Pol xs)\r\n\r\n			     1 -> if ( head xs > 0) then \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n				  else \"x^\" ++ show (lxs-1)  ++ show (Pol xs)\r\n\r\n			     _ ->  if ( head xs > 0) then show x ++ \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n                                   else show x ++ \"x^\" ++ show (lxs-1) ++ show (Pol xs)\r\n\r\n 		where lxs = length (x:xs)	   \r\n\r\n\r\n\r\ninstance Num Polinom where\r\n\r\n   (Pol (x:xs)) + (Pol (y:ys)) =\r\n\r\n                 if (a > 0)   then (Pol ((take a (x:xs)) ++ (reverse (zipWith (+) revX revY)))) \r\n\r\n                             \r\n\r\n			      else( Pol ((take (-a) (y:ys)) ++ (reverse (zipWith (+) revX revY))))  \r\n\r\n                where a = length (x:xs) - length (y:ys)\r\n\r\n                      revX = reverse (x:xs)\r\n\r\n                      revY = reverse (y:ys)\r\n\r\n\r\n\r\n   (Pol (x:xs)) * (Pol (y:ys)) = Pol (reverse ([ l | k<-[0..stX + stY], \r\n\r\n                                                    let l = sum [z| n <-[0..stX], \r\n\r\n                                                                    m <-[0..stY] , \r\n\r\n								    let z = (reverse(x:xs)!!n) * (reverse(y:ys)!!m), \r\n\r\n								     m + n == k]]))\r\n\r\n 		where stX = length (x:xs) - 1\r\n\r\n 		      stY = length (y:ys) - 1 \r\n\r\n\r\n\r\nfunc (x:xs) (y:ys) =\r\n\r\n    if x == 0 then func (xs)(y:ys)\r\n\r\n              else if y == 0 then func (ys) (xs)\r\n\r\n                   else  (x:xs) == (y:ys)   \r\n\r\n\r\n\r\ninstance Eq Polinom where\r\n\r\n   (Pol (x:xs)) == (Pol (y:ys))  = func (x:xs) (y:ys)\r\n\r\n             \r\n\r\n             \r\n\r\n\r\n\r\n\r\n\r\n    ','<br/>Тесты успешно пройдены!'),(7382,76,'anna','2013-11-06 22:18:55',0,'data Rect = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\nclass Shape a where\r\n    contains :: a->Double->Double->Bool\r\ninstance Shape Rect where\r\n   contains (Rect m n x1 y1) x2 y2 = \r\n            ((x1-n/2) < x2) && ((x1+n/2)>x2) && ((y1-m/2) < y2) && ((y1+m/2)>y2)\r\n\r\ninstance Shape Circle where\r\n    contains (Circle r x1 y1) x2 y2 = x1*x2<= r*r;\r\n','Выражение имеет неправильное значение: contains (Circle 5 5 5) 1 1'),(7381,136,'2156724','2013-11-06 17:07:05',2,' --- Не совсем правильно. Во первых, у вас не совем правильно, печататется\r\n --- Попроьуйте напечатать например Pol [1,2,3]\r\n --- Во вторых например Pol [-1,1,1] + Pol [1,1,1] == Pol [2,2] у вас дает False, а должно быть, видимо, True.\r\n --- Исправьте, пожалуйста.\r\ndata Polinom = Pol [Int]\r\n\r\n\r\n\r\ninstance Show Polinom where\r\n\r\n    show (Pol [a,b]) = if (b > 0) then \"x+\" ++ show b\r\n\r\n                                  else \"x\" ++ show b\r\n\r\n    show (Pol [x]) = show x\r\n\r\n    show (Pol (x:xs)) = case x of \r\n\r\n                             0 -> show (Pol xs)\r\n\r\n			     1 -> if ( head xs > 0) then \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n				  else \"x^\" ++ show (lxs-1)  ++ show (Pol xs)\r\n\r\n			     _ ->  if ( head xs > 0) then show x ++ \"x^\" ++ show (lxs-1) ++ \"+\" ++ show (Pol xs)\r\n\r\n                                   else show x ++ \"x^\" ++ show (lxs-1) ++ show (Pol xs)\r\n\r\n 		where lxs = length (x:xs)	   \r\n\r\n\r\n\r\ninstance Num Polinom where\r\n\r\n   (Pol (x:xs)) + (Pol (y:ys)) =\r\n\r\n                 if (a > 0)   then (Pol ((take a (x:xs)) ++ (reverse (zipWith (+) revX revY)))) \r\n\r\n                             \r\n\r\n			      else( Pol ((take (-a) (y:ys)) ++ (reverse (zipWith (+) revX revY))))  \r\n\r\n                where a = length (x:xs) - length (y:ys)\r\n\r\n                      revX = reverse (x:xs)\r\n\r\n                      revY = reverse (y:ys)\r\n\r\n\r\n\r\n   (Pol (x:xs)) * (Pol (y:ys)) = Pol (reverse ([ l | k<-[0..stX + stY], \r\n\r\n                                                    let l = sum [z| n <-[0..stX], \r\n\r\n                                                                    m <-[0..stY] , \r\n\r\n								    let z = (reverse(x:xs)!!n) * (reverse(y:ys)!!m), \r\n\r\n								     m + n == k]]))\r\n\r\n 		where stX = length (x:xs) - 1\r\n\r\n 		      stY = length (y:ys) - 1 \r\n\r\n\r\n\r\ninstance Eq Polinom where\r\n\r\n   (Pol (x:xs)) == (Pol (y:ys)) =  (x:xs) == (y:ys)\r\n\r\n\r\n\r\n\r\n\r\n    ','<br/>Тесты успешно пройдены!'),(7379,85,'anna','2013-11-06 00:41:37',1,'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n    (Rat x1 y1) + (Rat x2 y2) = Rat (x1*y2 + x2*y1) (y1*y2)\r\n\r\ninstance Ord Ration where\r\n    (Rat x1 y1) < (Rat x2 y2) = if (y1*y2 > 0) then x1*y2 < x2*y1 else x1*y2 > x2*y1\r\n\r\ninstance Eq Ration where\r\n    (Rat x1 y1) == (Rat x2 y2) = x1*y2 == x2*y1\r\n\r\ninstance Show Ration where\r\n    show (Rat x y) = show x ++ \"/\" ++ show y','<br/>Тесты успешно пройдены!'),(7380,100,'2156724','2013-11-06 00:57:50',1,'allDiffLists\' n 0 cond = [[]]	\r\n\r\nallDiffLists\' n k cond = \r\n\r\n    [x:xs | x<-[1..n], xs<-allDiffLists\' n (k-1) (	 -> cond t && (not (x==t))), cond x == True]\r\n  --- или вместо cond x == True можно просто cond x\r\nallDiffLists n k = allDiffLists\' n k (	 -> True) \r\n','<br/>Тесты успешно пройдены!'),(7378,85,'anna','2013-11-06 00:31:21',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n    (Rat x1 y1) + (Rat x2 y2) = Rat (x1*y2 + x2*y1) (y1*y2)\r\n\r\ninstance Ord Ration where\r\n    (Rat x1 y1) < (Rat x2 y2) = if (x1*x2 > 0) then x1*y2 < x2*y1 else x1*y2 > x2*y1\r\n\r\ninstance Eq Ration where\r\n    (Rat x1 y1) == (Rat x2 y2) = x1*y2 == x2*y1\r\n\r\ninstance Show Ration where\r\n    show (Rat x y) = show x ++ \"/\" ++ show y','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7376,90,'anna','2013-11-06 00:06:07',1,'  --- Засчитано, но вообще это не совсем то. Так, человек, который будет вызывать эту функцию,\r\n  --- увидит ответ, но он не сможет использовать его в программе.\r\n  --- Например, если ему надо найти повторяющийся элемент и вернуть его квадрат, с вашей\r\n  --- функцией ему это будет не сделать. Но ОК, мы это обсудим. \r\nfindSame\' [] _ = putStrLn \"False\"\r\nfindSame\' (x:xs) acc = if elem x acc then putStrLn (\"True \" ++show x) else findSame\' xs (x:acc)\r\nfindSame xs = findSame\' xs []','<br/>Тесты успешно пройдены!'),(7377,136,'2156724','2013-11-06 00:25:52',2,'--- как-то так:\r\n--- data Poly  = Poly [Integer]\r\n--- и потом \r\n---   f (Poly (x:xs)) = ...\r\n--- Вообще если есть вопросы, лучше писать письмо. Просто на письма я как правило отвечаю быстрее. \r\nДумаю в качестве данных использовать список, но не могу понять, как его описать в data\r\n','<br/>Тесты успешно пройдены!'),(7375,86,'2156724','2013-11-05 19:41:58',1,'allNondivisible\' [] cond = True\r\n\r\nallNondivisible\' (x:xs) cond = if not (cond x) then False \r\n\r\n				          else allNondivisible\' xs \r\n\r\n					  		(	 -> cond t && not(rem t x == 0)\r\n\r\n                                                               && not (rem x t == 0))\r\n\r\n\r\n\r\n\r\n\r\nallNondivisible xs = allNondivisible\' xs (	 -> True)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7374,82,'3270666','2013-11-05 18:59:58',1,'countDifferentVars rules vars = \r\n\r\n	count vars (mergeSets (rulesToSets rules [])) 0 (const True)\r\n\r\n\r\n\r\nmergeSets [] = []\r\n\r\nmergeSets (x:xs) = mergeSets\' (x:xs) xs\r\n\r\nmergeSets\' [x] [] = [x]\r\n\r\nmergeSets\' (x1:x2:xs) [] = x1 : (mergeSets\' (x2:xs) xs)\r\n\r\nmergeSets\' (x:xs) (y:ys) = \r\n\r\n	if ([r | r <- x, r `elem` y] /= [])\r\n\r\n		then mergeSets\' ((x ++ y):xs) ys\r\n\r\n		else mergeSets\' (x:xs) ys\r\n\r\n\r\n\r\ncount [] _ res _ = res\r\n\r\ncount (x:vars) varSets res cond = if (not (cond x))\r\n\r\n	then count vars varSets res cond\r\n\r\n	else let set = findSet x varSets\r\n\r\n	         newCond = if (set /= [])\r\n\r\n	         	then (	 -> cond t && not (t `elem` set))\r\n\r\n	         	else (	 -> cond t && t /= x)\r\n\r\n	     in count vars varSets (res + 1) newCond\r\n\r\n\r\n\r\nfindSet _ [] = []\r\n\r\nfindSet x (varSet:sets) = if (x `elem` varSet)\r\n\r\n	then varSet\r\n\r\n	else findSet x sets\r\n\r\n\r\n\r\nrulesToSets [] sets = sets\r\n\r\nrulesToSets ((x, y) : rules) sets = \r\n\r\n	rulesToSets rules (addRule (x, y) sets)\r\n\r\n\r\n\r\naddRule (x, y) [] = [[x, y]]\r\n\r\naddRule (x, y) (varSet:sets) = \r\n\r\n	if (x `elem` varSet && not (y `elem` varSet))\r\n\r\n		then (y:varSet) : sets\r\n\r\n		else if (y `elem` varSet && not (x `elem` varSet))\r\n\r\n			then (x:varSet) : sets\r\n\r\n			else varSet : (addRule (x, y) sets)\r\n','<br/>Тесты успешно пройдены!'),(7372,82,'3270666','2013-11-05 18:57:54',0,'countDifferentVars rules vars = \r\n	count vars (mergeSets (rulesToSets rules [])) 0 (const True)\r\n\r\nmergeSets (x:xs) = mergeSets\' (x:xs) xs\r\nmergeSets\' [x] [] = [x]\r\nmergeSets\' (x1:x2:xs) [] = x1 : (mergeSets\' (x2:xs) xs)\r\nmergeSets\' (x:xs) (y:ys) = \r\n	if ([r | r <- x, r `elem` y] /= [])\r\n		then mergeSets\' ((x ++ y):xs) ys\r\n		else mergeSets\' (x:xs) ys\r\n\r\ncount [] _ res _ = res\r\ncount (x:vars) varSets res cond = if (not (cond x))\r\n	then count vars varSets res cond\r\n	else let set = findSet x varSets\r\n	         newCond = if (set /= [])\r\n	         	then (	 -> cond t && not (t `elem` set))\r\n	         	else (	 -> cond t && t /= x)\r\n	     in count vars varSets (res + 1) newCond\r\n\r\nfindSet _ [] = []\r\nfindSet x (varSet:sets) = if (x `elem` varSet)\r\n	then varSet\r\n	else findSet x sets\r\n\r\nrulesToSets [] sets = sets\r\nrulesToSets ((x, y) : rules) sets = \r\n	rulesToSets rules (addRule (x, y) sets)\r\n\r\naddRule (x, y) [] = [[x, y]]\r\naddRule (x, y) (varSet:sets) = \r\n	if (x `elem` varSet && not (y `elem` varSet))\r\n		then (y:varSet) : se','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(7373,82,'3270666','2013-11-05 18:59:04',0,'countDifferentVars rules vars = \r\n\n	count vars (mergeSets (rulesToSets rules [])) 0 (const True)\r\n\n\r\n\nmergeSets (x:xs) = mergeSets\' (x:xs) xs\r\n\nmergeSets\' [x] [] = [x]\r\n\nmergeSets\' (x1:x2:xs) [] = x1 : (mergeSets\' (x2:xs) xs)\r\n\nmergeSets\' (x:xs) (y:ys) = \r\n\n	if ([r | r <- x, r `elem` y] /= [])\r\n\n		then mergeSets\' ((x ++ y):xs) ys\r\n\n		else mergeSets\' (x:xs) ys\r\n\n\r\n\ncount [] _ res _ = res\r\n\ncount (x:vars) varSets res cond = if (not (cond x))\r\n\n	then count vars varSets res cond\r\n\n	else let set = findSet x varSets\r\n\n	         newCond = if (set /= [])\r\n\n	         	then (	 -> cond t && not (t `elem` set))\r\n\n	         	else (	 -> cond t && t /= x)\r\n\n	     in count vars varSets (res + 1) newCond\r\n\n\r\n\nfindSet _ [] = []\r\n\nfindSet x (varSet:sets) = if (x `elem` varSet)\r\n\n	then varSet\r\n\n	else findSet x sets\r\n\n\r\n\nrulesToSets [] sets = sets\r\n\nrulesToSets ((x, y) : rules) sets = \r\n\n	rulesToSets rules (addRule (x, y) sets)\r\n\n\r\n\naddRule (x, y) [] = [[x, y]]\r\n\naddRule (x, y) (varSet:sets) = \r\n\n	if (x `elem` varSet && not (y `elem` varSet))\r\n\n		then (y:varSet) : sets\r\n\n		else if (y `elem` varSet && not (x `elem` varSet))\r\n\n			then (x:varSet) : sets\r\n\n			else varSet : (addRule (x, y) sets)\n','Не удалось вычислить выражение \"countDifferentVars [] [1,2,3]\", проверьте правильность синтаксиса'),(7371,82,'3270666','2013-11-05 18:57:20',0,'countDifferentVars rules vars = \r\n	count vars (mergeSets (rulesToSets rules [])) 0 (const True)\r\n\r\nmergeSets (x:xs) = mergeSets\' (x:xs) xs\r\nmergeSets\' [x] [] = [x]\r\nmergeSets\' (x1:x2:xs) [] = x1 : (mergeSets\' (x2:xs) xs)\r\nmergeSets\' (x:xs) (y:ys) = \r\n	if ([r | r <- x, r `elem` y] /= [])\r\n		then mergeSets\' ((x ++ y):xs) ys\r\n		else mergeSets\' (x:xs) ys\r\n\r\ncount [] _ res _ = res\r\ncount (x:vars) varSets res cond = if (not (cond x))\r\n	then count vars varSets res cond\r\n	else let set = findSet x varSets\r\n	         newCond = if (set /= [])\r\n	         	then (	 -> cond t && not (t `elem` set))\r\n	         	else (	 -> cond t && t /= x)\r\n	     in count vars varSets (res + 1) newCond\r\n\r\nfindSet _ [] = []\r\nfindSet x (varSet:sets) = if (x `elem` varSet)\r\n	then varSet\r\n	else findSet x sets\r\n\r\nrulesToSets [] sets = sets\r\nrulesToSets ((x, y) : rules) sets = \r\n	rulesToSets rules (addRule (x, y) sets)\r\n\r\naddRule (x, y) [] = [[x, y]]\r\naddRule (x, y) (varSet:sets) = \r\n	if (x `elem` varSet && not (y `elem` varSet))\r\n		then (y:varSet) : se','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(7370,82,'3270666','2013-11-05 18:45:14',0,'countDifferentVars rules vars = \r\n	count vars (rulesToSets rules []) 0 (const True)\r\n\r\ncount [] _ res _ = res\r\ncount (x:vars) varSets res cond = if (not (cond x))\r\n	then count vars varSets res cond\r\n	else let set = findSet x varSets\r\n	         newCond = if (set /= [])\r\n	         	then (	 -> cond t && not (t `elem` set))\r\n	         	else (	 -> cond t && t /= x)\r\n	     in count vars varSets (res + 1) newCond\r\n\r\nfindSet _ [] = []\r\nfindSet x (varSet:sets) = if (x `elem` varSet)\r\n	then varSet\r\n	else findSet x sets\r\n\r\nrulesToSets [] sets = sets\r\nrulesToSets ((x, y) : rules) sets = \r\n	rulesToSets rules (addRule (x, y) sets)\r\n\r\naddRule (x, y) [] = [[x, y]]\r\naddRule (x, y) (varSet:sets) = \r\n	if (x `elem` varSet && not (y `elem` varSet))\r\n		then (y:varSet) : sets\r\n		else if (y `elem` varSet && not (x `elem` varSet))\r\n			then (x:varSet) : sets\r\n			else varSet : (addRule (x, y) sets)','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(7368,86,'3270666','2013-11-05 17:32:03',1,'allNondivisible xs = allNondivisible\' xs (const True)\r\n\r\nallNondivisible\' [] _ = True\r\nallNondivisible\' (x:xs) cond = \r\n	if not (cond x)\r\n		then False\r\n		else allNondivisible\' xs (	 -> cond t &&\r\n			t `mod` x /= 0 && x `mod` t /= 0)','<br/>Тесты успешно пройдены!'),(7369,100,'3270666','2013-11-05 17:45:40',1,'allDiffLists n k = allDiffLists\' n k (const True)\r\n\r\nallDiffLists\' n 0 _ = [[]]	\r\nallDiffLists\' n k cond = [x:xs | x <- [1..n], cond x,\r\n	xs <- allDiffLists\' n (k - 1) (	 -> cond t && t /= x)]','<br/>Тесты успешно пройдены!'),(7367,95,'artem.gomerman','2013-11-05 16:49:01',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n    {\r\n\r\n        if (from == a.Length)\r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (!cond(a[from]))\r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        else\r\n\r\n        {\r\n\r\n            return allDifferent1(a, from + 1, t => cond(t) && t != a[from]);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    public static bool allDifferent(int[] a)\r\n\r\n    {\r\n\r\n        return allDifferent1(a, 0, t => true);\r\n\r\n    }\r\n\r\n\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Console.Write(\"allDifferent test\r\nInput numbers separated by space: \");\r\n\r\n\r\n\r\n        // read and parse string\r\n\r\n        int[] arr = Console.ReadLine().Split(\' \').Select(t => int.Parse(t)).ToArray();\r\n\r\n\r\n\r\n        // output\r\n\r\n        Console.Write(\"All the numbers are different: \");\r\n\r\n        Console.WriteLine(allDifferent(arr));\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7366,93,'1170660','2013-11-05 14:59:59',1,'\r\nmerge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n    | x == y = x : merge xs ys\r\n\r\n    | x > y = y : merge (x:xs) ys\r\n\r\n    | otherwise = x : merge xs (y:ys)\r\n\r\n\r\n\r\nham = 1 : merge (map (*3) ham) (map (*10) ham)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7365,95,'1170660','2013-11-05 14:51:21',1,'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_26_1\r\n\r\n{\r\n\r\n	class Task_diff\r\n\r\n	{\r\n\r\n		public static bool allDifferent(int[] a)\r\n\r\n		{\r\n\r\n			return allDifferent1(a, 0, t => true);\r\n\r\n		}\r\n\r\n		\r\n\r\n		public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n		{\r\n\r\n			if (from == a.Length)\r\n\r\n			{\r\n\r\n				return true;\r\n\r\n			}\r\n\r\n			\r\n\r\n			int x = a[from];\r\n\r\n			if (!cond(x))\r\n\r\n			{\r\n\r\n				return false;\r\n\r\n			} else\r\n\r\n			{\r\n\r\n				return allDifferent1(a, from + 1, t => cond(t) && t != x);\r\n\r\n			}\r\n\r\n		}\r\n\r\n		\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n			int[] a = {1,2,3,4,5};\r\n\r\n			int[] b = {1,2,3,4,1};\r\n\r\n			Console.WriteLine(allDifferent(a));\r\n\r\n			Console.WriteLine(allDifferent(b));\r\n\r\n            Console.ReadLine();\r\n\r\n\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7364,96,'1170660','2013-11-05 14:46:48',1,'using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace task_26_2\r\n\r\n{\r\n\r\n	class Task_merge\r\n\r\n	{\r\n\r\n		public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n		{\r\n\r\n			IEnumerator<int> aEnum = a.GetEnumerator();\r\n\r\n			IEnumerator<int> bEnum = b.GetEnumerator();\r\n\r\n			bool aHasNext = aEnum.MoveNext();\r\n\r\n			bool bHasNext = bEnum.MoveNext();\r\n\r\n			\r\n\r\n			while (true)\r\n\r\n			{\r\n\r\n				if (aHasNext && !bHasNext)\r\n\r\n				{\r\n\r\n					yield return aEnum.Current;\r\n\r\n					while (aEnum.MoveNext())\r\n\r\n					{\r\n\r\n						yield return aEnum.Current;\r\n\r\n					}\r\n\r\n					yield break;\r\n\r\n				} else if (!aHasNext && bHasNext)\r\n\r\n				{\r\n\r\n					yield return bEnum.Current;\r\n\r\n					while (bEnum.MoveNext())\r\n\r\n					{\r\n\r\n						yield return bEnum.Current;\r\n\r\n					}\r\n\r\n					yield break;\r\n\r\n				} else if (aHasNext && bHasNext)\r\n\r\n				{\r\n\r\n					int x = aEnum.Current;\r\n\r\n					int y = bEnum.Current;\r\n\r\n					if (x == y) \r\n\r\n					{\r\n\r\n						aHasNext = aEnum.MoveNext();\r\n\r\n						bHasNext = bEnum.MoveNext();\r\n\r\n						yield return x;\r\n\r\n					} else if (x > y)\r\n\r\n					{\r\n\r\n						bHasNext = bEnum.MoveNext();\r\n\r\n						yield return y;\r\n\r\n					} else\r\n\r\n					{\r\n\r\n						aHasNext = aEnum.MoveNext();\r\n\r\n						yield return x;\r\n\r\n					}\r\n\r\n				} else\r\n\r\n				{\r\n\r\n					yield break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args)\r\n\r\n		{\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n			foreach (int i in Merge(a, b))\r\n\r\n			{\r\n\r\n				Console.WriteLine(i);\r\n\r\n			}\r\n\r\n            Console.ReadLine();\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7363,83,'1170660','2013-11-05 14:40:30',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace dop_task\r\n{\r\n	class Task_21_1\r\n	{\r\n		public static IEnumerable<int> Lst137()\r\n		{\r\n			yield return 1;\r\n			yield return 3;\r\n			yield return 7;\r\n			foreach (int i in Lst137())\r\n			{\r\n				yield return 10*i + 1;\r\n				yield return 10*i + 3;\r\n				yield return 10*i + 7;\r\n			}\r\n		}\r\n\r\n		static void Main(string[] args)\r\n		{\r\n			int count = 0;\r\n			foreach (int i in Lst137())\r\n			{\r\n				Console.Write(\"{0} \", i);\r\n				count++;\r\n				if (count == 15){break;}\r\n			}\r\n            Console.ReadKey();\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7362,82,'1170660','2013-11-05 14:31:54',1,'addUsedVars vars [] usedVars = vars ++ usedVars\r\n\r\naddUsedVars [] pairs usedVars = usedVars\r\n\r\naddUsedVars (var:vars) pairs usedVars =\r\n\r\n    let\r\n\r\n      f (x, y) res =\r\n\r\n        if x == var && not(elem y vars) && not(elem y res) && not(elem y usedVars)\r\n\r\n        then y:res\r\n\r\n        else if y == var && not(elem x vars) && not(elem x res) && not(elem x usedVars)\r\n\r\n             then x:res\r\n\r\n             else res\r\n\r\n      newVars = foldr f [] pairs\r\n\r\n    in addUsedVars (newVars ++ vars) pairs (var:usedVars)\r\n\r\n\r\n\r\ncountDifferentVars\' [] pairs usedVars differentVars = length differentVars\r\n\r\ncountDifferentVars\' (var:vars) pairs usedVars differentVars =\r\n\r\n    if elem var usedVars\r\n\r\n    then countDifferentVars\' vars pairs usedVars differentVars\r\n\r\n    else countDifferentVars\' vars pairs (addUsedVars [var] pairs usedVars) (var:differentVars)\r\n\r\n\r\n\r\ncountDifferentVars pairs vars = countDifferentVars\' vars pairs [] []\r\n','<br/>Тесты успешно пройдены!'),(7361,100,'MaryK','2013-11-05 13:47:00',1,'module Func where\r\n\r\n\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),const,filter,RealFloat(),(&&),null,not,take,(<=),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nallDiffLists n k = allDiffLists\' n k (const False)\r\n\r\nallDiffLists\' _ 0 _ = [[]]\r\n\r\nallDiffLists\' n k f = [(x:xs)|x<-[1..n],not(f x), xs<-(allDiffLists\' n (k-1) (	->(f t )|| (t==x)))]\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7360,136,'3226573','2013-11-05 11:25:50',1,'import Data.List\r\n\r\n\r\n\r\n-- List of tuples (Power, Coefficient)\r\n\r\ndata Polynom = Polynom [(Integer, Integer)]\r\n\r\n-- Constructor for polynoms. Use this for correct Polynom constucting\r\n\r\nnewPolynom xs = Polynom (sortBy (a b -> compare (fst a) (fst b)) xs)\r\n\r\n\r\n\r\n-- (==) handling\r\n\r\n\r\n\r\ninstance Eq Polynom where\r\n\r\n	(Polynom xs) == (Polynom ys) = (length xs == length ys) &&\r\n\r\n	                               (any ((a, b) -> a == b) (zip xs ys))\r\n\r\n\r\n\r\n-- (+) and (*) handling\r\n\r\n\r\n\r\nsumMerge xs [] = xs\r\n\r\nsumMerge [] ys = ys\r\n\r\nsumMerge ((xp, xc):xs) ((yp, yc):ys)\r\n\r\n	| xp == yp  = (xp, xc + yc) : sumMerge xs ys\r\n\r\n	| xp < yp   = (xp, xc) : sumMerge xs ((yp, yc):ys)\r\n\r\n	| otherwise	= (yp, yc) : sumMerge ((xp, xc):xs) ys\r\n\r\n\r\n\r\nmultOne (p, c) (Polynom xs) = Polynom (foldr ((xp, xc) res -> (p + xp, c * xc) : res) [] xs)\r\n\r\n\r\n\r\ninstance Num Polynom where\r\n\r\n	(Polynom xs) + (Polynom ys) = Polynom (foldr ((p, c) res -> if c /= 0 then ((p, c) : res) else res) [] (sumMerge xs ys))\r\n\r\n	(Polynom xs) * (Polynom ys) = foldr (x res -> x + res) (Polynom []) (map (x -> multOne x (Polynom ys)) xs)\r\n\r\n\r\n\r\n-- show handling\r\n\r\n\r\n\r\nshowForCoef x = let\r\n\r\n                  sign = if x < 0 then \" - \" else \" + \"\r\n\r\n                  coef = if abs(x) == 1 then \"\" else show (abs(x))\r\n\r\n                in sign ++ coef\r\n\r\n\r\n\r\nshowForPower x = if x == 1 then \"x\" else \"x^\" ++ show x\r\n\r\n\r\n\r\ninstance Show Polynom where\r\n\r\n	show (Polynom xs) = let\r\n\r\n	                      line = foldr ((p, coef) res -> showForCoef coef ++ showForPower p ++ res) \"\" xs\r\n\r\n	                      isMinus = line !! 2 == \'-\'\r\n\r\n	                      restLine = snd (splitAt 3 line)\r\n\r\n	                    in if isMinus then (\'-\' : restLine) else restLine\r\n','<br/>Тесты успешно пройдены!'),(7359,82,'517309','2013-11-05 08:36:46',3,'import Debug.Trace\r\n\r\nmain = print(countDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"])\r\n\r\ncountDifferentVars xs ys = \r\n	let \r\n		y = toSet ys \r\n	in if(y/=[]) then length (destroySynonyms (head y) xs (tail y)) else 0\r\n\r\ndestroySynonyms s xs ys = \r\n	let\r\n		toProcess = chain s xs ys\r\n	in if (toProcess /= []) then s:(destroySynonyms (head toProcess) xs (tail toProcess)) else [s]\r\n\r\nchain s xs ys =\r\n	let\r\n		(newEqs, newVars, synonyms) = findSynonyms s xs ys\r\n	in if(synonyms == []) then newVars else foldr1 intersect (map (	 -> chain t newEqs newVars) synonyms)\r\n\r\nfindSynonyms s xs ys = fs s xs ys [] [] where\r\n	fs s ((a,b):xs) ys e r = if (a/=s && b/=s) then fs s xs ys ((a,b):e) r else \r\n		if (a==s) then fs s xs (filter (/=b) ys) e (b:r) else fs s xs (filter (/=a) ys) e (a:r)\r\n	fs s [] ys e r = (e,ys,r)\r\n\r\nintersect x y = [t|t<-x, elem t y]\r\n\r\ntoSet [] = []\r\ntoSet (x:xs) = x:(toSet (filter (/=x) xs))','<br/>Тесты успешно пройдены!'),(7358,136,'artem.gomerman','2013-11-05 00:27:44',1,'class Polynomial a where\r\n\r\n	(+)::a -> a -> a\r\n\r\n	(*)::a -> a -> a\r\n\r\n	_listAddition::a -> [Double] -> [Double] -> [Double]\r\n\r\n	\r\n\r\ndata Poly = Poly [Double]\r\n\r\n\r\n\r\ninstance Polynomial Poly where\r\n\r\n	(+) (Poly xs) (Poly ys) = Poly (_listAddition (Poly []) xs ys)\r\n\r\n	(*) (Poly xs) (Poly ys) = let \r\n\r\n		xsLen = length xs\r\n\r\n		ysLen = length ys in Poly [sum [(xs !! i) Prelude.* (ys !! j) | i <- [0..xsLen - 1], j <- [0..ysLen - 1], i Prelude.+ j == k] | k <- [0..(xsLen Prelude.* ysLen - 1)] ]\r\n\r\n	_listAddition _ [] xs = xs\r\n\r\n	_listAddition _ xs [] = xs\r\n\r\n	_listAddition p (x:xs) (y:ys) = (x Prelude.+ y):(_listAddition p xs ys)\r\n\r\n	\r\n\r\ninstance Show Poly where\r\n\r\n	show (Poly [x]) = show x\r\n\r\n	show (Poly (x:xs)) = (show x) ++ foldl (\r\nes (x,y) -> if x == 0.0 then res else res ++ \" + \" ++ (show x) ++ \"*x^\" ++ (show y)) \"\" (zip xs [1..])\r\n\r\n	\r\n\r\ninstance Eq Poly where\r\n\r\n	(==) (Poly []) (Poly []) = True\r\n\r\n	(==) (Poly xs) (Poly []) = all (==0) xs\r\n\r\n	(==) (Poly []) (Poly ys) = all (==0) ys\r\n\r\n	(==) (Poly (x:xs)) (Poly (y:ys)) = (x == y) && Poly xs == Poly ys\r\n','<br/>Тесты успешно пройдены!'),(7357,136,'artem.gomerman','2013-11-05 00:03:49',2,'  --- Не совсем так, вот такой тест не проходит, а должен вроде бы проходить:\r\n  ---    Poly [1,1,1]+Poly[1,1,-1] == Poly [2,2]\r\nclass Polynomial a where\r\n\r\n	(+)::a -> a -> a\r\n\r\n	(*)::a -> a -> a\r\n\r\n	_listAddition::a -> [Double] -> [Double] -> [Double]\r\n\r\n	\r\n\r\ndata Poly = Poly [Double]\r\n\r\n\r\n\r\ninstance Polynomial Poly where\r\n\r\n	(+) (Poly xs) (Poly ys) = Poly (_listAddition (Poly []) xs ys)\r\n\r\n	(*) (Poly xs) (Poly ys) = let \r\n\r\n		xsLen = length xs\r\n\r\n		ysLen = length ys in Poly [sum [(xs !! i) Prelude.* (ys !! j) | i <- [0..xsLen - 1], j <- [0..ysLen - 1], i Prelude.+ j == k] | k <- [0..(xsLen Prelude.* ysLen - 1)] ]\r\n\r\n	_listAddition _ [] xs = xs\r\n\r\n	_listAddition _ xs [] = xs\r\n\r\n	_listAddition p (x:xs) (y:ys) = (x Prelude.+ y):(_listAddition p xs ys)\r\n\r\n	\r\n\r\ninstance Show Poly where\r\n\r\n	show (Poly [x]) = show x\r\n\r\n	show (Poly (x:xs)) = (show x) ++ foldl (\r\nes (x,y) -> if x == 0.0 then res else res ++ \" + \" ++ (show x) ++ \"*x^\" ++ (show y)) \"\" (zip xs [1..])\r\n\r\n	\r\n\r\ninstance Eq Poly where\r\n\r\n	(==) (Poly []) (Poly []) = True\r\n\r\n	(==) (Poly xs) (Poly []) = False\r\n\r\n	(==) (Poly []) (Poly ys) = False\r\n\r\n	(==) (Poly (x:xs)) (Poly (y:ys)) = (x == y) && Poly xs == Poly ys','<br/>Тесты успешно пройдены!'),(7355,135,'nomeansno','2013-11-04 23:32:46',1,'superMap f s = foldr g [] s\r\n\r\n	where g = (xn z -> foldr (:) z (f xn))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7356,89,'ilia','2013-11-04 23:47:51',1,'data Node =\r\n\r\n	Empty | \r\n\r\n	Node Integer Node Node\r\n\r\n\r\n\r\nflatten Empty = [ ]\r\n\r\nflatten (Node val l r) = val : (flatten l) ++ (flatten r)\r\n\r\n\r\n\r\nmain = print (flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7353,85,'nomeansno','2013-11-04 21:30:51',1,'data Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat a1 b1) + (Rat a2 b2) = (Rat (a `div` d) (b `div` d))\r\n\r\n		where a = a1*b2+b1*a2; b = b1*b2; d = gcd a b\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat a b) = if b /= 1 then show a ++ \"/\" ++ show b\r\n\r\n			 else show b\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat a1 b1) == (Rat a2 b2) = a1*b2 == b1*a2\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat a1 b1) < (Rat a2 b2) = if b1*b2 > 0 then a1*b2-a2*b1 < 0 else a1*b2-a2*b1 > 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7354,86,'nomeansno','2013-11-04 23:14:02',1,'f\' _ [] = True\r\n\r\nf\' cond (x:xs) = if not (cond x) then False else f\' (	 -> cond t && d t x) xs\r\n\r\n	where d x y = if x `mod` y == 0 || y `mod` x == 0 then False else True\r\n  --- Или короче   d x y = not ( x `mod` y == 0 || y `mod` x == 0 )\r\nallNondivisible = f\' (const True)\r\n\r\n','<br/>Тесты успешно пройдены!'),(7352,95,'15309342','2013-11-04 18:16:41',1,'using System;\r\n\r\nclass Task26_1\r\n{\r\n    public static bool allDifferent(int[] a)\r\n    {\r\n        return allDifferent1(a, 0, t => true);\r\n    }\r\n    \r\n    public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n    {\r\n        if (from == a.Length) {\r\n            return true;\r\n        }\r\n        if (!cond(a[from])) {\r\n            return false;\r\n        }\r\n        return allDifferent1(a, from + 1, t => (cond(t) && t != a[from])); \r\n    }\r\n    \r\n    static void Main()\r\n    {\r\n        int [] a = { 1, 5, 8, 5, 3, 11};\r\n        Console.WriteLine(allDifferent(a));\r\n        int [] b = { 1, 5, 8, 3, 11};\r\n        Console.WriteLine(allDifferent(b));\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7351,96,'15309342','2013-11-04 17:57:56',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nclass Task26_2\r\n\r\n{\r\n\r\n    public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n    {\r\n\r\n        IEnumerator<int> aEnumerator = a.GetEnumerator();\r\n\r\n        IEnumerator<int> bEnumerator = b.GetEnumerator();\r\n\r\n        while (aEnumerator.MoveNext() && bEnumerator.MoveNext()) {\r\n\r\n            int aValue = aEnumerator.Current;\r\n\r\n            int bValue = bEnumerator.Current;\r\n\r\n            if (aValue < bValue) {\r\n\r\n                yield return aValue;\r\n\r\n                yield return bValue;\r\n\r\n            }\r\n\r\n            else if (bValue < aValue) {\r\n\r\n                yield return bValue;\r\n\r\n                yield return aValue;\r\n\r\n            }\r\n\r\n            else {\r\n\r\n                yield return aValue;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        while (aEnumerator.MoveNext()) {\r\n\r\n            yield return aEnumerator.Current;\r\n\r\n        }\r\n\r\n        while (bEnumerator.MoveNext()) {\r\n\r\n            yield return bEnumerator.Current;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    static void Main()\r\n\r\n    {\r\n\r\n        int [] a = { 1, 5, 8 };\r\n\r\n        int [] b = { 3, 5, 9, 10, 11, 12 };\r\n\r\n        foreach (int i in Merge(a, b))\r\n\r\n        {\r\n\r\n            Console.WriteLine(i); // 1, 3, 5, 8, 9, 10, 11, 12\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7350,76,'nomeansno','2013-11-04 17:07:32',1,'data Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	area:: a -> Double\r\n\r\n	perim:: a -> Double\r\n\r\n	contains:: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n	area (Rect x y _ _) = x*y\r\n\r\n	perim (Rect x y _ _) = 2*(x+y)\r\n\r\n	contains (Rect a b x0 y0) x y = x `into` (x0-a\',x0+a\') && y `into` (y0-b\',y0+b\')\r\n\r\n		where into = (x (a,b) -> a<=x && x<=b); a\' = a/2; b\' = b/2\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	area (Circle r _ _) = 3.14*r*r\r\n\r\n	perim (Circle r _ _) = 2*3.14*r\r\n\r\n	contains (Circle r x0 y0) x y = sq_dist (x0,y0) (x,y) <= r*r\r\n\r\n			where sq_dist (x1,y1) (x2, y2) = x*x + y*y\r\n\r\n				where x = x2-x1; y = y2-y1;\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7349,83,'ArtemK','2013-11-04 16:40:44',1,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Task\r\n{\r\n	class MainClass\r\n	{\r\n	public static IEnumerable<int> lst137()\r\n		{\r\n			yield return 1;\r\n			yield return 3;\r\n			yield return 7;\r\n			foreach (int i in lst137()) {\r\n				int t = i * 10;\r\n				yield return t + 1;\r\n				yield return t + 3;\r\n				yield return t + 7;\r\n			}\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			int count = 0;\r\n			foreach (int i in lst137()) {\r\n				Console.Write (i + \", \");\r\n				if (++count == 100)\r\n					return;\r\n			}\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(7348,82,'517309','2013-11-04 15:28:06',3,'import Debug.Trace\r\n\r\nmain = print(countDifferentVars [(\"1\",\"2\"),(\"1\",\"5\"),(\"3\",\"4\"),(\"4\",\"5\")] [\"1\",\"2\",\"3\",\"4\"])\r\n\r\ncountDifferentVars xs ys = \r\n	let \r\n		y = toSet ys \r\n	in if(y/=[]) then length (destroySynonyms (head y) xs (tail y)) else 0\r\n\r\ndestroySynonyms s xs ys = \r\n	let\r\n		toProcess = chain s xs ys\r\n	in if (toProcess /= []) then s:(destroySynonyms (head toProcess) xs (tail toProcess)) else [s]\r\n\r\nchain s xs ys =\r\n	let\r\n		(newEqs, newVars, synonyms) = findSynonyms s xs ys\r\n	in if(synonyms == []) then newVars else foldr intersect [] (map (	 -> chain t newEqs newVars) synonyms)\r\n\r\nfindSynonyms s xs ys = fs s xs ys [] [] where\r\n	fs s ((a,b):xs) ys e r = if (a/=s && b/=s) then fs s xs ys ((a,b):e) r else \r\n		if (a==s) then fs s xs (filter (/=b) ys) e (b:r) else fs s xs (filter (/=a) ys) e (a:r)\r\n	fs s [] ys e r = (e,ys,r)\r\n\r\nintersect x [] = x\r\nintersect x y = [t|t<-x, elem t y]\r\n\r\ntoSet [] = []\r\ntoSet (x:xs) = x:(toSet (filter (/=x) xs))','Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]'),(7347,136,'3226573','2013-11-04 12:42:09',2,'--- Не совсем правильно. Например, Polynom [(1,1),(0,1)] * Polynom [(1,1),(0,-1)] == Polynom [(2,1),(0,-1)]\r\n--- должно возвращать True а у вас False\r\n\r\n-- List of tuples (Power, Coefficient)\r\n\r\ndata Polynom = Polynom [(Integer, Integer)]\r\n\r\n\r\n\r\ninstance Eq Polynom where\r\n\r\n	(Polynom xs) == (Polynom ys) = (length xs == length ys) &&\r\n\r\n	                               (any ((a, b) -> a == b) (zip xs ys))\r\n\r\n\r\n\r\n-- (+) and (*) handling\r\n\r\n\r\n\r\nsumMerge xs [] = xs\r\n\r\nsumMerge [] ys = ys\r\n\r\nsumMerge ((xp, xc):xs) ((yp, yc):ys)\r\n\r\n	| xp == yp  = (xp, xc + yc) : sumMerge xs ys\r\n\r\n	| xp < yp   = (xp, xc) : sumMerge xs ((yp, yc):ys)\r\n\r\n	| otherwise	= (yp, yc) : sumMerge ((xp, xc):xs) ys\r\n\r\n\r\n\r\nmultOne (p, c) (Polynom xs) = Polynom (foldr ((xp, xc) res -> (p + xp, c * xc) : res) [] xs)\r\n\r\n\r\n\r\ninstance Num Polynom where\r\n\r\n	(Polynom xs) + (Polynom ys) = Polynom (foldr ((p, c) res -> if c /= 0 then ((p, c) : res) else res) [] (sumMerge xs ys))\r\n\r\n	(Polynom xs) * (Polynom ys) = foldr (x res -> x + res) (Polynom []) (map (x -> multOne x (Polynom ys)) xs)\r\n\r\n\r\n\r\n-- show handling\r\n\r\n\r\n\r\nshowForCoef x = let\r\n\r\n                  sign = if x < 0 then \" - \" else \" + \"\r\n\r\n                  coef = if abs(x) == 1 then \"\" else show (abs(x))\r\n\r\n                in sign ++ coef\r\n\r\n\r\n\r\nshowForPower x = if x == 1 then \"x\" else \"x^\" ++ show x\r\n\r\n\r\n\r\ninstance Show Polynom where\r\n\r\n	show (Polynom xs) = let\r\n\r\n	                      line = foldr ((p, coef) res -> showForCoef coef ++ showForPower p ++ res) \"\" xs\r\n\r\n	                      isMinus = line !! 2 == \'-\'\r\n\r\n	                      restLine = snd (splitAt 3 line)\r\n\r\n	                    in if isMinus then (\'-\' : restLine) else restLine','<br/>Тесты успешно пройдены!'),(7346,136,'284427','2013-11-04 12:37:04',1,'--многочлены представлены списком коэффициентов при степенях x, начиная с наименьшей\r\n\r\n\r\n\r\nsumLists [] [] = []\r\n\r\nsumLists [] (y:ys) = y : sumLists [] ys\r\n\r\nsumLists (x:xs) [] = x : sumLists xs []\r\n\r\nsumLists (x:xs) (y:ys) = (x+y) : sumLists xs ys\r\n\r\n\r\n\r\nzeroes 0 = []\r\n\r\nzeroes n = 0 : zeroes (n-1)\r\n\r\n\r\n\r\nml [] _ _ = []\r\n\r\nml (x:xs) ys n = ((zeroes n) ++ (map (	 -> t*x) ys)) : ml xs ys (n+1)\r\n\r\n\r\n\r\nmulLists _ [] = []\r\n\r\nmulLists [] _ = []\r\n\r\nmulLists xs ys = \r\n\r\n	let \r\n\r\n		(s:ss) = ml xs ys 0 \r\n\r\n	in\r\n\r\n	foldr sumLists s ss\r\n\r\n\r\n\r\neqLists [] [] = True\r\n\r\neqLists [] (y:ys) = if y == 0 then eqLists [] ys else False\r\n\r\neqLists (x:xs) [] = if x == 0 then eqLists xs [] else False\r\n\r\neqLists (x:xs) (y:ys) = if not(x == y) then False else eqLists xs ys\r\n\r\n\r\n\r\n\r\n\r\nplToStr [] _ = show 0\r\n\r\nplToStr (x:xs) n =\r\n\r\n	let \r\n\r\n		str = if (n == 0) \r\n\r\n			then show x \r\n\r\n			else if (n == 1) then show x ++ \"*x\"\r\n\r\n			else show x ++ \"*x^\" ++ show n\r\n\r\n	in\r\n\r\n	if length xs > 0 \r\n\r\n		then str ++ \" + \" ++ plToStr xs (n+1)\r\n\r\n		else str\r\n\r\n\r\n\r\n\r\n\r\ndata Polynom = Poly [Integer]\r\n\r\n\r\n\r\ninstance Num Polynom where\r\n\r\n    (Poly a1) + (Poly a2) = Poly (sumLists a1 a2)\r\n\r\n    (Poly a1) * (Poly a2) = Poly (mulLists a1 a2)\r\n\r\n\r\n\r\ninstance Show Polynom where\r\n\r\n    show (Poly a) = plToStr a 0\r\n\r\n\r\n\r\ninstance Eq Polynom where\r\n\r\n    (Poly a1) == (Poly a2) = eqLists a1 a2\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7344,100,'48167667','2013-11-04 02:02:14',1,'allDiffLists n k = allDiffLists_ n k (const True)\r\nallDiffLists_ n 0 _ = [[]]	\r\nallDiffLists_ n k cond = [x:xs|x<-[1..n],cond x,xs<-allDiffLists_ n (k-1) (	->cond t && t/=x)]\r\nallLists n 0 = [[]]\r\nallLists n k = [x:xs | x<-[1..n],xs<-allLists n (k-1)]\r\n','<br/>Тесты успешно пройдены!'),(7345,100,'SNNatalieS','2013-11-04 04:01:53',1,'allDiffLists n k = allDiffLists\' n k (const True)\r\nallDiffLists\' n 0 _ = [[]]	\r\nallDiffLists\' n k cond = [x:xs | x <- [1..n], (cond x), xs <- allDiffLists\' n (k - 1) (	 -> cond t && t /= x)]\r\n','<br/>Тесты успешно пройдены!'),(7342,90,'3226573','2013-11-04 00:25:20',1,'findSame\' [] _ = \"There are no same values\"\r\nfindSame\' (x:xs) cond = if not (cond x) then (\"Repeated value: \" ++ show x)\r\n                        else findSame\' xs (	 -> (cond t) && (x /= t))\r\nfindSame xs = findSame\' xs (	 -> True)','<br/>Тесты успешно пройдены!'),(7343,89,'3226573','2013-11-04 00:25:45',1,'data Node = Node Integer Node Node | Empty\r\n\r\nflatten\' Empty f = f\r\nflatten\' (Node val left right) f = ls -> val : (flatten\' left (flatten\' right f)) ls\r\nflatten xs = (flatten\' xs id) []','<br/>Тесты успешно пройдены!'),(7340,86,'3226573','2013-11-04 00:24:29',1,'f [] _ = True\r\nf (x:xs) cond = if not (cond x) then False\r\n                else f xs (	 -> let a = (gcd x t) in (cond t) && (x /= a) && (t /= a))\r\n\r\nallNondivisible xs = f xs (	 -> True)','<br/>Тесты успешно пройдены!'),(7341,135,'3226573','2013-11-04 00:24:53',1,'superMap f xs = foldr (x res -> (f x) ++ res) [] xs','<br/>Тесты успешно пройдены!'),(7339,100,'3226573','2013-11-04 00:23:43',1,'allDiffLists\' n 0 _ = [[]]\r\nallDiffLists\' n k cond = [x:xs | x <- [1..n], cond x, xs <- allDiffLists\' n (k - 1) (	 -> (cond t) && (t /= x))]\r\n\r\nallDiffLists n k = allDiffLists\' n k (	 -> True)','<br/>Тесты успешно пройдены!'),(7337,100,'Artur','2013-11-03 22:50:35',1,'allDiffLists n k = map (fst) (allDiffLists\' n k) \r\n\r\n\r\n\r\nallDiffLists\' n 0 = [([],const True)]\r\n\r\nallDiffLists\' n k = [(x:xs,(i -> (cond i) && i /= x) ) | x<-[1..n],\r\n\r\n					(xs,cond)<- allDiffLists\' n (k-1),  cond x  ]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7338,100,'artem.gomerman','2013-11-03 23:10:39',1,'allDiffLists n k = allDiffLists\' n k (x -> True)\r\n\r\nallDiffLists\' n 0 cond = [[]]\r\n\r\nallDiffLists\' n k cond = [(x:xs) | x <- [1..n], cond x, xs <- (allDiffLists\' n (k - 1) (	 -> cond t && t /= x))]\r\n','<br/>Тесты успешно пройдены!'),(7336,18,'Artur','2013-11-03 22:49:16',1,'\r\n\r\n\r\nallDiffLists n k = map (fst) (allDiffLists\' n k) \r\n\r\n\r\n\r\nallDiffLists\' n 0 = [([],const True)]\r\n\r\nallDiffLists\' n k = [(x:xs,(i -> (cond i) && i /= x) ) | x<-[1..n],\r\n\r\n					(xs,cond)<- allDiffLists\' n (k-1),  cond x  ]\r\n\r\n\r\n\r\ncheck cond [] = False\r\n\r\ncheck cond (y:ys) = if cond y then True else check cond ys\r\n\r\n\r\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(7335,100,'284427','2013-11-03 22:20:19',1,'allD _ 0 _ = [[]]\r\n\r\nallD n k test = [ (r:rs) | r <- [1..n], not(test r), rs <- allD n (k-1) (	 -> test t || t == r)]\r\n\r\n\r\n\r\nallDiffLists n k = allD n k (const False)\r\n','<br/>Тесты успешно пройдены!'),(7334,136,'284427','2013-11-03 22:07:53',2,'  --- Правильно, но не совсем:) Вот такой тест дает False:\r\n  ---   Poly [1,1,1] + Poly [1,1,-1] == Poly [2,2]\r\n  --- а должно быть, видимо, True\r\n  --- Исправьте, пожалуста.\r\n--многочлены представлены списком коэффициентов при степенях x, начиная с наименьшей\r\n\r\nsumLists [] [] = []\r\n\r\nsumLists [] (y:ys) = y : sumLists [] ys\r\n\r\nsumLists (x:xs) [] = x : sumLists xs []\r\n\r\nsumLists (x:xs) (y:ys) = (x+y) : sumLists xs ys\r\n\r\n\r\n\r\nzeroes 0 = []\r\n\r\nzeroes n = 0 : zeroes (n-1)\r\n\r\n\r\n\r\nml [] _ _ = []\r\n\r\nml (x:xs) ys n = ((zeroes n) ++ (map (	 -> t*x) ys)) : ml xs ys (n+1)\r\n\r\n\r\n\r\nmulLists _ [] = []\r\n\r\nmulLists [] _ = []\r\n\r\nmulLists xs ys = \r\n\r\n	let \r\n\r\n		(s:ss) = ml xs ys 0 \r\n\r\n	in\r\n\r\n	foldr sumLists s ss\r\n\r\n\r\n\r\nql [] [] = True\r\n\r\nql (x:xs) (y:ys) = if not(x == y) then False else ql xs ys\r\n\r\neqLists xs ys = \r\n\r\n	if not(length xs == length ys) \r\n\r\n		then False\r\n\r\n		else ql xs ys\r\n\r\n\r\n\r\n\r\n\r\nplToStr [] _ = show 0\r\n\r\nplToStr (x:xs) n =\r\n\r\n	let \r\n\r\n		str = if (n == 0) \r\n\r\n			then show x \r\n\r\n			else if (n == 1) then show x ++ \"*x\"\r\n\r\n			else show x ++ \"*x^\" ++ show n\r\n\r\n	in\r\n\r\n	if length xs > 0 \r\n\r\n		then str ++ \" + \" ++ plToStr xs (n+1)\r\n\r\n		else str\r\n\r\n\r\n\r\n\r\n\r\ndata Polynom = Poly [Integer]\r\n\r\n\r\n\r\ninstance Num Polynom where\r\n\r\n    (Poly a1) + (Poly a2) = Poly (sumLists a1 a2)\r\n\r\n    (Poly a1) * (Poly a2) = Poly (mulLists a1 a2)\r\n\r\n\r\n\r\ninstance Show Polynom where\r\n\r\n    show (Poly a) = plToStr a 0\r\n\r\n\r\n\r\ninstance Eq Polynom where\r\n\r\n    (Poly a1) == (Poly a2) = eqLists a1 a2\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7333,136,'284427','2013-11-03 22:06:17',0,'sumLists [] [] = []\r\n\nsumLists [] (y:ys) = y : sumLists [] ys\r\n\nsumLists (x:xs) [] = x : sumLists xs []\r\n\nsumLists (x:xs) (y:ys) = (x+y) : sumLists xs ys\r\n\n\r\n\nzeroes 0 = []\r\n\nzeroes n = 0 : zeroes (n-1)\r\n\n\r\n\nml [] _ _ = []\r\n\nml (x:xs) ys n = ((zeroes n) ++ (map (	 -> t*x) ys)) : ml xs ys (n+1)\r\n\n\r\n\nmulLists _ [] = []\r\n\nmulLists [] _ = []\r\n\nmulLists xs ys = \r\n\n	let \r\n\n		(s:ss) = ml xs ys 0 \r\n\n	in\r\n\n	foldr sumLists s ss\r\n\n\r\n\nql [] [] = True\r\n\nql (x:xs) (y:ys) = if not(x == y) then False else ql xs ys\r\n\neqLists xs ys = \r\n\n	if not(length xs == length ys) \r\n\n		then False\r\n\n		else ql xs ys\r\n\n\r\n\n\r\n\nplToStr [] _ = show 0\r\n\nplToStr (x:xs) n =\r\n\n	let \r\n\n		str = if (n == 0) \r\n\n			then show x \r\n\n			else if (n == 1) then show x ++ \"*x\"\r\n\n			else show x ++ \"*x^\" ++ show n\r\n\n	in\r\n\n	if length xs > 0 \r\n\n		then str ++ \" + \" ++ plToStr xs (n+1)\r\n\n		else str\r\n\n\r\n\n\r\n\ndata Polynom = Poly [Integer]\r\n\n\r\n\ninstance Num Polynom where\r\n\n    (Poly a1) + (Poly a2) = Poly (sumLists a1 a2)\r\n\n    (Poly a1) * (Poly a2) = Poly (mulLists a1 a2)\r\n\n\r\n\ninstance Show Polynom where\r\n\n    show (Poly a) = plToStr a 0\r\n\n\r\n\ninstance Eq Polynom where\r\n\n    (Poly a1) == (Poly a2) = eqLists a1 a2\r\n\n\r\n\n\n','<br/>Тесты успешно пройдены!'),(7332,89,'5543298','2013-11-03 22:01:38',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nflatten\' Empty res = res\r\n\r\nflatten\' (Node m l r) res = let rr = flatten\' r res in let rl = flatten\' l rr in m:rl\r\n\r\nflatten x = flatten\' x []\r\n','<br/>Тесты успешно пройдены!'),(7331,136,'Artur','2013-11-03 21:45:05',1,'data Polynomial = Poly Int [Integer]\r\n\r\n-- Poly 4 [1,2,3,4,5] ~ 1 + 2x + 3x^2 +4x^3 + 5x^4\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	Poly n1 xs1 == Poly n2 xs2 = polyEq xs1 xs2\r\n\r\npolyEq [] [] = True\r\n\r\npolyEq [] xs = if length (filter (/=0) xs) > 0 then False else True\r\n\r\npolyEq xs [] = if length (filter (/=0) xs) > 0 then False else True\r\n\r\npolyEq (x:xs1) (y:ys1) = if ( x /= y) then False else polyEq xs1 ys1\r\n\r\n	\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Poly n1 (x:xs)) = show x ++ \" + \" ++ (f xs 1)\r\n\r\nf [x] d = show x ++ \"*x^\" ++ show d\r\n\r\nf (x:xs) d= show x ++ \"*x^\" ++ show d ++ \" + \"++(f xs (d+1)) \r\n\r\n	\r\n\r\ninstance Num Polynomial where\r\n\r\n	Poly n1 xs1 + Poly n2 xs2 = Poly (max n1 n2) (addPoly xs1 xs2)\r\n\r\n	Poly n1 xs1 * Poly n2 xs2 = multPoly xs1 xs2 0 \r\n\r\n\r\n\r\naddPoly [] [] = []\r\n\r\naddPoly [] xs = xs\r\n\r\naddPoly xs [] = xs\r\n\r\naddPoly (x:xs) (y:ys) = (x+y): (addPoly xs ys)\r\n\r\n\r\n\r\nmultPoly (x:xs1) ys degree =  let zs = if degree == 0 then map(*x) ys else map(const 0) [1..degree] ++ (map(*x) ys) \r\n\r\n							in if length xs1 > 0 then Poly (length ys -1 + degree) zs + (multPoly xs1 ys (degree+1))\r\n\r\n													else Poly (length ys -1 + degree) zs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7329,135,'5543298','2013-11-03 21:28:29',1,'superMap l xs = foldr (x r -> foldr (y res -> y:res) r (l x)) [] xs\r\n','<br/>Тесты успешно пройдены!'),(7330,90,'5543298','2013-11-03 21:39:17',1,'f _ _ [] = \"\"\r\n\r\nf xs x ys = if length (filter (==x) xs) /= 0 || length (filter (==x) ys) /= 0 then show x else f (x:xs) (head ys) (tail ys)\r\n\r\nfindSame (x:xs) = f [] x xs \r\n\r\nfindSame [] = \"\" \r\n','<br/>Тесты успешно пройдены!'),(7328,93,'Artur','2013-11-03 20:57:24',1,'ham = 1: (merge (map (*3) ham) (map (*10) ham)) \r\n\r\n							\r\n\r\nmerge (x:xs) (y:ys) = if x < y then x : (merge xs (y:ys))\r\n\r\n						else if x > y then y : (merge (x:xs) ys )\r\n\r\n								else x:(merge xs ys)\r\n\r\n\r\n\r\n\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(7325,90,'284427','2013-11-03 20:22:26',1,'data Res a = NoSuchElements | Element a deriving Show\r\n\r\n\r\n\r\nfindSame [] = NoSuchElements\r\n\r\nfindSame (x:xs) = if elem x xs then Element x else findSame xs\r\n','<br/>Тесты успешно пройдены!'),(7326,89,'284427','2013-11-03 20:29:03',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfl Empty as = as\r\n\r\nfl (Node x lt rt) as = x : (fl lt (fl rt as))\r\n\r\nflatten t = fl t []\r\n','<br/>Тесты успешно пройдены!'),(7327,86,'SNNatalieS','2013-11-03 20:38:26',1,'allNondivisible xs = q xs (const True)\r\nq [] _ = True\r\nq (x:xs) cond = if not (cond x) then False\r\n				else q xs (	 -> cond t && not(mod x t == 0) && not(mod t x ==0))','<br/>Тесты успешно пройдены!'),(7321,86,'5543298','2013-11-03 19:33:35',0,'allNondivisible\' [] _ = True\r\n\nallNondivisible\' (x:xs) cond = if not (cond x) then False \r\n\n				          else allNondivisible\' xs \r\n\n					  		(	 -> cond t && t `mod` x /= 0)\r\n\n\r\n\nallNondivisible xs = allNondivisible\' xs (	 -> True)\n','Выражение имеет неправильное значение: allNondivisible [4,2]'),(7322,86,'5543298','2013-11-03 19:34:25',1,'allNondivisible\' [] _ = True\r\n\r\nallNondivisible\' (x:xs) cond = if not (cond x) then False \r\n\r\n				          else allNondivisible\' xs \r\n\r\n					  		(	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0)\r\n\r\n\r\n\r\nallNondivisible xs = allNondivisible\' xs (	 -> True)\r\n','<br/>Тесты успешно пройдены!'),(7323,86,'284427','2013-11-03 19:37:33',1,'allND [] cond = True\r\n\r\nallND (x:xs) cond = if not(cond x) then False else allND xs (	 -> cond t && not(t `mod` x == 0) && not(x `mod` t == 0))\r\n\r\nallNondivisible xs = allND xs (const True)\r\n','<br/>Тесты успешно пройдены!'),(7324,135,'284427','2013-11-03 20:08:38',1,'  --- На самом деле у вас ys всегда будет равен [], вы ведь сначала передает [] и потом\r\n  --- этот параметр никогда не меняется. Поэтому программу можно немного упростить:) \r\nsuperMap f xs = sm f xs []\r\n\r\nsm f [] ys = ys\r\n\r\nsm f (x:xs) ys = ys ++ (f x) ++ (sm f xs ys)\r\n','<br/>Тесты успешно пройдены!'),(7320,85,'284427','2013-11-03 19:07:37',1,'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n    (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2 + n2*d1) (d1*d2)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n    (Rat n1 d1) < (Rat n2 d2) = if (d1*d2 > 0) then n1*d2 < n2*d1 else n1*d2 > n2*d1\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat n d) = show n ++ \"/\" ++ show d\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n    (Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7319,96,'Artur','2013-11-03 19:06:51',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Collections;\r\n\r\n\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace IEnum\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            //IEnumerable.GetEnumerator()\r\n\r\n            IEnumerator aEnum = a.GetEnumerator();\r\n\r\n            IEnumerator bEnum = b.GetEnumerator();\r\n\r\n            aEnum.MoveNext();\r\n\r\n            bEnum.MoveNext();\r\n\r\n            int c = Convert.ToInt32(aEnum.Current);\r\n\r\n            int d = Convert.ToInt32(bEnum.Current);\r\n\r\n                   \r\n\r\n            bool aEnd = false, bEnd = false, nexta = false;\r\n\r\n            while (!aEnd || !bEnd)\r\n\r\n            {\r\n\r\n                if (!aEnd && !bEnd)\r\n\r\n                {\r\n\r\n                    if (c < d)\r\n\r\n                    {\r\n\r\n                        yield return c;\r\n\r\n                        nexta = true ;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        yield return d ;\r\n\r\n                        nexta = false ;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                    if (aEnd)\r\n\r\n                    {\r\n\r\n                        yield return Convert.ToInt32(bEnum.Current) ;\r\n\r\n                        nexta = false;\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        yield return Convert.ToInt32(aEnum.Current) ;\r\n\r\n                        nexta = true;\r\n\r\n                    }\r\n\r\n\r\n\r\n                if (nexta)\r\n\r\n                {\r\n\r\n                    try\r\n\r\n                    {\r\n\r\n                        aEnum.MoveNext();  \r\n\r\n                        c = Convert.ToInt32(aEnum.Current);\r\n\r\n                    }\r\n\r\n                    catch (Exception e) { aEnd = true; }\r\n\r\n                }\r\n\r\n                else \r\n\r\n                {\r\n\r\n                    try { \r\n\r\n                           bEnum.MoveNext();\r\n\r\n                           d = Convert.ToInt32(bEnum.Current);\r\n\r\n                        }\r\n\r\n                    catch (Exception e) {bEnd = true;}\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int [] a = { 1, 5, 8 , 13, 24 ,36 };\r\n\r\n            int [] b = { 3, 5, 9 , 48 , 101, 177};\r\n\r\n            int j = 1;\r\n\r\n            foreach (int i in Merge(a, b) )\r\n\r\n            {      \r\n\r\n                Console.Write(i + \" \"); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n                j++;\r\n\r\n                if (j > 100) break;\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(7317,85,'5543298','2013-11-03 18:41:19',1,'data Ration = Rat Int Int \r\n\r\n\r\n\r\ninstance Num Ration where \r\n\r\n (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\r\n \r\n\r\ninstance Eq Ration where\r\n\r\n    Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\r\n\r\n	\r\n\r\ninstance Ord Ration where\r\n\r\n    Rat x1 y1 < Rat x2 y2 = let s = sign y1 * sign y2 in if s > 0 then x1 * y2 < x2 * y1 else x1 * y2 > x2 * y1\r\n\r\n	\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat x y) = show ((sign y) * x) ++ \"/\" ++ show (abs y)\r\n\r\n\r\n\r\nsign y = if y < 0 then -1 else 1\r\n','<br/>Тесты успешно пройдены!'),(7318,76,'284427','2013-11-03 19:04:06',1,'data Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	area:: a -> Double\r\n\r\n	perim:: a -> Double\r\n\r\n	contains:: a-> Double -> Double -> Bool\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n	area (Rect x y _ _) = x*y\r\n\r\n	perim (Rect x y _ _) = 2*(x+y)\r\n\r\n	contains (Rect x y x1 y1) px py = \r\n\r\n		let \r\n\r\n			xt = x/2\r\n\r\n			yt = y/2\r\n\r\n		in\r\n\r\n		((abs (px - x1)) <= xt) && ((abs (py - y1)) <= yt)  \r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	area (Circle r _ _) = 3.14*r*r\r\n\r\n	perim (Circle r _ _) = 2*3.14\r\n\r\n	contains (Circle r x y) px py =\r\n\r\n		let \r\n\r\n			dx = x - px\r\n\r\n			dy = y - py\r\n\r\n		in \r\n\r\n		(dx*dx+dy*dy) <= r*r\r\n','<br/>Тесты успешно пройдены!'),(7315,85,'5543298','2013-11-03 18:15:50',0,'data Ration = Rat Int Int \r\n\n\r\n\ninstance Num Ration where \r\n\n (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\n \r\n\ninstance Eq Ration where\r\n\n    Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\r\n\n	\r\n\ninstance Ord Ration where\r\n\n    Rat x1 y1 < Rat x2 y2 = let s = sign x1 y1 * sign x2 y2 in s * x1 * y2 < s * x2 * y1\r\n\n	\r\n\ninstance Show Ration where\r\n\n    show (Rat x y) = show ((sign\' y) * x) ++ \"/\" ++ show (abs y)\r\n\n\r\n\nsign x y = if x <0 && y < 0 then -1 else 1\r\n\n\r\n\nsign\' y = if y < 0 then -1 else 1\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7316,85,'5543298','2013-11-03 18:16:57',0,'data Ration = Rat Int Int \r\n\n\r\n\ninstance Num Ration where \r\n\n (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\n \r\n\ninstance Eq Ration where\r\n\n    Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\r\n\n	\r\n\ninstance Ord Ration where\r\n\n    Rat x1 y1 < Rat x2 y2 = let s = sign x1 y1 * sign x2 y2 in if s > 0 then x1 * y2 < x2 * y1 else x1 * y2 > x2 * y1\r\n\n	\r\n\ninstance Show Ration where\r\n\n    show (Rat x y) = show ((sign\' y) * x) ++ \"/\" ++ show (abs y)\r\n\n\r\n\nsign x y = if x <0 && y < 0 then -1 else 1\r\n\n\r\n\nsign\' y = if y < 0 then -1 else 1\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7314,85,'5543298','2013-11-03 17:49:13',0,'data Ration = Rat Int Int \r\n\n\r\n\ninstance Num Ration where \r\n\n (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\n \r\n\ninstance Eq Ration where\r\n\n    Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\r\n\n	\r\n\ninstance Ord Ration where\r\n\n    Rat x1 y1 < Rat x2 y2 = let s = sign x1 y1 * sign x2 y2 in s * x1 * y2 < s * x2 * y1\r\n\n	\r\n\ninstance Show Ration where\r\n\n    show (Rat x y) = show x ++ \"/\" ++ show y\r\n\n\r\n\nsign x y = if x <0 && y < 0 then -1 else 1\r\n\n\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7313,85,'5543298','2013-11-03 17:48:42',0,'data Ration = Rat Int Int \r\n\n\r\n\ninstance Num Ration where \r\n\n (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\n \r\n\ninstance Eq Ration where\r\n\n    Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\r\n\n	\r\n\ninstance Ord Ration where\r\n\n    Rat x1 y1 < Rat x2 y2 = let s = sign x1 y1 * sign x2 y2 in s * y2 < s * x2 * y1\r\n\n	\r\n\ninstance Show Ration where\r\n\n    show (Rat x y) = show x ++ \"/\" ++ show y\r\n\n\r\n\nsign x y = if x <0 && y < 0 then -1 else 1\r\n\n\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7311,76,'5543298','2013-11-03 17:25:09',0,'\n','Не удалось вычислить выражение \"contains (Circle 10 0 0) 6 5\", проверьте правильность синтаксиса'),(7312,76,'5543298','2013-11-03 17:25:49',1,'data Rect = Rect Double Double Double Double \r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n   area:: a -> Double\r\n\r\n   perim:: a -> Double\r\n\r\n   contains:: a -> Double -> Double -> Bool\r\n\r\n   \r\n\r\ninstance Shape Rect where\r\n\r\n  	area (Rect w h _ _) = w*h\r\n\r\n  	perim (Rect w h _ _) = 2*(w+h)\r\n\r\n	contains (Rect w h x y) a b = let w2 = w / 2 in let h2 = h / 2 in x - w2 <= a && x + w2 >= a && y - h2 <= b && y + h2 >= b  \r\n\r\n	\r\n\r\ninstance Shape Circle where\r\n\r\n  	area (Circle r _ _) = 3.14*r*r\r\n\r\n  	perim (Circle r _ _) = 2*3.14*r\r\n\r\n	contains (Circle r x y) a b = (x - a)^2 + (y - b)^2 <= r^2  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7310,135,'1170660','2013-11-03 17:22:09',1,'superMap op [] =[]\r\n\r\nsuperMap op xs = foldr (++) [] (map op xs)\r\n','<br/>Тесты успешно пройдены!'),(7309,85,'5543298','2013-11-03 17:21:42',0,'data Ration = Rat Int Int \r\n\n\r\n\ninstance Num Ration where \r\n\n (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\n \r\n\ninstance Eq Ration where\r\n\n    Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\r\n\n	\r\n\ninstance Ord Ration where\r\n\n    Rat x1 y1 < Rat x2 y2 = x1 * y2 < x2 * y1\r\n\n	\r\n\ninstance Show Ration where\r\n\n    show (Rat x y) = show x ++ \"/\" ++ show y\r\n\n\r\n\n\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7306,85,'1170660','2013-11-03 17:08:26',1,'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n    (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2 + n2*d1) (d1*d2)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n    (Rat n1 d1) < (Rat n2 d2) = if (d1*d2 > 0) then n1*d2 < n2*d1 else n1*d2 > n2*d1\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n    (Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat n d) = show n ++ \"/\" ++ show d\r\n','<br/>Тесты успешно пройдены!'),(7307,135,'1170660','2013-11-03 17:10:49',2,'--- Не та задача\r\nallNondivisible\' [] cond = True\r\n\r\nallNondivisible\' (x:xs) cond = if not(cond x) then False else allNondivisible\' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0)\r\n\r\nallNondivisible xs = allNondivisible\' xs (const True)\r\n','Не удалось вычислить выражение \"let f x = [x*x, 100*x] in superMap f [1,2,3]\", проверьте правильность синтаксиса'),(7308,86,'1170660','2013-11-03 17:11:15',1,'allNondivisible\' [] cond = True\r\n\r\nallNondivisible\' (x:xs) cond = if not(cond x) then False else allNondivisible\' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0)\r\n\r\nallNondivisible xs = allNondivisible\' xs (const True)\r\n','<br/>Тесты успешно пройдены!'),(7305,76,'1170660','2013-11-03 17:04:45',1,'  --- Да зачем же вы всюду пишете = if выражение then True else False\r\n  --- Короче просто = выражение :) \r\ndata Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n    contains :: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n    contains (Rect a b x y) x1 y1 = if(x1>=x-a/2 && x1<=x+a/2&&y1<=y+b/2&&y1>=y-b/2) then True else False\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n    contains (Circle r x y) x1 y1 = if(((x-x1)*(x-x1)+(y-y1)*(y-y1))<=r*r)then True else False \r\n','<br/>Тесты успешно пройдены!'),(7304,82,'517309','2013-11-03 16:52:54',3,'import Debug.Trace\r\n\r\ncountDifferentVars xs ys = \r\n	let \r\n		y = toSet ys \r\n	in if(y/=[]) then length (destroySynonyms (head y) xs (tail y)) else 0\r\n\r\ndestroySynonyms s xs ys = \r\n	let\r\n		toProcess = chain s xs ys\r\n	in if (toProcess /= []) then s:(destroySynonyms (head toProcess) xs (tail toProcess)) else [s]\r\n\r\nchain s xs ys =\r\n	let\r\n		(newEqs, newVars, synonyms) =  findSynonyms s xs ys\r\n	in if(synonyms == []) then newVars else foldr union [] (map (	 -> chain t newEqs newVars) synonyms)\r\n\r\nfindSynonyms s xs ys = fs s xs ys [] [] where\r\n	fs s ((a,b):xs) ys e r = if (a/=s && b/=s) then fs s xs ys ((a,b):e) r else \r\n		if (a==s) then fs s xs (filter (/=b) ys) e (b:r) else fs s xs (filter (/=a) ys) e (a:r)\r\n	fs s [] ys e r = (e,ys,r)\r\n\r\nunion x y = x ++ [t | t<-y, notElem t x]\r\n\r\ntoSet [] = []\r\ntoSet (x:xs) = x:(toSet (filter (/=x) xs))','Выражение имеет неправильное значение: countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]'),(7303,82,'517309','2013-11-03 16:51:12',0,'import Debug.Trace\r\n\r\nmain = print(countDifferentVars [\"x\"=\"x\"] [])\r\n\r\ncountDifferentVars xs ys = \r\n	let \r\n		y = toSet ys \r\n	in if(y/=[]) then length (destroySynonyms (head y) xs (tail y)) else 0\r\n\r\ndestroySynonyms s xs ys = \r\n	let\r\n		toProcess = chain s xs ys\r\n	in if (toProcess /= []) then s:(destroySynonyms (head toProcess) xs (tail toProcess)) else [s]\r\n\r\nchain s xs ys =\r\n	let\r\n		(newEqs, newVars, synonyms) =  findSynonyms s xs ys\r\n	in if(synonyms == []) then newVars else foldr union [] (map (	 -> chain t newEqs newVars) synonyms)\r\n\r\nfindSynonyms s xs ys = fs s xs ys [] [] where\r\n	fs s ((a,b):xs) ys e r = if (a/=s && b/=s) then fs s xs ys ((a,b):e) r else \r\n		if (a==s) then fs s xs (filter (/=b) ys) e (b:r) else fs s xs (filter (/=a) ys) e (a:r)\r\n	fs s [] ys e r = (e,ys,r)\r\n\r\nunion x y = x ++ [t | t<-y, notElem t x]\r\n\r\ntoSet [] = []\r\ntoSet (x:xs) = x:(toSet (filter (/=x) xs))','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(7301,90,'1170660','2013-11-03 16:27:18',1,'data Value value = None | Duplicate value deriving Show\r\n\r\n\r\n\r\nfindSame\' [] xs = None\r\n\r\nfindSame\' (x:xs) temp = if elem x temp then Duplicate x else findSame\' xs (x:temp)\r\n\r\nfindSame xs = findSame\' xs []\r\n','<br/>Тесты успешно пройдены!'),(7302,76,'5543298','2013-11-03 16:38:16',1,'data Rect = Rect Double Double Double Double \r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n   area:: a -> Double\r\n\r\n   perim:: a -> Double\r\n\r\n   contains:: a -> Double -> Double -> Bool\r\n\r\n   \r\n\r\ninstance Shape Rect where\r\n\r\n  	area (Rect w h _ _) = w*h\r\n\r\n  	perim (Rect w h _ _) = 2*(w+h)\r\n\r\n	contains (Rect w h x y) a b = let w2 = w / 2 in let h2 = h / 2 in x - w2 <= a && x + w2 >= a && y - h2 <= b && y + h2 >= b  \r\n\r\n	\r\n\r\ninstance Shape Circle where\r\n\r\n  	area (Circle r _ _) = 3.14*r*r\r\n\r\n  	perim (Circle r _ _) = 2*3.14*r\r\n\r\n	contains (Circle r x y) a b = (x - a)^2 + (y - b)^2 <= r^2  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7299,100,'1170660','2013-11-03 16:13:44',1,'allListsModif n 0 check = [[]]\r\n\r\nallListsModif n k check = [ (x:xs) | x <- [1..n], not (check x), xs <- allListsModif n (k-1) (	 -> check t || t == x)]\r\n\r\n\r\n\r\nallDiffLists n k = allListsModif n k (const False)\r\n','<br/>Тесты успешно пройдены!'),(7300,89,'1170660','2013-11-03 16:21:03',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nflatten\' Empty temp = temp\r\n\r\nflatten\' (Node n l r) temp = n : flatten\' l (flatten\' r temp)\r\n\r\nflatten t = flatten\' t []\r\n','<br/>Тесты успешно пройдены!'),(7298,82,'517309','2013-11-03 15:58:03',0,'import Debug.Trace\r\n\r\ncountDifferentVars xs ys = \r\n	let \r\n		y = toSet ys \r\n	in length (destroySynonyms (head y) xs (tail y))\r\n\r\ndestroySynonyms s xs ys = \r\n	let\r\n		toProcess = chain s xs ys\r\n	in if (toProcess /= []) then s:(destroySynonyms (head toProcess) xs (tail toProcess)) else [s]\r\n\r\nchain s xs ys =\r\n	let\r\n		(newEqs, newVars, synonyms) =  findSynonyms s xs ys\r\n	in if(synonyms == []) then newVars else foldr union [] (map (	 -> chain t newEqs newVars) synonyms)\r\n\r\nfindSynonyms s xs ys = fs s xs ys [] [] where\r\n	fs s ((a,b):xs) ys e r = if (a/=s && b/=s) then fs s xs ys ((a,b):e) r else \r\n		if (a==s) then fs s xs (filter (/=b) ys) e (b:r) else fs s xs (filter (/=a) ys) e (a:r)\r\n	fs s [] ys e r = (e,ys,r)\r\n\r\nunion x y = x ++ [t | t<-y, notElem t x]\r\n\r\ntoSet [] = []\r\ntoSet (x:xs) = x:(toSet (filter (/=x) xs))','Не удалось вычислить выражение \"countDifferentVars [(1,2),(2,3), (4,5)] []\", проверьте правильность синтаксиса'),(7297,95,'Artur','2013-11-03 15:50:48',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace DiffList\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n         {\r\n\r\n            return allDifferent1(a, 0, t => true);\r\n\r\n         }\r\n\r\n\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (from == a.Length - 1 ) \r\n\r\n                return cond(a[from]) ;\r\n\r\n\r\n\r\n            for (int i = from + 1; i < a.Length; i++)\r\n\r\n                if (a[i] == a[from]) return false;\r\n\r\n            \r\n\r\n            return allDifferent1(a, from+1, t => cond(t) && t != a[from]);\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 2 , 3, 4 ,5 } ;\r\n\r\n            int[] b = { 7, 5, 6, 124, 141, 7 } ;\r\n\r\n\r\n\r\n            Console.WriteLine(allDifferent(a)) ;\r\n\r\n            Console.WriteLine(allDifferent(b)) ;\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7296,89,'Artur','2013-11-03 15:07:43',1,'  --- А зачем different, я не очень понял? Тут не надо устранять дупликаты, может я условие нечетко сформулировал..\r\ndifferent [] = []\r\n\r\ndifferent (x:xs) = if elem x xs then different xs\r\n\r\n					else x:(different xs)\r\n\r\n\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten Empty = []\r\n\r\nflatten (Node val l r )= different (flatten\' (Node val l r) [] )\r\n\r\n--flatten (Node val l r )= flatten\' (Node val l r) []\r\n\r\n\r\n\r\n\r\n\r\nflatten\' Empty res = res\r\n\r\nflatten\' (Node val l r) res = let \r\n\r\n								res1 = flatten\' r res\r\n\r\n							in val:(flatten\' l res1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7295,90,'Artur','2013-11-03 14:24:08',1,'findSame [] = show \"all numbers are different\"\r\n\r\nfindSame (x:xs) =  let \r\n\r\n					ys = filter (i -> i /= x ) xs \r\n\r\n					diff = 1 + length xs - length ys\r\n\r\n					in if diff > 1 then show \"number \" ++ show x ++ \" occurs \" ++ show diff ++\" times\" \r\n\r\n						else findSame xs\r\n','<br/>Тесты успешно пройдены!'),(7293,86,'Artur','2013-11-03 13:58:06',1,'allNondivisible xs = allNondivisible\' xs (const True)\r\n\r\n\r\n\r\nallNondivisible\' [x] cond = cond x\r\n\r\nallNondivisible\' (x:xs) cond = if not (cond x) then False \r\n\r\n									else allNondivisible\' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7294,85,'Artur','2013-11-03 13:58:47',1,'data Ration = Rat Integer Integer \r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	Rat n1 d1 + Rat n2 d2 = Rat (n1*d2+n2*d1) (d1*d2) \r\n\r\ninstance Eq Ration where\r\n\r\n	Rat n1 d1 == Rat n2 d2 = n1*d2 == n2*d1\r\n\r\ninstance Ord Ration where\r\n\r\n	Rat n1 d1 < Rat n2 d2 = if (d1 < 0 ) then Rat (-n1) (-d1) < Rat n2 d2 \r\n\r\n							else if (d2 < 0) then Rat n1 d1 < Rat (-n2) (-d2)\r\n\r\n								else n1*d2 < n2*d1\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat n d )= show n ++ \"/\" ++ show d\r\n\r\n	\r\n','<br/>Тесты успешно пройдены!'),(7292,86,'Artur','2013-11-03 13:52:19',0,'allNondivisible xs = allNondivisible\' xs (const True)\r\n\n\r\n\nallNondivisible\' [x] cond = cond x\r\n\nallNondivisible\' (x:xs) cond = if not (cond x) then False \r\n\n									else allNondivisible\' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0) \r\n\n\n','<br/>Тесты успешно пройдены!'),(7291,85,'Artur','2013-11-03 13:51:29',0,'data Ration = Rat Integer Integer \r\n\n\r\n\ninstance Num Ration where\r\n\n	Rat n1 d1 + Rat n2 d2 = Rat (n1*d2+n2*d1) (d1*d2) \r\n\ninstance Eq Ration where\r\n\n	Rat n1 d1 == Rat n2 d2 = n1*d2 == n2*d1\r\n\ninstance Ord Ration where\r\n\n	Rat n1 d1 < Rat n2 d2 = n1*d2 < n2*d1\r\n\ninstance Show Ration where\r\n\n	show (Rat n d )= show n ++ \"/\" ++ show d\r\n\n	\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7290,76,'Artur','2013-11-03 13:50:59',1,'  --- Да зачем же вы всюду пишете = if выражение then True else False\r\n  --- Короче просто = выражение :) \r\nclass Shape a where\r\n\r\n	area:: a -> Double\r\n\r\n	perim:: a -> Double\r\n\r\n	contains:: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n 	\r\n\r\ninstance Shape Rect where \r\n\r\n	area (Rect x y _ _) = x*y\r\n\r\n	perim (Rect x y _ _) = 2*(x+y)\r\n\r\n	contains (Rect w h cx cy) x y= if x >= cx - w/2 && x <= cx + w/2 && y >= cy - h/2 && y <= cy + h/2 then True else False \r\n\r\n	\r\n\r\ninstance Shape Circle where\r\n\r\n	area (Circle r _ _) = 3.14 * r * r\r\n\r\n	perim(Circle r _ _) = 2 * 3.14 * r\r\n\r\n	contains( Circle r cx cy ) x y = if (cx-x)^2 + (cy-y)^2 <= r^2 then True else False\r\n\r\n	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7289,135,'Artur','2013-11-03 13:50:32',1,'superMap f xs = foldr ( i res ->(f i)++res ) [] xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7287,85,'8519021','2013-11-03 13:02:07',0,'data Ration = Rat Int Int\n\n\n\ninstance Num Ration where\n\n	(Rat a b) + (Rat c d) = Rat (a * d + b * c) (b * d)\n\n\n\ninstance Ord Ration where\n\n	(Rat a b) < (Rat c d) \n\n	  | (a * b) < 0 && (c * d) < 0 = abs (a * d) > abs (b * c)\n\n	  | (a * b) < 0 && (c * d) > 0 = True\n\n	  | (a * b) > 0 && (c * d) < 0 = False\n\n	  | otherwise = a * d < b * c\n\n\n\ninstance Eq Ration where\n\n    Rat a b == Rat c d = a == c && b == d\n\n\n\ninstance Show Ration where\n\n    show (Rat a b) = show a ++ \"/\" ++ show b\n','Выражение имеет неправильное значение: Rat (-1) (-2) < Rat 1 3'),(7288,85,'8519021','2013-11-03 13:03:58',1,'data Ration = Rat Int Int\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat a b) + (Rat c d) = Rat (a * d + b * c) (b * d)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat a b) < (Rat c d) \r\n\r\n	  | (a * b) < 0 && (c * d) < 0 = abs (a * d) > abs (b * c)\r\n\r\n	  | (a * b) < 0 && (c * d) > 0 = True\r\n\r\n	  | (a * b) > 0 && (c * d) < 0 = False\r\n\r\n	  | otherwise = abs (a * d) < abs (b * c)\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n    Rat a b == Rat c d = a == c && b == d\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat a b) = show a ++ \"/\" ++ show b\r\n','<br/>Тесты успешно пройдены!'),(7285,85,'8519021','2013-11-03 12:42:28',0,'data Ration = Rat Int Int\n\n\n\ninstance Num Ration where\n\n	(Rat a b) + (Rat c d) = Rat (a * d + b * c) (b * d)\n\n\n\ninstance Ord Ration where\n\n	(Rat a b) < (Rat c d) = a * d < b * c\n\n\n\ninstance Eq Ration where\n\n    Rat a b == Rat c d = a == c && b == d\n\n\n\ninstance Show Ration where\n\n    show (Rat a b) = show a ++ \"/\" ++ show b\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7286,86,'8519021','2013-11-03 12:46:01',1,'allNondivisible xs = allNondivisible\' xs (const True)\r\n\r\nallNondivisible\' [] _ = True\r\n\r\nallNondivisible\' (x:xs) cond = if not (cond x) then False else allNondivisible\' xs (	 -> cond t && t `mod` x /= 0 && x `mod` t /= 0)\r\n','<br/>Тесты успешно пройдены!'),(7284,90,'55363692','2013-11-02 22:25:33',1,'findSame [] = Nothing\r\n\r\nfindSame (x:xs) = if elem x xs then Just x else findSame xs \r\n','<br/>Тесты успешно пройдены!'),(7283,136,'55363692','2013-11-02 22:24:07',1,'import Data.List\r\n\r\n\r\n\r\ndata Polynomial = Pol [Int]\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	Pol (x:xs) + Pol (y:ys) = \r\n\r\n		let Pol zs =  Pol xs + Pol ys in Pol ((x + y) : zs)\r\n\r\n	Pol xs + Pol [] = Pol xs\r\n\r\n	Pol [] + Pol ys = Pol ys\r\n\r\n		\r\n\r\n	Pol (x:xs) * Pol (y:ys) = \r\n\r\n		let Pol zs = Pol [x] * Pol ys + Pol xs * Pol (y:ys) in Pol ((x*y) : zs)\r\n\r\n	Pol _ * Pol _ = Pol []\r\n\r\n	\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Pol xs) = intercalate \" + \" $ map ((x, pow) -> (show x) ++ \"*x^\" ++ (show pow)) (zip xs [0..])	\r\n\r\n\r\n\r\nallZeros [] = True	\r\n\r\nallZeros (x:xs) = x == 0 && allZeros xs	\r\n\r\n	\r\n\r\nareEqual xs [] = allZeros xs	\r\n\r\nareEqual [] ys = allZeros ys	\r\n\r\nareEqual (x:xs) (y:ys) = x == y && areEqual xs ys	\r\n\r\n	\r\n\r\ninstance Eq Polynomial where\r\n\r\n	Pol xs == Pol ys = areEqual xs ys	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7282,136,'15309342','2013-11-02 21:30:27',1,'﻿{-\r\n\r\n\r\n\r\nИсправила сравнение.\r\n\r\n\r\n\r\nПолином представляется в виде списка коэффициентов, начиная с коэффициента при нулевой степени. Если какой-то степени нет, то на соответсвующем месте стоит 0.\r\n\r\n\r\n\r\nПримеры вызовов: Pol [1,2,3] + Pol [1,2]. Получается 2 + 4x + 3x^2\r\n\r\n\r\n\r\n    	 Pol [0,2.3] + Pol [2,3]. Получается 4x + 12x^2 + 3x^3\r\n\r\n\r\n\r\nПроверка на равенство учитывает пропорциональность коэффициентов.\r\n\r\n\r\n\r\n-}\r\n\r\n\r\n\r\ndata Polinoame = Pol [Integer]\r\n\r\n\r\n\r\nsumLists xs [] = xs\r\n\r\n\r\n\r\nsumLists [] ys = ys\r\n\r\n\r\n\r\nsumLists (x:xs) (y:ys) = (x + y) : sumLists xs ys\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmultListsHelper [] ys = []\r\n\r\n\r\n\r\nmultListsHelper (x:xs) ys = (map (* x) ys) : multListsHelper xs (0 : ys)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmultLists xs ys = foldr sumLists [] (multListsHelper xs ys)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n{-\r\n\r\n\r\n\r\nmultLists xs ys | l > 0 = multLists\' $ pairList (addZeros xs (l_xs - 1)) (addZeros ys (l_xs + l - 1)) [([],[])]\r\n\r\n\r\n\r\n                | otherwise = multLists\' $ pairList (addZeros xs (l_ys + l - 1)) (addZeros ys (l_ys - 1)) [([],[])]\r\n\r\n\r\n\r\n                                where\r\n\r\n\r\n\r\n                                    l_xs = length xs\r\n\r\n\r\n\r\n                                    l_ys = length ys\r\n\r\n\r\n\r\n                                    l = l_xs - l_ys\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\r\nmultLists\' [] = []\r\n\r\n\r\n\r\nmultLists\' (x:xs) = (foldl (+) 0 (zipWith (*) (fst x) (reverse $ snd x))) : multLists\' xs \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npairList [] [] acc = tail $ reverse acc\r\n\r\n\r\n\r\npairList (x:xs) (y:ys) acc = pairList xs ys (((fst (head acc) ++ [x]), (snd (head acc) ++ [y])) : acc)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\naddZeros xs n  = xs ++ (take n [0,0..])\r\n\r\n\r\n\r\n-}\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nshowNum x | x == 0 = \"\"\r\n\r\n\r\n\r\n          | otherwise = \" + \" ++ show x\r\n\r\n\r\n\r\n        \r\n\r\n\r\n\r\nshowX x | x == 0 = \"\"\r\n\r\n\r\n\r\n        | otherwise = \" + \" ++ show x ++ \"x\"\r\n\r\n\r\n\r\n        \r\n\r\n\r\n\r\nshowMonome x n | x == 0 = \"\"\r\n\r\n\r\n\r\n               | otherwise = \" + \" ++ show x ++ \"x^\" ++ show n\r\n\r\n\r\n\r\n             \r\n\r\n\r\n\r\nshowPol [] _ = \"\"\r\n\r\n\r\n\r\nshowPol [x] n    | n == 0 = showNum x\r\n\r\n\r\n\r\n                 | n == 1 = showX x\r\n\r\n\r\n\r\n                 | otherwise = showMonome x n\r\n\r\n\r\n\r\n                 \r\n\r\n\r\n\r\nshowPol (x:xs) n | n == 0 = showNum x  ++ (showPol xs (n + 1))\r\n\r\n\r\n\r\n                 | n == 1 = showX x ++ (showPol xs (n + 1))\r\n\r\n\r\n\r\n                 | otherwise = showMonome x n ++ (showPol xs (n + 1))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nshowPolNormalized [] _ = \"\"\r\n\r\n\r\n\r\nshowPolNormalized (x:xs) n | x == 0 = showPolNormalized xs (n + 1)\r\n\r\n\r\n\r\n                           | x /= 0 && n == 0 = show x ++ showPol xs (n + 1)\r\n\r\n\r\n\r\n                           | x /= 0 && n == 1 = show x ++ \"x\" ++ showPol xs (n + 1)\r\n\r\n\r\n\r\n                           | x /= 0 && n > 1  = show x ++ \"x^\" ++ show n ++ showPol xs (n + 1)\r\n\r\n\r\n\r\n                 \r\n\r\n\r\n\r\neqPol [] z@(y:ys) cond = isZeroList z\r\n\r\n\r\n\r\neqPol z@(x:xs) [] cond = isZeroList z\r\n\r\n\r\n\r\neqPol [] [] cond = True\r\n\r\n\r\n\r\neqPol (x:xs) (y:ys) cond | not $ cond (x, y) = False\r\n\r\n\r\n\r\n                         | otherwise = eqPol xs ys (		 -> (cond t) && ((fst t * y == snd t * x) || (x == 0 && y == 0)))\r\n\r\n\r\n\r\nisZeroList [] = True\r\n\r\nisZeroList (x:xs) = if (x == 0) then isZeroList xs else False\r\n\r\n\r\n\r\ninstance Num Polinoame where\r\n\r\n\r\n\r\n    (Pol xs) + (Pol ys) = Pol (sumLists xs ys)\r\n\r\n\r\n\r\n    (Pol xs) * (Pol ys) = Pol (multLists xs ys)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninstance Eq Polinoame where\r\n\r\n\r\n\r\n    (Pol xs) == (Pol ys) = eqPol xs ys (const True)    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninstance Show Polinoame where\r\n\r\n\r\n\r\n    show (Pol xs) = showPolNormalized xs 0\r\n','<br/>Тесты успешно пройдены!'),(7281,96,'55363692','2013-11-02 20:52:27',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> e1 = a.GetEnumerator();\r\n\r\n            IEnumerator<int> e2 = b.GetEnumerator();\r\n\r\n            \r\n\r\n            if (!e1.MoveNext())\r\n\r\n            {\r\n\r\n                while (e2.MoveNext())\r\n\r\n                {\r\n\r\n                    yield return e2.Current;\r\n\r\n                }\r\n\r\n                yield break;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (!e2.MoveNext())\r\n\r\n            {\r\n\r\n                yield return e1.Current;\r\n\r\n                while (e1.MoveNext())\r\n\r\n                {\r\n\r\n                    yield return e1.Current;\r\n\r\n                }\r\n\r\n                yield break;\r\n\r\n            }\r\n\r\n\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                int val1 = e1.Current;\r\n\r\n                int val2 = e2.Current;\r\n\r\n\r\n\r\n                if (val1 < val2)\r\n\r\n                {\r\n\r\n                    yield return val1;\r\n\r\n                    if (!e1.MoveNext())\r\n\r\n                    {\r\n\r\n                        while (e2.MoveNext())\r\n\r\n                        {\r\n\r\n                            yield return e2.Current;\r\n\r\n                        }\r\n\r\n                        yield break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    if (val1 == val2)\r\n\r\n                    {\r\n\r\n                        yield return val1;\r\n\r\n                        if (!e1.MoveNext())\r\n\r\n                        {\r\n\r\n                            while (e2.MoveNext())\r\n\r\n                            {\r\n\r\n                                yield return e2.Current;\r\n\r\n                            }\r\n\r\n                            yield break;\r\n\r\n                        }\r\n\r\n                        if (!e2.MoveNext())\r\n\r\n                        {\r\n\r\n                            while (e1.MoveNext())\r\n\r\n                            {\r\n\r\n                                yield return e1.Current;\r\n\r\n                            }\r\n\r\n                            yield break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        yield return val2;\r\n\r\n                        if (!e2.MoveNext())\r\n\r\n                        {\r\n\r\n                            while (e1.MoveNext())\r\n\r\n                            {\r\n\r\n                                yield return e1.Current;\r\n\r\n                            }\r\n\r\n                            yield break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(String.Join(\", \", Merge(new int[0], new[] { 3, 5, 9 }).ToArray()));\r\n\r\n            Console.WriteLine(String.Join(\", \", Merge(new[] { 1, 5, 9 }, new int[0]).ToArray()));\r\n\r\n            Console.WriteLine(String.Join(\", \", Merge(new[] {1, 5, 9}, new[] {3, 5, 9}).ToArray()));\r\n\r\n            Console.WriteLine(String.Join(\", \", Merge(new[] {1, 2, 5}, new[] {2, 3, 5}).ToArray()));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7278,83,'artem.gomerman','2013-11-02 20:03:29',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    public static IEnumerable<int> Lst137()\r\n\r\n    {\r\n\r\n        int[] lst137 = { 1, 3, 7 };\r\n\r\n\r\n\r\n        foreach (int i in lst137)\r\n\r\n        {\r\n\r\n            yield return i;\r\n\r\n        }\r\n\r\n\r\n\r\n        foreach (int i in Lst137())\r\n\r\n        {\r\n\r\n            foreach (int j in lst137)\r\n\r\n            {\r\n\r\n                yield return 10 * i + j;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Console.Write(\"Integers list of 1-3-7 numbers.\r\nEnter needed count of numbers: \");\r\n\r\n        int count = int.Parse(Console.ReadLine());\r\n\r\n        int index = 0;\r\n\r\n        foreach (int i in Lst137())\r\n\r\n        {\r\n\r\n            if(index >= count)\r\n\r\n                break;\r\n\r\n            index++;\r\n\r\n            Console.Write(i);\r\n\r\n            Console.Write(\" \");\r\n\r\n        }\r\n\r\n        Console.WriteLine();\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7279,85,'3226573','2013-11-02 20:03:35',1,'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n	(Rat x1 y1) == (Rat x2 y2) = (x1 * y2) == (x2 * y1)\r\n	(Rat x1 y1) /= (Rat x2 y2) = (x1 * y2) /= (x2 * y1)\r\n  --- На самом деле достаточно определить == , а /= определится автоматически. \r\n	\r\ninstance Ord Ration where\r\n	(Rat x1 y1) <  (Rat x2 y2) = let\r\n	                               a = fromIntegral x1 / fromIntegral y1\r\n	                               b = fromIntegral x2 / fromIntegral y2\r\n	                             in a < b\r\n\r\ninstance Num Ration where\r\n	(Rat x1 y1) +  (Rat x2 y2) = let\r\n	                               x3 = x1 * y2 + x2 * y1\r\n	                               y3 = y1 * y2\r\n	                             in Rat x3 y3\r\n\r\ninstance Show Ration where\r\n	show (Rat x y) = (show x) ++ \"/\" ++ (show y)','<br/>Тесты успешно пройдены!'),(7280,95,'55363692','2013-11-02 20:19:35',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace FProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        public static bool AllDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (a.Length == from)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n\r\n\r\n            int cur = a[from];\r\n\r\n            if (!cond(cur))\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            return AllDifferent1(a, from + 1, (x => cond(x) && x != cur));\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool AllDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return AllDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(AllDifferent(new[] {1, 3, 2, 4}));\r\n\r\n            Console.WriteLine(AllDifferent(new[] {1, 3, 2, 1}));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7273,136,'55363692','2013-11-02 19:38:47',2,'--- Не совсем так. Вот пример, когда у вас неправильный ответ\r\n---  Pol [1,1,1,1] + Pol [1,1,-1,-1] == Pol [2,2]\r\n--- Исправьте, пожалуйста.\r\n\r\nimport Data.List\r\n\r\n\r\n\r\ndata Polynomial = Pol [Int]\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	Pol (x:xs) + Pol (y:ys) = \r\n\r\n		let Pol zs =  Pol xs + Pol ys in Pol ((x + y) : zs)\r\n\r\n	Pol xs + Pol [] = Pol xs\r\n\r\n	Pol [] + Pol ys = Pol ys\r\n\r\n		\r\n\r\n	Pol (x:xs) * Pol (y:ys) = \r\n\r\n		let Pol zs = Pol [x] * Pol ys + Pol xs * Pol (y:ys) in Pol ((x*y) : zs)\r\n\r\n	Pol _ * Pol _ = Pol []\r\n\r\n	\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Pol xs) = intercalate \" + \" $ map ((x, pow) -> (show x) ++ \"*x^\" ++ (show pow)) (zip xs [0..])	\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	Pol xs == Pol ys = xs == ys	\r\n\r\n','<br/>Тесты успешно пройдены!'),(7274,89,'artem.gomerman','2013-11-02 19:48:45',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n	resl = foldTree f e l\r\n\r\n	resr = foldTree f e r\r\n\r\n	in f val resl resr\r\n\r\n\r\n\r\nflatten tree = foldTree (v l r -> (v:l)++r) [] tree\r\n','<br/>Тесты успешно пройдены!'),(7275,85,'3226573','2013-11-02 19:48:51',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n	(Rat x1 y1) == (Rat x2 y2) = (x1 == x2) && (y1 == y2)\r\n	(Rat x1 y1) /= (Rat x2 y2) = (x1 /= x2) || (y1 /= y2)\r\n	\r\ninstance Ord Ration where\r\n	(Rat x1 y1) <  (Rat x2 y2) = (x1 * y2) < (x2 * y1)\r\n\r\ninstance Show Ration where\r\n	show (Rat x y) = (show x) ++ \"/\" ++ (show y)\r\n\r\ninstance Num Ration where\r\n	(Rat x1 y1) +  (Rat x2 y2) = let\r\n	                               x3 = x1 * y2 + x2 * y1\r\n	                               y3 = y1 * y2\r\n	                               d = gcd x3 y3\r\n	                             in Rat (div x3 d) (div y3 d)','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7276,85,'3226573','2013-11-02 19:50:33',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n	(Rat x1 y1) == (Rat x2 y2) = (x1 == x2) && (y1 == y2)\r\n	(Rat x1 y1) /= (Rat x2 y2) = (x1 /= x2) || (y1 /= y2)\r\n	\r\ninstance Ord Ration where\r\n	(Rat x1 y1) <  (Rat x2 y2) = (x1 * y2) < (x2 * y1)\r\n\r\ninstance Show Ration where\r\n	show (Rat x y) = (show x) ++ \"/\" ++ (show y)\r\n\r\ninstance Num Ration where\r\n	(Rat x1 y1) +  (Rat x2 y2) = let\r\n	                               x3 = x1 * y2 + x2 * y1\r\n	                               y3 = y1 * y2\r\n	                             in Rat x3 y3','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7277,85,'3226573','2013-11-02 19:58:09',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Eq Ration where\r\n	(Rat x1 y1) == (Rat x2 y2) = (x1 * y2) == (x2 * y1)\r\n	(Rat x1 y1) /= (Rat x2 y2) = (x1 * y2) /= (x2 * y1)\r\n	\r\ninstance Ord Ration where\r\n	(Rat x1 y1) <  (Rat x2 y2) = (x1 * y2) < (x2 * y1)\r\n\r\ninstance Num Ration where\r\n	(Rat x1 y1) +  (Rat x2 y2) = let\r\n	                               x3 = x1 * y2 + x2 * y1\r\n	                               y3 = y1 * y2\r\n	                             in Rat x3 y3\r\n\r\ninstance Show Ration where\r\n	show (Rat x y) = (show x) ++ \"/\" ++ (show y)','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7264,85,'55363692','2013-11-02 16:46:07',1,'data Ration = Rat Int Int\r\n\r\n\r\n\r\ninstance Num Ration where \r\n\r\n	(Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + y1 * x2) (y1 * y2)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat x1 y1) < (Rat x2 y2) = (y1 * y2 > 0) == (x1 * y2 < y1 * x2)\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat x1 y1) == (Rat x2 y2) = x1 * y2 == y1 * x2\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat x y) = (show x) ++ \"/\" ++ (show y)	\r\n','<br/>Тесты успешно пройдены!'),(7265,86,'55363692','2013-11-02 16:54:28',1,'allNondivisible\' [] _ = True\r\n\r\nallNondivisible\' (x:xs) cond = \r\n\r\n	if not (cond x) then False\r\n\r\n	else allNondivisible\' xs (	 -> cond t && x `mod` t /= 0 && t `mod` x /= 0)\r\n\r\n\r\n\r\nallNondivisible xs = allNondivisible\' xs (const True)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7266,135,'55363692','2013-11-02 16:59:33',1,'superMap = concatMap\r\n','<br/>Тесты успешно пройдены!'),(7267,90,'55363692','2013-11-02 17:08:03',2,'findSame [] = error \"No duplicates\"\r\n  --- Нет, так не по условию.. Смотрите, ведь написано \"Подойдет любое решение, но надо, \r\n  --- чтобы пользователь мог понять, нашлось что-то или нет.\" Поскольку речь идет о пользователе - программисте,\r\n  --- то, мне кажется, это надо понимать так, что мы должны придумать такой интерфейс, чтобы мы могли вызвать\r\n  --- findSame и по результату в программе понять, успешным был поиск или нет, и в зависмости от этого что-то \r\n  --- делать дальше. А у вас если мы ничего не найдем, то сделать ничего уже не сможем, программа аварийно\r\n  --- завершиться. Попробуйте предложить какой-нибудь такой интерфейс, пожалуйста.\r\n\r\nfindSame (x:xs) = if elem x xs then x else findSame xs ','<br/>Тесты успешно пройдены!'),(7268,89,'55363692','2013-11-02 17:25:42',1,'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\nflatten\' tree acc = case tree of\r\n\r\n	Empty -> acc\r\n\r\n	Node val l r -> let\r\n\r\n		resRight = flatten\' r acc\r\n\r\n		resLeft = flatten\' l resRight\r\n\r\n		in val : resLeft\r\n\r\n\r\n\r\nflatten tree = flatten\' tree []\r\n','<br/>Тесты успешно пройдены!'),(7269,100,'55363692','2013-11-02 17:35:32',1,'allDiffLists\' n 0 _ = [[]]	\r\n\r\nallDiffLists\' n k cond = [(x:xs) | x <- [1..n], cond x, xs <- allDiffLists\' n (k - 1) (	 -> cond t && t /= x)]\r\n\r\n\r\n\r\nallDiffLists n k = allDiffLists\' n k (const True)\r\n','<br/>Тесты успешно пройдены!'),(7270,76,'3226573','2013-11-02 18:44:14',0,'class Shape a where \r\n	area :: a -> Double \r\n	perim :: a -> Double\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\ndata Rect = Rect \r\n	{\r\n	height :: Double,\r\n	width :: Double,\r\n	xr :: Double,\r\n	yr :: Double\r\n	}\r\n\r\ninstance Shape Rect where \r\n	area (Rect height width x y) = height * width \r\n	perim (Rect height width x y) = 2 * (height + width)\r\n	contains (Rect height width x y) x1 y1 = (abs(x - x1) <= (width / 2)) && (abs(y - y1) <= (height / 2))\r\n\r\ndata Circle = Circle\r\n	{\r\n	r :: Double,\r\n	xc :: Double,\r\n	yc :: Double	\r\n	}\r\n\r\ninstance Shape Circle where\r\n	area (Circle r x y) = pi * r * r \r\n	perim (Circle r x y) = 2 * pi * r\r\n	contains (Circle r x y) x1 y1 = ((x - x1) * (x - x1) + (y - y1) * (y - y1)) <= r * r','<br/>Тесты успешно пройдены!'),(7271,76,'3226573','2013-11-02 18:51:47',1,'class Shape a where \r\n	area :: a -> Double \r\n	perim :: a -> Double\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where \r\n	area (Rect height width x y) = height * width \r\n	perim (Rect height width x y) = 2 * (height + width)\r\n	contains (Rect height width x y) x1 y1 = (abs(x - x1) <= (width / 2)) && (abs(y - y1) <= (height / 2))\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n	area (Circle r x y) = pi * r * r \r\n	perim (Circle r x y) = 2 * pi * r\r\n	contains (Circle r x y) x1 y1 = ((x - x1) * (x - x1) + (y - y1) * (y - y1)) <= r * r','<br/>Тесты успешно пройдены!'),(7272,90,'artem.gomerman','2013-11-02 19:09:57',1,'findSame xs = findSame\' xs (x -> True)\r\n\r\nfindSame\' [] cond = (0, False)\r\n\r\nfindSame\' (x:xs) cond = if not (cond x) then (x, True) else findSame\' xs (	 -> cond t && x /= t)\r\n','<br/>Тесты успешно пройдены!'),(7260,76,'55363692','2013-11-02 15:00:09',1,'class Shape a where\r\n\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double	\r\n\r\n	\r\n\r\ninstance Shape Rect \r\n\r\n	where contains (Rect w h x y) a b = abs (a - x) < w / 2 && abs (b - y) < h / 2\r\n\r\ninstance Shape Circle\r\n\r\n	where contains (Circle r x y) a b = (x - a) * (x - a) + (y - b) * (y - b) < r * r\r\n','<br/>Тесты успешно пройдены!'),(7261,82,'Artur','2013-11-02 15:35:43',0,'different [] = []\r\n\ndifferent (x:xs) = if elem x xs then different xs\r\n\n					else x:(different xs)\r\n\n					\r\n\nrules xs = let \r\n\n		f = (s1,s2) res -> if check (ys -> elem s1 ys || (elem s2 ys) ) res then  map (ys -> if elem s1 ys || (elem s2 ys) then s1:s2:ys else ys) res\r\n\n							else [s1,s2]:res\r\n\n		in map (xs -> different xs)(foldr f [] xs)\r\n\n\r\n\ncheck cond [] = False\r\n\ncheck cond (x:xs) = if cond x then True else check cond xs\r\n\n\r\n\ncountDifferentVars xs ys = \r\n\n					let f = s1 (xss,yss) -> if check (zs -> elem s1 zs) xss \r\n\n						   then (filter (zs -> not (elem s1 zs) ) xss, (head (filter (zs -> elem s1 zs) xss)) : yss)\r\n\n						   else if check (zs -> elem s1 zs) yss then (xss,yss) else (xss,[s1]:yss) \r\n\n						\r\n\n			in length ( snd(foldr f (rules xs, []) ys) )\r\n\n\r\n\n\n','Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]'),(7262,82,'Artur','2013-11-02 15:45:19',1,'different [] = []\r\n\r\ndifferent (x:xs) = if elem x xs then different xs\r\n\r\n					else x:(different xs)\r\n\r\n					\r\n\r\nrules xs = let \r\n\r\n		f = (s1,s2) res -> if check (ys -> elem s1 ys)res && (check(ys -> elem s2 ys)  res) \r\n\r\n							then (head (filter (ys -> elem s1 ys) res) ++ (head (filter (ys -> elem s2 ys) res))) \r\n\r\n									: (filter (ys -> not (elem s1 ys) && (not (elem s2 ys))) res)\r\n\r\n							else if check (ys -> elem s1 ys || (elem s2 ys) ) res then  map (ys -> if elem s1 ys || (elem s2 ys) then s1:s2:ys else ys) res\r\n\r\n								  else [s1,s2]:res\r\n\r\n		in map (xs -> different xs)(foldr f [] xs)\r\n\r\n\r\n\r\ncheck cond [] = False\r\n\r\ncheck cond (x:xs) = if cond x then True else check cond xs\r\n\r\n\r\n\r\ncountDifferentVars xs ys = \r\n\r\n					let f = s1 (xss,yss) -> if check (zs -> elem s1 zs) xss \r\n\r\n						   then (filter (zs -> not (elem s1 zs) ) xss, (head (filter (zs -> elem s1 zs) xss)) : yss)\r\n\r\n						   else if check (zs -> elem s1 zs) yss then (xss,yss) else (xss,[s1]:yss) \r\n\r\n						\r\n\r\n			in length ( snd(foldr f (rules xs, []) ys) )\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7263,85,'55363692','2013-11-02 16:45:04',0,'data Ration = Rat Double Double\r\n\n\r\n\ninstance Num Ration where \r\n\n	(Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + y1 * x2) (y1 * y2)\r\n\n\r\n\ninstance Ord Ration where\r\n\n	(Rat x1 y1) < (Rat x2 y2) = (y1 * y2 > 0) == (x1 * y2 < y1 * x2)\r\n\n\r\n\ninstance Eq Ration where\r\n\n	(Rat x1 y1) == (Rat x2 y2) = x1 * y2 == y1 * x2\r\n\n\r\n\ninstance Show Ration where\r\n\n	show (Rat x y) = (show x) ++ \"/\" ++ (show y)	\n','Выражение имеет неправильное значение: Rat 1 2 + Rat 1 7'),(7259,136,'deripaska','2013-11-02 12:15:59',1,'{--\r\n\r\n	task 25-02\r\n\r\nСложение и умножение многочленов\r\n\r\n\r\n\r\nОпишите тип, позволяющий хранить информацию о многочленах с одной переменной, и реализуйте для него операторы + (сложение), * (умножение), == (равенство) и функцию show.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Monomial = Monom (Integer, Integer) -- первое число в паре - коеффициент (k), а второе число - степень (n), т.е. k * (X ^ n)\r\n\r\ndata Polynomial = Polynom [Monomial]\r\n\r\n\r\n\r\nsumAppropriateMonom (Monom (k1, n1)) (Monom (k2, n2)) = Monom (k1 + k2, n1) -- here n1 = n2\r\n\r\n\r\n\r\nsimplifyMonomList [] = []\r\n\r\nsimplifyMonomList ((Monom (k, n)):xs) = \r\n\r\n	let \r\n\r\n		h = filter ( (Monom (k1, n1)) -> n1 == n) xs\r\n\r\n		t = filter ( (Monom (k1, n1)) -> n1 /= n) xs\r\n\r\n		Monom (sumK, sumN) = foldr ( x res -> sumAppropriateMonom x res) (Monom (k, n)) h\r\n\r\n	in	\r\n\r\n		if (sumK == 0) then (simplifyMonomList t)\r\n\r\n		else (Monom (sumK, sumN)) : (simplifyMonomList t)\r\n\r\n\r\n\r\nsimplifyPolynom (Polynom xs) = Polynom (simplifyMonomList xs)\r\n\r\n\r\n\r\ninstance Eq Monomial where\r\n\r\n	(Monom (k1, n1)) == (Monom (k2, n2)) = (k1 == k2) && (n1 == n2)\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	(Polynom [Monom (k, n)]) + (Polynom xs) = \r\n\r\n		simplifyPolynom (Polynom ((Monom (k, n)):xs))\r\n\r\n	(Polynom xs) + (Polynom ys) = \r\n\r\n		foldr ( x res -> (Polynom [x]) + res) (Polynom ys) xs\r\n\r\n	(Polynom [Monom (k, n)]) * (Polynom xs) = \r\n\r\n		Polynom (foldr ( (Monom (k1, n1)) res -> Monom (k1 * k, n1 + n) : res) [] xs)\r\n\r\n	(Polynom xs) * (Polynom ys) = foldr ( x res -> (Polynom [x]) * (Polynom ys) + res) (Polynom []) xs\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	(Polynom xs) == (Polynom ys) = \r\n\r\n		let \r\n\r\n			first = simplifyMonomList xs\r\n\r\n			second = simplifyMonomList ys\r\n\r\n		in (length first == length second) && (foldr ( x res -> (elem x second) && res) True first)\r\n\r\n\r\n\r\ninstance Show Monomial where\r\n\r\n    show (Monom (k, n)) = \r\n\r\n		if (k /= 0) then\r\n\r\n			if (n == 0) then show k\r\n\r\n			else if (n == 1) then show k ++ \" * X\"\r\n\r\n			else show k ++ \" * X^\" ++ show n\r\n\r\n		else \"\"\r\n\r\n	\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Polynom (x:xs)) = show x \r\n\r\n						++ foldr (y res -> \r\n\r\n									let yShow = show y\r\n\r\n									in \r\n\r\n										if (yShow /= \"\") then \" + \" ++ yShow ++ res\r\n\r\n										else res\r\n\r\n								) [] xs\r\n\r\n	\r\n\r\n-- Polynom [Monom (1, 0)] + Polynom [Monom (2, 1), Monom (3, 2)] -- 1 + 2 * X + 3 * X^2\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] + Polynom [Monom (2, 1), Monom (3, 2)] -- 1 + 5 * X + 3 * X^2\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1), Monom (1, 2)] + Polynom [Monom (2, 2), Monom (3, 2), Monom (5, 3)]  -- 1 + 3 * X + 6 * X^2 + 5 * X^3\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] + Polynom [Monom (1, 0), Monom (-3, 1)] -- 2\r\n\r\n-- Polynom [Monom (1, 0)] * Polynom [Monom (2, 1), Monom (3, 2)] -- 2 * X + 3 * X^2\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] * Polynom [Monom (2, 1), Monom (3, 2)] -- 2 * X + 9 * X^2 + 9 * X^3\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] == Polynom [Monom (1, 0), Monom (3, 1)] -- True\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] == Polynom [Monom (1, 0), Monom (3, 2)] -- False\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] + Polynom [Monom (1, 0), Monom (-3, 1)] == Polynom [Monom (2, 0)] -- True\r\n','<br/>Тесты успешно пройдены!'),(7258,96,'1595828','2013-11-02 11:50:50',2,'  --- Нет, это не совсем правильно.\r\n  --- Дело в том, что, хоть это прямо и не написано, но подразумевается, что \r\n  --- последовательности могут быть и бесконечными. А, значит, ни Concat ни OrderBy использовать нельзя.\r\n  --- Те надо написать как-то без стандартных фунцкций - сравниваем первые элементы, продвигаем \r\n  --- ту последовательность, которая меньше и т.д. При этом надо использовать, видимо методы \r\n  --- IEnumerator (MoveNext и Current).\r\n  --- Попробуйте исправить, пожалуйста.\r\nusing System.Collections.Generic;\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\nnamespace zd26_2\r\n\r\n{\r\n\r\n    class zd\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n           return a.Concat(b).OrderBy(x=>x).Distinct();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 3, 5, 6 };\r\n\r\n            int[] b = { 1, 2, 4, 6, 8, 10, 12, 14 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7257,82,'Artur','2013-11-02 08:27:58',0,'countDifferentVars xs ys = length (foldr ((s1,s2) res ->\r\n\n		if  length (filter (vs-> elem s1 vs  && (elem s2 vs)) res) > 0	then res\r\n\n		else filter (vs-> elem s1 vs ) res\r\n\n			 ++ (filter (vs-> elem s2 vs ) res ) \r\n\n			 ++(filter (vs-> not(elem s1 vs)&& (not(elem s2 vs)) ) res)) ((ws -> map ( i -> [i]) ws) ys) xs )\r\n\n\r\n\n		\r\n\n		\r\n\n--		if  length (filter (vs-> elem s1 vs  && (elem s2 vs)) res) > 0	then res\r\n\n--		else (head(filter (vs-> elem s1 vs ) res)\r\n\n--			 ++(head(filter (vs-> elem s2 vs ) res)) \r\n\n--			 )\r\n\n--			 :(filter (vs-> not(elem s1 vs)&& (not(elem s2 vs)) ) res)) ((ws -> map ( i -> [i]) ws) ys) xs )\r\n\n\n','Выражение имеет неправильное значение: countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]'),(7256,82,'Artur','2013-11-02 08:25:06',0,'countDifferentVars _ [] = 0\r\n\ncountDifferentVars xs ys = length (foldr ((s1,s2) res ->\r\n\n		if  length (filter (vs-> elem s1 vs  && (elem s2 vs)) res) > 0	then res\r\n\n		else (head(filter (vs-> elem s1 vs ) res)\r\n\n			 ++(head(filter (vs-> elem s2 vs ) res)) \r\n\n			 )\r\n\n			 :(filter (vs-> not(elem s1 vs)&& (not(elem s2 vs)) ) res)) ((ws -> map ( i -> [i]) ws) ys) xs )\r\n\n\n','Не удалось вычислить выражение \"countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]\", проверьте правильность синтаксиса'),(7255,82,'Artur','2013-11-02 08:23:13',0,'\r\n\ncountDifferentVars xs ys = length (foldr ((s1,s2) res ->\r\n\n		if  length (filter (vs-> elem s1 vs  && (elem s2 vs)) res) > 0	then res\r\n\n		else (head(filter (vs-> elem s1 vs ) res)\r\n\n			 ++(head(filter (vs-> elem s2 vs ) res)) \r\n\n			 )\r\n\n			 :(filter (vs-> not(elem s1 vs)&& (not(elem s2 vs)) ) res)) ((ws -> map ( i -> [i]) ws) ys) xs )\r\n\n\n','Не удалось вычислить выражение \"countDifferentVars [(1,2),(2,3), (4,5)] []\", проверьте правильность синтаксиса'),(7254,82,'Artur','2013-11-02 08:19:36',0,'\r\n\ncountDifferentVars xs ys = foldr ((s1,s2) res ->\r\n\n		if  length (filter (vs-> elem s1 vs  && (elem s2 vs)) res) > 0	then res\r\n\n		else (head(filter (vs-> elem s1 vs ) res)\r\n\n			 ++(head(filter (vs-> elem s2 vs ) res)) \r\n\n			 )\r\n\n			 :(filter (vs-> not(elem s1 vs)&& (not(elem s2 vs)) ) res)) ((ws -> map ( i -> [i]) ws) ys) xs\r\n\n\n','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(7253,136,'romos2007','2013-11-02 02:55:11',1,'{--\r\n\r\nЗадача 25-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\nПолином с целочисленными коэффициентами.\r\n\r\nОперации (+), (*), (==), show.\r\n\r\n\r\n\r\np.s. Мне было довольно лень писать хорошую функцию show для многочлена :( Поэтому она работает не очень красиво.\r\n\r\nХотя, по-моему, отображение многочлена в виде обычного массива чисел вполне сносно выглядит и без X-ов и степеней.\r\n\r\n-}\r\n\r\n\r\n\r\ndata Polynom = P [Int]\r\n\r\n\r\n\r\ninstance Num (Polynom) where\r\n\r\n	(P p1) + (P p2) = P (add p1 p2)\r\n\r\n	(P p1) * (P p2) = P (delNull (multPoly (p1) (p2)))\r\n\r\n\r\n\r\ninstance Eq (Polynom) where\r\n\r\n	(P p1) == (P p2) = let\r\n\r\n						lp1 = length p1\r\n\r\n						lp2 = length p2\r\n\r\n					  in\r\n\r\n					  	if lp1 < lp2\r\n\r\n					  	then (p1++[x|x<-(map (const 0) [1..(lp2-lp1)])]) == p2\r\n\r\n					  	else p1 == (p2 ++ [x|x<-(map (const 0) [1..(lp1-lp2)])])\r\n\r\n\r\n\r\ninstance Show (Polynom) where\r\n\r\n	show (P p) = showPoly p\r\n\r\n	--show (P p) = show p\r\n\r\n\r\n\r\n\r\n\r\n----------------------------------------------\r\n\r\n--Удалить незначащие нули при старших степенях\r\n\r\ndelNull [] = []\r\n\r\ndelNull xs = if (last xs == 0) then delNull (init xs) else xs\r\n\r\n\r\n\r\n-- Сложение двух многочленов в терминах массивов\r\n\r\nadd p1 p2 = let\r\n\r\n				lp1 = length p1\r\n\r\n				lp2 = length p2\r\n\r\n			in\r\n\r\n			  	if lp1 < lp2\r\n\r\n			  	then (delNull (zipWith (+) (p1 ++ repeat 0) p2))\r\n\r\n			  	else (delNull (zipWith (+) p1 (p2 ++ repeat 0)))\r\n\r\n\r\n\r\n\r\n\r\n-- Реализация умножения двух многочленов в терминах массивов\r\n\r\n---- умножение на число\r\n\r\nmultByNum num p = map (*num) (delNull p)\r\n\r\n\r\n\r\n---- умножение на X\r\n\r\nmultByX p = delNull (0:p)\r\n\r\n\r\n\r\n---- непосредственно умножение двух многочленов\r\n\r\nmultPoly [] p2 = []\r\n\r\nmultPoly (p:p1) p2 = let\r\n\r\n						pp2 = multByNum p p2\r\n\r\n						xpp2 = multByX (multPoly p1 p2)\r\n\r\n                     in add pp2 xpp2\r\n\r\n\r\n\r\n-- Процедура отображения многочлена\r\n\r\nshowPoly p =let\r\n\r\n				--делаем пары (коэффициент,степень) для нашего многочлена. Только ненулевые коэффициенты.\r\n\r\n				coeff = filter ((x_i,i)->x_i/=0) (zip (delNull p) [0..])\r\n\r\n				--отображение коэффициента при X\r\n\r\n				showCoeff c = if c == 1 then \"\" else show c\r\n\r\n				--отображение степени X\r\n\r\n				showXPow pow = if pow == 0\r\n\r\n                				then \"\"\r\n\r\n                				else\r\n\r\n	                				if pow == 1\r\n\r\n            						then \"x\"\r\n\r\n            						else \"x^\" ++ show pow\r\n\r\n\r\n\r\n				--отображение целиком всего многочлена\r\n\r\n				revCoeff = reverse coeff\r\n\r\n				initRevCoeff = init revCoeff\r\n\r\n				lastRevCoeff = last revCoeff\r\n\r\n			in	foldr ((x_i,i) e->show x_i ++\"x^\"++show i++\" + \" ++ e) \"\" initRevCoeff ++ show (fst lastRevCoeff) ++\"x^\"++show (snd lastRevCoeff)\r\n','<br/>Тесты успешно пройдены!'),(7252,76,'8519021','2013-11-02 01:08:58',1,'data Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	contains::a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n  	contains (Rect a b x0 y0) x y = ((x - x0) ^ 2 <= (a / 2) ^ 2) && ((y - y0) ^ 2 <= (b / 2) ^ 2)\r\n\r\n	\r\n\r\ninstance Shape Circle where\r\n\r\n  	contains (Circle r x0 y0) x y = (x - x0) ^ 2 + (y - y0) ^ 2 <= r ^ 2\r\n','<br/>Тесты успешно пройдены!'),(7251,136,'15309342','2013-11-01 23:05:13',2,'  --- В проверке на равенство, видимо, у вас не совсем все правильно:\r\n  ---   Pol [2,2]==Pol [1,1,1,1]+Pol [1,1,-1,-1]\r\n  --- выдает False, а должно быть видимо True \r\n  --- > Проверка на равенство учитывает пропорциональность коэффициентов.\r\n  --- Мне кажется что этого нет смысла делать. По моему x+1 и 2*x+2 - это разные многочлены.\r\n  --- Но это ОК, если проверять равенство с точностью до умножения на константу, можно и так.\r\ndata Polinoame = Pol [Integer]\r\n\r\n\r\n\r\n{-\r\n\r\nПолином представляется в виде списка коэффициентов, начиная с коэффициента при нулевой степени. Если какой-то степени нет, то на соответсвующем месте стоит 0.\r\n\r\nПримеры вызовов: Pol [1,2,3] + Pol [1,2]. Получается 2 + 4x + 3x^2\r\n\r\n		 Pol [0,2.3] + Pol [2,3]. Получается 4x + 12x^2 + 3x^3\r\n\r\nПроверка на равенство учитывает пропорциональность коэффициентов.\r\n\r\n-}\r\n\r\n\r\n\r\nsumLists xs [] = xs\r\n\r\nsumLists [] ys = ys\r\n\r\nsumLists (x:xs) (y:ys) = (x + y) : sumLists xs ys\r\n\r\n\r\n\r\nmultListsHelper [] ys = []\r\n\r\nmultListsHelper (x:xs) ys = (map (* x) ys) : multListsHelper xs (0 : ys)\r\n\r\n\r\n\r\nmultLists xs ys = foldr sumLists [] (multListsHelper xs ys)\r\n\r\n\r\n\r\n{-\r\n\r\nmultLists xs ys | l > 0 = multLists\' $ pairList (addZeros xs (l_xs - 1)) (addZeros ys (l_xs + l - 1)) [([],[])]\r\n\r\n                | otherwise = multLists\' $ pairList (addZeros xs (l_ys + l - 1)) (addZeros ys (l_ys - 1)) [([],[])]\r\n\r\n                                where\r\n\r\n                                    l_xs = length xs\r\n\r\n                                    l_ys = length ys\r\n\r\n                                    l = l_xs - l_ys\r\n\r\n                \r\n\r\nmultLists\' [] = []\r\n\r\nmultLists\' (x:xs) = (foldl (+) 0 (zipWith (*) (fst x) (reverse $ snd x))) : multLists\' xs \r\n\r\n\r\n\r\npairList [] [] acc = tail $ reverse acc\r\n\r\npairList (x:xs) (y:ys) acc = pairList xs ys (((fst (head acc) ++ [x]), (snd (head acc) ++ [y])) : acc)\r\n\r\n\r\n\r\naddZeros xs n  = xs ++ (take n [0,0..])\r\n\r\n-}\r\n\r\n                \r\n\r\n\r\n\r\nshowNum x | x == 0 = \"\"\r\n\r\n          | otherwise = \" + \" ++ show x\r\n\r\n        \r\n\r\nshowX x | x == 0 = \"\"\r\n\r\n        | otherwise = \" + \" ++ show x ++ \"x\"\r\n\r\n        \r\n\r\nshowMonome x n | x == 0 = \"\"\r\n\r\n               | otherwise = \" + \" ++ show x ++ \"x^\" ++ show n\r\n\r\n             \r\n\r\nshowPol [] _ = \"\"\r\n\r\nshowPol [x] n    | n == 0 = showNum x\r\n\r\n                 | n == 1 = showX x\r\n\r\n                 | otherwise = showMonome x n\r\n\r\n                 \r\n\r\nshowPol (x:xs) n | n == 0 = showNum x  ++ (showPol xs (n + 1))\r\n\r\n                 | n == 1 = showX x ++ (showPol xs (n + 1))\r\n\r\n                 | otherwise = showMonome x n ++ (showPol xs (n + 1))\r\n\r\n\r\n\r\nshowPolNormalized [] _ = \"\"\r\n\r\nshowPolNormalized (x:xs) n | x == 0 = showPolNormalized xs (n + 1)\r\n\r\n                           | x /= 0 && n == 0 = show x ++ showPol xs (n + 1)\r\n\r\n                           | x /= 0 && n == 1 = show x ++ \"x\" ++ showPol xs (n + 1)\r\n\r\n                           | x /= 0 && n > 1  = show x ++ \"x^\" ++ show n ++ showPol xs (n + 1)\r\n\r\n                 \r\n\r\neqPol [] (y:ys) cond = False\r\n\r\neqPol (x:xs) [] cond = False\r\n\r\neqPol [] [] cond = True\r\n\r\neqPol (x:xs) (y:ys) cond | not $ cond (x, y) = False\r\n\r\n                         | otherwise = eqPol xs ys (	 -> (cond t) && (fst t * y == snd t * x))\r\n\r\ninstance Num Polinoame where\r\n\r\n    (Pol xs) + (Pol ys) = Pol (sumLists xs ys)\r\n\r\n    (Pol xs) * (Pol ys) = Pol (multLists xs ys)\r\n\r\n\r\n\r\ninstance Eq Polinoame where\r\n\r\n    (Pol xs) == (Pol ys) = eqPol xs ys (const True)    \r\n\r\n\r\n\r\ninstance Show Polinoame where\r\n\r\n    show (Pol xs) = showPolNormalized xs 0','<br/>Тесты успешно пройдены!'),(7250,100,'8519021','2013-11-01 22:40:57',1,'allDiffLists n k = allDiffLists\' n k (const True)\r\n\r\nallDiffLists\' n 0 _ = [[]]\r\n\r\nallDiffLists\' n k cond = \r\n\r\n  [x:xs | x<-[1..n], cond x, xs<-allDiffLists\' n (k-1) (	 -> cond t && t /= x)]\r\n','<br/>Тесты успешно пройдены!'),(7249,96,'115753099','2013-11-01 22:13:41',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace ConsoleApplication4\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> ia = a.GetEnumerator(), ib = b.GetEnumerator();\r\n\r\n            bool ba = ia.MoveNext(), bb = ib.MoveNext();\r\n\r\n            int i = 0, j = 0;\r\n\r\n            while (ba && bb)\r\n\r\n            {\r\n\r\n                i = ia.Current;\r\n\r\n                j = ib.Current;\r\n\r\n                if (i > j)\r\n\r\n                {\r\n\r\n                    bb = ib.MoveNext();\r\n\r\n                    yield return j;\r\n\r\n                }\r\n\r\n                else if (i == j)\r\n\r\n                {\r\n\r\n                    bb = ib.MoveNext();\r\n\r\n                    ba = ia.MoveNext();\r\n\r\n                    yield return j;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    ba = ia.MoveNext();\r\n\r\n                    yield return i;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            while (ba)\r\n\r\n            {\r\n\r\n                i = ia.Current;\r\n\r\n                ba = ia.MoveNext();\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n            while (bb)\r\n\r\n            {\r\n\r\n                j = ib.Current;\r\n\r\n                bb = ib.MoveNext();\r\n\r\n                yield return j;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 0, 1, 5, 8 };\r\n\r\n            int[] b = { 0, 5, 10, 11 };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7248,96,'romos2007','2013-11-01 21:04:55',1,'﻿/*\r\n\r\n * Задача 26-2\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace _26_2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> aEn = a.GetEnumerator();\r\n\r\n            IEnumerator<int> bEn = b.GetEnumerator();\r\n\r\n            bool aMoveNext = aEn.MoveNext();\r\n\r\n            bool bMoveNext = bEn.MoveNext();\r\n\r\n\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                if (aMoveNext && bMoveNext) // в обоих списках еще остались элементы\r\n\r\n                {\r\n\r\n                    if (aEn.Current < bEn.Current)\r\n\r\n                    {\r\n\r\n                        yield return aEn.Current;\r\n\r\n                        aMoveNext = aEn.MoveNext();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                        if (aEn.Current > bEn.Current)\r\n\r\n                        {\r\n\r\n                            yield return bEn.Current;\r\n\r\n                            bMoveNext = bEn.MoveNext();\r\n\r\n                        }\r\n\r\n                        else\r\n\r\n                            if (aEn.Current == bEn.Current)\r\n\r\n                            {\r\n\r\n                                yield return aEn.Current;\r\n\r\n                                aMoveNext = aEn.MoveNext();\r\n\r\n                                bMoveNext = bEn.MoveNext();\r\n\r\n                            }\r\n\r\n                }\r\n\r\n                else\r\n\r\n                if (aMoveNext && !bMoveNext) // один из списков закончился\r\n\r\n                {\r\n\r\n                    yield return aEn.Current;\r\n\r\n                    while (aEn.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return aEn.Current;\r\n\r\n                    }\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                if (!aMoveNext && bMoveNext) // другой список закончился\r\n\r\n                {\r\n\r\n                    yield return bEn.Current;\r\n\r\n                    while (bEn.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return bEn.Current;\r\n\r\n                    }\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9 };\r\n\r\n            //int[] a = { 1, 5, 8, 10, 15, 20, 22 };\r\n\r\n            //int[] b = { 3, 5, 9, 10, 11, 12 };\r\n\r\n            //int[] a = { };\r\n\r\n            //int[] b = { };\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7247,95,'romos2007','2013-11-01 20:06:09',1,'﻿/*\r\n\r\n * Задача 26-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\n\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _26_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferent1(a, 0, t => true);\r\n\r\n        }\r\n\r\n        public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (from == a.Length)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n\r\n\r\n            int afrom = a[from];\r\n\r\n            if (cond(afrom))\r\n\r\n            {\r\n\r\n                return allDifferent1(a, from + 1, t => cond(t) && (t != afrom));\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static string Show(int[] a)\r\n\r\n        {\r\n\r\n            string str = \"\";\r\n\r\n            for (int i = 0; i < a.Length - 1; i++)\r\n\r\n            {\r\n\r\n                str += a[i] + \", \";\r\n\r\n            }\r\n\r\n            str += a[a.Length - 1];\r\n\r\n            return str;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 2, 3, 4, 5, 6 };\r\n\r\n            int[] b = { 1, 2, 3, 4, 5, 1 };\r\n\r\n            int[] c = { 1, 2, 2, 3 };\r\n\r\n            Console.WriteLine(\"Does array [ {0} ] consist of unique elements?\r\n	{1}\r\n\r\n\", Show(a), allDifferent(a));\r\n\r\n            Console.WriteLine(\"Does array [ {0} ] consist of unique elements?\r\n	{1}\r\n\r\n\", Show(b), allDifferent(b));\r\n\r\n            Console.WriteLine(\"Does array [ {0} ] consist of unique elements?\r\n	{1}\r\n\r\n\", Show(c), allDifferent(c));\r\n\r\n            Console.WriteLine(\"\r\n\r\n---------\r\nHappy end. Now hit ENTER\");\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7246,90,'3270666','2013-11-01 19:40:32',1,'findSame xs = findSame\' xs []\r\n\r\nfindSame\' [] _ = (-1, False)\r\nfindSame\' (x:xs) s = if (hasSame x s)\r\n	then (x, True)\r\n	else findSame\' xs (x:s)\r\n\r\nhasSame _ [] = False\r\nhasSame x (y:ys) = if (x == y)\r\n	then True\r\n	else hasSame x ys','<br/>Тесты успешно пройдены!'),(7244,135,'3270666','2013-11-01 19:16:39',1,'superMap _ [] = []\r\nsuperMap f (x:xs) = f x ++ superMap f xs','<br/>Тесты успешно пройдены!'),(7245,89,'3270666','2013-11-01 19:31:08',1,'data Tree = Empty | Node Int Tree Tree\r\n\r\nflatten (Node val l r) = flatten\' [(Node val l r)]\r\n\r\nflatten\' [] = []\r\nflatten\' (Empty : xs) = flatten\' xs\r\nflatten\' ((Node val l r) : xs) = val : (flatten\' (l : r : xs))','<br/>Тесты успешно пройдены!'),(7243,86,'3270666','2013-11-01 19:14:04',2,'--- Это правильно, но не по условию, это не прием, о котором шла речь.\r\n--- Те надо взять программу с прошлого занятия (она на слайде 19) и попробовать\r\n--- написать что-то похожее. Начало, видимо должно быть таким:\r\n---  allNondivisible xs = allNondivisible\' xs (const True)\r\n---  b дальше надо описать allNondivisible\' c двумя параметрами xs (список) и cond\r\n---  - условие, которое мы по мере продвижения по списку делаем все сложнее и сложнее,\r\n---   добавляем в него новые проверки.    \r\nallNondivisible xs = allNondivisible\' xs []\r\n\r\nallNondivisible\' [] _ = True\r\nallNondivisible\' (x:xs) s = if (divisable x s)\r\n	then False\r\n	else allNondivisible\' xs (x:s)\r\n\r\ndivisable _ [] = False\r\ndivisable x (y:ys) = if (x `mod` y == 0 || y `mod` x == 0)\r\n	then True\r\n	else divisable x ys','<br/>Тесты успешно пройдены!'),(7242,86,'3270666','2013-11-01 19:12:57',0,'allNondivisible xs = allNondivisible\' xs []\r\n\r\nallNondivisible\' [] _ = True\r\nallNondivisible\' (x:xs) s = if (divisable x s)\r\n	then False\r\n	else allNondivisible\' xs (x:s)\r\n\r\ndivisable _ [] = False\r\ndivisable x (d:ds) = if (x `mod` d == 0)\r\n	then True\r\n	else divisable x ds','Выражение имеет неправильное значение: allNondivisible [4,2]'),(7241,85,'3270666','2013-11-01 19:06:16',1,'data Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n	(Rat numer1 denom1) + (Rat numer2 denom2) = \r\n		let (Rat numer1\' denom1\') = checkNeg (Rat numer1 denom1)\r\n		    (Rat numer2\' denom2\') = checkNeg (Rat numer2 denom2)\r\n		in Rat (numer1\' * denom2\' + numer2\' * denom1\') (denom1\' * denom2\')\r\n\r\ninstance Eq Ration where\r\n	(Rat numer1 denom1) == (Rat numer2 denom2) =\r\n		let (Rat numer1\' denom1\') = checkNeg (Rat numer1 denom1)\r\n		    (Rat numer2\' denom2\') = checkNeg (Rat numer2 denom2)\r\n		in numer1\' * denom2\' == numer2\' * denom1\'\r\n\r\ninstance Ord Ration where\r\n	(Rat numer1 denom1) < (Rat numer2 denom2) =\r\n		let (Rat numer1\' denom1\') = checkNeg (Rat numer1 denom1)\r\n		    (Rat numer2\' denom2\') = checkNeg (Rat numer2 denom2)\r\n		in numer1\' * denom2\' < numer2\' * denom1\'\r\n\r\ninstance Show Ration where\r\n	show (Rat numer denom) =\r\n		show numer ++ \"/\" ++ show denom\r\n\r\ncheckNeg (Rat numer denom) = if (denom < 0)\r\n	then (Rat (-numer) (-denom))\r\n	else (Rat numer denom)','<br/>Тесты успешно пройдены!'),(7240,85,'3270666','2013-11-01 18:53:07',0,'data Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n	(Rat numer1 denom1) + (Rat numer2 denom2) = \r\n		Rat (numer1 * denom2 + numer2 * denom1) (denom1 * denom2)\r\n\r\ninstance Eq Ration where\r\n	(Rat numer1 denom1) == (Rat numer2 denom2) =\r\n		numer1 * denom2 == numer2 * denom1\r\n\r\ninstance Ord Ration where\r\n	(Rat numer1 denom1) < (Rat numer2 denom2) =\r\n		numer1 * denom2 < numer2 * denom1\r\n\r\ninstance Show Ration where\r\n	show (Rat numer denom) =\r\n		show numer ++ \"/\" ++ show denom','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7239,96,'deripaska','2013-11-01 18:25:36',1,'﻿/*\r\n\r\n	task 26-02\r\n\r\n*Доп.задача на C#, до 15.11*\r\n\r\nСлияние IEnumerable\r\n\r\n\r\n\r\nОпределить генератор Merge с двумя параметрами типа IEnumerable<int>. Пусть мы точно знаем, что в обоих IEnumerable числа строго возрастают. Генератор должен объединять последовательности, т.е. результатом должна быть последовательность чисел из обеих входных последовательностей в порядке возрастания. Если какое-то число было в обеих входных последовательностях, то в выходной оно должно встречаться один раз.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\nint [] a = { 1, 5, 8 };\r\n\r\nint [] b = { 3, 5, 9 };\r\n\r\nforeach (int i in Merge(a, b))\r\n\r\n{\r\n\r\nConsole.WriteLine(i); // Должно напечататься 1, 3, 5, 8, 9\r\n\r\n}\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_26_02\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {     \r\n\r\n        public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n\r\n        {\r\n\r\n            IEnumerator<int> a_iterator = a.GetEnumerator();\r\n\r\n            IEnumerator<int> b_iterator = b.GetEnumerator();\r\n\r\n            bool aFrom = a_iterator.MoveNext();\r\n\r\n            bool bFrom = b_iterator.MoveNext();\r\n\r\n\r\n\r\n            while (aFrom || bFrom)\r\n\r\n            {\r\n\r\n                if (aFrom && bFrom)\r\n\r\n                {\r\n\r\n                    int x = a_iterator.Current;\r\n\r\n                    int y = b_iterator.Current;\r\n\r\n                    if (x < y)\r\n\r\n                    {\r\n\r\n                        yield return x;\r\n\r\n                        aFrom = a_iterator.MoveNext();\r\n\r\n                    }\r\n\r\n                    else if (x > y)\r\n\r\n                    {\r\n\r\n                        yield return y;\r\n\r\n                        bFrom = b_iterator.MoveNext();\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        yield return x;\r\n\r\n                        aFrom = a_iterator.MoveNext();\r\n\r\n                        bFrom = b_iterator.MoveNext();\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else if (!aFrom)\r\n\r\n                {\r\n\r\n                    yield return b_iterator.Current;\r\n\r\n\r\n\r\n                    while (b_iterator.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return b_iterator.Current;\r\n\r\n                    }\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n                else if (!bFrom)\r\n\r\n                {\r\n\r\n                    yield return a_iterator.Current;\r\n\r\n\r\n\r\n                    while (a_iterator.MoveNext())\r\n\r\n                    {\r\n\r\n                        yield return a_iterator.Current;\r\n\r\n                    }\r\n\r\n                    yield break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 1, 5, 8 };\r\n\r\n            int[] b = { 3, 5, 9, 10, 11};\r\n\r\n            foreach (int i in Merge(a, b))\r\n\r\n            {\r\n\r\n                Console.WriteLine(i); // 1, 3, 5, 8, 9\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7238,95,'deripaska','2013-11-01 18:25:19',1,'﻿/*\r\n\r\n	task 26-01\r\n\r\n*Доп.задача на C#, до 15.11*\r\n\r\n\r\n\r\nНаписать на C# функцию, которая для данного массива целых чисел проверяет, верно ли, что в нем все элементы разные. При этом функция должна использовать \"представление множеств с помощью логической функции\". Т.е., другими словами, попробуйте переписать на С# пример с последнего занятия.\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n\r\n- Вы можете спросить, а зачем такую простую задачу решать так сложно? Да в общем-то просто для интереса:) Ну и для тренировки в работе с лямбда-выражениями и т.д. На практике это, наверное, особо не применимо, честно говоря.\r\n\r\n\r\n\r\nПодсказка: \r\n\r\nЯ бы начал решение этой задачи как-то так:\r\n\r\n\r\n\r\npublic static bool allDifferent(int[] a)\r\n\r\n{\r\n\r\nreturn allDifferent1(a, 0, t => true);\r\n\r\n}\r\n\r\n\r\n\r\n// allDifferent1 - вспомогательная функция\r\n\r\n// a - массив, который мы проверяем\r\n\r\n// from - с какого места в массиве мы проверяем\r\n\r\n// cond - функция проверки (которую мы делаем все сложнее и сложнее)\r\n\r\n\r\n\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n\r\n{\r\n\r\n...\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_26_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static bool allDifferent(int[] a)\r\n\r\n        {\r\n\r\n            return allDifferent_help(a, 0, t => true);\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool allDifferent_help(int[] a, int from, Predicate<int> cond)\r\n\r\n        {\r\n\r\n            if (from >= a.Length)\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n\r\n\r\n            int head = a[from];\r\n\r\n            if (!cond (head)) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            } else \r\n\r\n            {\r\n\r\n                return allDifferent_help(a, from + 1, (t => cond(t) && t != head));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = new int[] {1,2,3,4,5}; //True\r\n\r\n            int[] b = new int[] {2,5,6,8,2}; // False\r\n\r\n            Console.WriteLine(allDifferent(a));\r\n\r\n            Console.WriteLine(allDifferent(b));\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7237,76,'3270666','2013-11-01 17:45:50',1,'  --- ОК, но только всюду вместо if _какое-то_условие_ then True else False\r\n  --- лучше писать просто _какое-то_условие_ :)\r\nclass Shape a where\r\n	area:: a -> Double\r\n	perim:: a -> Double\r\n	contains:: a -> Double -> Double -> Bool\r\n-- Rectangle: x_length, y_length, x_center, y_center\r\ndata Rect = Rect Double Double Double Double\r\n-- Circle: radius, x_center, y_center\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Rect where\r\n  	area (Rect x y _ _) = x*y\r\n  	perim (Rect x y _ _) = 2*(x+y)\r\n  	contains (Rect x y cent_x cent_y) x\' y\' = \r\n  		let left = cent_x - x / 2\r\n  		    right = cent_x + x / 2\r\n  		    top = cent_y + y / 2\r\n  		    bottom = cent_y - y / 2\r\n  		in if (x\' < left || x\' > right || y\' > top || y\' < bottom)\r\n  			  then False\r\n  			  else True\r\n\r\ninstance Shape Circle where\r\n  	area (Circle r _ _) = 3.14*r*r\r\n  	perim (Circle r _ _) = 2*3.14*r\r\n  	contains (Circle r x y) x\' y\' = \r\n  		let dist = (x - x\')^2 + (y - y\')^2\r\n  		in if (r^2 <= dist)\r\n  			  then False\r\n  			  else True','<br/>Тесты успешно пройдены!'),(7236,96,'115753099','2013-11-01 16:51:47',2,'  --- Нет, это не совсем то.. Дело в том, что, хотя это и не написано было, но подразумевается,\r\n  --- что Merge должна работать и для бесконечных списков. А у вас не будет работать, потому что \r\n  --- на Concat произойдет зацикливание. Т.е. надо как-то вручную, брать из двух последовательностей\r\n  --- наименьший элемент, передвигать его и т.д. \r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n		public static IEnumerable<int> Merge(IEnumerable<int> a, IEnumerable<int> b)\r\n		{\r\n			IEnumerator<int> inum = a.Concat<int>(b).OrderBy<int, int>(x => x).GetEnumerator();\r\n			int i = 0;\r\n			if (inum.MoveNext()) {\r\n				i = inum.Current;\r\n				yield return i;\r\n			}\r\n			while (inum.MoveNext()) {\r\n				if (i != inum.Current) {\r\n					i = inum.Current;\r\n					yield return inum.Current;\r\n				}\r\n			}\r\n		}\r\n		\r\n		\r\n		public static void Main (string[] args)\r\n		{\r\n			int [] a = { 0, 1, 5, 8 };\r\n			int [] b = { 3, 5, 9 };\r\n			foreach (int i in Merge(a, b))\r\n			{\r\n				Console.WriteLine(i);\r\n			}\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7235,79,'2156724','2013-11-01 16:05:20',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace digits\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> digits(int n)\r\n        {\r\n            for (int i = 0, d = 1; ; i++, d = d*10)\r\n            {\r\n                    double digit = Math.Truncate((double)d / n);\r\n                    yield return digit;\r\n                    d = d - (int) digit * n;\r\n            }\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Введите n\");\r\n            int n = int.Parse(Console.ReadLine());\r\n            foreach (double x in digits(n).Take(100))\r\n            {\r\n                Console.Write(x + \" \"); \r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7234,95,'115753099','2013-11-01 15:38:07',1,'using System;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n		public static bool allDifferent(int[] a)\r\n		{\r\n			return allDifferent1(a, 0, t => true);\r\n		}\r\n		\r\n		public static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n		{\r\n			if (from == a.Length) return true;\r\n			if (!cond(a[from])) return false;\r\n			else return allDifferent1(a, (from + 1), t => cond(t) && t != a[from]);	\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			Console.WriteLine (allDifferent(new int[6]{1,3,2,5,4,4}) + \"\r\n\" + allDifferent(new int[5]{1,3,2,5,4}));\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7233,100,'15309342','2013-11-01 11:01:51',1,'allDiffLists n k = allDiffLists\' n k (const True)\r\nallDiffLists\' n 0 _ = [[]]\r\nallDiffLists\' n k cond = [x:xs | x <- [1..n], cond x, xs <- allDiffLists\' n (k - 1) (	 -> cond t && t /= x)]','<br/>Тесты успешно пройдены!'),(7231,100,'1595828','2013-11-01 02:17:01',1,'allLists _ 0 _=[[]]\r\n\r\nallLists n k cond =[(x:xs)|x<-[1..n],not (cond x), xs<-allLists n (k-1) (	 -> cond t || t == x)]\r\n\r\nallDiffLists n k =  allLists n k (const False)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7232,136,'115753099','2013-11-01 08:26:35',1,'import Data.List\r\n\r\ndata Polinom = Polinom [Int]\r\n\r\n---list --- is a coef in back order\r\n\r\n\r\n\r\ninstance Num Polinom where\r\n\r\n	(Polinom xs) + (Polinom ys) =\r\n\r\n		Polinom (reverse list)\r\n\r\n		where\r\n\r\n			list = doListSum (reverse xs) (reverse ys)\r\n\r\n			doListSum [] js = js\r\n\r\n			doListSum is [] = is\r\n\r\n			doListSum (i:is) (j:js) = (i + j) : doListSum is js\r\n\r\n	(Polinom xs) * (Polinom ys) =\r\n\r\n		Polinom list\r\n\r\n		where\r\n\r\n			resultLen = (length xs + length ys - 1)\r\n\r\n			doDoList list len = mapAccumL (curLevel x -> ( curLevel+1 , (emptyList curLevel) ++ x ++ (emptyList (len - (length x) - curLevel)))) 0 list\r\n\r\n			emptyList len\r\n\r\n				| len == 0 = []\r\n\r\n				| otherwise = 0 : emptyList (len - 1)\r\n\r\n			(list, _) = mapAccumL (l z -> (zipWith (+) l z, z) ) (emptyList (resultLen)) temp2\r\n\r\n			(_, temp2) = (doDoList temp (resultLen))\r\n\r\n			temp = map (x -> fst (mapAccumL (acc y -> ((acc ++ [x*y]), y)) [] ys)) xs\r\n\r\n	abs _ = Polinom []\r\n\r\n	signum _ = Polinom []\r\n\r\n	fromInteger _ = Polinom []\r\n\r\ninstance Show Polinom where\r\n\r\n	show (Polinom l) = \r\n\r\n		\"result: \" ++ show (result (reverse l) 0)\r\n\r\n		where\r\n\r\n			result [] powe = \"\"\r\n\r\n			result (i:li) powe\r\n\r\n				| powe == 0 = show i ++ (result li (powe+1))\r\n\r\n				| otherwise = \" + \" ++ show i ++ \"*x^\" ++ (show powe) ++ (result li (powe+1))\r\n\r\ninstance Eq Polinom where\r\n\r\n	Polinom xs == Polinom ys =\r\n\r\n		xs == ys\r\n','<br/>Тесты успешно пройдены!'),(7229,135,'artem.gomerman','2013-11-01 01:35:32',1,'superMap func xs = concat (map func xs)\r\n','<br/>Тесты успешно пройдены!'),(7230,90,'artem.gomerman','2013-11-01 01:46:52',2,'findSame xs = findSame\' xs (x -> True)\r\n   --- Но это не совсем по условию. Там же написано:\r\n   --- *Подойдет любое решение, но надо, чтобы пользователь мог понять, нашлось что-то или нет.*\r\n   --- Имелось в виду, что надо иметь возможность в программе вызвать fidSame и как-то узнать,\r\n   --- как функция закончилась 0 успешн или нет.  И в зависмости от этого что-то сделать.\r\n   --- В вашем случае, если мы ничего не найдем, то программа аварийно завершитья, и это понятно не совсем то.\r\nfindSame\' [] cond = error \"All the numbers are different\"\r\n\r\nfindSame\' (x:xs) cond = if not (cond x) then x else findSame\' xs (	 -> cond t && x /= t)','<br/>Тесты успешно пройдены!'),(7227,135,'ilia','2013-11-01 01:19:30',1,'superMap f m = foldr (i j -> f i ++ j) [ ] m\r\n\r\n\r\n\r\nmain = print (superMap (x -> [ x * x, 100 * x ]) [ 1, 2, 3 ])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7228,86,'artem.gomerman','2013-11-01 01:31:19',1,'allNondivisible xs = allNondivisible\' xs (x -> True)\r\n\r\nallNondivisible\' [] cond = True\r\n\r\nallNondivisible\' (x:xs) cond = if not (cond x) then False else allNondivisible\' xs (	 -> cond t && (mod (max t x) (min t x)) /= 0)\r\n','<br/>Тесты успешно пройдены!'),(7226,135,'ilia','2013-11-01 01:19:02',0,'','Не удалось вычислить выражение \"let f x = [x*x, 100*x] in superMap f [1,2,3]\", проверьте правильность синтаксиса'),(7225,136,'deripaska','2013-11-01 01:16:17',2,'--- Не совсем так, потому что надо еще учитывать, что степени могут сокращаться.\r\n--- Например:  Polynom [Monom (1, 0), Monom (3, 1)] + Polynom [Monom (1, 0), Monom (-3, 1)]==Polynom [Monom (2, 0)]\r\n--- Получается False, а должно быть, видимо, True.\r\n--- Исправьте, пожалуйста.\r\n{--\r\n\r\n	task 25-02\r\n\r\nСложение и умножение многочленов\r\n\r\n\r\n\r\nОпишите тип, позволяющий хранить информацию о многочленах с одной переменной, и реализуйте для него операторы + (сложение), * (умножение), == (равенство) и функцию show.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Monomial = Monom (Integer, Integer) -- первое число в паре - коеффициент (k), а второе число - степень (n), т.е. k * (X ^ n)\r\n\r\ndata Polynomial = Polynom [Monomial]\r\n\r\n\r\n\r\nsumAppropriateMonom (Monom (k1, n1)) (Monom (k2, n2)) = Monom (k1 + k2, n1) -- here n1 = n2\r\n\r\n		\r\n\r\ninstance Eq Monomial where\r\n\r\n	(Monom (k1, n1)) == (Monom (k2, n2)) = (k1 == k2) && (n1 == n2)\r\n\r\n\r\n\r\ninstance Num Polynomial where\r\n\r\n	(Polynom [Monom (k, n)]) + (Polynom xs) = \r\n\r\n		let \r\n\r\n			h = filter ( (Monom (k1, n1)) -> n1 == n) xs\r\n\r\n			t = filter ( (Monom (k1, n1)) -> n1 /= n) xs\r\n\r\n			mainMonom = sumAppropriateMonom (Monom (k, n)) (foldr ( x res -> sumAppropriateMonom x res) (Monom (0, n)) h) -- here n2 = n3 = n\r\n\r\n		in\r\n\r\n			Polynom (mainMonom : t)\r\n\r\n	(Polynom xs) + (Polynom ys) = \r\n\r\n		foldr ( x res -> (Polynom [x]) + res) (Polynom ys) xs\r\n\r\n	(Polynom [Monom (k, n)]) * (Polynom xs) = \r\n\r\n		Polynom (foldr ( (Monom (k1, n1)) res -> Monom (k1 * k, n1 + n) : res) [] xs)\r\n\r\n	(Polynom xs) * (Polynom ys) = foldr ( x res -> (Polynom [x]) * (Polynom ys) + res) (Polynom []) xs\r\n\r\n\r\n\r\ninstance Eq Polynomial where\r\n\r\n	(Polynom xs) == (Polynom ys) = (length xs == length ys) && (foldr ( x res -> (elem x ys) && res) True xs)\r\n\r\n\r\n\r\ninstance Show Monomial where\r\n\r\n    show (Monom (k, n)) = show k ++ \" * X^\" ++ show n\r\n\r\n	\r\n\r\ninstance Show Polynomial where\r\n\r\n	show (Polynom (x:xs)) = show x ++ foldr (y res -> \" + \" ++ show y ++ res) [] xs\r\n\r\n	\r\n\r\n-- Polynom [Monom (1, 0)] + Polynom [Monom (2, 1), Monom (3, 2)] -- 1 * X^0 + 2 * X^1 + 3 * X^2\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] + Polynom [Monom (2, 1), Monom (3, 2)] -- 1 * X^0 + 5 * X^1 + 3 * X^2\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1), Monom (1, 2)] + Polynom [Monom (2, 2), Monom (3, 2), Monom (5, 3)]  -- 1 * X^0 + 3 * X^1 + 6 * X^2 + 5 * X^3\r\n\r\n-- Polynom [Monom (1, 0)] * Polynom [Monom (2, 1), Monom (3, 2)] -- 2 * X^1 + 3 * X^2\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] * Polynom [Monom (2, 1), Monom (3, 2)] -- 2 * X^1 + 9 * X^2 + 9 * X^3\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] == Polynom [Monom (1, 0), Monom (3, 1)] -- True\r\n\r\n-- Polynom [Monom (1, 0), Monom (3, 1)] == Polynom [Monom (1, 0), Monom (3, 2)] -- False','<br/>Тесты успешно пройдены!'),(7224,86,'ilia','2013-11-01 01:12:43',1,'   --- Я вам написал письмо, про то, с какого слайда я бы совестовал попробовать списать:) \r\nimport Debug.Trace\r\n\r\nimport Data.List\r\n\r\n\r\n\r\nallNondivisible xs =\r\n\r\n	all (x -> let\r\n\r\n			xxs = delete x xs\r\n\r\n		in all (xx -> mod x xx /= 0) xxs\r\n\r\n			&& allNondivisible xxs\r\n\r\n	) xs\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (allNondivisible [2, 7, 6, 5])\r\n\r\n	print (allNondivisible [4, 7, 6, 5])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7223,85,'artem.gomerman','2013-11-01 01:07:57',1,'--- В конце можно просто r1 < r2 = signum (r1 - r2) == (Rat (-1) 1)\r\ndata Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat n1 d1) + (Rat n2 d2) = let\r\n\r\n		newN = n1 * d2 + n2 * d1\r\n\r\n		newD = d1 * d2\r\n\r\n		reduction = gcd newN newD in (Rat (div newN reduction) (div newD reduction))\r\n\r\n	(Rat n1 d1) - (Rat n2 d2) = let\r\n\r\n		newN = n1 * d2 - n2 * d1\r\n\r\n		newD = d1 * d2\r\n\r\n		reduction = gcd newN newD in (Rat (div newN reduction) (div newD reduction))\r\n\r\n	(Rat n1 d1) * (Rat n2 d2) = let\r\n\r\n		newN = n1 * n2\r\n\r\n		newD = d1 * d2\r\n\r\n		reduction = gcd newN newD in (Rat (div newN reduction) (div newD reduction))\r\n\r\n	abs (Rat n d) = (Rat (abs n) (abs d))\r\n\r\n	signum (Rat n d) = (Rat (signum (n*d)) 1)\r\n\r\n	fromInteger i = (Rat (fromInteger i) 1)\r\n\r\n	\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat n d) = show n ++ \"/\" ++ show d\r\n\r\n	\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat n1 d1) == (Rat n2 d2) = n1 * d2 - n2 * d1 == 0\r\n\r\n	\r\n\r\ninstance Ord Ration where\r\n\r\n	r1 < r2 = if signum (r1 - r2) == (Rat (-1) 1) then True else False\r\n              ','<br/>Тесты успешно пройдены!'),(7222,136,'romos2007','2013-11-01 00:58:37',0,'{--\r\n\nЗадача 25-2\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\n{-\r\n\nПолином с целочисленными коэффициентами.\r\n\nОперации (+), (*), (==), show.\r\n\n\r\n\np.s. Мне было довольно лень писать хорошую функцию show для многочлена :( Поэтому она работает не очень красиво.\r\n\nХотя, по-моему, отображение многочлена в виде обычного массива чисел вполне сносно выглядит и без X-ов и степеней.\r\n\n-}\r\n\n\r\n\ndata Polynom = P [Int]\r\n\n\r\n\ninstance Num (Polynom) where\r\n\n	(P p1) + (P p2) = P (add p1 p2)\r\n\n	(P p1) * (P p2) = P (delNull (multPoly (p1) (p2)))\r\n\n\r\n\ninstance Eq (Polynom) where\r\n\n	(P p1) == (P p2) = let\r\n\n						lp1 = length p1\r\n\n						lp2 = length p2\r\n\n					  in\r\n\n					  	if lp1 < lp2\r\n\n					  	then (p1++[x|x<-(map (const 0) [1..(lp2-lp1)])]) == p2\r\n\n					  	else p1 == (p2 ++ [x|x<-(map (const 0) [1..(lp1-lp2)])])\r\n\n\r\n\ninstance Show (Polynom) where\r\n\n	show (P p) = showPoly p\r\n\n	--show (P p) = show p\r\n\n\r\n\n\r\n\n----------------------------------------------\r\n\n--Удалить незначащие нули при старших степенях\r\n\ndelNull [] = []\r\n\ndelNull xs = if (last xs == 0) then delNull (init xs) else xs\r\n\n\r\n\n-- Сложение двух многочленов в терминах массивов\r\n\nadd p1 p2 = let\r\n\n				lp1 = length p1\r\n\n				lp2 = length p2\r\n\n			in\r\n\n			  	if lp1 < lp2\r\n\n			  	then (delNull (zipWith (+) (p1 ++ repeat 0) p2))\r\n\n			  	else (delNull (zipWith (+) p1 (p2 ++ repeat 0)))\r\n\n\r\n\n\r\n\n-- Реализация умножения двух многочленов в терминах массивов\r\n\n---- умножение на число\r\n\nmultByNum num p = map (*num) (delNull p)\r\n\n\r\n\n---- умножение на X\r\n\nmultByX p = delNull (0:p)\r\n\n\r\n\n---- непосредственно умножение двух многочленов\r\n\nmultPoly [] p2 = []\r\n\nmultPoly (p:p1) p2 = let\r\n\n						pp2 = multByNum p p2\r\n\n						xpp2 = multByX (multPoly p1 p2)\r\n\n                     in add pp2 xpp2\r\n\n\r\n\n-- Процедура отображения многочлена\r\n\nshowPoly p =let\r\n\n				--делаем пары (коэффициент,степень) для нашего многочлена. Только ненулевые коэффициенты.\r\n\n				coeff = filter ((x_i,i)->x_i/=0) (zip (delNull p) [0..])\r\n\n				--отображение коэффициента при X\r\n\n				showCoeff c = if c == 1 then \"\" else show c\r\n\n				--отображение степени X\r\n\n				showXPow pow = if pow == 0\r\n\n                				then \"\"\r\n\n                				else\r\n\n	                				if pow == 1\r\n\n            						then \"x\"\r\n\n            						else \"x^\" ++ show pow\r\n\n\r\n\n				--отображение целиком всего многочлена\r\n\n				revCoeff = reverse coeff\r\n\n				initRevCoeff = init revCoeff\r\n\n				lastRevCoeff = last revCoeff\r\n\n			in	foldr ((x_i,i) e->show x_i ++\"x^\"++show i++\" + \" ++ e) \"\" initRevCoeff ++ show (fst lastRevCoeff) ++\"x^\"++show (snd lastRevCoeff)\n','<br/>Тесты успешно пройдены!'),(7218,135,'8519021','2013-11-01 00:16:35',1,'superMap f xs = concatMap f xs\r\n   --- или можно просто superMap = concatMap  :)\r\n','<br/>Тесты успешно пройдены!'),(7219,77,'nomeansno','2013-11-01 00:23:52',1,'f\' (x,y) = (f x y,y)\r\n        where f x y = if (x*x > y) then x-1 else f (x+1) y\r\nsqrt2 = map (x->x `mod` 10) s\r\n        where s = [x | (x,y)<-g\']\r\n                where g\' = (1,2):[f\' (x*10,y*100) | (x,y)<-g\']','<br/>Тесты успешно пройдены!'),(7220,79,'2156724','2013-11-01 00:46:46',2,'   --- На самом деле у вас не совсем по условию. Тут надо вводить число n и вызывать генератор для него.\r\n   --- Я не сомневаюсь, то вы это можете, но добавьте это, пожалуста, раз такое условие.\r\n   --- И потом, у меня ваш код не компилируется, есть одна синтаксическая ошибка. А у вас компилируется?\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace digits\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable digits(int n)\r\n        {\r\n            for (int i = 0, d = 1; ; i++, d = d*10)\r\n            {\r\n                    double digit = Math.Truncate((double)d / n);\r\n                    yield return digit;\r\n                    d = d - (int) digit * n;\r\n            }\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (double x in digits(7).Take(100))\r\n            {\r\n                Console.Write(x + \" \"); \r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7221,83,'2156724','2013-11-01 00:53:35',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace Lst137\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Geom()\r\n        {\r\n            yield return 1;\r\n            yield return 3;\r\n            yield return 7;\r\n            foreach (int i in Geom())\r\n            {\r\n                yield return 10 * i + 1;\r\n                yield return 10 * i + 3;\r\n                yield return 10 * i + 7;\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (int x in Geom().Take(20)){\r\n                Console.Write(x + \"  \");\r\n\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7216,93,'2156724','2013-11-01 00:01:01',2,'-- Не правильно понял условие задачи, буду переделывать, мои решения можно не смотреть.\r\n\r\n--- ОК) (На самом деле интерфейс преподавателя так устроен, что я и не могу увидеть никакие решения кроме последнего.)','Не удалось вычислить выражение \"take 10 ham\", проверьте правильность синтаксиса'),(7217,83,'8519021','2013-11-01 00:04:10',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Lst137\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                yield return i * 10 + 1;\r\n\r\n                yield return i * 10 + 3;\r\n\r\n                yield return i * 10 + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (int i in Lst137().Take(15))\r\n\r\n            {\r\n\r\n                Console.Write(i + \" \");\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7215,93,'2156724','2013-10-31 23:58:07',0,'-- Честно признаюсь, эту идею я услышал у своего одногруппника,\r\n--   засчитывать или нет - решать вам, по другому я пока не придумал как решить\r\n-- если подскажете как можно сделать по другому я перерешаю.\r\n\r\nmerge [] [] = []\r\nmerge [] (y:ys) = y:ys\r\nmerge (x:xs) [] = x:xs\r\nmerge (x:xs) (y:ys) =\r\n    if x > y then y : merge (x:xs) ys\r\n    else\r\n      if x < y then x : merge xs (y:ys)\r\n      else x : merge xs ys\r\n\r\n\r\nst3 = 1 : map (*3) st3\r\nst10 = 10 : map (*10) st10\r\n\r\nham = merge st3 st10','Выражение имеет неправильное значение: take 10 ham'),(7214,136,'115753099','2013-10-31 23:58:01',0,'import Data.List\n\ninstance Num Polinom where\n\n	(Polinom xs) + (Polinom ys) =\n\n		Polinom (reverse list)\n\n		where\n\n			list = doListSum (reverse xs) (reverse ys)\n\n			doListSum [] js = js\n\n			doListSum is [] = is\n\n			doListSum (i:is) (j:js) = (i + j) : doListSum is js\n\n	(Polinom xs) * (Polinom ys) =\n\n		Polinom list\n\n		where\n\n			resultLen = (length xs + length ys - 1)\n\n			doDoList list len = mapAccumL (curLevel x -> ( curLevel+1 , (emptyList curLevel) ++ x ++ (emptyList (len - (length x) - curLevel)))) 0 list\n\n			emptyList len\n\n				| len == 0 = []\n\n				| otherwise = 0 : emptyList (len - 1)\n\n			(list, _) = mapAccumL (l z -> (zipWith (+) l z, z) ) (emptyList (resultLen)) temp2\n\n			(_, temp2) = (doDoList temp (resultLen))\n\n			temp = map (x -> fst (mapAccumL (acc y -> ((acc ++ [x*y]), y)) [] ys)) xs\n\n	abs _ = Polinom []\n\n	signum _ = Polinom []\n\n	fromInteger _ = Polinom []\n\ninstance Show Polinom where\n\n	show (Polinom l) = \n\n		\"result: \" ++ show (result (reverse l) 0)\n\n		where\n\n			result [] powe = \"\"\n\n			result (i:li) powe\n\n				| powe == 0 = show i ++ (result li (powe+1))\n\n				| otherwise = \" + \" ++ show i ++ \"*x^\" ++ (show powe) ++ (result li (powe+1))\n\ninstance Eq Polinom where\n\n	Polinom xs == Polinom ys =\n\n		xs == ys\n\n\n\n\n\n\n\n\n','<br/>Тесты успешно пройдены!'),(7210,86,'2156724','2013-10-31 23:40:50',2,'А где можно прочитать про этот прием? не могу понять его.\r\n  --- не знаю, где-то я про него прочел, конечно, но ссылку так сразу не могу дать.\r\n  --- Так а слайды вы смотрели? Надо взять программу на слайде 19 и попробовать ее переделать.\r\n  --- Или вы видели слайд 19, но непонятно, что там написано? Если так, мб выможете написать\r\n  --- какие-нибудь более-менее конткретые вопросы? Это было бы замечательно.','Не удалось вычислить выражение \"allNondivisible [2, 7, 6, 5]\", проверьте правильность синтаксиса'),(7211,85,'ilia','2013-10-31 23:42:21',0,'data Ration = Rat Integer Integer\n\n\n\ninstance Eq Ration where\n\n	Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\n\n\n\ninstance Ord Ration where\n\n	Rat x1 y1 < Rat x2 y2 = x1 * y2 < x2 * y1\n\n\n\ninstance Num Ration where\n\n	Rat x1 y1 + Rat x2 y2 = Rat (x1 * y2 + x2 * y1) (y1 * y2)\n\n\n\ninstance Show Ration where\n\n	show (Rat x y) = show x ++ \"/\" ++ show y\n\n\n\nmain = do\n\n	print (Rat 1 2 + Rat 1 7)\n\n	print (Rat 1 3 < Rat 4 5)\n\n\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7212,85,'ilia','2013-10-31 23:48:05',1,'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n	Rat x1 y1 == Rat x2 y2 = x1 * y2 == x2 * y1\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	Rat x1 y1 < Rat x2 y2\r\n\r\n		| y1 * y2 > 0 = x1 * y2 < x2 * y1\r\n\r\n		| otherwise = x1 * y2 > x2 * y1\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	Rat x1 y1 + Rat x2 y2 = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat x y) = show x ++ \"/\" ++ show y\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (Rat 1 2 + Rat 1 7)\r\n\r\n	print (Rat 1 3 < Rat 4 5)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7213,100,'115753099','2013-10-31 23:57:22',1,'allDiffLists n k = allDiffLists\' n k [] (const True)\r\n\r\nallDiffLists\' n 0 _ _ = [[]]\r\nallDiffLists\' n k s fu = [x:xs | x<-[1..n], (fu x), xs <- allDiffLists\' n (k-1) (x:s) (y -> fu y && y /= x)]\r\n\r\n---25.2\r\ndata Polinom = Polinom [Int]','<br/>Тесты успешно пройдены!'),(7207,85,'2156724','2013-10-31 23:37:46',1,'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\nsign a b = if a*b < 0 then -1\r\n\r\n           else 1\r\n\r\n\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat a1 b1) =  show a1 ++ \"/\" ++ show b1\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n   (Rat a1 b1) + (Rat a2 b2) =  Rat ((sign a1 b1) * abs(a1*b2) + \r\n\r\n			(sign a2 b2)*abs(b1*a2)) (abs(b1*b2))\r\n\r\n\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n   (Rat a1 b1) < (Rat a2 b2) = ((sign a1 b1) * abs(a1*b2) - (sign a2 b2)*abs(b1*a2)) < 0\r\n\r\n       \r\n\r\ninstance Eq Ration where\r\n\r\n   (Rat a1 b1) == (Rat a2 b2) = ((sign a1 b1) * abs(a1*b2) - (sign a2 b2)*abs(b1*a2)) == 0\r\n\r\n    \r\n\r\n   	\r\n','<br/>Тесты успешно пройдены!'),(7208,135,'2156724','2013-10-31 23:39:25',1,'superMap f [] = []\r\n\r\nsuperMap f (x:xs) = f x ++ superMap f xs \r\n','<br/>Тесты успешно пройдены!'),(7209,90,'2156724','2013-10-31 23:40:02',1,'quicksort [] = []\r\n\r\nquicksort (x:xs) = quicksort small ++ (x : quicksort large)\r\n\r\n  where small = [y | y <- xs, y <= x]\r\n\r\n        large = [y | y <- xs, y > x]\r\n\r\nfindSame (x:xs) = findSame\' (quicksort (x:xs))\r\n   --- ОК, но нак не очень хорошо, потому что ваш код будет работать только если мы умеетм сравнивать\r\n   --- элементы списка. Те мы сужаем область значентя, для которой findSame работает.\r\n\r\nfindSame\' [x] = [(x, False)]\r\n\r\nfindSame\' (x:y:xs) = \r\n\r\n         if (x==y) then (x, True) : findSame (filter (\r\n -> not(n == x)) xs)\r\n                          else (x, False) : findSame (y:xs)\r\n','<br/>Тесты успешно пройдены!'),(7206,80,'8519021','2013-10-31 23:28:08',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Cantor\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<KeyValuePair<int, int>> Cantor()\r\n\r\n        {\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                for (int j = 1; j <= i; j++)\r\n\r\n                {\r\n\r\n                    yield return (new KeyValuePair<int, int>(j, i - j + 1));\r\n\r\n                }                \r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            foreach (KeyValuePair<int, int> pair in Cantor().Take(10))\r\n\r\n            {\r\n\r\n                Console.Write(\" (\" + pair.Key + \",\" + pair.Value + \") \");\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7205,76,'ilia','2013-10-31 23:24:42',1,'class Shape s where\r\n\r\n	area:: s -> Double\r\n\r\n	perim:: s -> Double\r\n\r\n	contains:: s -> Double -> Double -> Bool\r\n\r\n\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n\r\n	area (Circle r _ _) = 3.14 * r * r\r\n\r\n	perim (Circle r _ _) = 2 * 3.14 * r\r\n\r\n	contains (Circle r ox oy) ax ay = let\r\n\r\n			aox = ax - ox\r\n\r\n			aoy = ay - oy \r\n\r\n		in r >= sqrt (aox * aox + aoy * aoy)\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where\r\n\r\n	area (Rect x y _ _) = x * y\r\n\r\n	perim (Rect x y _ _) = 2 * (x + y)\r\n\r\n	contains (Rect x y ox oy) ax ay = let\r\n\r\n			x2 = x / 2\r\n\r\n			y2 = y / 2\r\n\r\n		in ax >= ox - x2 && ax <= ox + x2 && ay >= oy - y2 && ay <= oy + y2\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (contains (Circle 10 0 0) 6 5)\r\n\r\n	print (contains (Rect 6 8 0 0) 5 5)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7204,85,'2156724','2013-10-31 23:14:46',0,'data Ration = Rat Integer Integer\r\n\n\r\n\ninstance Show Ration where\r\n\n    show (Rat a1 b1) =  show a1 ++ \"/\" ++ show b1\r\n\n   \r\n\n\r\n\ninstance Num Ration where\r\n\n   (Rat a1 b1) + (Rat a2 b2) = Rat (a1 *b2 + b1*a2) (b1*b2)\r\n\n\r\n\ninstance Ord Ration where\r\n\n   (Rat a1 b1) < (Rat a2 b2) = ((a1*b2 - b1 * a2) < 0)\r\n\n       \r\n\ninstance Eq Ration where\r\n\n   (Rat a1 b1) == (Rat a2 b2) = ((a1*b2 - b1 * a2) == 0)\r\n\n    \r\n\n   	\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7203,85,'2156724','2013-10-31 23:13:18',0,'data Ration = Rat Double Double\r\n\n\r\n\ninstance Show Ration where\r\n\n    show (Rat a1 b1) =  show a1 ++ \"/\" ++ show b1\r\n\n   \r\n\n\r\n\ninstance Num Ration where\r\n\n   (Rat a1 b1) + (Rat a2 b2) = Rat (a1 *b2 + b1*a2) (b1*b2)\r\n\n\r\n\ninstance Ord Ration where\r\n\n   (Rat a1 b1) < (Rat a2 b2) = ((a1*b2 - b1 * a2) < 0)\r\n\n       \r\n\ninstance Eq Ration where\r\n\n   (Rat a1 b1) == (Rat a2 b2) = ((a1*b2 - b1 * a2) == 0)\r\n\n    \r\n\n   	\n','Выражение имеет неправильное значение: Rat 1 2 + Rat 1 7'),(7202,76,'2156724','2013-10-31 23:12:47',1,'class Shape a where\r\n\r\n   area:: a -> Double\r\n\r\n   perim:: a -> Double\r\n\r\n   contains:: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\n\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n  	area (Rect x y a b) = x*y\r\n\r\n  	perim (Rect x y a b) = 2*(x+y)\r\n\r\n	contains (Rect x y a b) x1 y1 = (x1 < (a + x/2)) && (x1 > a - x/2) && \r\n\r\n						(y1 > b - y/2) && (y1 < b + y/2) &&\r\n\r\n					(x1 < (b + x/2)) && (x1 > b - x/2) && \r\n\r\n						(y1 > a - y/2) && (y1 < a + y/2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n  	area (Circle r x y) = 3.14*r*r\r\n\r\n  	perim (Circle r x y) = 3.14*r*r\r\n\r\n	contains (Circle r x y) x1 y1 = (x1 - x) ^ 2 + (y1 - y)^2 < r^2 \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7200,78,'nomeansno','2013-10-31 22:04:54',0,'let pascal = [1]:[1:(zipWith (+) s (tail s)) ++ [1] | s<-pascal]','Не удалось вычислить выражение \"take 6 pascal\", проверьте правильность синтаксиса'),(7201,78,'nomeansno','2013-10-31 22:05:27',1,'pascal = [1]:[1:(zipWith (+) s (tail s)) ++ [1] | s<-pascal]','<br/>Тесты успешно пройдены!'),(7199,100,'deripaska','2013-10-31 21:57:08',1,'{--\r\n\r\n	task 25-01\r\n\r\nОписать функцию allDiffLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\n\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nallDiffLists 3 2\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\r\n\r\n\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\n--}\r\n\r\n\r\n\r\nallDiffLists n k = allDiffLists_help n k (const True)\r\n\r\n\r\n\r\nallDiffLists_help _ 0 _ = [[]]	\r\n\r\nallDiffLists_help n k cond = [(x : xs) | x <- [1..n], cond x, xs <- allDiffLists_help n (k - 1) (	 -> cond t && (t /= x))]\r\n','<br/>Тесты успешно пройдены!'),(7198,100,'romos2007','2013-10-31 21:54:05',1,'{--\r\n\r\nЗадача 25-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nallLists\' n k used = [(x:xs)| 	x<-[1..n],\r\n\r\n								not (used x),\r\n\r\n								xs <- 	if (k>1)\r\n\r\n										then allLists\' n (k-1) (	 -> used t || t == x)\r\n\r\n										else [[]]\r\n\r\n					]\r\n\r\nallDiffLists n k = allLists\' n k (const False)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7197,89,'romos2007','2013-10-31 21:42:03',1,'{--\r\n\r\nЗадача 24-6\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Empty \r\n\r\n			| Node Int Tree Tree\r\n\r\n\r\n\r\n--Первая версия, пришедшая мне в голову.\r\n\r\nflatten t = f t []\r\n\r\nf Empty = id\r\n\r\nf (Node x l r) = (x:).(f l).(f r)\r\n  --- ОК, очень хорошо, я тоже бы так написал. Мне так кажется понятнее всего.\r\n\r\n\r\n-- Вторая версия. С использованием написанной нами ранее foldTree.\r\n\r\nfoldTree f e (Node val l r) = f val (foldTree f e l) (foldTree f e r)\r\n\r\nfoldTree f e Empty = e\r\n\r\n			\r\n\r\nflatten1 t = foldTree (x l r -> (x:).(l).(r)) id t []\r\n','<br/>Тесты успешно пройдены!'),(7196,90,'romos2007','2013-10-31 21:41:38',1,' --- C одной стороны, идея сортировать - очень хорошая. Но с другой стороны, так мы сможем вызывать\r\n --- функцию только для типов, которые можно сравнивать, те вы немного сузили область.\r\n{--\r\n\r\nЗадача 24-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\nИдея: сортируем, а потом сравниваем каждую пару подряд идущих чисел.\r\n\r\n-}\r\n\r\nimport Data.List\r\n\r\n\r\n\r\nfindSame [] = \"Nothing to compare: empty input list.\"\r\n\r\nfindSame xs = fs (sort xs)\r\n\r\n\r\n\r\nfs (x:y:xs) = 	if (x==y)\r\n\r\n				then \"Repeatable value found: \" ++ show x\r\n\r\n				else \r\n\r\n					if (xs /= [])\r\n\r\n					then fs (y:xs)\r\n\r\n					else \"All elements are unique\"\r\n','<br/>Тесты успешно пройдены!'),(7195,86,'romos2007','2013-10-31 21:41:21',1,'{--\r\n\r\nЗадача 24-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nallNondivisible xs = allNondiv xs (const True)\r\n\r\nallNondiv [] f = True\r\n\r\nallNondiv (x:xs) f = 	if (f x)\r\n\r\n						then\r\n\r\n							allNondiv xs (	 -> f t && (x `mod` t /= 0) && (t `mod` x /= 0))\r\n\r\n						else\r\n\r\n							False\r\n','<br/>Тесты успешно пройдены!'),(7194,82,'2156724','2013-10-31 21:02:07',1,'countDifferentVars [][] = 0\r\n\r\n\r\n\r\ncountDifferentVars ((x,y) : xs)[] = 0\r\n\r\n\r\n\r\ncountDifferentVars [] (z:ys) = length (z:ys)\r\n\r\ncountDifferentVars ((x,y) : xs) (z:ys) = length  (countDifferentVars\' ((x,y) : xs) (z:ys))\r\n\r\n\r\n\r\n\r\n\r\nmyMap ((x,y):xs) = map ((m,n) -> if (m == y) then (x,n)\r\n\r\n                                  else if (n == y) then (m,x)\r\n\r\n                                  else (m, n)) xs\r\n\r\n\r\n\r\ncountDifferentVars\' [] (z:ys) = (z:ys) \r\n\r\n\r\n\r\ncountDifferentVars\' ((x,y) : xs) (z:ys) = \r\n\r\n    (countDifferentVars\' (myMap ((x,y):xs)) \r\n\r\n                       ( x:(filter (\r\n -> not (x == n || y == n)) (z:ys)))) \r\n','<br/>Тесты успешно пройдены!'),(7193,82,'2156724','2013-10-31 21:00:27',0,'countDifferentVars [] (z:ys) = length (z:ys)\r\n\ncountDifferentVars ((x,y) : xs) (z:ys) = length  (countDifferentVars\' ((x,y) : xs) (z:ys))\r\n\n\r\n\n\r\n\nmyMap ((x,y):xs) = map ((m,n) -> if (m == y) then (x,n)\r\n\n                                  else if (n == y) then (m,x)\r\n\n                                  else (m, n)) xs\r\n\n\r\n\ncountDifferentVars\' [] (z:ys) = (z:ys) \r\n\n\r\n\ncountDifferentVars\' ((x,y) : xs) (z:ys) = \r\n\n    (countDifferentVars\' (myMap ((x,y):xs)) \r\n\n                       ( x:(filter (\n -> not (x == n || y == n)) (z:ys)))) \n','Не удалось вычислить выражение \"countDifferentVars [(1,2),(2,3), (4,5)] []\", проверьте правильность синтаксиса'),(7192,82,'2156724','2013-10-31 20:58:56',0,'\r\n\ncountDifferentVars ((x,y) : xs) (z:ys) = length  (countDifferentVars\' ((x,y) : xs) (z:ys))\r\n\n\r\n\n\r\n\nmyMap ((x,y):xs) = map ((m,n) -> if (m == y) then (x,n)\r\n\n                                  else if (n == y) then (m,x)\r\n\n                                  else (m, n)) xs\r\n\n\r\n\ncountDifferentVars\' [] (z:ys) = (z:ys) \r\n\n\r\n\ncountDifferentVars\' ((x,y) : xs) (z:ys) = \r\n\n    (countDifferentVars\' (myMap ((x,y):xs)) \r\n\n                       ( x:(filter (\n -> not (x == n || y == n)) (z:ys)))) \n','Не удалось вычислить выражение \"countDifferentVars [] [1,2,3]\", проверьте правильность синтаксиса'),(7191,79,'2156724','2013-10-31 19:11:43',0,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace digits\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> digits(int n)\r\n        {\r\n            for (int i = 0, d = 1; ; i++, d = d*10)\r\n            {\r\n                    double digit = Math.Truncate((double)d / n);\r\n                    yield return digit;\r\n                    d = d - (int) digit * n;\r\n            }\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (double x in digits(7).Take(100))\r\n            {\r\n                Console.Write(x + \" \"); \r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7190,89,'deripaska','2013-10-31 18:05:43',1,'{--\r\n\r\n	task 24-06\r\n\r\nОпишите функцию flatten, которая для данного дерева возвращает список из всех значений, записанных в вершинах дерева.\r\n\r\n\r\n\r\nПожелание: \r\n\r\nБыло бы замечательно, если бы вы написали реализацию flatten, которая не использует операцию ++. Потому что ++, как мы знаем, работает медленно и flatten получится неэффективным. Но, если не придумаете, подойдет любая реализация, и с использованием ++.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\nflatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\n\r\n\r\nДолжно получиться\r\n\r\n\r\n\r\n[1,2,3] \r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Node Integer Tree Tree | Empty\r\n\r\nflatten tree = flatten_help tree []\r\n\r\n\r\n\r\nflatten_help Empty res = res \r\n\r\nflatten_help (Node val left right) res = val : (flatten_help left (flatten_help right res))\r\n','<br/>Тесты успешно пройдены!'),(7189,90,'deripaska','2013-10-31 17:57:18',1,'{--\r\n\r\n	task 24-05\r\n\r\nПусть нас попросили написать функцию findSame, которая для данного списка возвращает элемент, который в нем встречается больше одного раза. Например, для [1,2,3,2,5] надо вернуть 2.\r\n\r\n\r\n\r\nМы, естественно, просим уточнить:\r\n\r\n- Что делать, если таких элементов несколько?\r\n\r\n- Что делать, если таких элементов вообще нет?\r\n\r\n\r\n\r\nА нам сказали:\r\n\r\n- Если из несколько, можно вернуть любой.\r\n\r\n- Если вообще нет таких элементов - ну, нам сказали, придумайте что-нибудь.. Подойдет любое решение, но надо, чтобы пользователь мог понять, нашлось что-то или нет.\r\n\r\n\r\n\r\nЗадача: придумать интерфейс для findSame и реализовать эту функцию.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nfindSame [1,2,3,2,5]\r\n\r\n\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должно быть число 2 и еще м.б. какая-то дополнительная информация.\r\n\r\n\r\n\r\nfindSame [1,3,2,5]\r\n\r\n\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должна быть какая-то информация о том, что мы ничего не нашли.\r\n\r\n--}\r\n\r\n\r\n\r\n-- first, with error message\r\n\r\nfindSame xs = findSame_help xs (const False)\r\n\r\nfindSame_help [] cond = error (\"This element not found\")\r\n\r\nfindSame_help (x:xs) cond =\r\n\r\n	if cond x then x\r\n\r\n	else findSame_help xs (	 -> cond t || (t == x))\r\n\r\n--}\r\n\r\n\r\n\r\n{-- second, with result type\r\n\r\ndata FunctionResult a = Element a | NotFound deriving (Show, Eq)\r\n\r\n	\r\n\r\nfindSame xs = \r\n\r\n	let result = findSame_help xs (const False)\r\n\r\n	in if (result == NotFound) then \"This element not found\" else show (result)\r\n\r\n\r\n\r\nfindSame_help [] cond = NotFound\r\n\r\nfindSame_help (x:xs) cond =\r\n\r\n	if cond x then Element x\r\n\r\n	else findSame_help xs (	 -> cond t || (t == x))\r\n\r\n--}\r\n','<br/>Тесты успешно пройдены!'),(7188,78,'1170660','2013-10-31 17:15:01',1,'pascal = [1]:(zipWith (xs ys -> 1 : zipWith (+) xs (tail ys ++ [0])) pascal pascal)','<br/>Тесты успешно пройдены!'),(7187,135,'deripaska','2013-10-31 16:58:50',1,'{--\r\n\r\n	task 24-04\r\n\r\nsuperMap\r\n\r\n\r\n\r\nОписать функцию superMap, похожую на map, но только она умеет заменять один элемент на несколько.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\nsuperMap (x -> [x*x, 100*x]) [1,2,3]\r\n\r\n\r\n\r\nОтвет должен быть равен [1, 100, 4, 200, 9, 300].\r\n\r\n--}\r\n\r\n\r\n\r\nsuperMap f [] = []\r\n\r\nsuperMap f (x:xs) = f x ++ superMap f xs\r\n','<br/>Тесты успешно пройдены!'),(7186,86,'deripaska','2013-10-31 16:52:58',1,'{--\r\n\r\n	task 24-03\r\n\r\nОпределить функцию allNondivisible, которая проверяет, верно ли что в данном списке нет двух элементов, таких, что один делится на другой.\r\n\r\n\r\n\r\nДополнительное условие: В этой задаче, пожалуйста, обязательно используйте прием с представлением множества с помощью логической функции, который мы разбирали на занятии.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nallNondivisible [2, 7, 6, 5]\r\n\r\n\r\n\r\nРезультат должен быть равен False, потому что 6 делится на 2\r\n\r\n\r\n\r\nallNondivisible [4, 7, 6, 5]\r\n\r\n\r\n\r\nРезультат должен быть равен True, потому что ни одно число в списке не делится на другое.\r\n\r\n--}\r\n\r\n\r\n\r\nallNondivisible xs = allNondivisible_help xs (const True)\r\n\r\n\r\n\r\nallNondivisible_help [] _ = True\r\n\r\nallNondivisible_help (x:xs) cond =\r\n\r\n	if not (cond x) then False \r\n\r\n	else allNondivisible_help xs (	 -> cond t && (mod t x /= 0) && (mod x t /= 0))\r\n','<br/>Тесты успешно пройдены!'),(7185,85,'deripaska','2013-10-31 16:44:26',1,'{--\r\n\r\n	task 24-02\r\n\r\nОпределите тип Ration для представления дробей. Конструктор этого типа должен записываться так: Rat <числитель> <знаменатель>.\r\n\r\nДля этого типа: \r\n\r\na. Определите оператор + (сложение дробей)\r\n\r\nb. Определите оператор < (сравнение дробей)\r\n\r\nc. Определите функцию show, которая генерирует строковое представление дроби в формате <числитель>/<знаменатель> \r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\nRat 1 2 + Rat 1 7\r\n\r\n\r\n\r\nДолжно быть напечатано\r\n\r\n\r\n\r\n9/14\r\n\r\n\r\n\r\n(потому что при выводе автоматически вызовется show) \r\n\r\n\r\n\r\nRat 1 3 < Rat 4 5\r\n\r\n\r\n\r\nРезультат должен быть равен True\r\n\r\n--}\r\n\r\n\r\n\r\ndata Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat i1 j1) + (Rat i2 j2) = \r\n\r\n		let \r\n\r\n			numerator = i1 * j2 + i2 * j1\r\n\r\n			denominator = j1 * j2\r\n\r\n			nod = gcd numerator denominator\r\n\r\n		in Rat (div numerator nod) (div denominator nod)\r\n\r\n\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat i1 j1) < (Rat i2 j2) = \r\n\r\n		if (j1 * j2 > 0) then i1 * j2 < i2 * j1\r\n\r\n		else i1 * j2 > i2 * j1\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat i1 j1) == (Rat i2 j2) = (i1 * j2 == i2 * j1)\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n	show (Rat i j) = show i ++ \"/\" ++ show j\r\n','<br/>Тесты успешно пройдены!'),(7184,76,'deripaska','2013-10-31 16:10:32',1,'{--\r\n\r\n	task 24-01\r\n\r\nОпишите класс Shape и типы Circle и Rect, как мы это делали на занятии. \r\n\r\n\r\n\r\nа. Добавьте в оба типа еще два вещественных поля -координаты центра фигуры.\r\n\r\n\r\n\r\nб. Добавьте в Shape функцию contains c двумя вещественными параметрами, которая проверяет, принадлежит ли точка с данными координатами фигуре, и возвращает True или False. Напишите определение этой функции для Circle и Rect.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\ncontains (Circle 10 0 0) 6 5\r\n\r\n\r\n\r\nОтвет должен быть True, потому что точка с координатами 6 5 принадлежит кругу радиуса 10 с центром 1 2.\r\n\r\n\r\n\r\ncontains (Rect 6 8 0 0) 5 5\r\n\r\n\r\n\r\nОтвет должен быть равен False, потому что точка 5 5 не принадлежит прямоугольнику со сторонами 6 и 8 и центром 0 0. \r\n\r\n--}\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a  where\r\n\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\n	\r\n\r\ninstance Shape Rect where\r\n\r\n	contains (Rect h w cx cy) x y =\r\n\r\n		let \r\n\r\n				halfWidth = w / 2\r\n\r\n				halfHeight = h / 2\r\n\r\n				left = cx - halfWidth\r\n\r\n				right = cx + halfWidth\r\n\r\n				top = cy + halfHeight\r\n\r\n				bottom = cy - halfHeight\r\n\r\n			in (x <= right) && (x >= left) && (y <= top) && (y >= bottom)\r\n\r\n	\r\n\r\ninstance Shape Circle where\r\n\r\n	contains (Circle r cx cy) x y =\r\n\r\n		let \r\n\r\n			distX = cx - x\r\n\r\n			distY = cy - y\r\n\r\n		in (distX * distX + distY * distY) <= r * r\r\n','<br/>Тесты успешно пройдены!'),(7181,78,'nbumakov','2013-10-31 15:13:51',1,'pascal = [1]:map (p-> zipWith (+) (p ++ [0]) (0:p)) pascal','<br/>Тесты успешно пройдены!'),(7182,78,'Artur','2013-10-31 15:33:30',1,'pascal = [1] : (map (xs -> zipWith (+) (0:xs) (xs++[0])) pascal)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7183,76,'artem.gomerman','2013-10-31 16:10:16',1,'class Shape a where\r\n\r\n	area:: a -> Double\r\n\r\n	perim:: a -> Double\r\n\r\n	contains:: a -> Double -> Double -> Bool\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n	\r\n\r\ninstance Shape Rect where\r\n\r\n	area (Rect x y cX cY) = x*y\r\n\r\n	perim (Rect x y cX cY) = 2*(x+y)\r\n\r\n	contains (Rect x y cX cY) pX pY = let\r\n\r\n		halfWidth = x / 2\r\n\r\n		halfHeight = y / 2 in cX <= pX - halfWidth && pX <= cX + halfWidth && cY <= pY - halfHeight && pY <= cY + halfHeight\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	area (Circle r cX cY) = 3.14*r*r\r\n\r\n	perim (Circle r cX cY) = 2*3.14*r\r\n\r\n	contains (Circle r cX cY) pX pY = (cX - pX)^2 + (cY - pY)^2 <= r^2\r\n\r\n	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7180,83,'Artur','2013-10-31 14:53:18',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace generator\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1 ;\r\n\r\n            yield return 3 ;\r\n\r\n            yield return 7 ;\r\n\r\n            foreach (int a in Lst137())\r\n\r\n            {\r\n\r\n                yield return a*10 + 1 ;\r\n\r\n                yield return a*10 + 3 ;\r\n\r\n                yield return a*10 + 7 ;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int num = 100;\r\n\r\n            //рассмотрим первые num элементов\r\n\r\n            int i = 1; \r\n\r\n           foreach(int a in Lst137() )\r\n\r\n           {\r\n\r\n               Console.WriteLine(a) ;\r\n\r\n               i++;\r\n\r\n               if (i > num)\r\n\r\n                   break;\r\n\r\n           }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7179,80,'Artur','2013-10-31 14:36:41',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace generator\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n       public static IEnumerable<int[] > cantor()\r\n\r\n        {\r\n\r\n            Func<int, int> sumN = y => Convert.ToInt32(y * (y + 1) / 2);\r\n\r\n            Func<int, int[]> f = k =>\r\n\r\n            {\r\n\r\n                int sum, i = 0;\r\n\r\n                while (sumN(i + 1) < k) i++;\r\n\r\n                sum = sumN(i);\r\n\r\n                int[] ans = { i + 2 - (k - sum), k - sum };\r\n\r\n                return ans;\r\n\r\n            };\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                yield return f(i) ;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int num = 100;\r\n\r\n            //рассмотрим первые num элементов\r\n\r\n            int i = 1; \r\n\r\n           foreach(int[] ar in cantor() )\r\n\r\n           {\r\n\r\n               Console.WriteLine(ar[0] + \" \" + ar[1]) ;\r\n\r\n               i++;\r\n\r\n               if (i > num)\r\n\r\n                   break;\r\n\r\n           }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7178,77,'517309','2013-10-31 14:05:46',3,'sqrt2 = lst2 1\r\n\r\nlst2 k = mod (snd (l k)) 10 : lst2 (k+1)\r\n\r\nl 1 = (100,1)\r\nl (n+1) = let (f,s) = l n in h (2*s) f 9\r\n\r\nh x y 0 = (y*100,x*5)\r\nh x y l = if (x*10+l)*l <= y then \r\n     ((y - (x*10+l)*l)*100,(div x 2)*10+l)\r\n  else h x y (l-1)','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7177,77,'517309','2013-10-31 14:04:35',0,'sqrt2 = lst2 1\r\n\r\nlst2 k = mod (snd (l k)) 10 : lst2 (k+1)\r\n\r\nl 1 = (100,1)\r\nl (n+1) = (f,s) = l n in h (2*s) f 9\r\n\r\nh x y 0 = (y*100,x*5)\r\nh x y l = if (x*10+l)*l <= y then \r\n     ((y - (x*10+l)*l)*100,(div x 2)*10+l)\r\n  else h x y (l-1)','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7176,77,'517309','2013-10-31 14:03:30',0,'sqrt2 = lst2 1\r\n\r\nlst2 k = mod (snd (l k)) 10 : lst2 (k+1)\r\n\r\nl 1 = (100,1)\r\n\r\nl (n+1) = let xs = l n in h (2* (snd xs)) (fst xs) 9\r\n\r\nh x y 0 = (y*100,x*5)\r\nh x y l = if (x*10+l)*l <= y then \r\n     ((y - (x*10+l)*l)*100,(div x 2)*10+l)\r\n  else h x y (l-1)','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7174,77,'517309','2013-10-31 14:00:18',0,'sqrt2 = (lst2 1)\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nlst2 k = (snd (l k) `mod` 10) :(lst2 (k+1))\r\n\n\r\n\n\r\n\n\r\n\nl 1 = (100,1)\r\n\n\r\n\nl (n+1) = h (2* (snd xs)) (fst xs) 9 where xs = l n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nh x y 0 = (y*100,x*5)\r\n\n\r\n\nh x y l = if (x*10+l)*l <= y then ((y - (x*10+l)*l)*100,(x `div` 2)*10+l)\r\n\n\r\n\n			else h x y (l-1)\r\n\n\r\n\n\r\n\n\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7175,77,'517309','2013-10-31 14:01:39',0,'sqrt2 = (lst2 1)\r\n\r\nlst2 k = (mod (snd (l k)) 10) :(lst2 (k+1))\r\n\r\nl 1 = (100,1)\r\n\r\nl (n+1) = h (2* (snd xs)) (fst xs) 9 where xs = l n\r\n\r\nh x y 0 = (y*100,x*5)\r\n\r\nh x y l = if (x*10+l)*l <= y then ((y - (x*10+l)*l)*100,(div x 2)*10+l)\r\n\r\n			else h x y (l-1)','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7173,77,'517309','2013-10-31 13:58:36',0,'sqrt2 = (lst2 1)\r\n\r\n\r\n\r\n\r\n\r\nlst2 k = (snd (l k) `mod` 10) :(lst2 (k+1))\r\n\r\n\r\n\r\nl 1 = (100,1)\r\n\r\nl (n+1) = h (2* (snd xs)) (fst xs) 9 where xs = l n\r\n\r\n\r\n\r\n\r\n\r\nh x y 0 = (y*100,x*5)\r\n\r\nh x y l = if (x*10+l)*l <= y then ((y - (x*10+l)*l)*100,(x `div` 2)*10+l)\r\n\r\n			else h x y (l-1)\r\n\r\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7172,90,'1595828','2013-10-31 13:39:05',1,'data Res = Not_Found | Answer Integer  deriving (Show)\r\n  --- ОК, замечательно. Но, на самом деле, еще хамечательнее было бы написать\r\n  --- data Res a = Not_Found | Answer a и т.д. :) Тогда бы у вас все работало не только для чисел,\r\n  --- но и для чего угодно.\r\n\r\nfindSame\' [] _ _=Not_Found\r\n\r\nfindSame\' (x:xs) y cond = if not (cond x) then Answer y \r\n\r\n				          else findSame\' xs x\r\n\r\n					  		(	 -> cond t && (t /= x))\r\n\r\nfindSame xs = findSame\' xs 0 (const True)\r\n','<br/>Тесты успешно пройдены!'),(7171,86,'1595828','2013-10-31 13:03:02',1,'allNondivisible\' [] cond = True\r\n\r\nallNondivisible\' (x:xs) cond = if not(cond x) then False else allNondivisible\' xs (	 -> cond t && gcd t x/= min x t)\r\n\r\nallNondivisible xs = allNondivisible\' xs (const True)\r\n','<br/>Тесты успешно пройдены!'),(7170,82,'1835693','2013-10-31 11:52:34',1,'-- update5: понял свою очередную ошибку и переделал алгоритм проверки наличия переменных\r\n\r\n-- теперь после подсчета всех классов классы просто подбираются по списку переменных (с удалением этого класса из списка классов)\r\n\r\n\r\n\r\n-- update4: проблема была в том, что у меня неправильно учитывались пустые классы\r\n\r\n-- например, countDifferentVarsH [(1,2)] [] возвращает один пустой класс - [[]], а длина этого - 1, а не 0\r\n\r\n-- я решил это проверкой на пустые классы: filter (/= [])\r\n\r\n\r\n\r\n--- У вас неправильно работает, если список переменных пустой.\r\n\r\n--- Например countDifferentVars [(1,2)] []\r\n\r\n--- Ответ должен быть 0 (в списке переменных вообще 0 переменных, тем более 0 разных переменных)\r\n\r\n\r\n\r\n-- update: добавил проверку на пустой список переменных\r\n\r\n-- update2: переделал проверку на некорректные условия (если переменных указано недостатчно)\r\n\r\n-- update3: переделал проверку еще раз :)\r\n\r\ncountDifferentVars eqs vars = checkPresense (countDifferentVarsH eqs (map (x -> [x]) vars)) vars\r\n\r\n\r\n\r\n-- Храним одинаковые переменные как элементы одного списка в последовательности (классы эквивалентности)\r\n\r\n-- После каждого равенства, ищем классы этих двух переменных и совмещаем их в один\r\n\r\ncountDifferentVarsH []       vars = vars\r\n\r\ncountDifferentVarsH (eq:eqs) vars = countDifferentVarsH eqs (updateVars eq vars)\r\n\r\n\r\n\r\nupdateVars eq vars = merged : rest\r\n\r\n                     where -- сами переменные\r\n\r\n                           a = fst eq\r\n\r\n                           b = snd eq\r\n\r\n                           -- их классы\r\n\r\n                           firstFilter = filter (elem (fst eq)) vars\r\n\r\n                           secondFilter = filter (elem (snd eq)) vars\r\n\r\n                           first = if (firstFilter == [])\r\n\r\n                                   then [a]\r\n\r\n                                   else head firstFilter\r\n\r\n                           second = if (secondFilter == [])\r\n\r\n                                   then [b]\r\n\r\n                                   else head secondFilter\r\n\r\n                           -- совмещение классов\r\n\r\n                           merged = first ++ second\r\n\r\n                           -- оставшиеся классы\r\n\r\n                           rest = filter (not . elem a) (filter (not . elem b) vars)\r\n\r\n\r\n\r\ncheckPresense mergedVars []   = 0\r\n\r\ncheckPresense mergedVars (var:vars) = if (any (elem var) mergedVars)\r\n\r\n                                      then checkPresense (filter (x -> not $ elem var x) mergedVars) vars + 1\r\n\r\n                                      else checkPresense mergedVars vars\r\n','<br/>Тесты успешно пройдены!'),(7169,82,'1835693','2013-10-31 11:36:59',0,'-- update4: проблема была в том, что у меня неправильно учитывались пустые классы\r\n\n-- например, countDifferentVarsH [(1,2)] [] возвращает один пустой класс - [[]], а длина этого - 1, а не 0\r\n\n-- я решил это проверкой на пустые классы: filter (/= [])\r\n\n\r\n\n--- У вас неправильно работает, если список переменных пустой.\r\n\n--- Например countDifferentVars [(1,2)] []\r\n\n--- Ответ должен быть 0 (в списке переменных вообще 0 переменных, тем более 0 разных переменных)\r\n\n\r\n\n-- update: добавил проверку на пустой список переменных\r\n\n-- update2: переделал проверку на некорректные условия (если переменных указано недостатчно)\r\n\n-- update3: переделал проверку еще раз :)\r\n\ncountDifferentVars eqs vars = length $ filter (/= []) $ countDifferentVarsH eqs (map (x -> [x]) vars)\r\n\n\r\n\n-- Храним одинаковые переменные как элементы одного списка в последовательности (классы эквивалентности)\r\n\n-- После каждого равенства, ищем классы этих двух переменных и совмещаем их в один\r\n\ncountDifferentVarsH []       vars = vars\r\n\ncountDifferentVarsH (eq:eqs) vars = countDifferentVarsH eqs (updateVars eq vars)\r\n\n\r\n\nupdateVars eq vars = merged : rest\r\n\n                     where -- сами переменные\r\n\n                           a = fst eq\r\n\n                           b = snd eq\r\n\n                           -- их классы\r\n\n                           firstFilter = filter (elem (fst eq)) vars\r\n\n                           secondFilter = filter (elem (snd eq)) vars\r\n\n                           first = if (firstFilter == [])\r\n\n                                   then []\r\n\n                                   else head firstFilter\r\n\n                           second = if (secondFilter == [])\r\n\n                                   then []\r\n\n                                   else head secondFilter\r\n\n                           -- совмещение классов\r\n\n                           merged = first ++ second\r\n\n                           -- оставшиеся классы\r\n\n                           rest = filter (not . elem a) (filter (not . elem b) vars)\n','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(7168,90,'15309342','2013-10-31 10:57:10',1,'findSame xs = findSame\' xs (const True)\r\nfindSame\' [] cond = (False, 0) \r\nfindSame\' (x:xs) cond | not $ cond x = (True, x) \r\n        		      | otherwise = findSame\' xs (	 -> cond t && t /= x)','<br/>Тесты успешно пройдены!'),(7167,79,'Artur','2013-10-31 08:24:57',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace iterator\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {// считаем, что n > 1\r\n\r\n            int num = 10, div = n ;\r\n\r\n            for (int i = 0; ; i ++)\r\n\r\n            {\r\n\r\n                yield return Convert.ToInt32(num / n) ;\r\n\r\n                num =  10 * (num % n) ; \r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n , count ;\r\n\r\n            string s ;\r\n\r\n            Console.Write(\"Enter the number: \") ;\r\n\r\n            s = Console.ReadLine() ;\r\n\r\n            n = Convert.ToInt32(s) ;\r\n\r\n            count = 1 ;\r\n\r\n            foreach (int x in digits(n) )\r\n\r\n            {\r\n\r\n                Console.Write(x + \" \");\r\n\r\n                count++ ;\r\n\r\n                if (count > 10) \r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.ReadKey() ;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7165,77,'Artur','2013-10-31 00:25:09',1,'sqrt2 = (lst2 1)\r\n\r\n\r\n\r\n\r\n\r\nlst2 k = (snd (l k) `mod` 10) :(lst2 (k+1))\r\n\r\n\r\n\r\nl 1 = (100,1)\r\n\r\nl (n+1) = h (2* (snd xs)) (fst xs) 9 where xs = l n\r\n\r\n\r\n\r\n\r\n\r\nh x y 0 = (y*100,x*5)\r\n\r\nh x y l = if (x*10+l)*l <= y then ((y - (x*10+l)*l)*100,(x `div` 2)*10+l)\r\n\r\n			else h x y (l-1)\r\n\r\n\r\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7166,82,'ilia','2013-10-31 01:14:10',1,'countDifferentVars defs xs = let\r\n\r\n		same_defs = join_same (gen_same defs)\r\n\r\n	in length (unique ([ let\r\n\r\n			x_defs = filter (sd -> elem x sd) same_defs\r\n\r\n		in\r\n\r\n			if (length x_defs == 0) then x else head (head x_defs)\r\n\r\n		| x <- xs ]))\r\n\r\n\r\n\r\njoin_same [ ] = [ ]\r\n\r\njoin_same (def:defs) = let\r\n\r\n		rs = join_same defs\r\n\r\n	in\r\n\r\n		if any (\r\n -> any (d -> elem d r) def) rs then\r\n\r\n			map (\r\n ->\r\n\r\n				if any (d -> elem d r) def then\r\n\r\n					def ++ r\r\n\r\n				else\r\n\r\n					r) rs\r\n\r\n		else\r\n\r\n			def : rs\r\n\r\n\r\n\r\ngen_same [ ] = [ ]\r\n\r\ngen_same (def:defs) = let\r\n\r\n		rs = gen_same defs\r\n\r\n		def_f = fst def\r\n\r\n		def_s = snd def\r\n\r\n	in\r\n\r\n		if any (\r\n -> elem def_f r || elem def_s r) rs then\r\n\r\n			map (\r\n -> if elem def_f r && not (elem def_s r) then def_s : r else r)\r\n\r\n				(map (\r\n -> if elem def_s r && not (elem def_f r) then def_f : r else r) rs)\r\n\r\n		else\r\n\r\n			[ def_f, def_s ] : rs\r\n\r\n\r\n\r\nunique [] = []\r\n\r\nunique (x:xs)\r\n\r\n	| elem x xs = unique xs\r\n\r\n	| otherwise = x : unique xs\r\n\r\n\r\n\r\nmain = print (countDifferentVars [\r\n\r\n		(\"x\", \"y\"),\r\n\r\n		(\"y\", \"z\"),\r\n\r\n		(\"n\", \"m\")\r\n\r\n	] [ \"x\", \"w\", \"y\", \"z\", \"x\", \"n\", \"m\" ])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7164,82,'ilia','2013-10-31 00:22:45',0,'countDifferentVars defs xs = let\n\n		svs = same_vars defs\n\n	in length (unique ([ let\n\n			x_defs = filter (sv -> elem x sv) svs\n\n		in\n\n			if (length x_defs == 0) then x else head (head x_defs)\n\n		| x <- xs ]))\n\n\n\nsame_vars [ ] = [ ]\n\nsame_vars (def:defs) = let\n\n		rs = same_vars defs\n\n		def_f = fst def\n\n		def_s = snd def\n\n	in\n\n		if any (\r -> elem def_f r || elem def_s r) rs then\n\n			map (\r -> if elem def_f r && not (elem def_s r) then def_s : r else r)\n\n				(map (\r -> if elem def_s r && not (elem def_f r) then def_f : r else r) rs)\n\n		else\n\n			[ def_f, def_s ] : rs\n\n\n\nunique [] = []\n\nunique (x:xs)\n\n	| elem x xs = unique xs\n\n	| otherwise = x : unique xs\n\n\n\nmain = print (countDifferentVars [\n\n		(\"x\", \"y\"),\n\n		(\"y\", \"z\"),\n\n		(\"n\", \"m\")\n\n	] [ \"x\", \"w\", \"y\", \"z\", \"x\", \"n\", \"m\" ])\n\n\n','Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]'),(7163,135,'romos2007','2013-10-31 00:21:18',1,'{--\r\n\r\nЗадача 24-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nsuperMap f xs = [x | y<-xs, x <- f y]\r\n\r\n\r\n\r\nsuperMap\' f xs = foldr (++) [] (map f xs)\r\n','<br/>Тесты успешно пройдены!'),(7162,77,'Artur','2013-10-31 00:17:25',0,'lst2 k = (snd (l k) `mod` 10) :(lst2 (k+1))\r\n\n\r\n\nl 1 = (100,1)\r\n\nl (n+1) = h (2* (snd xs)) (fst xs) 9 where xs = l n\r\n\n\r\n\nsqrt2 = (lst2 1)\r\n\n\r\n\nh x y 0 = (y*100,x*5)\r\n\nh x y l = if (x*10+l)*l <= y then ((y - (x*10+l)*l)*100,(x `div` 2)*10+l)\r\n\n			else h x y (l-1)\r\n\n\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7160,77,'Artur','2013-10-31 00:14:27',0,'\r\n\n\r\n\nlst2 k = (sc (l k) `mod` 10) :(lst2 (k+1))\r\n\nl 1 = [100,1]\r\n\nl (n+1) = h (2* (sc xs)) (fs xs) 9 where xs = l n\r\n\n\r\n\nsqrt2 = (lst2 1)\r\n\n\r\n\nfs (x:xs) = x\r\n\nsc (x:y:ys) = y\r\n\n		\r\n\nh x y 0 = [y*100,x*5]\r\n\nh x y l = if (x*10+l)*l <= y then [(y - (x*10+l)*l)*100,(x `div` 2)*10+l]\r\n\n			else h x y (l-1)\r\n\n\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7161,77,'Artur','2013-10-31 00:15:06',0,'\r\n\n\r\n\nlst2 k = (sc (l k) `mod` 10) :(lst2 (k+1))\r\n\nl 1 = [100,1]\r\n\nl (n+1) = h (2* (sc xs)) (fs xs) 9 where xs = l n\r\n\n\r\n\nsqrt2 = (lst2 1)\r\n\n\r\n\nfs (x:xs) = x\r\n\nsc (x:y:ys) = y\r\n\n		\r\n\nh x y 0 = [y*100,x*5]\r\n\nh x y l = if (x*10+l)*l <= y then [(y - (x*10+l)*l)*100,(x `div` 2)*10+l]\r\n\n			else h x y (l-1)\r\n\n\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7159,85,'romos2007','2013-10-31 00:14:22',1,'{--\r\n\r\nЗадача 24-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\ndata Ration = Rat Int Int\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n	(Rat nom1 denom1) + (Rat nom2 denom2) = let\r\n\r\n												nom = denom1 * nom2 + denom2 * nom1\r\n\r\n												denom = denom1 * denom2\r\n\r\n											in\r\n\r\n												Rat nom denom\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n	(Rat nom1 denom1) == (Rat nom2 denom2) = (nom1*denom2 == nom2*denom1)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n	(Rat nom1 denom1) < (Rat nom2 denom2) = if (denom1*denom2 > 0) then (nom1*denom2 < nom2*denom1) else (nom1*denom2 > nom2*denom1)\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n		show (Rat nom denom) = show (nom) ++ \"/\" ++ show (denom)\r\n','<br/>Тесты успешно пройдены!'),(7158,77,'Artur','2013-10-31 00:12:37',0,'sqrt2 = (lst2 1)\r\n\n\r\n\nlst2 k = (sc (l k) `mod` 10) :(lst2 (k+1))\r\n\nl 1 = [100,1]\r\n\nl (n+1) = h (2* (sc xs)) (fs xs) 9 where xs = l n\r\n\n\r\n\nfs (x:xs) = x\r\n\nsc (x:y:ys) = y\r\n\n		\r\n\nh x y 0 = [y*100,x*5]\r\n\nh x y l = if (x*10+l)*l <= y then [(y - (x*10+l)*l)*100,(x `div` 2)*10+l]\r\n\n			else h x y (l-1)\r\n\n\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7157,77,'Artur','2013-10-31 00:11:20',0,'sqrt2 = (lst2 1)\r\n\n\r\n\nlst2 k = (sc (l k) `mod` 10) :(lst2 (k+1))\r\n\nl 1 = [100,1]\r\n\nl (n+1) = h (2* (sc xs)) (fs xs) 9 where xs = l n\r\n\n\r\n\nfs (x:xs) = x\r\n\nsc (x:y:ys) = y\r\n\n		\r\n\nh x y 0 = [y*100,x*5]\r\n\nh x y l = if (x*10+l)*l <= y then [(y - (x*10+l)*l)*100,(x `div` 2)*10+l]\r\n\n			else h x y (l-1)\r\n\n\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7156,85,'romos2007','2013-10-31 00:09:21',0,'{--\r\n\nЗадача 24-2\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\ndata Ration = Rat Int Int\r\n\n\r\n\ninstance Num Ration where\r\n\n	(Rat nom1 denom1) + (Rat nom2 denom2) = let\r\n\n												nom = denom1 * nom2 + denom2 * nom1\r\n\n												denom = denom1 * denom2\r\n\n											in\r\n\n												Rat nom denom\r\n\n\r\n\ninstance Eq Ration where\r\n\n	(Rat nom1 denom1) == (Rat nom2 denom2) = (nom1*denom2 == nom2*denom1)\r\n\n\r\n\ninstance Ord Ration where\r\n\n	(Rat nom1 denom1) < (Rat nom2 denom2) = (nom1*denom2 < nom2*denom1)\r\n\n\r\n\ninstance Show Ration where\r\n\n		show (Rat nom denom) = show (nom) ++ \"/\" ++ show (denom)\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7155,76,'romos2007','2013-10-31 00:09:03',1,'{--\r\n\r\nЗадача 24-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\n\r\n\r\nclass Shape a where\r\n\r\n	area::a->Double\r\n\r\n	perim::a->Double\r\n\r\n	contains::a->Double->Double->Bool\r\n\r\n\r\n\r\ninstance Shape Rect where\r\n\r\n	area (Rect l h cx cy) = l*h\r\n\r\n	perim (Rect l h cx cy) = 2*(l+h)\r\n\r\n	contains (Rect l h cx cy) x y = let\r\n\r\n										l2 = l/2\r\n\r\n										h2 = h/2\r\n\r\n									in\r\n\r\n										(cx - l2 <= x) && (x <= cx + l2) && (cy - h2 <= y) && (y <= cy + h2)\r\n\r\n\r\n\r\ninstance Shape Circle where\r\n\r\n	area (Circle r cx cy) = 3.14*r*r\r\n\r\n	perim (Circle r cx cy) = 2*3.14*r\r\n\r\n	contains (Circle r cx cy) x y = ((x-cx)^2+(y-cy)^2 <= r^2)\r\n','<br/>Тесты успешно пройдены!'),(7153,89,'15309342','2013-10-30 23:46:18',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten tree = flatten1 [] tree\r\nflatten1 xs Empty = xs\r\nflatten1 xs (Node e left right) = e : flatten1 (flatten1 xs right) left\r\n','<br/>Тесты успешно пройдены!'),(7154,80,'artem.gomerman','2013-10-31 00:00:02',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    static public IEnumerable<KeyValuePair<int, int>> cantor()\r\n\r\n    {\r\n\r\n        for (int sumIndex = 2; ; sumIndex++)\r\n\r\n        {\r\n\r\n            for (int x = 1; x <= sumIndex - 1; x++)\r\n\r\n            {\r\n\r\n                yield return new KeyValuePair<int, int>(x, sumIndex - x);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Console.Write(\"Cantor set\r\nInput amount of cantor pairs: \");\r\n\r\n        int pairsCount = int.Parse(Console.ReadLine());\r\n\r\n        int index = 0;\r\n\r\n        foreach (KeyValuePair<int, int> x in cantor())\r\n\r\n        {\r\n\r\n            if (index >= pairsCount)\r\n\r\n                break;\r\n\r\n            index++;\r\n\r\n            Console.Write(x);\r\n\r\n        }\r\n\r\n        Console.ReadKey(false);\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7152,89,'15309342','2013-10-30 23:45:53',0,'flatten tree = flatten1 [] tree\r\nflatten1 xs Empty = xs\r\nflatten1 xs (Node e left right) = e : flatten1 (flatten1 xs right) left\r\n','Не удалось вычислить выражение \"flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\", проверьте правильность синтаксиса'),(7150,78,'Artur','2013-10-30 23:18:39',2,'  --- Но в этой задаче нельзя описывать свои функции, перечитайте условие внимательнее,\r\n  --- пожалуйста. Т.е. надо вместо q и f использоать лямбда выражения и стандартные функции.\r\npascal = [1] : (g pascal)\r\n\r\n\r\n\r\n\r\n\r\ng (xs:xss) = (f xs): (g xss)\r\n\r\nf xs = zipWith (+) (0:xs) (xs++[0]) \r\n','<br/>Тесты успешно пройдены!'),(7151,79,'artem.gomerman','2013-10-30 23:43:30',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    public static IEnumerable<int> digits(int n)\r\n\r\n    {\r\n\r\n        int currentQuotient = 10;\r\n\r\n        for (int i = 0; ; i++)\r\n\r\n        {\r\n\r\n            int newQuot = currentQuotient / n;\r\n\r\n            currentQuotient = (currentQuotient - newQuot * n) * 10;\r\n\r\n            yield return newQuot;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    static void Main(string[] args)\r\n\r\n    {\r\n\r\n        Console.Write(\"Infinite fraction 1/n\r\nInput n: \");\r\n\r\n        int n = int.Parse(Console.ReadLine());\r\n\r\n        int index = 0;\r\n\r\n        const int outputDigitsCount = 100;\r\n\r\n        foreach (int x in digits(n))\r\n\r\n        {\r\n\r\n            if (index >= outputDigitsCount)\r\n\r\n                break;\r\n\r\n            index++;\r\n\r\n            Console.Write(x);\r\n\r\n        }\r\n\r\n        Console.ReadKey(false);\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7149,90,'15309342','2013-10-30 23:16:04',2,' --- В принципе это хорошее решение, но оно не по условию :(\r\n --- Там написано, что пользователь функции мог понять, нашлось что-то ии нет,\r\n --- Имелось в виду, что надо чтобы пользователь мог в своей программе, если\r\n --- нашелся повторяющийся элемент, сделать что-то одно, а если не нашелся - \r\n --- что-то другое. А у вас, если не нашлось, он сделать ничего не сможет, программа\r\n --- аварийно завершится и все.\r\n --- Попробуйте какой-нибудь такой вариант придумать, пожалуйста.\r\nfindSame xs = findSame\' xs (const True)\r\nfindSame\' [] cond = error \"No such element\"\r\nfindSame\' (x:xs) cond | not $ cond x = x \r\n    			      | otherwise = findSame\' xs (	 -> cond t && t /= x)','<br/>Тесты успешно пройдены!'),(7148,86,'15309342','2013-10-30 23:04:29',1,'allNondivisible xs = allNondivisible\' xs (const True)\r\nallNondivisible\' [] cond = True\r\nallNondivisible\' (x:xs) cond | not $ cond x = False\r\n                             | otherwise = allNondivisible\' xs (	 -> cond t && t `mod` x /= 0 &&  x `mod` t /= 0)','<br/>Тесты успешно пройдены!'),(7147,85,'15309342','2013-10-30 22:43:44',1,'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n    (Rat n1 d1) + (Rat n2 d2) = let\r\n                                n = n1 * d2 + n2 * d1\r\n                                d = d1 * d2\r\n                                nd_gcd = gcd n d\r\n                            in (Rat (n `div` nd_gcd) (d `div` nd_gcd))\r\ninstance Ord Ration where\r\n    (Rat n1 d1) < (Rat n2 d2) | d1 * d2 > 0 = n1 * d2 < n2 * d1\r\n                          | otherwise = n2 * d1 < n1 * d2\r\n\r\ninstance Eq Ration where\r\n    (Rat n1 d1) == (Rat n2 d2) = n1 * d2 == n2 * d1\r\n\r\ninstance Show Ration where\r\n    show (Rat n d) = show n ++ \"/\" ++ show d','<br/>Тесты успешно пройдены!'),(7146,85,'15309342','2013-10-30 22:42:21',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n    (Rat n1 d1) + (Rat n2 d2) = let\r\n                                n = n1 * d2 + n2 * d1\r\n                                d = d1 * d2\r\n                                nd_gcd = gcd n d\r\n                            in (Rat (n `div` nd_gcd) (d `div` nd_gcd))\r\ninstance Ord Ration where\r\n    (Rat n1 d1) < (Rat n2 d2) | d1 * d2 > 0 = n1 * d2 < n2 * d1\r\n                          | otherwise = n2 * d1 < n1 * d2\r\n\r\ninstance Eq Ration where\r\n    (Rat n1 d1) == (Rat n2 d2) = n1 * d2 == n2 * d1\r\n\r\ninstance Show Ration where\r\n    show (Rat n d) = show n ++ \" / \" ++ show d','Выражение имеет неправильное значение: Rat 1 2 + Rat 1 7'),(7145,90,'anlun','2013-10-30 22:28:10',1,'findSame :: Eq a => [a] -> Maybe a\r\nfindSame []                   = Nothing\r\nfindSame (x:xs) | x `elem` xs = Just x\r\nfindSame (x:xs)               = findSame xs','<br/>Тесты успешно пройдены!'),(7144,89,'anlun','2013-10-30 22:21:47',1,'data Tree a = Empty\r\n			| Node a (Tree a) (Tree a)\r\n\r\nfoldlWithAccum :: (c -> a -> c) -> c -> Tree a -> c\r\nfoldlWithAccum _ contex  Empty       = contex\r\nfoldlWithAccum f contex (Node e l r) = vertexContex\r\n	where\r\n		rightTreeContex = foldlWithAccum f          contex r\r\n		leftTreeContex  = foldlWithAccum f rightTreeContex l\r\n		vertexContex    = f leftTreeContex e\r\n\r\nflatten :: Tree a -> [a]\r\nflatten = foldlWithAccum (flip (:)) []','<br/>Тесты успешно пройдены!'),(7141,135,'15309342','2013-10-30 21:55:33',1,'superMap f xs = foldr (x ys -> (f x) ++ ys) [] xs','<br/>Тесты успешно пройдены!'),(7142,135,'anlun','2013-10-30 22:03:19',1,'superMap :: (a -> [b]) -> [a] -> [b]\r\nsuperMap = (concat .) . map','<br/>Тесты успешно пройдены!'),(7143,76,'15309342','2013-10-30 22:21:15',1,'data Rect = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\nclass Shape a where\r\n   contains :: a -> Double -> Double -> Bool\r\n\r\ninstance Shape Rect where\r\n    contains (Rect w h x0 y0) x y = ((x - x0)^2 < w^2 / 4) && ((y - y0)^2 < h^2 / 4)\r\n\r\ninstance Shape Circle where\r\n    contains (Circle r x0 y0) x y = ((x - x0)^2 + (y - y0)^2) < r * r','<br/>Тесты успешно пройдены!'),(7139,86,'SNNatalieS','2013-10-30 21:34:22',2,'allNondivisible xs = q xs []\r\nq [] _ = True\r\nq (x:xs) s = if (any(	 -> (mod x t == 0) || (mod t x == 0)) s) then False\r\n				else q xs (x:s)\r\n  --- Нет, это не совсем то. Тут надо было испльзовать прием со слайда 19 из последних\r\n  --- слайдов. Те. там должно быть что-то вроде:\r\n  --- allNondivisible xs = q xs (const True)\r\n  --- И определить allNondivisible xs cond\r\n  --- где xs - список, а cond - условие, которое мы проверяем, и которое по мере просмотра списка делаем\r\n  --- все сложнее и сложнее.\r\n  --- Если не очень понятно, о чем речь, напишите письмо и я могу еще немного подсказать.','<br/>Тесты успешно пройдены!'),(7140,76,'anlun','2013-10-30 21:47:56',1,'-- a b center_x center_y \r\ndata Rect   = Rect   Double Double Double Double\r\n\r\nclass Shape a where\r\n	area  :: a -> Double\r\n	perim :: a -> Double\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\ninstance Shape Rect where\r\n	area     (Rect a b _ _) = a * b\r\n	perim    (Rect a b _ _) = 2 * (a + b)\r\n	contains (Rect a b x y) px py = (&&) (abs (px - x) <= a / 2) $ abs (py - y) <= b / 2\r\n\r\n-- r center_x center_y \r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n	area     (Circle r _ _) = pi * r * r\r\n	perim    (Circle r _ _) = 2 * pi * r\r\n	contains (Circle r x y) px py = (px - x) ** 2 + (py - y) ** 2 <= r ** 2\r\n','<br/>Тесты успешно пройдены!'),(7138,86,'SNNatalieS','2013-10-30 21:32:28',0,'allNondivisible xs = q xs []\r\nq [] _ = True\r\nq (x:xs) s = if (any(	 -> mod x t == 0) s) then False\r\n				else q xs (x:s)','Выражение имеет неправильное значение: allNondivisible [4,2]'),(7136,77,'artem.gomerman','2013-10-30 21:25:24',1,'sqrt2 = sqrt2\' 0 2 0\r\n\r\n\r\n\r\nsqrt2\'::Integer->Integer->Integer->[Integer]\r\n\r\nsqrt2\' p c sqrtAsInteger = let\r\n\r\n	x = findMaxDigit p c\r\n\r\n	y = (20*p + x) * x \r\n\r\n	newSqrtInteger = 10*sqrtAsInteger + x in x:(sqrt2\' newSqrtInteger ((c - y)*100) newSqrtInteger)\r\n\r\n\r\n\r\nfindMaxDigit::Integer->Integer->Integer\r\n\r\nfindMaxDigit p c = toInteger(length (filter (<= c) [(20*p + x) * x | x <- [0..9]]) - 1)\r\n\r\n\r\n\r\nfromDigits xs = foldl (x res -> res + x*10) 0 xs\r\n','<br/>Тесты успешно пройдены!'),(7137,86,'SNNatalieS','2013-10-30 21:29:19',0,'allNondivisible xs = q xs []\r\nq [] _ = True\r\nq (x:xs) s = if (any(	 -> mod x t == 0) s) then False\r\n				else q xs (x:s)','Выражение имеет неправильное значение: allNondivisible [4,2]'),(7135,85,'SNNatalieS','2013-10-30 20:59:09',1,'data Rat = Rat Int Int\r\ninstance Show Rat where\r\n	show (Rat re im) = (show re) ++ \"/\" ++ (show im)\r\ninstance Eq Rat where \r\n	Rat n1 d1 == Rat n2 d2 = n1 * d2 == n2 * d1\r\ninstance Ord Rat where\r\n	(Rat n1 d1) < (Rat n2 d2) = (fromIntegral(n1 * d2) - fromIntegral(n2 * d1)) / fromIntegral(d1 * d2) < 0.0\r\ninstance Num Rat where\r\n	(Rat n1 d1) + (Rat n2 d2) = Rat (n1 * d2 + n2 * d1) (d1 * d2)\r\n\r\n','<br/>Тесты успешно пройдены!'),(7134,82,'ilia','2013-10-30 20:51:16',0,'countDifferentVars defs vars = length (replace_vars vars defs)\n\n\n\nreplace_vars vars defs = unique [ replace_var var defs | var <- vars ]\n\nreplace_var var defs = let\n\n		n = filter (d -> fst d == var) defs\n\n	in\n\n		if length n == 0 then\n\n			var\n\n		else\n\n			replace_var (snd (n !! 0)) defs\n\n\n\nunique [] = []\n\nunique (x:xs)\n\n	| elem x xs = unique xs\n\n	| otherwise = x : unique xs\n\n\n\nmain = print (countDifferentVars [\n\n		(\"x\", \"y\"),\n\n		(\"y\", \"z\"),\n\n		(\"n\", \"m\")\n\n	]\n\n	[ \"x\", \"w\", \"y\", \"z\", \"x\", \"n\", \"m\" ])\n\n\n','Не удалось вычислить выражение \"countDifferentVars [(1,2),(2,1)] [1,2,3]\", проверьте правильность синтаксиса'),(7133,85,'SNNatalieS','2013-10-30 20:49:27',0,'data Rat = Rat Int Int\r\ninstance Show Rat where\r\n	show (Rat re im) = (show re) ++ \"/\" ++ (show im)\r\ninstance Eq Rat where \r\n	Rat n1 d1 == Rat n2 d2 = n1 * d2 == n2 * d1\r\ninstance Ord Rat where\r\n	Rat n1 d1 < Rat n2 d2 = n1 * d2 < n2 * d1\r\ninstance Num Rat where\r\n	(Rat n1 d1) + (Rat n2 d2) = Rat (n1 * d2 + n2 * d1) (d1 * d2)\r\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7131,135,'1595828','2013-10-30 20:27:17',1,'superMap f xs = concatMap f xs\r\n','<br/>Тесты успешно пройдены!'),(7132,89,'1595828','2013-10-30 20:37:18',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nflatten\' Empty res = res\r\n\r\nflatten\' (Node n l r) res = n : flatten\' l (flatten\' r res)\r\n\r\nflatten t = flatten\' t []\r\n','<br/>Тесты успешно пройдены!'),(7130,76,'SNNatalieS','2013-10-30 20:16:30',1,'  --- ОК, но вместо if выражение then True else False всегда можно писать просто выражение:)\r\ndata Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\nclass Shape a where\r\n	area:: a -> Double\r\n	perim:: a -> Double\r\n	contains:: a -> Double-> Double -> Bool   \r\ninstance Shape Rect where\r\n	area (Rect x y c1 c2) = x*y\r\n	perim (Rect x y c1 c2) = 2*(x+y)\r\n	contains (Rect x y c1 c2) p1 p2 = let \r\n										w = x / 2\r\n										h = y / 2\r\n										in	if (p1 > c1 - w) && (p1 < c1 + w) && (p2 > c2 - h) && (p2 < c2 + h) then True\r\n												else False											\r\ninstance Shape Circle where\r\n  	area (Circle r c1 c2) = 3.14*r*r\r\n  	perim (Circle r c1 c2) = 2*3.14*r\r\n	contains (Circle r c1 c2) p1 p2 = if (p1 - c1)^2 + (p2 - c2)^2 < r * r then True else False\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7129,85,'1595828','2013-10-30 19:53:16',1,'data Ration = Rat Integer Integer\r\n\r\n\r\n\r\ninstance Num Ration where\r\n\r\n    (Rat n1 d1) + (Rat n2 d2) = Rat (n1*d2 + n2*d1) (d1*d2)\r\n\r\n\r\n\r\ninstance Ord Ration where\r\n\r\n    (Rat n1 d1) < (Rat n2 d2) = if (d1*d2 > 0) then n1*d2 < n2*d1 else n1*d2 > n2*d1\r\n\r\n\r\n\r\ninstance Eq Ration where\r\n\r\n    (Rat n1 d1) == (Rat n2 d2) = n1*d2 == n2*d1\r\n\r\n\r\n\r\ninstance Show Ration where\r\n\r\n    show (Rat n d) = show n ++ \"/\" ++ show d\r\n','<br/>Тесты успешно пройдены!'),(7128,76,'1595828','2013-10-30 19:17:18',1,'data Rect = Rect Double Double Double Double\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\nclass Shape a where\r\n\r\n   contains:: a ->Double ->Double ->Bool\r\n\r\ninstance Shape Rect where\r\n\r\n  	contains (Rect x_l y_l x_c y_c) x_p y_p = ((x_c-x_p)^2<=(x_l/2)^2)&&((y_c-y_p)^2<=(y_l/2)^2)\r\n\r\ninstance Shape Circle where\r\n\r\n  	contains (Circle r x y) x_p y_p= (((x-x_p)^2+(y-y_p)^2)<=(r^2))\r\n','<br/>Тесты успешно пройдены!'),(7126,90,'egeorge','2013-10-30 18:23:38',1,'findSame [] = []\r\nfindSame (x:xs) = if (elem x xs)\r\n                  then [x] \r\n                  else findSame xs','<br/>Тесты успешно пройдены!'),(7127,86,'115753099','2013-10-30 18:45:04',1,'allNondivisible xs = allNondivisible1 xs (const True)\r\n\r\nallNondivisible1 [] re = True\r\nallNondivisible1 (x:xs) re =\r\n	if not (re x) then False\r\n	else allNondivisible1 xs (y -> re y && (max x y) `rem` (min x y) /= 0)','<br/>Тесты успешно пройдены!'),(7125,135,'egeorge','2013-10-30 18:18:35',1,'superMap _ [] = []\r\nsuperMap f (x:xs) = (f x) ++ (superMap f xs)\r\n','<br/>Тесты успешно пройдены!'),(7123,78,'toskira','2013-10-30 18:00:57',1,'pascal = [1]:(zipWith (a b -> zipWith (+) (a++[0]) (0:b)) pascal pascal)','<br/>Тесты успешно пройдены!'),(7124,135,'egeorge','2013-10-30 18:17:25',0,'superMap f (x:xs) = (f x) ++ (superMap f xs)','Не удалось вычислить выражение \"let f x = [x*x, 100*x] in superMap f [1,2,3]\", проверьте правильность синтаксиса'),(7121,53,'48167667','2013-10-30 17:51:59',2,'coins n = [[x,y,z]|x<-[0..n],y<-[0..n],z<-     [0..n],2*x+3*y+5*z==n]','<br/>Тесты успешно пройдены!'),(7122,85,'egeorge','2013-10-30 17:55:42',1,'data Rat = Rat Integer Integer\r\n\r\ninstance Num Rat where\r\n (Rat numA denomA) + (Rat numB denomB) = (Rat ((numA * denomB) + (numB * denomA)) (denomA * denomB))\r\n\r\ninstance Ord Rat where\r\n (Rat numA denomA) < (Rat numB denomB) = if (denomA * denomB > 0)\r\n                                         then (numA * denomB) < (numB * denomA)\r\n                                         else (numA * denomB) > (numB * denomA)\r\n\r\ninstance Show Rat where\r\n show (Rat num denom) = ((show num) ++ \"/\" ++ (show denom))\r\n\r\ninstance Eq Rat where\r\n (Rat numA denomA) == (Rat numB denomB) = ((numA * denomB) == (numB * denomA))\r\n','<br/>Тесты успешно пройдены!'),(7120,77,'toskira','2013-10-30 17:51:23',1,'sqrt2 = 1:[get x sqrt2 | x <- [1..]]\r\n\r\nget i list = let sum = prev i list\r\n                 up = 2 * (100^i)\r\n             in (head . (filter (x -> (sum + x)^2 > up))) [0..10] - 1\r\n\r\nprev 0 _ = 0\r\nprev n (x:t) = (x * (10^n) + prev (n-1) t)','<br/>Тесты успешно пройдены!'),(7119,53,'48167667','2013-10-30 17:48:54',0,'coins n = [(x,y,z)|x<-[0..n],y<-[0..n],z<-     [0..n],2*x+3*y+5*z==n]','Выражение имеет неправильное значение: coins 2'),(7118,85,'115753099','2013-10-30 17:47:54',1,'data Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n	(Rat m1 n1) + (Rat m2 n2) = Rat (m1 * n2 + m2 * n1) (n1 * n2)\r\n	r1 * r2 = Rat 1 1\r\n	r1 - r2 = Rat 1 1\r\n	abs (Rat m n) = Rat m (abs n)\r\n	signum r = 1\r\n	fromInteger r = 1\r\ninstance Ord Ration where\r\n	(Rat m1 n1) < (Rat m2 n2)\r\n		| n1 * n2 < 0 = m1 * n2 > m2 * n1\r\n		| otherwise = m1 * n2 < m2 * n1\r\ninstance Eq Ration where\r\n	Rat m1 n1 == Rat m2 n2 =\r\n		m1 * n2 == m2 * n1\r\ninstance Show Ration where\r\n	show (Rat m n) = show m ++ \"/\" ++ show n','<br/>Тесты успешно пройдены!'),(7117,76,'egeorge','2013-10-30 17:41:49',1,'class Shape a where\r\n area:: a -> Double\r\n perim:: a -> Double\r\n contains:: a -> Double -> Double -> Bool\r\n \r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n area (Circle r ox oy) = 3.14*r*r\r\n perim (Circle r ox oy) = 2*3.14*r\r\n contains (Circle r ox oy) ax ay = (((ax - ox)^2 + (ay - oy)^2) < r^2)\r\n \r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where\r\n area (Rect x y ox oy) = x*y\r\n perim (Rect x y ox oy) = 2*(x+y)\r\n contains (Rect x y ox oy) ax ay = let halfX = x / 2\r\n                                       halfY = y / 2\r\n                                   in (ax > (ox - halfX)) &&\r\n                                      (ax < (ox + halfX)) && \r\n                                      (ay > (oy - halfY)) && \r\n                                      (ay < (oy + halfY))','<br/>Тесты успешно пройдены!'),(7116,82,'1835693','2013-10-30 17:05:29',2,'--- У вас неправильно работает, если список переменных пустой.\r\n--- Например countDifferentVars [(1,2)] []\r\n--- Ответ должен быть 0 (в списке переменных вообще 0 переменных, тем более 0 разных переменных)\r\n\r\n-- update: добавил проверку на пустой список переменных\r\n\r\n-- update2: переделал проверку на некорректные условия (если переменных указано недостатчно)\r\n\r\n-- update3: переделал проверку еще раз :)\r\n\r\ncountDifferentVars eqs vars = length $ countDifferentVarsH eqs (map (x -> [x]) vars)\r\n\r\n\r\n\r\n-- Храним одинаковые переменные как элементы одного списка в последовательности (классы эквивалентности)\r\n\r\n-- После каждого равенства, ищем классы этих двух переменных и совмещаем их в один\r\n\r\ncountDifferentVarsH []       vars = vars\r\n\r\ncountDifferentVarsH (eq:eqs) vars = countDifferentVarsH eqs (updateVars eq vars)\r\n\r\n\r\n\r\nupdateVars eq vars = merged : rest\r\n\r\n                     where -- сами переменные\r\n\r\n                           a = fst eq\r\n\r\n                           b = snd eq\r\n\r\n                           -- их классы\r\n\r\n                           firstFilter = filter (elem (fst eq)) vars\r\n\r\n                           secondFilter = filter (elem (snd eq)) vars\r\n\r\n                           first = if (firstFilter == [])\r\n\r\n                                   then []\r\n\r\n                                   else head firstFilter\r\n\r\n                           second = if (secondFilter == [])\r\n\r\n                                   then []\r\n\r\n                                   else head secondFilter\r\n\r\n                           -- совмещение классов\r\n\r\n                           merged = first ++ second\r\n\r\n                           -- оставшиеся классы\r\n\r\n                           rest = filter (not . elem a) (filter (not . elem b) vars)\r\n','Хитрый тест номер 6 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),(7115,82,'1835693','2013-10-30 17:01:39',0,'-- update: добавил проверку на пустой список переменных\r\n\n-- update2: переделал проверку на некорректные условия (если переменных указано недостатчно)\r\n\n-- update3: переделал проверку еще раз :)\r\n\ncountDifferentVars eqs vars = length $ countDifferentVarsH eqs (map (x -> [x]) vars)\r\n\n\r\n\n-- Храним одинаковые переменные как элементы одного списка в последовательности (классы эквивалентности)\r\n\n-- После каждого равенства, ищем классы этих двух переменных и совмещаем их в один\r\n\ncountDifferentVarsH []       vars = vars\r\n\ncountDifferentVarsH (eq:eqs) vars = countDifferentVarsH eqs (updateVars eq vars)\r\n\n\r\n\nupdateVars eq vars = if (first == [] || second == [])\r\n\n                     then vars\r\n\n                     else merged : rest\r\n\n                     where -- сами переменные\r\n\n                           a = fst eq\r\n\n                           b = snd eq\r\n\n                           -- их классы\r\n\n                           first = filter (elem (fst eq)) vars\r\n\n                           second = filter (elem (snd eq)) vars\r\n\n                           -- совмещение классов\r\n\n                           merged = head first ++ head second\r\n\n                           -- оставшиеся классы\r\n\n                           rest = filter (not . elem a) (filter (not . elem b) vars)\n','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(7114,82,'1835693','2013-10-30 16:59:05',0,'-- update: добавил проверку на пустой список переменных\r\n\n-- update2: переделал проверку на некорректные условия (если переменных указано недостатчно)\r\n\ncountDifferentVars eqs vars = length $ countDifferentVarsH eqs (map (x -> [x]) vars)\r\n\n\r\n\n-- Храним одинаковые переменные как элементы одного списка в последовательности (классы эквивалентности)\r\n\n-- После каждого равенства, ищем классы этих двух переменных и совмещаем их в один\r\n\ncountDifferentVarsH []       vars = vars\r\n\ncountDifferentVarsH (eq:eqs) vars = countDifferentVarsH eqs (updateVars eq vars)\r\n\n\r\n\nupdateVars eq vars = if (first == [] || second == [])\r\n\n                     then []\r\n\n                     else merged : rest\r\n\n                     where -- сами переменные\r\n\n                           a = fst eq\r\n\n                           b = snd eq\r\n\n                           -- их классы\r\n\n                           first = filter (elem (fst eq)) vars\r\n\n                           second = filter (elem (snd eq)) vars\r\n\n                           -- совмещение классов\r\n\n                           merged = head first ++ head second\r\n\n                           -- оставшиеся классы\r\n\n                           rest = filter (not . elem a) (filter (not . elem b) vars)\n','Выражение имеет неправильное значение: countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]'),(7113,82,'1835693','2013-10-30 16:55:07',0,'-- update: добавил проверку на пустой список переменных\r\n\ncountDifferentVars eqs []   = 0\r\n\ncountDifferentVars eqs vars = length $ countDifferentVarsH eqs (map (x -> [x]) vars)\r\n\n\r\n\n-- Храним одинаковые переменные как элементы одного списка в последовательности (классы эквивалентности)\r\n\n-- После каждого равенства, ищем классы этих двух переменных и совмещаем их в один\r\n\ncountDifferentVarsH []       vars = vars\r\n\ncountDifferentVarsH (eq:eqs) vars = countDifferentVarsH eqs (updateVars eq vars)\r\n\n\r\n\nupdateVars eq vars = merged : rest\r\n\n                     where -- сами переменные\r\n\n                           a = fst eq\r\n\n                           b = snd eq\r\n\n                           -- их классы\r\n\n                           first = head $ filter (elem (fst eq)) vars\r\n\n                           second = head $ filter (elem (snd eq)) vars\r\n\n                           -- совмещение классов\r\n\n                           merged = first ++ second\r\n\n                           -- оставшиеся классы\r\n\n                           rest = filter (not . elem a) (filter (not . elem b) vars)\n','Не удалось вычислить выражение \"countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]\", проверьте правильность синтаксиса'),(7112,82,'1835693','2013-10-30 16:53:16',0,'countDifferentVars eqs vars = length $ countDifferentVarsH eqs (map (x -> [x]) vars)\r\n\r\n-- Храним одинаковые переменные как элементы одного списка в последовательности (классы эквивалентности)\r\n-- После каждого равенства, ищем классы этих двух переменных и совмещаем их в один\r\ncountDifferentVarsH []       vars = vars\r\ncountDifferentVarsH (eq:eqs) vars = countDifferentVarsH eqs (updateVars eq vars)\r\n\r\nupdateVars eq vars = merged : rest\r\n                     where -- сами переменные\r\n                           a = fst eq\r\n                           b = snd eq\r\n                           -- их классы\r\n                           first = head $ filter (elem (fst eq)) vars\r\n                           second = head $ filter (elem (snd eq)) vars\r\n                           -- совмещение классов\r\n                           merged = first ++ second\r\n                           -- оставшиеся классы\r\n                           rest = filter (not . elem a) (filter (not . elem b) vars)','Не удалось вычислить выражение \"countDifferentVars [(1,2),(2,3), (4,5)] []\", проверьте правильность синтаксиса'),(7111,93,'1835693','2013-10-30 16:32:25',1,'-- Считает последовательности вида a1 ^ b1 * a2 ^ b2 с фиксированным b2\r\n\r\npow a1 a2 b2 = [ a1 ^ x * a2 ^ b2 | x <- [0..] ]\r\n\r\n\r\n\r\n-- Две функции - для того, чтобы считать 3 ^ k * 10 ^ n и 3 ^ n * 10 ^ k с фиксированным k\r\n\r\npow3 = pow 3 10\r\n\r\npow10 = pow 10 3\r\n\r\n\r\n\r\nham = hamH 0 (-1) [pow3 0] 0\r\n\r\n\r\n\r\n-- На каждом шаге храним список все последовательностей, полученных из pow3/pow10,\r\n\r\n-- а также проверяем, не нужно ли добавить туда еще одну (когда предварительный результат\r\n\r\n-- больше, чем первый элемент последовательности)\r\n\r\nhamH p3 p10 seqs prev = if (x > head (pow3 (p3 + 1)))\r\n\r\n                        then hamH (p3 + 1) p10 ((pow3 (p3 + 1)) : seqs) prev\r\n\r\n                        else if (x > head (pow10 (p10 + 1)))\r\n\r\n                             then hamH p3 (p10 + 1) ((pow10 (p10 + 1)) : seqs) prev\r\n\r\n                             else if (x == prev)\r\n\r\n                                  then hamH p3 p10 (map (removeFirst x) seqs) x\r\n\r\n                                  else x : hamH p3 p10 (map (removeFirst x) seqs) x\r\n\r\n                        where x = takeFirst seqs\r\n\r\n\r\n\r\n-- Убирает первый элемент во всех элементах списка, если он равен параметру\r\n\r\nremoveFirst a (x:xs) = if (x == a)\r\n\r\n                       then xs\r\n\r\n                       else (x:xs)\r\n\r\n\r\n\r\n-- Находит минимальный первый элемент списка последовательностей\r\n\r\ntakeFirst seqs = minimum $ map head seqs\r\n','<br/>Тесты успешно пройдены!'),(7110,83,'ilia','2013-10-30 16:27:44',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\ndef Lst137():\r\n\r\n	arr = [1, 3, 7]\r\n\r\n	for i in arr:\r\n\r\n		yield i\r\n\r\n	for i in Lst137():\r\n\r\n		for j in arr:\r\n\r\n			yield i * 10 + j\r\n\r\n\r\n\r\ndef take(n, s):\r\n\r\n	i = 0\r\n\r\n	ret = []\r\n\r\n	for x in s:\r\n\r\n		if (i == n): return ret\r\n\r\n		i += 1\r\n\r\n		ret.append(x)\r\n\r\n\r\n\r\nprint take(15, Lst137())\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7109,83,'1835693','2013-10-30 15:30:33',1,'using System.IO;\r\nusing System;\r\nusing System.Collections.Generic;\r\n\r\nclass Program\r\n{\r\n    public static IEnumerable<int> Lst137()\r\n    {\r\n        yield return 1;\r\n        yield return 3;\r\n        yield return 7;\r\n        foreach (int i in Lst137())\r\n        {\r\n            yield return 10 * i + 1;\r\n            yield return 10 * i + 3;\r\n            yield return 10 * i + 7;\r\n        }\r\n    }\r\n    \r\n    static void Main()\r\n    {\r\n        int i = 0;\r\n        const int max = 100;\r\n        foreach (int x in Lst137())\r\n        {\r\n            if (i > max) {\r\n                return;\r\n            }\r\n            Console.WriteLine(x);\r\n            i++;\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7108,79,'1835693','2013-10-30 15:26:20',2,'  --- Во первых, программа должна _вводить_ число, а у вас 7 забито прямо в digits/\r\n  --- Во вторых, более существенно, у вас начиная примерно с 15 знака вместо периода 1 2 3 8 5 7\r\n  --- начинает печататься что-то совсем другое, вы не обратили внимение?\r\n  --- И понятно почему, вы ищете цифры числе 1.0/7 тип double. А это вовсе не настоящая дробь 1/7,\r\n  --- это ее приближение с той точностью, которая доступна double (как раз 15 знаков)\r\n  --- Те тут надо как-то считаь цифры дроби не используюя double, работая только с целыми\r\nusing System.IO;\r\nusing System;\r\nusing System.Collections.Generic;\r\n\r\nclass Program\r\n{\r\n    public static IEnumerable<int> digits(int number)\r\n    {\r\n        for (int i = 1; ; i++)\r\n        {\r\n            yield return (int) ((1.0 / 7) * Math.Pow(10, i) % 10);\r\n        }\r\n    }\r\n    \r\n    static void Main()\r\n    {\r\n        int i = 0;\r\n        const int max = 100;\r\n        const int n = 7;\r\n        foreach (double x in digits(7))\r\n        {\r\n            if (i > max) {\r\n                return;\r\n            }\r\n            Console.Write(x);\r\n            Console.Write(\" \");\r\n            i++;\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7107,80,'1835693','2013-10-30 15:12:45',1,'using System.IO;\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\n// Я не совсем понял, как передавать Tuple. Пойдет ли такое решение?\r\n   --- ОК, пойдет, хорошая идея. Но Tuple тоже бы работало, просто в описании блока итераторов\r\n   --- надо указать параметры Tuple в угловых скобках:  public static IEnumerable<Tuple<int,int>> tuples()\r\n\r\nclass Program\r\n\r\n{\r\n\r\n    //public static IEnumerable<Tuple> tuples()\r\n\r\n    public static IEnumerable<double> tuples()\r\n\r\n    {\r\n\r\n        for (int i = 1; ; i++)\r\n\r\n        {\r\n\r\n            for (int j = 1; j < i; j++)\r\n\r\n            {\r\n\r\n                //yield return Tuple.Create(i, j);\r\n\r\n                //yield return Tuple.Create(j, i);\r\n\r\n                yield return j;\r\n\r\n                yield return i;\r\n\r\n                yield return i;\r\n\r\n                yield return j;\r\n\r\n            }\r\n\r\n            //yield return Tuple.Create(i, i);\r\n\r\n            yield return i;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    \r\n\r\n    static void Main()\r\n\r\n    {\r\n\r\n        int i = 0;\r\n\r\n        const int max = 99;\r\n\r\n        //foreach (Tuple x in tuples())\r\n\r\n        foreach (double x in tuples())\r\n\r\n        {\r\n\r\n            if (i > max) {\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            //Console.WriteLine(\"({0}, {1})\", x.Item1, x.Item2);\r\n\r\n            if (i % 2 == 0) {\r\n\r\n                Console.Write(\"(\");\r\n\r\n                Console.Write(x);\r\n\r\n            } else {\r\n\r\n                Console.Write(\", \");\r\n\r\n                Console.Write(x);\r\n\r\n                Console.WriteLine(\")\");\r\n\r\n            }\r\n\r\n            i++;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n','<br/>Тесты успешно пройдены!'),(7106,82,'517309','2013-10-30 15:04:33',3,'countDifferentVars [] ys =length(toSet ys)\r\ncountDifferentVars (x:xs) ys = \r\n if (fst x) == (snd x) then countDifferentVars xs ys\r\n	else countDifferentVars (changePattern x xs) (filter (/=(snd x)) ys)\r\n\r\ntoSet [] = []\r\ntoSet (x:xs) = x:(toSet (filter (/=x) xs))\r\n\r\nchangePattern (x,y) xs = map ((a,b) -> (if a==y then x else a, if b==y then x else b)) xs','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(7105,76,'6053606','2013-10-30 14:38:58',1,'class Shape a where\r\n  area :: a -> Double\r\n  perim :: a -> Double\r\n  contains :: a -> Double -> Double -> Bool\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where\r\n  area (Rect a b _ _) = a * b\r\n  perim (Rect a b _ _) = 2 * (a + b)\r\n  contains (Rect a b x0 y0) x y =\r\n    abs (x - x0) <= (a / 2) && abs (y - y0) <= (b / 2)\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n  area (Circle r _ _) = 3.14 * r * r\r\n  perim (Circle r _ _) = 2 * 3.14 * r\r\n  contains (Circle r x0 y0) x y =\r\n    (x - x0) * (x - x0) + (y - y0) * (y - y0) <= r * r\r\n','<br/>Тесты успешно пройдены!'),(7104,89,'1835693','2013-10-30 14:11:51',1,'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nfoldTree op res Empty          = res\r\nfoldTree op res (Node val l r) = op val foldTreeL\r\n                                 where foldTreeL = foldTree op foldTreeR l\r\n                                       foldTreeR = foldTree op res r\r\n\r\nflatten = foldTree (:) []','<br/>Тесты успешно пройдены!'),(7103,90,'1835693','2013-10-30 13:59:20',1,'import List\r\n\r\nfindSame xs = findSameH (sort xs)\r\n\r\nfindSameH []       = (0, False)\r\nfindSameH [x]      = (0, False)\r\nfindSameH (x:y:xs) = if (x == y)\r\n                     then (x, True)\r\n                     else findSameH (y:xs)','<br/>Тесты успешно пройдены!'),(7102,86,'1835693','2013-10-30 13:51:31',1,'allNondivisible xs = allNondivisibleH xs (	 -> True)\r\n\r\nallNondivisibleH []     cond = True\r\nallNondivisibleH (x:xs) cond = if (not $ cond x)\r\n                               then False\r\n                               else allNondivisibleH xs (	 -> cond t && mod t x /= 0 && mod x t /= 0)','<br/>Тесты успешно пройдены!'),(7101,85,'1835693','2013-10-30 13:41:50',1,'-- update: заменил Ration на Rat\r\n-- update2: перечитал задание и переделал show :)\r\ndata Rat = Rat Double Double\r\n\r\ninstance Eq Rat where\r\n  (Rat x1 y1) == (Rat x2 y2) = (x1 / y1) == (x2 / y2)\r\n  \r\ninstance Show Rat where\r\n  show (Rat x y) = show (truncate x) ++ \"/\" ++ show (truncate y)\r\n\r\ninstance Num Rat where\r\n  (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n  \r\ninstance Ord Rat where\r\n  (Rat x1 y1) < (Rat x2 y2) = (x1 / y1) < (x2 / y2)','<br/>Тесты успешно пройдены!'),(7100,85,'1835693','2013-10-30 13:35:43',2,'--- вы show определяете вовсе не так, как в условии - посмотрите внимательно пожалуйста.\r\n-- update: заменил Ration на Rat\r\ndata Rat = Rat Double Double\r\n\r\ninstance Eq Rat where\r\n  (Rat x1 y1) == (Rat x2 y2) = (x1 / y1) == (x2 / y2)\r\n  \r\ninstance Show Rat where\r\n  show (Rat x y) = show $ x / y\r\n\r\ninstance Num Rat where\r\n  (Rat x1 y1) + (Rat x2 y2) = Rat (x1 * y2 + x2 * y1) (y1 * y2)\r\n  \r\ninstance Ord Rat where\r\n  (Rat x1 y1) < (Rat x2 y2) = (x1 / y1) < (x2 / y2)','Выражение имеет неправильное значение: Rat 1 2 + Rat 1 7'),(7096,80,'6053606','2013-10-30 12:52:31',1,'#python\r\n\r\nimport itertools\r\n\r\ndef cantor():\r\n    for n in itertools.count(1):\r\n        for a in xrange(1, n):\r\n            yield (a, n - a)\r\n\r\nprint(list(itertools.islice(cantor(), 100)))\r\n','<br/>Тесты успешно пройдены!'),(7097,135,'1835693','2013-10-30 13:06:19',1,'superMap op [] = []\r\nsuperMap op (x:xs) = (op x) ++ superMap op xs','<br/>Тесты успешно пройдены!'),(7098,76,'1835693','2013-10-30 13:21:53',1,'data Rect   = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\nclass Shape a where\r\n  area     :: a -> Double\r\n  perim    :: a -> Double\r\n  contains :: a -> Double -> Double -> Bool\r\n  \r\ninstance Shape Rect where\r\n  area     (Rect x y cx cy)       = x * y\r\n  perim    (Rect x y cx cy)       = 2 * (x + y)\r\n  contains (Rect x y cx cy) px py = (abs (px - cx) <= x / 2) && (abs (py - cy) <= y / 2)\r\n\r\ninstance Shape Circle where\r\n  area     (Circle r cx cy)       = pi * r * r\r\n  perim    (Circle r cx cy)       = 2 * pi * r\r\n  contains (Circle r cx cy) px py = (px - cx) ^ 2  + (py - cy) ^ 2 <= r ^ 2\r\n','<br/>Тесты успешно пройдены!'),(7099,85,'1835693','2013-10-30 13:34:58',0,'data Ration = Ration Double Double\r\n\r\ninstance Eq Ration where\r\n  (Ration x1 y1) == (Ration x2 y2) = (x1 / y1) == (x2 / y2)\r\n  \r\ninstance Show Ration where\r\n  show (Ration x y) = show $ x / y\r\n\r\ninstance Num Ration where\r\n  (Ration x1 y1) + (Ration x2 y2) = Ration (x1 * y2 + x2 * y1) (y1 * y2)\r\n  \r\ninstance Ord Ration where\r\n  (Ration x1 y1) < (Ration x2 y2) = (x1 / y1) < (x2 / y2)','Не удалось вычислить выражение \"Rat 1 2 + Rat 1 7\", проверьте правильность синтаксиса'),(7095,82,'egeorge','2013-10-30 11:18:27',2,'    --- Что-то у вас не то, хотя так сразу не могу сказать, в чем проблема.\r\n    --- Но могу дать совет:) Я бы советовал сначала обработать _все_ правила и выяснить, \r\n    --- какие переменные равны между собой,\r\n    --- а потом уже считать переменные в списке\r\ncountDifferentVars xs ys = let zs = reduceRight xs (reduceLeft xs ys)\r\n                           in if sum (zipWith (x y -> if x == y then 0 else 1) zs ys) == 0\r\n                              then countDifferent ys\r\n                              else countDifferentVars xs zs\r\n\r\nremoveEl [] _ = []\r\nremoveEl (x:xs) el = (if x == el\r\n                      then (removeEl xs el)\r\n                      else (x:(removeEl xs el)))\r\n\r\ncountDifferent [] = 0;\r\ncountDifferent (x:xs) = 1 + countDifferent (removeEl xs x)\r\n\r\nreduceLeft [] ys = ys\r\nreduceLeft ((a,b):xs) ys = reduceLeft xs \r\n                          (map (x -> if x == a \r\n                                      then b\r\n                                      else x)\r\n                               ys)\r\n\r\nreduceRight [] ys = ys\r\nreduceRight ((a,b):xs) ys = reduceLeft ((b,a):xs) ys','Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]'),(7093,135,'517309','2013-10-30 10:32:19',3,'superMap f xs = concat $ map f xs','<br/>Тесты успешно пройдены!'),(7094,82,'egeorge','2013-10-30 11:17:17',0,'countDifferentVars xs ys = let zs = reduceRight xs (reduceLeft xs ys)\r\n                           in if sum (zipWith (-) zs ys) == 0\r\n                              then countDifferent ys\r\n                              else countDifferentVars xs zs\r\n\r\nremoveEl [] _ = []\r\nremoveEl (x:xs) el = (if x == el\r\n                      then (removeEl xs el)\r\n                      else (x:(removeEl xs el)))\r\n\r\ncountDifferent [] = 0;\r\ncountDifferent (x:xs) = 1 + countDifferent (removeEl xs x)\r\n\r\nreduceLeft [] ys = ys\r\nreduceLeft ((a,b):xs) ys = reduceLeft xs \r\n                          (map (x -> if x == a \r\n                                      then b\r\n                                      else x)\r\n                               ys)\r\n\r\nreduceRight [] ys = ys\r\nreduceRight ((a,b):xs) ys = reduceLeft ((b,a):xs) ys','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(7091,89,'115753099','2013-10-30 03:20:24',1,'data Tree = Empty | Node Int Tree Tree\r\n\r\nflatten tree = treeToList tree []\r\n\r\ntreeToList Empty accList = accList\r\ntreeToList (Node element left right) accList =\r\n	let r = treeToList right accList\r\n	in element : (treeToList left r)','<br/>Тесты успешно пройдены!'),(7092,82,'egeorge','2013-10-30 03:54:53',0,'countDifferentVars xs ys = let zs = reduceRight xs (reduceLeft xs ys)\r\n                               zsDifferent = countDifferent zs\r\n                               ysDifferent = countDifferent ys\r\n                           in if zsDifferent == ysDifferent\r\n                              then zsDifferent\r\n                              else countDifferentVars xs zs\r\n\r\nremoveEl [] _ = []\r\nremoveEl (x:xs) el = (if x == el\r\n                      then (removeEl xs el)\r\n                      else (x:(removeEl xs el)))\r\n\r\ncountDifferent [] = 0;\r\ncountDifferent (x:xs) = 1 + countDifferent (removeEl xs x)\r\n\r\nreduceLeft [] ys = ys\r\nreduceLeft ((a,b):xs) ys = reduceLeft xs \r\n                          (map (x -> if x == a \r\n                                      then b\r\n                                      else x)\r\n                               ys)\r\n\r\nreduceRight [] ys = ys\r\nreduceRight ((a,b):xs) ys = reduceLeft ((b,a):xs) ys','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(7089,135,'115753099','2013-10-30 03:00:10',1,'superMap f xs = concat $ map f xs','Не удалось вычислить выражение \"superMap f [1,2,3] where f x = [x*x,100*x]\", проверьте правильность синтаксиса'),(7090,90,'115753099','2013-10-30 03:11:51',1,'findSame xs = findSame1 xs\r\n\r\nfindSame1 [] = \"Ooops. All elements are unic\"\r\nfindSame1 (x:xs) =\r\n	if elem x xs then show x ++ \" Found same elements\"\r\n	else findSame1 xs\r\n','<br/>Тесты успешно пройдены!'),(7087,90,'3320654','2013-10-30 02:49:38',1,'findSame (x:xs) = findSame\' (x:xs) (	 -> False)\r\n\r\nfindSame\' [] _ = \"Not found same number\"\r\nfindSame\' (x:xs) cond = if (cond x)\r\n		  then \"First same number is \" ++ show x\r\n		  else findSame\' xs (	 -> cond t || (t == x))','<br/>Тесты успешно пройдены!'),(7088,86,'115753099','2013-10-30 02:57:48',2,'allNondivisible []	   = True\r\nallNondivisible (x:xs) = allNondivisible1 xs [x]\r\n\r\nf x [] = True\r\nf x (y:s) =\r\n	(max x y) `rem` (min x y) /= 0 && f x s\r\n\r\nallNondivisible1 [] s	  = True\r\nallNondivisible1 (x:xs) s =\r\n	f x s && allNondivisible1 xs (x:s)\r\n  --- Нет, это не совсем, то. Имелся в виду прием на слайде 19 из последних слайдов.\r\n  --- Мы вместо списка s испольуем _функцию_ проверки, которую постепенно делаем все сложнее и сложнее.\r\n  --- Те сначала \r\n  --- allNondivisible xs = allNondivisible1 xs (const True)\r\n  --- ну а дальше попробуйте написать по отразцу из слайдов. Если непонятно, напишите письмо, пожалуйста,\r\n  --- обсудим.\r\n','<br/>Тесты успешно пройдены!'),(7086,85,'115753099','2013-10-30 02:42:33',2,'  --- Не совсем правильно, вот такой тест у вас не проходит, например\r\n  ---    Rat (-1) (-2) < Rat 1 3\r\n  --- Исправьте, пожалуста. (А я сейчас добавлю такой тест)\r\ndata Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n	(Rat m1 n1) + (Rat m2 n2) = Rat (m1 * n2 + m2 * n1) (n1 * n2)\r\n	r1 * r2 = Rat 1 1\r\n	r1 - r2 = Rat 1 1\r\n	abs (Rat m n) = Rat m (abs n)\r\n	signum r = 1\r\n	fromInteger r = 1\r\ninstance Ord Ration where\r\n	(Rat m1 n1) < (Rat m2 n2)\r\n		| n1 < 0 && n2 > 0 = True\r\n		| n1 > 0 && n2 < 0 = False\r\n		| otherwise = m1 * n2 < m2 * n1\r\ninstance Eq Ration where\r\n	Rat m1 n1 == Rat m2 n2 =\r\n		m1 * n2 == m2 * n1\r\ninstance Show Ration where\r\n	show (Rat m n) = show m ++ \"/\" ++ show n','<br/>Тесты успешно пройдены!'),(7085,135,'3320654','2013-10-30 02:41:38',1,'superMap _ [] 	= []\r\nsuperMap f (x:xs) 	=  f x ++ superMap f xs','Не удалось вычислить выражение \"superMap f [1,2,3] where f x = [x*x,100*x]\", проверьте правильность синтаксиса'),(7084,135,'3320654','2013-10-30 02:40:56',0,'superMap _ [] 	        = []\r\nsuperMap f (x:xs) 	=  f x ++ superMap f xs','Не удалось вычислить выражение \"superMap f [1,2,3] where f x = [x*x,100*x]\", проверьте правильность синтаксиса'),(7083,86,'3320654','2013-10-30 02:38:51',1,'allNondivisible (x:xs) = allNondivisible\' (x:xs) (	 -> False)\r\n\r\nallNondivisible\' [] _		= True\r\nallNondivisible\' (x:xs) cond 	= if (cond x) \r\n			   then False\r\n			   else allNondivisible\' xs (	 -> cond t || ((mod x t) == 0) || ((mod t x) == 0))','<br/>Тесты успешно пройдены!'),(7082,85,'115753099','2013-10-30 02:38:10',0,'data Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n	(Rat m1 n1) + (Rat m2 n2) = Rat (m1 * n2 + m2 * n1) (n1 * n2)\r\n	r1 * r2 = Rat 1 1\r\n	r1 - r2 = Rat 1 1\r\n	abs r = Rat 1 1\r\n	signum r = 1\r\n	fromInteger r = 1\r\ninstance Ord Ration where\r\n	(Rat m1 n1) < (Rat m2 n2) = m1 * n2 < m2 * n1\r\n	--abs r = Rat 1 1\r\ninstance Eq Ration where\r\n	Rat m1 n1 == Rat m2 n2 =\r\n		m1 * n2 == m2 * n1\r\ninstance Show Ration where\r\n	show (Rat m n) = show m ++ \"/\" ++ show n\r\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7081,135,'6053606','2013-10-30 02:35:37',1,'--- К предыдущей посылке:\r\n--- *Main> superMap f [1,2,3] where f x = [x*x,100*x]\r\n\r\n--- <interactive>:123:20: parse error on input `where\'\r\n--- *Main> let f x = [x * x, 100 * x]\r\n--- *Main> superMap f [1,2,3]\r\n--- [1,100,4,200,9,300]\r\n\r\n--- Сама посылка:\r\n--- В условии потерялся \"\": superMap (x -> [x*x, 100*x]) [1,2,3]\r\n--- вместо superMap (x -> [x*x, 100*x]) [1,2,3]\r\n\r\nsuperMap f = concat . map f','Не удалось вычислить выражение \"superMap f [1,2,3] where f x = [x*x,100*x]\", проверьте правильность синтаксиса'),(7079,85,'6053606','2013-10-30 02:26:01',1,'data Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n  Rat a b + Rat c d =\r\n    let g = gcd b d\r\n        m = b `div` g\r\n        n = d `div` g\r\n    in\r\n    Rat (a * n + c * m)  (m * n * g)\r\n\r\nreduce (Rat a b) =\r\n  let g = gcd a b in\r\n  Rat (signum b * a `div` g) (abs b `div` g)\r\n\r\n\r\ninstance Eq Ration where\r\n  r1 == r2 = a1 == a2 && b1 == b2 where\r\n    Rat a1 b1 = reduce r1\r\n    Rat a2 b2 = reduce r2\r\n\r\ninstance Ord Ration where\r\n  compare r1 r2 =\r\n    let Rat a1 b1 = reduce r1\r\n        Rat a2 b2 = reduce r2\r\n    in compare (a1 * b2) (a2 * b1)\r\n\r\ninstance Show Ration where\r\n  show (Rat a b) = show a ++ \"/\" ++ show b\r\n','<br/>Тесты успешно пройдены!'),(7080,135,'6053606','2013-10-30 02:31:38',0,'--- В условии потерялся \"\": superMap (x -> [x*x, 100*x]) [1,2,3]\r\n--- вместо superMap (x -> [x*x, 100*x]) [1,2,3]\r\n\r\nsuperMap f = concat . map f\r\n','Не удалось вычислить выражение \"superMap f [1,2,3] where f x = [x*x,100*x]\", проверьте правильность синтаксиса'),(7078,76,'115753099','2013-10-30 02:24:55',1,'data Rect = Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\nclass Shape a where\r\n	area	 :: a -> Double\r\n	perim	 :: a -> Double\r\n	contains :: a -> Double -> Double -> Bool\r\n\r\ninstance Shape Rect where\r\n	area	 (Rect x y _ _) = x * y\r\n	perim	 (Rect x y _ _) = 2 * (x + y)\r\n	contains (Rect x y oX oY) tX tY\r\n		| (oX + a >= tX) && (oY + b >= tY)\r\n			&& (oX - a <= tX) && (oY - b <= tY) \r\n			= True\r\n		| otherwise = False\r\n		where\r\n			a = x / 2\r\n			b = y / 2\r\n\r\ninstance Shape Circle where\r\n	area	 (Circle r _ _) = 3.14 * r *r\r\n	perim	 (Circle r _ _) = 2 * 3.14 * r\r\n	contains (Circle r x y) i j =\r\n		(x - i) * (x - i) + (y - j) * (y - j) <= r * r\r\n','<br/>Тесты успешно пройдены!'),(7077,85,'3320654','2013-10-30 02:19:36',1,'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n  (Rat x y) + (Rat z w) = Rat (x * w + z * y) (y * w)\r\n\r\ninstance Eq Ration where\r\n  (Rat x y) == (Rat z w) = x * w == z * y\r\n\r\ninstance Show Ration where\r\n  show (Rat x y) = show x ++ \"/\" ++ show y\r\n\r\ninstance Ord Ration where\r\n  (Rat x y) < (Rat z w) = if ((x * y < 0) && (z * w > 0))\r\n		  then True\r\n		  else	if ((x * y < 0) && (z * w < 0))\r\n			then  abs (x * w) < abs (z * y)\r\n			else	if ((x * y > 0) && (z * w > 0))\r\n				then abs (x * w) < abs (z * y)\r\n				else False','<br/>Тесты успешно пройдены!'),(7076,85,'6053606','2013-10-30 02:15:49',0,'data Ration = Rat Int Int\r\n\r\ninstance Num Ration where\r\n  Rat a b + Rat c d =\r\n    let g = gcd b d\r\n        m = b `div` g\r\n        n = d `div` g\r\n    in\r\n    Rat (a * n + c * m)  (m * n * g)\r\n\r\nreduce (Rat a b) =\r\n  let g = gcd a b in\r\n  Rat (a `div` g) (b `div` g)\r\n\r\n\r\ninstance Eq Ration where\r\n  r1 == r2 = a1 == a2 && b1 == b2 where\r\n    Rat a1 b1 = reduce r1\r\n    Rat a2 b2 = reduce r2\r\n\r\ninstance Ord Ration where\r\n  compare r1 r2 =\r\n    let Rat a1 b1 = reduce r1\r\n        Rat a2 b2 = reduce r2\r\n    in compare (a1 * b2) (a2 * b1)\r\n\r\ninstance Show Ration where\r\n  show (Rat a b) = show a ++ \"/\" ++ show b\r\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7075,85,'3320654','2013-10-30 02:08:28',0,'data Ration = Rat Integer Integer\r\n\r\ninstance Num Ration where\r\n  (Rat x y) + (Rat z w) = Rat (x * w + z * y) (y * w)\r\n\r\ninstance Eq Ration where\r\n  (Rat x y) == (Rat z w) = x * w == z * y\r\n\r\ninstance Show Ration where\r\n  show (Rat x y) = show x ++ \"/\" ++ show y\r\n\r\ninstance Ord Ration where\r\n  (Rat x y) < (Rat z w) = (x * w) < (z * y)','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Числа ведь могут быть и отрицательными...'),(7074,76,'6053606','2013-10-30 01:43:25',2,'class Shape a where\r\n  area :: a -> Double\r\n  perim :: a -> Double\r\n  contains :: a -> Double -> Double -> Bool\r\n\r\ndata Rect = Rect Double Double Double Double\r\n\r\ninstance Shape Rect where\r\n  area (Rect a b _ _) = a * b\r\n  perim (Rect a b _ _) = 2 * (a + b)\r\n  contains (Rect a b x0 y0) x y =\r\n    abs (x - x0) <= (a / 2) && abs (y - y0) <= (b / 2)\r\n\r\ndata Circle = Circle Double Double Double\r\n\r\ninstance Shape Circle where\r\n  area (Circle r _ _) = 3.14 * r * r\r\n  perim (Circle r _ _) = 2 * 3.14 * r\r\n  contains (Circle r x0 y0) x y =\r\n    abs (x - x0) <= r && abs (y - y0) <= r\r\n       --- ??? Это не совсем правильно :) \r\n       --- Исправьте, пожалуйста (а я сейчас добавлю текой тест)\r\n','<br/>Тесты успешно пройдены!'),(7073,76,'3320654','2013-10-30 01:22:54',1,'class Shape a where\r\n  area 	:: a -> Double\r\n  perim 	:: a -> Double\r\n  contains	:: a -> Double -> Double -> Bool\r\n\r\ndata Rect 	= Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\n-- принадлежит точка прямоугольнику или нет\r\n-- зависит от его расположения, не только от центра\r\ninstance Shape Rect where\r\n  area (Rect x y _ _) 		= x * y\r\n  perim (Rect x y _ _)		= 2 * (x + y)\r\n  contains (Rect a b x y) z w 	= ((z - x) * (z - x) + (w - y) * (w - y)) <= (a * a + b * b) / 4\r\n     --- Имеется в виду, что сторонны параллельны осям координат. (Точно так же, как например\r\n     --- это подразумевают стандарные функции рисования прямоугольника практичекси во всех графических\r\n     --- библиотеках) Но ОК, неважно, засчитано..\r\n\r\ninstance Shape Circle where\r\n  area (Circle r _ _)		= 3.14 * r * r\r\n  perim (Circle r _ _)		= 2 * 3.14 * r\r\n  contains (Circle r x y) z w 	= ((z - x) * (z - x) + (w - y) * (w - y)) <= (r * r)','<br/>Тесты успешно пройдены!'),(7072,76,'3320654','2013-10-30 01:18:14',0,'class Shape a where\r\n  area 	:: a -> Double\r\n  perim 	:: a -> Double\r\n  contains	:: a -> Double -> Double -> Bool\r\n\r\ndata Rect 	= Rect Double Double Double Double\r\ndata Circle = Circle Double Double Double\r\n\r\n-- принадлежит точка прямоугольнику или нет\r\n-- зависит от его расположения, не только от центра\r\ninstance Shape Rect where\r\n  area (Rect x y _ _) 		= x * y\r\n  perim (Rect x y _ _)		= 2 * (x + y)\r\n  contains (Rect a b x y) z w 	= (z * z + w * w) <= (a * a + b * b) / 4\r\n\r\ninstance Shape Circle where\r\n  area (Circle r _ _)		= 3.14 * r * r\r\n  perim (Circle r _ _)		= 2 * 3.14 * r\r\n  contains (Circle r x y) z w 	= (z * z + w * w) <= (r * r)','Выражение имеет неправильное значение: contains (Rect 3 7 20 20) 0 0'),(7068,78,'6053606','2013-10-30 00:01:23',1,'pascal = [1] : [go r | r <- pascal] where\r\n  go r = 1 : [a + b | (a, b) <- zip r (tail r)] ++ [1]\r\n','<br/>Тесты успешно пройдены!'),(7069,80,'6053606','2013-10-30 00:07:51',2,'# python\r\n\r\ndef cantor():\r\n    for n in itertools.count(1):\r\n        for a in xrange(1, n):\r\n            yield (a, n - a)\r\n\r\n--- В задачаз на обычном языке всегда подразуменвается, что надо еще написать пример вызова \r\n--- (в данном случае, например, напечатать первые 100 пар)\r\n--- Я совсем не сомневаюсь. что вы это можете сделать, но добавьте пример вызова, пожалуйста.\r\n','<br/>Тесты успешно пройдены!'),(7070,79,'6053606','2013-10-30 00:23:57',1,'# python \r\n\r\nimport itertools\r\n\r\ndef digits(n):\r\n    acc, order = 0, 10\r\n    while True:\r\n        c = next(itertools.dropwhile(lambda c: (acc + c) * n <= order,\r\n                                     xrange(1, 11)))\r\n        yield c - 1\r\n        acc = (acc + c - 1) * 10\r\n        order *= 10\r\n\r\nif __name__ == \"__main__\":\r\n    n = input(\"n = \")\r\n    print(list(itertools.islice(digits(n), 100)))\r\n','<br/>Тесты успешно пройдены!'),(7071,82,'6053606','2013-10-30 01:00:33',2,'import Data.List (delete, nub)\r\n\r\ncountDifferentVars ps vars = go ps $ nub vars\r\n\r\ngo [] vars = length vars\r\ngo ((x, y):rest) vars =\r\n  if x `elem` vars\r\n  then countDifferentVars rest $ delete x vars\r\n  else countDifferentVars rest $ delete y vars\r\n    --- Это не совсем то.. Например, почему else часть у вас такая, не очень понятно..\r\n    --- Но я бы вообще советовал сначала обработать _все_ правила и выяснить, какие переменные равны между собой,\r\n    --- а потом уже считать переменные в списке\r\n','Выражение имеет неправильное значение: countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]'),(7066,20,'48167667','2013-10-29 22:59:45',2,'sumfact 0 = 0\r\nsumfact n = sumfact (n-1) + fact n\r\nfact 1 = 1\r\nfact n = fact (n-1) * n','<br/>Тесты успешно пройдены!'),(7067,77,'6053606','2013-10-29 23:40:51',1,'sqrt2 = go 0 1 where\r\n  go acc order =\r\n    let (c:_) = dropWhile (c -> sqr (acc + c) <= 2 * sqr order) [1..10]\r\n    in c - 1 : go (acc * 10  + (c - 1) * 10) (order * 10)\r\n\r\n  sqr x = x * x\r\n','<br/>Тесты успешно пройдены!'),(7064,19,'48167667','2013-10-29 21:30:19',0,'sumsin n = sin (a n) / (b n 0)  \r\na 0 = 0\r\na n = n+a (n-1)\r\nb 0 s = s \r\nb n s = b (n-1) (s+sin n)','<br/>Тесты успешно пройдены!'),(7065,19,'48167667','2013-10-29 21:30:33',2,'sumsin n = sin (a n) / (b n 0)  \r\na 0 = 0\r\na n = n+a (n-1)\r\nb 0 s = s \r\nb n s = b (n-1) (s+sin n)','<br/>Тесты успешно пройдены!'),(7062,19,'48167667','2013-10-29 21:29:12',0,'sumsin n = sin (sum n) / a n 0  \r\nsum 0 = 0\r\nsum n = n+sum (n-1)\r\na 0 s = s \r\na n s = a (n-1) (s+sin n)','Не удалось вычислить выражение \"sumsin 1\", проверьте правильность синтаксиса'),(7063,19,'48167667','2013-10-29 21:29:25',0,'sumsin n = sin (sum n) / (a n 0)  \r\nsum 0 = 0\r\nsum n = n+sum (n-1)\r\na 0 s = s \r\na n s = a (n-1) (s+sin n)','Не удалось вычислить выражение \"sumsin 1\", проверьте правильность синтаксиса'),(7060,24,'48167667','2013-10-29 21:12:37',2,'b n = b_ n n\r\nb_ 0 p = p\r\nb_ n p = b_ (n-1) (n-1+1/p) ','<br/>Тесты успешно пройдены!'),(7061,19,'48167667','2013-10-29 21:12:45',2,'b n = b_ n n\r\nb_ 0 p = p\r\nb_ n p = b_ (n-1) (n-1+1/p) ','Не удалось вычислить выражение \"sumsin 1\", проверьте правильность синтаксиса'),(7058,24,'48167667','2013-10-29 21:12:02',0,'b n = b_ n n\r\nb_ 0 p = p\r\nb_ n p = b_ (n-1) (n-1+2+1/p) ','Выражение имеет неправильное значение: let res = b 3 in res > 0.6999 && res < 0.7001'),(7059,24,'48167667','2013-10-29 21:12:16',0,'b n = b_ n n\r\nb_ 0 p = p\r\nb_ n p = b_ (n-1) (n-1+1/p) ','<br/>Тесты успешно пройдены!'),(7057,24,'48167667','2013-10-29 21:11:53',0,'b n = b_ n n\r\nb_ 0 p = p\r\nb_ n p = b_ (n-1) (n-1+1/p) ','<br/>Тесты успешно пройдены!'),(7055,24,'48167667','2013-10-29 21:10:12',0,'b n = b` n n\r\nb` 0 p = p\r\nb` n p = b` (n-1) (n-1+2+1/p) ','Не удалось вычислить выражение \"let res = b 3 in res > 0.6999 && res < 0.7001\", проверьте правильность синтаксиса'),(7056,24,'48167667','2013-10-29 21:10:28',0,'b n = b` n n\r\nb` 0 p = p\r\nb` n p = b` (n-1) (n-1+1/p) ','Не удалось вычислить выражение \"let res = b 3 in res > 0.6999 && res < 0.7001\", проверьте правильность синтаксиса'),(7054,83,'SNNatalieS','2013-10-29 20:43:09',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _23_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<int> Lst137()\r\n        {\r\n            yield return 1;\r\n            yield return 3;\r\n            yield return 7;\r\n            foreach (int i in Lst137())\r\n            {\r\n                yield return 10 * i + 1;\r\n                yield return 10 * i + 3;\r\n                yield return 10 * i + 7;\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            var g = Lst137();\r\n            var rt = g.GetEnumerator();\r\n            Console.WriteLine(\"Please, type an integer!\");\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n            for (int i = 0; i < n; i++)\r\n            {\r\n                if (rt.MoveNext())\r\n                {\r\n                    Console.WriteLine(rt.Current);\r\n                }\r\n            }\r\n            \r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7053,18,'48167667','2013-10-29 20:37:37',2,'f 0 = 1\r\nf n = 1+1/f (n-1) ','<br/>Тесты успешно пройдены!'),(7052,18,'48167667','2013-10-29 20:37:27',0,'f 0 = 1\r\nf n = 2+1/f (n-1) ','Выражение имеет неправильное значение: f 1'),(7051,18,'48167667','2013-10-29 20:37:00',1,'f 0 = 1\r\nf n = 1+1/f (n-1) ','<br/>Тесты успешно пройдены!'),(7049,18,'48167667','2013-10-29 20:31:31',0,'f 0 = 1\r\nf n = 1 + 1 / fun (n-1) ','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(7050,18,'48167667','2013-10-29 20:32:01',0,'f 0 = 1\r\nf n = 1+1/fun (n-1) ','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(7048,18,'48167667','2013-10-29 20:30:17',0,'f 0 = 1\r\nf n = 1 + 1  fun (n-1) ','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(7047,18,'48167667','2013-10-29 20:30:00',0,'fun 0 = 1\r\nfun n = 1 + 1  fun (n-1) ','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(7046,82,'egeorge','2013-10-29 20:07:37',0,'countDifferentVars xs ys = countDifferent (unif xs ys)\r\n\r\nremoveEl [] _ = []\r\nremoveEl (x:xs) el = (if x == el\r\n                      then (removeEl xs el)\r\n                      else (x:(removeEl xs el)))\r\n\r\ncountDifferent [] = 0;\r\ncountDifferent (x:xs) = 1 + countDifferent (removeEl xs x)\r\n\r\nunif [] ys = ys\r\nunif ((a,b):xs) ys = unif xs \r\n                          (map (x -> if x == a \r\n                                      then b\r\n                                      else x)\r\n                               ys)','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(7045,93,'egeorge','2013-10-29 18:25:10',1,'ham = ham\' [-1]\r\n\r\nham\' xs = let (el, (i, j)) = next xs (-1) (0, 0) 0\r\n          in el:(ham\' (modify xs j))\r\n\r\nmodify xs j = zipWith (x index -> if (index == j)\r\n                                   then (x + 1)\r\n                                   else x)\r\n                      xs\r\n                      [0..] ++ (if (j == (length xs - 1)) then [-1] else [])\r\n\r\nnext [] el index _ = (el, index)\r\n\r\nnext (i:xs) minEl index j = let t = (3^(i+1))*(10^j)\r\n                            in if ((t < minEl) || (minEl == (-1)))\r\n                               then (next xs t (i, j) (j+1))\r\n                               else (next xs minEl index (j+1))','<br/>Тесты успешно пройдены!'),(7044,78,'artem.gomerman','2013-10-29 15:46:21',1,'pascal = [1]:(map (xs -> zipWith (+) (0:xs) (xs++[0])) pascal)\r\n','<br/>Тесты успешно пройдены!'),(7033,79,'15309342','2013-10-29 10:53:02',1,'using System.IO;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nclass Program\r\n{\r\n    public static IEnumerable<int> digits(int n)\r\n    {\r\n        int a = 1;\r\n        int b = n;\r\n        int dig = 0;\r\n        for (int i = 0; ; ++i) {\r\n            a = (a - b * dig) * 10;\r\n            dig = a / b;\r\n            yield return dig;\r\n        }\r\n    }\r\n    static void Main()\r\n    {\r\n        int n = 7;\r\n        Console.WriteLine(\"Enter n in 1 / n\");\r\n        n = Console.ReadLine();\r\n   --- Вот это не комипилируется вообще-то :(\r\n        int counter = 1;\r\n        foreach (int dig in digits(n)) {\r\n            if (counter > 100) {\r\n                break;\r\n            }\r\n            Console.WriteLine(dig);\r\n            counter++;\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7034,83,'15309342','2013-10-29 11:13:47',1,'using System.IO;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nclass Program\r\n{\r\n    public static IEnumerable<int> lst137()\r\n    {\r\n        yield return 1;\r\n        yield return 3;\r\n        yield return 7;\r\n        foreach (int i in lst137()) {\r\n            yield return i * 10 + 1;\r\n            yield return i * 10 + 3;\r\n            yield return i * 10 + 7;\r\n        }\r\n    }\r\n    static void Main()\r\n    {\r\n        int counter = 1;\r\n        foreach (int n in lst137()) {\r\n            if (counter > 20) {\r\n                break;\r\n            }\r\n            Console.WriteLine(n);\r\n            counter++;\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7035,82,'15309342','2013-10-29 12:01:08',0,'countDifferentVars [] xs = length xs\r\ncountDifferentVars (y:ys) xs = \r\n                                let \r\n                                    y1 = fst y \r\n                                    y2 = snd y \r\n                                in countDifferentVars (changeRules y1 y2 ys) (changeList y1 y2 xs)\r\n\r\nchangeRules y1 y2 ys = map (y -> changeRule y1 y2 y) ys\r\n\r\nchangeList y1 y2 xs = y2 : (filter (x -> (x /= y1 && x /= y2)) xs)\r\n\r\nchangeRule y1 y2 y | fst y == y1 = (y2, snd y)\r\nchangeRule y1 y2 y | snd y == y1 = (fst y, y2)\r\n                   | otherwise = y','Хитрый тест номер 6 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),(7036,82,'15309342','2013-10-29 12:05:01',1,'countDifferentVars [] xs = length xs\r\ncountDifferentVars ys [] = 0\r\ncountDifferentVars (y:ys) xs = \r\n                                let \r\n                                    y1 = fst y \r\n                                    y2 = snd y \r\n                                in countDifferentVars (changeRules y1 y2 ys) (changeList y1 y2 xs)\r\n\r\nchangeRules y1 y2 ys = map (y -> changeRule y1 y2 y) ys\r\n\r\nchangeList y1 y2 xs = y2 : (filter (x -> (x /= y1 && x /= y2)) xs)\r\n\r\nchangeRule y1 y2 y | fst y == y1 = (y2, snd y)\r\nchangeRule y1 y2 y | snd y == y1 = (fst y, y2)\r\n                   | otherwise = y\r\n','<br/>Тесты успешно пройдены!'),(7037,79,'ArtemK','2013-10-29 12:14:37',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n\r\nnamespace Task\r\n{\r\n	class MainClass\r\n	{\r\n		public static IEnumerable<int> digits(int n)\r\n		{\r\n			int x = 10;\r\n			for (int i = 0; ; i++) {\r\n				if (x < n) {\r\n					yield return 0;\r\n				} \r\n				else {\r\n					yield return (x / n);\r\n					x %= n;\r\n				}\r\n				x *= 10;\r\n			}\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			Console.WriteLine (\"Enter n -> \");\r\n			int n = int.Parse (Console.ReadLine ());\r\n			int count = 0;\r\n			foreach (int i in digits(n)) {\r\n				Console.Write (i + \" \");\r\n				if (++count == 100)\r\n					return;\r\n			}\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7038,78,'ArtemK','2013-10-29 12:18:35',1,'pascal = [1]:(zipWith (xs ys -> 1:zipWith (+) xs (tail ys ++ [0])) pascal pascal)','<br/>Тесты успешно пройдены!'),(7039,93,'115753099','2013-10-29 12:54:57',1,'merge [] xs = xs\r\nmerge ys [] = ys\r\nmerge (y:ys) (x:xs)\r\n	| x > y 	= y : merge ys (x:xs)\r\n	| x < y 	= x : merge (y:ys) xs\r\n	| otherwise = x : merge ys xs\r\n\r\nham =\r\n	1 : merge (map (x -> x * 10) ham) (map (x -> x * 3) ham)','<br/>Тесты успешно пройдены!'),(7040,93,'3270666','2013-10-29 13:49:40',1,'threePowers = 1 : map (*3) threePowers\r\ntenPowers = 1 : map (*10) tenPowers\r\npairs = map (i -> map (* threePowers !! i) tenPowers) [0..]\r\n--next = 0 : next\r\n\r\nprocess n max_i prev = \r\n	let lst = map (i -> head (filter (> prev) (pairs !! i))) [0..max_i]\r\n	    res = minimum lst\r\n	    new_i = if (res >= (threePowers !! max_i))\r\n	    	then max_i + 1\r\n	    	else max_i\r\n	in res : process (n + 1) new_i res\r\n\r\nham = process 1 0 0','<br/>Тесты успешно пройдены!'),(7041,77,'egeorge','2013-10-29 14:32:10',0,'sqrt2 = sqrt2\' 1 2\r\n\r\nsqrt2\' sqrt n = let d = (nextDigit sqrt n 0)\r\n                in d : sqrt2\' ((sqrt + d)*10) (n * 100)\r\n\r\nnextDigit m n k = if ((m + k)^2 < n)\r\n                  then nextDigit m n (k + 1)\r\n                  else (k - 1)','Выражение имеет неправильное значение: take 20 sqrt2'),(7042,77,'egeorge','2013-10-29 14:33:55',1,'sqrt2 = sqrt2\' 0 2\r\n\r\nsqrt2\' sqrt n = let d = (nextDigit sqrt n 0)\r\n                in d : sqrt2\' ((sqrt + d)*10) (n * 100)\r\n\r\nnextDigit m n k = if ((m + k)^2 < n)\r\n                  then nextDigit m n (k + 1)\r\n                  else (k - 1)','<br/>Тесты успешно пройдены!'),(7043,80,'ArtemK','2013-10-29 14:45:27',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n\r\nnamespace Task\r\n{\r\n	class MainClass\r\n	{\r\n		public struct Couple\r\n		{\r\n			public int _1;\r\n			public int _2;\r\n\r\n			public Couple(int x, int y) {\r\n				_1 = x;\r\n				_2 = y;\r\n			}\r\n		}\r\n\r\n		public static IEnumerable<Couple> cantor()\r\n		{\r\n			int x = 1;\r\n			while (true) {\r\n				for (int i = 1; i < x; i++) {\r\n					yield return new Couple (x, i);\r\n					yield return new Couple (i, x);\r\n				}\r\n				yield return new Couple (x, x);\r\n				x++;\r\n			}\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			int count = 0;\r\n			foreach (Couple c in cantor()) {\r\n				Console.Write (\"(\" + c._1 + \", \" + c._2 + \") \");\r\n				if (++count == 100)\r\n					return;\r\n			}\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(7026,79,'3270666','2013-10-28 19:21:48',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FP20_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            int x = 1;\r\n\r\n            if (n == 1) \r\n\r\n            {\r\n\r\n                x = 0;\r\n\r\n            }\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                x *= 10;\r\n\r\n                yield return x / n;\r\n\r\n                x %= n;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.Write(\"Enter n: \");\r\n\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            int count = 0;\r\n\r\n            foreach (int x in digits(n))\r\n\r\n            {\r\n\r\n                Console.Write(x);\r\n\r\n                if (++count <= 100)\r\n\r\n                {\r\n\r\n                    Console.Write(\", \");\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7027,77,'42284313','2013-10-28 21:40:15',0,'{--\r\n\n\r\n\n*Доп. задача, до 31.10*\r\n\n\r\n\nОписать sqrt2 как бесконечный список из чисел от 0 до 9, описывающий разложение sqrt(2) в бесконечную десятичную дробь. \r\n\n\r\n\nПример вызова:\r\n\ntake 20 sqrt2\r\n\n\r\n\nРезультат должен быть равен \r\n\n[1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]\r\n\n\r\n\nЗамечания:\r\n\n- Это, видимо, больше задачка по выч. методам, а не по программированию.. Мне кажется, не очень сложная.\r\n\n- Подсказка: задача не очень сложная, потому что Haskell может выполнять операции над целыми числами любой длины. Тут это удобно.\r\n\n\r\n\n--}\r\n\n\r\n\ncalculateNevaluetDigit value result l r\r\n\n  | l == r || l == r - 1 = if (result + r)^2 < value then r else l\r\n\n  | otherwise =\r\n\n    let\r\n\n      avr = (l+r) `div` 2\r\n\n    in if (result + avr)^2 < value then calculateNevaluetDigit value result avr r else calculateNevaluetDigit value result l avr\r\n\n\r\n\nmySqrt value result = \r\n\n    let\r\n\n      digit = calculateNevaluetDigit value result 0 9\r\n\n    in digit : sqrt (100 * value) (10*(result + digit))\r\n\n\r\n\nsqrt2 = mySqrt 2 0\n','Не удалось вычислить выражение \"take 20 sqrt2\", проверьте правильность синтаксиса'),(7028,77,'42284313','2013-10-28 21:42:18',1,'{--\r\n\r\n\r\n\r\n*Доп. задача, до 31.10*\r\n\r\n\r\n\r\nОписать sqrt2 как бесконечный список из чисел от 0 до 9, описывающий разложение sqrt(2) в бесконечную десятичную дробь. \r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 20 sqrt2\r\n\r\n\r\n\r\nРезультат должен быть равен \r\n\r\n[1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- Это, видимо, больше задачка по выч. методам, а не по программированию.. Мне кажется, не очень сложная.\r\n\r\n- Подсказка: задача не очень сложная, потому что Haskell может выполнять операции над целыми числами любой длины. Тут это удобно.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ncalculateNevaluetDigit value result l r\r\n\r\n  | l == r || l == r - 1 = if (result + r)^2 < value then r else l\r\n\r\n  | otherwise =\r\n\r\n    let\r\n\r\n      avr = (l+r) `div` 2\r\n\r\n    in if (result + avr)^2 < value then calculateNevaluetDigit value result avr r else calculateNevaluetDigit value result l avr\r\n\r\n\r\n\r\nmySqrt value result = \r\n\r\n    let\r\n\r\n      digit = calculateNevaluetDigit value result 0 9\r\n\r\n    in digit : mySqrt (100 * value) (10*(result + digit))\r\n\r\n\r\n\r\nsqrt2 = mySqrt 2 0\r\n','<br/>Тесты успешно пройдены!'),(7029,78,'42284313','2013-10-28 21:48:15',1,'{--\r\n\r\n\r\n\r\n*Доп. задача, до 31.10*\r\n\r\n\r\n\r\nОписать pascal как бесконечный список списков, содержащий треугольник Паскаля. \r\n\r\n\r\n\r\nДополнительное условие: В этой задаче нельзя определять никакие новые функции (кроме pascal). Можно использовать стандартные функции. Можно (и я бы советовал) использовать прием tying the knot. \r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 6 pascal\r\n\r\n\r\n\r\nРезультат должен быть равен \r\n\r\n[[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\npascal = [1]:(zipWith (xs ys -> 1 : zipWith (+) xs (tail ys ++ [0])) pascal pascal)\r\n','<br/>Тесты успешно пройдены!'),(7030,78,'egeorge','2013-10-29 00:21:15',1,'pascal = [1]:map (xs -> (zipWith (+) (0:xs) (xs ++ [0]))) pascal','<br/>Тесты успешно пройдены!'),(7031,78,'1990147','2013-10-29 01:36:10',1,'pascal = [1] : map (i-> (zipWith (+) (0:i) (i++[0]))) pascal \r\n','<br/>Тесты успешно пройдены!'),(7032,77,'15309342','2013-10-29 10:18:03',1,'nextDig x appr dig | ((appr + dig) ^ 2 < x) && dig < 10 = nextDig x appr (dig + 1)\r\n                   | otherwise = dig - 1\r\n\r\nsqrt2appr x appr = dig : sqrt2appr (x * 100) ((appr + dig) * 10) where dig = nextDig x appr 0\r\n\r\nsqrt2 = sqrt2appr 2 0','<br/>Тесты успешно пройдены!'),(7025,93,'15309342','2013-10-28 19:11:16',1,'ham = merge ham1 ham2\r\n\r\nmerge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys) | x > y  = y : merge (x:xs) ys \r\n                    | x == y = x : merge xs ys\r\n                    | x < y  = x : merge xs (y:ys)\r\n\r\nham1 = 1 : (map (*3) ham)\r\nham2 = 1 : (map (*10) ham)','<br/>Тесты успешно пройдены!'),(7024,93,'ilia','2013-10-28 18:54:29',1,'ham = merge pow3lst pow10lst\r\n\r\n\r\n\r\npow3lst = 1 : map (*3) (merge pow3lst pow10lst)\r\n\r\npow10lst = 1 : map (*10) (merge pow10lst pow3lst)\r\n\r\n\r\n\r\nmerge a [] = a\r\n\r\nmerge [] b = b\r\n\r\nmerge a b =\r\n\r\n	let\r\n\r\n		ha = head a\r\n\r\n		hb = head b\r\n\r\n	in\r\n\r\n		if ha < hb then\r\n\r\n			ha : merge (tail a) b\r\n\r\n		else if ha == hb then\r\n\r\n			ha : merge (tail a) (tail b)\r\n\r\n		else \r\n\r\n			hb : merge a (tail b)\r\n\r\n		\r\n\r\n\r\n\r\nmain = print (ham !! 10000)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7023,77,'3320654','2013-10-28 18:40:59',1,'-- нашёл алгоритм в интернете, основанный на выражении \r\n-- (10 * x + y) ^ 2 = 100 * (a ^ 2) + (20 * a + b) * b\r\n-- на каждом шаге, зная \"некоторый остаток\" и первые несколько цифр,\r\n-- есть возможность вычислять след. цифру\r\n-- вавилонский метод (a(i + 1) = a(i) / 2 + 1 / a(i)) куда быстрее,\r\n-- но его сложнее закодить\r\n  --- да, мне тоже кажется, что этот метод больше подходит для приближенного\r\n  --- вычисления, а если нам нужны точные цифры, то проще иц вычислять цифру за цифрой, как у вас\r\nsqrt2 = 1 : help 1 1\r\n\r\nhelp a b = 	let 	newA = 100 * a\r\n			newB = 20 * b\r\n			k = nextDigit newA newB 0\r\n		in k : (help (newA - (newB + k) * k) (b * 10 + k))\r\n\r\nnextDigit a b t = if (b + t) * t < a\r\n		  then nextDigit a b (t + 1)\r\n		  else (t - 1)','<br/>Тесты успешно пройдены!'),(7022,78,'egeorge','2013-10-28 18:30:47',0,'pascal = pascal\' [1]\r\n\r\npascal\' x = x:(pascal\' (zipWith (+) (0:x) (x ++ [0])))','<br/>Тесты успешно пройдены!'),(7020,78,'3270666','2013-10-28 17:15:53',1,'pascal = [1] : map (\r\now -> (1 : zipWith (+) row (tail row)) ++ [1]) pascal','<br/>Тесты успешно пройдены!'),(7021,80,'3270666','2013-10-28 18:24:58',1,'using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FP20_2\r\n\r\n{\r\n\r\n    class Pair\r\n\r\n    {\r\n\r\n        public int _x;\r\n\r\n        public int _y;\r\n\r\n\r\n\r\n        public Pair(int x, int y)\r\n\r\n        {\r\n\r\n            _x = x;\r\n\r\n            _y = y;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static IEnumerable<Pair> Cantor()\r\n\r\n        {\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                int w = Convert.ToInt32(Math.Floor((Math.Sqrt(8 * i + 1) - 1) / 2.0));\r\n\r\n                int t = (w * w + w) / 2;\r\n\r\n                int y = i - t;\r\n\r\n                int x = w - y;\r\n\r\n                yield return new Pair(x + 1, y + 1);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int count = 0;\r\n\r\n            foreach (Pair p in Cantor())\r\n\r\n            {\r\n\r\n                count++;\r\n\r\n                if (count <= 20)\r\n\r\n                {\r\n\r\n                    Console.WriteLine(\"({0}, {1})\", p._x, p._y);\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(7019,77,'3270666','2013-10-28 16:13:14',1,'approx root goal 10 = \r\n	let x = root + 9\r\n	in 9 : approx (x * 10) (goal * 100) 1\r\napprox root goal next = \r\n	let x = root + next\r\n    in if (x * x) <= goal\r\n    	  then approx root goal (next + 1)\r\n    	  else (next - 1) : approx ((x - 1) * 10) (goal * 100) 1\r\n\r\nsqrt2 = approx 0 2 1','<br/>Тесты успешно пройдены!'),(7013,91,'1170660','2013-10-28 09:38:38',0,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n    | x <= y = x : merge xs (y:ys)\r\n    | otherwise = y : merge (x:xs) ys','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(7014,134,'1170660','2013-10-28 10:21:00',1,'   --- ОК, очень хорошо. А, просто интересно, почему вы выбрали такой, все-таки не очень\r\n   --- обычный способ решения? Вы видели его где-нибудь?\r\n   --- Кстати, у нас будет доп задача, как раз решить эту задачу таким хитрым способом, и вы можете\r\n   --- просто выложить это решение еще раз.\r\nallListsModif n 0 check = [[]]\r\n\r\nallListsModif n k check = [ (x:xs) | x <- [1..n], not (check x), xs <- allListsModif n (k-1) (	 -> check t || t == x)]\r\n\r\n\r\n\r\nallDiffLists n k = allListsModif n k (const False)\r\n','<br/>Тесты успешно пройдены!'),(7015,81,'1170660','2013-10-28 10:32:30',1,'list = [1, 3, 7] : (map (xs -> foldl (++) [] (map (x -> [10*x + 1,10*x + 3,10*x + 7]) xs)) list)\r\n\r\nlst137 = foldr(++)[] list\r\n','<br/>Тесты успешно пройдены!'),(7016,91,'1170660','2013-10-28 11:20:28',1,'merge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n    | x==y = x:merge xs ys\r\n\r\n    | x < y = x : merge xs (y:ys)\r\n\r\n    | otherwise = y : merge (x:xs) ys\r\n','<br/>Тесты успешно пройдены!'),(7017,78,'15309342','2013-10-28 11:48:36',1,'pascal = [1] : (map (xs -> zipWith (+) (0 : xs) (xs ++ [0])) pascal)','<br/>Тесты успешно пройдены!'),(7018,80,'15309342','2013-10-28 12:33:32',1,'using System.IO;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nclass Program\r\n{\r\n    public static IEnumerable<KeyValuePair<int, int>> cantor()\r\n    {\r\n        for (int sum = 2; ; ++sum)\r\n            for (int k = 1; k < sum; ++k)\r\n        {\r\n            yield return new KeyValuePair<int, int> (k, sum - k);\r\n        }\r\n    }\r\n    static void Main()\r\n    {\r\n        int counter = 0;\r\n        foreach (KeyValuePair<int, int> pair in cantor()) {\r\n            Console.WriteLine(pair);\r\n            counter++;\r\n            if (counter > 20) {\r\n                break;\r\n            }\r\n            \r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(7010,91,'1170660','2013-10-28 09:36:49',0,'','Не удалось вычислить выражение \"merge [1,4,8] [2,4,5,10,20]\", проверьте правильность синтаксиса'),(7011,91,'1170660','2013-10-28 09:37:09',0,'merge [] ys = ys\r\n\nmerge xs [] = xs\r\n\nmerge (x:xs) (y:ys)\r\n\n    | x <= y = x : merge xs (y:ys)\r\n\n    | otherwise = y : merge (x:xs) ys\n','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(7012,91,'1170660','2013-10-28 09:37:47',0,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n    | x <= y = x : merge xs (y:ys)\r\n    | otherwise = y : merge (x:xs) ys','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(7008,91,'MaryK','2013-10-28 05:34:57',0,'module Func where\r\n\n\r\n\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),take,(<=),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\n\r\n\nmerge ::[Int] -> [Int] -> [Int]\r\n\nmerge [] [] = []\r\n\nmerge [] (c:second) = (c:second)\r\n\nmerge (h:first) [] = (h:first)\r\n\nmerge (h:first) (c:second)  | h <= c = h:merge first (c:second)\r\n\n                | h > c = c:merge (h:first) second \r\n\n\n','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(7009,91,'MaryK','2013-10-28 05:37:31',1,'module Func where\r\n\r\n\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),take,(<=),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\n\r\n\r\nmerge ::[Int] -> [Int] -> [Int]\r\n\r\nmerge [] [] = []\r\n\r\nmerge [] (c:second) = (c:second)\r\n\r\nmerge (h:first) [] = (h:first)\r\n\r\nmerge (h:first) (c:second)  | h == c = h:merge first second | h <= c = h:merge first (c:second)\r\n\r\n                | h > c = c:merge (h:first) second \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(7006,134,'1990147','2013-10-28 03:08:34',1,'allDiffLists n 0 = [[]]\r\n\r\nallDiffLists n k = [i:xs | i<-[1..n], xs<- allDiffLists n (k-1),not (any (j->j==i) xs)]\r\n','<br/>Тесты успешно пройдены!'),(7007,75,'toskira','2013-10-28 03:44:20',1,'a)\r\nтип foldr: (a->b->b)->b->[a]->b\r\n\r\n\r\nb)\r\nfoldr f z []     = z \r\nfoldr f z (x:xs) = f x (foldr f z xs) \r\n\r\nx1 ->x2 ->x3 ->x4\r\n\r\n1)\r\nf - функция с двумя аргументами\r\nx1=(x5 ->x6 ->x7)\r\n(x5 ->x6 ->x7) ->x2 ->x3 ->x4\r\n\r\n(x:xs) - список\r\nx3=[x8]\r\n(x5 ->x6 ->x7) ->x2 ->[x8] ->x4\r\n\r\n2)\r\nx - первый аргумент f\r\nx5=x8\r\n(x5 ->x6 ->x7) ->x2 ->[x5] ->x4\r\n\r\nрезультат foldr совпадает по типу со вторым аргументом f\r\nx4=x7\r\n(x5 ->x6 ->x4) ->x2 ->[x5] ->x4\r\n\r\nрезультат foldr совпадает по типу со своим вторым аргументом\r\nx2=x4\r\n(x5 ->x6 ->x2) ->x2 ->[x5] ->x2\r\n\r\nвторой аргумент функции f совпадает по типу с z, так как результат folder совпадает по типу с z\r\nx6=x2\r\n(x5 ->x2 ->x2) ->x2 ->[x5] ->x2\r\n\r\n\r\nполучили тип:\r\n(a->b->b)->b->[a]->b','<br/>Тесты успешно пройдены!'),(7004,91,'1990147','2013-10-28 02:23:08',1,'merge [] b = b\r\n\r\nmerge a [] = a\r\n\r\nmerge (a:as) (b:bs) = if (a>b) then b:merge (a:as) bs\r\n\r\n                      else if (b>a) then a:merge as (b:bs)\r\n\r\n                      else a:merge as bs\r\n','<br/>Тесты успешно пройдены!'),(7005,134,'1990147','2013-10-28 03:07:34',0,'','Не удалось вычислить выражение \"length (allDiffLists 3 3)\", проверьте правильность синтаксиса'),(7002,81,'1990147','2013-10-28 02:06:42',1,'lst137 = 1 : 3 : 7 : [i*10+j|i<-lst137,j<-[1,3,7]]\r\n','<br/>Тесты успешно пройдены!'),(7003,134,'641524','2013-10-28 02:16:23',1,'allDiffLists n 0 = [[]]\r\n\r\nallDiffLists n k = [x:xs | x<-[1..n], xs<-allDiffLists n (k-1), not(x `elem` xs)]\r\n','<br/>Тесты успешно пройдены!'),(7000,91,'1526701','2013-10-28 01:27:10',1,'merge x [] = x;\r\nmerge [] y = y;\r\nmerge (x:xs) (y:ys)\r\n	| x > y = y:(merge (x:xs) ys)\r\n	| x < y = x:(merge xs (y:ys))\r\n	| otherwise = x:(merge xs ys);','<br/>Тесты успешно пройдены!'),(7001,134,'1526701','2013-10-28 01:36:31',1,'allLists n t 0 = [[]];\r\nallLists n t k = [x:xs | x<-[1..n], notElem x t == True, xs<-allLists n (x:t) (k-1)];\r\n  --- Или условие можно записать просто notElem a t ( == True писать не надо...)\r\nallDiffLists n k = allLists n [] k;','<br/>Тесты успешно пройдены!'),(6999,134,'bazhutin','2013-10-28 01:14:52',1,'allDiffLists n 1 = [ [x] | x <- [1..n]]\r\nallDiffLists n k = [ x:xs |  x <- [1..n], xs <- allDiffLists n (k-1), uniq xs x == 1]\r\n\r\nuniq [] n = 1\r\nuniq (x:xs) n\r\n	| (x == n ) = 0\r\n	| otherwise =  uniq xs n \r\n   --- OK, но логичнее, мне кажется, чтобы uniq возвращала True или False, а не 1 и 0.  ','<br/>Тесты успешно пройдены!'),(6998,91,'bazhutin','2013-10-28 00:50:50',1,'merge [] y = y\r\nmerge x [] = x\r\nmerge (x:xs) (y:ys) \r\n	| (x < y) = x : merge xs (y:ys)\r\n	| (x == y) = x : merge xs ys\r\n	| otherwise = y : merge (x:xs) ys	   ','<br/>Тесты успешно пройдены!'),(6997,83,'5543298','2013-10-28 00:50:32',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"23.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var num in Lst137())\r\n\r\n                        {\r\n\r\n                            Console.Write(\"{0}, \", num);\r\n\r\n                            k++;\r\n\r\n                            if (k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"20.2\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var pair in cantor())\r\n\r\n                        {\r\n\r\n                            Console.WriteLine(pair);\r\n\r\n                            k++;\r\n\r\n                            if (k == 50)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                var next = i * 10;\r\n\r\n                yield return next + 1;\r\n\r\n                yield return next + 3;\r\n\r\n                yield return next + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var resPowN = new BigInteger(0);\r\n\r\n            var left = new BigInteger(1);\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                left *= 10;\r\n\r\n                var min = left - resPowN * 10 * n;\r\n\r\n                var minIndex = 0;\r\n\r\n                for (int j = 1; j < 10; j++)\r\n\r\n                {\r\n\r\n                    var current = left - (resPowN * 10 + j) * n;\r\n\r\n                    if (current < min && current > 0)\r\n\r\n                    {\r\n\r\n                        min = current;\r\n\r\n                        minIndex = j;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                resPowN = resPowN * 10 + minIndex;\r\n\r\n                yield return minIndex;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6996,75,'5543298','2013-10-28 00:36:44',1,'Определение: \r\nfoldr f e [] = e\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\nТип foldr: (a -> b -> b) -> b -> [a] -> b\r\nВывод:\r\n0. x1 -> x2 -> x3 -> x4\r\n1. 	x1 = (x5->x6->x7) Потому что у f тип x1 и f – это функция (видно из f x (foldr f e xs))\r\n	x3 = [x8] Потому что у (x:xs) тип x3\r\n=> (x5->x6->x7) -> x2 -> [x8] -> x4\r\n2. Некоторые x совпадают: \r\n	x5 == x8 Потому что у x тип x8 как у элемента списка [x8] и x5, как у аргумента f\r\n	x4 == x7 Потому что x4 результат foldr, x7 - результат f, и результат foldr является резульатом применения функции f\r\n	x4 == x6 Потому что x4 результат foldr, x6 - аргумент f, получаемый применением foldr\r\n	x2 == x4 Потому что x4 результат foldr, X2 - результат foldr\r\n  ','<br/>Тесты успешно пройдены!'),(6995,75,'egeorge','2013-10-27 23:55:47',1,'foldr f e [] = e\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\n\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\n1) третий аргумент может быть [], значит это список\r\n.. -> .. -> [a] -> ..\r\n2) из первой строки, тип второго аргумента и возвращаемого значения совпадает\r\n.. -> b -> [a] -> b\r\n3) из правой части второй строки, первый аргумент - функция от 2х аргументов\r\n(.. -> .. -> ..) -> b -> [a] -> b\r\n4) из второй строки, тип 1го аргумента f и тип элементов 3го аргумента foldr совпадают (потому что тип оператора : можно записать как a -> [a] -> [a])\r\n(a -> .. -> ..) -> b -> [a] -> b\r\n5) во второй строке, второй аргумент f - результат foldr, значит у 2го аргумента f и у возвращаемого значения foldr один и тот же тип\r\n(a -> b -> ..) -> b -> [a] -> b\r\n6) во второй строке, результата f равняется результату foldr, значит у их возвращаемого значение один и тот же тип\r\n(a -> b -> b) -> b -> [a] -> b','<br/>Тесты успешно пройдены!'),(6994,91,'641524','2013-10-27 23:55:03',1,'merge [] xs = xs\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys) = if x<y then x:(merge (xs) (y:ys)) \r\n\r\n			     else if x==y then y:(merge (xs) (ys))\r\n\r\n					  else y:(merge (x:xs) (ys))\r\n','<br/>Тесты успешно пройдены!'),(6993,75,'nomeansno','2013-10-27 23:51:21',1,'(a->b->b)->b->[a]->b\r\n\r\n\r\n\r\n1. foldr f e [] = e\r\n\r\n2. foldr f e (x:xs) = f x (foldr f e xs)\r\n\r\n\r\n\r\n1 этап:\r\n\r\nx1->x2->x3->x4\r\n\r\nx1=(x5->x6->x7)\r\n\r\nx2=x2\r\n\r\nx3=[x8]\r\n\r\nx4=x4\r\n\r\n2 этап:\r\n\r\nx4==x7 (т.к рез-т foldr - это рез-т f по 2.)\r\n\r\nx5==x8 (т.к (x:xs) = [x8] и x есть в вызове f по 2.)\r\n\r\nx4==x2 (по 1.)\r\n\r\nx6==x4 (т.к (foldr f e xs) есть в вызове f по 2.)\r\n\r\nт.о x4==x7==x6==x2 и x5==x8\r\n\r\n\r\n\r\n \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6992,91,'641524','2013-10-27 23:46:53',0,'merge [] xs = xs\r\n\nmerge xs [] = xs\r\n\nmerge (x:xs) (y:ys) = if x<y then x:(merge xs (y:ys)) else y:(merge (x:xs) (ys))\n','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(6990,134,'62628590','2013-10-27 22:52:15',1,'   --- ОК, очень хорошо. А, просто интересно, почему вы выбрали такой, все-таки не очень\r\n   --- обычный способ решения? Вы видели его где-нибудь?\r\n   --- Кстати, у нас будет доп задача, как раз решить эту задачу таким хитрым способом, и вы можете\r\n   --- просто выложить это решение еще раз.\r\nallDiffLists\' n 0 l = [[]]	\r\nallDiffLists\' n k l= [x:xs | x <- [1..n], xs <- allDiffLists\' n (k-1) (a -> (a==x)||(l a)), not (l x)]\r\nallDiffLists n k = allDiffLists\' n k (const False)','<br/>Тесты успешно пройдены!'),(6991,81,'egeorge','2013-10-27 23:29:06',1,'lst137 = lst137\' [1,3,7]\r\n\r\nlst137\' xs = xs ++ (lst137\' (f xs))\r\n\r\nf xs = zipWith (+) (cycle [1,3,7]) (map (*10) (multElements (length xs) xs))\r\n\r\nmultElements n [] = []\r\nmultElements n (x:xs) = (replicate n x) ++ (multElements n xs)\r\n','<br/>Тесты успешно пройдены!'),(6989,77,'ilia','2013-10-27 22:43:27',1,'sqrt2 = sqrttoarr 2 0\r\n\r\nsqrttoarr x dx = let\r\n\r\n		ds = filter (d -> let dx10d = dx * 10 + d in dx10d * dx10d <= x) [0..9]\r\n\r\n		d = last ds\r\n\r\n	in d : sqrttoarr (x * 100) (10 * dx + d)\r\n\r\n\r\n\r\nmain = print (take 20 sqrt2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6988,134,'ip','2013-10-27 21:52:31',1,'  --- Что-то у вас всегда подлучается [] :(\r\n  --- Но ОК, у нас и не совсем правильные решения засчитываются, так что зачтено. \r\nallDiffLists n 0 = [[]]\r\nallDiffLists n k = aL n k [1..n]\r\n\r\naL n k ys = [x:xs | x<-ys,\r\n                    xs<-aL n (k-1) (e [] ys x)]\r\n\r\n\r\ne xs [] x = xs\r\ne xs (a:ys) x = if (x==a)\r\n                then (xs++ys)\r\n                else (e (xs++[a]) ys x)  ','Выражение имеет неправильное значение: length (allDiffLists 3 3)'),(6987,134,'ip','2013-10-27 21:51:48',0,'allDiffLists n 0 = [[]]\r\nallDiffLists n k = aL n k [1..n]\r\n\r\naL n k ys = [x:xs | x<-ys,\r\n                    xs<-aL n (k-1) (e [] ys x)]\r\n\r\n\r\ne xs [] x = xs\r\ne xs (a:ys) x = if (x==a)\r\n                then (xs++ys)\r\n                else (e (xs++[a]) ys x)  ','Выражение имеет неправильное значение: length (allDiffLists 3 3)'),(6985,134,'ip','2013-10-27 21:48:42',0,'allDiffLists n k = aL n k [1..n]\r\n\r\naL n k ys = [x:xs | x<-ys\r\n          xs<-aL n (k-1) (e [] ys x)]\r\n\r\n\r\ne xs [] x = xs\r\ne xs (a:ys) x = if (x==a)\r\n                then (xs++ys)\r\n                else (e (xs++[a]) ys x)  ','Не удалось вычислить выражение \"length (allDiffLists 3 3)\", проверьте правильность синтаксиса'),(6986,134,'ip','2013-10-27 21:50:15',0,'allDiffLists n k = aL n k [1..n]\r\n\r\naL n k ys = [x:xs | x<-ys,\r\n                    xs<-aL n (k-1) (e [] ys x)]\r\n\r\n\r\ne xs [] x = xs\r\ne xs (a:ys) x = if (x==a)\r\n                then (xs++ys)\r\n                else (e (xs++[a]) ys x)  ','Выражение имеет неправильное значение: length (allDiffLists 3 3)'),(6984,91,'2501950','2013-10-27 21:47:51',1,'merge xs ys = lst\' xs ys\r\nlst\' [] ys = ys\r\nlst\' xs [] = xs\r\nlst\' (x:xs) (y:ys) = if x < y\r\n                      then x : lst\' xs (y:ys) \r\n                      else (if x==y \r\n                            then y : lst\' xs ys\r\n                            else y : lst\' (x:xs) ys) ','<br/>Тесты успешно пройдены!'),(6983,91,'2501950','2013-10-27 21:44:35',0,'merge xs ys = lst\' xs ys\r\nlst\' [] ys = ys\r\nlst\' xs [] = xs\r\nlst\' (x:xs) (y:ys) = if x < y\r\n                      then x : lst\' xs (y:ys) \r\n                      else y : lst\' (x:xs) ys \r\n','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(6982,75,'8519021','2013-10-27 21:39:41',1,'﻿foldr f e [] = e\r\n\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\n\r\n\r\n\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\n\r\n\r\nЭтап 1: \r\n\r\nx1 = (x5 -> x6 -> x7)\r\n\r\n	Потому что у f тип x1 и f - это функция двух аргументов (видно из f x (foldr f e xs))\r\n\r\nx3 = [x8]\r\n\r\n	Потому что у (x:xs) тип x3\r\n\r\nПолучаем:\r\n\r\n(x5 -> x6 -> x7) -> x2 -> [x8] -> x4\r\n\r\n\r\n\r\nЭтап 2:\r\n\r\nx5 = x8\r\n\r\n	Потому что x встречается в (x:xs) типа [x8] и в f x (foldr f e xs)\r\n\r\nx6 = x4\r\n\r\n	Видно из f x (foldr f e xs)\r\n\r\n	- здесь (foldr f e xs) имеет тип x4 и он же является вторым аргументом f, т.е. имеет тип x6\r\n\r\n\r\n\r\nx2 = x4\r\n\r\n	Видно из правила foldr f e [] = e\r\n\r\nx7 = x4\r\n\r\n	Рассмотрим правило foldr f e (x:xs) = f x (foldr f e xs) \r\n\r\n	- здесь результат работы (f x (foldr f e xs)) имеет тип x7,\r\n\r\n	а результат работы foldr f e (x:xs) имеет тип x4\r\n\r\nВ итоге, получаем:\r\n\r\n(x8 -> x4 -> x4) -> x4 -> [x8] -> x4\r\n','<br/>Тесты успешно пройдены!'),(6981,81,'ip','2013-10-27 21:23:01',1,'lst137 = [1,3,7] ++ (map f2 (zip (f lst137) num))\r\n\r\nnum = [1,3,7]++num\r\n\r\nf [] = []\r\nf (a:xs) = [a,a,a]++(f xs)\r\n\r\nf2 (a,b) = a*10+b ','<br/>Тесты успешно пройдены!'),(6980,81,'ip','2013-10-27 21:18:20',0,'lst137 = [1,3,7]++(map f2 (zip (f [] lst137) num))\r\n\r\nnum = [1,3,7]++num\r\n\r\nf x [] = x\r\nf x (a:xs) = f (x++[a,a,a]) xs\r\n\r\nf2 (a,b) = a*10+b ','Не удалось вычислить выражение \"take 15 lst137\", проверьте правильность синтаксиса'),(6977,81,'ip','2013-10-27 20:52:29',0,'lst137 = [1,3,7] ++ (map f2 (zip (foldl f [] lst137) num))\r\n\r\nnum = [1,3,7]++num\r\n\r\nf x a = x++[a,a,a]\r\nf2 (a,b) = a*10+b ','Не удалось вычислить выражение \"take 15 lst137\", проверьте правильность синтаксиса'),(6978,81,'ip','2013-10-27 21:08:37',0,'lst137 = [1,3,7] ++ (map f2 (zip (foldr f [] lst137) num))\r\n\r\nnum = [1,3,7]++num\r\n\r\nf x a = [a,a,a]++x\r\nf2 (a,b) = a*10+b ','Не удалось вычислить выражение \"take 15 lst137\", проверьте правильность синтаксиса'),(6979,93,'2260659','2013-10-27 21:10:44',1,'ham = 1 : map (*3) ham # map (*10) ham\r\n\r\n    where ham3@(x:xs) # ham10@(y:ys)\r\n\r\n              | x==y = x : xs # ys\r\n\r\n              | x<y  = x : xs # ham10\r\n\r\n              | x>y  = y : ham3 # ys\r\n','<br/>Тесты успешно пройдены!'),(6976,75,'ilia','2013-10-27 20:34:19',1,'foldr f e [] = e\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\n\r\nПервое приближение:\r\nfoldr :: a -> b -> c -> d\r\n\r\nПоянтно что c - массив, а f - функция, у которой первый аргумент такой же как и эл-ты массива:\r\nfoldr :: (c -> a2 -> a3) -> b-> [c] -> d\r\n\r\nfoldr возращает эл-т типа e, а также, функция f принимает его как второй аргумент:\r\nfoldr :: (c -> b -> a3) -> b -> [c] -> b\r\n\r\nТакже понятно что типа возвращаемого значиния f равен типу возращаемого foldr\r\nfoldr :: (c -> b -> b) -> b -> [c] -> b\r\n','<br/>Тесты успешно пройдены!'),(6974,134,'ilia','2013-10-27 19:58:49',1,'allDiffLists n k = gen_lists [1..n] k\r\n\r\n\r\n\r\ngen_lists s 1 = [ [i] | i <- s ]\r\n\r\ngen_lists s l = [ i : gl | gl <- gen_lists s (l - 1), i <- filter (si -> all (gli -> si /= gli) gl) s ]\r\n\r\n\r\n\r\nmain = print (allDiffLists 3 2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6975,91,'ilia','2013-10-27 20:14:30',1,'merge a [] = a\r\n\r\nmerge [] b = b\r\n\r\nmerge a b =\r\n\r\n	let\r\n\r\n		ha = head a\r\n\r\n		hb = head b\r\n\r\n	in\r\n\r\n		if ha < hb then\r\n\r\n			ha : merge (tail a) b\r\n\r\n		else if ha == hb then\r\n\r\n			ha : merge (tail a) (tail b)\r\n\r\n		else \r\n\r\n			hb : merge a (tail b)\r\n\r\n		\r\n\r\n\r\n\r\nmain = print (merge [1,4,8] [2,4,5,10,20])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6972,81,'8519021','2013-10-27 19:50:47',1,'lst137 = 1:3:7:(concat [[x * 10 + 1, x * 10 + 3, x * 10 + 7] | x<-lst137])\r\n','<br/>Тесты успешно пройдены!'),(6973,75,'ip','2013-10-27 19:50:51',1,'foldr f x [] = x\r\nfoldr f x xs++[a] = foldr f (f x a) xs\r\n\r\n1 x1->x2-x3-x4\r\n\r\n2.выясняем сложные типы \r\n\r\nx1 = (x5->x6->x7) тк это функция (видно что (f x a))\r\n\r\nx2 = x8 тк видно что результат функции\r\n\r\nx3 = [x9] видно что список\r\n\r\nx4 = x10 видно тк в силу рекурсии будет результат x, а x простой\r\n\r\n3. (x5->x6->x7)->x8->[x9]-x10\r\n\r\nx8 = x7 т.к результат функции f\r\n\r\nx6 = x7 т.к видно что аргумент в f x a\r\n\r\nx5 = x9 видно из xs++[a]\r\n\r\nx10 =x7 видно из самой первой строчки (как результат)\r\n\r\nИтог (x9 -> x7 -> x7) -> x7 -> [x9] -> x7','<br/>Тесты успешно пройдены!'),(6968,75,'3320654','2013-10-27 19:01:35',1,'foldr f z []        = z \r\nfoldr f z (x:xs) = f x (foldr f z xs)\r\n\r\nподставим некие абстрактные типы\r\n(foldr f::F z::Z (x:xs)::[X])::Foldr = f x (foldr f z xs)\r\nправая часть второго шаблона позволяет сделать вывод:\r\nF = X -> Foldr -> Foldr\r\n1 шаблон позволяет сделать вывод:\r\nFoldr = Z\r\nтаким образом F:\r\nF = X -> Z -> Z\r\n\r\nТаким образом тип foldr :: (X -> Z -> Z) -> Z -> [X] -> Z','<br/>Тесты успешно пройдены!'),(6969,134,'nomeansno','2013-10-27 19:01:56',1,'not_in x s = length (filter (y -> y==x) s) == 0\r\n\r\nallDiffLists n 1 = [[x] | x <- [1..n]]\r\n\r\nallDiffLists n k = [x:y | x <- [1..n], y<-allDiffLists n (k-1), x `not_in` y]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6970,134,'8519021','2013-10-27 19:05:07',1,'allDiffLists n 0 = [[]]\r\n\r\nallDiffLists n k = [x:xs | x<-[1..n], xs<-allDiffLists n (k-1), not(x `elem` xs)]\r\n','<br/>Тесты успешно пройдены!'),(6971,134,'Artur','2013-10-27 19:06:52',1,'allDiffLists n 0 = [[]]	\r\n\r\nallDiffLists n k = [x:xs | x<-[1..n], \r\n\r\n			        xs<-allDiffLists n (k-1) \r\n\r\n					 ,not (check (i -> i == x) xs)]\r\n\r\n--- Или можно использовать стандартную функцию any\r\n\r\ncheck cond [] = False\r\n\r\ncheck cond (y:ys) = if cond y then True else check cond ys\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6962,75,'Artur','2013-10-27 18:41:11',1,'foldr f e [] = e\r\nfoldr f e (x:xs) = x `f` foldr f e xs\r\n\r\n x1-> x2-> x3-> x4\r\n\r\n1)\r\nx1 = (x5->x6->x7)\r\nx3 = [x8]\r\n\r\n(x5 -> x6 -> x7) -> x2  -> [x8] -> x4\r\n\r\n2) \r\n	x8 == x5 так как у x тип x8, второй аргумент у f - типа f\r\n	x2 == x6 так как у e - тип x2, второй аргумент f - тип x6\r\n	x2 == x4 так как у e - тип x2 , а результат foldr - x4\r\n	x4 == x7 так как результат f - тип x7, результат foldr - результат f\r\n	x7 == x5 так как результат f будет передан в качестве первого аргумента\r\n\r\nИтак, 	\r\n(x5 -> x2 -> x2) -> x2  -> [x5] -> x2','<br/>Тесты успешно пройдены!'),(6963,91,'Artur','2013-10-27 18:47:19',1,'merge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys) = if x < y then x : (merge xs (y:ys))\r\n\r\n						else if x > y then y : (merge (x:xs) ys )\r\n\r\n								else x:(merge xs ys)\r\n','<br/>Тесты успешно пройдены!'),(6964,81,'nomeansno','2013-10-27 18:48:45',0,'add [] = []\n\nadd (x:xs) = [x*10+y | y<-[1,3,7]] ++ add xs\n\n\n\nlst137 = lst137\' [1,3,7]\n\n	where lst137\' s = s ++ lst137\' (add s)\n\n\n','<br/>Тесты успешно пройдены!'),(6965,81,'nomeansno','2013-10-27 18:50:17',1,'add [] = []\r\n\r\nadd (x:xs) = [x*10+y | y<-[1,3,7]] ++ add xs\r\n\r\n\r\n\r\nlst137 = lst137\' [1,3,7]\r\n\r\n	where lst137\' s = s ++ lst137\' (add s)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6966,91,'ip','2013-10-27 18:50:42',1,'merge x y = merge2 [] x y\r\n\r\nmerge2 a [] [] = a\r\nmerge2 a b [] = (a++b)\r\nmerge2 a [] c = (a++c)\r\nmerge2 a (b:x) (b:y) = merge2 (b:a) x y\r\n   --- В левой части нельзя использовать одну переменную два раза, мы про это говорили\r\n   --- на первом занятии. Те надо писать if b == с then ...\r\nmerge2 a (b:x) (c:y) = if (b<c)\r\n                       then (merge2 (b:a) x (c:y))\r\n                       else (merge2 (c:a) (b:x) y)','Не удалось вычислить выражение \"merge [1,4,8] [2,4,5,10,20]\", проверьте правильность синтаксиса'),(6967,134,'Artur','2013-10-27 18:59:07',0,'allDiffLists n 0 = [[]]	\r\n\nallDiffLists n k = [x:xs | x<-[1..n], \r\n\n			        xs<-allDiffLists n (k-1) \r\n\n					 ,check (i -> i /= x) xs]\r\n\n\r\n\ncheck cond [] = True\r\n\ncheck cond (x:xs) = if cond x then True else False\r\n\n\n','Выражение имеет неправильное значение: length (allDiffLists 3 3)'),(6959,91,'ip','2013-10-27 18:35:28',0,'merge x y = merge2 [] x y\r\n\r\nmerge2 a [] [] = a\r\nmerge2 a b [] = a++b\r\nmerge2 a [] c = a++c\r\nmerge2 a (b:x) (b:y) = merge2 (b:a) x y\r\nmerge2 a (b:x) (c:y) = if (b<c)\r\n                   then merge2 (b:a) x (c:y)\r\n                   else merge2 (c:a) (b:x) y','Не удалось вычислить выражение \"merge [1,4,8] [2,4,5,10,20]\", проверьте правильность синтаксиса'),(6960,91,'ip','2013-10-27 18:36:21',0,'merge x y = merge2 [] x y\r\n\r\nmerge2 a [] [] = a\r\nmerge2 a b [] = (a++b)\r\nmerge2 a [] c = (a++c)\r\nmerge2 a (b:x) (b:y) = merge2 (b:a) x y\r\nmerge2 a (b:x) (c:y) = if (b<c)\r\n                   then (merge2 (b:a) x (c:y))\r\n                   else (merge2 (c:a) (b:x) y)','Не удалось вычислить выражение \"merge [1,4,8] [2,4,5,10,20]\", проверьте правильность синтаксиса'),(6961,91,'ip','2013-10-27 18:36:46',0,'merge x y = merge2 [] x y\r\n\r\nmerge2 a [] [] = a\r\nmerge2 a b [] = (a++b)\r\nmerge2 a [] c = (a++c)\r\nmerge2 a (b:x) (b:y) = merge2 (b:a) x y\r\nmerge2 a (b:x) (c:y) = if (b<c)\r\n                       then (merge2 (b:a) x (c:y))\r\n                       else (merge2 (c:a) (b:x) y)','Не удалось вычислить выражение \"merge [1,4,8] [2,4,5,10,20]\", проверьте правильность синтаксиса'),(6958,91,'ip','2013-10-27 18:34:20',0,'merge x y = merge2 [] x y\r\n\r\nmerge2 a [] [] = a\r\nmerge2 a b [] = a++b\r\nmerge2 a [] c = a++c\r\nmerge2 a b:x b:y = merge2 b:a x y\r\nmerge2 a b:x c:y = if (b<c)\r\n                   then merge2 b:a x c:y\r\n                   else merge2 c:a b:x y\r\n\r\n','Не удалось вычислить выражение \"merge [1,4,8] [2,4,5,10,20]\", проверьте правильность синтаксиса'),(6955,18,'Artur','2013-10-27 17:35:28',1,'lst137 = [1,3,7] ++ (f lst137)\r\n\r\n\r\n\r\ntriple (x:xs) = x:x:x: (triple xs)\r\n\r\nf xs = zipWith ( x y ->x*10+y) (triple xs) list137  \r\n\r\n\r\n\r\nlist137=1:3:7:list137\r\n\r\n\r\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(6956,81,'Artur','2013-10-27 17:36:39',1,'lst137 = [1,3,7] ++ (funct lst137)\r\n\r\n\r\n\r\ntriple (x:xs) = x:x:x: (triple xs)\r\n\r\nfunct xs = zipWith ( x y ->x*10+y) (triple xs) list137  \r\n\r\n\r\n\r\nlist137=1:3:7:list137\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6957,79,'8519021','2013-10-27 18:11:06',1,'  --- На самом деле вариант для 0 можно было отдельно не писать,\r\n  ---﻿ основной цикл делал бы как раз то, что вы написали..\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Digits\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Digits(int n)\r\n\r\n        {\r\n\r\n            int d = 1;\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                if (d * 10 >= n)\r\n\r\n                {\r\n\r\n                    int digit = d * 10 / n;\r\n\r\n                    yield return digit;\r\n\r\n                    d = d * 10 - digit * n;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    d *= 10;\r\n\r\n                    yield return 0;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine(\"Введите число n:\");\r\n\r\n            int n;\r\n\r\n            if (int.TryParse(Console.ReadLine(), out n))\r\n\r\n            {\r\n\r\n                int i = 0;\r\n\r\n                foreach (int digit in Digits(n))\r\n\r\n                {\r\n\r\n                    Console.Write(\"{0} \", digit);\r\n\r\n                    i++;\r\n\r\n                    if (i > 100)\r\n\r\n                        break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6953,91,'nomeansno','2013-10-27 17:19:36',1,'merge [] s = s\r\n\r\nmerge s [] = s\r\n\r\nmerge (x:xs) (y:ys) = \r\n\r\n	if (x>y) \r\n\r\n		then y:merge (x:xs) ys\r\n\r\n		else if (x<y) \r\n\r\n			then x:merge xs (y:ys)\r\n\r\n			else x:merge xs ys\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6954,77,'3226573','2013-10-27 17:30:28',1,'findNextNum target cur = maximum [i | i <- [0..9], (cur + i) * (cur + i) <= target]\r\n\r\nnextNum target cur = let\r\n		       newTarget = target * 100\r\n		       newCur = 10 * cur\r\n		       newDigit = findNextNum newTarget newCur\r\n		     in newDigit : (nextNum newTarget (newCur + newDigit))\r\n\r\nsqrt2 = 1 : nextNum 2 1','<br/>Тесты успешно пройдены!'),(6950,134,'15309342','2013-10-27 17:00:33',1,'allDiffLists n k =allDiffLists1 k [1..n]\r\nallDiffLists1 0 ys = [[]]\r\nallDiffLists1 k ys = [x:xs | x<-ys, xs<-allDiffLists1 (k-1) (filter (/=x) ys)]','<br/>Тесты успешно пройдены!'),(6951,91,'nomeansno','2013-10-27 17:15:32',0,'merge [] s = s\n\nmerge s [] = s\n\nmerge (x:xs) (y:ys) = \n\n	if (x>y) \n\n		then y:merge (x:xs) ys\n\n		else x:merge xs (y:ys)\n\n\n','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(6952,75,'15309342','2013-10-27 17:19:34',1,'  --- ОК, но мне кажется вы все-таки рассказываете, как рассуждает человек, если ему надо понять тип\r\n  --- foldr. А алгоритм Хиндли Милнера, о котором была речь в условии, он более формальный,\r\n  --- как компилятор определяет тип. Это примерно то же, но более формально:\r\n  --- Выводы там типа \"Выражение X имеет тип A и с другой стороны выражение X имеет тип B, значит A == B\"\r\n  --- Но ОК, вообще хорошо, засчитано.\r\nfoldr f elem list, \r\nf - функция, elem - начальное значение, list - список, result - результат выполнения foldr\r\nf :: a1 -> a2 -> a3 (принимает два скалярных значения, возвращает скалярное значение)\r\nelem :: a4 (скалярное значение)\r\nlist :: [a5] (список)\r\nresult :: a6 (скалярное значение)\r\n\r\nf принимает принимает элемент списка и начальное значение, поэтому\r\nelem :: a2\r\nlist :: [a1]\r\n\r\nрезультат выполнения foldr в итоге применение функции f, поэтому\r\nresult :: a3\r\n\r\nвыполняя функцию f мы получаем на каждый следующий шаг новое начальное значение, поэтому\r\nelem :: a2\r\nresult :: a2\r\n\r\nИтого: foldr :: (a1 -> a2 -> a2) -> a2 -> [a1] -> a2','<br/>Тесты успешно пройдены!'),(6949,81,'ilia','2013-10-27 17:00:24',1,'lst137 = 1 : 3 : 7 : [ x * 10 + i | x <- lst137, i <- [1, 3, 7] ]\r\n\r\n\r\n\r\nmain = print (take 15 lst137)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6947,93,'62628590','2013-10-27 16:28:02',1,'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys)\r\n	|x==y = x : merge xs ys\r\n	|x>y = y : merge (x:xs) ys\r\n	|otherwise = x : merge xs (y:ys)\r\nham = 1 : merge (map (*3) ham) (map (*10) ham)\r\n','<br/>Тесты успешно пройдены!'),(6948,77,'ilia','2013-10-27 16:40:38',2,'   ---  Не совсем то (как я написал в письме..)\r\nsqrt2 = sqrttoarr 2\r\n\r\nsqrttoarr x =\r\n\r\n	let\r\n\r\n		sx = sqrt x\r\n\r\n		fsx = floor sx\r\n\r\n		fsxm10 = mod fsx 10\r\n\r\n	in fsxm10 : sqrttoarr (x * 100)\r\n\r\n\r\n\r\nmain = print (take 20 sqrt2)\r\n\r\n\r\n','Выражение имеет неправильное значение: take 20 sqrt2'),(6946,79,'ilia','2013-10-27 16:25:02',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\nclass digits:\r\n\r\n	def __init__(self, n):\r\n\r\n		self.n = n\r\n\r\n	def __iter__(self):\r\n\r\n		self.rem = 1\r\n\r\n		return self\r\n\r\n	def next(self):\r\n\r\n		self.rem *= 10\r\n\r\n		ret, self.rem = self.rem / self.n, self.rem % self.n\r\n\r\n		return ret\r\n\r\n\r\n\r\ndef take(n, s):\r\n\r\n	i = 0\r\n\r\n	ret = []\r\n\r\n	for x in s:\r\n\r\n		if (i == n): return ret\r\n\r\n		i += 1\r\n\r\n		ret.append(x)\r\n\r\n\r\n\r\nprint take(12, digits(7))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6945,79,'ilia','2013-10-27 16:24:45',0,'','<br/>Тесты успешно пройдены!'),(6943,91,'15309342','2013-10-27 16:13:56',1,'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys) | x > y  = y : merge (x:xs) ys \r\n                    | x == y = x : merge xs ys\r\n                    | x < y  = x : merge xs (y:ys)\r\n','<br/>Тесты успешно пройдены!'),(6944,91,'62628590','2013-10-27 16:14:25',1,'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys)\r\n    |x==y = x : merge xs ys\r\n    |x>y = y : merge (x:xs) ys\r\n    |otherwise = x : merge xs (y:ys)','<br/>Тесты успешно пройдены!'),(6942,81,'15309342','2013-10-27 16:12:05',1,'lst137 = merge f1 f3 f7\r\n\r\nmerge (x:xs) (y:ys) (z:zs) = x : y : z : merge xs ys zs\r\n\r\nf1 = 1 : (map (x -> 10 * x + 1) lst137)\r\nf3 = 3 : (map (x -> 10 * x + 3) lst137)\r\nf7 = 7 : (map (x -> 10 * x + 7) lst137)\r\n','<br/>Тесты успешно пройдены!'),(6941,79,'ilia','2013-10-27 16:09:24',2,'#!/usr/bin/env python\r\n\r\n  --- Идея примерно правильная, но не совсем. Что-то вы там с делением не то написали. \r\n\r\nclass digits:\r\n\r\n	def __init__(self, n):\r\n\r\n		self.n = n\r\n\r\n	def __iter__(self):\r\n\r\n		self.rem = 1\r\n\r\n		return self\r\n\r\n	def next(self):\r\n\r\n		self.rem *= 10\r\n\r\n		ret, self.rem = self.rem / 7, self.rem % 7\r\n\r\n		return ret\r\n\r\n\r\n\r\ndef take(n, s):\r\n\r\n	i = 0\r\n\r\n	ret = []\r\n\r\n	for x in s:\r\n\r\n		if (i == n): return ret\r\n\r\n		i += 1\r\n\r\n		ret.append(x)\r\n\r\n\r\n\r\nprint take(12, digits(7))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6940,80,'ilia','2013-10-27 16:01:36',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\nclass Cantor:\r\n\r\n	def __iter__(self):\r\n\r\n		self.i, self.j = 0, 1\r\n\r\n		return self\r\n\r\n	def next(self):\r\n\r\n		self.i, self.j = (self.i + 1, self.i + 1) if self.j == 1 else (self.i, self.j - 1)\r\n\r\n		return (self.i, self.j)\r\n\r\n\r\n\r\ndef take(n, s):\r\n\r\n	i = 0\r\n\r\n	ret = []\r\n\r\n	for x in s:\r\n\r\n		if (i == n): return ret\r\n\r\n		i += 1\r\n\r\n		ret.append(x)\r\n\r\n\r\n\r\nprint take(3, Cantor())\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6937,91,'8519021','2013-10-27 15:03:35',0,'merge [] ys = ys\n\nmerge xs [] = xs\n\nmerge (x:xs) (y:ys) \n\n  | x < y =  x:y:(merge xs ys)\n\n  | x == y = x:(merge xs ys)\n\n  | otherwise = y:x:(merge xs ys)\n','Выражение имеет неправильное значение: merge [1,2] [3,4]'),(6938,80,'ilia','2013-10-27 15:03:57',0,'#!/usr/bin/env python\n\n\n\nclass Cantor:\n\n	def __init__(self, max):\n\n		self.max = max\n\n	def __iter__(self):\n\n		self.i, self.j = 0, 1\n\n		return self\n\n	def next(self):\n\n		self.i, self.j = (self.i + 1, self.i + 1) if self.j == 1 else (self.i, self.j - 1)\n\n		if (self.i == self.max):\n\n			raise StopIteration\n\n		return (self.i, self.j)\n\n\n\nprint [c for c in Cantor(4)]\n\n\n','<br/>Тесты успешно пройдены!'),(6939,91,'8519021','2013-10-27 15:05:53',1,'merge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys) \r\n\r\n  | x < y =  x:(merge xs (y:ys))\r\n\r\n  | x == y = x:(merge xs ys)\r\n\r\n  | otherwise = y:(merge (x:xs) ys)\r\n','<br/>Тесты успешно пройдены!'),(6936,82,'3226573','2013-10-27 14:56:29',1,'import Data.Set (Set)\r\nimport qualified Data.Set as Set\r\n\r\nf (a, b) (res, set) = if (Set.member a set) || (Set.member b set)\r\n		      then (res, Set.insert a (Set.insert b set))\r\n		      else ((a, b) : res, set)\r\n\r\nremoveSameVars pairs set = let\r\n			     (newPairs, newSet) = foldr f ([], set) pairs\r\n			   in if (length pairs) == (length newPairs)\r\n			      then (pairs, set)\r\n			      else removeSameVars newPairs newSet\r\n\r\ncdf [] vars ans = ans + (Set.size vars)\r\ncdf ((a,b):pairs) vars ans = let\r\n				set = Set.insert b (Set.insert a Set.empty)\r\n				(newPairs, newSet) = removeSameVars pairs set\r\n				newVars = Set.difference vars (Set.intersection newSet vars)\r\n			     in cdf newPairs newVars (ans + 1)\r\n\r\n\r\ncountDifferentVars _ [] = 0\r\ncountDifferentVars [] vars = length vars\r\ncountDifferentVars pairs vars = cdf pairs (Set.fromList vars) 0','<br/>Тесты успешно пройдены!'),(6935,82,'3226573','2013-10-27 14:36:42',0,'import Data.Set (Set)\r\nimport qualified Data.Set as Set\r\n\r\nf (a, b) (res, set) = if (Set.member a set) || (Set.member b set)\r\n		      then (res, Set.insert a (Set.insert b set))\r\n		      else ((a, b) : res, set)\r\n\r\ncdf [] vars ans = ans + (Set.size vars)\r\ncdf ((a,b):pairs) vars ans = let\r\n				set = Set.insert b (Set.insert a Set.empty)\r\n				(newPairs, newSet) = foldr f ([], set) pairs\r\n				newVars = Set.difference vars newSet\r\n			     in cdf newPairs newVars (ans + 1)\r\n\r\n\r\ncountDifferentVars _ [] = 0\r\ncountDifferentVars [] vars = length vars\r\ncountDifferentVars pairs vars = cdf pairs (Set.fromList vars) 0','Выражение имеет неправильное значение: countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]'),(6934,82,'3226573','2013-10-27 14:34:14',0,'import Data.Set (Set)\r\nimport qualified Data.Set as Set\r\n\r\nf (a, b) (res, set) = if (Set.member a set) || (Set.member b set)\r\n		      then (res, Set.insert a (Set.insert b set))\r\n		      else ((a, b) : res, set)\r\n\r\ncdf [] vars ans = ans + (Set.size vars)\r\ncdf ((a,b):pairs) vars ans = let\r\n				set = Set.insert b (Set.insert a Set.empty)\r\n				(newPairs, newSet) = foldr f ([], set) pairs\r\n				newVars = Set.difference vars newSet\r\n			     in cdf newPairs newVars (ans + 1)\r\n\r\ncountDifferentVars pairs vars = cdf pairs (Set.fromList vars) 0\r\n','Хитрый тест номер 6 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),(6932,93,'3226573','2013-10-27 13:35:41',1,'import Data.Set (Set)\r\nimport qualified Data.Set as Set\r\n\r\nham\' set = let\r\n	     (elem, newSet) = Set.deleteFindMin set \r\n	   in elem : ham\' (Set.insert (elem * 10) (Set.insert (elem * 3) newSet))\r\nham = ham\' (Set.fromList [1])','<br/>Тесты успешно пройдены!'),(6933,78,'2260659','2013-10-27 14:05:38',1,'pascal = iterate (xs -> zipWith (+) ([0] ++ xs) (xs ++ [0])) [1]\r\n','<br/>Тесты успешно пройдены!'),(6931,134,'617015','2013-10-27 13:14:16',1,'allDiffLists n k = allDiffLists\' n k 0\r\n\r\nallDiffLists\' n 0 i = [[]]\r\n\r\nallDiffLists\' n k i = [x:xs| x<-[1..n], x/=i, xs<- allDiffLists\' n (k-1) x]\r\n   --- Но так у вас разными будут только соседние элементы. А надо, чтобы все были разными. \r\n\r\n\r\n','Выражение имеет неправильное значение: length (allDiffLists 3 3)'),(6929,91,'617015','2013-10-27 13:10:47',0,'merge (x:xs) (y:ys) 	| x<y = x:y:merge xs ys\r\n\n						| y<x = y:x: merge xs ys\r\n\n						| otherwise =x:merge xs ys\r\n\n						\r\n\nmerge [] ys = ys\r\n\nmerge xs []= xs\n','Выражение имеет неправильное значение: merge [1,2] [3,4]'),(6930,91,'617015','2013-10-27 13:13:33',1,'merge (x:xs) (y:ys) 	| x<y = x:merge xs (y:ys)\r\n\r\n						| y<x = y :merge (x:xs) ys\r\n\r\n						| otherwise =x:merge xs ys\r\n\r\n						\r\n\r\nmerge [] ys = ys\r\n\r\nmerge xs []= xs\r\n','<br/>Тесты успешно пройдены!'),(6928,75,'617015','2013-10-27 13:10:08',1,' foldr f z []= z\r\n\r\n foldr f z (x:xs) = f x (foldr f z xs)\r\n\r\n \r\n\r\n x1->x2->x3->x4\r\n\r\n \r\n\r\n этап 1\r\n\r\n \r\n\r\n x1=(x5->x6->x7), потому что f имеет тип x1\r\n\r\n x3=[x8], потому что (x:xs) имеет тип x3\r\n\r\n \r\n\r\n (x5->x6->x7)->x2->[x8]->x4\r\n\r\n \r\n\r\n \r\n\r\n Этап 2\r\n\r\n \r\n\r\n x8==x2, т к z имеет тип х2 и z аргумент f(f z ...), также х аргумент f(f x ...) и (x:xs) \r\n\r\n \r\n\r\n x4==x2, т к   foldr f z [] = z\r\n\r\n \r\n\r\n x7==x2, т к значение foldr имеет тип x2 и foldr f z (x:xs) = f x (foldr f z xs)\r\n\r\n \r\n\r\n x5==x2, т  к  x имеет тип х5 и тип х2, т к f применяется к z(f z...)\r\n\r\n \r\n\r\n x6=x8, т к  (x:xs) имеет тип x8 и каждый элемент имеет тип x6(f x... ), a x8==x2=> x6==x2\r\n\r\n \r\n\r\n  \r\n\r\n  \r\n\r\n тип foldr: (x2->x2->x2)->x2->[x2]->x2\r\n','<br/>Тесты успешно пройдены!'),(6922,78,'ilia','2013-10-27 12:28:57',1,'pascal = [ 1 ] : [ zipWith (a b -> a + b) (0:xs) (xs++[0]) | xs <- pascal ]\r\n\r\n\r\n\r\nmain = print (take 6 pascal)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6923,134,'3226573','2013-10-27 12:32:59',1,'allDiffLists n k = foldr (\\_ res -> [(x:xs) | x <- [1..n], xs <- res, all ( /= x) xs]) [[]] [1..k]','<br/>Тесты успешно пройдены!'),(6924,91,'2260659','2013-10-27 12:34:22',1,'merge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys) 	| x < y =  x : merge xs (y:ys)\r\n\r\n			| x > y = y : merge (x:xs) ys\r\n\r\n			| x == y = x : merge xs ys\r\n','<br/>Тесты успешно пройдены!'),(6925,81,'62628590','2013-10-27 12:48:08',1,'lst137\' = [1, 3, 7] : (map (xs -> foldr (++) [] (map (x -> [10*x + 1,10*x + 3,10*x + 7]) xs)) lst137\')\r\nlst137 = foldr (++) [] lst137\'','<br/>Тесты успешно пройдены!'),(6926,134,'2260659','2013-10-27 12:53:11',1,'import Data.List\r\n\r\nallDiffLists n k = allDiffLists1 n k []\r\n\r\nallDiffLists1 n 0 zs = [[]]\r\n\r\nallDiffLists1 n k zs = [ (x:xs) | x<-([1..n]zs), xs<-allDiffLists1 n (k-1) (x:zs)] \r\n','<br/>Тесты успешно пройдены!'),(6927,75,'3226573','2013-10-27 13:09:55',1,'  --- Последнее замечание не очень понятное, вовсе и не требовалось использовать только первое правило.  \r\nТип для foldr (написано почти самостоятельно :)\r\n\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\nТекст foldr с занятия:\r\n\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\n\r\n\r\n\r\nОбщий вид для foldr\r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\n\r\n\r\nВидно, что f - это функция от 2 параметров (видно из \"f x (foldr f e xs)\"). Поэтому x1 = (x5 -> x6 -> x7)\r\n\r\n(x5 -> x6 -> x7) -> x2 -> x3 -> x4\r\n\r\n\r\n\r\nВидно, что x3 - это список (видно из \"(x:xs)\"). Поэтому x3 = [x8]\r\n\r\n(x5 -> x6 -> x7) -> x2 -> [x8] -> x4\r\n\r\n\r\n\r\nВидно, что x4 = x7, поскольку результат foldr есть результат выполнения f от некоторых переменных.\r\n\r\n(x5 -> x6 -> x4) -> x2 -> [x8] -> x4\r\n\r\n\r\n\r\nВидно, что x4 = x6 (видно из \"f x (foldr f e xs)\"), поскольку результат foldr используется как второй параметр f. Получили x4 = x6 = x7.\r\n\r\n(x5 -> x4 -> x4) -> x2 -> [x8] -> x4\r\n\r\n\r\n\r\nВидно, что x5 = x8, поскольку x используется как первый параметр f (видно из \"f x (foldr f e xs)\").\r\n\r\n(x5 -> x4 -> x4) -> x2 -> [x5] -> x4\r\n\r\n\r\n\r\nЗаменим x5 --> a, x4 --> b. Получим\r\n\r\n(a -> b -> b) -> x2 -> [a] -> b\r\n\r\n\r\n\r\nУточнить тип x2 без равенства \"foldr f e [] = e\" не представляется возможным.\r\n','<br/>Тесты успешно пройдены!'),(6920,81,'3226573','2013-10-27 12:20:23',1,'lst\' xs order =	let\r\n		  xs1 = (map (+ 1 * order) xs)\r\n		  xs3 = (map (+ 3 * order) xs)\r\n		  xs7 = (map (+ 7 * order) xs)\r\n		  xss = (xs1 ++ xs3 ++ xs7)\r\n		in xss ++ lst\' xss (order * 10)\r\nlst137 = lst\' [0] 1','<br/>Тесты успешно пройдены!'),(6921,91,'3226573','2013-10-27 12:26:06',1,'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys)\r\n	| x == y	= x : merge xs ys\r\n	| x < y		= x : merge xs (y:ys)\r\n	| otherwise	= y : merge (x:xs) ys','<br/>Тесты успешно пройдены!'),(6919,79,'8519021','2013-10-27 01:03:18',2,'--- Очень хорошо, но вас не совсем правильно обрабатывается ситуация, когда очередная цифра 0.\r\n--- Попробуйте ввести 99 или 700, вы увидите, что печатается совсем не то.\r\n--- Исправьте, пожалуйста.\r\n  \r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\nnamespace Digits\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Digits(int n)\r\n\r\n        {\r\n\r\n            int d = 1;\r\n\r\n            for (int i = 0; ; i++)\r\n\r\n            {\r\n\r\n                if (d * 10 >= n)\r\n\r\n                {\r\n\r\n                    int digit = d * 10 / n;\r\n\r\n                    yield return digit;\r\n\r\n                    d = d * 10 - digit * n;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                    yield return 0;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.WriteLine(\"Введите число n:\");\r\n\r\n            int n;\r\n\r\n            if (int.TryParse(Console.ReadLine(), out n))\r\n\r\n            {\r\n\r\n                int i = 0;\r\n\r\n                foreach (int digit in Digits(n))\r\n\r\n                {\r\n\r\n                    Console.Write(\"{0} \", digit);\r\n\r\n                    i++;\r\n\r\n                    if (i > 100)\r\n\r\n                        break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6916,91,'5247795','2013-10-26 19:34:13',0,'merge [] ys = ys\r\n\nmerge xs [] = xs\r\n\nmerge (x:xs) (y:ys) = if (x<y) then x : y : (merge xs ys)\r\n\n		      else if (y<x) then y : x : (merge xs ys)\r\n\n		      else x : (merge xs ys)\n','Выражение имеет неправильное значение: merge [1,2] [3,4]'),(6917,91,'5247795','2013-10-26 19:57:24',0,'merge [] ys = ys\r\n\nmerge xs [] = xs\r\n\nmerge (x:xs) (y:ys) = if (x<y) then x : (merge xs (y:ys))\r\n\n		      else y : (merge ys (x:xs))\n','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(6918,91,'5247795','2013-10-26 19:59:01',1,'merge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys) = if (x<y) then x : (merge xs (y:ys))\r\n\r\n		      else if (y<x) then y : (merge ys (x:xs))\r\n\r\n		      else x : (merge xs ys)\r\n','<br/>Тесты успешно пройдены!'),(6915,91,'5247795','2013-10-26 19:33:28',0,'merge [] ys = ys\r\n\nmerge xs [] = xs\r\n\nmerge (x:xs) (y:ys) = if (x<y) then x : y : (merge xs ys)\r\n\n		      else if (y<x) then y : x : (merge xs ys)\r\n\n		      else x : (merge xs ys)\n','Выражение имеет неправильное значение: merge [1,2] [3,4]'),(6912,91,'ArtemK','2013-10-26 18:11:10',1,'merge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys) = if x < y then x:(merge xs (y:ys))\r\n                      else if x > y then y:(merge (x:xs) ys)\r\n                      else x:merge xs ys','<br/>Тесты успешно пройдены!'),(6913,134,'ArtemK','2013-10-26 18:19:15',1,'allLists _ 0 = [[]]\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- (allLists n (k-1))]\r\n\r\nisDiff [] = True\r\nisDiff (x:xs) = (all (/=x) xs) && isDiff xs\r\nallDiffLists n k = filter isDiff (allLists n k)','<br/>Тесты успешно пройдены!'),(6914,75,'ArtemK','2013-10-26 18:48:50',1,'foldr f z []     = z \r\nfoldr f z (x:xs) = f x (foldr f z xs) \r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\nСложные:\r\n// f x (...)\r\nx1 = (x5 -> x6 -> x7)\r\n// (x:xs)\r\nx3 = [x8]\r\n\r\nПолучили:\r\n(x5 -> x6 -> x7) -> x2 -> [x8] -> x4\r\n\r\nОдинаковые:\r\n// z == f x (...) — оба результаты foldr, т. е. x4\r\nx2 == x7 == x4\r\n// f x (foldr ...) — второй аргумент\r\nx6 == x4\r\n// f x ... — первый аргумент\r\nx5 == x8\r\n\r\nИтого получили:\r\n(x5 -> x2 -> x2) -> x2 -> [x5] -> x2\r\n\r\nЭто и есть тип foldr:\r\n(a -> b -> b) -> b -> [a] -> b','<br/>Тесты успешно пройдены!'),(6910,78,'3226573','2013-10-26 14:49:44',1,'pascal = [1] : map (xs -> zipWith (+) (xs ++ [0]) (0:xs)) pascal','<br/>Тесты успешно пройдены!'),(6911,81,'ArtemK','2013-10-26 17:44:08',1,'zipThree (x:xs) (y:ys) (z:zs) = x:y:z:zipThree xs ys zs\r\nlst137 = let\r\n    xs = map (x -> x*10 + 1) lst137\r\n    ys = map (x -> x*10 + 3) lst137\r\n    zs = map (x -> x*10 + 7) lst137\r\n    in 1:3:7:zipThree xs ys zs','<br/>Тесты успешно пройдены!'),(6909,82,'115753099','2013-10-26 14:41:51',1,'cont [] y = False\r\n\r\ncont (x:xs) y\r\n\r\n	| x == y	= True\r\n\r\n	| otherwise = cont xs y\r\n\r\n\r\n\r\ncountDifferentVars1 [] list = list\r\n\r\ncountDifferentVars1 ((x,y):pairList) list =\r\n\r\n	countDifferentVars1 pairList newList\r\n\r\n	where\r\n\r\n		newList = map (elList -> \r\n\r\n			if (cont elList x) && (not (cont elList y)) then elList ++ (concat $ map (el -> if (cont el y) then el else []) list)\r\n\r\n			else if (cont elList x) && (cont elList y) then elList\r\n\r\n			else if (cont elList y) then []\r\n\r\n			else elList\r\n\r\n			) list\r\n\r\n\r\n\r\ndeleteEmpty [] = []\r\n\r\ndeleteEmpty (x:xs)\r\n\r\n	| x == []   = deleteEmpty xs\r\n\r\n	| otherwise = x : (deleteEmpty xs)\r\n\r\n\r\n\r\ndeleteSame [] = []\r\n\r\ndeleteSame (x:xs)\r\n\r\n	| cont xs x = deleteSame xs\r\n\r\n	| otherwise = x : (deleteSame xs)\r\n\r\n\r\n\r\naddElements [] list = list\r\n\r\naddElements ((x,y):pairList) list\r\n\r\n	| not (cont list x) && not (cont list y) = addElements pairList (x:y:list)\r\n\r\n	| not (cont list y)						 = addElements pairList (y:list)\r\n\r\n	| not (cont list x)						 = addElements pairList (x:list)\r\n\r\n	| otherwise								 = addElements pairList list\r\n\r\n\r\n\r\ncountDifferentVars pairList [] = 0\r\n\r\ncountDifferentVars [] list = length $ deleteSame list\r\n\r\ncountDifferentVars pairList list =\r\n\r\n	length $ deleteEmpty $ countDifferentVars1 pairList (map (x -> [x]) (addElements pairList (deleteSame list)))\r\n','<br/>Тесты успешно пройдены!'),(6908,82,'115753099','2013-10-26 14:40:12',0,'cont [] y = False\n\ncont (x:xs) y\n\n	| x == y	= True\n\n	| otherwise = cont xs y\n\n\n\ncountDifferentVars1 [] list = list\n\ncountDifferentVars1 ((x,y):pairList) list =\n\n	countDifferentVars1 pairList newList\n\n	where\n\n		newList = map (elList -> \n\n			if (cont elList x) && (not (cont elList y)) then elList ++ (concat $ map (el -> if (cont el y) then el else []) list)\n\n			else if (cont elList x) && (cont elList y) then elList\n\n			else if (cont elList y) then []\n\n			else elList\n\n			) list\n\n\n\ndeleteEmpty [] = []\n\ndeleteEmpty (x:xs)\n\n	| x == []   = deleteEmpty xs\n\n	| otherwise = x : (deleteEmpty xs)\n\n\n\ndeleteSame [] = []\n\ndeleteSame (x:xs)\n\n	| cont xs x = deleteSame xs\n\n	| otherwise = x : (deleteSame xs)\n\n\n\naddElements [] list = list\n\naddElements ((x,y):pairList) list\n\n	| not (cont list x) && not (cont list y) = addElements pairList (x:y:list)\n\n	| not (cont list y)						 = addElements pairList (y:list)\n\n	| not (cont list x)						 = addElements pairList (x:list)\n\n	| otherwise								 = addElements pairList list\n\n\n\ncountDifferentVars pairList list =\n\n	length $ deleteEmpty $ countDifferentVars1 pairList (map (x -> [x]) (addElements pairList (deleteSame list)))\n','Хитрый тест номер 6 не пройден :(<br/>Подсказка: Списки могут быть и пустыми..'),(6907,82,'115753099','2013-10-26 14:18:07',0,'cont [] y = False\r\ncont (x:xs) y\r\n	| x == y	= True\r\n	| otherwise = cont xs y\r\n\r\ncountDifferentVars1 [] list = list\r\ncountDifferentVars1 ((x,y):pairList) list =\r\n	countDifferentVars1 pairList newList\r\n	where\r\n		newList = map (elList -> \r\n			if (cont elList x) && (not (cont elList y)) then y:elList\r\n			else if (cont elList x) && (cont elList y) then elList\r\n			else if (cont elList y) then []\r\n			else elList\r\n			) list\r\n\r\ndeleteEmpty [] = []\r\ndeleteEmpty (x:xs)\r\n	| x == []   = deleteEmpty xs\r\n	| otherwise = x : (deleteEmpty xs)\r\n\r\ndeleteSame [] = []\r\ndeleteSame (x:xs)\r\n	| cont xs x = deleteSame xs\r\n	| otherwise = x : (deleteSame xs)\r\n\r\ndeletePairs [] list = []\r\ndeletePairs ((x,y):pairList) list\r\n	| (cont list x) && (cont list y) = (x,y) : (deletePairs pairList list)\r\n	| otherwise						 = deletePairs pairList list\r\n\r\ncountDifferentVars pairList list =\r\n	length $ deleteEmpty $ countDifferentVars1 (deletePairs pairList list) (map (x -> [x]) (deleteSame list))','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(6906,75,'55363692','2013-10-26 14:07:03',1,'(1) foldr f e [] = e\r\n\r\n(2) foldr f e (x:xs) = f x (foldr f e xs)\r\n\r\n\r\n\r\nШаг 1.\r\n\r\n\r\n\r\nfoldr :: a1 -> a2 -> a3 -> a4\r\n\r\n\r\n\r\n1) a3 = (x:xs) из (2) => a3 - список [a5]\r\n\r\n2) из (2) => foldr = f a b, a1 = f => a1 - функция a1 :: a6 -> a7 -> a8\r\n\r\n\r\n\r\nТо есть: foldr :: (a6 -> a7 -> a8) -> a2 -> [a5] -> a4 \r\n\r\n\r\n\r\nШаг 2.\r\n\r\n\r\n\r\n1) из (1) => a2 = a4 (равны e)\r\n\r\n2) из (1) => a8 = a2 (= a4) (foldr возвращает то же, что и f)\r\n\r\n3) a7 = a4 так как f x (foldr ...), а foldr возвращает a4\r\n\r\n4) f x _, x имеет тип a6, но (x:xs) имеет тип [a5] => a6 = a5\r\n\r\n \r\n\r\nВсе вместе: foldr :: (a5 -> a2 -> a2) -> a2 -> [a5] -> a2\r\n\r\nили: foldr :: (a -> b -> b) -> b -> [a] -> b\r\n','<br/>Тесты успешно пройдены!'),(6905,82,'115753099','2013-10-26 14:05:45',0,'cont [] y = False\r\ncont (x:xs) y\r\n	| x == y	= True\r\n	| otherwise = cont xs y\r\n\r\ncountDifferentVars1 [] list = list\r\ncountDifferentVars1 ((x,y):pairList) list =\r\n	countDifferentVars1 pairList newList\r\n	where\r\n		newList = map (elList -> \r\n			if (cont elList x) && (not (cont elList y)) then y:elList\r\n			else if (cont elList x) && (cont elList y) then elList\r\n			else if (cont elList y) then []\r\n			else elList\r\n			) list\r\n\r\ndeleteEmpty [] = []\r\ndeleteEmpty (x:xs)\r\n	| x == []   = deleteEmpty xs\r\n	| otherwise = x : (deleteEmpty xs)\r\n\r\ndeleteSame [] = []\r\ndeleteSame (x:xs)\r\n	| cont xs x = deleteSame xs\r\n	| otherwise = x : (deleteSame xs)\r\n\r\n\r\ncountDifferentVars pairList list =\r\n	length $ deleteEmpty $ countDifferentVars1 pairList (map (x -> [x]) (deleteSame list))\r\n','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(6904,82,'115753099','2013-10-26 14:03:13',0,'cont [] y = False\r\ncont (x:xs) y\r\n	| x == y	= True\r\n	| otherwise = cont xs y\r\n\r\ncountDifferentVars1 [] list = list\r\ncountDifferentVars1 ((x,y):pairList) list =\r\n	countDifferentVars1 pairList newList\r\n	where\r\n		newList = map (elList -> \r\n			if (cont elList x) && (not (cont elList y)) then y:elList\r\n			else if (cont elList y) then []\r\n			else elList\r\n			) list\r\n\r\ndeleteEmpty [] = []\r\ndeleteEmpty (x:xs)\r\n	| x == []   = deleteEmpty xs\r\n	| otherwise = x : (deleteEmpty xs)\r\n\r\ndeleteSame [] = []\r\ndeleteSame (x:xs)\r\n	| cont xs x = deleteSame xs\r\n	| otherwise = x : (deleteSame xs)\r\n\r\n\r\ncountDifferentVars pairList list =\r\n	length $ deleteEmpty $ countDifferentVars1 pairList (map (x -> [x]) (deleteSame list))','Выражение имеет неправильное значение: countDifferentVars [(1,2),(2,1)] [1,2,3]'),(6903,83,'115753099','2013-10-26 11:16:39',1,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n		public static IEnumerable<int> lst137()\r\n		{\r\n			yield return 1;\r\n			yield return 3;\r\n			yield return 7;\r\n			foreach (int i in lst137())\r\n			{\r\n				yield return i*10 + 1;\r\n				yield return i*10+3;\r\n				yield return i*10+7;\r\n			}\r\n		}\r\n				\r\n		public static void Main (string[] args)\r\n		{\r\n			int i = 0;\r\n			foreach (int x in lst137())\r\n			{\r\n				if (i == 100) break;\r\n				i++;\r\n				Console.Write(x.ToString() + \'\r\n\');\r\n			}\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6901,134,'1595828','2013-10-26 00:01:10',1,'allLists _ 0 _=[[]]\r\n\r\nallLists n k ys =[(x:xs)|x<-ys, xs<-allLists n (k-1) (filter (/=x) ys)]\r\n\r\nallDiffLists n k =  allLists n k [1..n]\r\n','<br/>Тесты успешно пройдены!'),(6902,82,'115753099','2013-10-26 11:01:51',0,'import Data.List\r\n\r\nadd [] acc = acc\r\nadd (q:qs) acc = \r\n	if (any (x -> (x == q)) acc) then add qs acc\r\n	else add qs (q:acc)\r\n\r\n---acc - список одинаковых элментов(с x и y)\r\n---acc2 - оставшиеся\r\nmyUnion _ _ [] acc acc2 = acc : acc2\r\nmyUnion x y (el:els) acc acc2 =\r\n	if (any (q -> (q == x) || (q == y)) el) then myUnion x y els (add el acc) acc2\r\n	else myUnion x y els acc (el:acc2)\r\n\r\ncountDifferentVars [] list = length list\r\ncountDifferentVars ((x, y):pairList) list =\r\n	countDifferentVars pairList (myUnion x1 y1 list \"\" [])\r\n	where\r\n		x1 = head x\r\n		y1 = head y','Не удалось вычислить выражение \"countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]\", проверьте правильность синтаксиса'),(6900,83,'3320654','2013-10-25 23:39:10',1,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication3\r\n{\r\n    class Program \r\n    {\r\n        static IEnumerable<int> Lst137()\r\n        {\r\n            yield return 1;\r\n            yield return 3;\r\n            yield return 7;\r\n            foreach (int i in Lst137())\r\n            {\r\n                yield return 10 * i + 1;\r\n                yield return 10 * i + 3;\r\n                yield return 10 * i + 7;\r\n            }\r\n        }\r\n        public static void Main(string[] args)\r\n        {\r\n            int i = 0;\r\n            foreach (int x in Lst137())\r\n            {                \r\n                Console.Write(x);                                  \r\n                i++;\r\n                if (i == 100)\r\n                    break;\r\n                Console.Write(\", \"); \r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6899,78,'3320654','2013-10-25 23:34:40',1,'-- другой редактор не особо помог, так и не понял, в чём беда\r\npascal = [1] : (map (x -> zipWith (+) (1:x) (0:(tail x) ++ [0])) pascal)','<br/>Тесты успешно пройдены!'),(6898,82,'3320654','2013-10-25 23:26:25',1,'﻿countDifferentVars setOfEq list = length (help [] setOfEq list)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nhelp listUnique _ []                   = listUnique\r\n\r\n\r\n\r\nhelp listUnique setOfEq (x:xs) = if (help\' listUnique (help\'\' setOfEq [x] setOfEq x))\r\n\r\n\r\n\r\n                                                       then (help (x:listUnique) setOfEq xs)\r\n\r\n\r\n\r\n                                                       else (help listUnique setOfEq xs)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n-- add or not in listUnique\r\n\r\n\r\n\r\nhelp\' listUnique []        = True\r\n\r\n\r\n\r\nhelp\' listUnique (x:xs) = if (any (== x) listUnique)\r\n\r\n\r\n\r\n                                         then False\r\n\r\n\r\n\r\n                                         else help\' listUnique xs\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n-- get class of equal\r\n\r\n\r\n\r\nhelp\'\' setOfEq listRes [] y        = if (y == (head listRes))\r\n\r\n\r\n\r\n                                                      then listRes\r\n\r\n\r\n\r\n                                                     else help\'\' setOfEq listRes setOfEq (help\'\'\' listRes y)\r\n\r\n\r\n\r\nhelp\'\' setOfEq listRes (x:xs) y = let \r\n\r\n\r\n\r\n                                                        myFst = fst x\r\n\r\n\r\n\r\n                                                        mySnd = snd x\r\n\r\n\r\n\r\n                                                     in \r\n\r\n\r\n\r\n                                                        if (myFst == y)\r\n\r\n\r\n\r\n                                                        then if (any (== mySnd) listRes)\r\n\r\n\r\n\r\n                                                                then (help\'\' setOfEq listRes xs y)\r\n\r\n\r\n\r\n                                                                else (help\'\' setOfEq (mySnd:listRes) xs y)\r\n\r\n\r\n\r\n                                                        else if (mySnd == y)\r\n\r\n\r\n\r\n                                                               then if (any (== myFst) listRes)\r\n\r\n\r\n\r\n                                                                       then (help\'\' setOfEq listRes xs y)\r\n\r\n\r\n\r\n                                                                       else (help\'\' setOfEq (myFst:listRes) xs y)\r\n\r\n\r\n\r\n                                                               else (help\'\' setOfEq listRes xs y)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nhelp\'\'\' (x:y:xs) z = if (y == z)\r\n\r\n\r\n\r\n                              then x\r\n\r\n\r\n\r\n                              else help\'\'\' (y:xs) z\r\n','<br/>Тесты успешно пройдены!'),(6897,82,'3320654','2013-10-25 23:24:51',0,'-- в окошко не влазило, из блокнота система не хотела брать ни в каких кодировках\r\n\n-- так и не понял, с чем связано\r\n\n-- зато обзавёлся нормальным текстовым редактором\r\n\ncountDifferentVars setOfEq list = length (help [] setOfEq list)\r\n\n\r\n\nhelp listUnique _ [] 			= listUnique\r\n\nhelp listUnique setOfEq (x:xs) 	= if (help\' listUnique (help\'\' setOfEq [x] setOfEq x))\r\n\n			  					  then (help (x:listUnique) setOfEq xs)\r\n\n			   					  else (help listUnique setOfEq xs)\r\n\n\r\n\n-- проверяет нужно ли добавлять класс в список уникальных\r\n\nhelp\' listUnique []    	= True\r\n\nhelp\' listUnique (x:xs) = if (any (== x) listUnique)\r\n\n		   				  then False\r\n\n		   				  else help\' listUnique xs\r\n\n\r\n\n\r\n\n-- подбор класса эквивалентности\r\n\nhelp\'\' setOfEq listRes [] y  	= if (y == (head listRes))\r\n\n								  then listRes\r\n\n								  else help\'\' setOfEq listRes setOfEq (help\'\'\' listRes y)\r\n\nhelp\'\' setOfEq listRes (x:xs) y = let \r\n\n									myFst = fst x\r\n\n									mySnd = snd x\r\n\n								  in \r\n\n									if (myFst == y)\r\n\n									then 	if (any (== mySnd) listRes)\r\n\n											then (help\'\' setOfEq listRes xs y)\r\n\n											else (help\'\' setOfEq (mySnd:listRes) xs y)\r\n\n									else 	if (mySnd == y)\r\n\n											then 	if (any (== myFst) listRes)\r\n\n													then (help\'\' setOfEq listRes xs y)\r\n\n													else (help\'\' setOfEq (myFst:listRes) xs y)\r\n\n											else (help\'\' setOfEq listRes xs y)\r\n\n\r\n\nhelp\'\'\' (x:y:xs) z = if (y == z)\r\n\n					 then x\r\n\n					 else help\'\'\' (y:xs) z\n','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(6896,82,'3320654','2013-10-25 23:16:50',0,'﻿countDifferentVars setOfEq list = length (help [] setOfEq list)\r\n\n\r\n\nhelp listUnique _ []                   = listUnique\r\n\nhelp listUnique setOfEq (x:xs) = if (help\' listUnique (help\'\' setOfEq [x] setOfEq x))\r\n\n                                                       then (help (x:listUnique) setOfEq xs)\r\n\n                                                       else (help listUnique setOfEq xs)\r\n\n\r\n\n-- add or not in listUnique\r\n\nhelp\' listUnique []        = True\r\n\nhelp\' listUnique (x:xs) = if (any (== x) listUnique)\r\n\n                                         then False\r\n\n                                         else help\' listUnique xs\r\n\n\r\n\n-- get class of equal\r\n\nhelp\'\' setOfEq listRes [] y        = if (y == (head listRes))\r\n\n                                                      then listRes\r\n\n                                                     else help\'\' setOfEq listRes setOfEq (help\'\'\' listRes y)\r\n\nhelp\'\' setOfEq listRes (x:xs) y = let \r\n\n                                                        myFst = fst x\r\n\n                                                        mySnd = snd x\r\n\n                                                     in \r\n\n                                                        if (myFst == y)\r\n\n                                                        then if (any (== mySnd) listRes)\r\n\n                                                                then (help\'\' setOfEq listRes xs y)\r\n\n                                                                else (help\'\' setOfEq (mySnd:listRes) xs y)\r\n\n                                                        else if (mySnd == y)\r\n\n                                                               then if (any (== myFst) listRes)\r\n\n                                                                       then (help\'\' setOfEq listRes xs y)\r\n\n                                                                       else (help\'\' setOfEq (myFst:listRes) xs y)\r\n\n                                                               else (help\'\' setOfEq listRes xs y)\r\n\n\r\n\nhelp\'\'\' (x:y:xs) z = if (y == z)\r\n\n                              then x\r\n\n                              else help\'\'\' (y:xs) z\n','<br/>Тесты успешно пройдены!'),(6895,68,'Artur','2013-10-25 23:16:28',1,'﻿﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\nnamespace NonZLDigits\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Func<int[], int, int[]> ZeroDigits = (y, x) => y.Select(\r\n\r\n                                                    z => { int divis = 1 ;\r\n\r\n                                                    for (int i = 0; i < x; i++)\r\n\r\n                                                        divis *= 10;\r\n --- ОК, но на самом деле лучше сосчитать divis один раз вне Select, а не каждый раз.. \r\n                                                            return divis*(z / divis ); \r\n\r\n                                                         }\r\n\r\n                                                    ).ToArray();\r\n\r\n            int[] a = { 563, 5643, 76796 };\r\n\r\n            int[] b = { 33210, 1, 30, 0, 40, 7, 110, 1 };\r\n\r\n              \r\n\r\n            int[] c  = ZeroDigits( a,  2 );\r\n\r\n            int[] c1 = ZeroDigits( b , 1 );\r\n\r\n            Console.WriteLine(b);\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6894,82,'3320654','2013-10-25 23:03:23',0,'﻿countDifferentVars setOfEq list = length (help [] setOfEq list)\r\n\n\r\n\nhelp listUnique _ [] 		= listUnique\r\n\nhelp listUnique setOfEq (x:xs) 	= if (help\' listUnique (help\'\' setOfEq [x] setOfEq x))\r\n\n			   then (help (x:listUnique) setOfEq xs)\r\n\n			   else (help listUnique setOfEq xs)\r\n\n\r\n\n-- проверяет нужно ли добавить представителя класса эквивалентности в список уникальных\r\n\nhelp\' listUnique []        = True\r\n\nhelp\' listUnique (x:xs) = if (any (== x) listUnique)\r\n\n		   then False\r\n\n		   else help\' listUnique xs\r\n\n\r\n\n\r\n\n-- для переменной возвращает её класс эквивалентности\r\n\nhelp\'\' setOfEq listRes [] y        = 	if (y == (head listRes))\r\n\n			then listRes\r\n\n			else help\'\' setOfEq listRes setOfEq (help\'\'\' listRes y)\r\n\nhelp\'\' setOfEq listRes (x:xs) y = 	let \r\n\n				myFst = fst x\r\n\n				mySnd = snd x\r\n\n			in \r\n\n				if (myFst == y)\r\n\n				then 	if (any (== mySnd) listRes)\r\n\n					then (help\'\' setOfEq listRes xs y)\r\n\n					else (help\'\' setOfEq (mySnd:listRes) xs y)\r\n\n				else 	if (mySnd == y)\r\n\n					then 	if (any (== myFst) listRes)\r\n\n						then (help\'\' setOfEq listRes xs y)\r\n\n						else (help\'\' setOfEq (myFst:listRes) xs y)\r\n\n					else (help\'\' setOfEq listRes xs y)\r\n\n\r\n\nhelp\'\'\' (x:y:xs) z = 	if (y == z)\r\n\n		then x\r\n\n		else help\'\'\' (y:xs) z\n','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(6893,68,'nomeansno','2013-10-25 23:02:14',1,'#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\nint f(int x, int n) {\r\n\r\n    while (n--!=0 && x!=0)\r\n\r\n        x/=10;\r\n\r\n    return x;\r\n\r\n}\r\n\r\n\r\n\r\nvoid zerodigits (int *array, size_t size, int n) {\r\n\r\n    std::transform(array,array+size,array,[n] (int x) {\r\n   --- ОК, но на самом деле лучше сосчитать pow(10,n) один раз вне цикла.\r\n        return pow(10,n)*f(x,n);\r\n\r\n    });\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n    int a[] = { 1,23, 563, 5643, 76796 };\r\n\r\n    zerodigits (a, sizeof(a)/sizeof(int), 2);\r\n\r\n    for (int* p=a; p!=a+sizeof(a)/sizeof(int); ++p)\r\n\r\n        std::cout << \' \' << *p;\r\n\r\n    std::cout << \'\r\n\';\r\n\r\n}\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6891,78,'1595828','2013-10-25 22:30:20',1,'pascal=[1]:(zipWith (xs ys -> 1:zipWith (+) (tail xs ++[0]) ys) pascal pascal)\r\n','<br/>Тесты успешно пройдены!'),(6892,82,'3320654','2013-10-25 23:00:55',0,'﻿countDifferentVars setOfEq list = length (help [] setOfEq list)\r\n\n\r\n\nhelp listUnique _ [] 		= listUnique\r\n\nhelp listUnique setOfEq (x:xs) 	= if (help\' listUnique (help\'\' setOfEq [x] setOfEq x))\r\n\n			   then (help (x:listUnique) setOfEq xs)\r\n\n			   else (help listUnique setOfEq xs)\r\n\n\r\n\n-- проверяет нужно ли добавить представителя класса эквивалентности в список уникальных\r\n\nhelp\' listUnique []        = True\r\n\nhelp\' listUnique (x:xs) = if (any (== x) listUnique)\r\n\n		   then False\r\n\n		   else help\' listUnique xs\r\n\n\r\n\n\r\n\n-- для переменной возвращает её класс эквивалентности\r\n\nhelp\'\' setOfEq listRes [] y        = 	if (y == (head listRes))\r\n\n			then listRes\r\n\n			else help\'\' setOfEq listRes setOfEq (help\'\'\' listRes y)\r\n\nhelp\'\' setOfEq listRes (x:xs) y = 	let \r\n\n				myFst = fst x\r\n\n				mySnd = snd x\r\n\n			in \r\n\n				if (myFst == y)\r\n\n				then 	if (any (== mySnd) listRes)\r\n\n					then (help\'\' setOfEq listRes xs y)\r\n\n					else (help\'\' setOfEq (mySnd:listRes) xs y)\r\n\n				else 	if (mySnd == y)\r\n\n					then 	if (any (== myFst) listRes)\r\n\n						then (help\'\' setOfEq listRes xs y)\r\n\n						else (help\'\' setOfEq (myFst:listRes) xs y)\r\n\n					else (help\'\' setOfEq listRes xs y)\r\n\n\r\n\nhelp\'\'\' (x:y:xs) z = 	if (y == z)\r\n\n		then x\r\n\n		else help\'\'\' (y:xs) z\n','Не удалось вычислить выражение \"countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]\", проверьте правильность синтаксиса'),(6889,82,'55363692','2013-10-25 22:14:12',1,'import Data.List\r\n\r\n\r\n\r\nreplace (x, y) z = if z == x then y else z\r\n\r\n\r\n\r\nreplaceRule r (a, b) = (replace r a, replace r b)\r\n\r\n\r\n\r\nreplaceRules r rs = map (x -> replaceRule r x) rs\r\n\r\n\r\n\r\nreplaceVars r vs = map (v -> replace r v) vs\r\n\r\n\r\n\r\ncountDifferentVars [] vs = length $ nub vs\r\n\r\ncountDifferentVars (r:rs) vs = countDifferentVars (replaceRules r rs) (replaceVars r vs)\r\n','<br/>Тесты успешно пройдены!'),(6890,83,'55363692','2013-10-25 22:23:24',1,'﻿﻿using System;\r\n\r\n﻿using System.Collections.Generic;\r\n\r\n﻿using System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static readonly int[] Digits = {1, 3, 7};\r\n\r\n\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            foreach (var digit in Digits)\r\n\r\n            {\r\n\r\n                yield return digit;\r\n\r\n            }\r\n\r\n\r\n\r\n            foreach (int x in Lst137())\r\n\r\n            {\r\n\r\n                foreach (var digit in Digits)\r\n\r\n                {\r\n\r\n                    yield return x*10 + digit;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(String.Join(\", \", Lst137().Take(25).ToArray()));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6888,83,'romos2007','2013-10-25 21:44:57',1,'﻿/*\r\n\r\n * Задача 23-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace _23_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                yield return 10 * i + 1;\r\n\r\n                yield return 10 * i + 3;\r\n\r\n                yield return 10 * i + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static public void ShowLst137(int count)\r\n\r\n        {\r\n\r\n            int[] numbers = Lst137().Take(count).ToArray();\r\n\r\n            for (int i = 0; i < count; i++)\r\n\r\n            {\r\n\r\n                Console.Write(\"{0}, \", numbers[i]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string s_c = \"0\";\r\n\r\n\r\n\r\n            Console.Write(\"\r\nEnter count of digits(exit = hit ENTER): \");\r\n\r\n            s_c = Console.ReadLine();\r\n\r\n\r\n\r\n            while (s_c != \"\")\r\n\r\n            {\r\n\r\n                int count = Convert.ToInt32(s_c);\r\n\r\n                ShowLst137(count);\r\n\r\n\r\n\r\n                Console.Write(\"\r\n\r\nEnter count of digits(exit = hit ENTER): \");\r\n\r\n                s_c = Console.ReadLine();\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine(\"\r\n\r\n---------\r\nHappy end. Now hit ENTER\");\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6887,93,'55363692','2013-10-25 21:32:56',1,'﻿import Data.List\r\n\r\n\r\n\r\n-- тут, в принципе, можно быстрее, если использовать Heap вместо сортированного списка\r\n\r\nham\' (next:ls) = let \r\n\r\n	nextLS = insert (next * 3) ls\r\n\r\n	in \r\n\r\n		if (next `mod` 3) /= 0 then next : ham\' (insert (next * 10) nextLS)\r\n\r\n		else next : ham\' nextLS\r\n\r\n\r\n\r\nham = ham\' [1]\r\n','<br/>Тесты успешно пройдены!'),(6886,68,'42284313','2013-10-25 21:23:20',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Task17_1\r\n{\r\n    class Program\r\n    {\r\n        static int transformNmber(int source, int k)\r\n        {\r\n            int multiplier = 1;\r\n            while (k > 0)\r\n            {\r\n                k--;\r\n                source /= 10;\r\n                multiplier *= 10;\r\n            }\r\n  --- ОK, но на самом деле 10^k лучше сосчитать заранее, мы это обсудим в следующий раз немного\r\n\r\n            return source * multiplier;\r\n        }\r\n\r\n        static int[] zeroDigits(int[] array, int k)\r\n        {\r\n            return (array.Select(x => transformNmber(x, k))).ToArray();\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] array = new int[] { 354534, 243520, 6249, 42631 };\r\n            int[] result = zeroDigits(array, 4);\r\n\r\n            for (int i = 0; i < result.Length; i++)\r\n                Console.Write(result[i].ToString() + \" \");\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6881,134,'romos2007','2013-10-25 20:00:19',1,'{--\r\n\r\nЗадача 21-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nimport Data.Set\r\n\r\n\r\n\r\ndata Set used\r\n\r\n\r\n\r\nallLists\' n k used = [(x:xs)| x<-[1..n], not (member x used), xs <- if (k>1) then allLists\' n (k-1) (insert x used) else [[]] ]\r\n\r\n\r\n\r\nallDiffLists n k = allLists\' n k empty\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6882,134,'egeorge','2013-10-25 20:33:06',1,'allDiffLists n 0 = [[]]\r\n\r\nallDiffLists n k = [x:xs | x<-[1..n], xs<-(allDiffLists n (k-1)), not (elem x xs)]','<br/>Тесты успешно пройдены!'),(6883,91,'egeorge','2013-10-25 20:33:26',0,'merge (x:xs) (y:ys) = if (x < y)\r\n                      then (x:(merge xs (y:ys)))\r\n                      else (y:(merge (x:xs) ys))\r\nmerge [] xs = xs\r\nmerge xs [] = xs','Выражение имеет неправильное значение: merge [1,4,8] [2,4,5,10,20]'),(6884,91,'egeorge','2013-10-25 20:37:10',1,'merge (x:xs) (y:ys) = if (x < y)\r\n                      then (x:(merge xs (y:ys)))\r\n                      else if (x > y)\r\n                           then (y:(merge (x:xs) ys))\r\n                           else (merge (x:xs) ys)\r\nmerge [] xs = xs\r\nmerge xs [] = xs','<br/>Тесты успешно пройдены!'),(6885,93,'romos2007','2013-10-25 21:13:26',1,'{--\r\n\r\nЗадача 22-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\nНам нужны все возможные числа, полученные из 1 умножением на 3 и на 10.\r\n\r\nПри этом они должны идти в порядке возрастания\r\n\r\nИспользуем merge и пробуем смержить списки последовательного умножения на 3 и на 10\r\n\r\n-}\r\n\r\nmerge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n	| x < y = x : merge xs (y:ys)\r\n\r\n	| x > y = y:merge (x:xs) ys\r\n\r\n	|otherwise = x:merge xs ys\r\n\r\n\r\n\r\nham = 1 : merge (map (h->h*10) ham) (map (h->h*3) ham)\r\n\r\n\r\n\r\n{-\r\n\r\n-- Сначала я пробовал итеративно \"вручную\" пробовать вычислять значения, но что-то не продумал. \r\n\r\n-- Поэтому этот способ пропускает иногда числа, полученные чередованием умножения на 3 и на 10. Например,\r\n\r\n-- 		take 10 ham\'\' = [1,3,9,10,27,81,100,243,729,1000]\r\n\r\n-- По сравнению с методом выше, здесь отсутствуют 30, 90, 270, 300, 810, 900 ...\r\n\r\n\r\n\r\nham\'\' = 1:ham\' [] 1 1 1\r\n\r\nham\' xs x3 x10 xlast =  let\r\n\r\n							x3\' = x3 * 3\r\n\r\n							x10\' = x10 * 10\r\n\r\n							xlast3 = xlast * 3\r\n\r\n							xlast10 = xlast * 10\r\n\r\n							xmin = minimum [x3\',x10\',xlast3,xlast10]\r\n\r\n						in\r\n\r\n							if (xmin == x3\')\r\n\r\n							then if (x3\'==xlast3)\r\n\r\n								 then (xmin : (ham\' xs x3\' x10 xlast3))\r\n\r\n								 else (xmin : (ham\' xs x3\' x10 xlast))\r\n\r\n							else\r\n\r\n								if (xmin == x10\')\r\n\r\n								then if (x10\'==xlast10)\r\n\r\n									 then (xmin : (ham\' xs x3 x10\' xlast10))\r\n\r\n									 else (xmin : (ham\' xs x3 x10\' xlast))\r\n\r\n								else\r\n\r\n									if (xmin == xlast3)\r\n\r\n									then if (x3\'==xlast3)\r\n\r\n										 then (xmin : (ham\' xs x3\' x10 xlast3))\r\n\r\n										 else (xmin : (ham\' xs x3 x10 xlast3))\r\n\r\n									else\r\n\r\n										if (xmin == xlast10)\r\n\r\n										then if (x10\'==xlast10)\r\n\r\n									 		 then (xmin : (ham\' xs x3 x10\' xlast10))\r\n\r\n									 		 else (xmin : (ham\' xs x3 x10 xlast10))\r\n\r\n										else []\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6878,75,'romos2007','2013-10-25 19:59:08',1,'{--\r\n\r\nЗадача 21-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-----------------------------------------\r\n\r\na). Тип foldr:\r\n\r\n(a->b->b)->b->[a]->b\r\n\r\n\r\n\r\nHaskell сказал по поводу \":t foldr\":\r\n\r\nfoldr :: (a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\nСошлось :-)\r\n\r\n----------------------------------------\r\n\r\nb). Алгоритм Хиндли-Милнера:\r\n\r\n\r\n\r\nfoldr f e (x:xs) = f x (foldr f e xs)\r\n\r\nfoldr f e [] = e\r\n\r\n\r\n\r\nЭтап 1-ый\r\n\r\n*	x1->x2->x3->x4\r\n\r\n*	x1 = функция 2-х аргументов, т.к. это видно, когда применяется f x (foldr f e xs)\r\n\r\n	x1 = x5 -> x6 -> x7\r\n\r\n*	x3 = массив элементов. Т.е. x3 = [x8]\r\n\r\n\r\n\r\nИтого: (x5->x6->x7)->x2->[x8]->x4\r\n\r\n\r\n\r\nЭтап 2-ой\r\n\r\n*	x2 = x4, т.к. во втором правиле \'e\'-параметр и \'e\' - результат foldr\r\n\r\n	(x5->x6->x7)->x2->[x8]->x2\r\n\r\n\r\n\r\n*	f применяется к аргументам элемент списка(=x8) и результату foldr (который есть x2)\r\n\r\n	Тип результата f = тип результата foldr (x2)\r\n\r\n	Т.о. x5=x8, x6=x7=x2:\r\n\r\n	(x8->x2->x2)->x2->[x8]->x2\r\n\r\n\r\n\r\nИтог: \r\n\r\n(x8->x2->x2)->x2->[x8]->x2, т.е.\r\n\r\n(a ->b ->b )->b ->[a] ->b\r\n\r\n-----------------------------------------}\r\n','<br/>Тесты успешно пройдены!'),(6879,91,'romos2007','2013-10-25 19:59:25',1,'{--\r\n\r\nЗадача 21-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nmerge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n	| x < y = x : merge xs (y:ys)\r\n\r\n	| x > y = y:merge (x:xs) ys\r\n\r\n	|otherwise = x:merge xs ys\r\n','<br/>Тесты успешно пройдены!'),(6880,134,'romos2007','2013-10-25 19:59:51',0,'{--\r\n\nЗадача 21-4\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\nimport Data.Set\r\n\n\r\n\ndata Set used\r\n\n\r\n\nallLists\' n k used = [(x:xs)| x<-[1..n], not (member x used), xs <- if (k>1) then allLists\' n (k-1) (insert x used) else [[]] ]\r\n\n\r\n\nallLists n k = allLists\' n k empty\r\n\n\n','Не удалось вычислить выражение \"length (allDiffLists 3 3)\", проверьте правильность синтаксиса'),(6877,81,'romos2007','2013-10-25 19:58:49',1,'{--\r\n\r\nЗадача 21-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\n[1,3,7,11,13,17,31,33,37,71,73,77,...] <=>\r\n\r\n[1,3,7] ++ [11,13,17,  31,33,37,  71,73,77] ++ ...\r\n\r\n-}\r\n\r\n\r\n\r\n{-\r\n\r\nlst137\' = [1,3,7] ++ (map (\r\n\r\n						xs -> foldl (++)\r\n\r\n									[] \r\n\r\n									(map (x->[10*x+1,10*x+3,10*x+7]) xs)\r\n\r\n						)\r\n\r\n						lst137\')\r\n\r\n\r\n\r\n--Не работает с оператором ++. Пришлось попробовать так:\r\n\r\n-}\r\n\r\n\r\n\r\nlst137\' = [1,3,7] : (map (\r\n\r\n						xs -> foldr (++)\r\n\r\n									[] \r\n\r\n									(map (x->[10*x+1,10*x+3,10*x+7]) xs)\r\n\r\n						)\r\n\r\n						lst137\')\r\n\r\n\r\n\r\nlst137 = foldr (++) [] lst137\'\r\n','<br/>Тесты успешно пройдены!'),(6876,68,'3270666','2013-10-25 19:55:07',1,'--- В задачах на С# надо обязательно выкладывать целую программу, с using,  печатью результатов и т.д.\r\n--- Выложите такой вариант пожалуйста. \r\n\r\nstatic int[] zeroDigits(int[] a, int n)\r\n        {\r\n            return a.Select(x => Math.Max(0, x - x % Convert.ToInt32(Math.Pow(10, n)))).ToArray();\r\n        }','<br/>Тесты успешно пройдены!'),(6875,93,'1595828','2013-10-25 19:09:51',1,'merge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys) \r\n\r\n | x==y = x:merge xs ys\r\n\r\n | x>y  = y:merge(x:xs) ys\r\n\r\n |otherwise =x:merge xs (y:ys)\r\n\r\nham = 1 : merge (map (*3) ham) (map (*10) ham)\r\n','<br/>Тесты успешно пройдены!'),(6874,134,'SNNatalieS','2013-10-25 18:32:49',1,'allDiffLists n 0 = [[]]	\r\nallDiffLists n k = [x:xs| xs<-allDiffLists n (k-1), x<-[1..n], let r = any (==x) xs, r == False]','<br/>Тесты успешно пройдены!'),(6873,134,'SNNatalieS','2013-10-25 18:31:47',0,'allLists n 0 = [[]]	\r\nallLists n k = [x:xs| xs<-allLists n (k-1), x<-[1..n], let r = any (==x) xs, r == False]','Не удалось вычислить выражение \"length (allDiffLists 3 3)\", проверьте правильность синтаксиса'),(6871,81,'2156724','2013-10-25 18:25:39',0,'','Не удалось вычислить выражение \"take 15 lst137\", проверьте правильность синтаксиса'),(6872,81,'2156724','2013-10-25 18:26:27',1,'﻿--как сделать через завязывание ы узел пока не придумал, пока так\r\n  --- OK, и так сойдет:) Но если придумаете, пришлите, интересно будет посмотреть.\r\n\r\n\r\ndigits137 0 = True\r\n\r\n\r\n\r\ndigits137 n =\r\n\r\n   if (k == 1) ||  (k == 3) || (k==7) then digits137 (quot n 10)\r\n\r\n   else False\r\n\r\n   where k = (rem n 10)\r\n\r\n\r\n\r\n\r\n\r\nlst137 = filter (\r\n -> digits137 n) [1..]\r\n','<br/>Тесты успешно пройдены!'),(6870,75,'2156724','2013-10-25 17:44:49',1,'foldr f e [] = e\r\nfoldr f e (x:xs) = f e (foldr f e xs)\r\n\r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\nЭтап 1 - определяем сложные конструкции\r\n\r\nx1 == (x5 -> x6 -> x7)\r\n    x1 - f и это функция (стоит справа от равенства)\r\n\r\nx3 == [x8] - т.к это список\r\n\r\nx4 == x6 т.к результат выполнения функции foldr - результат выполнения функции f\r\n\r\nполучаем\r\n (x5->x6->x7) -> x2 -> [x8] -> x4\r\n\r\nЭтап 2\r\n   x4 == x7 - т.к результат выполнения foldr - результат выполнения f\r\n\r\n (x5->x6->x4) -> x2 -> [x8] -> x4\r\n  \r\n   x2 == x6 т.к это один и тот же параметр\r\n         \r\n (x5->x6->x4) -> x6 -> [x8] -> x4\r\n\r\n    x6 == x4 - т.к foldr f e [] = e\r\n\r\n (x5->x6->x6) -> x6 -> [x8] -> x6\r\n \r\n     x8 == x5 т.к функция f принимает список типов x8\r\n\r\n (x8->x6->x6) -> x6 -> [x8] -> x6\r\n    \r\n\r\n','<br/>Тесты успешно пройдены!'),(6864,91,'3270666','2013-10-25 15:43:07',1,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys) = if (x > y)\r\n	then y : merge (x:xs) ys\r\n	else if (x == y)\r\n	  then x : merge xs ys\r\n	  else x : merge xs (y:ys)','<br/>Тесты успешно пройдены!'),(6865,134,'3270666','2013-10-25 15:56:25',1,'allDiffLists n 0 = [[]]\r\nallDiffLists n k = [x:xs | x <- [1..n], xs <- allDiffLists n (k - 1),\r\n    filter (== x) xs == []]','<br/>Тесты успешно пройдены!'),(6866,81,'3270666','2013-10-25 16:02:15',1,'lst137 = 1:3:7:(make137 lst137)\r\n\r\nmake137 [] = []\r\nmake137 (x:xs) = let x10 = x * 10\r\n                 in x10 + 1 : x10 + 3 : x10 + 7 : make137 xs','<br/>Тесты успешно пройдены!'),(6867,81,'1595828','2013-10-25 17:05:39',1,'lst137 = 1:3:7:concatMap (a ->zipWith (x y -> (x*10+y)) (replicate 3 a) [1,3,7] ) lst137\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6868,91,'1595828','2013-10-25 17:28:47',1,'merge [] ys = ys\r\n\r\nmerge xs [] = xs\r\n\r\nmerge (x:xs) (y:ys) \r\n\r\n | x==y = x:merge xs ys\r\n\r\n | x>y  = y:merge(x:xs) ys\r\n\r\n |otherwise =x:merge xs (y:ys)\r\n','<br/>Тесты успешно пройдены!'),(6869,83,'1595828','2013-10-25 17:39:20',1,'\r\n\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System;\r\n\r\nnamespace zd23_1\r\n\r\n{\r\n\r\n    class zd\r\n\r\n    {\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                yield return (i * 10 + 1);\r\n\r\n                yield return (i * 10 + 3);\r\n\r\n                yield return (i * 10 + 7);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n = 1;\r\n\r\n\r\n\r\n            System.Console.Write(\"Введите целое, положительное число - кол-во элементов: \");\r\n\r\n            int i = 1;\r\n\r\n            n = Convert.ToInt32(System.Console.ReadLine());\r\n\r\n            foreach (int x in Lst137())\r\n\r\n            {\r\n\r\n                Console.Write(\"{0},\", x);\r\n\r\n                if (++i == n)\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6863,75,'3270666','2013-10-25 15:36:03',1,'а) (a -> b -> b) -> b -> [a] -> b\r\n\r\n\r\n\r\nб) Если я всё правильно понимаю, функция foldr в Хаскелле описывается так:\r\n\r\nfoldr f z []     = z \r\n\r\nfoldr f z (x:xs) = f x (foldr f z xs)\r\n\r\n\r\n\r\nУ foldr 3 аргумента, поэтому изначально тип будет \r\n\r\nx1 -> x2 -> x3 -> x4.\r\n\r\n\r\n\r\nТип f - x1, а в правой части второго правила мы используем f как функцию с двумя аргументами, поэтому \r\n\r\nx1 = (x5 -> x6 -> x7)\r\n\r\n\r\n\r\nУ (x:xs) тип x3, поэтому\r\n\r\nx3 = [x8]\r\n\r\n\r\n\r\nПока получаем\r\n\r\n(x5 -> x6 -> x7) -> x2 -> [x8] -> x4\r\n\r\n\r\n\r\nПеременная x входит в множество [x8], и в то же время является первым аргументом функции f (x5 -> x6 -> x7), поэтому\r\n\r\nx5 == x8\r\n\r\n\r\n\r\nРезультат работы foldr есть результат применения функции f, поэтому\r\n\r\nx4 == x7\r\n\r\n\r\n\r\nВ то же время результат применения foldr используется в качестве второго аргумента f, так что\r\n\r\nx4 == x6\r\n\r\n\r\n\r\nНаконец, из первого правила понятно, что тип переменной z совпадает с типом результата работы foldr, то есть\r\n\r\nx2 == x4\r\n\r\n\r\n\r\nТаким образом, проведя замену x5 == x8 = a; x2 == x4 == x6 == x7 = b, получаем\r\n\r\n(a -> b -> b) -> b -> [a] -> b\r\n','<br/>Тесты успешно пройдены!'),(6862,91,'2156724','2013-10-25 15:33:26',1,'merge [] [] = []\r\n \r\nmerge [] (y:ys) = y:ys\r\n\r\nmerge (x:xs) [] = x:xs\r\n\r\nmerge (x:xs) (y:ys) =\r\n\r\n    if x > y then y : merge (x:xs) ys\r\n\r\n    else\r\n\r\n      if x < y then x : merge xs (y:ys)\r\n\r\n      else x : merge xs ys\r\n','<br/>Тесты успешно пройдены!'),(6861,134,'2156724','2013-10-25 15:29:20',1,'allDiffLists n 0 = [[]]	\r\n\r\nallDiffLists n k = [x:xs | x<-[1..n], xs<-allDiffLists n (k-1), elem x xs == False]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6860,134,'2156724','2013-10-25 15:28:43',0,'allDiffLists n 0 = [[]]	\r\n\nallDiffLists n k = [x:xs | x<-[1..n], xs<-allLists n (k-1), elem x xs == False]\r\n\n\n','Не удалось вычислить выражение \"length (allDiffLists 3 3)\", проверьте правильность синтаксиса'),(6859,75,'SNNatalieS','2013-10-25 14:50:07',1,'а)(a -> b -> b) -> b -> [a] -> b\r\nб)foldr f res xs -> smth\r\nт.е. изначально имеет вид x1 -> x2 -> x3 -> x4\r\n1 этап:\r\n1) x3 - список, поэтому выглядит так: [x3]\r\n2) х1 - функция с 2мя аргументами,т.е. х1 = (х5 -> х6 -> х7)\r\nТаким образом, получаем (х5 -> х6 -> х7) -> х2 -> [x3] -> х4\r\n2 этап:\r\n1) x2 == x4, тк х2 - накапливающийся параметр, который возвращается функцией\r\n2) х1 - функция, которая принимает на вход элемент списка (его тип х3) и накапливающийся параметр (с типом х2) и возвращает значение типа х2, значит \r\n   х5 == х3, х6 == х7 == х2\r\nВ результате: foldr :: (х3 -> х2 -> х2) -> х2 -> [x3] -> х2','<br/>Тесты успешно пройдены!'),(6858,134,'nbumakov','2013-10-25 13:34:35',1,'allDiffLists n 0 = [[]]\r\nallDiffLists n k = [ x:xs | x <- [1..n], xs <- allDiffLists n (k - 1), notElem x xs]','<br/>Тесты успешно пройдены!'),(6857,91,'nbumakov','2013-10-25 13:34:14',1,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n  | x == y = x:merge xs ys\r\n  | x < y  = x:merge xs (y:ys)\r\n  | otherwise = y:merge (x:xs) ys','<br/>Тесты успешно пройдены!'),(6856,81,'nbumakov','2013-10-25 13:33:53',1,'lst137 = 1:3:7: concatMap (x -> let y = x * 10 in [y + 1, y + 3, y + 7]) lst137','<br/>Тесты успешно пройдены!'),(6855,83,'deripaska','2013-10-25 12:47:27',1,'/*\r\n\r\n	task 23-01\r\n\r\n*Доп. задача на C#, до 8.11*\r\n\r\n\r\n\r\nДля определения IEnumerable на C# тоже можно использовать прием tying the knot. Например, так можно определить геометрическую прогрессию:\r\n\r\n\r\n\r\npublic static IEnumerable<int> Geom()\r\n\r\n{\r\n\r\n    yield return 1;\r\n\r\n    foreach (int i in geom())\r\n\r\n    {\r\n\r\n        yield return 3*i;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nПолучится, видимо, не так эффективно, как на Хаскеле (из-за того, что нет запоминания уже вычисленных значений), но вполне работоспособно.\r\n\r\n\r\n\r\nЗадача:\r\n\r\nРешить задачу 21-1 про числа из цифр 1, 3, 7 на C#. Т.е., описать блок итератора Lst137(), который по очереди возвращает числа 1, 3, 7, 11, 13, 17, 31, 33, 37, 71, 73, 77, 111, 113, 117 и т.д.\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_23_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        const int maxK = 30;\r\n\r\n        public static IEnumerable<int> Lst137()\r\n\r\n        {\r\n\r\n            yield return 1;\r\n\r\n            yield return 3;\r\n\r\n            yield return 7;\r\n\r\n            foreach (int i in Lst137())\r\n\r\n            {\r\n\r\n                yield return 10 * i + 1;\r\n\r\n                yield return 10 * i + 3;\r\n\r\n                yield return 10 * i + 7;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int k = 0;\r\n\r\n            foreach (int x in Lst137())\r\n\r\n            {\r\n\r\n                Console.Write(x + \", \");\r\n\r\n                k++;\r\n\r\n                if (k >= maxK)\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6854,82,'deripaska','2013-10-25 12:25:15',1,'{--\r\n\r\n	task 22-02\r\n\r\n*Доп. задача, до 7.11*\r\n\r\n\r\n\r\nПусть у нас есть система равенств вида:\r\n\r\n<переменная1> = <переменная2>.\r\n\r\nМы представляем ее в Хаскеле, как список пар строк. Например, список [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] описывает систему равенств:\r\n\r\nx = y\r\n\r\ny = z\r\n\r\nn = m\r\n\r\nКроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ncountDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]\r\n\r\n\r\n\r\nРезультат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\r\n--}\r\n\r\n\r\n\r\n-- contains : проверяет, содержится ли v в списке (x:xs)\r\n\r\ncontains [] v = False\r\n\r\ncontains (x:xs) v\r\n\r\n	| x == v = True\r\n\r\n	| otherwise = contains xs v\r\n\r\n\r\n\r\n{-- \r\n\r\nfindVarInGroups : \r\n\r\n	- возращает номер k \"группы переменных\" (начиная отсчёт с 1) в списке (x:xs), в которой находится переменная v;\r\n\r\n	- если переменная не содержится ни в одной группе, то возращается номер 0\r\n\r\n--}\r\n\r\nfindVarInGroups _ [] k = 0\r\n\r\nfindVarInGroups v (x:xs) k\r\n\r\n	| contains x v = k\r\n\r\n	| otherwise = findVarInGroups v xs (k + 1)\r\n\r\n\r\n\r\ndeleteKGroup groups kGroup = filter (g -> g /= kGroup) groups\r\n\r\n\r\n\r\n-- addVarPairInGroupList : добавляет новую пару переменных (\"ревенство\") в список групп переменных (в одной \"группе переменных\" находятся все \"равные\" переменные)\r\n\r\n{--addVarPairInGroupList (v1, v2) [] = [[v1, v2]]\r\n\r\naddVarPairInGroupList (v1, v2) (x:xs)\r\n\r\n	| contains x v1 = (v2:x):xs\r\n\r\n	| contains x v2 = (v1:x):xs\r\n\r\n	| otherwise = x: addVarPairInGroupList (v1, v2) xs\r\n\r\n--}\r\n\r\naddVarPairInGroupList (v1, v2) groups\r\n\r\n	| k1 == 0 && k2 == 0 = [v1, v2]:groups\r\n\r\n	| k1 /= 0 && k2 == 0 = (v2:k1Group):newGroupsWithoutK1\r\n\r\n	| k2 /= 0 && k1 == 0 = (v1:k2Group):newGroupsWithoutK2\r\n\r\n	| k1 /= 0 && k2 /= 0 && k1 /= k2 = (k1Group ++ k2Group):(deleteKGroup newGroupsWithoutK1 k2Group)\r\n\r\n	| otherwise = groups -- т.е. k1 /= 0 && k2 == k1\r\n\r\n	where \r\n\r\n		k1 = findVarInGroups v1 groups 1\r\n\r\n		k2 = findVarInGroups v2 groups 1\r\n\r\n		k1Group = if k1 /= 0 then groups !! (k1 - 1) else []\r\n\r\n		k2Group = if k2 /= 0 then groups !! (k2 - 1) else []\r\n\r\n		newGroupsWithoutK1 = deleteKGroup groups k1Group\r\n\r\n		newGroupsWithoutK2 = deleteKGroup groups k2Group\r\n\r\n\r\n\r\n-- buildDifferentGroupsOfVars : по входному списку \"равенств\" строит список групп переменных (т.е. список списков)\r\n\r\nbuildDifferentGroupsOfVars [] result = result\r\n\r\nbuildDifferentGroupsOfVars (x:xs) result = buildDifferentGroupsOfVars xs (addVarPairInGroupList x result)\r\n\r\n\r\n\r\n-- deleteEqalVars : удаляет все переменные, находящиеся в группе group, из входного списка переменных vars (возвращается \"новый\" список переменных)\r\n\r\ndeleteEqalVars group vars = filter (v -> (contains group v) /= True) vars\r\n\r\n\r\n\r\n-- countDifferentVarsWithGroups : возращает количество (result) различных переменных в входном списке перменных (v:vs), при условии входного списка \"групп переменных\" (groups)\r\n\r\ncountDifferentVarsWithGroups _ [] result = result\r\n\r\ncountDifferentVarsWithGroups groups (v:vs) result =\r\n\r\n	let \r\n\r\n		k = findVarInGroups v groups 1 -- k - номер группы переменных, где находится v\r\n\r\n		newVars = if k /= 0 then deleteEqalVars (groups !! (k - 1)) (v:vs) else vs\r\n\r\n	in countDifferentVarsWithGroups groups newVars (result + 1)\r\n\r\n\r\n\r\n-- 	countDifferentVars : искомая функция\r\n\r\ncountDifferentVars equalities variables =\r\n\r\n	let groups = buildDifferentGroupsOfVars equalities []\r\n\r\n	in countDifferentVarsWithGroups groups variables 0\r\n','<br/>Тесты успешно пройдены!'),(6853,68,'nbumakov','2013-10-25 12:20:37',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Task17\r\n{\r\n    class Task17_1\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 563, 5643, 76796 };\r\n            int[] b = ZeroDigits(a, 2);\r\n\r\n            foreach (var item in b)\r\n                Console.Write(\"{0} \", item);\r\n\r\n            Console.ReadLine();\r\n        }\r\n\r\n        static int[] ZeroDigits(int[] a, int n)\r\n        {\r\n            long pow = (int)Math.Pow(10, n);\r\n            return a.Select(x => (int) (x / pow * pow)).ToArray();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6852,82,'deripaska','2013-10-25 11:44:07',0,'{--\r\n\n	task 22-02\r\n\n*Доп. задача, до 7.11*\r\n\n\r\n\nПусть у нас есть система равенств вида:\r\n\n<переменная1> = <переменная2>.\r\n\nМы представляем ее в Хаскеле, как список пар строк. Например, список [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] описывает систему равенств:\r\n\nx = y\r\n\ny = z\r\n\nn = m\r\n\nКроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\n\r\n\nПример вызова:\r\n\ncountDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]\r\n\n\r\n\nРезультат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\n--}\r\n\n\r\n\n-- contains : проверяет, содержится ли v в списке (x:xs)\r\n\ncontains [] v = False\r\n\ncontains (x:xs) v\r\n\n	| x == v = True\r\n\n	| otherwise = contains xs v\r\n\n\r\n\n-- addVarPairInGroupList : добавляет новую пару переменных (\"ревенство\") в список групп переменных (в одной \"группе переменных\" находятся все \"равные\" переменные)\r\n\naddVarPairInGroupList (v1, v2) [] = [[v1, v2]]\r\n\naddVarPairInGroupList (v1, v2) (x:xs)\r\n\n	| contains x v1 = (v2:x):xs\r\n\n	| contains x v2 = (v1:x):xs\r\n\n	| otherwise = x: addVarPairInGroupList (v1, v2) xs\r\n\n\r\n\n-- buildDifferentGroupsOfVars : по входному списку \"равенств\" строит список групп переменных (т.е. список списков)\r\n\nbuildDifferentGroupsOfVars [] result = result\r\n\nbuildDifferentGroupsOfVars (x:xs) result = buildDifferentGroupsOfVars xs (addVarPairInGroupList x result)\r\n\n\r\n\n{-- \r\n\nfindVarInGroups : \r\n\n	- возращает номер k \"группы переменных\" (начиная отсчёт с 1) в списке (x:xs), в которой находится переменная v;\r\n\n	- если переменная не содержится ни в одной группе, то возращается номер 0\r\n\n--}\r\n\nfindVarInGroups _ [] k = 0\r\n\nfindVarInGroups v (x:xs) k\r\n\n	| contains x v = k\r\n\n	| otherwise = findVarInGroups v xs (k + 1)\r\n\n\r\n\n-- deleteEqalVars : удаляет все переменные, находящиеся в группе group, из входного списка переменных vars (возвращается \"новый\" список переменных)\r\n\ndeleteEqalVars group vars = filter (v -> (contains group v) /= True) vars\r\n\n\r\n\n-- countDifferentVarsWithGroups : возращает количество (result) различных переменных в входном списке перменных (v:vs), при условии входного списка \"групп переменных\" (groups)\r\n\ncountDifferentVarsWithGroups _ [] result = result\r\n\ncountDifferentVarsWithGroups groups (v:vs) result =\r\n\n	let \r\n\n		k = findVarInGroups v groups 1 -- k - номер группы переменных, где находится v\r\n\n		newVars = if k /= 0 then deleteEqalVars (groups !! (k - 1)) (v:vs) else vs\r\n\n	in countDifferentVarsWithGroups groups newVars (result + 1)\r\n\n\r\n\n-- 	countDifferentVars : искомая функция\r\n\ncountDifferentVars equalities variables =\r\n\n	let groups = buildDifferentGroupsOfVars equalities []\r\n\n	in countDifferentVarsWithGroups groups variables 0\n','Выражение имеет неправильное значение: countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]'),(6851,93,'deripaska','2013-10-25 10:42:48',1,'{--\r\n\r\n	task 22-01\r\n\r\n*Доп.задача, до 7.11*\r\n\r\n\r\n\r\nОпишите ham - бесконечную последовательность, состоящую из целых чисел вида 3^i*10^j (где i, j - целые неотрицательные числа), расположенных в порядке возрастания.\r\n\r\n\r\n\r\nДополнительное условие: функция должна работать более-менее быстро. Скажем, надо, чтобы за 30 секунд можно было вычислить элемент с номером 10000.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\n\r\n\r\ntake 10 ham\r\n\r\n\r\n\r\nДолжно получиться \r\n\r\n\r\n\r\n[1,3,9,10,27,30,81,90,100,243]\r\n\r\n\r\n\r\nham !! 10000\r\n\r\n\r\n\r\nДолжно получиться \r\n\r\n\r\n\r\n8862938119652501095929000000000000000000000000000000000000000000000000000000000000000000000000000\r\n\r\n--}\r\n\r\n\r\n\r\nmerge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n	| x < y = x : (merge xs (y:ys))\r\n\r\n	| x > y = y : (merge (x:xs) ys)\r\n\r\n	| otherwise = x : (merge xs ys) -- т.е. x == y\r\n\r\n	\r\n\r\nham = 1: merge (map (x -> x * 3) ham) (map (x -> x * 10) ham)\r\n','<br/>Тесты успешно пройдены!'),(6850,91,'SNNatalieS','2013-10-25 01:35:00',1,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys) = if x < y then (x : (merge xs (y:ys))) \r\n					else  \r\n						if y < x then (y : (merge (x:xs) ys))\r\n						else (x : (merge xs ys))\r\n','<br/>Тесты успешно пройдены!'),(6847,78,'artem.gomerman','2013-10-25 00:25:38',2,' --- Что ж вы условия то не читаете... :) В этой задаче нельзя определять свом функции,\r\n --- те вместо sums\' надо как-то использовать лямбда-выражение с стандартными функциями.  \r\npascal = [1]:(map sums pascal)\r\n\r\n\r\n\r\nsums xs = 1:sums\' xs\r\n\r\nsums\' [_] = [1]\r\n\r\nsums\' (x:xs) = (x + (head xs)):(sums\' xs)\r\n','<br/>Тесты успешно пройдены!'),(6848,81,'SNNatalieS','2013-10-25 00:57:26',1,'lst137 = 1 : 3 : 7 : [x * 10 + k | x <- lst137, k <- [1, 3, 7]]','<br/>Тесты успешно пройдены!'),(6849,91,'SNNatalieS','2013-10-25 01:33:19',0,'m [] ys = ys\r\nm xs [] = xs\r\nm (x:xs) (y:ys) = if x < y then (x : (m xs (y:ys))) \r\n					else  \r\n						if y < x then (y : (m (x:xs) ys))\r\n						else (x : (m xs ys))\r\n','Не удалось вычислить выражение \"merge [1,4,8] [2,4,5,10,20]\", проверьте правильность синтаксиса'),(6846,66,'3226573','2013-10-24 23:57:44',1,'produceList n maxVal cnt = 	let\r\n								temp = fst (foldr ( \\_ (xs, rest) -> (((mod rest maxVal) + 1):xs, div rest maxVal) ) ([], cnt) [1..n])\r\n							in 	if any ( == maxVal) temp\r\n								then [temp]\r\n								else []\r\n\r\nf n maxVal cnt =	let\r\n						xs = produceList n maxVal cnt\r\n						xss =	if (cnt + 1) == foldr (x res -> res * maxVal) 1 [1..n] \r\n								then f n (maxVal + 1) maxVal\r\n								else f n maxVal (cnt + 1)\r\n					in	if length xs > 0 \r\n						then (head xs : xss)							\r\n						else xss\r\n						\r\ngeneralizedCantor n = f n 1 0','<br/>Тесты успешно пройдены!'),(6845,66,'42284313','2013-10-24 23:07:51',1,'  --- ОК, засчитано ( у вас просто программа не очень эффективная, за 30 сек не успевает получить 10000 элементов) \r\n{--\r\n\r\n\r\n\r\n*Доп. задача, до 24.10*\r\n\r\n\r\n\r\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 100 (generalizedCantor 3)\r\n\r\n\r\n\r\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет [[1,1,1], [1,1,2], и т.д.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nkDimDiagonal n 1 = [[n]]\r\n\r\nkDimDiagonal n k = [x : ys | x <- [1..(n - k + 1)], let yss = kDimDiagonal (n - x) (k - 1), ys <- yss]\r\n\r\nallCantors k = [(xs, length xs) | n <- [k..], let xs = kDimDiagonal n k]\r\n\r\n\r\n\r\ngetIndex n k diag indexInDiag\r\n\r\n  | n - indexInDiag <= 0 = (diag, indexInDiag - n)\r\n\r\n  | otherwise = getIndex n k (diag + 1) (indexInDiag + snd (allCantors k !! (diag + 1)))\r\n\r\n\r\n\r\ngenCantor n k =\r\n\r\n  let\r\n\r\n    (diag, indexInDiag) = getIndex n k 0 1\r\n\r\n  in ((fst (allCantors k !! diag)) !! indexInDiag) : (genCantor (n + 1) k)\r\n\r\n\r\n\r\ngeneralizedCantor k = genCantor 1 k\r\n','Не удалось вычислить выражение \"length(filter (==[2,1,4]) (take 10000 (generalizedCantor 3)))\", проверьте правильность синтаксиса'),(6844,66,'42284313','2013-10-24 23:06:34',0,'{--\r\n\n\r\n\n*Доп. задача, до 24.10*\r\n\n\r\n\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\n\r\n\nПример вызова:\r\n\ntake 100 (generalizedCantor 3)\r\n\n\r\n\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет [[1,1,1], [1,1,2], и т.д.\r\n\n\r\n\n--}\r\n\n\r\n\nkDimDiagonal n 1 = [[n]]\r\n\nkDimDiagonal n k = [x : ys | x <- [1..(n - k + 1)], let yss = kDimDiagonal (n - x) (k - 1), ys <- yss]\r\n\nallCantors k = [(xs, length xs) | n <- [k..], let xs = kDimDiagonal n k]\r\n\n\r\n\ngetIndex n k diag indexInDiag\r\n\n  | n - indexInDiag <= 0 = (diag, indexInDiag - n)\r\n\n  | otherwise = getIndex n k (diag + 1) (indexInDiag + snd (allCantors k !! (diag + 1)))\r\n\n\r\n\ngenCantor n k =\r\n\n  let\r\n\n    (diag, indexInDiag) = getIndex n k 0 1\r\n\n  in ((fst (allCantors k !! diag)) !! indexInDiag) : (genCantor (n + 1) k)\r\n\n\r\n\ngeneralizedCantor k = genCantor 1 k\n','Не удалось вычислить выражение \"length(filter (==[2,1,4]) (take 10000 (generalizedCantor 3)))\", проверьте правильность синтаксиса'),(6841,91,'toskira','2013-10-24 22:42:32',1,'merge [] l = l\r\nmerge l [] = l\r\nmerge (a:b) (c:d)\r\n    | a == c = a:(merge b d)\r\n    | a < c = a:(merge b (c:d))\r\n    | otherwise = c:(merge (a:b) d)','<br/>Тесты успешно пройдены!'),(6842,134,'toskira','2013-10-24 22:51:00',1,'import Data.List\r\n\r\nallLists n 0 = [[]]\r\nallLists n k = [(h:t) | h <- [1..n], t <- (allLists n (k-1))]\r\n\r\nallDiffLists n k = ((filter ((k==).length)).(map nub)) (allLists n k)','<br/>Тесты успешно пройдены!'),(6843,66,'42284313','2013-10-24 23:05:54',0,'{--\r\n\n\r\n\n*Доп. задача, до 24.10*\r\n\n\r\n\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\n\r\n\nПример вызова:\r\n\ntake 100 (generalizedCantor 3)\r\n\n\r\n\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет [[1,1,1], [1,1,2], и т.д.\r\n\n\r\n\n--}\r\n\n\r\n\nkDimDiagonal n 1 = [[n]]\r\n\nkDimDiagonal n k = [x : ys | x <- [1..(n - k + 1)], let yss = kDimDiagonal (n - x) (k - 1), ys <- yss]\r\n\nallCantors k = [(xs, length xs) | n <- [k..], let xs = kDimDiagonal n k]\r\n\n\r\n\ngetIndex n k diag indexInDiag\r\n\n  | n - indexInDiag <= 0 = (diag, indexInDiag - n)\r\n\n  | otherwise = getIndex n k (diag + 1) (indexInDiag + snd (allCantors k !! (diag + 1)))\r\n\n\r\n\ngenCantor n k =\r\n\n  let\r\n\n    (diag, indexInDiag) = getIndex n k 0 1\r\n\n  in ((fst (allCantors k !! diag)) !! indexInDiag) : (genCantor (n + 1) k)\r\n\n\r\n\ngeneralizedCantor k = genCantor 1 k\n','Не удалось вычислить выражение \"length(filter (==[2,1,4]) (take 10000 (generalizedCantor 3)))\", проверьте правильность синтаксиса'),(6840,65,'42284313','2013-10-24 22:41:58',1,'{--\r\n\r\n\r\n\r\n*Доп. задача, до 24.10*\r\n\r\n\r\n\r\nОписать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 100 cantor\r\n\r\n\r\n\r\nЧто получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ncalculateDiagonal n k\r\n\r\n	| n <= div (k * (k + 1)) 2 = k\r\n\r\n	| otherwise = calculateDiagonal n (k + 1)\r\n\r\n\r\n\r\ncantorList n = \r\n\r\n	let\r\n\r\n		diag = calculateDiagonal n 1\r\n\r\n		sum = div (diag * (diag + 1)) 2\r\n\r\n		i = sum - n;\r\n\r\n		j = diag - i - 1;\r\n\r\n	in (i + 1,j + 1) : cantorList (n + 1)\r\n\r\n\r\n\r\ncantor = cantorList 1\r\n','<br/>Тесты успешно пройдены!'),(6839,81,'toskira','2013-10-24 22:33:24',1,'f (h:t) = let x = h*10 in (x+1):(x+3):(x+7):(f t)\r\n\r\nlst137 = 1:3:7:(f lst137)','<br/>Тесты успешно пройдены!'),(6837,81,'3320654','2013-10-24 22:28:29',1,'lst137 = 1 : 3 : 7 : help [1,3,7]\r\n\r\nhelp (x:xs) = (10 * x + 1) : (10 * x + 3) : (10 * x + 7) : (help (xs ++ [(10 * x + 1),(10 * x + 3), (10 * x + 7)]))','<br/>Тесты успешно пройдены!'),(6838,91,'3320654','2013-10-24 22:33:01',1,'merge [] list = list\r\nmerge list [] = list\r\nmerge (x:xs) (y:ys) = 	if x < y\r\n		then x : (merge xs (y:ys))\r\n		else	if x > y\r\n			then y : (merge (x:xs) ys)\r\n			else y : (merge xs ys)','<br/>Тесты успешно пройдены!'),(6835,66,'nomeansno','2013-10-24 21:59:58',2,'generalizedCantor 0 = [[]]\r\ngeneralizedCantor k = [(x:xs) | x<-[1..], xs<-generalizedCantor (k-1)]\r\n   --- Нет, мы же говорили, нельзя в list comprehension использовать больше одного бесконечного списка.\r\n   --- У вас например, мы никогда не дойдем до x == 2, потому что бесконечно будем перебирать\r\n   --- варианты для x == 1 ','Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),(6836,93,'3320654','2013-10-24 22:16:37',1,'--seq использована для отказа от ленивых вычислений\r\n--иначе stack overflow error\r\n--ham !! 10000 за 6 секунд\r\n   --- ОК, но можно и без seq сосчитать очень эффективно..)\r\nham = help [1]\r\n\r\nhelp list = 	let k = minimum list\r\n	in k `seq` (k) : help (filter (> k) ((3 * k) : (10 * k) : list))\r\n','<br/>Тесты успешно пройдены!'),(6834,66,'Artur','2013-10-24 21:59:31',1,'get 0 (xs:xss) = xs\r\n\r\nget k (xs:xss) = get (k-1) xss\r\n\r\n\r\n\r\n\r\n\r\ngeneralizedCantor 1 =	 map (i -> [i]) [1..]\r\n\r\ngeneralizedCantor 2 =	 cantor\r\n\r\ngeneralizedCantor k =	map ([i,j] -> i:(get (j-1) xss) ) cantor  \r\n\r\n						where xss =generalizedCantor (k-1)\r\n\r\n\r\n\r\n\r\n\r\ng k =  let  \r\n\r\n			sumN i = i*(i+1) `div` 2\r\n\r\n			f = (i,n) -> n < k && sumN (i+1) >= k\r\n\r\n			(n, sum) = head (filter f (map (i -> (i ,sumN i)) [0..] )) \r\n\r\n			j = k - sum\r\n\r\n		in [n+2-j,j]\r\n\r\n	\r\n\r\nlist k = g k : (list (k+1))\r\n\r\ncantor = list 1\r\n','<br/>Тесты успешно пройдены!'),(6833,66,'Artur','2013-10-24 21:19:00',0,'g xs = [x:xs| x<-[1..maximum xs] ]\r\n\nincrease (xs:xss) = g xs ++ (increase xss)\r\n\n\r\n\ngeneralizedCantor 1 = map (i -> [i]) [1..]\r\n\ngeneralizedCantor k = let xs = generalizedCantor (k-1)\r\n\n						in increase xs\r\n\n\n','Выражение имеет неправильное значение: length(filter(==[6,3])(take 100 (generalizedCantor 2)))'),(6832,66,'Artur','2013-10-24 21:12:18',0,'g xs = [x:xs| x<-[1..minimum xs] ]\r\n\nincrease (xs:xss) = g xs ++ (increase xss)\r\n\n\r\n\ngeneralizedCantor 1 = map (i -> [i]) [1..]\r\n\ngeneralizedCantor k = let xs = generalizedCantor (k-1)\r\n\n						in increase xs\r\n\n\n','Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),(6831,65,'Artur','2013-10-24 20:42:40',1,'g k =  let  \r\n\r\n			sumN i = i*(i+1) `div` 2\r\n\r\n			f = (i,n) -> n < k && sumN (i+1) >= k\r\n\r\n			(n, sum) = head (filter f (map (i -> (i ,sumN i)) [0..] )) \r\n\r\n			j = k - sum\r\n\r\n		in (n+2-j,j)\r\n\r\n		\r\n\r\nlist k = g k : (list (k+1))\r\n\r\ncantor = list 1\r\n','<br/>Тесты успешно пройдены!'),(6830,81,'anlun','2013-10-24 19:44:51',1,'lst137 :: [Int]\r\nlst137 = l ++ [x * 10 + y | x <- lst137, y <- l]\r\n	where\r\n		l = [1, 3, 7]','<br/>Тесты успешно пройдены!'),(6829,91,'anlun','2013-10-24 19:42:28',1,'merge :: [Int] -> [Int] -> [Int]\r\n   --- Но на самом деле не Int, конечно, а все, что можно сравнивать. \r\nmerge x [] = x\r\nmerge [] y = y\r\nmerge (x:xs) (y:ys) | x == y = (:) x $ merge xs ys\r\nmerge (x:xs) (y:ys) | x <  y = (:) x $ merge xs (y:ys)\r\nmerge (x:xs) (y:ys) | x >  y = (:) y $ merge (x:xs) ys','<br/>Тесты успешно пройдены!'),(6828,79,'3320654','2013-10-24 17:39:58',1,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication3\r\n{\r\n    class Program \r\n    {\r\n        static IEnumerable digits(int n)\r\n        {            \r\n            int next = 1;\r\n            for (int i = 2; ; i++)\r\n            {\r\n                --что-то я забыл о нулях\r\n                next *= 10;\r\n                yield return next / n;\r\n                next %= n;\r\n            }\r\n        }\r\n        public static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Введите число n и нажмите Enter:\");\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n            int i = 0;\r\n            foreach (int x in digits(n))\r\n            {                \r\n                Console.Write(x);                                  \r\n                i++;\r\n                if (i == 100)\r\n                    break;\r\n                Console.Write(\", \"); \r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6827,65,'3226573','2013-10-24 16:49:16',1,'cantor\' (x,y) = (x,y):(cantor\' d)\r\n				where d = if x > 1 then (x - 1, y + 1)\r\n						  else (y + 1, 1)\r\ncantor = cantor\' (1, 1)','<br/>Тесты успешно пройдены!'),(6826,134,'artem.gomerman','2013-10-24 16:06:56',1,'allDiffLists n k = allDiffLists\' n k [0]\r\n\r\nallDiffLists\' n 0 _ = [[]]\r\n\r\nallDiffLists\' n k alreadyUsed = [(x:xs) | x <- [1..n], all (/=x) alreadyUsed, xs <- (allDiffLists\' n (k - 1) (x:alreadyUsed))]\r\n','<br/>Тесты успешно пройдены!'),(6825,134,'artem.gomerman','2013-10-24 15:57:31',0,'allDiffLists n k = allDiffLists\' n k 0\r\n\nallDiffLists\' n 0 _ = [[]]\r\n\nallDiffLists\' n k i = [(x:xs) | x <- [1..n], i /= x, xs <- (allDiffLists\' n (k - 1) x)]\n','Выражение имеет неправильное значение: length (allDiffLists 3 3)'),(6824,134,'artem.gomerman','2013-10-24 15:57:02',0,'allLists n k = allLists\' n k 0\r\n\nallLists\' n 0 _ = [[]]\r\n\nallLists\' n k i = [(x:xs) | x <- [1..n], i /= x, xs <- (allLists\' n (k - 1) x)]\n','Не удалось вычислить выражение \"length (allDiffLists 3 3)\", проверьте правильность синтаксиса'),(6823,91,'artem.gomerman','2013-10-24 14:40:32',1,'merge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge xs ys = let\r\n\r\n	x = head xs\r\n\r\n	y = head ys in if x < y then (x:merge (tail xs) ys) else \r\n\r\n		if x > y then (y:merge xs (tail ys)) else (y:merge (tail xs) (tail ys))\r\n','<br/>Тесты успешно пройдены!'),(6822,81,'1835693','2013-10-24 13:24:03',1,'lst137 = genList [] [1, 3, 7]\r\n\r\n-- Небольшой вокараунд для первой итерации\r\ngenList [] values = values ++ genList values values\r\n\r\n-- На каждой итерации генерируем список списков со значениями после добавления каждой цифры в начало и склеиваем их\r\ngenList list values = listPart ++ genList listPart values\r\n                      where listPart = foldl (++) [] [ map (appendDigit x) list | x <- values ]\r\n\r\n-- Добавляет цифру к началу числа: 1, 337 -> 1337\r\nappendDigit digit number = digit * 10 ^ (length $ show number) + number','<br/>Тесты успешно пройдены!'),(6821,81,'artem.gomerman','2013-10-24 13:17:09',1,'import Data.List\r\n\r\n\r\n\r\nlst137 = map fromDigits (filter (all (/= 0)) [generateTernaryList x [] | x <- [1..]])\r\n\r\n\r\n\r\ngenerateTernaryList currentIndex xs = let\r\n\r\n	q = div currentIndex 4\r\n\r\n	r = convertTo137( mod currentIndex 4) in if q == 0 then r:xs else generateTernaryList q (r:xs)\r\n\r\n	\r\n\r\nfromDigits xs = foldl (x res -> res + x*10) 0 xs\r\n\r\n\r\n\r\nconvertTo137 x = case x of\r\n\r\n	0 -> 0\r\n\r\n	1 -> 1\r\n\r\n	2 -> 3\r\n\r\n	3 -> 7\r\n','<br/>Тесты успешно пройдены!'),(6819,134,'1835693','2013-10-24 12:08:58',1,'allDiffLists n k = [xs | xs <- allLists n k, isDiff xs]\r\n\r\nisDiff [] = True\r\nisDiff (x:xs) = (not $ elem x xs) && isDiff xs\r\n\r\nallLists n 0 = [[]]\r\nallLists n k = [x : xs | x <- [1..n], xs <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(6820,81,'artem.gomerman','2013-10-24 12:47:32',2,'   --- Почему-то у вас выдается [1,3,7,11,13,17,31,33,37,71,73,77,311,313,317\r\n   --- Те после 77 долэно идти 111, а у вас почему-то 311\r\nlst137 = zipWith (x y -> 10*x + y) listOfMults lst137\'\r\n\r\nlst137\' = 1:3:7:lst137\'\r\n\r\n\r\n\r\nlistOfMults = 0:0:0:concat [replicate 3 (fromDigits (generateTernaryList x [])) | x <- [0..]]\r\n\r\n\r\n\r\ngenerateTernaryList currentIndex xs = let\r\n\r\n	q = div currentIndex 3\r\n\r\n	r = convertTo137( mod currentIndex 3) in if q == 0 then r:xs else generateTernaryList q (r:xs)\r\n\r\n	\r\n\r\nfromDigits xs = foldl (x res -> res + x*10) 0 xs\r\n\r\n\r\n\r\nconvertTo137 x = case x of\r\n\r\n	0 -> 1\r\n\r\n	1 -> 3\r\n\r\n	2 -> 7','Выражение имеет неправильное значение: take 15 lst137'),(6817,66,'3320654','2013-10-24 00:00:49',1,'generalizedCantor n =  help n n\r\n\r\nhelp t n = if t > 0\r\n                then (allLists t n) ++ (help (t + 1) n)\r\n                else [[]]\r\n\r\n--возвращает все списки длинной k элементов, сумма равна n\r\nallLists n 1 = [[n]]	\r\nallLists n k = [x:xs | x<-[1..(n - 1)], xs<-allLists (n-x) (k-1)]','<br/>Тесты успешно пройдены!'),(6818,91,'1835693','2013-10-24 11:39:10',1,'merge [] [] = []\r\nmerge [] (x:xs) = x : merge [] xs\r\nmerge (x:xs) [] = x : merge xs []\r\nmerge (x:xs) (y:ys) = if (x == y)\r\n                      then merge (x:xs) ys\r\n                      else if (x > y)\r\n                           then y : merge (x:xs) ys\r\n                           else x : merge xs (y:ys)\r\n','<br/>Тесты успешно пройдены!'),(6816,68,'artem.gomerman','2013-10-23 23:55:34',1,'#include <iostream>\r\n\r\n#include <time.h>\r\n\r\n#include <vector>\r\n\r\n#include <algorithm>\r\n\r\n\r\n\r\nvoid zeroDigits(std::vector<unsigned int>& a, unsigned int n)\r\n\r\n{\r\n\r\n	unsigned int roundingNumber = std::pow(10.0f, (float)n);\r\n\r\n	std::transform(a.begin(), a.end(), a.begin(), [roundingNumber](unsigned int i) {return (i / roundingNumber) * roundingNumber;});\r\n\r\n}\r\n\r\n\r\n\r\ninline void printVector(const std::vector<unsigned int>& arr)\r\n\r\n{\r\n\r\n	std::for_each(arr.begin(), arr.end(), [](unsigned int i){std::cout << i << \" \";});\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	srand(time(NULL));\r\n\r\n\r\n\r\n	const unsigned int testVectorsCount = rand() % 5 + 5;\r\n\r\n	const unsigned int zerosCount = 4;\r\n\r\n	for(unsigned int vectorIndex = 0; vectorIndex < testVectorsCount; vectorIndex++)\r\n\r\n	{\r\n\r\n		// generate vector\r\n\r\n		const unsigned int vectorSize = rand() % 5 + 5;\r\n\r\n		std::vector<unsigned int> testVector;\r\n\r\n		for(unsigned int i = 0; i < vectorSize; i++)\r\n\r\n		{\r\n\r\n			testVector.push_back(rand() % 1000000);\r\n\r\n		}\r\n\r\n\r\n\r\n		// test zeroDigits\r\n\r\n		std::cout << \"Testing on vector:\r\n\";\r\n\r\n		printVector(testVector);\r\n\r\n		std::cout << \"\r\n\";\r\n\r\n		for(unsigned int i = 1; i < zerosCount; i++)\r\n\r\n		{\r\n\r\n			std::vector<unsigned int> tempVector = testVector;\r\n\r\n			std::cout << \"	Zeros count: \" << i << \"\r\n\";\r\n\r\n\r\n\r\n			zeroDigits(tempVector, i);\r\n\r\n			std::cout << \"After zeroDigits:\r\n\";\r\n\r\n			printVector(tempVector);\r\n\r\n			std::cout << \"\r\n\";\r\n\r\n		}\r\n\r\n		std::cout << \"\r\n\";\r\n\r\n	}\r\n\r\n\r\n\r\n	system(\"pause\");\r\n\r\n	return 0;\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6813,79,'3320654','2013-10-23 22:34:32',2,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication3\r\n{\r\n    class Program \r\n    {\r\n        static IEnumerable<int> digits(int n)\r\n        {            \r\n            int next = 1;\r\n            for (int i = 2; ; i++)\r\n            {\r\n                while (next < n)\r\n                {\r\n                    next *= 10;\r\n                }\r\n                yield return next / n;\r\n   --- Тут немного неправильно. Например, для 99 у вас выдает 1, 1, 1, 1, 1 а надо 0, 1, 0, 1, 0, 1\r\n   --- Исправьте, пожалуйста. \r\n                next %= n;\r\n            }\r\n        }\r\n        public static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Введите число n и нажмите Enter:\");\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n            int i = 0;\r\n            foreach (int x in digits(n))\r\n            {                \r\n                Console.Write(x);                                  \r\n                i++;\r\n                if (i == 100)\r\n                    break;\r\n                Console.Write(\", \"); \r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6814,134,'3320654','2013-10-23 22:56:40',1,'allDiffLists n 0 = [[]]	\r\nallDiffLists n k = [x:xs | x<-[1..n], xs<-allDiffLists n (k-1), not (any (== x) xs)]','<br/>Тесты успешно пройдены!'),(6815,66,'3320654','2013-10-23 23:17:40',0,'--такое является решением задачи? :D формально, да, но вот фактически\r\ngeneralizedCantor 0 = [[]]	\r\ngeneralizedCantor n = [x:xs | x<-list, xs<-generalizedCantor (n - 1)]\r\nlist = 1 : (map (+1) list)','Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),(6812,80,'3320654','2013-10-23 22:16:36',1,'﻿using System;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\n--пришлось загружать файлом, в окошку почему-то не вставляет (видимо какое-то ограничение на длину)\r\n\r\n--а также в строке Console.Write(\"]\")  должно быть Console.Write(\"backslashb]\")\r\n\r\n--чтобы стереть лишнюю запятую\r\n\r\n--почему-то загрузчик всегда убирает бэкслэши\r\n   --- Да, есть такой баг, все никак не   соберусь исправить :( \r\n\r\nnamespace ConsoleApplication3\r\n\r\n{\r\n\r\n    class Program \r\n\r\n    {\r\n\r\n        static int[] getPairs(int n)\r\n\r\n        {\r\n\r\n            int[] array = new int[2 * (n - 1)];\r\n\r\n            int a = 0, b = n, i = 0;\r\n\r\n            while (b > 1)\r\n\r\n            {\r\n\r\n                a++;\r\n\r\n                b--;\r\n\r\n                array[i] = a;\r\n\r\n                array[i + 1] = b;\r\n\r\n                i += 2;\r\n\r\n            }\r\n\r\n            return array;\r\n\r\n        }\r\n\r\n        static IEnumerable<int[]> pairs()\r\n\r\n        {\r\n\r\n            for (int i = 2; ; i++)\r\n\r\n            {\r\n\r\n                yield return getPairs(i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.Write(\"[\");\r\n\r\n            foreach (int[] x in pairs())\r\n\r\n            {                \r\n\r\n                for (int i = 0; i < x.Length; i += 2) \r\n\r\n                {\r\n\r\n                    Console.Write(\"[\" + x[i] + \",\" + x[i + 1] + \"]\");\r\n\r\n                    Console.Write(\",\");                   \r\n\r\n                }\r\n\r\n                if (x[0] + x[1] > 10)               \r\n\r\n                    break;               \r\n\r\n            }\r\n\r\n            Console.Write(\"]\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6808,134,'115753099','2013-10-23 18:15:33',0,'allLists n 0 = [[]]\r\nallLists n k = [x:xs | x <- [1..n], xs <- allLists n (k-1), not (elem x xs)]','Не удалось вычислить выражение \"length (allDiffLists 3 3)\", проверьте правильность синтаксиса'),(6809,134,'115753099','2013-10-23 18:16:07',1,'allDiffLists n 0 = [[]]\r\nallDiffLists n k = [x:xs | x <- [1..n], xs <- allDiffLists n (k-1), not (elem x xs)]','<br/>Тесты успешно пройдены!'),(6810,68,'3320654','2013-10-23 21:26:32',1,'using System;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication3\r\n{\r\n    class Program\r\n    {\r\n        static int power(int a, int n)\r\n        {\r\n            int res = 1;\r\n            for (int i = 1; i <= n; i++)\r\n                res *= a;\r\n            return res;\r\n        }\r\n        static int[] ZeroDigits(int[] a, int n)\r\n        {\r\n            return a.Select(x => x / power(10,n) * power(10,n)).ToArray();\r\n        }\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] a = { 563, 5643, 76796 };\r\n            int[] b = ZeroDigits(a, 2);\r\n            for (int i = 0; i < b.Length; i++)\r\n            {\r\n                Console.WriteLine(b[i]);            \r\n            }\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6811,80,'3320654','2013-10-23 22:14:04',0,'﻿using System;\r\n\nusing System.Linq;\r\n\nusing System.Collections.Generic;\r\n\n\r\n\n--пришлось загружать файлом, в окошку почему-то не вставляет (видимо какое-то ограничение на длину)\r\n\nnamespace ConsoleApplication3\r\n\n{\r\n\n    class Program \r\n\n    {\r\n\n        static int[] getPairs(int n)\r\n\n        {\r\n\n            int[] array = new int[2 * (n - 1)];\r\n\n            int a = 0, b = n, i = 0;\r\n\n            while (b > 1)\r\n\n            {\r\n\n                a++;\r\n\n                b--;\r\n\n                array[i] = a;\r\n\n                array[i + 1] = b;\r\n\n                i += 2;\r\n\n            }\r\n\n            return array;\r\n\n        }\r\n\n        static IEnumerable<int[]> pairs()\r\n\n        {\r\n\n            for (int i = 2; ; i++)\r\n\n            {\r\n\n                yield return getPairs(i);\r\n\n            }\r\n\n        }\r\n\n        public static void Main(string[] args)\r\n\n        {\r\n\n            Console.Write(\"[\");\r\n\n            foreach (int[] x in pairs())\r\n\n            {                \r\n\n                for (int i = 0; i < x.Length; i += 2) \r\n\n                {\r\n\n                    Console.Write(\"[\" + x[i] + \",\" + x[i + 1] + \"]\");\r\n\n                    Console.Write(\",\");                   \r\n\n                }\r\n\n                if (x[0] + x[1] > 10)               \r\n\n                    break;               \r\n\n            }\r\n\n            Console.Write(\"]\");\r\n\n            Console.ReadKey();\r\n\n        }\r\n\n    }\r\n\n}\r\n\n\n','<br/>Тесты успешно пройдены!'),(6807,91,'115753099','2013-10-23 18:10:15',1,'merge [] xs = xs\r\nmerge ys [] = ys\r\nmerge (y:ys) (x:xs)\r\n	| x > y 	= y : merge ys (x:xs)\r\n	| x < y 	= x : merge (y:ys) xs\r\n	| otherwise = x : merge ys xs','<br/>Тесты успешно пройдены!'),(6805,81,'115753099','2013-10-23 17:19:09',1,'lst137 = 1:3:7:f2\r\nf2 = concat $ map (x -> [x*10+1, x*10+3, x*10+7]) lst137','<br/>Тесты успешно пройдены!'),(6806,75,'115753099','2013-10-23 17:57:51',1,'foldr :: (t -> g -> g) -> g -> [t] -> g\r\nfoldr f e [] = e\r\nfoldr f e (x:xs) = x `f` (foldr f e xs)\r\n\r\nx1 -> x2 -> x3 -> x4\r\n1.1. x1 = (x5 -> x6 -> x7)\r\n	т.к. f - функция примененная к 2-ум аргументам\r\n1.2. x3 = [x8]\r\n	т.к. (x:xs)\r\nт.о. (x5 -> x6 -> x7) -> x2 -> [x8] -> x4\r\n\r\n2.1. x6 == x7 == x2 == x4 := g\r\n	результат f служит вторым аргументом для неё же;\r\n	f применяется к x2, как ко 2-ому аргументу\r\n2.2. x5 == x8 := t\r\n	потому что f применяется к элементам списка\r\n\r\nитого: (t -> g -> g) -> g -> [t] -> g','<br/>Тесты успешно пройдены!'),(6804,81,'115753099','2013-10-23 17:18:26',0,'lst15 = 1:3:7:f2\r\nf2 = concat $ map (x -> [x*10+1, x*10+3, x*10+7]) lst15','Не удалось вычислить выражение \"take 15 lst137\", проверьте правильность синтаксиса'),(6803,81,'115753099','2013-10-23 17:16:53',0,'f = 1:3:7:f2\r\nf2 = concat $ map (x -> [x*10+1, x*10+3, x*10+7]) f','Не удалось вычислить выражение \"take 15 lst137\", проверьте правильность синтаксиса'),(6802,134,'deripaska','2013-10-23 16:08:21',1,'{--\r\n\r\n	task 21-04\r\n\r\nОписать функцию allDiffLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nallDiffLists 3 2\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\r\n\r\n\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\n--}\r\n\r\ngenListWithout [] n = [1..n]\r\n\r\ngenListWithout (x:xs) n = filter (y -> x /= y) (genListWithout xs n)\r\n\r\n\r\n\r\nallDiffLists _ 0 = [[]]\r\n\r\nallDiffLists n k = [(x:xs) | xs <- allDiffLists n (k - 1), x <- (genListWithout xs n)]\r\n','<br/>Тесты успешно пройдены!'),(6801,91,'deripaska','2013-10-23 15:49:56',1,'{--\r\n\r\n	task 21-03\r\n\r\nОпишите функцию merge, у которой два параметра - списки, причем мы точно знаем, что эти значения в этих списках строго возрастают. Функция должна вернуть строго возрастающий список, содержащий значения из обеих списков. Если элемент встречается в обеих списках, в результате он должен встречаться только один раз. \r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\nmerge [1,4,8] [2,4,5,10,20]\r\n\r\n\r\n\r\nДолжно получиться\r\n\r\n\r\n\r\n[1,2,4,5,8,10,20]\r\n\r\n--}\r\n\r\n\r\n\r\nmerge xs [] = xs\r\n\r\nmerge [] ys = ys\r\n\r\nmerge (x:xs) (y:ys)\r\n\r\n	| x < y = x : (merge xs (y:ys))\r\n\r\n	| x > y = y : (merge (x:xs) ys)\r\n\r\n	| otherwise = x : (merge xs ys) -- т.е. x == y\r\n','<br/>Тесты успешно пройдены!'),(6800,75,'deripaska','2013-10-23 15:41:35',1,'{--\r\n\r\n	task 21-02\r\n\r\nВ этой задаче надо прислать не программу, а просто текст.\r\n\r\na. Напишите, какой тип у функции foldr (если хотите, можете посмотреть, а можете сами попробовать придумать)\r\n\r\nб. Расскажите, как можно вывести этот тип, используя определение foldr - примерно так, как мы это делали на занятии для map. Т.е. в этой задаче надо показать, неформально, как для foldr работает алгоритм Хиндли-Милнера.\r\n\r\n--}\r\n\r\n(1) foldr f e [] = e\r\n\r\n(2) foldr f e (x:xs) = f x (foldr f e xs)\r\n\r\n\r\n\r\n1 этап.\r\n\r\na). Очевидно, что функция \"от трех параметров\", т.е.:\r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\n\r\n\r\nb). По программе видно, что:\r\n\r\nx3 - это список (т.к. \'[]\' в (1) и \'x:xs\' в (2)), т.е. x3 = [x5]\r\n\r\nx1 - это функция \"с двумя параметрами\" (т.к. \'f x (foldr f e xs)\' в (2)), т.е. x1 = x6 -> x7 -> x8\r\n\r\nТаким образом, foldr : (x6 -> x7 -> x8) -> x2 -> [x5] -> x4\r\n\r\n\r\n\r\n2 этап.\r\n\r\nx8 = x4, т.к. \'f x (foldr f e xs)\' является, очевидно, результатом f (т.е. x8), но также и результатом foldr (из (2), т.е. x4);\r\n\r\nx4 = x7, т.к. \'foldr f e xs\' является, очевидно, результатом foldr (т.е. x4), но также и \"вторым\" входным параметром f(из (2) \'f x (foldr f e xs)\', т.е. x7);\r\n\r\nx5 = x6, т.к. \'x\' - элемент (точнее \'головой\') списка, являющегося \"третим\" входным параметром foldr, (т.е. x5), но при этом \'x\' - \"первый\" входной параметр f(из (2) \'f x (foldr f e xs)\', т.е. x6);\r\n\r\nx2 = x4, т.к. \'e\' - \"второй\" входной параметр foldr (т.е. x2), но при этом \'e\' также является результатом foldr (из (1) \'foldr f e [] = e\', т.е. x4);\r\n\r\n\r\n\r\nТаким образом, x2 = x4 = x7 = x8 и x5 = x6, значит foldr : (x5 -> x2 -> x2) -> x2 -> [x5] -> x2\r\n\r\n(заменим x2 на a, x5 на b), тогда foldr : (b -> a -> a) -> a -> [b] -> a\r\n','<br/>Тесты успешно пройдены!'),(6799,81,'deripaska','2013-10-23 14:53:09',1,'{--\r\n\r\n	task 21-01\r\n\r\nОписать бесконечный список lst137, содержащий все целые положительные числа, состоящие только из цифр 1, 3 и 7. (Числа должны идти в порядке возрастания).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ntake 15 lst239\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[1,3,7,11,13,17,31,33,37,71,73,77,111,113,117]\r\n\r\n\r\n\r\nЗамечание:\r\n\r\n- Эта задача, на самом деле, довольно эффектно решается с помощью tying the knot. Но, если не придумаете как тут завязать этот узел, эту задачу можно решить любым способом.\r\n\r\n--}\r\n\r\n\r\n\r\n{--\r\n\r\nascribe1 [] = []\r\n\r\nascribe1 (x:xs) = (1:x):(ascribe1 xs)\r\n\r\n\r\n\r\nascribe3 [] = []\r\n\r\nascribe3 (x:xs) = (3:x):(ascribe3 xs)\r\n\r\n\r\n\r\nascribe7 [] = []\r\n\r\nascribe7 (x:xs) = (7:x):(ascribe7 xs)\r\n\r\n\r\n\r\ngenThreeList xs = (ascribe1 xs) ++ (ascribe3 xs) ++ (ascribe7 xs)\r\n\r\n\r\n\r\nconvertToInt [x] = x\r\n\r\nconvertToInt (x:xs) = (convertToInt xs) * 10 + x\r\n\r\n\r\n\r\nlst137_help = [[1], [3], [7]]:(map (xss -> genThreeList xss) lst137_help)\r\n\r\nlst137 = map (xs -> convertToInt (reverse xs)) (foldr (++) [] lst137_help)\r\n\r\n--}\r\n\r\n\r\n\r\nascribeForNumber x = [10 * x + 1, 10 * x + 3, 10 * x + 7]\r\n\r\nbuildNextList xs = foldr (++) [] (map (ascribeForNumber) xs)\r\n\r\n\r\n\r\nlst137_help = [1, 3, 7]:(map (buildNextList) lst137_help)\r\n\r\nlst137 = foldr (++) [] lst137_help\r\n','<br/>Тесты успешно пройдены!'),(6798,78,'2156724','2013-10-23 12:01:30',1,'pascal = [1]: map (\r\n -> 1: zipWith (+) n (tail n) ++[1]) pascal\r\n','<br/>Тесты успешно пройдены!'),(6796,81,'5543298','2013-10-23 02:07:24',1,'lst137 = 1:3:7: [y + z | y <- (map (*10) lst137), z <- [1,3,7]]\r\n','<br/>Тесты успешно пройдены!'),(6797,66,'egeorge','2013-10-23 09:00:42',1,'generalizedCantor 0 = [[]]\r\n\r\ngeneralizedCantor 1 = [[x] | x <- [1..]]\r\n\r\ngeneralizedCantor n = [y:(x - y):xs | x:xs <- (generalizedCantor (n-1)),\r\n                                      y <- [1..(x - 1)]]','<br/>Тесты успешно пройдены!'),(6795,91,'5543298','2013-10-23 01:40:25',1,'import Data.List\r\n\r\n--manual way\r\n\r\nmerge\'\' [] zs = zs\r\n\r\nmerge\'\' (x:xs) (y:ys) = let zs = (y:ys) in if x /= y then merge\'\' xs (x:zs) else merge\'\' xs zs\r\n\r\nmerge\' [] ys zs = merge\'\' ys zs\r\n\r\nmerge\' (x:xs) [] zs = merge\'\' xs zs\r\n\r\nmerge\' (x:xs) (y:ys) [] = if (x < y) then merge\' xs (y:ys) [x] else merge\' (x:xs) ys [y] \r\n\r\nmerge\' (x:xs) (y:ys) (z:zs) = let ws = z:zs in if (x == z) then merge\' xs (y:ys) ws else if (y == z) then merge\' (x:xs) ys ws else if (x < y) then merge\' xs ys (y:x:ws) else if (y < x) then merge\' xs ys (x:y:ws) else merge\' xs ys (x:ws) \r\n\r\nmerge xs ys = reverse (merge\' xs ys [])\r\n\r\n\r\n\r\n--simple way\r\n\r\nmerge1 xs ys = sort (xs `union` ys) \r\n   --- Это конечно просто, но менее эффективно - ручной алгоритм линейный, а этот O(n*log n)\r\n   --- И еще, даже более важно, ручной алгоритм работает с бесконечными списками, а этот - нет\r\n','<br/>Тесты успешно пройдены!'),(6793,134,'55363692','2013-10-23 01:34:12',1,'allDiffLists n 0 = [[]]	\r\n\r\nallDiffLists n k = [x:xs | x <-[1..n], xs <- allDiffLists n (k-1), not (elem x xs)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6794,91,'5543298','2013-10-23 01:37:44',0,'import Data.List\r\n\n--manual way\r\n\nmerge\'\' [] zs = zs\r\n\nmerge\'\' (x:xs) (y:ys) = let zs = (y:ys) in if x /= y then merge\'\' xs (x:zs) else merge\'\' xs zs\r\n\nmerge\' [] ys zs = merge\'\' ys zs\r\n\nmerge\' (x:xs) [] zs = merge\'\' xs zs\r\n\nmerge\' (x:xs) (y:ys) [] = if (x < y) then merge\' xs ys [y, x] else if (y < x) then merge\' xs ys [x,y] else merge\' xs ys [x] \r\n\nmerge\' (x:xs) (y:ys) (z:zs) = if (x == z) then merge\' xs (y:ys) zs else if (y == z) then merge\' (x:xs) ys zs else let ws = z:zs in if (x < y) then merge\' xs ys (y:x:ws) else if (y < x) then merge\' xs ys (x:y:ws) else merge\' xs ys (x:ws) \r\n\nmerge xs ys = reverse (merge\' xs ys [])\r\n\n\r\n\n--simple way\r\n\nmerge1 xs ys = sort (xs `union` ys) \n','Выражение имеет неправильное значение: merge [1,2] [3,4]'),(6792,91,'55363692','2013-10-23 01:21:13',1,'merge xs [] = xs\r\n\r\nmerge [] xs = xs\r\n\r\nmerge list1@(x:xs) list2@(y:ys) = \r\n\r\n	if (x < y) then x : merge xs list2\r\n\r\n	else if (x == y) then x : merge xs ys\r\n\r\n	else y : merge list1 ys\r\n','<br/>Тесты успешно пройдены!'),(6791,78,'2156724','2013-10-23 01:11:22',2,'func [1] [] = []\r\n\r\nfunc [a,b] [] = [(a+b)]\r\n\r\nfunc [a,b] xs = a+b : xs\r\n\r\nfunc b xy =  func (tail b) ((head (tail b) + head b) : xy)\r\n\r\n\r\n\r\nfunc1 n [] = 1: (func n []) ++[1] \r\n   --- Это же не по условию, в условии написано, что нельзя определять свои функции.\r\n   --- Попробуйте, пожалуйста, вместо func1 написать лямбда выражение, с использованием стандартных\r\n   --- функций. Это не очень сложно.\r\n\r\n\r\npascal = [1]: map (\r\n -> func1 n []) pascal\r\n','<br/>Тесты успешно пройдены!'),(6788,78,'5543298','2013-10-23 00:57:08',1,'pascal = [1]: map (xs -> let ys = 0:xs in zipWith (+) ys (reverse ys)) pascal\r\n\r\n\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(6789,134,'5543298','2013-10-23 00:57:23',1,'allDiffLists\' n 0 _= [[]]	\r\n\r\nallDiffLists\' n k ys = [x:xs | x <- [1..n], length (filter (==x) ys) == 0, xs <- allDiffLists\' n (k-1) (x:ys)]\r\n\r\nallDiffLists n k = allDiffLists\'  n k []\r\n','<br/>Тесты успешно пройдены!'),(6790,81,'55363692','2013-10-23 01:04:29',1,'lst137 = let digits = [1, 3, 7] in digits ++ concat [[x * 10 + l | l <- digits] | x <- lst137]\r\n','<br/>Тесты успешно пройдены!'),(6786,78,'8519021','2013-10-23 00:55:13',1,'pascal = [1]:[1:((zipWith (+) xs (tail xs))++[1]) | xs <- pascal]\r\n','<br/>Тесты успешно пройдены!'),(6787,78,'5543298','2013-10-23 00:56:50',0,'allDiffLists\' n 0 _= [[]]	\r\n\nallDiffLists\' n k ys = [x:xs | x <- [1..n], length (filter (==x) ys) == 0, xs <- allDiffLists\' n (k-1) (x:ys)]\r\n\nallDiffLists n k = allDiffLists\'  n k []\n','Не удалось вычислить выражение \"take 6 pascal\", проверьте правильность синтаксиса'),(6785,78,'5543298','2013-10-23 00:37:27',1,'pascal = [1]: map (xs -> let ys = 0:xs in zipWith (+) ys (reverse ys)) pascal\r\n\r\n\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(6784,75,'6053606','2013-10-23 00:28:19',1,'{-\r\nfoldr ::\r\n(a -> b -> b) -> b -> [a] -> b\r\n\r\nfoldr k z = go\r\n          where\r\n            go []     = z\r\n            go (y:ys) = y `k` go ys\r\n\r\nx1 -> x2 -> x3 -> x4\r\n\r\n1.\r\nx1 = (x5 -> x6 -> x7)\r\nx3 = [x8]\r\n\r\nПолучили:\r\n(x5 -> x6 -> x7) -> x2 -> [x8] -> x4\r\n\r\n2.\r\n\r\nx5 == x8, потому что y `k` go ys, то есть k вызывется от элемента списка y с типом x8\r\n\r\nx6 == x7, потому что результат go ys мы подставляем вторым аргументом в функцию `k`\r\n\r\nx7 == x2, потому что go [] = z\r\n\r\nx4 == x2, потому что возвращаем результат go\r\n\r\nПолучилось\r\n(x5 -> x2 -> x2) -> x2 -> [x5] -> x2\r\n-}\r\n','<br/>Тесты успешно пройдены!'),(6783,134,'6053606','2013-10-22 23:57:13',1,'allDiffLists n 0 = [[]]\r\nallDiffLists n k = [x:xs | x <- [1..n], xs <- allDiffLists n (k-1), x `notElem` xs]\r\n','<br/>Тесты успешно пройдены!'),(6782,91,'6053606','2013-10-22 23:46:28',1,'merge [] ys = ys\r\nmerge xs [] = xs\r\nmerge (x:xs) (y:ys)\r\n  | x == y    = x : merge xs ys\r\n  | x > y     = y : merge (x:xs) ys\r\n  | otherwise = x : merge xs (y:ys)\r\n','<br/>Тесты успешно пройдены!'),(6781,81,'6053606','2013-10-22 23:38:51',1,'lst137 = 1:3:7:[n * 10 + d | n <- lst137, d <- [1, 3, 7]]\r\n  --- Ой , это у меня тесты неправильные, сейчас исправлю','Не удалось вычислить выражение \"take 15 lst239\", проверьте правильность синтаксиса'),(6779,65,'8519021','2013-10-22 22:07:53',1,'cantor\' n = (zip [1..n] (reverse [1..n])) ++ cantor\' (n+1)\r\n\r\ncantor = cantor\' 1\r\n','<br/>Тесты успешно пройдены!'),(6780,77,'romos2007','2013-10-22 22:26:34',1,'{--\r\n\r\nЗадача 19-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\nsqrt2 = sqrt2\' 2 0\r\n\r\nsqrt2\' n prev = let curr = getNextDig n prev\r\n\r\n				in curr : sqrt2\' (100*n) (10*(prev + curr))\r\n\r\n\r\n\r\ngetNextDig n prev = head (filter (x -> (x + prev)^2 <= n) (reverse [0..9]))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6777,66,'artem.gomerman','2013-10-22 16:10:45',1,'generalizedCantor n = (fillWithZeros [] n) : [xs | j <- [2..], xs <- filter (xs -> any (j==) xs) (generateAllLists j n)]\r\n\r\n\r\n\r\ngenerateAllLists neededMax neededLength = [generateList i neededMax neededLength [] | i <- [1..(neededMax^neededLength - 1)]]\r\n\r\n\r\n\r\ngenerateList currentIndex neededMax neededLength xs = let\r\n\r\n	q = div currentIndex neededMax\r\n\r\n	r = mod currentIndex neededMax in if q == 0 then (fillWithZeros ((r + 1):xs) neededLength) else generateList q neededMax neededLength ((r + 1):xs)\r\n\r\n\r\n\r\nfillWithZeros inputList neededLength = [1 | i <- [1..neededLength - (length inputList)]] ++ inputList\r\n','<br/>Тесты успешно пройдены!'),(6778,66,'5543298','2013-10-22 16:15:52',1,'import Data.List\r\n\r\n\r\n\r\n--use task 13.1\r\n\r\ncheckList xs n k = sum xs <= n * k\r\n\r\nallLists\' n k xs = if length xs == k then [xs] else foldr (ys res -> (allLists\' n k ys)++res) [] [(x:xs) | x <- [1..n], checkList xs n k]\r\n\r\nallLists n k = allLists\' n k []\r\n\r\n\r\n\r\n--it isn\'t optimal but it works\r\n\r\ngeneralizedCantor n = [x | m <- [1..], x <- [xs | xs <- allLists m n  allLists (m - 1) n]]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6776,77,'115753099','2013-10-22 13:23:25',1,'import Data.List\r\n--- getNext 9 1 2\r\n--- getNext 9 141 20000\r\ngetNext digit curNumber cur2Number\r\n	| digit == 0 = 0\r\n	| (curNumber * 10 + digit) ^ 2 < cur2Number * 100 = digit\r\n	| otherwise = getNext (digit - 1) curNumber cur2Number\r\n\r\nsqrt2 = 1 : xs where\r\n	(x, xs) = mapAccumL ((curNumber, cur2Number) x -> let i = getNext 9 curNumber cur2Number in ((curNumber * 10 + i, cur2Number*100), i)) (1, 2) [1..]','<br/>Тесты успешно пройдены!'),(6775,80,'2156724','2013-10-22 13:12:04',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace cantor\r\n{\r\n    class Program\r\n    {\r\n        public static int diag(int n, int k)\r\n        {\r\n            if (n <= k * (k+1) /2) return k;\r\n            else return diag (n, k+1);\r\n        }\r\n\r\n        public static IEnumerable<double[]> cantor()\r\n        {\r\n            double[] a = new double[2];\r\n            for (int n = 1; ; n++)\r\n            {\r\n                int b = diag(n,1) + 1;\r\n                int k = b - 1;\r\n                a[0] = n - k * (k-1) / 2;\r\n                a[1] = -a[0] + b;\r\n                yield return a;\r\n            }\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (double[] x in cantor().Take(15))\r\n            {\r\n                Console.Write(\" (\" + x[0] + \",\" + x[1]  + \") \");\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6774,79,'2156724','2013-10-22 12:57:11',2,'  --- Нет, так нельзя.. Если вы вызовите digits(7).Take(100), то увидите, что у вас\r\n  --- период довольно скоро нарушается. Это из-за того, что Math.Pow(10,i) / n при больших n\r\n  --- считает неправильно (переполнение)\r\n  --- Попробуйте исправить, пожалуйста.\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace digits\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> digits(int n)\r\n        {\r\n            for (int i = 1; ; i++)\r\n            {\r\n                yield return  Math.Truncate( Math.Pow(10,i) / n) % 10;\r\n            }\r\n        }\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            foreach (double x in digits(10).Take(15))\r\n            {\r\n                Console.Write(x + \" \"); \r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6773,68,'2156724','2013-10-22 12:30:18',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication4\r\n{\r\n    class Program\r\n    {\r\n        static double[] zeroDigits(int[] a, int n)\r\n        {\r\n            double[] c = a.Select(x => Math.Truncate(x / Math.Pow(10,(double) n)) * Math.Pow(10, (double)n)).ToArray();\r\n            return c;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 563, 5643, 76796 };\r\n            double[] b = zeroDigits(a,2);\r\n            for (int i = 0; i < b.Length; ++i)\r\n            {\r\n                System.Console.Write(b[i] + \" \");\r\n            }\r\n            System.Console.ReadLine();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6772,79,'115753099','2013-10-22 12:29:20',1,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n		public static IEnumerable digits (int n)\r\n		{\r\n			int rest = 0;\r\n			int devident = 10;\r\n			int devisor = n;\r\n			int quotient = 0;\r\n			for (int i = 1; ; i++)\r\n			{\r\n				quotient = devident / devisor;\r\n				rest = devident % devisor;\r\n				if (quotient != 0)\r\n				{\r\n					devident = rest * 10;\r\n				} else {\r\n					devident *= 10;\r\n				}\r\n				yield return quotient;\r\n			}\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			Console.Write(\"Hello!\r\nInput number: n = \");\r\n			int n = Console.Read() - \'0\';\r\n			Console.Write(\";\r\n\r\nResult(1/n) = 0,\");\r\n			int i = 0;\r\n			foreach (int x in digits(n))\r\n			{\r\n				if (i == 100) break;\r\n				i++;\r\n				Console.Write(x.ToString());\r\n			}\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6771,65,'2156724','2013-10-22 12:29:10',1,'diag k n = if n <= (k * (k+1)/2 ) then k \r\n\r\n    else diag (k+1) n \r\n\r\n\r\n\r\ncantor = [(truncate x,  truncate y) |  n <- [1..], let b = diag 1 n + 1, let k = b-1, let x =n - k* (k-1)/2, let y = -x +b] \r\n\r\n          \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6770,65,'nomeansno','2013-10-22 00:12:32',1,'cantor = g 1\r\n\r\n	where g n = f n ++ g (n+1)\r\n\r\n		where f n = zip (s1++s2) (s2++s1)\r\n\r\n			where s1 = [1..n-1]; s2 = [n | x <-[1..n]];\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6767,78,'62628590','2013-10-21 23:29:36',1,'pascal = [1] : map (xs -> 1 : zipWith (+) xs (tail xs ++ [0])) pascal','<br/>Тесты успешно пройдены!'),(6768,77,'2156724','2013-10-22 00:07:19',2,'func n = (rem (truncate ((sqrt 2) * 10 ^ n)) 10) : func (n+1)\r\n  --- Нет так нельзя.. Если вы пишете sqrt(2), то вы получаете приближение для квадратного\r\n  --- корня с той точностью, которую позволяет тип double (примерно 16 знаков)\r\n  --- А дальше все цифры будут неправильные.\r\n  --- Что же делать? Можно придумать разные способы, но проще всего, видимо,\r\n  --- как-то свести задачу к задаче с целыми числами. А дальше все просто, так как\r\n  --- целые числа в Хаскеле имеют бесконечную точность.\r\nsqrt2 = func 0','Выражение имеет неправильное значение: take 20 sqrt2'),(6769,66,'nomeansno','2013-10-22 00:11:45',2,'cantor = g 1\r\n  --- Это у вас не та задача решается - это опечатка, да?\r\n	where g n = f n ++ g (n+1)\r\n\r\n		where f n = zip (s1++s2) (s2++s1)\r\n\r\n			where s1 = [1..n-1]; s2 = [n | x <-[1..n]];\r\n\r\n\r\n\r\n\r\n','Не удалось вычислить выражение \"length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))\", проверьте правильность синтаксиса'),(6766,77,'1595828','2013-10-21 23:09:37',1,'sqrt2=(truncate (sqrt 2)):sqrt\' (17,12) 1 0\r\n\r\nsqrt\' (num,den) mul deg = \r\n\r\n let\r\n\r\n	new = num*(10^mul)`div` den `mod` 10\r\n\r\n	(a,b,c) \r\n\r\n		| (mul<=3*2^deg-2) = (num,den,deg) \r\n\r\n		|  otherwise   = ((num^2+2*den^2),(2*den*num),deg+1)\r\n\r\n in  new:sqrt\' (a,b) (mul+1) c\r\n','<br/>Тесты успешно пройдены!'),(6765,77,'1595828','2013-10-21 23:05:07',0,'sqrt2=(truncate (sqrt 2)):sqrt\' (17,12) 1 0\r\n\nsqrt\' (num,den) mul deg = \r\n\n let\r\n\n	new = num*(10^mul)`div` den `mod` 10\r\n\n	(a,b,c) \r\n\n		| (mul<=3*2^deg) = (num,den,deg) \r\n\n		|  otherwise   = ((num^2+2*den^2),(2*den*num),deg+1)\r\n\n in  new:sqrt\' (a,b) (mul+1) c\n','Выражение имеет неправильное значение: take 20 sqrt2'),(6764,65,'6053606','2013-10-21 22:54:10',1,'cantor = concatMap (\\n -> [(a, b) | a <- [1..n], b <- [1..n], a + b == n]) [1..]\r\n   --- ОК но вообще-то вместо b <- [1..n], a + b == n можно написать let b = n - a :)','<br/>Тесты успешно пройдены!'),(6763,77,'1595828','2013-10-21 22:47:23',0,'--sqrt2 = (truncate (sqrt 2)):sqrt\'  (10)\r\n\n--sqrt\' y = ((truncate((sqrt 2)*y)) `mod` 10):sqrt\' (y*10)\r\n\nsqrt2=(truncate (sqrt 2)):sqrt\' (3,2) 1 1\r\n\nsqrt\' (num,den) mul deg = \r\n\n let\r\n\n	new = num*(10^mul)`div` den `mod` 10\r\n\n	c\r\n\n		|(mul<=3*2^deg) = deg \r\n\n		|otherwise = (deg+1)\r\n\n	(a,b) =if (mul==3*2^c) then (num,den) else ((num^2+2*den^2),(2*den*num))\r\n\n in  new:sqrt\' (a,b) (mul+1) c\n','Выражение имеет неправильное значение: take 20 sqrt2'),(6762,65,'6053606','2013-10-21 22:47:15',0,'--- Конечно, этот список настолько бесконечный, что \r\n--- до элемента (2, 1) так и не дойдёт :( \r\n--- Наверное, это не то, что нужно?\r\ncantor = (1, 1) : [(a, b + 1) | (a, b) <- cantor] ++ [(a + 1, b) | (a, b) <- cantor]\r\n','Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),(6760,77,'1595828','2013-10-21 21:37:59',0,'sqrt2 = (truncate (sqrt 2)):sqrt\'  (10)\r\n\nsqrt\' y = ((truncate((sqrt 2)*y)) `mod` 10):sqrt\' (y*10)\r\n\n\n','Выражение имеет неправильное значение: take 20 sqrt2'),(6761,68,'2156724','2013-10-21 22:38:31',0,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication4\r\n{\r\n    class Program\r\n    {\r\n        static double[] zeroDigits(int[] a, int n)\r\n        {\r\n            double[] c = a.Select(x => Math.Truncate(x / Math.Pow(10,(double) n)) * Math.Pow(10, (double)n)).ToArray();\r\n            return c;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 563, 5643, 76796 };\r\n            double[] b = zeroDigits(a,2);\r\n            for (int i = 0; i < b.Length; ++i)\r\n            {\r\n                System.Console.Write(b[i] + \" \");\r\n            }\r\n            System.Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6759,77,'1595828','2013-10-21 19:06:42',0,'sqrt2 = fromIntegral(truncate (sqrt 2)):sqrt\'  (10)\r\n\nsqrt\' y = fromIntegral(truncate((sqrt 2)*y) -  ((truncate ((sqrt 2)*y)) `div` 10 *10)):sqrt\' (y*10)\r\n\n\n','Выражение имеет неправильное значение: take 20 sqrt2'),(6755,65,'egeorge','2013-10-21 12:32:05',1,'cantor = [(x,k-x) | k <- [1..], x <- [1..(k-1)]]','<br/>Тесты успешно пройдены!'),(6756,66,'egeorge','2013-10-21 12:40:08',2,'generalizedCantor 1 = [[x] | x <- [1..]]\r\n\r\ngeneralizedCantor n = [x:xs | xs <- generalizedCantor (n - 1), x <- [1..]]\r\n  --- Нет, мы обсуждали что так нельзя. И вообще в list comprehension нельзя использовать больше одного бесконечного списка','Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),(6757,78,'1835693','2013-10-21 14:10:42',1,'pascal = [1] : (map (xs -> zipWith (+) (0:xs) (xs ++ [0])) pascal)\r\n','<br/>Тесты успешно пройдены!'),(6758,77,'1835693','2013-10-21 16:52:09',1,'sqrt2 = sqrtList 0 2 0\r\n\r\n\r\n\r\n-- res - текущий результат (\'склеивание\' первых len элементов списка)\r\n\r\n-- n - искомое число (в этой конкретной задаче - 2)\r\n\r\nsqrtList res n len = x : sqrtList (10 * res + x) n (len + 1)\r\n\r\n                     where x = (nextDigit res n len)\r\n\r\n\r\n\r\n-- Вычисляет, какая цифра будет добавлена следующей\r\n\r\nnextDigit res n len = head [ x | x <- [0..9], isDigitOk x res n len ]\r\n\r\n\r\n\r\n-- Критерий добавления: при добавлении квадрат должен, очевидно, не превосходить n\r\n\r\n-- Но при этом это должна быть максимальная из таких цифр\r\n\r\n\r\n\r\n-- Поскольку цифры перебираются, начиная с 0, то если 0-8 не подходят, то это гарантированно 6\r\n\r\nisDigitOk 9 _   _ _   = True\r\n\r\nisDigitOk x res n len = (sqrDiff n res x len > 0) && (sqrDiff n res (x + 1) len < 0)\r\n\r\n\r\n\r\n-- Разница между n^2 и квадратом числа, составленного из первых len цифр последовательности (с учетом точки)\r\n\r\n-- (На самом деле, эта разница домножена на 10 ^ (2 * len) - для того, чтобы избежать ошибок округления.\r\n\r\n-- В isDigitOk все равно идет сравнение с нулем).\r\n\r\nsqrDiff n res x len = n * (10 ^ (2 * len)) - ((10 * res + x) ^ 2)\r\n\r\n\r\n\r\naddDigit res x = 10 * res + x\r\n','<br/>Тесты успешно пройдены!'),(6750,74,'1170660','2013-10-21 11:10:04',0,'','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6751,74,'1170660','2013-10-21 11:10:23',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node i l r) = f i (foldTree f e l) (foldTree f e r)\r\n\r\n\r\n\r\nsumPos tree = foldTree(x leftsum rightsum ->if x > 0 then x+leftsum+rightsum else leftsum+rightsum ) 0 tree\r\n','<br/>Тесты успешно пройдены!'),(6752,133,'1170660','2013-10-21 11:20:31',1,'fib = 1:1:(zipWith(+) fib (tail fib))\r\n\r\n	\r\n','<br/>Тесты успешно пройдены!'),(6753,132,'1170660','2013-10-21 11:33:27',1,'facts = 1:(zipWith (*) facts [2..])\r\n','<br/>Тесты успешно пройдены!'),(6754,66,'nbumakov','2013-10-21 11:40:27',1,'generalizedCantor n = concatMap (`allLists2` n) [n ..]\r\n\r\nallLists2 n k =  filter(xs -> sum xs == n) (allLists (n-k+1) k)\r\n\r\nallLists n 0 = [[]]\r\nallLists n k = [ x:xs | x <- [1..n], xs <- allLists n (k - 1)]','<br/>Тесты успешно пройдены!'),(6749,72,'1170660','2013-10-21 10:58:35',1,'week= 0:0:0:0:0:1:1:week\r\n\r\nweekendExpences xs =foldr (+) 0 (zipWith(*) week xs)\r\n','<br/>Тесты успешно пройдены!'),(6748,65,'nbumakov','2013-10-21 10:52:18',1,'cantor = concatMap cantor2 [2 ..]\r\ncantor2 n = [(x,y)|x<-[1..n-1], let y = n-x]','<br/>Тесты успешно пройдены!'),(6747,69,'1170660','2013-10-21 10:51:25',1,'bigSin x = filter (>=x) (map sin [1..])!!0\r\n','<br/>Тесты успешно пройдены!'),(6743,72,'6053606','2013-10-21 03:25:44',1,'weekendExpences [] = 0\r\nweekendExpences xs = sum weekend + weekendExpences rest where\r\n  week = take 7 xs\r\n  rest = drop 7 xs\r\n\r\n  weekend = drop 5 week\r\n','<br/>Тесты успешно пройдены!'),(6744,132,'6053606','2013-10-21 03:47:34',1,'facts = 1:[n * i | (i, n) <- zip [2..] facts]\r\n','<br/>Тесты успешно пройдены!'),(6745,133,'6053606','2013-10-21 03:58:49',1,'fib = 1:1:[a + b | (a, b) <- zip fib $ tail fib]\r\n','<br/>Тесты успешно пройдены!'),(6746,74,'6053606','2013-10-21 04:35:54',1,'data Tree = Empty\r\n          | Node Int Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n  resl = foldTree f e l\r\n  resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\nsumPos = foldTree\r\n         (v l r -> l + r + max 0 v) 0\r\n','<br/>Тесты успешно пройдены!'),(6737,133,'MaryK','2013-10-21 02:23:45',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),take,RealFloat(),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nfib = 1:1:zipWith (+) fib (tail fib)\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(6738,74,'MaryK','2013-10-21 02:58:51',0,'','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6739,74,'MaryK','2013-10-21 02:59:05',0,'module Func where\r\n\nimport Prelude(Bool(..),zipWith,(!!),take,RealFloat(),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\ndata Tree = Empty | Node Int Tree Tree\r\n\nfoldTree f e (Node val l r) = let\r\n\n	resl = foldTree f e l\r\n\n	resr = foldTree f e r\r\n\n	in f val resl resr\r\n\n\r\n\nfoldTree f e Empty = e\r\n\nsumPos = foldTree(v l r->if l<0 then v+r else  if r<0 then v+l else r+v+l) 0\r\n\n \n','Выражение имеет неправильное значение: sumPos (Node (-5) (Node 2 Empty Empty) Empty)'),(6740,69,'6053606','2013-10-21 03:00:57',0,'bigSin x = head $ dropWhile (> x) $ map sin ','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6741,69,'6053606','2013-10-21 03:08:07',1,'bigSin x = head $ dropWhile (< x) $ map sin [1..]\r\n','<br/>Тесты успешно пройдены!'),(6742,74,'MaryK','2013-10-21 03:20:15',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),take,RealFloat(),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ndata Tree = Empty | Node Int Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n	resl = foldTree f e l\r\n\r\n	resr = foldTree f e r\r\n\r\n	in f val resl resr\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nsumPos = foldTree(v l r->if v<0 then l+0+r else  if r<0 then 0+v+l else if l<0 then 0+v+r else v+l+r) 0\r\n   --- l и r вы совершенно зря проверяете, их надо просто сложить\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(6736,132,'MaryK','2013-10-21 02:10:41',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),take,RealFloat(),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nfacts = 1:(zipWith (*) [2..] facts)\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(6735,72,'MaryK','2013-10-21 01:55:15',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),cycle,div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nweekendExpences::[Int]->Int\r\n\r\nweekendExpences xs = sum(zipWith (*) (xs) (cycle[0,0,0,0,0,1,1]))\r\n','<br/>Тесты успешно пройдены!'),(6734,74,'54411321','2013-10-21 01:51:28',1,'data Tree = Empty | \r\n\r\n            Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n                                 resl = foldTree f e l   \r\n\r\n                                 resr = foldTree f e r\r\n\r\n                              in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nsumPos t = foldTree (v l r -> l + r + (if v > 0 then v else 0)) 0 t\r\n','<br/>Тесты успешно пройдены!'),(6733,66,'bazhutin','2013-10-21 01:41:33',1,'checkN n [] = 0\r\ncheckN n (x:xs)\r\n	| (x == n)  = 1\r\n	| otherwise = checkN n xs\r\n   --- ОК, но я бы возращал не 1 и 0 а True и False. Это и логичнее и вызывать потом проще.\r\n\r\nallLists n 1 = [ [x] | x <- [1..n] ]\r\nallLists n k = [ x:xs |  x <- [1..n], xs <- allLists n (k-1)]\r\n\r\n\r\nclist n i = (filter (x-> (checkN i x == 1)) (allLists i n)) ++ clist n (i+1)\r\n\r\ngeneralizedCantor n = clist n 1','<br/>Тесты успешно пройдены!'),(6729,133,'3301494','2013-10-21 01:24:54',1,'fib = 1 : 1 : map ((a,b) -> a + b) (zip fib (tail fib))\r\n','<br/>Тесты успешно пройдены!'),(6730,66,'bazhutin','2013-10-21 01:25:37',0,'checkN n [] = 0\r\ncheckN n (x:xs)\r\n	| (x == n)  = 1\r\n	| otherwise = checkN n xs\r\n\r\nallLists n 1 = [ [x] | x <- [1..n]]\r\nallLists n k = [ x:xs |  x <- [1..n], xs <- allLists n (k-1), checkN n (x:xs) == 1]\r\n\r\n\r\nclist n i = allLists i n ++ clist n (i+1)\r\n\r\ngeneralizedCantor n = clist n 1','Выражение имеет неправильное значение: length(filter(==[4,1,1])(take 1000 (generalizedCantor 3)))'),(6731,69,'MaryK','2013-10-21 01:31:45',0,'module Func where\r\n\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nbigSin :: Float->Float\r\n\nbigSin x = sin ([z|z<-[1..], sin z > x]!!1) \n','Выражение имеет неправильное значение: (bigSin 0.99) < 0.991'),(6732,69,'MaryK','2013-10-21 01:36:22',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),(>=),div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nbigSin :: Float->Float\r\n\r\nbigSin x = sin ([z|z<-[1..], (sin z) >= x]!!0) \r\n','<br/>Тесты успешно пройдены!'),(6728,132,'3301494','2013-10-21 00:56:37',1,'facts = 1 : 2 : map ((a,b) -> b * (div b a + 1)) (zip facts (tail facts))\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6727,74,'bazhutin','2013-10-21 00:49:08',2,'pos n\r\n	| n > 0 = n\r\n	| otherwise = 0\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree e Empty = e\r\n\r\nfoldTree e (Node val l r) = let \r\n     res1 = foldTree e l \r\n     res2 = foldTree res1 r\r\n   in res2 + pos val\r\n  --- Это не тот foldTree о котором шла речь в условии. Попробуйте, если хотите, написать решение для правильного\r\n  --- foldrTree - до 14:00 вторника.\r\n\r\n\r\nsumPos (Node val l r) = foldTree 0 (Node val l r)\r\n','<br/>Тесты успешно пройдены!'),(6724,133,'54411321','2013-10-21 00:26:09',1,'-- Cразу не обратил внимания что единицы две.\r\n\r\n-- Но мое первое решение должно быть немного быстрей (там нету tail)\r\n  --- Система, к сожалению, не посзволяет мне смотреть предыдущие решения- я вижу только последнее..\r\nfib = 1:1:(zipWith (+) fib (tail fib))\r\n','<br/>Тесты успешно пройдены!'),(6725,69,'Artur','2013-10-21 00:29:20',1,'bigSin x = head (filter (y -> y >= x) (lsin 0))\r\n\r\n\r\n\r\n\r\n\r\nlsin n = sin n : lsin(n+1)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6726,74,'3301494','2013-10-21 00:38:18',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\n  \r\n\r\nsumPos x = foldTree (a b c -> sum (map (x -> if x < 0 then 0 else x)  [a, b, c])) 0 x\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6723,69,'480387','2013-10-21 00:23:24',1,'bigSin x = let p = x in (filter (>p) (map sin [1..]))!!0','<br/>Тесты успешно пройдены!'),(6721,133,'54411321','2013-10-21 00:16:57',0,'fib = 1:(zipWith (+) fib (0:fib))\n','<br/>Тесты успешно пройдены!'),(6722,72,'480387','2013-10-21 00:17:08',1,'weekendExpences xs = foldr (+) 0 [xs!!n| n<-[1..length xs], let m = n `mod` 7 in  m == 5 || m == 6]','<br/>Тесты успешно пройдены!'),(6720,132,'4604056','2013-10-21 00:03:06',1,'facts = 1:(map (\\n -> n*(n+1)) facts)\r\n  --- OK, засчитано, но вообщ это совсем неприавильно.. Это у просто я забыл для этой задаи написать тесты, поэтому у вас и прошло..','<br/>Тесты успешно пройдены!'),(6716,72,'3301494','2013-10-20 23:50:24',1,'f [] _ res = res\r\n\r\nf (x:xs) i res = let m = i `mod` 7 in if m /= 0 && m /= 6 then f xs (i + 1) res else f xs (i + 1) (res + x)\r\n\r\nweekendExpences xs = f xs 1 0\r\n','<br/>Тесты успешно пройдены!'),(6717,133,'bazhutin','2013-10-20 23:50:47',1,'fib = 1 : zipWith (+) fib (0 : fib)','<br/>Тесты успешно пройдены!'),(6718,132,'bazhutin','2013-10-20 23:55:20',1,'facts = 1 : zipWith (*) facts ([2..])','<br/>Тесты успешно пройдены!'),(6719,78,'1526701','2013-10-20 23:58:54',1,'pascal = [1] : zipWith (zipWith (+)) (map ([0]++) pascal) (map (++[0]) pascal);','<br/>Тесты успешно пройдены!'),(6715,79,'toskira','2013-10-20 23:48:25',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace _20_1 {\r\n\r\n	class Program {\r\n		\r\n		static IEnumerable<int> digits(int n) {\r\n			int a = 10;\r\n			for (int i = 0; ; i++) {\r\n				int output = (int)((double)a / (double) n);\r\n				a = (a - output * n) * 10;\r\n				yield return output;\r\n			}\r\n		}\r\n\r\n		static void printDigits(int n) {\r\n			IEnumerator<int> iter = digits(n).GetEnumerator();\r\n			Console.WriteLine(n);\r\n			for (int i = 0; i < 100; i++) {\r\n				iter.MoveNext();\r\n				Console.Write(iter.Current);\r\n			}\r\n			Console.ReadKey();\r\n		}\r\n\r\n		static void Main(string[] args) {\r\n			printDigits(7);\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6713,72,'4604056','2013-10-20 23:37:57',0,'WeekEnds = [0,0,0,0,0,1,1]:WeekEnds\r\nweekendExpences xs = sum foldWith (*) xs WeekEnds','Не удалось вычислить выражение \"weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]\", проверьте правильность синтаксиса'),(6714,72,'4604056','2013-10-20 23:40:21',1,'WeekEnds = [0,0,0,0,0,1,1]:WeekEnds\r\n   --- WeekEnds обязательно должно начинаться со строчной буквы\r\nweekendExpences xs = sum zipWith (*) xs WeekEnds','Не удалось вычислить выражение \"weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]\", проверьте правильность синтаксиса'),(6711,133,'5247795','2013-10-20 23:29:01',1,'fib = 1 : 1 : zipWith (+) fib (tail fib)\r\n','<br/>Тесты успешно пройдены!'),(6712,69,'5247795','2013-10-20 23:32:43',1,'bigSin x = head ( filter (>= x) (map sin [1..]) )\r\n','<br/>Тесты успешно пройдены!'),(6709,132,'54411321','2013-10-20 23:25:30',1,'facts = 1 : zipWith (*) facts [2..]\r\n','<br/>Тесты успешно пройдены!'),(6710,74,'1526701','2013-10-20 23:28:03',2,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e;\r\nfoldTree f e (Node val l r) = let \r\n	res1 = foldTree f e l \r\n	res2 = foldTree f res1 r \r\n	in res2 `f` val;\r\n  --- Это не тот foldTree о котором шла речь в условии. Попробуйте, если хотите, написать решение для правильного\r\n  --- foldrTree - до 14:00 вторника.\r\nsumPos t = foldTree (x y -> if y > 0 then x+y else x) 0 t;','<br/>Тесты успешно пройдены!'),(6706,133,'1526701','2013-10-20 23:17:08',1,'fib = 1 : zipWith (+) fib (0 : fib);','<br/>Тесты успешно пройдены!'),(6707,72,'54411321','2013-10-20 23:24:30',0,'','Не удалось вычислить выражение \"weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]\", проверьте правильность синтаксиса'),(6708,72,'54411321','2013-10-20 23:25:08',1,'weekendExpences xs = foldl (\r\nes (x, y) -> \r\n\r\n                     res + x * (if (((y-6)`mod`7==0) || (y`mod`7==0)) then 1 else 0)) \r\n\r\n                     0 (zip xs [1..])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6705,69,'3301494','2013-10-20 23:16:32',1,'bigSin x = head [sin a | a <- [1..], sin (a - 1) < x, sin a >= x]\r\n','<br/>Тесты успешно пройдены!'),(6703,132,'1526701','2013-10-20 23:14:47',1,'facts = 1 : zipWith (*) facts [2..];','<br/>Тесты успешно пройдены!'),(6704,68,'toskira','2013-10-20 23:15:01',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace _17_1 {\r\n\r\n	class Program {\r\n\r\n		static Func<int[], int, int[]> zeroDigits = (a, n) => { int n_pow = (int)Math.Pow(10, n); return a.Select(x => (x / n_pow) * n_pow).ToArray(); };\r\n\r\n		static void Main(string[] args) {\r\n			int[] a = { 563, 5643, 76796 };\r\n			int[] result = zeroDigits(a, 2);\r\n			for (int i = 0; i < result.Length; i++) {\r\n				Console.Write(result[i] + \" \");\r\n			}\r\n			Console.ReadKey();\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6702,74,'egeorge','2013-10-20 23:08:48',1,'data Tree = Empty |\r\n            Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n    resl = foldTree f e l\r\n    resr = foldTree f e r\r\n    in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\nsumPos = foldTree (v l r -> (pos v) + (pos l) + (pos r)) 0\r\npos x = max x 0','<br/>Тесты успешно пройдены!'),(6700,132,'5247795','2013-10-20 23:08:13',1,'import Data.List\r\n\r\nfacts = 1: map (\r\n -> n * ((findIndices (==n) facts)!!0 + 2)) facts\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(6701,74,'egeorge','2013-10-20 23:08:20',0,'sumPos = foldTree (v l r -> (pos v) + (pos l) + (pos r)) 0\r\npos x = max x 0','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6699,74,'ip','2013-10-20 23:08:11',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\np x = if x>0\r\n      then x\r\n      else 0\r\n\r\nsumPos xs = foldTree (v l r -> (p v)+(p l)+(p r))\r\n   --- А зачем вы l и r проверяете на >0?  \r\n                  0\r\n                  xs','<br/>Тесты успешно пройдены!'),(6698,74,'egeorge','2013-10-20 23:05:46',0,'data Tree = Empty |\r\n            Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n    resl = foldTree f e l\r\n    resr = foldTree f e r\r\n    in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\nsumPos = foldTree (v l r -> v + (pos l) + (pos r)) 0\r\npos x = max x 0','Выражение имеет неправильное значение: sumPos (Node (-5) (Node 2 Empty Empty) Empty)'),(6697,74,'ip','2013-10-20 23:04:12',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\np x = if x>0\r\n      then x\r\n      else 0\r\n\r\nsumPos = ','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6696,72,'1526701','2013-10-20 22:57:54',1,'getPrice i x = if (i `mod` 7 == 6) || (i `mod` 7 == 0) then x else 0;\r\nmCalc _ [] = 0;\r\nmCalc i (x:xs) = getPrice i x + mCalc (i+1) xs\r\nweekendExpences l = mCalc 1 l;','<br/>Тесты успешно пройдены!'),(6695,69,'4604056','2013-10-20 22:57:06',1,'BigSin n = head (filter (>n) (map sin [..])\r\n   --- bigSin - строчеая первая буква. Зачитано, но будьте внимательнее пожалуйста, в следующий раз могу не засчитать','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6694,74,'1545234','2013-10-20 22:55:22',1,'  --- OK, но на самом деле проверять на >0 надо только x\r\n  --- у и z вы зря проверяете (но на ваше счастье они в данной задаче всегда >=0\r\n  --- так что ваша программа всегда работает правильно, просто делает лишние проверки:)\r\nbigSin x = if (abs x > 1) then x\r\n\r\n           else\r\n\r\n              head [ sin a | a <- [1..], sin a > x]\r\n\r\n\r\n\r\nfacts = 1:[x*i | (x,i) <- zip facts [2..] ]\r\n\r\n\r\n\r\nweekendExpences x = we x 1 0\r\n\r\n\r\n\r\nwe [] _ akk = akk\r\n\r\nwe (x:xs) i akk = if (i == 6 || i == 7) then we xs ((i `mod` 7)+1) (akk+x)\r\n\r\n                  else we xs ((i `mod` 7)+1) akk\r\n\r\n\r\n\r\ndata Tree = Empty |\r\n\r\n          Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nf1 x y z = if (x>0) then\r\n\r\n            if (y > 0) then\r\n\r\n              if (z > 0) then x+y+z\r\n\r\n              else x+y\r\n\r\n            else\r\n\r\n               if (z > 0) then x+z\r\n\r\n               else x           \r\n\r\n           else \r\n\r\n            if (y > 0) then \r\n\r\n             if (z > 0) then y+z\r\n\r\n             else y\r\n\r\n            else 0\r\n\r\n\r\n\r\nsumPos :: Tree -> Integer\r\n\r\nsumPos a = foldTree (f1) 0 a\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6693,74,'1545234','2013-10-20 22:55:01',0,'f1 x y z = if (x>0) then\r\n            if (y > 0) then\r\n              if (z > 0) then x+y+z\r\n              else x+y\r\n            else\r\n               if (z > 0) then x+z\r\n               else x           \r\n           else \r\n            if (y > 0) then \r\n             if (z > 0) then y+z\r\n             else y\r\n            else 0\r\n\r\nsumPos :: Tree -> Integer\r\nsumPos a = foldTree (f1) 0 a','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6689,69,'4604056','2013-10-20 22:47:54',0,'BigSin n = head (filter (>n) (map sin [..])','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6690,133,'ip','2013-10-20 22:48:05',1,'fib = 1:1:(map \r\n          ((a,b)->(a+b))\r\n          (zip (tail fib) fib))','<br/>Тесты успешно пройдены!'),(6691,132,'egeorge','2013-10-20 22:50:58',1,'multN (x:xs) n = (x * n) : multN xs (n+1)\r\n\r\nfact = 1 : multN fact 2','<br/>Тесты успешно пройдены!'),(6692,69,'1526701','2013-10-20 22:53:17',1,'bigSin x = [sin y | y<-[1..], sin y > x] !! 0;','<br/>Тесты успешно пройдены!'),(6687,132,'3320654','2013-10-20 22:42:50',1,'import List\r\n--не знаю, насколько уместно использование этого модуля\r\nfacts = 1 : (map (x -> x * (head (elemIndices x facts) + 2)) facts)\r\n   --= Можно проще, мне кажется, но ОК, сойдет)','<br/>Тесты успешно пройдены!'),(6688,74,'1545234','2013-10-20 22:46:15',0,'data Tree = Empty |\r\n          Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\nf1 x y z = if (y > 0 && z > 0) then x+y+z\r\n            else if (y > 0) then x+y\r\n             else if (z > 0) then x+z\r\n              else x\r\n\r\nsumPos :: Tree -> Integer\r\nsumPos a = foldTree (f1) 0 a','Выражение имеет неправильное значение: sumPos (Node (-5) (Node 2 Empty Empty) Empty)'),(6685,72,'egeorge','2013-10-20 22:20:03',1,'weekendExpences (_:_:_:_:_:a:b:xs) = a + b + (weekendExpences xs)\r\nweekendExpences (_:_:_:_:_:a:xs) = a + (weekendExpences xs)\r\nweekendExpences _ = 0','<br/>Тесты успешно пройдены!'),(6686,69,'2501950','2013-10-20 22:20:09',1,'bigSin x =  (filter (>x) (map sin [1..])) !! 0\r\n','<br/>Тесты успешно пройдены!'),(6684,133,'egeorge','2013-10-20 22:18:57',1,'fib n = take n (fib\' [1,1])\r\nfib\' (x:y:xs) = x:fib\'(y:(x+y):xs)','<br/>Тесты успешно пройдены!'),(6679,69,'55363692','2013-10-20 22:07:31',1,'import Data.List\r\n\r\nimport Data.Maybe\r\n\r\n\r\n\r\nbigSin x = fromJust $ find (s -> s >= x) (map sin [1..])\r\n','<br/>Тесты успешно пройдены!'),(6680,72,'12828920','2013-10-20 22:09:55',1,'list n = (n*7+5):(n*7+6):(list (n+1))\r\n\r\nweekendExpences xs = let \r\n\r\n					  lgth = (length xs)-1\r\n\r\n					  lst = take lgth (list 0)\r\n\r\n					  in foldr (i k->if (elem i lst) then k+xs!!i else k) 0 [0..lgth]\r\n','<br/>Тесты успешно пройдены!'),(6681,69,'egeorge','2013-10-20 22:17:53',1,'bigSin x = head [y | y <- [sin n | n <- [1..]], y > x]','<br/>Тесты успешно пройдены!'),(6682,68,'55363692','2013-10-20 22:18:07',0,'','<br/>Тесты успешно пройдены!'),(6683,68,'55363692','2013-10-20 22:18:47',1,'﻿﻿using System;\r\n\r\n﻿using System.Collections.Generic;\r\n\r\n﻿using System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static IEnumerable<int> ZeroDigits(IEnumerable<int> array, int n)\r\n\r\n        {\r\n\r\n            var pow10 = (int) Math.Pow(10, n);\r\n\r\n            // Вообще, мне кажется, компилятор соптимизирует если pow10 написать в Select\'е\r\n   --- Может быть, но я сомниваюсь вообще-то.. Компилятор ведь ничего не знает про функцию\r\n   --- Pow. А может у нее есть побочный эффект, и она кажлый раз выдает разные результаты?\r\n   --- Тогда вынос из Select - это ведь вовсе не эквивалентное преобразование, правильно?\r\n   --- Но если вы мне как-нибудь экспериментально докажете, что все-таки оптимизирует, то я вам это \r\n   --- засчитаю за балл! :) \r\n            return array.Select(x => x - x%pow10);\r\n    \r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(String.Join(\", \", ZeroDigits(new[] {111, 222, 333}, 2).ToArray()));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6675,74,'anna','2013-10-20 21:52:48',1,'data Tree a = Empty | Node a (Tree a)(Tree a)\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node val l r) =\r\n    let\r\n      res1 = foldTree f e l\r\n      res2 = foldTree f e r\r\n    in f val res1 res2\r\n\r\nsumPos t = foldTree (x res1 res2 -> if x > 0 then x + res1 + res2 else res1 + res2) 0 t','<br/>Тесты успешно пройдены!'),(6676,72,'1545234','2013-10-20 21:52:58',1,'weekendExpences x = we x 1 0\r\n\r\nwe [] _ akk = akk\r\nwe (x:xs) i akk = if (i == 6 || i == 7) then we xs ((i `mod` 7)+1) (akk+x)\r\n                  else we xs ((i `mod` 7)+1) akk','<br/>Тесты успешно пройдены!'),(6677,133,'anna','2013-10-20 21:59:57',1,'fib = 1 : 1 : (zipWith (+) fib (tail fib))','<br/>Тесты успешно пройдены!'),(6678,132,'ip','2013-10-20 22:02:45',1,'facts = 1:(map ((a,b)->(a*b)) (zip [2..n] facts))','<br/>Тесты успешно пройдены!'),(6672,132,'1545234','2013-10-20 21:44:26',1,'facts = 1:[x*i | (x,i) <- zip facts [2..] ]','<br/>Тесты успешно пройдены!'),(6673,133,'12828920','2013-10-20 21:46:44',1,'fibs = 1 : 1 : zipWith (+) fibs (tail fibs)\r\n','<br/>Тесты успешно пройдены!'),(6674,74,'3320654','2013-10-20 21:47:56',1,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = 	let\r\n     				resl = foldTree f e l\r\n		     		resr = foldTree f e r\r\n  			in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\nsumPos (Node val l r) = foldTree (v l r -> max v 0 + max l 0 + max r 0) 0 (Node val l r)','<br/>Тесты успешно пройдены!'),(6670,72,'ip','2013-10-20 21:36:05',0,'weekendExpences xs = foldr\r\n                  (x (y,d)-> if ((d==6)||(d==7))\r\n                              then (x+y)\r\n                              else x)\r\n                  0\r\n                  (zip xs s)\r\ns = [1..7]+s','Не удалось вычислить выражение \"weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]\", проверьте правильность синтаксиса'),(6671,72,'ip','2013-10-20 21:37:19',1,'weekendExpences xs = foldr\r\n                  (x (y,d)-> if ((d==6)||(d==7))\r\n   --- Хорошая идея, но вы тут перепуитали порядок - надо \\(y,d) x -> ...\r\n                              then (x+y)\r\n                              else x)\r\n                  0\r\n                  (zip xs s)\r\ns = [1..7]++s','Не удалось вычислить выражение \"weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]\", проверьте правильность синтаксиса'),(6665,69,'1545234','2013-10-20 21:19:50',1,'bigSin x = if (abs x > 1) then x\r\n           else\r\n              head [ sin a | a <- [1..], sin a > x]','<br/>Тесты успешно пройдены!'),(6666,69,'ip','2013-10-20 21:19:57',1,'bigSin x = head [y | y<-(map sin [1..n]), y>=x] \r\n  --- Что такое n, совсем не понятно:(\r\n  --- Засчитано, но будьте внимательнее, пожалуйста, в следующий раз могу не засчитать','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6667,133,'3320654','2013-10-20 21:23:19',1,'fib = 1 : 1 : sumList fib (tail fib)\r\nsumList (x:xs) (y:ys) = (x + y) : (sumList xs ys)','<br/>Тесты успешно пройдены!'),(6668,72,'1990147','2013-10-20 21:24:30',1,'settimana = 0:0:0:0:0:1:1:settimana\r\n   --- Здорово, вы говорите по итальянски? ) \r\n\r\nweekendExpences x = sum (zipWith (*) settimana x)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6669,72,'ip','2013-10-20 21:34:25',0,'weekendExpences xs = foldr\r\n                  (x (y,d)-> if (d==6)||(d==7)\r\n                              then x+y\r\n                              else x)\r\n                  0\r\n                  (zip xs s)\r\ns = [1..7]+s','Не удалось вычислить выражение \"weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]\", проверьте правильность синтаксиса'),(6661,72,'bazhutin','2013-10-20 21:04:00',1,'ifWeekEnd x n  \r\n	| (n `mod` 7 == 0) = x \r\n	| (n `mod` 7 == 6) = x\r\n	| otherwise = 0 \r\n\r\nsumWeekEnd [x] n = ifWeekEnd x n\r\nsumWeekEnd (x:xs) n  = ifWeekEnd x n + (sumWeekEnd xs (n + 1))\r\n\r\nweekendExpences list = sumWeekEnd list 1 \r\n\r\n','<br/>Тесты успешно пройдены!'),(6662,132,'12828920','2013-10-20 21:08:26',1,'facts = 1 : (zipWith (*) [2..] facts)\r\n','<br/>Тесты успешно пройдены!'),(6663,133,'1545234','2013-10-20 21:08:31',1,'fib = 1 : 1 : [ x + y | (x,y) <- zip fib (tail fib) ]','<br/>Тесты успешно пройдены!'),(6664,69,'54411321','2013-10-20 21:13:51',1,'bigSin x = if x < 1 then head (filter (>=x) [sin n | n <- [1..]]) else -1\r\n','<br/>Тесты успешно пройдены!'),(6654,69,'ip','2013-10-20 20:40:03',0,'bigSin x = head [y | y<-(map sin [1..n]), y>x] ','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6655,69,'ip','2013-10-20 20:45:44',0,'bigSin x = y | y<-(map sin [1..n]), y>=x ','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6656,77,'5543298','2013-10-20 20:48:21',1,'getNext xs = let (index, diff) = foldr ((x, y) (a, b) -> if y < b && y > 0 then (x, y) else (a, b)) (head xs) (tail xs)in index\r\n\r\nsqrt2\' = (1, 2, 1) : map ((cur, needSquare, i) -> let n = needSquare * 100 in let xs = map (i -> (i, n - (cur * 10 + i)^2)) [0..9] in  let a = getNext xs in (cur * 10 + a, n, a)) sqrt2\'\r\n\r\nsqrt2 = map ((a, b, c) -> c) sqrt2\'\r\n','<br/>Тесты успешно пройдены!'),(6657,69,'3320654','2013-10-20 20:49:30',1,'bigSin x = head [y | y <- [sin(t) | t <- [1,2..]], y >= x]','<br/>Тесты успешно пройдены!'),(6658,72,'3320654','2013-10-20 20:53:35',1,'weekendExpences (m:t:w:th:f:sa:su:xs) 	= sa + su + (weekendExpences xs)\r\nweekendExpences _			= 0','<br/>Тесты успешно пройдены!'),(6659,69,'54411321','2013-10-20 20:56:19',0,'bigSin x = head (filter (>=x) [sin n | n <- [1..]])\n','<br/>Тесты успешно пройдены!'),(6660,78,'5543298','2013-10-20 21:03:50',2,'getNext [1] ys = [1]\r\n\r\ngetNext [x,y] ys = (x + y):ys\r\n\r\ngetNext (x:y:xs) ys = getNext (y:xs) ((x + y):ys)\r\n   --- Это у вас не по условию. Там ведь написано \'не определять свои функции\'\r\n   --- Те попробуйте пожалуйста записать вместо getNext лямбда выражение, с использованием стандартных функций \r\n\r\npascal = [1]: map (xs -> 1:(getNext xs [1])) pascal\r\n','<br/>Тесты успешно пройдены!'),(6648,69,'1990147','2013-10-20 19:55:25',1,'bigSin n = head [sin x|x<-[1..],sin x > n]\r\n','<br/>Тесты успешно пройдены!'),(6649,72,'anna','2013-10-20 19:59:14',1,'foo = 0:0:0:0:0:1:1:foo\r\nweekendExpences xs = sum (zipWith (*) foo xs)','<br/>Тесты успешно пройдены!'),(6650,132,'ArtemK','2013-10-20 20:05:29',1,'facts = 1:(zipWith (*) facts [2..])','<br/>Тесты успешно пройдены!'),(6651,133,'ArtemK','2013-10-20 20:08:45',1,'fib = 1:1:(zipWith (+) fib (tail fib))','<br/>Тесты успешно пройдены!'),(6652,74,'ArtemK','2013-10-20 20:16:13',0,'data Tree = NonEmpty Double Tree Tree | Empty\r\nfoldTree f e (NonEmpty val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\nsumPos t = foldTree (x y z -> max 0 x + y + z) 0 t','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6653,74,'ArtemK','2013-10-20 20:16:48',1,'data Tree = Node Double Tree Tree | Empty\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\nsumPos t = foldTree (x y z -> max 0 x + y + z) 0 t','<br/>Тесты успешно пройдены!'),(6646,69,'ArtemK','2013-10-20 19:50:27',1,'bigSin x = (filter (>x) [sin y | y <- [1..]]) !! 0','<br/>Тесты успешно пройдены!'),(6647,72,'ArtemK','2013-10-20 19:53:39',1,'weekends = 0:0:0:0:0:1:1:weekends\r\nweekendExpences xs = sum (zipWith (*) xs weekends)','<br/>Тесты успешно пройдены!'),(6638,133,'Artur','2013-10-20 18:36:22',1,'fib =  1:zipWith (+) (1:fib) (zipWith (*) (0:lst) fib)\r\n\r\n\r\n\r\nlst = 1:lst\r\n\r\n\r\n\r\n--fib = 1:zipWith(+) (0:fib) (fib)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6639,69,'2501950','2013-10-20 18:38:55',2,'--не понимаю в чем ошибка, если вводить bigSin\' , \r\n--как было раньше, то все работает\r\n   --- Сейчас у вас ошибка в том, что вы определили bigSin с двумя параметрами,\r\n   --- а по условию надо с одним. Те тут дб что-то вроде\r\n   ---   bigSin x = ... что-то ... (map sin [1..]) \r\n   --- Причем это ...что-то... должно брать в списке первый элемент, больший x\r\n   --- И это  ...что-то... должно быть написано только через стандартные функцми.\r\n   --- Подумайте.. Но если не получится, выложите этот код еще раз, я его зачту.\r\nbigSin x [ ]= bigSin x (map sin [1..])\r\n\r\nbigSin x (y:ys) = \r\n if (x > y) \r\n then bigSin x ys\r\n else y\r\n','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6640,69,'12828920','2013-10-20 18:40:50',1,'bigSin n = head (filter (>= n) [sin x | x<-[1..]])\r\n','<br/>Тесты успешно пройдены!'),(6641,74,'Artur','2013-10-20 18:41:16',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\n\r\n\r\nsumPos t = foldTree (v l r -> if v > 0 then v + l + r else l+r) 0 t\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6642,74,'artem.gomerman','2013-10-20 18:50:13',0,'data Tree = Empty | Node Integer Tree Tree\r\n\n\r\n\nfoldTree f e Empty = e\r\n\nfoldTree f e (Node val l r) = let \r\n\n	res1 = foldTree f e l \r\n\n	res2 = foldTree f res1 r\r\n\n	in res2 `f` val\r\n\n   \r\n\nsumPos tree = foldTree (x res -> res + max 0 x) 0 tree\n','Выражение имеет неправильное значение: sumPos (Node (-5) (Node 2 Empty Empty) Empty)'),(6643,74,'artem.gomerman','2013-10-20 18:52:51',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n	resl = foldTree f e l\r\n\r\n	resr = foldTree f e r\r\n\r\n	in f val resl resr\r\n\r\n\r\n\r\nsumPos tree = foldTree (v l r -> max 0 v + max 0 l + max 0 r) 0 tree\r\n','<br/>Тесты успешно пройдены!'),(6644,133,'2501950','2013-10-20 19:05:52',1,'fib = 1 : 1: (zipWith (+) fib (tail fib))  \r\n','<br/>Тесты успешно пройдены!'),(6645,74,'nomeansno','2013-10-20 19:16:22',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f z Empty = if z>0 then z else 0\r\n\r\nfoldTree f z (Node v l r) = f v resl resr\r\n\r\n	where resl = foldTree f z l; resr = foldTree  f z r\r\n\r\n\r\n\r\nsumPos = foldTree (v l r->if v>0 then v+l+r else l+r) 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6636,69,'12828920','2013-10-20 18:26:40',0,'list = [sin x | x<-[1..]]\n\n\n\nbigSin n = head (filter (>= n) (list))\n','<br/>Тесты успешно пройдены!'),(6637,133,'nomeansno','2013-10-20 18:30:50',1,'fib1 = zipWith (+) fib fib2\r\n\r\nfib2 = 1:fib1\r\n\r\nfib = 1:fib2\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6629,69,'Artur','2013-10-20 17:32:36',2,'bigSin x = bigList x (lsin 0)\r\n\r\n			where bigList x (y:ys) = if y >= x then y else bigList x ys \r\n  --- Нет, в этой задаче нельзя определять никакие свои вспомогатеьные функции, это же\r\n  --- написано в условии..\r\n  --- См также замечание на это тему в группе в контакте.\r\n\r\n\r\nlsin n = sin n : lsin(n+1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6630,72,'Artur','2013-10-20 17:38:20',1,'weekendExpences xs = sum (zipWith (*) weekend xs)\r\n\r\nweekend = 0:0:0:0:0:1:1:weekend \r\n','<br/>Тесты успешно пройдены!'),(6631,132,'artem.gomerman','2013-10-20 17:45:06',1,'facts = 1:(zipWith (*) [2..] facts)\r\n','<br/>Тесты успешно пройдены!'),(6632,132,'nomeansno','2013-10-20 17:56:31',1,'facts0 = [2..]\r\n\r\nfacts1 = zipWith (*) facts facts0\r\n\r\nfacts = 1:facts1\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6633,132,'Artur','2013-10-20 18:09:06',1,'facts = 1 : (zipWith (*) facts [2..]) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6634,133,'artem.gomerman','2013-10-20 18:16:11',1,'fib = 1:1:zipWith (+) fib (tail fib)\r\n','<br/>Тесты успешно пройдены!'),(6635,79,'5543298','2013-10-20 18:22:57',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"20.2\":\r\n\r\n                {\r\n\r\n                    int k = 0;\r\n\r\n                    foreach (var pair in cantor())\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(pair);\r\n\r\n                        k++;\r\n\r\n                        if (k == 100)\r\n\r\n                            break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var resPowN = new BigInteger(0);\r\n\r\n            var left = new BigInteger(1);\r\n  --- Тут, мне кажется, BigInteger вовсе не надо. Ведь у вас вроде бы все числа в ходе вычисления будут не больше n \r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                left *= 10;\r\n\r\n                var min = left - resPowN * 10 * n;\r\n\r\n                var minIndex = 0;\r\n\r\n                for (int j = 1; j < 10; j++)\r\n\r\n                {\r\n\r\n                    var current = left - (resPowN * 10 + j) * n;\r\n\r\n                    if (current < min && current > 0)\r\n\r\n                    {\r\n\r\n                        min = current;\r\n\r\n                        minIndex = j;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                resPowN = resPowN * 10 + minIndex;\r\n\r\n                yield return minIndex;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6628,80,'1595828','2013-10-20 17:01:26',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\nnamespace zd20_2\r\n{\r\n    class zd\r\n    {\r\n        public static IEnumerable<KeyValuePair<int, int>> pairs()\r\n        {\r\n            int a = 1, b = 1;\r\n            for (; ; )\r\n            {\r\n                yield return new KeyValuePair<int, int>(a, b);\r\n                if (a == b) { a = 1; b += 1; }\r\n   --- ОК, но только вместо b += 1; лучше b++ (и то же всюду дальше)\r\n                else\r\n                    if (a < b)\r\n                        if (a + 1 == b)\r\n                            { a = b; b = 1; }\r\n                        else\r\n                            a += 1;\r\n                    else\r\n                        b += 1;\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            for (int i = 0; i < 100; i++)\r\n            {\r\n                Console.Write(\"{0} \", pairs().ElementAt(i));\r\n            }\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6626,69,'12828920','2013-10-20 16:39:27',2,'  --- Что ж вы никто условие не читаете:) В этой задаче нельзя определять новые функциии.\r\n  --- Те list надо как-то выразить через стандартные функции.\r\nlist n= (sin n):list (n+1)\r\n\r\n\r\n\r\nbigSin n = head (filter (>= n) (list 1))\r\n','<br/>Тесты успешно пройдены!'),(6627,69,'2501950','2013-10-20 16:58:25',2,'  --- Но это ведь не по условию.. Тут нельзя определять свои функции, кроме binSin\r\n  --- те и mySin и bigSin\' надо как-то выразить через стандартные функции (map, filter и т.д.)\r\n  --- Если нет идей, могу немного подсказать, тогда напишите. (Но вообще это несложно) \r\nmySin i = sin i: mySin(i+1)\r\nbigSin x = bigSin\' x (mySin 0)\r\nbigSin\' x (y:ys) = \r\n if (x > y) \r\n then bigSin\' x ys\r\n else y\r\n','<br/>Тесты успешно пройдены!'),(6625,74,'nbumakov','2013-10-20 15:47:06',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n   \r\nsumPos = foldTree (x lres rres -> lres + rres + if x > 0 then x else 0) 0','<br/>Тесты успешно пройдены!'),(6621,72,'nbumakov','2013-10-20 15:44:10',1,'weekendMask = 0:0:0:0:0:1:1:weekendMask\r\nweekendExpences xs = sum (zipWith (*) xs weekendMask)','<br/>Тесты успешно пройдены!'),(6622,132,'nbumakov','2013-10-20 15:44:31',1,'facts = 1 : zipWith (*) facts [2 ..]','<br/>Тесты успешно пройдены!'),(6623,133,'nbumakov','2013-10-20 15:45:03',1,'fibs = 1:1 : zipWith (+) fibs (tail fibs)','<br/>Тесты успешно пройдены!'),(6624,74,'nbumakov','2013-10-20 15:46:06',0,'foldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n   \r\nsumPos = foldTree (x lres rres -> lres + rres + if x > 0 then x else 0) 0','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6618,132,'62628590','2013-10-20 14:49:04',1,'import Data.List\r\nfacts = 1: map(\r\n->((findIndices (==n) facts)!!0 + 2)*n) facts','<br/>Тесты успешно пройдены!'),(6619,74,'1595828','2013-10-20 14:57:32',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\n\r\n\r\nsumPos tree = foldTree (val resl resr -> if val > 0 then val + resl + resr else resl + resr) 0 tree\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6620,69,'nbumakov','2013-10-20 15:43:47',1,'bigSin x = head (filter (>= x) (map sin [1..]))','<br/>Тесты успешно пройдены!'),(6617,133,'1595828','2013-10-20 14:21:36',1,'fib= 1:1: [(a+b)| (a,b) <- zip fib (tail fib)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6612,132,'284427','2013-10-20 14:00:27',0,'fibs = 1:1:(zipWith (+) fibs (tail fibs))\r\n\n\r\n\nfacts = 1:2:(zipWith (x y -> y * (div y x + 1)) facts (tail facts))\n','<br/>Тесты успешно пройдены!'),(6613,132,'284427','2013-10-20 14:00:57',1,'facts = 1:2:(zipWith (x y -> y * (div y x + 1)) facts (tail facts))\r\n','<br/>Тесты успешно пройдены!'),(6614,133,'15309342','2013-10-20 14:02:30',1,'fib = 1 : (1 : zipWith (+) fib (tail fib))','<br/>Тесты успешно пройдены!'),(6615,74,'15309342','2013-10-20 14:14:01',1,'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\nsumPos = foldTree (v l r -> if v > 0 then v + l + r else l + r) 0','<br/>Тесты успешно пройдены!'),(6616,66,'3270666','2013-10-20 14:16:26',1,'generalizedCantor n = map (xs -> map (+ 1) xs) (generalizedCantor\' n)\r\n\r\ngeneralizedCantor\' 2 = map f [0..]\r\ngeneralizedCantor\' n = [(f (head xs)) ++ (tail xs) | xs <- generalizedCantor\' (n - 1)]\r\n\r\nf z = let w1 = sqrt (fromIntegral (8 * z + 1))\r\n          w2 = (w1 - 1) / 2\r\n          w = floor w2\r\n          t = (w * w + w) `div` 2\r\n          y = z - t\r\n          x = w - y\r\n      in [x, y]','<br/>Тесты успешно пройдены!'),(6609,72,'284427','2013-10-20 13:49:17',2,'  --- Пустое решение??','Не удалось вычислить выражение \"weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]\", проверьте правильность синтаксиса'),(6610,133,'284427','2013-10-20 13:49:44',1,'fibs = 1:1:(zipWith (+) fibs (tail fibs))\r\n','<br/>Тесты успешно пройдены!'),(6611,74,'284427','2013-10-20 13:54:31',1,'data Tree = Empty | Node Double Tree Tree\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nsumPos t = foldTree (x resl resr -> if x>0 then x + resl + resr else resl + resr) 0 t\r\n','<br/>Тесты успешно пройдены!'),(6607,132,'15309342','2013-10-20 13:46:54',1,'facts = zipWith (*) (1 : facts) [1..]','<br/>Тесты успешно пройдены!'),(6608,65,'3270666','2013-10-20 13:49:05',1,'cantor = map f [0..]\r\n\r\nf z = let w1 = sqrt (fromIntegral (8 * z + 1))\r\n          w2 = (w1 - 1) / 2\r\n          w = floor w2\r\n          t = (w * w + w) `div` 2\r\n          y = z - t\r\n          x = w - y\r\n      in (x + 1, y + 1)','<br/>Тесты успешно пройдены!'),(6606,68,'8519021','2013-10-20 13:43:26',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Select_ZeroDigits\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] zeroDigits(int[] a, int n)\r\n\r\n        {\r\n\r\n            return a.Select(x => x - x % ((int)Math.Pow(10, n))).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = new int[] { 563, 5643, 76796 };\r\n\r\n            int[] b = zeroDigits(a, 2);\r\n\r\n            foreach (int i in b)\r\n\r\n            {\r\n\r\n                Console.Write(\"{0} \", i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6604,69,'284427','2013-10-20 13:37:25',2,'sinList = sins 1\r\n\r\nsins n = (sin n) : (sins (n+1))\r\n  --- Нет, это не совсем по условию, тут _нельзя_ определыть свои фунцкии \r\n\r\n\r\nbigSin x = head (filter (>=x) sinList)\r\n','<br/>Тесты успешно пройдены!'),(6605,72,'284427','2013-10-20 13:42:35',0,'template = 0:0:0:0:0:1:1:template\r\n\nweekendExpences xs = sum (zipWith (*) xs template)\n','<br/>Тесты успешно пройдены!'),(6603,74,'62628590','2013-10-20 13:23:33',1,'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\nsumPos a = foldTree (x resl resr -> if x > 0 then x + resl + resr else resl + resr) 0 a','<br/>Тесты успешно пройдены!'),(6602,74,'3270666','2013-10-20 13:19:57',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node val l r) = let res1 = foldTree f e l \r\n                                  res2 = foldTree f res1 r\r\n                              in res2 `f` val\r\n\r\nsumPos = foldTree (\r\nes x -> res + (max 0 x)) 0','<br/>Тесты успешно пройдены!'),(6600,133,'62628590','2013-10-20 13:16:30',1,'fib = 1:1:(zipWith (+) (tail fib) fib)','<br/>Тесты успешно пройдены!'),(6601,74,'3270666','2013-10-20 13:19:40',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node val l r) = let res1 = foldTree f e l \r\n                                  res2 = foldTree f res1 r\r\n                              in res2 `f` val\r\n\r\nsumPos1 = foldTree (\res x -> res + (max 0 x)) 0','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6596,133,'3270666','2013-10-20 12:57:02',1,'fib = 1 : (1 : zipWith (+) fib (tail fib))','<br/>Тесты успешно пройдены!'),(6597,69,'15309342','2013-10-20 13:06:12',1,'bigSin x = head [sin y | y <- [1..], sin y >= x]','<br/>Тесты успешно пройдены!'),(6598,74,'8519021','2013-10-20 13:11:12',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) =\r\n\r\n	let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n	in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\nsumPos = foldTree (v l r -> if v > 0 then v + l + r else l + r) 0\r\n','<br/>Тесты успешно пройдены!'),(6599,72,'15309342','2013-10-20 13:11:34',1,'weekend = 0:0:0:0:0:1:1:weekend\r\nweekendExpences xs = foldr ((x, id) sum -> (x * id + sum)) 0 (zip xs weekend)','<br/>Тесты успешно пройдены!'),(6593,69,'3270666','2013-10-20 12:42:55',1,'bigSin x = let sinList = map sin [1..]\r\n               bigSinList = [s | s <- sinList, s >= x]\r\n           in head bigSinList','<br/>Тесты успешно пройдены!'),(6594,72,'3270666','2013-10-20 12:46:47',1,'weekendExpences xs = let week = 0:0:0:0:0:1:1:week\r\n                     in sum (zipWith (*) xs week)','<br/>Тесты успешно пройдены!'),(6595,132,'3270666','2013-10-20 12:52:39',1,'facts = 1 : zipWith (*) [2..] facts','<br/>Тесты успешно пройдены!'),(6591,132,'8519021','2013-10-20 12:30:54',1,'facts = 1:(zipWith (*) [2..] facts)\r\n','<br/>Тесты успешно пройдены!'),(6592,133,'8519021','2013-10-20 12:39:49',1,'fib = 1:1:(zipWith (+) fib (tail fib))\r\n','<br/>Тесты успешно пройдены!'),(6590,79,'romos2007','2013-10-20 12:03:21',1,'﻿/*\r\n\r\n * Задача 20-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace _20_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        /* For example:\r\n\r\n         * 1/7 = 0,142857142857...\r\n\r\n         * 10/7 = 1,42857... <=> (1*10 - 7*0*10) / 7 = 1,42857...\r\n\r\n         * 100/7 = 14,2857... <=> (10*10 - 7*1*10) / 7 = 4,2857...\r\n\r\n         * ...\r\n\r\n         */\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            int nom = 1;\r\n\r\n            int denom = n;\r\n\r\n            int digit = 0;\r\n\r\n\r\n\r\n            for (int i = 1; ; i++)\r\n\r\n            {\r\n\r\n                nom = nom * 10 - denom * digit * 10;\r\n\r\n                digit = nom / denom;\r\n\r\n                yield return digit;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void ShowFractionDigits(int fraction_denom, int count)\r\n\r\n        {\r\n\r\n            int[] fractDigits = digits(fraction_denom).Take(count).ToArray();\r\n\r\n            for (int i = 0; i < count; i++)\r\n\r\n            {\r\n\r\n                Console.Write(\"{0}, \", fractDigits[i]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string s_fd,s_c = \"0\";\r\n\r\n\r\n\r\n            Console.Write(\"\r\nEnter fraction_denominator(exit = hit ENTER): \");\r\n\r\n            s_fd = Console.ReadLine();\r\n\r\n            Console.Write(\"\r\nEnter count of digits(exit = hit ENTER): \");\r\n\r\n            s_c = Console.ReadLine();\r\n\r\n\r\n\r\n            while (s_fd != \"\" || s_fd != \"\")\r\n\r\n            {\r\n\r\n                int count = Convert.ToInt32(s_c);\r\n\r\n                int fractDenom = Convert.ToInt32(s_fd);\r\n\r\n                ShowFractionDigits(fractDenom, count);\r\n\r\n\r\n\r\n                Console.Write(\"\r\nEnter fraction_denominator(exit = hit ENTER): \");\r\n\r\n                s_fd = Console.ReadLine();\r\n\r\n                Console.Write(\"\r\nEnter count of digits(exit = hit ENTER): \");\r\n\r\n                s_c = Console.ReadLine();\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine(\"\r\n\r\n---------\r\nHappy end. Now hit ENTER\");\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6588,69,'62628590','2013-10-20 11:38:19',1,'bigSin x = head (filter (>=x) (map sin [1..]))','<br/>Тесты успешно пройдены!'),(6589,72,'62628590','2013-10-20 11:57:43',1,'xcweek = 0:0:0:0:0:1:1:xcweek\r\nweekendExpences xs = sum (zipWith (*) xs xcweek)','<br/>Тесты успешно пройдены!'),(6587,80,'SNNatalieS','2013-10-20 06:46:32',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _20_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<Tuple<int, int>> cantor()\r\n        {\r\n            for(int n = 1; ;n++)\r\n            {\r\n                for (int x = 1; x < n; x++)\r\n                {\r\n                    yield return Tuple.Create(x, n);\r\n                    yield return Tuple.Create(n, x);\r\n                }\r\n                yield return Tuple.Create(n, n);\r\n\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            var g = cantor();\r\n            var rt = g.GetEnumerator();\r\n            for(int i = 0; i < 100; i++)\r\n            {\r\n                if(rt.MoveNext())\r\n                {\r\n                    Console.WriteLine(rt.Current);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6584,80,'SNNatalieS','2013-10-20 04:12:25',2,' --- В принципе очень хорошо, все правильно, но в задачах на С№ надо присылать не кусок\r\n --- программы, а всю программу, с примером вызова, чтобы я мог ее при желании\r\n --- скомпилировать и выполнить.\r\n --- Те выложите сюда программу полностью, пожалуйста.\r\npublic static IEnumerable<Tuple<int, int>> cantor()\r\n        {\r\n            for(int n = 1; ;n++)\r\n            {\r\n                for (int x = 1; x < n; x++)\r\n                {\r\n                    yield return Tuple.Create(x, n);\r\n                    yield return Tuple.Create(n, x);\r\n                }\r\n                yield return Tuple.Create(n, n);\r\n\r\n            }\r\n        }','<br/>Тесты успешно пройдены!'),(6585,77,'SNNatalieS','2013-10-20 04:26:58',2,'  --- Нет так нельзя.. Если вы пишете sqrt(2), то вы получаете приближение для квадратного\r\n  --- корня с той точностью, которую позволяет тип double (примерно 16 знаков)\r\n  --- А дальше все цифры будут неправильные.\r\n  --- Что же делать? Можно придумать разные способы, но проще всего, видимо,\r\n  --- как-то свести задачу к задаче с целыми числами. А дальше все просто, так как\r\n  --- целые числа в Хаскеле имеют бесконечную точность.\r\nsqrt2 = let t = sqrt(2) \r\n			in map (x -> mod (floor (x * t)) 10) [ 10 ^ b | b <- [0..]]\r\n','Выражение имеет неправильное значение: take 20 sqrt2'),(6586,80,'5543298','2013-10-20 04:27:50',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"20.2\":\r\n\r\n                {\r\n\r\n                    int k = 0;\r\n\r\n                    foreach (var pair in cantor())\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(pair);\r\n\r\n                        k++;\r\n\r\n                        if (k == 100)\r\n\r\n                            break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                break;\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<String> cantor()\r\n\r\n        {\r\n\r\n            foreach (var j in list())\r\n\r\n            {\r\n\r\n                for (int i = 1; i <= j; i++)\r\n\r\n                {\r\n\r\n                    yield return String.Format(\"({0}, {1})\", i, j);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> list()\r\n\r\n        {\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var number = BigInteger.Divide(BigInteger.Pow(10, 10000), n).ToString();\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i >= number.Length ? 0 : Convert.ToInt32(number[i].ToString());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6582,79,'SNNatalieS','2013-10-20 03:59:50',2,'  --- Нет, это не совсем правильно.. Попробуйте напечатать например дробь 1/3\r\n  --- и вы увидите, что вместо 0.33333 с какого то момента появляются совсем\r\n  --- другие цифры. Причина тут та же, что и с sqrt(2)\r\n  --- Если вы работаете с плавающими числами, значит у вас совершенно неизбежно\r\n  --- появляются ошибки округления. Значит, надо как-то работать с целыми.\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _20_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> digits(int n)\r\n        {\r\n            double c = 1.0 / n;\r\n            for( ; ;)\r\n            {\r\n                c *= 10;\r\n                yield return Math.Floor(c);\r\n                c %= 1;\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Please, type a number:\");\r\n            int n = int.Parse(Console.ReadLine());\r\n            IEnumerable<double> g = digits(n);\r\n            var rt = g.GetEnumerator();\r\n            for(int i = 0; i < 100; i++)\r\n            {\r\n                if(rt.MoveNext())\r\n                {\r\n                    Console.WriteLine(rt.Current);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6583,79,'5543298','2013-10-20 04:09:20',2,'  --- Не совсем правильно. У вас правильно выводятся первые 10000 цифр, а надо\r\n  --- чтобы правильно выдавалось любое количество цифр, потенциально неограниченное.\r\n  --- Если хотите, могу немного подсказать, тогда напишите письмо, пожалуйста.\r\n  --- Но вообще это просто.\r\n﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"20.1\":\r\n\r\n                    {\r\n\r\n                        int k = 0;\r\n\r\n                        foreach (var i in digits(7))\r\n\r\n                        {\r\n\r\n                            Console.Write(i + \", \");\r\n\r\n                            if (++k == 100)\r\n\r\n                                break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            var number = BigInteger.Divide(BigInteger.Pow(10, 10000), n).ToString();\r\n\r\n            for (int i = 0 ; ; i++)\r\n\r\n            {\r\n\r\n                yield return i >= number.Length ? 0 : Convert.ToInt32(number[i].ToString());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6581,79,'SNNatalieS','2013-10-20 03:57:51',0,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _20_1\r\n{\r\n    class Program\r\n    {\r\n        public static IEnumerable<double> plusminus(int n)\r\n        {\r\n            double c = 1.0 / n;\r\n            for( ; ;)\r\n            {\r\n                c *= 10;\r\n                yield return Math.Floor(c);\r\n                c %= 1;\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Please, type a number:\");\r\n            int n = int.Parse(Console.ReadLine());\r\n            IEnumerable<double> g = plusminus(n);\r\n            var rt = g.GetEnumerator();\r\n            for(int i = 0; i < 100; i++)\r\n            {\r\n                if(rt.MoveNext())\r\n                {\r\n                    Console.WriteLine(rt.Current);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6579,132,'2501950','2013-10-20 01:41:56',1,'facts = 1 : zipWith (*) [2..] facts','<br/>Тесты успешно пройдены!'),(6580,69,'2501950','2013-10-20 02:11:47',2,'mySin i = sin i: mySin (i+1)\r\nbigSin x []= bigSin x mySin(0)\r\n   --- во второй строке у вас скобок не хватает. Как раз вокруг 0 лни не нужны, а вот\r\n   --- в другом месте нужны. Это просто, но исправьте, пожалуйста.\r\nbigSin x (y:ys) = \r\n if (x > y) \r\n then bigSin x ys\r\n else y\r\n','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6575,78,'SNNatalieS','2013-10-20 00:21:35',1,'pascal = [1] : (zipWith (pas1 pas2 -> 1 : zipWith (+) pas1 (tail(pas2 ++ [0]))) pascal pascal)','<br/>Тесты успешно пройдены!'),(6576,69,'8519021','2013-10-20 00:43:05',1,'bigSin x = head (filter (>=x) [sin i | i<-[1..]])\r\n','<br/>Тесты успешно пройдены!'),(6577,72,'8519021','2013-10-20 00:43:35',1,'weekend = 0:0:0:0:0:1:1:weekend\r\n\r\nweekendExpences xs = sum (zipWith (*) weekend xs)\r\n','<br/>Тесты успешно пройдены!'),(6578,72,'2501950','2013-10-20 01:36:32',1,'weekend = 0:0:0:0:0:1:1:weekend\r\nweekendExpences xs = sum (zipWith (*) xs weekend)  ','<br/>Тесты успешно пройдены!'),(6574,59,'42284313','2013-10-19 23:36:32',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace task14_1\r\n{\r\n    class Program\r\n    {\r\n        static int[] nonZeroLastDigits(int[] array) \r\n        {\r\n            return (array.Select(x => x % 10).ToArray()).Where(x => x > 0).ToArray();\r\n        }\r\n        \r\n        \r\n        static void Main(string[] args) \r\n        {\r\n            int[] array = new int[] {354, 20, 9, 31};\r\n            int[] result = nonZeroLastDigits(array);\r\n\r\n            for (int i = 0; i < result.Length; i++)\r\n                Console.Write(result[i].ToString() + \" \");\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6573,131,'42284313','2013-10-19 23:22:54',2,'  --- Нет, это у вас слишком долго работает..\r\n  --- Я тестировал с примером canMakeScheme [130,777,70,20,446,30,1000,446] 1560\r\n  --- (ответ дб False) и программа за полтора часа ничего не выдала.. А предаполагается,\r\n  --- что вермя дб примерно 15 минут.\r\n  --- Если хотите, можете жл понедальника попроьвать как-то ускорить.\r\nremoveOne (x:xs) v\r\n\r\n  | x == v = xs\r\n\r\n  | otherwise = x : removeOne xs v\r\n\r\n\r\n\r\nremoveSeveral xs [] = xs\r\n\r\nremoveSeveral xs (v:vs) = removeSeveral (removeOne xs v) vs\r\n\r\n\r\n\r\npowerset [] = [[]]\r\n\r\npowerset (x:xs) = \r\n\r\n    let\r\n\r\n      ys = powerset xs\r\n\r\n      ts = map (qs -> (x:qs)) ys\r\n\r\n    in ts ++ ys\r\n\r\n\r\n\r\nsubsets xs len = filter (ys -> length ys <= len) (powerset xs)\r\n\r\n\r\n\r\nremoveDuplicates [] = []\r\n\r\nremoveDuplicates (x:xs) = x : (removeDuplicates (filter (/=x) xs))\r\n\r\n\r\n\r\nmix rs1 rs2 = removeDuplicates (foldr ([x1,x2,x3,x4] res -> x1:x2:x3:x4:res) [] [[r1, r2, r1 + r2, r1*r2/(r1 + r2)] | r1 <- rs1, r2 <- rs2])\r\n\r\n\r\n\r\ngenerateAllResistance [] = []\r\n\r\ngenerateAllResistance [r] = [r]\r\n\r\ngenerateAllResistance xs =\r\n\r\n    let\r\n\r\n      f ys res =\r\n\r\n        let\r\n\r\n          zs = removeSeveral xs ys\r\n\r\n        in removeDuplicates ((mix (generateAllResistance ys) (generateAllResistance zs)) ++ res)\r\n\r\n    in removeDuplicates (foldr f [] (subsets xs (length xs `div` 2)))\r\n\r\n\r\n\r\ncontains xs x = foldr (||) False (map (==x) xs)\r\n\r\n\r\n\r\ncanMakeScheme rs r = contains (generateAllResistance rs) r\r\n','Не удалось вычислить выражение \"canMakeScheme [130,777,70,20,223,30,1000] 560\", проверьте правильность синтаксиса'),(6572,58,'42284313','2013-10-19 23:22:00',1,'removeOne (x:xs) v\r\n\r\n  | x == v = xs\r\n\r\n  | otherwise = x : removeOne xs v\r\n\r\n\r\n\r\nremoveSeveral xs [] = xs\r\n\r\nremoveSeveral xs (v:vs) = removeSeveral (removeOne xs v) vs\r\n\r\n\r\n\r\npowerset [] = [[]]\r\n\r\npowerset (x:xs) = \r\n\r\n    let\r\n\r\n      ys = powerset xs\r\n\r\n      ts = map (qs -> (x:qs)) ys\r\n\r\n    in ts ++ ys\r\n\r\n\r\n\r\nsubsets xs len = filter (ys -> length ys <= len) (powerset xs)\r\n\r\n\r\n\r\nremoveDuplicates [] = []\r\n\r\nremoveDuplicates (x:xs) = x : (removeDuplicates (filter (/=x) xs))\r\n\r\n\r\n\r\nmix rs1 rs2 = removeDuplicates (foldr ([x1,x2,x3,x4] res -> x1:x2:x3:x4:res) [] [[r1, r2, r1 + r2, r1*r2/(r1 + r2)] | r1 <- rs1, r2 <- rs2])\r\n\r\n\r\n\r\ngenerateAllResistance [] = []\r\n\r\ngenerateAllResistance [r] = [r]\r\n\r\ngenerateAllResistance xs =\r\n\r\n    let\r\n\r\n      f ys res =\r\n\r\n        let\r\n\r\n          zs = removeSeveral xs ys\r\n\r\n        in removeDuplicates ((mix (generateAllResistance ys) (generateAllResistance zs)) ++ res)\r\n\r\n    in removeDuplicates (foldr f [] (subsets xs (length xs `div` 2)))\r\n\r\n\r\n\r\ncontains xs x = foldr (||) False (map (==x) xs)\r\n\r\n\r\n\r\ncanMakeScheme rs r = contains (generateAllResistance rs) r\r\n','<br/>Тесты успешно пройдены!'),(6571,57,'42284313','2013-10-19 23:21:11',1,'removeOne (x:xs) v\r\n\r\n  | x == v = xs\r\n\r\n  | otherwise = x : removeOne xs v\r\n\r\n\r\n\r\nremoveSeveral xs [] = xs\r\n\r\nremoveSeveral xs (v:vs) = removeSeveral (removeOne xs v) vs\r\n\r\n\r\n\r\npowerset [] = [[]]\r\n\r\npowerset (x:xs) = \r\n\r\n    let\r\n\r\n      ys = powerset xs\r\n\r\n      ts = map (qs -> (x:qs)) ys\r\n\r\n    in ts ++ ys\r\n\r\n\r\n\r\nsubsets xs len = filter (ys -> length ys <= len) (powerset xs)\r\n\r\n\r\n\r\nremoveDuplicates [] = []\r\n\r\nremoveDuplicates (x:xs) = x : (removeDuplicates (filter (/=x) xs))\r\n\r\n\r\n\r\nmix rs1 rs2 = removeDuplicates (foldr ([x1,x2,x3,x4] res -> x1:x2:x3:x4:res) [] [[r1, r2, r1 + r2, r1*r2/(r1 + r2)] | r1 <- rs1, r2 <- rs2])\r\n\r\n\r\n\r\ngenerateAllResistance [] = []\r\n\r\ngenerateAllResistance [r] = [r]\r\n\r\ngenerateAllResistance xs =\r\n\r\n    let\r\n\r\n      f ys res =\r\n\r\n        let\r\n\r\n          zs = removeSeveral xs ys\r\n\r\n        in removeDuplicates ((mix (generateAllResistance ys) (generateAllResistance zs)) ++ res)\r\n\r\n    in removeDuplicates (foldr f [] (subsets xs (length xs `div` 2)))\r\n\r\n\r\n\r\ncontains xs x = foldr (||) False (map (==x) xs)\r\n\r\n\r\n\r\ncanMakeScheme rs r = contains (generateAllResistance rs) r\r\n','<br/>Тесты успешно пройдены!'),(6570,133,'SNNatalieS','2013-10-19 23:01:27',1,'fib1 = 1 : (zipWith (+) (1 : fib1)  fib1)\r\nfib = 1 : fib1','<br/>Тесты успешно пройдены!'),(6569,69,'SNNatalieS','2013-10-19 22:25:31',1,'bigSin x = head(filter (>x) (lsin 1)) \r\n			where lsin n = sin n : lsin (n + 1)\r\n  --- Это не совсем по условию, в это задаче нельзя определять свои функции, кроме bigSin.\r\n  --- Это просто, но исправьте, пожалуйста.','<br/>Тесты успешно пройдены!'),(6567,65,'SNNatalieS','2013-10-19 22:08:39',1,'f n = [(x, n) | x <- [1 .. (n - 1)]] ++ [(n, x) | x <- (reverse [1 .. n])] ++ (f (n + 1))\r\ncantor = f 1\r\n','<br/>Тесты успешно пройдены!'),(6568,74,'toskira','2013-10-19 22:11:00',2,'data Tree a = Empty |                                                                         \r\n              Node a (Tree a) (Tree a)                                                        \r\n                                                                                              \r\nfoldTree f e (Node val l r) = let res1 = foldTree f e l                                       \r\n                                  res2 = foldTree f res1 r                                    \r\n                              in f res2 val                                                   \r\nfoldTree f e Empty = e                                                                        \r\n   --- Нет, это задача не про этот foldTree, а про следующий, который катаморфизм                                                                                             \r\nsumPos = foldTree (e x -> if x > 0 then x+e else e) 0\r\n  ','<br/>Тесты успешно пройдены!'),(6562,69,'toskira','2013-10-19 21:45:42',1,'bigSin x = (head.(filter (>=x)).(map sin)) [1..]','<br/>Тесты успешно пройдены!'),(6563,72,'toskira','2013-10-19 21:50:36',1,'weekendExpences (_:_:_:_:_:a:b:t) = a+b+(weekendExpences t)\r\nweekendExpences (_:_:_:_:_:a:[]) = a\r\nweekendExpences _ = 0','<br/>Тесты успешно пройдены!'),(6564,133,'SNNatalieS','2013-10-19 21:52:05',2,'f 1 = 1\r\nf 2 = 1\r\nf n = f (n - 1) + f (n - 2) \r\nfib1 = [f n | n <- [1..]]\r\nfib2 = [f n | n <- [2..]]\r\nfib = 1 : 1: (zipWith (+) fib1 fib2)\r\n  --- Это честно говоря совсем не то, что на рисунке.\r\n  --- Там линии образуют кольцо, и это означает что список определятся сам через себя.\r\n  --- И вам надо, fib1 fib2  и f не определять, а fib определить через себя. Собственно\r\n  --- вы почти это сделали, надо только немного исправить.\r\n  --- Попробуйте, пожалуйста. Но если не получится, просто выложите снова ту же программу, и я ее зачту.','<br/>Тесты успешно пройдены!'),(6565,132,'toskira','2013-10-19 21:57:03',1,'facts = 1:(zipWith (*) [2..] facts)','<br/>Тесты успешно пройдены!'),(6566,133,'toskira','2013-10-19 22:03:52',1,'fib = 1:1:(zipWith (+) fib (tail fib))','<br/>Тесты успешно пройдены!'),(6561,80,'55363692','2013-10-19 19:26:58',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Diagnostics;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static IEnumerable<Tuple<int, int>> Pairs()\r\n\r\n        {\r\n\r\n            for (int k = 0;; ++k)\r\n\r\n            {\r\n\r\n                for (int i = 1; i < k; ++i)\r\n\r\n                {\r\n\r\n                    yield return new Tuple<int, int>(i, k - i);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            const int count = 10;\r\n\r\n            Console.WriteLine(String.Join(\", \", Pairs().Take(count)));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6560,79,'55363692','2013-10-19 19:23:38',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Diagnostics;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Numerics;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static IEnumerable<int> Digits(int n)\r\n\r\n        {\r\n\r\n            BigInteger res = 0;\r\n\r\n            BigInteger one = 10;\r\n\r\n\r\n\r\n            for (;;)\r\n\r\n            {\r\n\r\n                int nextDigit = Enumerable.Range(0, 10).First(i => (res*10 + i)*n > one) - 1;\r\n\r\n                res = res*10 + nextDigit;\r\n\r\n                one *= 10;\r\n\r\n                yield return nextDigit;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            int n;\r\n\r\n            for (;;)\r\n\r\n            {\r\n\r\n                Console.Write(\"Enter n = \");\r\n\r\n                string input = Console.ReadLine();\r\n\r\n                if (input != null && Int32.TryParse(input, out n))\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            const int count = 100;\r\n\r\n            Console.WriteLine(String.Join(\", \", Digits(n).Take(count)));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6559,59,'nbumakov','2013-10-19 18:52:30',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Task14\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 354, 20, 9, 31 };\r\n            int[] b = NonZeroLastDigits(a);\r\n\r\n            foreach (var item in b)\r\n                Console.Write(\"{0} \", item);\r\n            Console.ReadLine();\r\n        }\r\n\r\n        static int[] NonZeroLastDigits(int[] a)\r\n        {\r\n            return a.Select(x => x % 10).Where(x => x > 0).ToArray();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6556,74,'SNNatalieS','2013-10-19 17:43:34',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n								 resl = foldTree f e l\r\n								 resr = foldTree f e r\r\n								in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\nsumPos = foldTree (v l r -> if v > 0 then (v+l+r) else (l + r)) 0','<br/>Тесты успешно пройдены!'),(6557,72,'nomeansno','2013-10-19 17:57:52',1,'\r\nweekendExpences s = sum (zipWith f [1..] s)\r\n\r\n	where f x y =  if x `mod` 7 == 6 || x `mod` 7 == 0 then y else 0\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6558,72,'5247795','2013-10-19 18:02:37',1,'weekends [] _ = []\r\n\r\nweekends (x:xs) n = if (n `div` 5 == 0 || n `div` 6 == 0) \r\n\r\n                    then x : weekends xs (n + 1)\r\n\r\n		    else  weekends xs (n + 1)\r\n\r\nweekendExpences xs = foldr (+) 0 (weekends xs 0)\r\n','<br/>Тесты успешно пройдены!'),(6551,69,'bazhutin','2013-10-19 16:10:17',1,'bigSin n = head [ sin x | x <-[1..], sin x > n ]','<br/>Тесты успешно пройдены!'),(6552,69,'nomeansno','2013-10-19 17:07:41',0,'','Не удалось вычислить выражение \"(bigSin 0.99) < 0.991\", проверьте правильность синтаксиса'),(6553,69,'nomeansno','2013-10-19 17:08:16',1,'bigSin x = head \r\n\r\n	where (head:tail) = filter (y->y>=x) (map sin [1..])\r\n\r\n \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6554,78,'55363692','2013-10-19 17:12:12',1,'pascal = [1] : map (xs -> zipWith (+) (xs ++ [0]) (0:xs)) pascal\r\n','<br/>Тесты успешно пройдены!'),(6555,68,'55363692','2013-10-19 17:31:40',2,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static IEnumerable<int> ZeroDigits(IEnumerable<int> array, int n)\r\n\r\n        {\r\n\r\n            return array.Select(x => x - x % (int)Math.Pow(10, n));\r\n  --- Тут, на самом деле, у вас получилось очень неэффективно, потому что Pow будет считаться для\r\n  --- каждого элемента массива. А можно, конечно, сосчитать один раз.\r\n  --- Исправьте это, пожалуйста, хорошо?\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(String.Join(\", \", ZeroDigits(new[] { 111, 222, 333 }, 2).ToArray()));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6548,132,'1595828','2013-10-19 15:00:31',1,'facts = 1:[n*(b+1)|n<-facts, let b = (until (l ->(product[1..l] == n)) (+1) 1)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6549,74,'2156724','2013-10-19 15:05:40',1,'data Tree = Empty | \r\n\r\n           Node Integer Tree Tree\r\n\r\n\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nsumPos = foldTree \r\n\r\n        	(v l r -> if v > 0 then v+l+r else l+r) 0\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6550,78,'55363692','2013-10-19 15:25:33',0,'pascal = [1] : zipWith (xs ys -> zipWith (+) (xs ++ [0]) (0:ys)) pascal pascal\n','<br/>Тесты успешно пройдены!'),(6547,133,'2156724','2013-10-19 14:57:42',1,'fib = 1:1: zipWith (+) fib (tail fib)\r\n','<br/>Тесты успешно пройдены!'),(6544,132,'55363692','2013-10-19 14:43:50',1,'facts = 1:zipWith (*) facts [2..]\r\n','<br/>Тесты успешно пройдены!'),(6545,132,'2156724','2013-10-19 14:45:28',1,'facts = 1:zipWith (*) [2..] facts \r\n','<br/>Тесты успешно пройдены!'),(6546,74,'55363692','2013-10-19 14:51:43',1,'data Tree a = Empty | Node a (Tree a) (Tree a) \r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n \r\n\r\nsumPos = foldTree ( v l r -> l + r + (if v > 0 then v else 0)) 0 \r\n','<br/>Тесты успешно пройдены!'),(6541,69,'55363692','2013-10-19 14:03:45',2,'import Data.List\r\n\r\nimport Data.Maybe\r\n\r\n\r\n\r\nlistSin n = (sin n) : (listSin $ n + 1)\r\n  --- Это не по условию, нельзя было определять свои функции, кроме bigSin\r\n  --- Это очень просто, но исправьте, пожалуйста\r\n\r\n\r\n\r\nbigSin x = fromJust $ find (s -> s >= x) (listSin 1)\r\n','<br/>Тесты успешно пройдены!'),(6542,72,'55363692','2013-10-19 14:14:33',1,'weekList = [0, 0, 0, 0, 0, 1, 1] ++ weekList\r\n\r\n\r\n\r\nweekendExpences xs = sum $ zipWith (*) xs weekList\r\n','<br/>Тесты успешно пройдены!'),(6543,133,'55363692','2013-10-19 14:22:40',1,'fib = 1:1: zipWith (+) fib (tail fib)\r\n','<br/>Тесты успешно пройдены!'),(6540,66,'55363692','2013-10-19 13:51:35',1,'generateLists 1 sum = [[sum]]\r\n\r\ngenerateLists n sum = [k:xs | k <- [1..(sum - n + 1)], xs <- generateLists (n - 1) (sum - k)]\r\n\r\n\r\n\r\ngeneralizedCantor n = concat [generateLists n k | k <- [2..]]\r\n','<br/>Тесты успешно пройдены!'),(6538,72,'2156724','2013-10-19 13:45:44',1,'weekEnd = 0:0:0:0:0:1:1:weekEnd\r\n\r\nweekendExpences xs = sum (zipWith (*) weekEnd xs)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6539,79,'1595828','2013-10-19 13:51:05',1,'using System.Collections.Generic;\r\nusing System;\r\nnamespace zd20_1\r\n{\r\n    class zd\r\n    {\r\n        public static IEnumerable<int> digits(int n)\r\n        {\r\n            int d = 10,res=0;\r\n            for (; ; )\r\n            {\r\n                \r\n                res = d / n;\r\n                yield return res;\r\n                d =(d-res*n)*10;\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int n = 1;\r\n           \r\n                System.Console.Write(\"Введите целое, положительное число - знаменатель дроби(0 -выход из цикла): \");\r\n                int i = 1;\r\n                n = Convert.ToInt32(System.Console.ReadLine());\r\n                foreach (int x in digits(n))\r\n                {\r\n                    Console.Write(\"{0},\", x);\r\n                    if (++i == 100)\r\n                        break;\r\n                }\r\n\r\n                Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6537,69,'2156724','2013-10-19 13:39:51',1,'bigSin x = head (filter (>x) xs) where xs = [sin n | n <-[1..]]\r\n','<br/>Тесты успешно пройдены!'),(6536,65,'55363692','2013-10-19 13:32:25',1,'cantor = concat [[(x, y) | x <- [1..k], y <- [1..k], x + y == k] | k <- [2..]]\r\n  -- Лучше let y = k - x, конечно... ','<br/>Тесты успешно пройдены!'),(6535,69,'5247795','2013-10-19 12:52:31',2,'sinXS n = (sin n ) : sinXS (n + 1)\r\n  --- Это не по условию, в этой задаче _нельзя_ было определят свои функции, кроме bigSin.\r\n  --- Это очень просто, но исправьте пожалуйста.\r\nbigSin x = head ( filter (>= x) (sinXS 1) )\r\n','<br/>Тесты успешно пройдены!'),(6534,79,'115753099','2013-10-19 12:25:39',0,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n		public static IEnumerable<int> digits (int n)\r\n		{\r\n			int rest = 0;\r\n			int devident = 10;\r\n			int devisor = n;\r\n			int quotient = 0;\r\n			for (int i = 1; ; i++)\r\n			{\r\n				quotient = devident / devisor;\r\n				rest = devident % devisor;\r\n				if (quotient != 0)\r\n				{\r\n					devident = rest * 10;\r\n				} else {\r\n					devident *= 10;\r\n				}\r\n				yield return quotient;\r\n			}\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			Console.Write(\"Hello!\nInput number: n = \");\r\n			int n = Console.Read() - \'0\';\r\n			Console.Write(\";\n\nResult(1/n) = 0,\");\r\n			int i = 0;\r\n			foreach (int x in digits(n))\r\n			{\r\n				if (i == 100) break;\r\n				i++;\r\n				Console.Write(x.ToString());\r\n			}\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(6533,80,'115753099','2013-10-19 11:58:18',1,'using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Application\r\n{\r\n	class Pair<T>\r\n  --- ОК, но в принципе есть стандартный класс Tuple\r\n	{\r\n		public Pair(T a, T b) {\r\n			x = a; y = b;\r\n		}\r\n\r\n		public T getFirst()\r\n        {\r\n            return x;\r\n        }\r\n\r\n		public void print ()\r\n		{\r\n			Console.Write(\"(\" + x.ToString() + \", \" + y.ToString() + \"); \");\r\n		}\r\n\r\n		private T x;\r\n		private T y;\r\n	}\r\n\r\n	class MainClass\r\n	{\r\n		public static IEnumerable<Pair<int>> pairsGen()\r\n		{\r\n			for (int i = 1; ; i++)\r\n			{\r\n				for (int j = 1; j <= i ; j++)\r\n				{\r\n					yield return new Pair<int>(j, i-j + 1);\r\n				}\r\n			}\r\n		}\r\n\r\n		public static void printLines (int n)\r\n		{\r\n			foreach (Pair<int> x in pairsGen())\r\n			{\r\n				if (x.getFirst() > n)\r\n				{\r\n					break;\r\n				}\r\n				x.print();\r\n			}\r\n		}\r\n\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			printLines(5);\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6530,69,'1595828','2013-10-19 06:47:26',1,'bigSin x= sin(until (\r\n -> x<=sin n) (+1) 1)\r\n','<br/>Тесты успешно пройдены!'),(6531,72,'1595828','2013-10-19 07:17:13',1,'pattern = 0:0:0:0:0:1:1:pattern\r\n\r\nweekendExpences xs = sum(zipWith (*) xs pattern)\r\n','<br/>Тесты успешно пройдены!'),(6532,78,'115753099','2013-10-19 11:20:46',1,'pascal =\r\n	[1] : map (x -> (1 : (map (y -> product[1..x] `div` ((product[1..y])*(product[1..(x-y)]))) [1..(x-1)]) ++ [1])) [1..]','<br/>Тесты успешно пройдены!'),(6529,59,'toskira','2013-10-19 02:48:32',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace _14_1 {\r\n\r\n	class Program {\r\n\r\n		static Func<int[], int[]> nonZeroLastDigits = a => a.Where(x => x % 10 != 0).Select(x => x % 10).ToArray();\r\n\r\n		static void Main(string[] args) {\r\n			int[] a = { 354, 20, 9, 31 };\r\n			int[] result = nonZeroLastDigits(a);\r\n			for (int i = 0; i < result.Length; i++) {\r\n				Console.Write(result[i] + \" \");\r\n			}\r\n			Console.ReadKey();\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(6523,59,'nomeansno','2013-10-18 23:07:56',1,'#include <algorithm>\r\n#include <iostream>\r\n\r\nint *nonZeroLastDigits (int *array, size_t size) {\r\n    int *end = array+size;\r\n    std::transform(array,array+size,array,[] (int i) {\r\n        return i%10;\r\n    });\r\n    return std::remove_if(array,array+size,[] (int i) {\r\n        return (i==0);\r\n    });\r\n}\r\n\r\nint main() {\r\n    int a[] = {1,2,70,98,65,66,80};\r\n    int *b = nonZeroLastDigits(a, sizeof(a)/sizeof(int));\r\n    for (int* p=a; p!=b; ++p)\r\n        std::cout << \' \' << *p;\r\n    std::cout << \'\r\n\';\r\n}','<br/>Тесты успешно пройдены!'),(6524,72,'artem.gomerman','2013-10-18 23:13:00',1,'weekendExpences xs = weekendExpences\' xs 0\r\n\r\nweekendExpences\' xs res = let\r\n\r\n	tailXs = drop 5 xs in case tailXs of\r\n\r\n		[] -> res\r\n\r\n		(x:[]) -> res + x\r\n\r\n		(x:y:[]) -> res + x + y\r\n\r\n		(x:y:xs) -> weekendExpences\' (drop 2 tailXs) (res + x + y)\r\n','<br/>Тесты успешно пройдены!'),(6525,69,'617015','2013-10-18 23:32:37',1,'bigSin x = head(filter (\\n-> n>=x)(map(\\n-> sin n)[1..]))\r\n\r\n  --- ОК, по просто как замечание, можно оба раха лямбда выражения не писать:\r\n  --- bigSin x = head(filter (>=x)(map sin [1..]))\r\n','<br/>Тесты успешно пройдены!'),(6526,72,'617015','2013-10-18 23:32:58',1,'weekends=0:0:0:0:0:1:1:weekends\r\n\r\nweekendExpences xs= sum(zipWith(*) weekends xs)\r\n','<br/>Тесты успешно пройдены!'),(6527,132,'617015','2013-10-18 23:33:21',1,'facts =  zipWith (*) (1:map(i->i)facts)(map(\\n->n)[1..])\r\n  --- А тут лямбда выражение совсем уж не нужны:) Можно просто все map убрать\r\n  ---   facts = zipWith (*) (1:facts)[1..])','<br/>Тесты успешно пройдены!'),(6528,74,'617015','2013-10-18 23:33:50',1,'data Tree a = Empty| Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n	 in f val resl resr\r\n\r\nfoldTree f e Empty = e\r\n\r\n\r\n\r\nsumPos = foldTree(v l r -> if v>=0 then v+l+r else l+r) 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6522,80,'deripaska','2013-10-18 22:56:36',1,'﻿/*\r\n\r\n	task 20-02\r\n\r\n*Доп.задача на C# до 1.11*\r\n\r\n\r\n\r\n\"Задача Кантора\" на С#\r\n\r\n\r\n\r\nОпишите на C# блок итератора, возвращающий последовательность всех пар целых положительных чисел.\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_20_02\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<KeyValuePair<int, int> > cantor()\r\n\r\n        {\r\n\r\n            for (int n = 2; ; ++n)\r\n\r\n            {\r\n\r\n                for (int i = 1; i < n; ++i)\r\n\r\n                {\r\n\r\n                    yield return new KeyValuePair<int, int>(i, n - i);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.Write(\"Enter the count of \'cantor\' pairs: \");\r\n\r\n            int maxK = int.Parse(Console.ReadLine()); // int maxK = 10\r\n\r\n\r\n\r\n            int k = 0;\r\n\r\n            foreach (KeyValuePair<int, int> x in cantor())\r\n\r\n            {\r\n\r\n                Console.Write(x + \" \");\r\n\r\n                k++;\r\n\r\n                if (k >= maxK)\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6521,69,'artem.gomerman','2013-10-18 22:49:03',1,'bigSin m = if 0 <= m && m <= 1.0 then head [y | x <- [1..], let y = sin x, y >= m] else -1.0\r\n','<br/>Тесты успешно пройдены!'),(6520,79,'deripaska','2013-10-18 22:24:46',1,'﻿/*\r\n\r\n	task 20-01\r\n\r\n*Доп.задача на C# до 1.11*\r\n\r\n\r\n\r\nОпишите блок итератора digits(int n), возвращающий последовательность цифр дроби 1/n. Например, при обращении к digits(7) должны возвращаться цифры 1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7, ...\r\n\r\n\r\n\r\nC использованием digits напишите программу, которая вводит число n и печатает первые 100 цифр числа 1/n.\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_20_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        const int maxK = 100;\r\n\r\n        public static IEnumerable<int> digits(int n)\r\n\r\n        {\r\n\r\n            int prevBase = 10;\r\n\r\n            for (int i = 0; ; ++i)\r\n\r\n            {\r\n\r\n                if (prevBase < n)\r\n\r\n                {\r\n\r\n                    yield return 0;\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    int currentInteger = prevBase / n;\r\n\r\n                    yield return currentInteger;\r\n\r\n                    prevBase -= currentInteger * n;\r\n\r\n                }\r\n\r\n                prevBase *= 10;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Console.Write(\"Enter the number \'n\': \");\r\n\r\n            int n = int.Parse(Console.ReadLine()); // int n = 7\r\n\r\n            Console.WriteLine();\r\n\r\n\r\n\r\n            int k = 0;\r\n\r\n            foreach (int x in digits(n))\r\n\r\n            {\r\n\r\n                Console.Write(x + \" \");\r\n\r\n                k++;\r\n\r\n                if (k >= maxK)\r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6519,77,'55363692','2013-10-18 22:24:33',1,'import Data.List\r\n\r\nimport Data.Maybe\r\n\r\n\r\n\r\ngetNextDigit :: Integer -> Integer\r\n\r\ngetNextDigit acc = let \r\n\r\n	t = find (x -> head ((show $ (acc * 10 + x) * (acc * 10 + x))) > \'1\') [0..10]\r\n\r\n	in (fromJust t) - 1\r\n\r\n\r\n\r\ngenerate :: Integer -> [Integer]	\r\n\r\ngenerate acc = let \r\n\r\n	nextDigit = getNextDigit acc \r\n\r\n	nextACC = acc * 10 + nextDigit\r\n\r\n	in nextDigit : (generate nextACC) 	\r\n\r\n\r\n\r\nsqrt2 = generate 0\r\n','<br/>Тесты успешно пройдены!'),(6518,131,'nbumakov','2013-10-18 21:51:51',1,'generatePairsList [] = []\r\ngeneratePairsList (x:xs) = foldr (y zs -> (x, y) : zs) [] xs : generatePairsList xs\r\ngeneratePairs xs = concat (generatePairsList xs)\r\n\r\nremove y (x:xs)\r\n  | x == y    = xs\r\n  | otherwise = x : remove y xs\r\n\r\ncanMakeScheme :: [Float] -> Float -> Bool\r\ncanMakeScheme [r1,r2,r3] r = elem r [r1,r2,r3,(r1+r2),r1*r2/(r1+r2),(r1+r3),r1*r3/(r1+r3),(r2+r3),r2*r3/(r2+r3),((r1+r2)+r3),(r1+r2)*r3/((r1+r2)+r3),(r1*r2/(r1+r2)+r3),r1*r2/(r1+r2)*r3/(r1*r2/(r1+r2)+r3),((r1+r3)+r2),(r1+r3)*r2/((r1+r3)+r2),(r1*r3/(r1+r3)+r2),r1*r3/(r1+r3)*r2/(r1*r3/(r1+r3)+r2),((r2+r3)+r1),(r2+r3)*r1/((r2+r3)+r1),(r2*r3/(r2+r3)+r1),r2*r3/(r2+r3)*r1/(r2*r3/(r2+r3)+r1)]\r\ncanMakeScheme xs r = \r\n        let\r\n        checkPair (r1,r2) = canMakeScheme (r1 + r2 : ys) r \r\n                            || canMakeScheme (r1 * r2 / (r1 + r2) : ys) r \r\n                            where ys = remove r2 (remove r1 xs) \r\n        in elem r xs || any checkPair (generatePairs xs)','<br/>Тесты успешно пройдены!'),(6517,78,'deripaska','2013-10-18 21:47:11',1,'{--\r\n\r\n	task 19-02\r\n\r\n*Доп. задача, до 31.10*\r\n\r\n\r\n\r\nОписать pascal как бесконечный список списков, содержащий треугольник Паскаля. \r\n\r\n\r\n\r\nДополнительное условие: В этой задаче нельзя определять никакие новые функции (кроме pascal). Можно использовать стандартные функции. Можно (и я бы советовал) использовать прием tying the knot. \r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 6 pascal\r\n\r\n\r\n\r\nРезультат должен быть равен \r\n\r\n[[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]\r\n\r\n--}\r\n\r\n\r\n\r\npascal = [1]:(zipWith (x y -> zipWith (+) (x++[0]) (0:y)) pascal pascal)\r\n','<br/>Тесты успешно пройдены!'),(6516,77,'deripaska','2013-10-18 21:46:50',1,'{--\r\n\r\n	task 19-01\r\n\r\n*Доп. задача, до 31.10*\r\n\r\n\r\n\r\nОписать sqrt2 как бесконечный список из чисел от 0 до 9, описывающий разложение sqrt(2) в бесконечную десятичную дробь.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 20 sqrt2\r\n\r\n\r\n\r\nРезультат должен быть равен \r\n\r\n[1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]\r\n\r\n--}\r\n\r\n\r\n\r\nsqrt2 = buildSqrt2 2 0\r\n\r\n\r\n\r\nbuildSqrt2 x begin = (newInteger - begin): buildSqrt2 (100 * x) (newInteger * 10) -- 100 = 10^2\r\n\r\n	where newInteger = (findNearestInteger x begin (begin + 9))\r\n\r\n\r\n\r\nfindNearestInteger x left right \r\n\r\n	| left == right || left == right - 1 = if right * right < x then right else left\r\n\r\n	| otherwise = if middle * middle > x then findNearestInteger x  left middle else findNearestInteger x  middle right\r\n\r\n	where middle = div (left + right) 2\r\n','<br/>Тесты успешно пройдены!'),(6515,131,'toskira','2013-10-18 20:59:24',1,'import Data.List \r\n\r\n\r\n\r\np = 1000000\r\n\r\n\r\n\r\nadd e [] = []\r\n\r\nadd e ((a,b):t) = (sort (e:a),b):(a,sort (e:b)):(a,b):(add e t)\r\n\r\n\r\n\r\nget_pairs [] l = [([],[])]\r\n\r\nget_pairs (h:t) l = add h (get_pairs t l)\r\n\r\n\r\n\r\nhash [] = 0\r\n\r\nhash (h:t) = h+p*(hash t)\r\n\r\n\r\n\r\nregroup = map ((a,b) -> if (hash b) < (hash a) then (b,a) else (a,b))\r\n\r\n\r\n\r\ndivide l = let (h:t) = nub(regroup (get_pairs l []))\r\n\r\n           in t\r\n\r\n\r\n\r\nprocess [] = []\r\n\r\nprocess ((a,b):t) = a:b:(process t)\r\n\r\n\r\n\r\nget_all_resistances [] = []\r\n\r\nget_all_resistances (a:[]) = [a]\r\n\r\nget_all_resistances (a:b:[]) = [a+b, a*b/(a+b)]\r\n\r\nget_all_resistances l = process [((x+y),(x*y/(x+y))) | (a,b) <- divide l, let x\' = get_all_resistances a, let y\' = get_all_resistances b, x <- x\', y <- y\']\r\n\r\n\r\n\r\ncanMakeScheme [] n = (0==n)\r\n\r\ncanMakeScheme (a:[]) n = (a==n) || (0==n)\r\n\r\ncanMakeScheme (a:b:[]) n = (a==n) || (b==n) || ((a+b)==n) || ((a*b/(a+b))==n) || (0==n)\r\n\r\ncanMakeScheme l n = let pairs = divide l\r\n\r\n                        a = sum l\r\n\r\n                        good = filter ((a,b) -> let x = get_all_resistances a in (any (	 -> canMakeScheme b (n-t)) x) || (any (	 -> (t-n /= 0.0) && (canMakeScheme b (t*n/(t-n)))) x)) pairs\r\n\r\n                    in (a >= n) && 0 /= (length good)\r\n','Не удалось вычислить выражение \"canMakeScheme [130,777,70,20,446,30,1000,446] 560\", проверьте правильность синтаксиса'),(6514,79,'romos2007','2013-10-18 20:42:12',0,'﻿/*\r\n\n * Задача 20-1\r\n\n * Одеров Роман, 545 гр.\r\n\n */\r\n\nusing System;\r\n\nusing System.Collections.Generic;\r\n\nusing System.Linq;\r\n\n\r\n\nnamespace _20_1\r\n\n{\r\n\n    class Program\r\n\n    {\r\n\n        /* For example:\r\n\n         * 1/7 = 0,142857142857...\r\n\n         * 10/7 = 1,42857... <=> (1*10 - 7*0*10) / 7 = 1,42857...\r\n\n         * 100/7 = 14,2857... <=> (10*10 - 7*1*10) / 7 = 4,2857...\r\n\n         * ...\r\n\n         */\r\n\n        public static IEnumerable<int> digits(int n)\r\n\n        {\r\n\n            int nom = 1;\r\n\n            int denom = n;\r\n\n            int digit = 0;\r\n\n\r\n\n            for (int i = 1; ; i++)\r\n\n            {\r\n\n                nom = nom * 10 - denom * digit * 10;\r\n\n                digit = nom / denom;\r\n\n                yield return digit;\r\n\n            }\r\n\n        }\r\n\n        public static void ShowFractionDigits(int fraction_denom, int count)\r\n\n        {\r\n\n            int[] fractDigits = digits(fraction_denom).Take(count).ToArray();\r\n\n            for (int i = 0; i < count; i++)\r\n\n            {\r\n\n                Console.Write(\"{0}, \", fractDigits[i]);\r\n\n            }\r\n\n        }\r\n\n        static void Main(string[] args)\r\n\n        {\r\n\n            string s_fd,s_c = \"0\";\r\n\n\r\n\n            Console.Write(\"\nEnter fraction_denominator(exit = hit ENTER): \");\r\n\n            s_fd = Console.ReadLine();\r\n\n            Console.Write(\"\nEnter count of digits(exit = hit ENTER): \");\r\n\n            s_c = Console.ReadLine();\r\n\n\r\n\n            while (s_fd != \"\" || s_fd != \"\")\r\n\n            {\r\n\n                int count = Convert.ToInt32(s_c);\r\n\n                int fractDenom = Convert.ToInt32(s_fd);\r\n\n                ShowFractionDigits(fractDenom, count);\r\n\n\r\n\n                Console.Write(\"\nEnter fraction_denominator(exit = hit ENTER): \");\r\n\n                s_fd = Console.ReadLine();\r\n\n                Console.Write(\"\nEnter count of digits(exit = hit ENTER): \");\r\n\n                s_c = Console.ReadLine();\r\n\n            }\r\n\n\r\n\n            Console.WriteLine(\"\n\n---------\nHappy end. Now hit ENTER\");\r\n\n            Console.ReadLine();\r\n\n        }\r\n\n    }\r\n\n}\r\n\n\n','<br/>Тесты успешно пройдены!'),(6513,59,'5247795','2013-10-18 20:39:29',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace nonZLD\r\n{\r\n	class Program\r\n	{\r\n		static int[] nonZeroLastDigits(int[] a)\r\n		{\r\n			int [] b = a.Select(x => (x % 10)).Where(x => x > 0).ToArray();\r\n			return b;\r\n		}\r\n		static void Main(string[] args)\r\n		{\r\n			int[] a = nonZeroLastDigits(new int[4] { 354, 20, 9, 31 });\r\n			for (int i = 0; i < a.Length; i++)\r\n				Console.Write(a[i] + \" \");\r\n			Console.WriteLine();\r\n\r\n			int[] b = nonZeroLastDigits(new int[4] { 10, 207, 935, 3 });\r\n			for (int i = 0; i < b.Length; i++)\r\n				Console.Write(b[i] + \" \");\r\n			Console.WriteLine();\r\n\r\n			Console.ReadLine();\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(6511,78,'romos2007','2013-10-18 18:57:49',1,'{--\r\n\r\nЗадача 19-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\n-- Эта функция написана для моего понимания, не обращайте внимания :)\r\n\r\npascal = pascal\' [1]\r\n\r\npascal\' xs = xs : pascal\' (zipWith (+) (xs++[0]) (0:xs))\r\n\r\n-}\r\n\r\n\r\n\r\n--Только надо убрать лишнюю функцию. Например, так:\r\n\r\npascal = [1] : map (ps -> zipWith (+) (ps++[0]) (0:ps)) pascal\r\n\r\n\r\n\r\n--О, а можно так :-)\r\n\r\npascal1 = [1] : zipWith (p1 p2 -> zipWith (+) (p1++[0]) (0:p2)) pascal1 pascal1\r\n','<br/>Тесты успешно пройдены!'),(6512,80,'romos2007','2013-10-18 19:53:17',1,'﻿/*\r\n\r\n * Задача 20-2\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace _20_2\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        public static IEnumerable<int[]> cantor()\r\n\r\n        {\r\n\r\n            for (int d = 1; ; d++)\r\n\r\n            {\r\n\r\n                for (int n = d; n > 0; n--)\r\n\r\n                {\r\n\r\n                    yield return new int[2] { n, d - n + 1 };\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        public static void ShowCantor(int n)\r\n\r\n        {\r\n\r\n            int[][] cantorPairs = cantor().Take(n).ToArray();\r\n\r\n            for (int i = 0; i < n; i++)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"( {0},{1} )\",cantorPairs[i][0],cantorPairs[i][1]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            string s = \"0\";\r\n\r\n            \r\n\r\n            Console.Write(\"\r\nEnter number of Cantor pairs (exit = hit ENTER): \");\r\n\r\n            s = Console.ReadLine();\r\n\r\n            \r\n\r\n            while (s != \"\")\r\n\r\n            {\r\n\r\n                int count = Convert.ToInt32(s);\r\n\r\n                ShowCantor(count);\r\n\r\n\r\n\r\n                Console.Write(\"\r\nEnter number of Cantor pairs (exit = hit ENTER): \");\r\n\r\n                s = Console.ReadLine();\r\n\r\n            }\r\n\r\n            \r\n\r\n            Console.WriteLine(\"\r\n\r\n---------\r\nHappy end. Now hit ENTER\");\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6510,131,'toskira','2013-10-18 16:15:33',0,'import Data.List \r\n\n\r\n\np = 1000\r\n\n\r\n\nadd e [] = []\r\n\nadd e ((a,b):t) = (sort (e:a),b):(a,sort (e:b)):(a,b):(add e t)\r\n\n\r\n\nget_pairs [] l = [([],[])]\r\n\nget_pairs (h:t) l = add h (get_pairs t l)\r\n\n\r\n\nhash [] = 0\r\n\nhash (h:t) = h+p*(hash t)\r\n\n\r\n\nregroup = map ((a,b) -> if (hash b) < (hash a) then (b,a) else (a,b))\r\n\n\r\n\ndivide l = let (h:t) = nub(regroup (get_pairs l []))\r\n\n           in t\r\n\n\r\n\nprocess [] = []\r\n\nprocess ((a,b):t) = a:b:(process t)\r\n\n\r\n\nget_all_resistances [] = []\r\n\nget_all_resistances (a:[]) = [a]\r\n\nget_all_resistances (a:b:[]) = [a+b, a*b/(a+b)]\r\n\nget_all_resistances l = process [((x+y),(x*y/(x+y))) | (a,b) <- divide l, let x\' = get_all_resistances a, let y\' = get_all_resistances b, x <- x\', y <- y\']\r\n\n\r\n\ncanMakeScheme [] n = (0==n)\r\n\ncanMakeScheme (a:[]) n = (a==n) || (0==n)\r\n\ncanMakeScheme (a:b:[]) n = (a==n) || (b==n) || ((a+b)==n) || ((a*b/(a+b))==n) || (0==n)\r\n\ncanMakeScheme l n = let pairs = divide l\r\n\n                        a = sum l\r\n\n                        good = filter ((a,b) -> let x = get_all_resistances a in (any (	 -> canMakeScheme b (n-t)) x) || (any (	 -> (t-n /= 0.0) && (canMakeScheme b (t*n/(t-n)))) x)) pairs\r\n\n                    in (a >= n) && 0 /= (length good)\n','Не удалось вычислить выражение \"canMakeScheme [130,777,70,20,446,30,1000,446] 560\", проверьте правильность синтаксиса'),(6509,58,'toskira','2013-10-18 16:13:47',2,'  --- Нет, для 9 у вас все-же работает слишком долго.. У меня на компьютере за час не прошло, а предполагается\r\n  --- примерно 15 мин.\r\nimport Data.List \r\n\r\n\r\n\r\np = 1000\r\n\r\n\r\n\r\nadd e [] = []\r\n\r\nadd e ((a,b):t) = (sort (e:a),b):(a,sort (e:b)):(a,b):(add e t)\r\n\r\n\r\n\r\nget_pairs [] l = [([],[])]\r\n\r\nget_pairs (h:t) l = add h (get_pairs t l)\r\n\r\n\r\n\r\nhash [] = 0\r\n\r\nhash (h:t) = h+p*(hash t)\r\n\r\n\r\n\r\nregroup = map ((a,b) -> if (hash b) < (hash a) then (b,a) else (a,b))\r\n\r\n\r\n\r\ndivide l = let (h:t) = nub(regroup (get_pairs l []))\r\n\r\n           in t\r\n\r\n\r\n\r\nprocess [] = []\r\n\r\nprocess ((a,b):t) = a:b:(process t)\r\n\r\n\r\n\r\nget_all_resistances [] = []\r\n\r\nget_all_resistances (a:[]) = [a]\r\n\r\nget_all_resistances (a:b:[]) = [a+b, a*b/(a+b)]\r\n\r\nget_all_resistances l = process [((x+y),(x*y/(x+y))) | (a,b) <- divide l, let x\' = get_all_resistances a, let y\' = get_all_resistances b, x <- x\', y <- y\']\r\n\r\n\r\n\r\ncanMakeScheme [] n = (0==n)\r\n\r\ncanMakeScheme (a:[]) n = (a==n) || (0==n)\r\n\r\ncanMakeScheme (a:b:[]) n = (a==n) || (b==n) || ((a+b)==n) || ((a*b/(a+b))==n) || (0==n)\r\n\r\ncanMakeScheme l n = let pairs = divide l\r\n\r\n                        a = sum l\r\n\r\n                        good = filter ((a,b) -> let x = get_all_resistances a in (any (	 -> canMakeScheme b (n-t)) x) || (any (	 -> (t-n /= 0.0) && (canMakeScheme b (t*n/(t-n)))) x)) pairs\r\n\r\n                    in (a >= n) && 0 /= (length good)\r\n','<br/>Тесты успешно пройдены!'),(6508,57,'toskira','2013-10-18 16:13:28',1,'import Data.List \r\n\r\n\r\n\r\np = 1000\r\n\r\n\r\n\r\nadd e [] = []\r\n\r\nadd e ((a,b):t) = (sort (e:a),b):(a,sort (e:b)):(a,b):(add e t)\r\n\r\n\r\n\r\nget_pairs [] l = [([],[])]\r\n\r\nget_pairs (h:t) l = add h (get_pairs t l)\r\n\r\n\r\n\r\nhash [] = 0\r\n\r\nhash (h:t) = h+p*(hash t)\r\n\r\n\r\n\r\nregroup = map ((a,b) -> if (hash b) < (hash a) then (b,a) else (a,b))\r\n\r\n\r\n\r\ndivide l = let (h:t) = nub(regroup (get_pairs l []))\r\n\r\n           in t\r\n\r\n\r\n\r\nprocess [] = []\r\n\r\nprocess ((a,b):t) = a:b:(process t)\r\n\r\n\r\n\r\nget_all_resistances [] = []\r\n\r\nget_all_resistances (a:[]) = [a]\r\n\r\nget_all_resistances (a:b:[]) = [a+b, a*b/(a+b)]\r\n\r\nget_all_resistances l = process [((x+y),(x*y/(x+y))) | (a,b) <- divide l, let x\' = get_all_resistances a, let y\' = get_all_resistances b, x <- x\', y <- y\']\r\n\r\n\r\n\r\ncanMakeScheme [] n = (0==n)\r\n\r\ncanMakeScheme (a:[]) n = (a==n) || (0==n)\r\n\r\ncanMakeScheme (a:b:[]) n = (a==n) || (b==n) || ((a+b)==n) || ((a*b/(a+b))==n) || (0==n)\r\n\r\ncanMakeScheme l n = let pairs = divide l\r\n\r\n                        a = sum l\r\n\r\n                        good = filter ((a,b) -> let x = get_all_resistances a in (any (	 -> canMakeScheme b (n-t)) x) || (any (	 -> (t-n /= 0.0) && (canMakeScheme b (t*n/(t-n)))) x)) pairs\r\n\r\n                    in (a >= n) && 0 /= (length good)\r\n','<br/>Тесты успешно пройдены!'),(6507,57,'toskira','2013-10-18 15:48:18',0,'import Data.List \r\n\n\r\n\np = 1000\r\n\n\r\n\nadd e [] = []\r\n\nadd e ((a,b):t) = (sort (e:a),b):(a,sort (e:b)):(a,b):(add e t)\r\n\n\r\n\nget_pairs [] l = [([],[])]\r\n\nget_pairs (h:t) l = add h (get_pairs t l)\r\n\n\r\n\nhash [] = 0\r\n\nhash (h:t) = h+p*(hash t)\r\n\n\r\n\nregroup = map ((a,b) -> if (hash b) < (hash a) then (b,a) else (a,b))\r\n\n\r\n\ndivide l = let (h:t) = nub(regroup (get_pairs l []))\r\n\n           in t\r\n\n\r\n\nprocess [] = []\r\n\nprocess ((a,b):t) = a:b:(process t)\r\n\n\r\n\nget_all_resistances [] = []\r\n\nget_all_resistances (a:[]) = [a]\r\n\nget_all_resistances (a:b:[]) = [a+b, a*b/(a+b)]\r\n\nget_all_resistances l = process [((x+y),(x*y/(x+y))) | (a,b) <- divide l, let x\' = get_all_resistances a, let y\' = get_all_resistances b, x <- x\', y <- y\']\r\n\n\r\n\ncanMakeScheme [] n = (0==n)\r\n\ncanMakeScheme (a:[]) n = (a==n) || (0==n)\r\n\ncanMakeScheme (a:b:[]) n = (a==n) || (b==n) || ((a+b)==n) || ((a*b/(a+b))==n) || (0==n)\r\n\ncanMakeScheme l n = let pairs = divide l\r\n\n                        a = sum l\r\n\n                        b = product l\r\n\n                        good = filter ((a,b) -> let x = get_all_resistances a in (any (	 -> canMakeScheme b (n-t)) x) || (any (	 -> (t-n /= 0.0) && (canMakeScheme b (t*n/(t-n)))) x)) pairs\r\n\n                    in (a >= n) && ((b/a) <= n) && 0 /= (length good)\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),(6505,59,'ArtemK','2013-10-18 14:41:04',1,'using System;\r\nusing System.Linq;\r\n\r\n\r\nnamespace Task\r\n{\r\n	class MainClass\r\n	{\r\n		public static int[] nonZeroLastDigits(int[] a) \r\n		{\r\n			return a.Select (x => x % 10).Where (x => x != 0).ToArray();\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			int[] a = { 11, 220, 23, 4, 5 };\r\n			a = nonZeroLastDigits (a);\r\n			foreach (int i in a) {\r\n				Console.WriteLine (i);\r\n			}\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(6506,57,'toskira','2013-10-18 15:44:33',0,'import Data.List \r\n\n\r\n\np = 1000\r\n\n\r\n\nadd e [] = []\r\n\nadd e ((a,b):t) = (sort (e:a),b):(a,sort (e:b)):(a,b):(add e t)\r\n\n\r\n\nget_pairs [] l = [([],[])]\r\n\nget_pairs (h:t) l = add h (get_pairs t l)\r\n\n\r\n\nhash [] = 0\r\n\nhash (h:t) = h+p*(hash t)\r\n\n\r\n\nregroup = map ((a,b) -> if (hash b) < (hash a) then (b,a) else (a,b))\r\n\n\r\n\ndivide l = let (h:t) = nub(regroup (get_pairs l []))\r\n\n           in t\r\n\n\r\n\nprocess [] = []\r\n\nprocess ((a,b):t) = a:b:(process t)\r\n\n\r\n\nget_all_resistances [] = []\r\n\nget_all_resistances (a:[]) = [a]\r\n\nget_all_resistances (a:b:[]) = [a+b, a*b/(a+b)]\r\n\nget_all_resistances l = process [((x+y),(x*y/(x+y))) | (a,b) <- divide l, let x\' = get_all_resistances a, let y\' = get_all_resistances b, x <- x\', y <- y\']\r\n\n\r\n\nf [] n = (0==n)\r\n\nf (a:[]) n = (a==n) || (0==n)\r\n\nf (a:b:[]) n = (a==n) || (b==n) || ((a+b)==n) || ((a*b/(a+b))==n) || (0==n)\r\n\nf l n = let pairs = divide l\r\n\n            a = sum l\r\n\n            b = product l\r\n\n            good = filter ((a,b) -> let x = get_all_resistances a in (any (	 -> f b (n-t)) x) || (any (	 -> (t-n /= 0.0) && (f b (t*n/(t-n)))) x)) pairs\r\n\n        in (a >= n) && ((b/a) <= n) && 0 /= (length good)\n','Не удалось вычислить выражение \"canMakeScheme [4,4,5] 7\", проверьте правильность синтаксиса'),(6504,68,'ArtemK','2013-10-18 14:38:40',1,'using System;\r\nusing System.Linq;\r\n\r\n\r\nnamespace Task\r\n{\r\n	class MainClass\r\n	{\r\n		public static int[] zeroDigits(int[] a, int n)\r\n		{\r\n			int m = (int)Math.Pow (10, n);\r\n			return a.Select(x => x - x % m).ToArray();\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			int[] a = { 11, 220, 23, 4, 5 };\r\n			a = zeroDigits (a, 2);\r\n			foreach (int i in a) {\r\n				Console.WriteLine (i);\r\n			}\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(6501,72,'SNNatalieS','2013-10-18 01:22:10',1,'weekendExpences xs = let weekends = 0 : 0 : 0 : 0 : 0 : 1 : 1 : weekends\r\n						in sum (zipWith (*) weekends xs)\r\n','<br/>Тесты успешно пройдены!'),(6502,132,'SNNatalieS','2013-10-18 01:43:55',1,'fact = 1 : [x * y | (x, y) <- zip fact [2..]]','<br/>Тесты успешно пройдены!'),(6503,66,'5543298','2013-10-18 01:47:58',2,'generalizedCantor n = map (x -> g x n) [1..]\r\n  \r\n\r\n\r\ng\' n k i xs = if i == k then xs else g\' (div n k) k (i + 1) ((mod n k + 1):xs)\r\n\r\ng n k = g\' n k 0 [] \r\n  --- Это что-то совсем не то:( Например, generalizedCantor 2 у вас выдает только последовательности из чмсел 1 и 2..\r\n\r\n','Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),(6497,132,'romos2007','2013-10-18 00:51:11',1,'{--\r\n\r\nЗадача 18-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nfacts = 1:(zipWith (*) [2	..] facts)\r\n','<br/>Тесты успешно пройдены!'),(6498,72,'romos2007','2013-10-18 00:51:38',1,'{--\r\n\r\nЗадача 18-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndays = 0:0:0:0:0:1:1:days\r\n\r\nweekendExpences xs = sum (zipWith (*) days xs)\r\n','<br/>Тесты успешно пройдены!'),(6499,69,'romos2007','2013-10-18 00:51:51',1,'{--\r\n\r\nЗадача 18-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nbigSin n = head (filter (sinus -> sinus > n) (map sin [1..]))\r\n','<br/>Тесты успешно пройдены!'),(6500,74,'5543298','2013-10-18 01:02:58',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = let\r\n\r\n     resl = foldTree f e l\r\n\r\n     resr = foldTree f e r\r\n\r\n  in f val resl resr\r\n\r\n  \r\n\r\nsumPos x = foldTree (a b c -> sum (filter (>0) [a, b, c])) 0 x\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6493,132,'5543298','2013-10-17 23:51:27',1,'facts = 1 : 2 : map ((a,b) -> b * (div b a + 1)) (zip facts (tail facts))\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6494,133,'5543298','2013-10-18 00:34:57',1,'fib = 1 : 1 : map ((a,b) -> a + b) (zip fib (tail fib))\r\n','<br/>Тесты успешно пройдены!'),(6495,74,'romos2007','2013-10-18 00:50:42',1,'{--\r\n\r\nЗадача 18-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\ndata Tree = Empty |\r\n\r\n			Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val l r) = \r\n\r\n	let \r\n\r\n		resl = foldTree f e l\r\n\r\n		resr = foldTree f e r\r\n\r\n	in f val resl resr\r\n\r\n\r\n\r\nsumPos t = foldTree (i l r -> let lr = l+r in if (i > 0) then i+lr else lr) 0 t\r\n','<br/>Тесты успешно пройдены!'),(6496,133,'romos2007','2013-10-18 00:50:56',1,'{--\r\n\r\nЗадача 18-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nfib  = 1:1:zipWith (+) fib (tail fib)\r\n','<br/>Тесты успешно пройдены!'),(6491,69,'5543298','2013-10-17 00:58:06',1,'bigSin x = head [sin n | n <- [1..], sin (n - 1) < x, sin n >= x]\r\n   --- проверка sin (n-1)<x на самом деле лишняя - можете ее убрать и убедиться, что все работает:)\r\n','<br/>Тесты успешно пройдены!'),(6492,72,'5543298','2013-10-17 01:20:45',1,'weekends = 0:0:0:0:0:1:1:weekends\r\n\r\nweekendExpences xs = sum (zipWith (*) weekends xs)\r\n','<br/>Тесты успешно пройдены!'),(6490,57,'nbumakov','2013-10-17 00:29:07',1,'generatePairsList [] = []\r\ngeneratePairsList (x:xs) = foldr (y zs -> (x, y) : zs) [] xs : generatePairsList xs\r\ngeneratePairs xs = concat (generatePairsList xs)\r\n\r\nremove y (x:xs)\r\n  | x == y    = xs\r\n  | otherwise = x : remove y xs\r\n\r\ncanMakeScheme :: [Float] -> Float -> Bool \r\ncanMakeScheme [x] r = x == r\r\ncanMakeScheme xs r \r\n  | elem r xs = True\r\n  | otherwise = let\r\n                checkPair (r1,r2) =\r\n                  let\r\n                  ys = remove r2 (remove r1 xs)  \r\n                  in canMakeScheme (r1 + r2 : ys) r || canMakeScheme (r1 * r2 / (r1 + r2) : ys) r  \r\n                resultList = map checkPair (generatePairs xs)\r\n                in or resultList\r\n','<br/>Тесты успешно пройдены!'),(6489,56,'nbumakov','2013-10-17 00:28:13',1,'allLists n 0 = [[]]\r\nallLists n k = [ x:xs | x <- [1..n], xs <- allLists n (k - 1)]','<br/>Тесты успешно пройдены!'),(6488,133,'deripaska','2013-10-16 23:04:12',1,'{--\r\n\r\n	task 18-04\r\n\r\n*Программа по картинке*\r\n\r\n\r\n\r\nВ слайдах 7 занятия на последнем слайде есть картинка. Эта картинка взята из одного их руководств по языку Haskell и иллюстрирует некоторую программу, описывающую бесконечный список fib.\r\n\r\nВаша задача - написать программу, которая, как вам кажется, соответствует этому рисунку.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 6 fib\r\n\r\nДолжно получиться [1,1,2,3,5,8]\r\n\r\n--}\r\n\r\n\r\n\r\nfib = 1:1:(zipWith (+) (tail fib) fib)\r\n','<br/>Тесты успешно пройдены!'),(6487,132,'deripaska','2013-10-16 22:59:46',1,'{--\r\n\r\n	task 18-03\r\n\r\nОписать бесконечный список facts, состоящий из факториалов целых положительных чисел [1!, 2!, 3!, 4!, ...]. \r\n\r\n\r\n\r\nПро этом в этой задаче довольно строгие дополнительные условия - см ниже. Особенно обратите, пожалуйста, внимание, на первое условие - тут надо обязательно применить именно этот прием. \r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 5 facts\r\n\r\nРезультат должен быть равен [1, 2, 6, 24, 120].\r\n\r\n--}\r\n\r\n\r\n\r\nfacts = 1:(zipWith (*) facts [(head facts + 1)..])\r\n','<br/>Тесты успешно пройдены!'),(6486,132,'anlun','2013-10-16 22:21:12',1,'facts = (++) [1, 2] $ zipWith (l r -> (r `div` l + 1) * r) facts $ tail facts','<br/>Тесты успешно пройдены!'),(6485,74,'anlun','2013-10-16 22:18:14',1,'sumPos = foldTree (v l r -> l + r + if v > 0 then v else 0) 0\r\n   --- OK, но foldTree тоже надо включить в текст, чтобы тесты прошли','Не удалось вычислить выражение \"sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(6484,133,'anlun','2013-10-16 22:11:42',1,'fib :: [Int]\r\nfib = (++) [1, 1] $ zipWith (+) fib $ tail fib','<br/>Тесты успешно пройдены!'),(6483,131,'3226573','2013-10-16 18:25:58',1,'-- Это решение - улучшенный вариант предыдущего решения для 13-3\r\n\r\nmodule HardHard where\r\n\r\n\r\n\r\nimport Data.List\r\n\r\nimport Data.Set (Set)\r\n\r\nimport qualified Data.Set as Set\r\n\r\n\r\n\r\n-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\r\n\r\nsplitList xs n m = let \r\n\r\n					 (x, t) = splitAt n xs\r\n\r\n					 (y, z) = splitAt (m - n) t		     \r\n\r\n				   in (x ++ (tail y) ++ (tail z), head y, head z)\r\n\r\n\r\n\r\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\r\n\r\nremoveElem xs n = let\r\n\r\n					(x, y) = splitAt n xs\r\n\r\n				  in (x ++ (tail y), head y)\r\n\r\n\r\n\r\n-- Ситуация, когда 2 элемента соединяем последовательно в 1\r\n\r\nf1 m (rss, s, p) (ans, cache) =	if (s == m || p == m) then (True, cache)\r\n\r\n								else canMakeScheme\' (insert s rss) m (ans, cache)\r\n\r\n\r\n\r\n-- Ситуация, когда 2 элемента соединяем параллельно в 1\r\n\r\nf2 m (rss, s, p) res = 	if s == p then res\r\n\r\n						else canMakeScheme\' (insert p rss) m res\r\n\r\n\r\n\r\n-- Хеш-функция от входного массива\r\n\r\nhash xs = foldr (x res -> res * 37 + x) 0 xs\r\n\r\n\r\n\r\n-- Главная функция\r\n\r\ncanMakeScheme\' rs m (ans, cache)\r\n\r\n	| ans == True = (ans, cache) \r\n\r\n	| rs == [] = (False, cache)\r\n\r\n	| Set.member calculatedHash cache = (False, cache)\r\n\r\n	| otherwise = 	let\r\n\r\n						listsWithoutTwo = 	[(rss, s, p)| n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], \r\n\r\n											let (rss, x, y) = splitList rs n1 n2, let s = x + y, let p = x * y / (x + y)]\r\n\r\n						(ans1, cache1) = foldr (f1 m) (ans, cache) listsWithoutTwo\r\n\r\n					in	if ans1 then (ans1, cache1)\r\n\r\n						else	let\r\n\r\n									(ans2, cache2) = foldr (f2 m) (ans1, cache1) listsWithoutTwo\r\n\r\n								in 	if ans2 then (ans2, cache2)\r\n\r\n									else (ans2, (Set.insert calculatedHash cache2))	\r\n\r\n	where calculatedHash = hash rs											 		\r\n\r\n\r\n\r\ncanMakeScheme rs m = any ( == m) rs || fst (canMakeScheme\' (sort (filter ( > 0) rs)) m (False, Set.empty))\r\n','<br/>Тесты успешно пройдены!'),(6482,72,'deripaska','2013-10-16 18:20:56',1,'{--\r\n\r\n	task 18-02\r\n\r\nПусть в списке я записал последовательность чисел - сколько денег я тратил каждый день в этом году. Запись я начал, конечно же, с понедельника. \r\n\r\n\r\n\r\nОпишите функцию weekendExpences у которой параметр - такой список расходов, и которая вычисляет для него общую сумму расходов по выходным.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nweekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1, 3]\r\n\r\nОтвет должен быть равен 5+17+5+1 = 28.\r\n\r\n--}\r\n\r\n\r\n\r\nweekendExpencesTemplate = 0:0:0:0:0:1:1:weekendExpencesTemplate\r\n\r\nweekendExpences xs = sum (zipWith (*) xs weekendExpencesTemplate)\r\n','<br/>Тесты успешно пройдены!'),(6481,69,'deripaska','2013-10-16 18:20:39',1,'{--\r\n\r\n	task 18-01\r\n\r\nОписать функцию bigSin c параметром x, которая возвращает первый элемент в последовательности\r\n\r\nsin 1, sin 2, sin 3, sin 4, ...\r\n\r\n, который больше или равен x. \r\n\r\n\r\n\r\nДополнительное условие: нельзя определять свои функции (кроме bigSin, конечно). Можно использовать любые стандартные функции и лямбда выражения.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nbigSin 0.99\r\n\r\nрезультат должен быть равен примерно 0.990607\r\n\r\n--}\r\n\r\n\r\n\r\nsinSeq = map sin [1..]\r\n\r\nbigSin x = head (filter (>= x) sinSeq)\r\n','<br/>Тесты успешно пройдены!'),(6480,133,'1835693','2013-10-16 16:10:03',1,'fib = 1 : 1 : zipWith (+) (drop 1 fib) fib','<br/>Тесты успешно пройдены!'),(6479,74,'1835693','2013-10-16 16:03:47',2,'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\nfoldTree f e Empty          = f e 0\r\nfoldTree f e (Node val l r) = let res1 = foldTree f e l \r\n                                  res2 = foldTree f res1 r\r\n                              in f res2 val\r\n\r\nsumPos t = foldTree addPos 0 t\r\n\r\naddPos a b = max a 0 + max b 0\r\n   --- Нет, это не тот вариант fold. который мы называем катаморфизмом. Посмотрите слайды внимательнее, пожалуйста','<br/>Тесты успешно пройдены!'),(6478,62,'517309','2013-10-16 16:01:27',3,'sumDiv n = sum (listDiv n)\r\n\r\nlistDiv n = [ i|  i<-[1.. (n `div` 2)], n `mod` i ==0]\r\n\r\nlistSum n = [sumDiv i| i<-[1..n] ]\r\n\r\n\r\n\r\namicables n = let l = listSum n in [(i,j)|j<-[1..n-1], i<-[1..j-1],  j==l!!i, l!!j==i]','Выражение имеет неправильное значение: amicables 300'),(6475,72,'1835693','2013-10-16 14:56:57',1,'weekendExpences xs = foldl (+) 0 [ xs !! i | i <- [0..(length xs - 1)], isWeekend i ]\r\n\r\nisWeekend i = (mod i 7 == 5) || (mod i 7 == 6)','<br/>Тесты успешно пройдены!'),(6476,132,'1835693','2013-10-16 15:48:30',2,'-- Используется вспомогательная лямбда-фунцкия: x -> x * head [ y | y <- [1..(x + 1)]\r\n-- Она ищет первый делитель, не входящий в факториал, и домножает на него, т.е. на самом деле это n! -> (n+1)!\r\n-- Таким образом, на каждой итерации достаточно дописать 1 в начало\r\n   --- Идея интересная, но например, у вас 5! домножится не на 6, а на 7..\r\n   --- Попробуйте исправить, пожалуйста, а я сечас добавлю такой тест.\r\n   --- Могу немного подсказать - опериции, которые мы делаем с последовательностбю, это вовсе не обязательно\r\n   --- map. Можно, например, применить zipWith\r\nfacts = 1 : map (x -> x * head [ y | y <- [1..(x + 1)], mod x y /= 0 ]) facts','<br/>Тесты успешно пройдены!'),(6477,132,'1835693','2013-10-16 15:55:47',1,'-- update: переписал после того, как узнал, что такое zipWith :)\r\nfacts = 1 : zipWith (*) [2..] facts','<br/>Тесты успешно пройдены!'),(6473,69,'1835693','2013-10-16 13:52:05',0,'bigSin x = head [ sin y | y <- [1..], sin y > x ]','<br/>Тесты успешно пройдены!'),(6474,69,'1835693','2013-10-16 13:52:32',1,'-- update: заменил \'>\' на \'>=\'\r\nbigSin x = head [ sin y | y <- [1..], sin y >= x ]','<br/>Тесты успешно пройдены!'),(6472,74,'deripaska','2013-10-16 10:36:00',1,'{--\r\n\r\n	task 18-05\r\n\r\nИспользуя функцию foldTree с последнего занятия (второй вариант, который катаморфизм), опишите функцию sumPos. У этой функции параметр - дерево, и она должна вычислять сумму всех положительных чисел в этом дереве.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nsumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\r\n\r\nОтвет должен быть равен 7.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Empty \r\n\r\n			| Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val left right) = f val (foldTree f e left) (foldTree f e right)\r\n\r\n\r\n\r\nsumPos tree = foldTree (val leftRes rightRes -> \r\n\r\n							let curRes = leftRes + rightRes \r\n\r\n							in if (val > 0) then val + curRes else curRes\r\n  --- Ну или можно короче letfRes + rightRes + if val > 0 then val else 0\r\n						) 0 tree\r\n','<br/>Тесты успешно пройдены!'),(6469,132,'115753099','2013-10-16 01:06:05',1,'import Data.List\r\n\r\nfacts = 1 : s\r\n	where (_,s) = mapAccumL (acc x -> (acc + 1, x * acc)) 2 facts','<br/>Тесты успешно пройдены!'),(6470,133,'115753099','2013-10-16 01:19:54',1,'fib = 1 : 1 : (zipWith (+) fib (tail fib))','<br/>Тесты успешно пройдены!'),(6471,74,'115753099','2013-10-16 01:29:13',1,'data Tree = Empty | Node Int Tree Tree\r\n\r\nfoldTree f e (Node val l r) = let\r\n     resl = foldTree f e l\r\n     resr = foldTree f e r\r\n  in f val resl resr\r\nfoldTree f e Empty = e\r\n\r\nsumPos =\r\n	foldTree (v l r -> maximum [v+l+r,v+l,v+r,l+r,v,l,r]) 0\r\n   --- ОК, но на самом деле можно maximum [v+l+r,l+r]\r\n   --- Поскольку l и r точно по условию >= 0, то остальные числа точно не больше.','<br/>Тесты успешно пройдены!'),(6467,69,'115753099','2013-10-16 00:42:26',1,'bigSin x =\r\n	head [sin y | y <- [1..], sin y >= x]','<br/>Тесты успешно пройдены!'),(6468,72,'115753099','2013-10-16 00:51:40',1,'helpList = 0:0:0:0:0:1:1:helpList\r\nweekendExpences xs =\r\n	sum $ zipWith (*) xs helpList','<br/>Тесты успешно пройдены!'),(6464,65,'artem.gomerman','2013-10-15 22:57:39',1,'cantor = [(generatePair i n) | n <- [1..], i <- [1..(2*n - 1)]]\r\n\r\ngeneratePair currentIndex neededMax = if currentIndex <= neededMax then (currentIndex, neededMax) else (neededMax, 2*neededMax - currentIndex)\r\n','<br/>Тесты успешно пройдены!'),(6465,57,'ilia','2013-10-15 23:07:50',0,'\n','Не удалось вычислить выражение \"canMakeScheme [4,4,5] 7\", проверьте правильность синтаксиса'),(6466,57,'ilia','2013-10-15 23:25:48',2,'import Data.List\r\n\r\n--- Вы предоплагаете, что можно брать по поному элементу, и присоединять к существующей схеме.\r\n--- Но мб ведь и более сложные иераршии. Например\r\n--- (13 и 2 последовательно) параллельно (7 и 3 последовательно)\r\n\r\n\r\ncanMakeScheme _ 0 = True\r\n\r\ncanMakeScheme r m = any (\r\n\r\n	\r\ni -> let\r\n\r\n		nm = m - ri\r\n\r\n		nr = delete ri r\r\n\r\n	in\r\n\r\n		if nm >= 0 then\r\n\r\n			canMakeScheme nr nm\r\n\r\n				|| canMakeScheme nr (div (ri * m) nm)\r\n\r\n		else\r\n\r\n			False\r\n\r\n	) r\r\n\r\n\r\n\r\nmain = print (canMakeScheme [13, 2, 10] 30)\r\n\r\n\r\n','Выражение имеет неправильное значение: canMakeScheme [13,10, 2, 1000, 1000] 506'),(6463,57,'ilia','2013-10-15 21:57:54',0,'canMakeScheme r m = canMakeScheme\' (zip r [1..]) m\n\n\n\ncanMakeScheme\' _ 0 = True\n\ncanMakeScheme\' rt m = any (\n\n		\ri ->\n\n			let\n\n				nm = m - fst ri\n\n				nr = take (snd ri) rt\n\n					++ map (\nri -> (fst nri, snd nri - 1))\n\n						(drop (snd ri + 1) rt)\n\n			in\n\n				if nm >= 0 then\n\n					canMakeScheme\' nr nm\n\n						|| canMakeScheme\' nr (div (fst ri * m) nm)\n\n				else\n\n					False\n\n		) rt\n\n\n\nmain = print (canMakeScheme [13, 7, 2, 3] 6)\n\n--main = print (zip [13, 7, 2, 3] [1..])\n\n\n','Не удалось вычислить выражение \"canMakeScheme [13,2,10] 30\", проверьте правильность синтаксиса'),(6461,57,'ilia','2013-10-15 20:44:10',0,'canMakeScheme _ 0 = True\n\ncanMakeScheme r m = any (\n\n		\ri ->\n\n			let\n\n				nm = m - ri\n\n				r12 = span (==ri) r\n\n				nr = tail (fst r12) ++ (snd r12)\n\n			in\n\n				if nm >= 0 then\n\n					canMakeScheme nr nm\n\n						|| canMakeScheme nr (div (ri * m) nm)\n\n				else\n\n					False\n\n		) r\n\n\n\nmain = print (canMakeScheme [4, 4, 5] 70)\n\n\n','Не удалось вычислить выражение \"canMakeScheme [13, 7, 2, 3] 6\", проверьте правильность синтаксиса'),(6462,57,'ilia','2013-10-15 21:41:08',0,'\n','Не удалось вычислить выражение \"canMakeScheme [4,4,5] 7\", проверьте правильность синтаксиса'),(6460,66,'5543298','2013-10-15 15:46:29',2,'generalizedCantor\' 0 _ = [[]]\r\n\r\ngeneralizedCantor\' n max = [x:xs | x <- [1..max], xs <- generalizedCantor\' (n - 1) max]\r\n  --- Так у вас получаются только подсписки, в которых первый элемент - самый большой\r\ngeneralizedCantor n = [x:xs | x <- [1..], xs <- generalizedCantor\' (n - 1) x]\r\n','Выражение имеет неправильное значение: length(filter (==[2,1,4]) (take 10000 (generalizedCantor 3)))'),(6459,66,'5543298','2013-10-15 13:18:41',0,'generalizedCantor\' 0 _ = [[]]\r\n\ngeneralizedCantor\' n max = [x:xs | x <- [1..max], xs <- generalizedCantor\' (n - 1) x]\r\n\ngeneralizedCantor n = [x:xs | x <- [1..], xs <- generalizedCantor\' (n - 1) x]\n','Выражение имеет неправильное значение: length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))'),(6458,56,'ilia','2013-10-15 12:50:28',1,'allLists n k = gen_lists [1..n] k\r\n\r\n\r\n\r\ngen_lists s 1 = [ [i] | i <- s ]\r\n\r\ngen_lists s l = [ i : gl | gl <- gen_lists s (l - 1), i <- s ]\r\n\r\n\r\n\r\nmain = print (allLists 3 2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6457,56,'ilia','2013-10-15 12:49:24',0,'allLists n k = gen_lists [1..n] k\n\n\n\ngen_lists s 1 = [ [i] | i <- s ]\n\ngen_lists s l = [ i : gl | gl <- gen_lists s (l - 1), i <- filter (si -> all (gli -> si /= gli) gl) s ]\n\n\n\nmain = print (allLists 3 2)\n\n\n','Выражение имеет неправильное значение: length (allLists 3 3)'),(6456,65,'ArtemK','2013-10-15 12:20:42',1,'cantor = cantor\' (1,1)\r\ncantor\' (x,1) = (x,1): cantor\' (1,x+1)\r\ncantor\' (x,y) = if y > x then (x,y):cantor\' (x+1,y)\r\n                       else (x,y):cantor\' (x,y-1)\r\n','<br/>Тесты успешно пройдены!'),(6455,56,'ArtemK','2013-10-15 11:41:11',1,'allLists _ 0 = [[]]\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- (allLists n (k-1))]','<br/>Тесты успешно пройдены!'),(6454,68,'ArtemK','2013-10-15 11:29:14',2,'--- В задачах по C# надо присылать полную программу, чтобы ее в принципе можно было скомпилировать. \r\n--- Не то чтобы это было очень принципиально, но пришлите, пожалуйста.\r\n--- И раз уж вы будете присылать снова - на самом деле ваша программа считает Pow(10, n)\r\n--- для каждого числа, и это конечно очень неэффективно. Попробуйте, пожалуйста, исправить,\r\n--- чтобы степень считалась один раз, это просто.\r\n\r\n		public static int[] zeroDigits(int[] a, int n)\r\n		{\r\n			return a.Select(x => x - x % (int) Math.Pow(10, n)).ToArray();\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			int[] a = { 11, 220, 23, 4, 5 };\r\n			a = zeroDigits (a, 2);\r\n			foreach (int i in a) {\r\n				Console.WriteLine (i);\r\n			}\r\n		}','<br/>Тесты успешно пройдены!'),(6453,59,'ArtemK','2013-10-15 11:21:09',2,'--- тут все правильно, но то же, пришлите пожалуйста, полую прjграмму на C#\r\n		public static int[] nonZeroLastDigits(int[] a) \r\n		{\r\n			return a.Select (x => x % 10).Where (x => x != 0).ToArray();\r\n		}\r\n\r\n		public static void Main (string[] args)\r\n		{\r\n			int[] a = { 11, 220, 23, 4, 5 };\r\n			a = nonZeroLastDigits (a);\r\n			foreach (int i in a) {\r\n				Console.WriteLine (i);\r\n			}\r\n		}','<br/>Тесты успешно пройдены!'),(6452,58,'55363692','2013-10-15 02:11:45',1,'-- для 9 работает 50 минут, для 8-ми 3 минуты.\r\n\r\n-- Можете подсказать немного как можно улучшить? Я пока вижу след. варианты:\r\n\r\n-- 1) можно генировать схемы состоящие только из 9 транзисторов (если всего 9, конечно), а не из 8,7, и так далее.\r\n\r\n-- Так как случай меньшего числа транзисторов можно учесть при переборе вариантов\r\n\r\n-- 2) Проверять все схемы сразу, а не по отдельности. То есть, совместить генерацию и проверку вариантов, чтобы не считать \r\n\r\n-- некоторые значения дважды.\r\n\r\n-- 3) Отсекать заведомо неподходящие варианты, \r\n\r\n-- например если сумма всех сопротивлений меньше чем сопротивление которое хотим получить\r\n\r\n-- 4) Распараллелить проверку схем\r\n\r\n\r\n\r\nimport Data.List\r\n\r\nimport Control.Parallel.Strategies\r\n\r\n\r\n\r\ndata Circuit len = Res | SeqRes len | ParRes len | Seq [Circuit Int] | Par [Circuit Int] deriving (Eq, Show)\r\n\r\n	\r\n\r\ntoString circuit = case circuit of\r\n\r\n	Res -> \"Res\"\r\n\r\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n	Par xs -> \"Par [\"  ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n	SeqRes l -> \"SeqRes \" ++ (show l)\r\n\r\n	ParRes l -> \"ParRes \" ++ (show l)\r\n\r\n	\r\n\r\nlen circuit = case circuit of\r\n\r\n	Res-> 1\r\n\r\n	Seq xs -> sum $ map (x -> len x) xs\r\n\r\n	Par xs -> sum $ map (x -> len x) xs\r\n\r\n	SeqRes l -> l\r\n\r\n	ParRes l -> l\r\n\r\n\r\n\r\nparts\' n k = \r\n\r\n	if n == 0 then [[]]\r\n\r\n	else if k > n then [] \r\n\r\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\r\n\r\nparts n = tail $ parts\' n 1\r\n\r\n	\r\n\r\n-- 1 == Par\r\n\r\n-- 0 == Seq\r\n\r\ngenerateAllCircuits\' n op = \r\n\r\n	if n == 1 then [Res]\r\n\r\n	else if op == 0 then let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Seq c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n	else let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Par c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n\r\n\r\ngenerateAllCircuits :: Int -> [Circuit Int]\r\n\r\n--generateAllCircuits n = generateAllCircuits\' n 0 ++ generateAllCircuits\' n 1\r\n\r\ngenerateAllCircuits n = concat [generateAllCircuits\' k 0 ++ generateAllCircuits\' k 1 | k <- [1..n]]\r\n\r\n\r\n\r\nchange circuit = case circuit of\r\n\r\n	Res -> Res\r\n\r\n	Seq xs -> if all (==Res) xs then SeqRes (length xs) else Seq $ map (c -> change c) xs \r\n\r\n	Par xs -> if all (==Res) xs then ParRes (length xs) else Par $ map (c -> change c) xs\r\n\r\n\r\n\r\ntakeK\' k xs = let \r\n\r\n	l = length xs \r\n\r\n	in  if (k == 0) then [([], xs)]\r\n\r\n		else if (k == l) then [(xs, [])]\r\n\r\n		else let\r\n\r\n			(x:ys) = xs\r\n\r\n			res1 = [(x:acc1, acc2) | (acc1, acc2) <- takeK\' (k - 1) ys]\r\n\r\n			res2 = [(acc1, x:acc2) | (acc1, acc2) <- takeK\' k ys]\r\n\r\n		in res1 ++ res2\r\n\r\ntakeK k xs = takeK\' k xs\r\n\r\n\r\n\r\nzipSeq (fst, snd) (x:cs) = let \r\n\r\n	res1 = generateAllResistanses fst x\r\n\r\n	res2 = generateAllResistanses snd (Seq cs)\r\n\r\n	in [r1 + r2 | r1 <- res1, r2 <- res2]\r\n\r\n	\r\n\r\nzipPar (fst, snd) (x:cs) = let \r\n\r\n	res1 = generateAllResistanses fst x\r\n\r\n	res2 = generateAllResistanses snd (Par cs)\r\n\r\n	in [(r1 * r2)/ (r1 + r2) | r1 <- res1, r2 <- res2]	\r\n\r\n\r\n\r\ngenerateAllResistanses xs circuit = case circuit of\r\n\r\n	Res -> xs\r\n\r\n	SeqRes l -> let\r\n\r\n		ds = takeK l xs\r\n\r\n		in [sum (fst d) | d <- ds]\r\n\r\n	Seq (x:[]) -> generateAllResistanses xs x\r\n\r\n	Seq (x:cs) -> let\r\n\r\n		l = len x\r\n\r\n		ds = takeK l xs\r\n\r\n		res = map (d -> zipSeq d (x:cs)) ds\r\n\r\n		in concat res\r\n\r\n	ParRes l -> let\r\n\r\n		ds = takeK l xs\r\n\r\n		in [1 / (sum (map (1/) (fst d))) | d <- ds]\r\n\r\n	Par (x:[]) -> generateAllResistanses xs x\r\n\r\n	Par (x:cs) -> let \r\n\r\n		l = len x\r\n\r\n		ds = takeK l xs\r\n\r\n		res = map (d -> zipPar d (x:cs)) ds\r\n\r\n		in concat res\r\n\r\n\r\n\r\ncheckCircuit xs circuit res = let \r\n\r\n	allResistances = generateAllResistanses	xs circuit\r\n\r\n	in elem res allResistances\r\n\r\n		\r\n\r\ncanMakeScheme rs res = let \r\n\r\n		n = length rs\r\n\r\n		allCircuits = map (c -> change c) (generateAllCircuits n)\r\n\r\n		bs\' = map (c -> checkCircuit rs c res) allCircuits \r\n\r\n		bs = bs\' `using` parList rdeepseq\r\n\r\n		in any (id) bs\r\n\r\n	-- in do\r\n\r\n		-- putStr $ unlines (map (c -> toString c) allCircuits)\r\n\r\n		-- putStrLn $ \"\r\nTOTAL = \" ++ (show $ length allCircuits)\r\n\r\n		\r\n\r\n--main = print $ canMakeScheme [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 200\r\n','Не удалось вычислить выражение \"canMakeScheme [13,2,30,3,7] 6\", проверьте правильность синтаксиса'),(6451,58,'55363692','2013-10-15 02:10:15',0,'-- для 9 работает 50 минут, для 8-ми 3 минуты.\n\n-- Можете подсказать немного как можно улучшить? Я пока вижу след. варианты:\n\n-- 1) можно генировать схемы состоящие только из 9 транзисторов (если всего 9, конечно), а не из 8,7, и так далее.\n\n-- Так как случай меньшего числа транзисторов можно учесть при переборе вариантов\n\n-- 2) Проверять все схемы сразу, а не по отдельности. То есть, совместить генерацию и проверку вариантов, чтобы не считать \n\n-- некоторые значения дважды.\n\n-- 3) Отсекать заведомо неподходящие варианты, \n\n-- например если сумма всех сопротивлений меньше чем сопротивление которое хотим получить\n\n-- 4) Распараллелить проверку схем\n\n\n\nimport Data.List\n\nimport Control.Parallel.Strategies\n\n\n\ndata Circuit len = Res | SeqRes len | ParRes len | Seq [Circuit Int] | Par [Circuit Int] deriving (Eq, Show)\n\n	\n\ntoString circuit = case circuit of\n\n	Res -> \"Res\"\n\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n	Par xs -> \"Par [\"  ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n	SeqRes l -> \"SeqRes \" ++ (show l)\n\n	ParRes l -> \"ParRes \" ++ (show l)\n\n	\n\nlen circuit = case circuit of\n\n	Res-> 1\n\n	Seq xs -> sum $ map (x -> len x) xs\n\n	Par xs -> sum $ map (x -> len x) xs\n\n	SeqRes l -> l\n\n	ParRes l -> l\n\n\n\nparts\' n k = \n\n	if n == 0 then [[]]\n\n	else if k > n then [] \n\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\n\nparts n = tail $ parts\' n 1\n\n	\n\n-- 1 == Par\n\n-- 0 == Seq\n\ngenerateAllCircuits\' n op = \n\n	if n == 1 then [Res]\n\n	else if op == 0 then let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Seq c | c <- cs]) css\n\n		in concat results\n\n	else let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Par c | c <- cs]) css\n\n		in concat results\n\n\n\ngenerateAllCircuits :: Int -> [Circuit Int]\n\n--generateAllCircuits n = generateAllCircuits\' n 0 ++ generateAllCircuits\' n 1\n\ngenerateAllCircuits n = concat [generateAllCircuits\' k 0 ++ generateAllCircuits\' k 1 | k <- [1..n]]\n\n\n\nchange circuit = case circuit of\n\n	Res -> Res\n\n	Seq xs -> if all (==Res) xs then SeqRes (length xs) else Seq $ map (c -> change c) xs \n\n	Par xs -> if all (==Res) xs then ParRes (length xs) else Par $ map (c -> change c) xs\n\n\n\ntakeK\' k xs = let \n\n	l = length xs \n\n	in  if (k == 0) then [([], xs)]\n\n		else if (k == l) then [(xs, [])]\n\n		else let\n\n			(x:ys) = xs\n\n			res1 = [(x:acc1, acc2) | (acc1, acc2) <- takeK\' (k - 1) ys]\n\n			res2 = [(acc1, x:acc2) | (acc1, acc2) <- takeK\' k ys]\n\n		in res1 ++ res2\n\ntakeK k xs = takeK\' k xs\n\n\n\nzipSeq (fst, snd) (x:cs) = let \n\n	res1 = generateAllResistanses fst x\n\n	res2 = generateAllResistanses snd (Seq cs)\n\n	in [r1 + r2 | r1 <- res1, r2 <- res2]\n\n	\n\nzipPar (fst, snd) (x:cs) = let \n\n	res1 = generateAllResistanses fst x\n\n	res2 = generateAllResistanses snd (Par cs)\n\n	in [(r1 * r2)/ (r1 + r2) | r1 <- res1, r2 <- res2]	\n\n\n\ngenerateAllResistanses xs circuit = case circuit of\n\n	Res -> xs\n\n	SeqRes l -> let\n\n		ds = takeK l xs\n\n		in [sum (fst d) | d <- ds]\n\n	Seq (x:[]) -> generateAllResistanses xs x\n\n	Seq (x:cs) -> let\n\n		l = len x\n\n		ds = takeK l xs\n\n		res = map (d -> zipSeq d (x:cs)) ds\n\n		in concat res\n\n	ParRes l -> let\n\n		ds = takeK l xs\n\n		in [1 / (sum (map (1/) (fst d))) | d <- ds]\n\n	Par (x:[]) -> generateAllResistanses xs x\n\n	Par (x:cs) -> let \n\n		l = len x\n\n		ds = takeK l xs\n\n		res = map (d -> zipPar d (x:cs)) ds\n\n		in concat res\n\n\n\ncheckCircuit xs circuit res = let \n\n	allResistances = generateAllResistanses	xs circuit\n\n	in elem res allResistances\n\n		\n\ncanMakeScheme rs res = let \n\n		n = length rs\n\n		allCircuits = map (c -> change c) (generateAllCircuits n)\n\n		bs\' = map (c -> checkCircuit rs c res) allCircuits \n\n		bs = bs\' `using` parList rdeepseq\n\n		in any (id) bs\n\n	-- in do\n\n		-- putStr $ unlines (map (c -> toString c) allCircuits)\n\n		-- putStrLn $ \"\nTOTAL = \" ++ (show $ length allCircuits)\n\n		\n\nmain = print $ canMakeScheme [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 200\n','Не удалось вычислить выражение \"canMakeScheme [13,2,30,3,7] 6\", проверьте правильность синтаксиса'),(6450,65,'5543298','2013-10-15 00:07:04',1,'cantor = [(x, y) | x <- [1..], y <- [1..x]]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6449,65,'5543298','2013-10-15 00:03:37',0,'cantor = [(x, y) | x <- [1..], y <- [1..]]\r\n\n\n','Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),(6448,65,'artem.gomerman','2013-10-14 23:06:26',2,'cantor = [(i, j) | i <- [1..], j <- [1..]]\r\n  --- Нет, это не засчитано все-таки.. Ели бы вы попробуете напечатать первые 100 или 1000 \r\n  --- или 10000 элементов этого списка, то увидели бы что все они имеют вид \r\n  --- (1,i). Те уже до (2,1) дело никогда не дойдет. А надо придумать и реализовать такой\r\n  --- порядок обхода, чтобы за конечное число шагов можно было добраться до любой пары. \r\n','Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),(6447,57,'1835693','2013-10-14 18:19:44',1,'-- Функция, нумерующая элементы списка\r\n\r\n-- Каждый элемент преобразуется : x -> (id, x), где id - номер в списке\r\n\r\n-- Используется для того, чтобы брать заведомо разные элементы, даже если у них одно значение\r\n\r\nnumerate list = reverse $ numerateH 0 [] list\r\n\r\n\r\n\r\nnumerateH _  res []       = res\r\n\r\nnumerateH id res (e:list) = numerateH (id + 1) ((id, e) : res) list\r\n\r\n\r\n\r\n-- Поскольку соединение 3 и больше соединных (последовательно или параллельно - неважно)\r\n\r\n-- резисторов можно рассматривать как соединение двух - первого и соединения остальных двух,\r\n\r\n-- то используется следующий подход: выбираются всевозможные пары и \'соединяются\'.\r\n\r\n-- В итоге, из списка сопротивлений получается список всевозможных сопротивлений, если соединены ровно два\r\n\r\ncombine list = [xs | a <- numerate list, b <- numerate list, fst a < fst b,\r\n\r\n                     -- Соединение - последовательное или параллельное\r\n\r\n                     combined <- [snd a + snd b, 1 / ((1 / (snd a)) + (1 / (snd b)))],\r\n\r\n					 -- Добавление всех незадействованных резисторов\r\n\r\n                     let front = take (fst a) list,\r\n\r\n					 let middle = drop (fst a + 1) (take (fst b) list),\r\n\r\n					 let back = drop (fst b + 1) list,\r\n\r\n					 let xs = combined : front ++ middle ++ back]\r\n\r\n\r\n\r\n--canMakeScheme rs m = canMakeSchemeH False [rs] m\r\n\r\ncanMakeScheme rs m = canMakeSchemeH False [rs] m\r\n\r\n\r\n\r\n-- В функции-помощнике одним из аргументов всегда будет флаг завершеня (1 аргумент)\r\n\r\n-- 2 аргумент - это список возможных полученных комбинаций сопротивлений (через функцию combine)\r\n\r\n-- Если хоть на каком-то этапе искомое сопротивление (m) будет содержаться в первой комбинации,\r\n\r\n-- то решение найдено (все остальные резисторы, кроме тех, через которые получилось это значение,\r\n\r\n-- использовать необязательно). Иначе эта комбинация \'разворачивается\' дальше\r\n\r\ncanMakeSchemeH True _      _ = True\r\n\r\ncanMakeSchemeH _    []     _ = False\r\n\r\n--canMakeSchemeH _    (r:rs) m = canMakeSchemeH (elem m r) ((combine r) ++ rs) m\r\n\r\ncanMakeSchemeH _    (r:rs) m = canMakeSchemeH (any (x -> abs (x - m) < 10e-16) r) ((combine r) ++ rs) m\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6446,66,'1835693','2013-10-14 16:53:49',1,'generalizedCantor = generalizedCantorH 1\r\n\r\n-- Аналогия с задачей (1): 1 аргумент - максимальное значение, второй - длина подсписков\r\n-- Из всех списков, полученных через generateLists, фильтруются только те, в которых хоть раз был элемент, равный k - для того, чтобы не повторять подсписки\r\ngeneralizedCantorH k n = [ xs | xs <- generateLists n k, elem k xs ] ++ generalizedCantorH (k + 1) n\r\n\r\n-- Генерация всевозможных списков из n элементов, не превосходящих k\r\ngenerateLists 0 _ = [[]]\r\ngenerateLists n k = [ x : xs | x <- [1..k], xs <- generateLists (n - 1) k ]','<br/>Тесты успешно пройдены!'),(6445,65,'1835693','2013-10-14 16:11:44',1,'-- Предыдущий вариант неверен: с таким использованием невозможно получить (2,1), т.к. сначала будут генерироваться пары вида (1,x) - пока не кончится память :)\r\n--cantor = [(a,b) | a <- [1..], b <- [1..]]\r\n\r\ncantor = cantorH 1\r\n\r\n-- Для каждого n будем генерировать список пар, значения в которых не превосходят n\r\ncantorH n = [(n,a) | a <- [1..(n-1)]] ++ [(a,n) | a <- [1..n]] ++ cantorH (n+1)','<br/>Тесты успешно пройдены!'),(6444,65,'1835693','2013-10-14 15:02:51',0,'cantor = [(a,b) | a <- [1..], b <- [1..]]','Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),(6443,64,'1835693','2013-10-14 13:36:54',1,'-- update: Добавил значения в узлы дерева (до этого значения были только в листах)\r\ndata Tree a = Leaf a | Branch a [Tree a]\r\n\r\nfoldTree op res (Leaf a)    = op res a\r\nfoldTree op res (Branch val xs) = op val (foldl (foldTree op) res xs)\r\n\r\n-- Примеры\r\n\r\n-- 1 + 2 + 3 = 6\r\nexample_1 = foldTree (+) 0 (Branch 1 [Leaf 2, Leaf 3])\r\n-- 10 * 2 * 3 * 4 * 5 = 1200\r\nexample_2 = foldTree (*) 1 (Branch 10 [Leaf 2, Branch 5 [Leaf 4, Leaf 3]])\r\n','<br/>Тесты успешно пройдены!'),(6442,64,'1835693','2013-10-14 13:32:00',0,'data Tree a = Leaf a | Branch [Tree a]\r\n\r\nfoldTree op res (Leaf a)    = op res a\r\nfoldTree op res (Branch xs) = foldl (foldTree op) res xs\r\n\r\n-- Примеры\r\n\r\n-- 2 + 3 = 5\r\nexample_1 = foldTree (+) 0 (Branch [Leaf 2, Leaf 3])\r\n-- 2 * 3 * 4 = 24\r\nexample_2 = foldTree (*) 1 (Branch [Leaf 2, Branch [Leaf 4, Leaf 3]])','<br/>Тесты успешно пройдены!'),(6440,63,'2501950','2013-10-14 13:03:36',1,'Numb 1 = 7\r\nNumb n = Numb(n-1) *10 + 7\r\n  --- Numb надо обязательно с маленькой буквы\r\nluckyNumbers n =  ( Numb n ): luckyNumbers (n+1)\r\nxs = luckyNumbers 1\r\n  --- И тут, чтобы тесты прошли, список должен был называться luckyNumbers\r\n  --- (а рекурсивная функция - как-то иначе)\r\n  --- Но ОК, засчитано, у нас и не совсем правильные решения тоже засчитываются.\r\n','Не удалось вычислить выражение \"take 4 luckyNumbers\", проверьте правильность синтаксиса'),(6441,64,'3270666','2013-10-14 13:25:02',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n-- простая версия\r\nfoldTree _ res Empty = res\r\nfoldTree f res (Node val l r) = foldTree f (f val (foldTree f res l)) r\r\n\r\nsumTree = foldTree (+) 0\r\n-- sumTree (Node 1 \r\n--	(Node 2 \r\n--	  Empty \r\n--    Empty\r\n--  ) \r\n--  (Node 3 \r\n--	  Empty \r\n--    (Node 5 \r\n--	    Empty \r\n--      Empty\r\n--    )\r\n--  )\r\n-- ) == 11 \r\n\r\nprodTree = foldTree (*) 1\r\n-- prodTree (Node 1 \r\n--	(Node 2 \r\n--	  Empty \r\n--    Empty\r\n--  ) \r\n--  (Node 3 \r\n--	  Empty \r\n--    (Node 5 \r\n--	    Empty \r\n--      Empty\r\n--    )\r\n--  )\r\n-- ) == 30\r\n\r\n-- в этой версии у f три входных параметра.\r\n-- это не позволяет использовать стандартрые бинарные функции типа\r\n-- (+) или (*), зато позволяет очень удобно вычислять более сложные.\r\nfoldTree1 _ res Empty = res\r\nfoldTree1 f res (Node val l r) = let res_l = foldTree1 f res l\r\n                                     res_r = foldTree1 f res r\r\n                                 in f val res_l res_r\r\n\r\nsumTree1 = foldTree1 ( val l r -> val + l + r) 0\r\n-- sumTree1 (Node 1 \r\n--	(Node 2 ','<br/>Тесты успешно пройдены!'),(6438,62,'12828920','2013-10-14 11:24:07',1,'sumDiv n = sum [k | k<-[1..div n 2], mod n k == 0]\r\n\r\n\r\n\r\namicables n = let sd = [(k,l) | k<-[1..n], l<-[sumDiv k]]\r\n\r\n				in [i | i<-sd, (fst i) < (snd i), (snd i) < n, (snd i) > 1, sd!!((snd i)-1)==(snd i, fst i)] \r\n','<br/>Тесты успешно пройдены!'),(6439,63,'Valentina Guleva','2013-10-14 12:32:50',1,'luckyNumbers i = iSevens i : luckyNumbers(i + 1)\r\n\r\niSevens 1 = 7\r\n\r\niSevens i = 7 + iSevens (i - 1)*10\r\n  --- В принципе все правильно, очень хорошо.\r\n  --- Но по условию luckyNumbers дб бесконечным списков без параметров.\r\n  --- Это просто означает, что ваш luckyNumbers надо переименовать например в luckyNumbers\'\r\n  --- и потом написать luckyNumbers = luckyNumbers\' 1\r\n  --- Но ОК, это неважно, засчитано.\r\n\r\n\r\n','Не удалось вычислить выражение \"take 4 luckyNumbers\", проверьте правильность синтаксиса'),(6437,64,'nbumakov','2013-10-14 11:21:53',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node nodeValue l r) = \r\n        let\r\n          value = f e nodeValue            \r\n          valueLeft = foldTree f value l\r\n          valueRight = foldTree f valueLeft r                \r\n        in valueRight\r\n\r\ntree = Node  3 (Node 4 Empty Empty) (Node 5 Empty Empty)\r\ns = foldTree (+) 0 tree\r\ns2 = foldTree (*) 1 tree','<br/>Тесты успешно пройдены!'),(6435,62,'1170660','2013-10-14 10:20:38',1,'sumDiv n = sumDiv\' n\r\n\r\nsumDiv\' n = foldr ((a,b) temp -> temp + a + b) 0 [(x, n `div` x) | x <- [1..(truncate (sqrt (fromIntegral n)))], n `mod` x == 0] - n\r\n\r\n\r\n\r\nperfects n = [m|m<-[2..n],sumDiv m == m]\r\n\r\n\r\n\r\namicables n = [(x,y)|x<-[1..n],let y = sumDiv x ,x<y,  sumDiv y == x]\r\n','<br/>Тесты успешно пройдены!'),(6436,64,'1170660','2013-10-14 10:23:18',1,'data Tree = EmptyNode | Node Integer Tree Tree\r\n\r\nfoldTree f e EmptyNode = e\r\n\r\nfoldTree f e (Node i l r) = f i (foldTree f e l) (foldTree f e r)\r\n','<br/>Тесты успешно пройдены!'),(6434,61,'1170660','2013-10-14 10:11:34',1,'sumDiv n = sumDiv\' n\r\n\r\nsumDiv\' n = foldr ((a,b) temp -> temp + a + b) 0 [(x, n `div` x) | x <- [1..(truncate (sqrt (fromIntegral n)))], n `mod` x == 0] - n\r\n  --- Так у вас для полных квадратов будет считаться неправильно. Например, для 9 получится 1 + 3 + 3\r\n\r\n\r\nperfects n = [m|m<-[2..n],sumDiv m == m]\r\n','<br/>Тесты успешно пройдены!'),(6433,63,'1170660','2013-10-14 09:50:51',1,'luckyNumbers = createList 0\r\n\r\n\r\n\r\ncreateList n =\r\n\r\n  let\r\n\r\n    m = n * 10 + 7\r\n\r\n  in m : createList m\r\n','<br/>Тесты успешно пройдены!'),(6432,64,'2260659','2013-10-14 03:58:50',1,'data BinTree = Node Float BinTree BinTree | Null\r\n\r\nfoldTree operation neutral Null = neutral \r\n\r\nfoldTree operation neutral (Node num leftNode rightNode) = foldTree operation(operation num (foldTree operation neutral leftNode)) rightNode\r\n','<br/>Тесты успешно пройдены!'),(6431,64,'1990147','2013-10-14 03:35:50',1,'﻿{--\r\n\r\nПервый способ для своеобразных деревьев, здесь листья помечаются, поэтому идет более простое вычисление, \r\n\r\nспособ работает для сложения и умножения, к сожалению, не хватает времени додумать про (:)...\r\n\r\nПример:\r\n\r\nfoldTree (+) 0 (N 3 ( N 4 (L 7) (L 1)) (N 2 (N 1 (L 3)(L 8))(L 1)))\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = L Integer | N Integer Tree Tree\r\n\r\nfoldTree f e t = f (foldTree\' f t) e \r\n\r\nfoldTree\' f (N a ltr rtr) = f (f (foldTree\' f ltr) (foldTree\' f rtr)) a \r\n\r\nfoldTree\' f (L val)=  val\r\n\r\n\r\n\r\n{--\r\n\r\nВторой использует более привычное задание дерева, но тут нужно строго оговаривать, что \"e\" это нейтральный элемент,\r\n\r\nпоэтому этот способ нравится мне куда меньше=)\r\n\r\nНо для примеров типа:\r\n\r\nfoldTree (*) 1 (N 5 (N 1 Empty Empty) Empty)\r\n\r\nОн тоже работает\r\n\r\n\r\n\r\ndata Tree = Empty | N Integer Tree Tree\r\n\r\nfoldTree f e (N a ltr rtr) =  f a (f (foldTree f e ltr) (foldTree f e rtr))\r\n\r\nfoldTree f e (Empty)=  e\r\n\r\n--}\r\n','<br/>Тесты успешно пройдены!'),(6429,64,'MaryK','2013-10-14 03:00:16',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),div,elem,take,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ndata Tree a = Tree a [Tree a]\r\n\r\nfoldTree :: (a -> [b] -> b) -> Tree a -> b\r\n\r\nfoldTree f (Tree num s) = f num (map (foldTree f) s)\r\n\r\n\r\n\r\nfoldTree (\\_ ys -> 1+sum ys) (Tree 2[ Tree 1[],Tree 3[Tree 5[],Tree 6[]]])\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6430,63,'2260659','2013-10-14 03:24:58',1,'luck 0 = 7\r\n\r\nluck n = 7 + 10 * luck (n-1)\r\n\r\nluckyNumbers = [ luck x | x<-[0..]]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6427,63,'MaryK','2013-10-14 02:34:58',0,'','Не удалось вычислить выражение \"take 4 luckyNumbers\", проверьте правильность синтаксиса'),(6428,63,'MaryK','2013-10-14 02:35:09',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),div,elem,take,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nseven :: [Int]->Int->[Int]\r\n\r\nseven (x:xs) k = ((k+1)*7) : seven (xs) (s*10) where s = (k+1)\r\n\r\nluckyNumbers::[Int]\r\n\r\nluckyNumbers = seven [1..] 0\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6423,64,'Artur','2013-10-14 02:33:40',0,'','<br/>Тесты успешно пройдены!'),(6424,64,'Artur','2013-10-14 02:33:55',1,'data Tree = E | N Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e E = e\r\n\r\nfoldTree f e (N k l r) = foldTree f (f (foldTree f e l) k ) r \r\n\r\n\r\n\r\n-- tests\r\n\r\n--foldTree (*) 1 (N 1 (N 2 (N 3 E E) E) (N 2 E (N 3 E E)))\r\n\r\n--foldTree (+) 1 (N 1 (N 2 (N 3 E E) E) (N 2 E (N 3 E E)))\r\n','<br/>Тесты успешно пройдены!'),(6425,63,'MaryK','2013-10-14 02:34:28',0,'module Func where\r\n\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),div,elem,take,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nseven :: [Int]->Int->[Int]\r\n\nseven (x:xs) k = ((k+1)*7) : seven (xs) (s*10) where s = (k+1)\r\n\n luckyNumbers::[Int]\r\n\n luckyNumbers = seven [1..] 0\r\n\n\n','Не удалось вычислить выражение \"take 4 luckyNumbers\", проверьте правильность синтаксиса'),(6426,64,'6053606','2013-10-14 02:34:28',1,'data Tree = Empty | Node Tree Int Tree\r\n    deriving Show\r\n\r\nfoldTree f init = go init where\r\n  go acc Empty = acc\r\n  go acc (Node l x r) =\r\n    let accL = foldTree f init l\r\n        accR = foldTree f init r\r\n        acc1 = f $ Left (accL, x)\r\n        acc2 = f $ Right (acc1, accR)\r\n    in acc2\r\n\r\nheight Empty = 0\r\nheight t = foldTree f 1 t where\r\n  f (Left (acc, _x)) = acc + 1\r\n  f (Right (acc1, acc2)) = max acc1 acc2\r\n\r\nsumTree = foldTree f 0 where\r\n  f (Left (acc, x)) = acc + x\r\n  f (Right (acc1, acc2)) = acc1 + acc2\r\n\r\nsizeTree = foldTree f 0 where\r\n  f (Left (acc, x)) = acc + 1\r\n  f (Right (acc1, acc2)) = acc1 + acc2\r\n\r\nprintTree = foldTree f \"\" where\r\n  pp \"\" = \".\"\r\n  pp x  = x\r\n\r\n  f (Left (acc, x)) =\r\n    if null acc\r\n    then \". [\" ++ show x ++ \"]\"\r\n    else acc ++ \" [\" ++ show x ++ \"]\"\r\n  f (Right (acc1, acc2)) = \"(\" ++ pp acc1 ++ \" \" ++ pp acc2 ++ \")\"\r\n','<br/>Тесты успешно пройдены!'),(6421,63,'3301494','2013-10-14 02:22:03',1,'f 1 res = res\r\n\r\nf n res = f (n - 1) (res * 10 + 7)\r\n\r\nluckyNumbers = [f x 7 | x <- [1..]]\r\n','<br/>Тесты успешно пройдены!'),(6422,63,'1990147','2013-10-14 02:23:21',1,'sumDiv x = foldl (+) 0 ([t|t<-[1..(div x 2)],mod x t == 0])\r\n\r\nperfects x = [t|t<-[1..x],sumDiv t==t]\r\n\r\namicables n = [(a,b)| a<-[1..n],let b=sumDiv a,a<b, sumDiv b==a]\r\n\r\nluckyNumbers = luckyNumbers\' 7\r\n\r\nluckyNumbers\' n = n :luckyNumbers\' (n*10+7)\r\n','<br/>Тесты успешно пройдены!'),(6419,63,'3301494','2013-10-14 02:18:22',0,'f 0 res = res\r\n\nf n res = f (n - 1) (res * 10 + 7)\r\n\nluckyNumbers = [f x 1 | x <- [1..]]\n','Выражение имеет неправильное значение: take 4 luckyNumbers'),(6420,63,'3301494','2013-10-14 02:21:21',0,'f 1 res = res\r\n\nf n res = f (n - 1) (res * 10 + 7)\r\n\nluckyNumbers = [f x 1 | x <- [1..]]\n','Выражение имеет неправильное значение: take 4 luckyNumbers'),(6412,63,'Artur','2013-10-14 01:53:10',1,'list n k =k:(list(n+1) (k*10+7))\r\n --- Параметр n тут, на самом деле, не нужен, вы его нигде и не используете\r\nluckyNumbers = list 1 7 \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6413,62,'2260659','2013-10-14 01:54:50',1,'sumDiv n = sum [ x | x<-[1..(n-1)],  (n `mod` x) == 0 ]\r\n\r\namicables n = [ (x,y) | x<-[1..(n-1)], y<-[1..n], x < y,  x == (sumDiv y), y == (sumDiv x) ]\r\n','<br/>Тесты успешно пройдены!'),(6414,62,'3301494','2013-10-14 01:57:37',0,'sumDiv n = sum [x | x <- [1..(n - 1)], n `mod` x == 0]\r\n\n\r\n\nf n = filter ((y, z) -> z /= 1 && z < n && y < z) (map (x -> (x, sumDiv x))[1..(n - 1)])\r\n\n\r\n\namicables  n = [(a, b) | (a, b) <- f n, sumDiv a == b]\n','Выражение имеет неправильное значение: amicables 300'),(6415,62,'3301494','2013-10-14 02:02:43',0,'sumDiv n = sum [x | x <- [1..(n - 1)], n `mod` x == 0]\r\n\n\r\n\nf n = filter ((y, z) -> z /= 1 && z < n && y < z) (map (y -> (y, sumDiv y))[1..(n - 1)])\r\n\n\r\n\namicables  n = [(a, b) | (a, b) <- f n, sumDiv a == b]\n','Выражение имеет неправильное значение: amicables 300'),(6416,62,'3301494','2013-10-14 02:07:33',1,'sumDiv n = sum [x | x <- [1..(n - 1)], n `mod` x == 0]\r\n\r\n\r\n\r\nf n = filter ((a, b) -> b /= 1 && b < n && a < b) (map (x -> (x, sumDiv x))[1..(n - 1)])\r\n\r\n\r\n\r\namicables  n = [(x, y) | (x, y) <- f n, sumDiv y == x]\r\n','<br/>Тесты успешно пройдены!'),(6417,62,'1990147','2013-10-14 02:11:43',1,'sumDiv x = foldl (+) 0 ([t|t<-[1..(div x 2)],mod x t == 0])\r\n\r\nperfects x = [t|t<-[1..x],sumDiv t==t]\r\n\r\namicables n = [(a,b)| a<-[1..n],let b=sumDiv a,a<b, sumDiv b==a]\r\n','<br/>Тесты успешно пройдены!'),(6418,58,'55363692','2013-10-14 02:14:29',0,'-- для 9 работает 50 минут, для 8-ми 3 минуты.\n\n-- Можете подсказать немного как можно улучшить? Я пока вижу след. варианты:\n\n-- 1) можно генировать схемы состоящие только из 9 транзисторов (если всего 9, конечно), а не из 8,7, и так далее.\n\n-- Так как случай меньшего числа транзисторов можно учесть при переборе вариантов\n\n-- 2) Проверять все схемы сразу, а не по отдельности. То есть, совместить генерацию и проверку вариантов, чтобы не считать \n\n-- некоторые значения дважды.\n\n-- 3) Отсекать заведомо неподходящие варианты, \n\n-- например если сумма всех сопротивлений меньше чем сопротивление которое хотим получить\n\n-- 4) Распараллелить проверку схем\n\n\n\nimport Data.List\n\n\n\ndata Circuit len = Res | SeqRes len | ParRes len | Seq [Circuit Int] | Par [Circuit Int] deriving (Eq, Show)\n\n	\n\ntoString circuit = case circuit of\n\n	Res -> \"Res\"\n\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n	Par xs -> \"Par [\"  ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n	SeqRes l -> \"SeqRes \" ++ (show l)\n\n	ParRes l -> \"ParRes \" ++ (show l)\n\n	\n\nlen circuit = case circuit of\n\n	Res-> 1\n\n	Seq xs -> sum $ map (x -> len x) xs\n\n	Par xs -> sum $ map (x -> len x) xs\n\n	SeqRes l -> l\n\n	ParRes l -> l\n\n\n\nparts\' n k = \n\n	if n == 0 then [[]]\n\n	else if k > n then [] \n\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\n\nparts n = tail $ parts\' n 1\n\n	\n\n-- 1 == Par\n\n-- 0 == Seq\n\ngenerateAllCircuits\' n op = \n\n	if n == 1 then [Res]\n\n	else if op == 0 then let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Seq c | c <- cs]) css\n\n		in concat results\n\n	else let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Par c | c <- cs]) css\n\n		in concat results\n\n\n\ngenerateAllCircuits :: Int -> [Circuit Int]\n\n--generateAllCircuits n = generateAllCircuits\' n 0 ++ generateAllCircuits\' n 1\n\ngenerateAllCircuits n = concat [generateAllCircuits\' k 0 ++ generateAllCircuits\' k 1 | k <- [1..n]]\n\n\n\nchange circuit = case circuit of\n\n	Res -> Res\n\n	Seq xs -> if all (==Res) xs then SeqRes (length xs) else Seq $ map (c -> change c) xs \n\n	Par xs -> if all (==Res) xs then ParRes (length xs) else Par $ map (c -> change c) xs\n\n\n\ntakeK\' k xs (acc1, acc2) = \n\n	if (k == 0) then [(acc1, acc2 ++ xs)]\n\n	else let\n\n		len = length xs\n\n		(x:ys) = xs\n\n		res1 = takeK\' (k - 1) ys (x:acc1, acc2)\n\n		res2 = if len <= k then [] else takeK\' k ys (acc1, x:acc2)\n\n	in res1 ++ res2\n\ntakeK k xs = takeK\' k xs ([], [])\n\n\n\nzipSeq (fst, snd) (x:cs) = let \n\n	res1 = generateAllResistanses fst x\n\n	res2 = generateAllResistanses snd (Seq cs)\n\n	in [r1 + r2 | r1 <- res1, r2 <- res2]\n\n	\n\nzipPar (fst, snd) (x:cs) = let \n\n	res1 = generateAllResistanses fst x\n\n	res2 = generateAllResistanses snd (Par cs)\n\n	in [(r1 * r2)/ (r1 + r2) | r1 <- res1, r2 <- res2]	\n\n\n\ngenerateAllResistanses xs circuit = case circuit of\n\n	Res -> xs\n\n	SeqRes l -> let\n\n		ds = takeK l xs\n\n		in [sum (fst d) | d <- ds]\n\n	Seq (x:[]) -> generateAllResistanses xs x\n\n	Seq (x:cs) -> let\n\n		l = len x\n\n		ds = takeK l xs\n\n		res = map (d -> zipSeq d (x:cs)) ds\n\n		in concat res\n\n	ParRes l -> let\n\n		ds = takeK l xs\n\n		in [1 / (sum (map (1/) (fst d))) | d <- ds]\n\n	Par (x:[]) -> generateAllResistanses xs x\n\n	Par (x:cs) -> let \n\n		l = len x\n\n		ds = takeK l xs\n\n		res = map (d -> zipPar d (x:cs)) ds\n\n		in concat res\n\n\n\ncheckCircuit xs circuit res = let \n\n	allResistances = generateAllResistanses	xs circuit\n\n	in elem res allResistances\n\n		\n\ncanMakeScheme rs res = let \n\n		n = length rs\n\n		allCircuits = map (c -> change c) (generateAllCircuits n)\n\n		in any (c -> checkCircuit rs c res) allCircuits \n\n	-- in do\n\n		-- putStr $ unlines (map (c -> toString c) allCircuits)\n\n		-- putStrLn $ \"\nTOTAL = \" ++ (show $ length allCircuits)\n','<br/>Тесты успешно пройдены!'),(6409,62,'Artur','2013-10-14 01:44:26',1,'amicables n = [(i,j)| i <- [1..n], j <- [1..n], i < j, j == sumDiv i, i == sumDiv j]\r\n\r\n\r\n\r\nsumDiv n = sum [k| k <- [1.. n `div` 2], n `mod` k == 0]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6410,64,'1526701','2013-10-14 01:50:21',1,'--Примеры запуска\r\n--foldTree (*) 1 (Node 5 (Node 2 Empty Empty) Empty)\r\n--foldTree (+) 0 (Node 5 (Node 2 Empty (Node 4 Empty Empty)) Empty)\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree1 f z (Node val Empty Empty) =  val;\r\nfoldTree1 f z (Node val Empty r) =  f val (foldTree1 f z r);\r\nfoldTree1 f z (Node val l Empty) =  f (foldTree1 f z l) val;\r\nfoldTree1 f z (Node val l r) =  f (foldTree1 f z l) (f val (foldTree1 f z r));\r\n\r\nfoldTree f z t = f z (foldTree1 f z t);','<br/>Тесты успешно пройдены!'),(6411,61,'1990147','2013-10-14 01:51:34',1,'sumDiv x = foldl (+) 0 ([t|t<-[1..(div x 2)],mod x t == 0])\r\n\r\nperfects x = [t|t<-[1..x],sumDiv t==t]\r\n','<br/>Тесты успешно пройдены!'),(6406,61,'Artur','2013-10-14 01:40:41',0,'sumDiv n = sum [k| k <- [1.. n `div` 2], n `mod` k == 0]\r\n\n\r\n\nperfects n = [k | k <- [2..n], sumdiv k == k]\n','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6407,61,'Artur','2013-10-14 01:41:32',1,'sumDiv n = sum [k| k <- [1.. n `div` 2], n `mod` k == 0]\r\n\r\n\r\n\r\nperfects n = [k | k <- [2..n], sumDiv k == k]\r\n','<br/>Тесты успешно пройдены!'),(6408,62,'Artur','2013-10-14 01:42:55',0,'amicables n = [(i,j)| i <- [1..n], j <- [1..n], i < j, j == sumDiv i, i == sumDiv j]\r\n\n\r\n\nsumdiv n = sum [k| k <- [1.. n `div` 2], n `mod` k == 0]\r\n\n\r\n\n\n','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6402,63,'6053606','2013-10-14 01:19:40',1,'luckyNumbers = go 7 where\r\n  go acc = acc:go (acc * 10 + 7)\r\n','<br/>Тесты успешно пройдены!'),(6403,61,'3301494','2013-10-14 01:31:41',1,'sumDiv n = sum [x | x <- [1..(n - 1)], n `mod` x == 0]\r\n\r\n\r\n\r\nperfects n = [x | x <-[1..n], sumDiv x == x] \r\n','<br/>Тесты успешно пройдены!'),(6404,61,'2260659','2013-10-14 01:38:40',1,'sumDiv n = sum [ x | x<-[1..(n-1)],  (n `mod` x) == 0 ]\r\n\r\nperfects n = [ x | x<-[1..n], x == (sumDiv x) ]\r\n','<br/>Тесты успешно пройдены!'),(6405,61,'Artur','2013-10-14 01:39:57',0,'sumdiv n = sum [k| k <- [1.. n `div` 2], n `mod` k == 0]\r\n\n\r\n\nperfects n = [k | k <- [2..n], sumdiv k == k]\n','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6401,62,'6053606','2013-10-14 01:16:06',1,'sumDiv n = sum [x | x <- [1..n `div` 2], n `mod` x == 0]\r\n\r\namicables n = [ (a, sa)\r\n              | (a, sa) <- ps\r\n              , sa < n\r\n              , a < sa\r\n              , lookup sa ps == Just a\r\n              ]\r\n  where\r\n    ps = zip [1..n] $ map sumDiv [1..n]\r\n','<br/>Тесты успешно пройдены!'),(6400,62,'2501950','2013-10-14 01:12:06',1,'myDiv n = [ x |x <- [1..n], n `mod`  x == 0, x < n ]\r\nsumDiv n = sum (myDiv n)\r\n\r\namicables n = [(x,y) | x <- [1..n], y <- [1..n],\r\n x == sumDiv y, y == sumDiv x, x < y ]','<br/>Тесты успешно пройдены!'),(6399,62,'MaryK','2013-10-14 01:11:27',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ndivid x = [y|y<-[1..x], mod x y == 0]\r\n\r\nsumDiv x = sum(divid x) - x\r\n\r\namicables :: Int -> [(Int,Int)]\r\n\r\namicables k = [(n,m) |  m <- [1..k],\r\n\r\n			n <- [1..(m-1)],\r\n\r\n			sumDiv n == m,\r\n\r\n			sumDiv m == n]\r\n','<br/>Тесты успешно пройдены!'),(6393,61,'nbumakov','2013-10-14 00:56:26',1,'sumDiv n = sum (map sum [[l,div n l] | l <- [1..truncate ( sqrt (fromIntegral n))], mod n l == 0]) - n\r\n   --- Так у вас для полных квадратов будет считаться неправильно. Например, для 9 получится 1 + 3 + 3\r\nperfects n = [l | l <- [2..n], sumDiv l == l]','<br/>Тесты успешно пройдены!'),(6394,61,'2501950','2013-10-14 00:59:05',1,'myDiv n = [ x |x <- [1..n], n `mod`  x == 0, x < n ]\r\n  --- Проще убрать последнюю проверку, и написать x <- [1..n-1] (а еще лучше [1..n `div` 2]\r\nsumDiv n = sum (myDiv n)\r\nperfects n = [x |x <-[1..n], x == sum (myDiv x) ]','<br/>Тесты успешно пройдены!'),(6395,62,'nbumakov','2013-10-14 01:00:02',1,'sumDiv n = sum (map sum [[l,div n l] | l <- [1..truncate ( sqrt (fromIntegral n))], mod n l == 0]) - n\r\n\r\namicables n =  [(a, sumDiv a) | a <- [1..n], let b = sumDiv a, a == sumDiv b, a < b]','<br/>Тесты успешно пройдены!'),(6396,63,'nbumakov','2013-10-14 01:00:24',1,'luckyNumbers =  map luckyNumbers2 [1..]\r\nluckyNumbers2 1 = 7\r\nluckyNumbers2 n = 10 * luckyNumbers2 (n-1) + 7','<br/>Тесты успешно пройдены!'),(6397,61,'6053606','2013-10-14 01:03:50',1,'sumDiv n = sum [x | x <- [1..n `div` 2], n `mod` x == 0]\r\n\r\nperfects n = [x | x <- [1..n], sumDiv x == x]\r\n','<br/>Тесты успешно пройдены!'),(6398,62,'MaryK','2013-10-14 01:08:47',0,'module Func where\r\n\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\ndivid x = [y|y<-[1..x], mod x y == 0]\r\n\nsumDiv x = sum(divid x) - x\r\n\namicables :: Int -> [(Int,Int)]\r\n\namicables k = [(m,n) |  m <- [1..k],\r\n\n			n <- [1..(m-1)],\r\n\n			sumDiv m == n,\r\n\n			sumDiv n == m]\n','Выражение имеет неправильное значение: amicables 300'),(6391,61,'nbumakov','2013-10-14 00:54:49',0,'sumDiv n = sum (map sum [[l,div n l] | l <- [1..truncate ( sqrt (fromIntegral n))], mod n l == 0]) - n\r\nperfects n = [l | l <- [1..n], sumDiv l == l]','Выражение имеет неправильное значение: perfects 100'),(6392,61,'MaryK','2013-10-14 00:54:55',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),div,elem,Show(..),length,(.),foldl,($),Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nperfects n = [x|x<-[1..n],sum([y|y<-[1..(x-1)], mod x y == 0]) == x]\r\n\r\n\r\n\r\ndividers x = [y|y<-[1..x], mod x y == 0]\r\n\r\nsumDiv x = sum(dividers x) - x\r\n','<br/>Тесты успешно пройдены!'),(6389,63,'artem.gomerman','2013-10-14 00:34:35',1,'luckyNumbers = luckyNumbers\' 7\r\n\r\nluckyNumbers\' previous = previous:(luckyNumbers\' newNumber) where newNumber = 10 * previous + 7\r\n','<br/>Тесты успешно пройдены!'),(6390,63,'12828920','2013-10-14 00:49:08',1,'list n m = m:list (n+1) (m*10+7)\r\n  --- параметр n не нужен...\r\n\r\n\r\nluckyNumbers = list 1 7\r\n','<br/>Тесты успешно пройдены!'),(6386,63,'54411321','2013-10-14 00:23:22',1,'doLuckyNumbers s n = s:(doLuckyNumbers (s*10+7) (n+1))\r\n  --- параметр n на самом деле не нужен, вы же его не используете\r\n\r\n\r\nluckyNumbers = doLuckyNumbers 7 1\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6387,63,'anna','2013-10-14 00:27:44',1,'a n = let b = n * 10 + 7 in b : a b\r\n\r\nluckyNumbers = a 0\r\n\r\n     \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6388,65,'bazhutin','2013-10-14 00:32:41',1,'cantor = [ (a,b) | k<-[1..], a <-[1..k], b <- [1..k], a + b == k ]','<br/>Тесты успешно пройдены!'),(6385,62,'54411321','2013-10-14 00:22:37',1,'sumDiv n = sum [x | x <-[1..(n-1)], n `mod` x == 0]\r\n\r\n\r\n\r\namicables n = let\r\n\r\n                l = [sumDiv x | x <-[1..n]]\r\n\r\n              in [(a,b) | a <-[2..n], let b = l !! (a - 1), a < b, b <= n,\r\n\r\n                 let sb = l !! (b - 1), sb == a]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6384,61,'54411321','2013-10-14 00:22:08',1,'sumDiv n = sum [x | x <- [1..(n-1)], n `mod` x == 0]\r\n\r\n\r\n\r\nperfects n = [x | x <- [1..n], (sumDiv x) == x]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6383,65,'1526701','2013-10-14 00:19:57',1,'walk x y = if x<y then (x,y):(walk (x+1) y) else (if y == 1 then (x,y):walk 1 (x+1) else (x,y):walk x (y-1));\r\n\r\ncantor = walk 1 1;','<br/>Тесты успешно пройдены!'),(6382,57,'55363692','2013-10-14 00:19:25',1,'import Data.List\r\n\r\n\r\n\r\ndata Circuit len = Res | SeqRes len | ParRes len | Seq [Circuit Int] | Par [Circuit Int] deriving (Eq, Show)\r\n\r\n	\r\n\r\ntoString circuit = case circuit of\r\n\r\n	Res -> \"Res\"\r\n\r\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n	Par xs -> \"Par [\"  ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n	SeqRes l -> \"SeqRes \" ++ (show l)\r\n\r\n	ParRes l -> \"ParRes \" ++ (show l)\r\n\r\n	\r\n\r\nlen circuit = case circuit of\r\n\r\n	Res-> 1\r\n\r\n	Seq xs -> sum $ map (x -> len x) xs\r\n\r\n	Par xs -> sum $ map (x -> len x) xs\r\n\r\n	SeqRes l -> l\r\n\r\n	ParRes l -> l\r\n\r\n\r\n\r\nparts\' n k = \r\n\r\n	if n == 0 then [[]]\r\n\r\n	else if k > n then [] \r\n\r\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\r\n\r\nparts n = tail $ parts\' n 1\r\n\r\n	\r\n\r\n-- 1 == Par\r\n\r\n-- 0 == Seq\r\n\r\ngenerateAllCircuits\' n op = \r\n\r\n	if n == 1 then [Res]\r\n\r\n	else if op == 0 then let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Seq c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n	else let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Par c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n\r\n\r\ngenerateAllCircuits :: Int -> [Circuit Int]\r\n\r\ngenerateAllCircuits n = concat [generateAllCircuits\' k 0 ++ generateAllCircuits\' k 1 | k <- [1..n]]\r\n\r\n\r\n\r\nchange circuit = case circuit of\r\n\r\n	Res -> Res\r\n\r\n	Seq xs -> if all (==Res) xs then SeqRes (length xs) else Seq $ map (c -> change c) xs \r\n\r\n	Par xs -> if all (==Res) xs then ParRes (length xs) else Par $ map (c -> change c) xs\r\n\r\n\r\n\r\ntakeK\' k xs (acc1, acc2) = \r\n\r\n	if (k == 0) then [(acc1, acc2 ++ xs)]\r\n\r\n	else let\r\n\r\n		len = length xs\r\n\r\n		(x:ys) = xs\r\n\r\n		res1 = takeK\' (k - 1) ys (x:acc1, acc2)\r\n\r\n		res2 = if len <= k then [] else takeK\' k ys (acc1, x:acc2)\r\n\r\n	in res1 ++ res2\r\n\r\ntakeK k xs = takeK\' k xs ([], [])\r\n\r\n\r\n\r\nzipSeq l (fst, snd) (x:cs) = let \r\n\r\n	res1 = generateAllResistanses fst x\r\n\r\n	res2 = generateAllResistanses snd (Seq cs)\r\n\r\n	in [r1 + r2 | r1 <- res1, r2 <- res2]\r\n\r\n	\r\n\r\nzipPar l (fst, snd) (x:cs) = let \r\n\r\n	res1 = generateAllResistanses fst x\r\n\r\n	res2 = generateAllResistanses snd (Par cs)\r\n\r\n	in [(r1 * r2)/ (r1 + r2) | r1 <- res1, r2 <- res2]	\r\n\r\n\r\n\r\ngenerateAllResistanses xs circuit = case circuit of\r\n\r\n	Res -> xs\r\n\r\n	SeqRes l -> let\r\n\r\n		ds = takeK l xs\r\n\r\n		in [sum (fst d) | d <- ds]\r\n\r\n	Seq (x:[]) -> generateAllResistanses xs x\r\n\r\n	Seq (x:cs) -> let\r\n\r\n		l = len x\r\n\r\n		ds = takeK l xs\r\n\r\n		res = map (d -> zipSeq (l - 1) d (x:cs)) ds\r\n\r\n		in concat res\r\n\r\n	ParRes l -> let\r\n\r\n		ds = takeK l xs\r\n\r\n		in [1 / (sum (map (1/) (fst d))) | d <- ds]\r\n\r\n	Par (x:[]) -> generateAllResistanses xs x\r\n\r\n	Par (x:cs) -> let \r\n\r\n		l = len x\r\n\r\n		ds = takeK l xs\r\n\r\n		res = map (d -> zipPar (l - 1) d (x:cs)) ds\r\n\r\n		in concat res\r\n\r\n\r\n\r\ncheckCircuit xs circuit res = let \r\n\r\n	allResistances = generateAllResistanses	xs circuit\r\n\r\n	in elem res allResistances\r\n\r\n		\r\n\r\ncanMakeScheme rs res = let \r\n\r\n		n = length rs\r\n\r\n		allCircuits = map (c -> change c) (generateAllCircuits n)\r\n\r\n		in any (c -> checkCircuit rs c res) allCircuits \r\n\r\n	-- in do\r\n\r\n		-- putStr $ unlines (map (c -> toString c) allCircuits)\r\n\r\n		-- putStrLn $ \"\r\nTOTAL = \" ++ (show $ length allCircuits)\r\n','<br/>Тесты успешно пройдены!'),(6380,63,'617015','2013-10-14 00:17:07',1,'luckyNumbers = lN 7\r\n\r\nlN pr = let \r\n\r\n	newN = 10 * pr + 7 in (pr:(lN newN))\r\n','<br/>Тесты успешно пройдены!'),(6381,61,'anna','2013-10-14 00:18:26',1,'sumDiv n = sum[x | x <- [1..(n - 1)], mod n x == 0]\r\n\r\nperfects n = [x | x <- [1..n], sumDiv x == x ]','<br/>Тесты успешно пройдены!'),(6377,64,'ArtemK','2013-10-14 00:12:36',1,'data Tree = NonEmpty Double Tree Tree | Empty\r\nfoldTree _ (Empty) acc = acc\r\nfoldTree f (NonEmpty a l r) acc = f (f (foldTree f l acc) a) (foldTree f r acc)\r\n\r\n-- Примеры\r\nfoldTree (+) (NonEmpty 1 (NonEmpty 2 Empty Empty) (NonEmpty 1 Empty Empty)) 0\r\n-- 4.0\r\nfoldTree (*) (NonEmpty 1 (NonEmpty 2 Empty Empty) (NonEmpty 1 Empty Empty)) 1\r\n-- 2.0\r\n\r\n-- Пункт б не очень понял :(','<br/>Тесты успешно пройдены!'),(6378,61,'617015','2013-10-14 00:13:56',1,'sumDiv n = sum (listDiv n)\r\n\r\nlistDiv n = [ i|  i<-[1.. (n `div` 2)], n `mod` i ==0]\r\n\r\nlistSum n = [sumDiv i| i<-[1..n] ]\r\n\r\nperfects n =  let l = listSum n in [i| i<-[1..n-1], l!!(i-1)==i]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6379,62,'617015','2013-10-14 00:14:32',1,'sumDiv n = sum (listDiv n)\r\n\r\nlistDiv n = [ i|  i<-[1.. (n `div` 2)], n `mod` i ==0]\r\n\r\nlistSum n = [sumDiv i| i<-[1..n] ]\r\n  --- Вот тут у вас неправильно. Надо i<-[0..n]. Потому что операция !! начниает индексировать \r\n  --- элементы с 0, значит и вам их надо нумеровать с 0.\r\n\r\namicables n = let l = listSum n in [(i,j)|j<-[1..n-1], i<-[1..j-1],  j==l!!i, l!!j==i]\r\n\r\n\r\n\r\n\r\n','Выражение имеет неправильное значение: amicables 300'),(6372,61,'ArtemK','2013-10-13 23:46:24',1,'divs n = [x | x <- [1..div n 2], mod n x == 0]\r\nsumDiv n = sum (divs n)\r\nperfects n = [x | x <- [1..n], x == sum (divs x)]','<br/>Тесты успешно пройдены!'),(6373,62,'ArtemK','2013-10-13 23:51:56',1,'divs n = [x | x <- [1..div n 2], mod n x == 0]\r\namicables n = [(x, y) | y <- [1..n], x <- [1..y-1], sum (divs x) == y, sum (divs y) == x]\r\n','<br/>Тесты успешно пройдены!'),(6374,63,'1526701','2013-10-13 23:56:25',1,'nextSeven x = 7+10*x;\r\n\r\nllist n = nextSeven n : (llist (nextSeven n));\r\n\r\nluckyNumbers :: [Integer];\r\nluckyNumbers = llist 0;','<br/>Тесты успешно пройдены!'),(6375,63,'ArtemK','2013-10-13 23:56:42',1,'luckyNumbers = luckyNumbers\' 0\r\nluckyNumbers\' n = let next = n * 10 + 7 in next : luckyNumbers\' next','<br/>Тесты успешно пройдены!'),(6376,61,'617015','2013-10-14 00:04:23',0,'sumDiv n = sum (listDiv n)\r\n\nlistDiv n = [ i|  i<-[1.. (n `div` 2)], n `mod` i ==0]\r\n\nlistSum n = [sumDiv i| i<-[1..n] ]\r\n\nperfect n =  let l = listSum n in [i| i<-[1..n-1], l!!i-1==i]\r\n\n\r\n\n\n','Не удалось вычислить выражение \"perfects 100\", проверьте правильность синтаксиса'),(6369,56,'bazhutin','2013-10-13 23:18:42',1,'allLists n 1 = [ [x] | x <- [1..n]]\r\nallLists n k = [ x:xs |  x <- [1..n], xs <- allLists n (k-1)]\r\n \r\n\r\n','<br/>Тесты успешно пройдены!'),(6370,62,'1526701','2013-10-13 23:33:26',1,'dlist n = [x | x<-[1..(n `div` 2)], n `mod` x == 0];\r\n\r\nsumList l = foldl (+) 0 l\r\n\r\nsumDiv n = sumList (dlist n);\r\n\r\namicables n = [(x,y) | x<-[1..n], y <- [sumDiv x], x < y, x == sumDiv y];','<br/>Тесты успешно пройдены!'),(6371,62,'1526701','2013-10-13 23:45:02',1,'dlist n = [x | x<-[1..(n `div` 2)], n `mod` x == 0];\r\n\r\nsumList l = foldl (+) 0 l\r\n\r\nsumDiv n = sumList (dlist n);\r\n\r\namicables n = [(x,y) | x<-[1..n], y <- [sumDiv x], y <= n, x < y, x == sumDiv y];','<br/>Тесты успешно пройдены!'),(6365,56,'1526701','2013-10-13 22:50:56',1,'allLists n 0 = [[]];\r\nallLists n k = [x:xs | x<-[1..n], xs<-allLists n (k-1)];','<br/>Тесты успешно пройдены!'),(6366,64,'bazhutin','2013-10-13 22:52:43',1,'data Tree = Node Integer Tree Tree \r\n		|Null \r\n\r\nfoldTree op n Null = n\r\nfoldTree op n (Node i left right) = foldTree op (op i (foldTree op n left)) right\r\n\r\n\r\n--foldTree (+) 1 (Node 1 (Node 2 (Node 3 Null Null) (Null)) (Node 4 Null Null))\r\n\r\n--foldTree (*) 1 (Node 1 (Node 2 (Node 3 Null Null) (Null)) (Node 4 Null Null))\r\n','<br/>Тесты успешно пройдены!'),(6367,62,'4604056','2013-10-13 23:08:40',1,'getDiv n = filter ( i -> ((mod n i) == 0)) [1..(n-1)]\r\n\r\nsumDiv n = sum (getDiv n)\r\n\r\n--list n = [(x,y)|x<-[1..n], y<-[1..n], x<y]\r\n\r\n--amicables n = filter ((a,b) -> (a == sumDiv b)&&(b == sumDiv a)) (list n)\r\n\r\namicables n = [(x, sumDiv x)|x<-[1..n], sumDiv(sumDiv x) == x, sumDiv x > x]','<br/>Тесты успешно пройдены!'),(6368,61,'1526701','2013-10-13 23:11:21',1,'dlist n = [x | x<-[1..n-1], n `mod` x == 0];\r\n\r\nsumList l = foldl (+) 0 l\r\n\r\nsumDiv n = sumList (dlist n);\r\n\r\nperfects n = [x | x<-[1..n], x == sumDiv x];','<br/>Тесты успешно пройдены!'),(6364,61,'4604056','2013-10-13 22:48:58',1,'getDiv n = filter ( i -> ((mod n i) == 0)) [1..(n-1)]\r\n\r\nsumDiv n = sum (getDiv n)\r\n\r\nperfects n = filter (i -> ((sumDiv i) == i)) [1..n]','<br/>Тесты успешно пройдены!'),(6361,65,'3320654','2013-10-13 22:35:12',1,'cantor = help 2\r\n\r\nhelp n = [(x, y) | x <- [1..(n - 1)], y <- [1..(n - 1)], x + y == n] ++ help (n + 1)','<br/>Тесты успешно пройдены!'),(6362,66,'toskira','2013-10-13 22:45:54',1,'generalizedCantor n = foldr (++) [] [list| x <- [1..], let list = filter (any (==x)) (cube n x)]                                                                                            \r\n                                                                                              \r\ncube 0 _ = [[]]\r\ncube k n = [(a:b) | a <- [1..n], b <- (cube (k-1) n)]','<br/>Тесты успешно пройдены!'),(6363,61,'12828920','2013-10-13 22:48:37',1,'sumDiv n = sum [k | k<-[1..div n 2], mod n k == 0]\r\n\r\n\r\n\r\nperfects n = [k | k<-[1..n], sumDiv k == k]\r\n','<br/>Тесты успешно пройдены!'),(6359,63,'4604056','2013-10-13 22:32:47',1,'getLuckyNumber 1 = 7\r\ngetLuckyNumber n = (getLuckyNumber (n-1))*10+7\r\n\r\n\r\nluckyNumbers = map getLuckyNumber [1..]','<br/>Тесты успешно пройдены!'),(6360,68,'5543298','2013-10-13 22:33:25',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"17.1\":\r\n\r\n                    {\r\n\r\n                        var test = new[] { 563, 5643, 76796 };\r\n\r\n                        var resArray = zeroDigits(test, 2);\r\n\r\n                        var result = resArray.Select(item => item.ToString()).ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next) =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static int[] zeroDigits(int[] test, int n)\r\n\r\n        {\r\n\r\n            var power = (int)Math.Pow(10, n);\r\n\r\n            return test.Select(item => (item / power) * power).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6356,65,'toskira','2013-10-13 22:22:07',1,'cantor = [if offset > s then (2*s-offset, s) else (s, offset) | x <- [1..], let s = (ceiling.sqrt.fromIntegral) x, let offset = s*s-x+1]','<br/>Тесты успешно пройдены!'),(6357,59,'55363692','2013-10-13 22:26:16',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static IEnumerable<int> NonZeroLastDigits(IEnumerable<int> array)\r\n\r\n        {\r\n\r\n            return array.Select(x => x%10).Where(x => x > 0);\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(String.Join(\", \", NonZeroLastDigits(new[] { 354, 20, 9, 31 }).ToArray()));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6358,61,'artem.gomerman','2013-10-13 22:29:52',1,'sumDiv n = sum[x | x <- [1.. (div n 2)], mod n x == 0]\r\n\r\n\r\n\r\nperfects n = let \r\n\r\n	xs = [x | x <- ( generateCubicsSums n), x == (sumDiv x)] in if n > 6 then (6:xs) else xs\r\n\r\n	\r\n\r\n-- если первое решение не годится\r\n\r\nperfects\' n = [x | x <- [1..n], x == (sumDiv x)]\r\n\r\n\r\n\r\ngenerateCubicsSums maxValue = filter even (generateCubicsSums\' maxValue 0 1 [])\r\n\r\ngenerateCubicsSums\' maxValue currentSum currentIndex xs = let\r\n\r\n	newSum = currentIndex^3 + currentSum in if maxValue < newSum then xs else (newSum:(generateCubicsSums\' maxValue newSum (currentIndex + 2) xs))\r\n','<br/>Тесты успешно пройдены!'),(6355,44,'517309','2013-10-13 22:09:51',3,'import Debug.Trace\r\n\r\n\r\n\r\ndioph [0,0,0,0] [0,0,0,0] = (1,1,1)\r\n\r\ndioph [0,0,0,l] [0,0,0,m] = trace (show \"no integer solution\") (-11,-11,-11)\r\n\r\n\r\n\r\ndioph [a,b,c,d] [k,l,m,n] = let \r\n\r\n								det1 = a*l - b*k\r\n\r\n								det2 = a*m - c*k\r\n\r\n								det3 = b*m - c*l\r\n\r\n							in if det1 /= 0 then f [a,b,c,d] [k,l,m,n]\r\n\r\n								else if det2 /= 0 then ((x,z,y) -> (x,y,z)) (f [a,c,b,d] [k,m,l,n])\r\n\r\n									else if det3 /= 0 then ((y,z,x) -> (x,y,z)) (f [b,c,a,d] [l,m,k,n])\r\n\r\n										else g1 [a,b,c,d] (-2^16) (-2^16)\r\n\r\n\r\n\r\npr [x,y,z,d] k = map (i -> i*k) [x,y,z,d]\r\n\r\n										\r\n\r\nf [a,0,c,d] [0,l,m,n] = if( c == 0 && m == 0 ) then (div d a, div n l, 1)\r\n\r\n						else if c == 0 then (div d a, x1, y1) \r\n\r\n							else if d == 0 then (x2, div n l, y2)\r\n\r\n								else g2 [a,0,c,d] [0,l,m,n] (-2^16)\r\n\r\n						where \r\n\r\n							[x1,y1] = h [l,m,n] (-2^16)\r\n\r\n							[x2,y2] = h [a,c,d] (-2^16)\r\n\r\n							\r\n\r\n\r\n\r\nf [a,b,c,d] [0,l,m,n] = let\r\n\r\n							lc = lcm b l \r\n\r\n							multb = div lc b\r\n\r\n							multl = div lc l\r\n\r\n							[x1,x2,x3,x4] = pr [a,b,c,d] multb\r\n\r\n							[y1,y2,y3,y4] = pr [0,l,m,n] multl\r\n\r\n						in f [x1-y1,x2-y2,x3-y3,x4-y4] [y1,y2,y3,y4]\r\n\r\n\r\n\r\nf [a,b,c,d] [k,l,m,n] = let \r\n\r\n							lc = lcm a k\r\n\r\n							multa = div lc a\r\n\r\n							multk = div lc k\r\n\r\n							[x1,x2,x3,x4] = pr [a,b,c,d] multa\r\n\r\n							[y1,y2,y3,y4] = pr [k,l,m,n] multk\r\n\r\n						in  f [x1,x2,x3,x4] [y1-x1,y2-x2,y3-x3,y4-x4]\r\n\r\n\r\n\r\n\r\n\r\nh [a,c,d] k = if k > 2^16 || (mod (d - c*k) a == 0) then [div (d - c*k) a,k]\r\n\r\n				else h [a,c,d] (k+1) \r\n\r\n						\r\n\r\ng1 [a,b,c,d] i j = if j > 2^16  then g1 [a,b,c,d] (i+1) 0\r\n\r\n					else if i > 2^16 || (mod (d - b*i - c*j) a == 0 )then (div (d - b*i - c*j) a , i, j)\r\n\r\n							else g1 [a,b,c,d] i (j+1)\r\n\r\n\r\n\r\ng2 [a,0,c,d] [0,l,m,n] k = if k > 2^16 || (mod (d - c*k) a == 0 && (mod (n - m*k) l == 0) ) \r\n\r\n							then (div (d - c*k) a, div (n - m*k) l, k)\r\n\r\n							 else g2 [a,0,c,d] [0,l,m,n] (k+1)\r\n\r\n\r\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(6353,63,'480387','2013-10-13 22:00:23',1,'luckyNumbers = let ns = [1..] in [if (n/=1) then (10*luckyNumbers!!(n-2) + 7) else 7| n<-ns]','<br/>Тесты успешно пройдены!'),(6354,64,'55363692','2013-10-13 22:07:47',1,'data Tree a = Empty | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\nfoldTree f e tree = case tree of \r\n\r\n	Empty -> e\r\n\r\n	Node a left right -> let\r\n\r\n		resLeft = foldTree f e left\r\n\r\n		resRight = foldTree f e right\r\n\r\n		in f a (f resLeft resRight)\r\n\r\n		\r\n\r\nmain = let\r\n\r\n	tree = Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)\r\n\r\n	in do \r\n\r\n		putStrLn $ \"foldTree (+) 0 tree = \" ++ (show $ foldTree (+) 0 tree) \r\n\r\n		putStrLn $ \"foldTree (*) 1 tree = \" ++ (show $ foldTree (*) 1 tree)\r\n','<br/>Тесты успешно пройдены!'),(6351,62,'480387','2013-10-13 21:39:58',1,'sumDiv n = foldr (+) 0 [x | x<-[1..div n 2], n `mod` x == 0]\r\namicables n = [(x,y) | x<-[1..n], y<-[1..n], x < y, x == sumDiv y, y == sumDiv x]\r\n','<br/>Тесты успешно пройдены!'),(6352,64,'toskira','2013-10-13 21:58:11',1,'data Tree a = Empty |\r\n              Node a (Tree a) (Tree a)\r\n\r\nfoldTree _ e Empty = e\r\nfoldTree f e (Node v l r) = let a = foldTree f e r\r\n                                b = f v a\r\n                                c = foldTree f b l\r\n                            in c','<br/>Тесты успешно пройдены!'),(6348,62,'ip','2013-10-13 21:29:27',0,'amicables n = [(a,b)| \r\na<-[1..n],\r\nb<-[1..n],(a<b),(sumDiv a)==b),(sumDiv b)==a ]\r\n','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6349,62,'ip','2013-10-13 21:30:20',1,'amicables n = [(a,b)| \r\n a<-[1..n],\r\n b<-[1..n],(a<b),(sumDiv a)==b),(sumDiv b)==a ]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n \r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n   --- Тут тоже не хватает обратных кавычек\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6350,61,'ip','2013-10-13 21:31:14',1,'perfects n = p n []\r\n\r\np n xs = if (sumDiv n)==n\r\n         then p (n-1) (n:xs)\r\n         else p (n-1) xs\r\n   --- Тут должно быть еще не рекурсивное правило.\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n   --- тут надо x `mod` n или mod x n\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6347,62,'ip','2013-10-13 21:28:45',0,'-- amicables n = [(a,b)| \r\n-- a<-[1..n],\r\n-- b<-[1..n],(a<b),(sumDiv a)==b),(sumDiv b)==a ]\r\n\r\n\r\n-- sumDiv n = s n (n-1) 0\r\n-- \r\n-- s x 0 xs = xs\r\n-- s x n xs = if ((x mod n)==0)\r\n--            then (s x (n-1) (n+xs))\r\n--            else (s x (n-1) xs)','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6339,63,'ip','2013-10-13 21:17:09',1,'luck 1 = [7]\r\n     --- Здесь бд просто 7, тогда бы все скомпилировалось\r\nluck n = (luck (n-1))*10 + 7\r\n    \r\nluckyNumbers = map luck [1..]','Не удалось вычислить выражение \"take 4 luckyNumbers\", проверьте правильность синтаксиса'),(6340,62,'ip','2013-10-13 21:21:50',0,'amicables n = [(a,b)| \r\n a<-[1..n],\r\n b<-[1..n], \r\n a<b,(sumDiv a)==b,(sumDiv b)==a ]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6341,61,'ip','2013-10-13 21:22:37',0,'amicables n = [(a,b)| \r\n a<-[1..n],\r\n b<-[1..n], \r\n (a<b),\r\n (sumDiv a)==b,\r\n (sumDiv b)==a ]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6342,62,'ip','2013-10-13 21:23:56',0,'// amicables n = [(a,b)| \r\n// a<-[1..n],\r\n// b<-[1..n], \r\n// (a<b),\r\n// (sumDiv a)==b,\r\n// (sumDiv b)==a ]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6343,62,'ip','2013-10-13 21:24:30',0,'amicables n = [(a,b)| \r\n a<-[1..n],\r\n b<-[1..n], \r\n (a<b),\r\n (sumDiv a)==b,\r\n (sumDiv b)==a ]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6344,62,'ip','2013-10-13 21:26:11',0,'amicables n = [(a,b)| \r\n a<-[1..n],\r\n b<-[1..n],(a<b),(sumDiv a)==b),(sumDiv b)==a ]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6345,62,'ip','2013-10-13 21:27:47',0,'-- amicables n = [(a,b)| \r\n-- a<-[1..n],\r\n-- b<-[1..n],(a<b),(sumDiv a)==b),(sumDiv b)==a ]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6346,61,'480387','2013-10-13 21:27:54',1,'sumDiv n = foldr (+) 0 [x | x<-[1..div n 2], n `mod` x == 0]\r\nperfects n = [x | x<-[1..n], sumDiv x  == x]','<br/>Тесты успешно пройдены!'),(6338,62,'ip','2013-10-13 21:14:10',0,'amicables n = [(a,b)| a<-[1..n], b<-[1..n], a<b,(sumDiv a)==b,(sumDiv b)==a ]\r\n\n\r\n\n\r\n\nsumDiv n = s n (n-1) 0\r\n\n\r\n\ns x 0 xs = xs\r\n\ns x n xs = if ((x mod n)==0)\r\n\n           then (s x (n-1) (n+xs))\r\n\n           else (s x (n-1) xs)\n','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6337,62,'ip','2013-10-13 21:10:54',0,'gflgk\r\namicables n = [(a,b)| a<-[1..n], b<-[1..n], a<b,(sumDiv a)==b,(sumDiv b)==a]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)\r\n','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6335,62,'ip','2013-10-13 21:08:33',0,'amicables n = [(a,b)| a<-[1..n], b<-[1..n], a<b,                      \r\n              (sumDiv a)==b,(sumDiv b)==a]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)\r\n\r\n','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6336,62,'ip','2013-10-13 21:09:44',0,'amicables n = [(a,b)| a<-[1..n], b<-[1..n], a<b,(sumDiv a)==b,(sumDiv b)==a]\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)\r\n','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6333,61,'ip','2013-10-13 20:58:19',0,'sumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n) == 0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6334,61,'ip','2013-10-13 21:01:55',0,'perfects n = p n []\r\n\r\np n xs = if (sumDiv n)==n\r\n         then p (n-1) (n:xs)\r\n         else p (n-1) xs\r\n\r\n\r\nsumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n)==0)\r\n           then (s x (n-1) (n+xs))\r\n           else (s x (n-1) xs)','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6332,61,'ip','2013-10-13 20:57:54',0,'sumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if ((x mod n) == 0)\r\n           then s x (n-1) (n+xs)\r\n           else s x (n-1) xs','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6330,63,'55363692','2013-10-13 20:55:57',1,'luckyNumbers\' n = let cur = (n * 10 + 7) in cur : luckyNumbers\' cur\r\n\r\n\r\n\r\nluckyNumbers = luckyNumbers\' 0\r\n','<br/>Тесты успешно пройдены!'),(6331,61,'ip','2013-10-13 20:56:57',0,'sumDiv n = s n (n-1) 0\r\n\r\ns x 0 xs = xs\r\ns x n xs = if (x mod n) == 0\r\n           then s x (n-1) (n+xs)\r\n           else s x (n-1) xs','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6329,64,'ip','2013-10-13 20:53:23',1,'Считаем что дерево пронумеровано последовательностью 0 и 1. 0 вершин,левый потомок обозначим 1 а правый 0.\r\nТ.е если дерево это корень с двумя потомками то левый имеет индекс [0,0] ,а правый [1,0].\r\n\r\nФункция f теперь от 3 переменных где k это индекс рассматриваемого элемента в дереве.\r\n\r\n   --- ОК, засчитано, но мне кажется в данном случае это сложновато. Но зато интересно)\r\n\r\nПример f для нахождения высоты:\r\nf x _ k = let a = f2 -1 k\r\n          in if a>x\r\n             then a\r\n             else x\r\nf2 x [] = x\r\nf2 x y:k = f2 (x+1) k\r\n\r\n\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f x Empty = fT f x t []\r\nfoldTree f x t = fT f x t [0]\r\n\r\nfT f x Empty _ = x\r\nfT f x (Node i t1 t2) xs = fT\r\n   f \r\n   (Ft f (f x i k) t1 (0:xs))\r\n   t2\r\n   (1:xs)','<br/>Тесты успешно пройдены!'),(6327,61,'55363692','2013-10-13 20:38:23',1,'sumDiv\' n cur acc = \r\n\r\n	if (cur * cur > n) then acc \r\n\r\n	else \r\n\r\n		let t = if n `mod` cur == 0 then cur + (n `div` cur) else 0\r\n\r\n		in sumDiv\' n (cur + 1) (acc + t)\r\n\r\n\r\n\r\nsumDiv 1 = 0\r\n\r\nsumDiv n = sumDiv\' n 2 1\r\n\r\n\r\n\r\nperfects n = filter (x -> x == sumDiv x) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(6328,62,'55363692','2013-10-13 20:50:05',1,'import Data.Array\r\n\r\n\r\n\r\nsumDiv\' n cur acc = \r\n\r\n	if (cur * cur > n) then acc \r\n\r\n	else \r\n\r\n		let t = if n `mod` cur == 0 then cur + (n `div` cur) else 0\r\n\r\n		in sumDiv\' n (cur + 1) (acc + t)\r\n   --- Так у вас, кстати, неправильно считает, если число - полный квадрат. Например, для 9 получается 7, а не 4\r\n   --- Так что мб даже у вас и образуются \"ложные\" дружественные числа, но тестов таких у меня нет:)\r\n\r\n\r\nsumDiv 1 = 0\r\n\r\nsumDiv n = sumDiv\' n 2 1\r\n\r\n\r\n\r\namicables n = let \r\n\r\n	arraySumDiv = array (1, n) [(i, sumDiv i) | i <- [1..n]]\r\n\r\n	check x y = x == (arraySumDiv ! y) && y == (arraySumDiv ! x)\r\n\r\n	in [(x, y) | x <- [1..n], y <- [1..n], x < y, check x y]\r\n','<br/>Тесты успешно пройдены!'),(6326,62,'anna','2013-10-13 20:12:46',1,'sumDiv n = sum[x | x <- [1..(n - 1)], mod n x == 0]\r\n\r\n\r\n\r\namicables n = [(x, y) | x <- [1..n], let y = sumDiv x, x < y, sumDiv y == x]\r\n','<br/>Тесты успешно пройдены!'),(6325,61,'anna','2013-10-13 20:11:38',0,'sumDiv n = sum[x | x <- [1..(n - 1)], mod n x == 0]\r\n\n\r\n\namicables n = [(x, y) | x <- [1..n], let y = sumDiv x, x < y, sumDiv y == x]\n','Не удалось вычислить выражение \"perfects 100\", проверьте правильность синтаксиса'),(6324,61,'anna','2013-10-13 20:02:59',0,'sumDiv n = sum[x | x <- [1..(n - 1)], mod n x == 0]\r\n\nperfects n = [x | x <- [1..n], sumDiv x == x ]\n','<br/>Тесты успешно пройдены!'),(6323,61,'anna','2013-10-13 20:01:37',0,'sumDiv n = sum[x | x <- [1..(n - 1)], mod n x == 0]\r\n\nperfects n = [x | x <- [1..n], divisors x == x ]\n','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6322,63,'bazhutin','2013-10-13 20:00:28',1,'number n  \r\n	| n == 0 = 7\r\n	| otherwise = 7 * 10 ^ n + number (n - 1)\r\nluckyNumbers  = [number x | x <- [0..] ]\r\n ','<br/>Тесты успешно пройдены!'),(6321,61,'anna','2013-10-13 20:00:18',0,'divisors n = sum[x | x <- [1..(n - 1)], mod n x == 0]\r\n\nperfects n = [x | x <- [1..n], divisors x == x ]\n','Не удалось вычислить выражение \"sumDiv 10\", проверьте правильность синтаксиса'),(6319,61,'bazhutin','2013-10-13 19:34:24',1,'sumDiv n = 1 + sum [ k + m | k <- [2..sq],\r\n                                   n `mod` k == 0,\r\n                                   let t = n `div` k\r\n                                       m = if t /= k then t else 0 ] where\r\n    sq = floor . sqrt . fromIntegral $ n\r\n\r\nperfects n = [ k | k <- [2..n], k == sumDiv k]','<br/>Тесты успешно пройдены!'),(6320,62,'bazhutin','2013-10-13 19:39:20',1,'sumDiv n = 1 + sum [ k + m | k <- [2..sq],\r\n                                   n `mod` k == 0,\r\n                                   let t = n `div` k\r\n                                       m = if t /= k then t else 0 ] where\r\n    sq = floor . sqrt . fromIntegral $ n\r\n\r\namicables n = [(x,y) | x <- [2..n], y <- [2..n], x < y, x == sumDiv y, y == sumDiv x]','<br/>Тесты успешно пройдены!'),(6318,57,'55363692','2013-10-13 19:11:41',0,'import Data.List\n\n\n\ndata Circuit = Res | Seq [Circuit] | Par [Circuit] deriving Show\n\n\n\nlen c = case c of \n\n	Res -> 1 \n\n	Seq cs -> sum $ map len cs\n\n	Par cs -> sum $ map len cs\n\n	\n\ntoString circuit = case circuit of\n\n	Res -> \"Res\"\n\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n	Par xs -> \"Par [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n\n\nparts\' n k = \n\n	if n == 0 then [[]]\n\n	else if k > n then [] \n\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\n\nparts n = tail (parts\' n 1)	\n\n	\n\n-- 1 == Par\n\n-- 0 == Seq\n\ngenerateAllCircuits\' n op = \n\n	if n == 1 then [Res]\n\n	else if op == 0 then let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Seq c | c <- cs]) css\n\n		in concat results\n\n	else let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Par c | c <- cs]) css\n\n		in concat results\n\n\n\ngenerateAllCircuits :: Int -> [Circuit]\n\ngenerateAllCircuits n = concat [generateAllCircuits\' k 0 ++ generateAllCircuits\' k 1 | k <- [1..n]]\n\n\n\ntakeK\' k xs (acc1, acc2) = \n\n	if (k == 0) then [(acc1, acc2 ++ xs)]\n\n	else let\n\n		len = length xs\n\n		(x:ys) = xs\n\n		res1 = takeK\' (k - 1) ys (x:acc1, acc2)\n\n		res2 = if len <= k then [] else takeK\' k ys (acc1, x:acc2)\n\n	in res1 ++ res2\n\ntakeK k xs = takeK\' k xs ([], [])\n\n\n\nzipSeq (fst, snd) (x:cs) = let \n\n	res1 = generateAllResistanses fst x\n\n	res2 = generateAllResistanses snd (Seq cs)\n\n	in [r1 + r2 | r1 <- res1, r2 <- res2]\n\n	\n\nzipPar (fst, snd) (x:cs) = let \n\n	res1 = generateAllResistanses fst x\n\n	res2 = generateAllResistanses snd (Par cs)\n\n	in [(r1 * r2)/ (r1 + r2) | r1 <- res1, r2 <- res2]	\n\n\n\ngenerateAllResistanses xs circuit = case circuit of\n\n	Res -> xs\n\n	Seq (x:[]) -> generateAllResistanses xs x\n\n	Seq (x:cs) -> let \n\n		l = len x \n\n		ds = takeK l xs\n\n		res = map (d -> zipSeq d (x:cs)) ds\n\n		in concat res\n\n	Par (x:[]) -> generateAllResistanses xs x\n\n	Par (x:cs) -> let \n\n		l = len x \n\n		ds = takeK l xs\n\n		res = map (d -> zipPar d (x:cs)) ds\n\n		in concat res\n\n\n\ncheckCircuit xs circuit res = let \n\n	allResistances = generateAllResistanses	xs circuit\n\n	in elem res allResistances\n\n		\n\ncanMakeScheme rs res = let \n\n		n = length rs\n\n		allCircuits = generateAllCircuits n\n\n		in any (c -> checkCircuit rs c res) allCircuits \n\n	--do\n\n		--putStr $ unlines (map (c -> toString c) allCircuits)\n\n		--putStrLn $ \"\nTOTAL = \" ++ (show $ length allCircuits)\n','<br/>Тесты успешно пройдены!'),(6316,56,'anna','2013-10-13 18:46:59',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(6317,131,'55363692','2013-10-13 19:10:21',1,'import Data.List\r\n\r\n\r\n\r\ndata Circuit = Res | Seq [Circuit] | Par [Circuit] deriving Show\r\n\r\n\r\n\r\nlen c = case c of \r\n\r\n	Res -> 1 \r\n\r\n	Seq cs -> sum $ map len cs\r\n\r\n	Par cs -> sum $ map len cs\r\n\r\n	\r\n\r\ntoString circuit = case circuit of\r\n\r\n	Res -> \"Res\"\r\n\r\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n	Par xs -> \"Par [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n\r\n\r\nparts\' n k = \r\n\r\n	if n == 0 then [[]]\r\n\r\n	else if k > n then [] \r\n\r\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\r\n\r\nparts n = tail (parts\' n 1)	\r\n\r\n	\r\n\r\n-- 1 == Par\r\n\r\n-- 0 == Seq\r\n\r\ngenerateAllCircuits\' n op = \r\n\r\n	if n == 1 then [Res]\r\n\r\n	else if op == 0 then let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Seq c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n	else let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Par c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n\r\n\r\ngenerateAllCircuits :: Int -> [Circuit]\r\n\r\ngenerateAllCircuits n = concat [generateAllCircuits\' k 0 ++ generateAllCircuits\' k 1 | k <- [1..n]]\r\n\r\n\r\n\r\ntakeK\' k xs (acc1, acc2) = \r\n\r\n	if (k == 0) then [(acc1, acc2 ++ xs)]\r\n\r\n	else let\r\n\r\n		len = length xs\r\n\r\n		(x:ys) = xs\r\n\r\n		res1 = takeK\' (k - 1) ys (x:acc1, acc2)\r\n\r\n		res2 = if len <= k then [] else takeK\' k ys (acc1, x:acc2)\r\n\r\n	in res1 ++ res2\r\n\r\ntakeK k xs = takeK\' k xs ([], [])\r\n\r\n\r\n\r\nzipSeq (fst, snd) (x:cs) = let \r\n\r\n	res1 = generateAllResistanses fst x\r\n\r\n	res2 = generateAllResistanses snd (Seq cs)\r\n\r\n	in [r1 + r2 | r1 <- res1, r2 <- res2]\r\n\r\n	\r\n\r\nzipPar (fst, snd) (x:cs) = let \r\n\r\n	res1 = generateAllResistanses fst x\r\n\r\n	res2 = generateAllResistanses snd (Par cs)\r\n\r\n	in [(r1 * r2)/ (r1 + r2) | r1 <- res1, r2 <- res2]	\r\n\r\n\r\n\r\ngenerateAllResistanses xs circuit = case circuit of\r\n\r\n	Res -> xs\r\n\r\n	Seq (x:[]) -> generateAllResistanses xs x\r\n\r\n	Seq (x:cs) -> let \r\n\r\n		l = len x \r\n\r\n		ds = takeK l xs\r\n\r\n		res = map (d -> zipSeq d (x:cs)) ds\r\n\r\n		in concat res\r\n\r\n	Par (x:[]) -> generateAllResistanses xs x\r\n\r\n	Par (x:cs) -> let \r\n\r\n		l = len x \r\n\r\n		ds = takeK l xs\r\n\r\n		res = map (d -> zipPar d (x:cs)) ds\r\n\r\n		in concat res\r\n\r\n\r\n\r\ncheckCircuit xs circuit res = let \r\n\r\n	allResistances = generateAllResistanses	xs circuit\r\n\r\n	in elem res allResistances\r\n\r\n		\r\n\r\ncanMakeScheme rs res = let \r\n\r\n		n = length rs\r\n\r\n		allCircuits = generateAllCircuits n\r\n\r\n		in any (c -> checkCircuit rs c res) allCircuits \r\n\r\n	--do\r\n\r\n		--putStr $ unlines (map (c -> toString c) allCircuits)\r\n\r\n		--putStrLn $ \"\r\nTOTAL = \" ++ (show $ length allCircuits)\r\n','<br/>Тесты успешно пройдены!'),(6313,62,'284427','2013-10-13 16:35:47',1,'sumDiv n = let m = (abs n) in\r\n\r\n			if m <= 1 then 0\r\n\r\n			else foldr (+) 1 [x | x <-[2..(div m 2)], (mod m x) == 0]\r\n\r\n			\r\n\r\namicables n = [(x,y) | x <- [1..n], let y = (sumDiv x), x == (sumDiv y), x < y]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6314,63,'284427','2013-10-13 16:49:30',1,'luckyNumbers = list 7\r\n\r\n\r\n\r\nlist n = n:list (n*10+7)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6315,64,'284427','2013-10-13 17:02:58',1,'data Tree = Empty | Node Double Tree Tree\r\n\r\n\r\n\r\nfoldTree func start Empty = start\r\n\r\nfoldTree func start (Node d left right) = foldTree func (foldTree func (start `func` d) left)  right\r\n\r\n\r\n\r\n--foldTree (+) 0 (Node 10 (Node 7 (Node 5 Empty Empty) (Node 9.5 Empty Empty)) (Node 15.25 Empty (Node 20.25 Empty Empty)))\r\n\r\n--foldTree (*) 1 (Node 10 (Node 5 (Node 0.1 Empty Empty) Empty) (Node 11.1 Empty Empty))\r\n','<br/>Тесты успешно пройдены!'),(6311,61,'284427','2013-10-13 16:20:21',1,'sumDiv n = let m = (abs n) in\r\n\r\n			if m <= 1 then 0\r\n\r\n			else foldr (+) 1 [x | x <-[2..(div m 2)], (mod m x) == 0]\r\n\r\nperfects n = [x | x <- [1..(abs n)], x == (sumDiv x), x > 1]\r\n','<br/>Тесты успешно пройдены!'),(6312,62,'284427','2013-10-13 16:31:27',0,'sumDiv n = let m = (abs n) in\r\n\n			if m <= 1 then 0\r\n\n			else foldr (+) 1 [x | x <-[2..(div m 2)], (mod m x) == 0]\r\n\n			\r\n\namicables n = \r\n\n	let divlist = [(sumDiv x) | x <- [1..n]] in\r\n\n	[(x,y) | x <- [1..n], y <- [1..n], x < y, x == (divlist !! (y-1)), y == (divlist !! (x-1))]\n','<br/>Тесты успешно пройдены!'),(6310,59,'8519021','2013-10-13 13:20:15',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Select_Where\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] nonZeroLastDigits(int[] a)\r\n\r\n        {\r\n\r\n            // Здравствуйте, Михаил Лазаревич! Скажите, пожалуйста, почему такое решение не годится? \r\n\r\n            // Может я неправильно поняла условие.. почему задача не засчитана?\r\n  --- Проблемав том, что система но позволяет мне посмотреть предыдущие решения.\r\n  --- А вы точно такое решение присылали и я его не зачел? И ничего не написал?\r\n  --- Тогда наверное это была просто опечатка - наверное, хотел зачесть, но попал не по той кнопке.\r\n            return a.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = new int[] { 354, 20, 9, 31 };\r\n\r\n            int[] b = nonZeroLastDigits(a);\r\n\r\n            foreach (int i in b)\r\n\r\n            {\r\n\r\n                Console.Write(\"{0} \", i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6309,57,'55363692','2013-10-13 03:10:17',1,'-- Пока неоптимизированная версия\r\n\r\n\r\n\r\nimport Data.List\r\n\r\n\r\n\r\ndata Circuit = Res | Seq [Circuit] | Par [Circuit] deriving Show\r\n\r\n\r\n\r\nlen c = case c of \r\n\r\n	Res -> 1 \r\n\r\n	Seq cs -> sum $ map len cs\r\n\r\n	Par cs -> sum $ map len cs\r\n\r\n	\r\n\r\ntoString circuit = case circuit of\r\n\r\n	Res -> \"Res\"\r\n\r\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n	Par xs -> \"Par [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\r\n\r\n\r\n\r\nparts\' n k = \r\n\r\n	if n == 0 then [[]]\r\n\r\n	else if k > n then [] \r\n\r\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\r\n\r\nparts n = tail (parts\' n 1)	\r\n\r\n	\r\n\r\n-- 1 == Par\r\n\r\n-- 0 == Seq\r\n\r\ngenerateAllCircuits\' n op = \r\n\r\n	if n == 1 then [Res]\r\n\r\n	else if op == 0 then let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Seq c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n	else let \r\n\r\n		xss = parts n\r\n\r\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\r\n\r\n		css = map (cs -> sequence cs) css\'\r\n\r\n		results = map (cs -> [Par c | c <- cs]) css\r\n\r\n		in concat results\r\n\r\n\r\n\r\ngenerateAllCircuits :: Int -> [Circuit]\r\n\r\ngenerateAllCircuits n = concat [generateAllCircuits\' k 0 ++ generateAllCircuits\' k 1 | k <- [1..n]]\r\n\r\n\r\n\r\neval:: (Num a, Fractional a) => [a] -> Circuit -> a\r\n\r\neval xs circuit = case circuit of \r\n\r\n	Res -> head xs\r\n\r\n	Seq (x:[]) -> eval xs x\r\n\r\n	Seq (x:cs) -> let \r\n\r\n		l = len x \r\n\r\n		(f, s) = splitAt l xs\r\n\r\n		in (eval f x) + (eval s (Seq cs)) \r\n\r\n	Par (x:[]) -> eval xs x\r\n\r\n	Par (x:cs) -> let \r\n\r\n		l = len x \r\n\r\n		(f, s) = splitAt l xs\r\n\r\n		r1 = (eval f x)\r\n\r\n		r2 = (eval s (Par cs))\r\n\r\n		in r1 * r2 / (r1 + r2)\r\n\r\n\r\n\r\ncheckCircuit:: (Eq a, Num a, Fractional a) => [[a]] -> Circuit -> a -> Bool\r\n\r\ncheckCircuit xss circuit res = any (xs -> eval xs circuit == res) xss		\r\n\r\n		\r\n\r\ncanMakeScheme rs res = let \r\n\r\n		n = length rs\r\n\r\n		allCircuits = generateAllCircuits n\r\n\r\n		perms = permutations rs \r\n\r\n		in any (c -> checkCircuit perms c res) allCircuits \r\n\r\n	--do\r\n\r\n		--putStr $ unlines (map (c -> toString c) allCircuits)\r\n\r\n		--putStrLn $ \"\r\nTOTAL = \" ++ (show $ length allCircuits)\r\n','<br/>Тесты успешно пройдены!'),(6307,64,'62628590','2013-10-13 02:05:06',1,'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f x Empty = x\r\nfoldTree f x (Node i j k) = foldTree f (foldTree f (f i x) j) k\r\n--foldTree (+) 0 (Node 1 (Node 3 Empty Empty) (Node 5 Empty Empty))\r\n--foldTree (*) 1 (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 Empty Empty))','<br/>Тесты успешно пройдены!'),(6308,57,'55363692','2013-10-13 03:07:26',0,'-- Пока неоптимизированная версия\n\n\n\nimport Data.List\n\n\n\ndata Circuit = Res | Seq [Circuit] | Par [Circuit] deriving Show\n\n\n\nlen c = case c of \n\n	Res -> 1 \n\n	Seq cs -> sum $ map len cs\n\n	Par cs -> sum $ map len cs\n\n	\n\ntoString circuit = case circuit of\n\n	Res -> \"Res\"\n\n	Seq xs -> \"Seq [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n	Par xs -> \"Par [\" ++ (intercalate \", \" (map (x -> toString x) xs)) ++ \"]\"\n\n\n\nparts\' n k = \n\n	if n == 0 then [[]]\n\n	else if k > n then [] \n\n	else parts\' n (k + 1) ++ [(k : xs) | xs <- parts\' (n - k) k]\n\nparts n = tail (parts\' n 1)	\n\n	\n\n-- 1 == Par\n\n-- 0 == Seq\n\ngenerateAllCircuits\' n op = \n\n	if n == 1 then [Res]\n\n	else if op == 0 then let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Seq c | c <- cs]) css\n\n		in concat results\n\n	else let \n\n		xss = parts n\n\n		css\' = map (xs -> map (x -> generateAllCircuits\' x (1 - op)) xs) xss\n\n		css = map (cs -> sequence cs) css\'\n\n		results = map (cs -> [Par c | c <- cs]) css\n\n		in concat results\n\n\n\ngenerateAllCircuits :: Int -> [Circuit]\n\ngenerateAllCircuits n = generateAllCircuits\' n 0 ++ generateAllCircuits\' n 1\n\n\n\neval:: (Num a, Fractional a) => [a] -> Circuit -> a\n\neval xs circuit = case circuit of \n\n	Res -> head xs\n\n	Seq (x:[]) -> eval xs x\n\n	Seq (x:cs) -> let \n\n		l = len x \n\n		(f, s) = splitAt l xs\n\n		in (eval f x) + (eval s (Seq cs)) \n\n	Par (x:[]) -> eval xs x\n\n	Par (x:cs) -> let \n\n		l = len x \n\n		(f, s) = splitAt l xs\n\n		r1 = (eval f x)\n\n		r2 = (eval s (Par cs))\n\n		in r1 * r2 / (r1 + r2)\n\n\n\ncheckCircuit:: (Eq a, Num a, Fractional a) => [[a]] -> Circuit -> a -> Bool\n\ncheckCircuit xss circuit res = any (xs -> eval xs circuit == res) xss		\n\n		\n\ncanMakeScheme rs res = let \n\n		n = length rs\n\n		allCircuits = generateAllCircuits n\n\n		perms = permutations rs \n\n		in any (c -> checkCircuit perms c res) allCircuits \n\n	--do\n\n		--putStr $ unlines (map (c -> toString c) allCircuits)\n\n		--putStrLn $ \"\nTOTAL = \" ++ (show $ length allCircuits)\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),(6304,61,'62628590','2013-10-13 01:48:38',1,'sumDiv n = foldr (x res -> if (mod n x == 0) then res+x else res) 0 [1..(n-1)]\r\nperfects n = [x | x <- [2..n], sumDiv x == x]','<br/>Тесты успешно пройдены!'),(6305,62,'62628590','2013-10-13 01:52:02',1,'sumDiv n = foldr (x res -> if (mod n x == 0) then res+x else res) 0 [1..(n-1)]\r\namicables n = [(x, y) | x <- [1..n], let y = sumDiv x, x < y, sumDiv y == x]','<br/>Тесты успешно пройдены!'),(6306,63,'62628590','2013-10-13 01:55:08',1,'luckyNumbers\' n = n : (luckyNumbers\' (n * 10 + 7))\r\nluckyNumbers = luckyNumbers\' 7','<br/>Тесты успешно пройдены!'),(6303,58,'deripaska','2013-10-13 00:05:50',2,'--- Что-то мне кажется у вас неправильно? \r\n--- Вот я ввожу canMakeScheme [200,1000,70,20,1000] 1560\r\n--- И получаю True. А надо вроде бы False?  \r\n\r\n{--\r\n\r\n	task 13-03\r\n\r\n*Доп.задача, до 17.10*\r\n\r\nУсловие см. в задаче 13-2, задача должна работать для 9 сопротивлений. (Таких тестов в системе нет, но я проверю вручную).\r\n\r\n\r\n\r\nЗамечание:\r\n\r\n- Если вы хотите писать эту задачу не на Haskell - обсудите это со мной сначала, пожалуйста. Точно можно писать на OCaml. Точно нельзя решать эту задачу на обычном языке типе С# (просто в данном случае на C# получается заметно проще).\r\n\r\n--}\r\n\r\n\r\n\r\n--import Debug.Trace\r\n\r\n\r\n\r\ncanMakeScheme xs r\r\n\r\n	| r < minScheme xs || r > maxScheme xs = False\r\n\r\n	| otherwise = (canMakeSchemeUsingOnlyOneResistor sortXs r) || (canMakeSchemeHelp 2 sortXs r)\r\n\r\n	where sortXs = quicksort xs\r\n\r\n\r\n\r\n-- тут уже дается отсортированный xs\r\n\r\ncanMakeSchemeHelp k xs r\r\n\r\n	| k == (length xs + 1) = False\r\n\r\n	| neededNext /= True = res\r\n\r\n	| otherwise = canMakeSchemeHelp (k + 1) xs r \r\n\r\n	where (res, neededNext) = canChooseKWith k xs 0 0 r\r\n\r\n\r\n\r\ncanMakeSchemeUsingOnlyOneResistor xs r -- = canChoosePairWith xs 0 r\r\n\r\n	| isContain xs r = True\r\n\r\n	| otherwise = False\r\n\r\n\r\n\r\ncanChoosePairWith [] first r = (True, False)-- второе значение в итоговой паре показывает, имеетли смысл искать дальше пару в возрастающем массиве\r\n\r\ncanChoosePairWith (x:xs) first r\r\n\r\n	| r == minVar || r == maxVar = (True, False)\r\n\r\n	| r < minVar = (False, False) -- xs будет возрастать, значит и минимальное сопротивление (minVar) тоже. А значит если  получить мЕньшее сопротивление мы уже не сможем\r\n\r\n	| otherwise = canChoosePairWith xs first r\r\n\r\n	where \r\n\r\n		maxVar = serial x first\r\n\r\n		minVar = x * first / maxVar -- = parallel x fisrt\r\n\r\n\r\n\r\ncanChooseKWith 1 xs i first r = {--trace \"===\" trace (show xs) --} canChoosePairWith xs first r\r\n\r\ncanChooseKWith k xs i first r \r\n\r\n	| r <= 0 || i == (length xs) = {--trace \"null\" trace (show k) trace (show xs)--} (False, True)\r\n\r\n	| otherwise =\r\n\r\n	let \r\n\r\n		x = xs !! i\r\n\r\n		newXS = removeOneResistor xs x\r\n\r\n		(res1, neededNext1) = canChooseKWith (k - 1) newXS 0 x (r - first)\r\n\r\n		(res2, neededNext2) = canChooseKWith (k - 1) newXS 0 x (1/ (1 / r - 1 / first))\r\n\r\n	in\r\n\r\n--	| neededNext1 /= True && neededNext2 /= True = (res1 || res2, False)\r\n\r\n	if neededNext1 /= True && res1 then (res1, False)\r\n\r\n	else if neededNext2 /= True && res2 then (res2, False)\r\n\r\n	else canChooseKWith k xs (i + 1) first r\r\n\r\n	\r\n\r\nremoveOneResistor (x:xs) r\r\n\r\n	| x == r = xs\r\n\r\n	| otherwise = x : removeOneResistor xs r\r\n\r\n	\r\n\r\nisContain xs r = foldr (x res -> res || (x == r)) False xs\r\n\r\nminScheme xs = min (minimum xs) (1 / (foldr (x res -> res + 1 / x) 0 xs))\r\n\r\nmaxScheme xs = foldr (+) 0 xs\r\n\r\n\r\n\r\nserial r1 r2 = r1 + r2 -- при последователньом соединении сопротивление будет максимально\r\n\r\nparallel r1 r2 = r1 * r2 / (r1 + r2) -- при параллельном соединении сопротивление будет минимально = 1 / r1 + 1 / r2\r\n\r\n\r\n\r\nquicksort []     = []\r\n\r\nquicksort (x:xs) = (quicksort left) ++ [x] ++ (quicksort right)\r\n\r\n    where\r\n\r\n        left  = filter (< x) xs\r\n\r\n        right = filter (>= x) xs\r\n','<br/>Тесты успешно пройдены!'),(6300,62,'8519021','2013-10-12 23:06:36',1,'sumDiv n = sum [i + (n `div` i) | i<-[1..(truncate(sqrt (fromIntegral n)))], n `mod` i == 0] - n\r\n\r\namicables n = [(a, b) | a<-[1..n], let b = sumDiv a, a < b, a == sumDiv b]\r\n','<br/>Тесты успешно пройдены!'),(6301,63,'toskira','2013-10-12 23:23:05',1,'luckyNumbers = f 0\r\n\r\nf a = let b = (10 * a + 7) in b:(f b)','<br/>Тесты успешно пройдены!'),(6302,59,'8519021','2013-10-12 23:56:26',2,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Select_Where\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] nonZeroLastDigits(int[] a)\r\n\r\n        {\r\n\r\n            return a.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = new int[] { 354, 20, 9, 31 };\r\n\r\n            int[] b = nonZeroLastDigits(a);\r\n\r\n            foreach (int i in b)\r\n\r\n            {\r\n\r\n                Console.Write(\"{0} \", i);\r\n\r\n            }\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6297,65,'SNNatalieS','2013-10-12 22:17:30',2,'cantor = [(x, c) | x <- [1..], c <- [1..]]\r\n  --- Нет, так нельзя, мы про это говорили на занятии. Так у вас до пары \r\n  --- (2,2) никогда не дойдет. Те пара есть, но на бесконечном расстоянии.\r\n  --- А надо придумать такой порядок обхода, чтобы до любой пары можно\r\n  --- дойти за конечное число шагов. Попробуйте, пожалуйста.','Выражение имеет неправильное значение: length(filter(==(3,2))(take 100 cantor))'),(6298,61,'8519021','2013-10-12 22:51:38',1,'sumDiv n = sum [i + (n `div` i) | i<-[1..(truncate(sqrt (fromIntegral n)))], n `mod` i == 0] - n\r\n  ---Так у вам неправильно получится, если число - полный квадрат. Но ОК,в данном случае неважно, засчитано.\r\nperfects n = [i | i<-[2..n], sumDiv i == i]\r\n','<br/>Тесты успешно пройдены!'),(6299,56,'nomeansno','2013-10-12 22:52:37',1,'allLists n 1 = [[x] | x <- [1..n]]\r\n\r\nallLists n k = [x:y | x <- [1..n], y<-allLists n (k-1)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6295,63,'Valentina Guleva','2013-10-12 22:00:31',2,'luckyNumbers i = [7 | t <- [1..i]] : luckyNumbers(i + 1)\r\n  --- Так у вас получается список списков ([[7],[7.7],[7,7,7],[7,7.7,7],...]\r\n  --- А надо список списков. Я вам пока не засчитаю. Но если вы ничего не придумаете, выложите то же решение\r\n  --- еще раз, и я его и так засчитаю. \r\n\r\n','Не удалось вычислить выражение \"take 4 luckyNumbers\", проверьте правильность синтаксиса'),(6296,68,'SNNatalieS','2013-10-12 22:06:26',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _14_1\r\n{\r\n    class Program\r\n    {\r\n       static int[] zeroDigits(int[] c, int n)\r\n        {\r\n            int r = (int)Math.Pow(10.0, (double)n);\r\n            int[] b = c.Select(x => x - (x % r)).ToArray();\r\n            return b;\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 587, 5643, 76796 };\r\n            int[] b = zeroDigits(a, 2);\r\n            foreach (var i in b) Console.WriteLine(i);\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6292,61,'Valentina Guleva','2013-10-12 21:48:37',1,'sumDiv n = sum [t | t<-[1..(n-1)], mod n t ==  0]\r\n\r\n\r\n\r\nperfects n = [t | t <- [1..n], t == sumDiv t]\r\n','<br/>Тесты успешно пройдены!'),(6293,62,'Valentina Guleva','2013-10-12 21:49:09',1,'sumDiv n = sum [t | t<-[1..(n-1)], mod n t ==  0]\r\n\r\n\r\n\r\namicables n = [(x, y) | x <- [1..n], y <- [1..n], x == sumDiv y, y == sumDiv x, x < y]\r\n','<br/>Тесты успешно пройдены!'),(6294,63,'8519021','2013-10-12 21:55:45',1,'luckyList n = let lucky = 10 * n + 7 in lucky : luckyList lucky\r\n\r\nluckyNumbers = luckyList 0\r\n','<br/>Тесты успешно пройдены!'),(6290,62,'toskira','2013-10-12 21:33:31',1,'sumDiv n = let f = foldr (a b -> let x = div n a in (if a == x then a:b else a:x:b)) []      \r\n               g = filter ((== 0).(mod n))                                                    \r\n           in ((+ 1).sum.f.g) [2..(round.sqrt.fromIntegral) n]                                \r\n                                                                                              \r\namicables n = [(b, a) | a <- [1..n], let b = sumDiv a, b < a, sumDiv b == a]','<br/>Тесты успешно пройдены!'),(6291,64,'nomeansno','2013-10-12 21:35:04',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f z Empty = z\r\n\r\nfoldTree f z (Node v l r) = foldTree f (f v (foldTree f z l)) r\r\n\r\n\r\n\r\ncount = foldTree (\\_ y -> y+1) 0\r\n\r\nmulpos = foldTree (x y -> y * if x>0 then x else 1) 1\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6289,58,'deripaska','2013-10-12 21:33:19',0,'{--\r\n\n	task 13-03\r\n\n*Доп.задача, до 17.10*\r\n\nУсловие см. в задаче 13-2, задача должна работать для 9 сопротивлений. (Таких тестов в системе нет, но я проверю вручную).\r\n\n\r\n\nЗамечание:\r\n\n- Если вы хотите писать эту задачу не на Haskell - обсудите это со мной сначала, пожалуйста. Точно можно писать на OCaml. Точно нельзя решать эту задачу на обычном языке типе С# (просто в данном случае на C# получается заметно проще).\r\n\n--}\r\n\n\r\n\ncanMakeScheme xs r\r\n\n	| r < minScheme xs || r > maxScheme xs = False\r\n\n	| otherwise = (canMakeSchemeUsingOnlyOneResistor sortXs r) || (canMakeSchemeHelp 2 sortXs r)\r\n\n	where sortXs = xs--quicksort xs\r\n\n\r\n\n-- тут уже дается отсортированный xs\r\n\ncanMakeSchemeHelp k xs r\r\n\n	| k == (length xs + 1) = False\r\n\n	| neededNext /= True = res\r\n\n	| otherwise = canMakeSchemeHelp (k + 1) xs r \r\n\n	where (res, neededNext) = canChooseKWith k xs 0 0 r\r\n\n\r\n\ncanMakeSchemeUsingOnlyOneResistor xs r -- = canChoosePairWith xs 0 r\r\n\n	| isContain xs r = True\r\n\n	| otherwise = False\r\n\n\r\n\ncanChoosePairWith [] first r = (False, True) -- второе значение в итоговой паре показывает, имеетли смысл искать дальше пару в возрастающем массиве\r\n\ncanChoosePairWith (x:xs) first r\r\n\n	| r == minVar || r == maxVar = (True, False)\r\n\n	| r < minVar = (False, False) -- xs будет возрастать, значит и минимальное сопротивление (minVar) тоже. А значит если  получить мЕньшее сопротивление мы уже не сможем\r\n\n	| otherwise = canChoosePairWith xs first r\r\n\n	where \r\n\n		maxVar = serial x first\r\n\n		minVar = x * first / maxVar -- = parallel x fisrt\r\n\n\r\n\ncanChooseKWith 1 xs i first r = canChoosePairWith xs first r\r\n\ncanChooseKWith k xs i first r\r\n\n	| i == length xs = (False, True)\r\n\n	| neededNext1 /= True && neededNext2 /= True = (res1 || res2, False)\r\n\n	| otherwise = canChooseKWith k xs (i + 1) first r\r\n\n	where \r\n\n		x = xs !! i\r\n\n		newXS = removeOneResistor xs x\r\n\n		(res1, neededNext1) = canChooseKWith (k - 1) newXS 0 x (r - first)\r\n\n		(res2, neededNext2) = canChooseKWith (k - 1) newXS 0 x (1/ (r - 1 / first))\r\n\n\r\n\nremoveOneResistor (x:xs) r\r\n\n	| x == r = xs\r\n\n	| otherwise = x : removeOneResistor xs r\r\n\n	\r\n\nisContain xs r = foldr (x res -> res || (x == r)) False xs\r\n\nminScheme xs = minimum xs\r\n\nmaxScheme xs = foldr (+) 0 xs\r\n\n\r\n\nserial r1 r2 = r1 + r2 -- при последователньом соединении сопротивление будет максимально\r\n\nparallel r1 r2 = r1 * r2 / (r1 + r2) -- при параллельном соединении сопротивление будет минимально = 1 / r1 + 1 / r2\r\n\n\r\n\nquicksort []     = []\r\n\nquicksort (x:xs) = (quicksort left) ++ [x] ++ (quicksort right)\r\n\n    where\r\n\n        left  = filter (< x) xs\r\n\n        right = filter (>= x) xs\n','Выражение имеет неправильное значение: canMakeScheme [13,2,30,3,7] 6'),(6287,61,'toskira','2013-10-12 21:13:21',0,'sumDiv n = let f = foldr (a b -> let x = div n a in (if a == x then a:b else a:x:b)) []\r\n               g = filter ((== 0).(mod n))\r\n           in ((+ 1).sum.f.g) [2..(round.sqrt.fromIntegral) n]\r\n\r\nperfect n = filter (a -> a == sumDiv a) [2..n]','Не удалось вычислить выражение \"perfects 100\", проверьте правильность синтаксиса'),(6288,61,'toskira','2013-10-12 21:13:47',1,'sumDiv n = let f = foldr (a b -> let x = div n a in (if a == x then a:b else a:x:b)) []\r\n               g = filter ((== 0).(mod n))\r\n           in ((+ 1).sum.f.g) [2..(round.sqrt.fromIntegral) n]\r\n\r\nperfects n = filter (a -> a == sumDiv a) [2..n]','<br/>Тесты успешно пройдены!'),(6284,62,'nomeansno','2013-10-12 17:53:00',1,'sumDiv n = f 2 1\r\n\r\n	where f d sum = if (d*d > n) then sum else f (d+1) (sum+add)\r\n\r\n		where add = if (n `mod` d == 0) then d+(n `div` d) else 0\r\n\r\n\r\n\r\namicables n = [(y, z) | x<-[2..n], let y = sumDiv x, let z = sumDiv y, y /= x && x == z && y<z]\r\n  --- Совсем не важно, но в конце достаточно x == z && y < z. Потому что если у < z значит\r\n  --- число не совершенное, значит и y /= x  \r\n\r\n','<br/>Тесты успешно пройдены!'),(6285,63,'nomeansno','2013-10-12 19:51:24',0,'luckyNumbers = luckyNumbers\' 7 0\n\nluckyNumbers\' a b =  b\': luckyNumbers\' a b\'\n\n	where b\' = b*10 + a \n\n\n\n\n\n\n','<br/>Тесты успешно пройдены!'),(6286,63,'nomeansno','2013-10-12 20:03:02',1,'--luckyNumbers = luckyNumbers\' 7 0\r\n\r\n--luckyNumbers\' a b =  b\': luckyNumbers\' a b\'\r\n\r\n--	where b\' = b*10 + a \r\n\r\n\r\n\r\nluckyNumbers = 7: map (x -> 10*x+7) luckyNumbers \r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6278,68,'anlun','2013-10-12 13:39:55',1,'#include <algorithm>\r\n\r\n#include <iostream>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nint* zeroDigits(const int* const arr, int const size, int const n) {\r\n\r\n	int delim = 1;\r\n\r\n	for (int i = 0; i < n; i++) {\r\n\r\n		delim *= 10;\r\n\r\n	}\r\n\r\n\r\n\r\n	int* b = new int[size]; \r\n\r\n	transform(arr, arr + size, b, [delim] (int el) { return (el / delim) * delim; });\r\n\r\n	return b;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nint main() {\r\n\r\n	int arr[] = {563, 5643, 76796};\r\n\r\n	int size = 3;\r\n\r\n\r\n\r\n	int* b = zeroDigits(arr, size, 2);\r\n\r\n\r\n\r\n	for (int i = 0; i < size; i++) {\r\n\r\n		cout << b[i] << \" \";\r\n\r\n	}\r\n\r\n	cout << endl;\r\n\r\n\r\n\r\n	delete [] b;\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6279,66,'15309342','2013-10-12 14:43:51',0,'generalizedCantor l = foldr (sum list -> list ++ cantor sum l) [] [2..]\r\ncantor sum 2 = [ [x, sum - x] | x <- [1..(sum - 1)]]\r\ncantor sum l = [ (x:xs) | x <- [1..(sum - 1)], xs <- cantor (sum - x) (l - 1)]','Не удалось вычислить выражение \"length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))\", проверьте правильность синтаксиса'),(6280,66,'15309342','2013-10-12 14:48:28',1,'generalizedCantor l = foldr (sum list -> (cantor sum l) ++ list) [] [2..]\r\ncantor sum 2 = [ [x, sum - x] | x <- [1..(sum - 1)]]\r\ncantor sum l = [ (x:xs) | x <- [1..(sum - 1)], xs <- cantor (sum - x) (l - 1)]','<br/>Тесты успешно пройдены!'),(6281,68,'15309342','2013-10-12 15:01:07',1,'using System.IO;\r\nusing System;\r\nusing System.Linq;\r\n\r\nclass Task17_1\r\n{\r\n    static int[] zeroDigits(int[] a, int n)\r\n    {\r\n        return a.Select(x => x - x % (int)Math.Pow(10, n)).ToArray();\r\n  --- OK, но лучше сосчитать Pow(10, n) один раз, а не для каждого числа. Мы это потом обсудим.\r\n    }\r\n    static void Main()\r\n    {\r\n        int [] a = {563, 5643, 76796};\r\n        int n = 2;\r\n        foreach (var x in zeroDigits(a, n))\r\n            Console.Write(x.ToString() + \" \");\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6282,64,'SNNatalieS','2013-10-12 15:42:29',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nfoldTree f e Empty = e\r\nfoldTree f e (Node v l r) = foldTree f (foldTree f (f e v) l) r\r\n','<br/>Тесты успешно пройдены!'),(6283,61,'nomeansno','2013-10-12 16:59:20',1,'sumDiv n = f 2 1\r\n\r\n	where f d sum = if (d*d > n) then sum else f (d+1) (sum+add)\r\n\r\n		where add = if (n `mod` d == 0) then d+(n `div` d) else 0\r\n  --- Мне кажется, у вас так неправильно считается сумма для полных квадратов\r\n  --- Например, для 9 у вас вроде бы получится 1 + 3 + 3 = 7\r\n  --- Но ОК, поскольку среди свершенных чисел полные квадраты пока не обнаружены,\r\n  --- но все засчитывется :)  \r\n\r\n\r\nperfects n = [x | x<-[2..n], sumDiv x == x]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6277,64,'42284313','2013-10-12 11:35:19',1,'{--\r\n\r\n\r\n\r\nОпишите функцию foldTree, которая для дерева делает что-то аналогичное foldr или foldl для списков.\r\n\r\n\r\n\r\nТ.е. задача написать что-то, что позволяет искать\r\n\r\nсумму, произведение и т.д. для всех элементов дерева. На самом деле это можно сделать разными\r\n\r\nспособами. \r\n\r\n\r\n\r\nа. Например, можно написать функцию foldTree, которая вызывается\r\n\r\nкак-то так:\r\n\r\n\r\n\r\nfoldTree (+) 0 t — ищет сумму всех элементов в дереве\r\n\r\nfoldTree (*) 1 t — ищет произведение всех элементов в дереве\r\n\r\n\r\n\r\nб. Но м.б. можно придумать что-то более общее? Например, придумать такой вариант foldTree, который позволяет реализовывать более сложные функции (например, искать высоту дерева и т.д.). Если придумаете, предложите какой-нибудь такой вариант.\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- Условие, естественно, не совсем строгое (но так и в жизни часто бывает..). Если есть вопросы - пишите.\r\n\r\n- Пункт б. необязательный (хотя и не особо сложный). Решения, описанного в пункте а. тоже вполне достаточно. \r\n\r\n- В этой задаче, естественно, тестов не будет. Желательно, чтобы вы включили в текст 2-3 примера того, как можно использовать программу.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree a = None | Leaf a | Node a (Tree a) (Tree a)\r\n\r\n\r\n\r\nfoldTree _ k (None) = k\r\n\r\nfoldTree f k (Leaf a) = f a k\r\n\r\nfoldTree f k (Node a b c) = foldr f k [a, foldTree f k b, foldTree f k c]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6276,63,'42284313','2013-10-12 10:24:20',1,'{--\r\n\r\n\r\n\r\nОпишите переменную luckyNumbers, как бесконечный список [7,77,777,7777,...] - т.е. список из целых положительных чисел, у которых все цифры равны 7.\r\n\r\n\r\n\r\nЗачемание\r\n\r\nПример вызова:\r\n\r\ntake 5 luckyNumbers\r\n\r\nОтвет должен быть равен:\r\n\r\n[7,77,777,7777,77777]\r\n\r\n\r\n\r\nЗамечание:\r\n\r\n- Поскольку мы не можем печатать бесконечные списки, для отладки удобно использовать стандарную фунцкию take n xs, которая возвращает список из первых n элементов списка xs.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ngenerate n =\r\n\r\n	let\r\n\r\n		next = n * 10 + 7\r\n\r\n	in n : generate next\r\n\r\n\r\n\r\nluckyNumbers = generate 7\r\n','<br/>Тесты успешно пройдены!'),(6272,56,'641524','2013-10-11 23:44:35',0,'trace xs = last (foldl (s x -> [(head s)+1, (last s) + (x !! (head s))]) [0, 0] xs)\r\n\n\r\n\nallLists n k = foldr (x res -> [y:ys | y <- [1..n], ys <- res]) [[]] [1..k] \n','<br/>Тесты успешно пройдены!'),(6273,56,'641524','2013-10-11 23:46:03',1,'allLists n k = foldr (x res -> [y:ys | y <- [1..n], ys <- res]) [[]] [1..k] \r\n','<br/>Тесты успешно пройдены!'),(6274,61,'42284313','2013-10-12 10:10:06',1,'{--\r\n\r\n\r\n\r\nВ этой задаче надо реализовать сразу две функции: \r\n\r\nа. Напишите функцию sumDiv, которая для данного целого положительного числа возвращает сумму всех его делителей, не считая сам это число.\r\n\r\nб. Напишите функция perfects n, которая возвращает список всех совершенных чисел, меньших или равных n.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nsumDiv 10\r\n\r\nОтвет должен быть равен 8 (так как 1+2+5=8)\r\n\r\nperfects 1000\r\n\r\nОтвет должен быть равен\r\n\r\n[6,28,496]\r\n\r\n\r\n\r\nСправка: Число называется совершенным, если оно равно сумме своих делителей.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nsumDiv n = sum [k | k <- [1..div n 2], mod n k == 0]\r\n\r\n\r\n\r\nperfects n = [k | k <- [1..n], sumDiv k == k]\r\n','<br/>Тесты успешно пройдены!'),(6275,62,'42284313','2013-10-12 10:17:57',1,'{--\r\n\r\n\r\n\r\nНапишите функция amicables n, которая возвращает список всех пар дружественных чисел, каждое из которых меньше или равно n. \r\n\r\nПример вызова:\r\n\r\namicables 1000\r\n\r\nОтвет должен быть равен\r\n\r\n[(220,284)]\r\n\r\n\r\n\r\nСправка: Числа a и b называется дружественными, если a равно сумме делителей b, а b равно сумме делителей a.\r\n\r\n\r\n\r\nЗамечания: \r\n\r\n- Для единообразия давайте включать в список только те пары, в которых первое число меньше второго.\r\n\r\n- Видимо, имеет смысл скопировать и использовать функцмю sumDiv из задачи 14-1\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nsumDiv n = sum [k | k <- [1..div n 2], mod n k == 0]\r\n\r\n\r\n\r\namicables n = [(a,b) | a <- [1..n],\r\n\r\n                       let\r\n\r\n                       	b = sumDiv a,\r\n\r\n                       b > a,\r\n\r\n                       a == sumDiv b]\r\n','<br/>Тесты успешно пройдены!'),(6271,128,'8519021','2013-10-11 23:06:19',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace CheckDigitCurriedApplication\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static bool CheckDigit(int i, int n)\r\n\r\n        {\r\n\r\n            string s = n.ToString();\r\n\r\n            return s.Contains(i.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        static Func<Ti, Func<Tn, Tresult>> CheckDigitCurried <Ti, Tn, Tresult>(Func<Ti, Tn, Tresult> f)\r\n\r\n        {\r\n\r\n            return i => n => f(i, n);\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            var checkDigitCurried = CheckDigitCurried<int, int, bool>(CheckDigit);\r\n\r\n            bool b = checkDigitCurried(7)(68);\r\n\r\n            Console.WriteLine(b);\r\n\r\n            int[] a = new int[] {7, 757, 777, 787};\r\n\r\n            bool b1 = a.All(checkDigitCurried(7));\r\n\r\n            Console.WriteLine(b1);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6265,61,'3270666','2013-10-11 20:22:40',1,'sumDiv n = sum [x | x <- [1..n `div` 2], n `mod` x == 0]\r\n\r\nperfects n = [x | x <- [1..n], x == sumDiv x]','<br/>Тесты успешно пройдены!'),(6266,56,'2156724','2013-10-11 20:32:32',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [ x:xs | x <- [1..n], xs <-allLists n (k-1)]\r\n','<br/>Тесты успешно пройдены!'),(6267,62,'3270666','2013-10-11 20:34:18',1,'sumDiv n = sum [x | x <- [1..n `div` 2], n `mod` x == 0]\r\n\r\namicables n = [(x, y) | x <- [1..n], y <- [(x + 1)..n], x == sumDiv y, y == sumDiv x]','<br/>Тесты успешно пройдены!'),(6268,63,'3270666','2013-10-11 20:43:59',0,'getLucky 1 = 7\r\ngetLucky n = getLucky (n - 1) * 10 + 7\r\n\r\nluckyList n = (getLucky n):luckyList (n+1)\r\n\r\nluckyNumbersTest n = let luckyNumbers = luckyList 1\r\n                      in take n luckyNumbers','Не удалось вычислить выражение \"take 4 luckyNumbers\", проверьте правильность синтаксиса'),(6269,63,'3270666','2013-10-11 20:46:03',1,'getLucky 1 = 7\r\ngetLucky n = getLucky (n - 1) * 10 + 7\r\n\r\nluckyList n = (getLucky n):luckyList (n+1)\r\n\r\nluckyNumbers = luckyList 1','<br/>Тесты успешно пройдены!'),(6270,128,'nomeansno','2013-10-11 21:41:26',1,'#include <iostream>\r\n\r\n#include <algorithm>\r\n\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nfunction<bool (int)> CheckDigitCurried(int digit) {\r\n\r\n    return [digit] (int x) {\r\n\r\n        while(x != 0) {\r\n\r\n            if (x%10 == digit) return true;\r\n\r\n            x = x/10;\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    };\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n    //int digit, number;\r\n\r\n    //cin >> digit >> number;\r\n\r\n    //cout << CheckDigitCurried(digit)(number);\r\n\r\n    list<int> l1, l2;\r\n\r\n    l1.push_back(1234);\r\n\r\n    l1.push_back(6789);\r\n\r\n    l2.push_back(123);\r\n\r\n    l2.push_back(345);\r\n\r\n    l2.push_back(3);\r\n\r\n    cout << all_of(l1.begin(), l1.end(), CheckDigitCurried(3));\r\n\r\n    cout << all_of(l2.begin(), l2.end(), CheckDigitCurried(3));\r\n\r\n}\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6261,62,'2156724','2013-10-11 17:38:11',0,'','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6262,62,'2156724','2013-10-11 17:38:59',1,'sumDiv n = sum (filter (i -> rem n i == 0) [1..quot n 2])\r\n\r\n\r\n\r\namicables n = [(x,y) | x <-[1..n], y <-[1..n], sumDiv x == y , sumDiv y == x, x<\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6263,66,'115753099','2013-10-11 18:17:09',1,'func 0 k = [[]]\r\nfunc n k =\r\n	[(x:xs) | x <- [1..(k+1)], xs <- func (n-1) k]\r\n\r\ngeneralizedCantor n =\r\n	concat (map (x -> filter (xs -> sum xs == (x + n)) (func n x)) [0..])','Не удалось вычислить выражение \"length(filter (==[2,1,4]) (take 100000 (generalizedCantor 3)))\", проверьте правильность синтаксиса'),(6264,68,'115753099','2013-10-11 18:35:53',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Application\r\n{\r\n	class MainClass\r\n	{\r\n\r\n		static int[] zeroDigits(int [] mas, int n)\r\n        {\r\n			int pow = (int)System.Math.Pow(10, n);\r\n			return (mas.Select(x => (x / pow) * pow)).ToArray();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int [] mas = new int[]{4, 14, 563, 5643, 76796};\r\n            foreach (var i in zeroDigits(mas, 2))\r\n            {\r\n                Console.WriteLine(i.ToString());\r\n            }\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(6259,62,'2156724','2013-10-11 17:37:08',0,'sumDiv n = sum (filter (i -> rem n i == 0) [1..quot n 2])\r\n\n\r\n\namicables 1000 = [(x,y) | x <-[1..1000], y <-[1..1000], sumDiv x == y , sumDiv y == x, x<y]\r\n\n\n','Не удалось вычислить выражение \"amicables 300\", проверьте правильность синтаксиса'),(6260,62,'2156724','2013-10-11 17:38:10',0,'sumDiv n = sum (filter (i -> rem n i == 0) [1..quot n 2])\r\n\n\r\n\namicables n = [(x,y) | x <-[1..n], y <-[1..n], sumDiv x == y , sumDiv y == x, x<y]\r\n\n\n','<br/>Тесты успешно пройдены!'),(6258,61,'2156724','2013-10-11 17:29:36',1,'sumDiv n = sum (filter (i -> rem n i == 0) [1..quot n 2])\r\n\r\nperfect n = if sumDiv n == n then True else False     \r\n  -- лучше просто ... = sumDiv n == n\r\n\r\nperfects n = filter (i -> perfect i) [1..n]  \r\n  --- тут короче просто filter perfect [1..n]','<br/>Тесты успешно пройдены!'),(6257,63,'2156724','2013-10-11 17:20:33',1,'list n = n:list (n * 10 + 7)\r\n\r\nluckyNumbers = list 7\r\n','<br/>Тесты успешно пройдены!'),(6254,68,'romos2007','2013-10-11 13:37:55',1,'﻿/*\r\n\r\n * Задача 17-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace _17_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] nonZeroLastDigits(int[] a, int n)\r\n\r\n        {\r\n\r\n            return a.Select(x => x - x % Convert.ToInt32(Math.Pow(10,n))).ToArray();\r\n  --- В прринципе правильно, но лучше, конечно, как-то сосчитать Math.Pow(10,n) один раз.\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 354, 21, 91, 31 };\r\n\r\n            int[] b = { 156546, 2565, 355, 466, 577, 180, 191, 220, 215, 1000, 1001, 5443 };\r\n\r\n            foreach (int x in nonZeroLastDigits(a,1))\r\n\r\n            {\r\n\r\n                Console.Write(x + \" \");\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            foreach (int x in nonZeroLastDigits(b,2))\r\n\r\n            {\r\n\r\n                Console.Write(x + \" \");\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n','<br/>Тесты успешно пройдены!'),(6255,128,'2156724','2013-10-11 15:57:51',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace curring\r\n{\r\n    class Program\r\n    {\r\n         public static bool checkDigit(double a, double n)\r\n  --- А почему n и a - вещественные, просто интересно? В условии написано,\r\n что они целые и по смыслу ясно, что речь о целых числах.\r\n        {\r\n            if  (n == 0) return false;\r\n            if (n % 10 == a) { return true;}\r\n            else{\r\n                return checkDigit (a, Math.Truncate(n / 10));\r\n            }\r\n\r\n        }\r\n\r\n        \r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            Func<double, Func<double, bool>>check = (x => (y => checkDigit(x,y)));\r\n\r\n            bool b = check(2)(4);\r\n            System.Console.WriteLine(b);\r\n            System.Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6256,59,'2156724','2013-10-11 17:13:03',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication3\r\n{\r\n    class Program\r\n    {\r\n        static int[] nonZeroLastDigits(int[] a)\r\n        {\r\n            int[] b = a.Where( x => (x % 10) !=0).ToArray();\r\n            int[] c = b.Select(x => x % 10).ToArray();\r\n   --- OK, но лучше сразу a.Where( x => (x % 10) !=0).Select(x => x % 10).ToArray(); \r\n            return c;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 354, 20, 9, 31 };\r\n            int[] b = nonZeroLastDigits(a);\r\n            for (int i = 0; i < b.Length; ++i)\r\n            {\r\n                System.Console.Write(b[i] + \" \");\r\n            }\r\n            System.Console.ReadLine();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6251,68,'deripaska','2013-10-11 12:28:03',1,'﻿/*\r\n\r\n	task 17-01\r\n\r\n*Доп.задача до 25.10*\r\n\r\n\r\n\r\nИспользуя функцию Select из задачи 14-1, напишите функцию zeroDigits с двумя параметрами a (массив целых положительных чисел), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0 и вернуть полученный новый массив.\r\n\r\n\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\n\r\nто после вызова zeroDigits(a, 2) должен вернуться массив из чисел 500, 5600, 76700\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_17_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] zeroDigits(int[] a, int n)\r\n\r\n        {\r\n\r\n            double k = Math.Pow(10, n);\r\n\r\n            return a.Select(x => x / (int) k * (int) k).ToArray();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] mas = new int[] { 563, 5643, 76796 };\r\n\r\n            foreach (int x in zeroDigits(mas, 2))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n            }\r\n\r\n            Console.Read();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6252,65,'15309342','2013-10-11 13:02:10',1,'cantor = [ (n - k, k)  | n <- [2..], k <- [1..(n - 1)]]','<br/>Тесты успешно пройдены!'),(6253,68,'1595828','2013-10-11 13:27:23',1,'using System.Linq;\r\nusing System;\r\nnamespace zd17_1\r\n{\r\n    class zd\r\n    {\r\n        static int[] zeroDigits(int[] a, int n)\r\n		{\r\n            int t = (int)Math.Pow(10, n);\r\n            return a.Select(x => x / t *t).ToArray();\r\n		}\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = new int[] { 14321, 322210, 5732 };\r\n            arr= zeroDigits(arr, 3);\r\n            foreach(int n in arr)\r\n                Console.Write(\"{0} \", n);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6250,128,'nbumakov','2013-10-11 10:56:18',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace HW11\r\n{\r\n    class Task_1\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 123, 123745, 1234567 };\r\n            bool b = a.All(CheckDigitCurried(7));\r\n\r\n            int n = 1234567;\r\n            bool b2 = CheckDigitCurried(7)(n);\r\n\r\n            Console.WriteLine(\"b: {0}, b2: {1}\", b, b2);\r\n            Console.ReadLine();\r\n        }\r\n\r\n        static Func<int, Func<int, bool>> CheckDigitCurried = (a => (i => CheckDigit(a, i))); \r\n\r\n        static bool CheckDigit(int a, int i)\r\n        {\r\n            return i.ToString().Contains(a.ToString());\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6249,58,'3226573','2013-10-11 02:23:46',2,'  --- Я добавил еще задачу 13-4 - там должно работать для 8 сопротивлений.\r\n  --- Выложите, пожалуйста, ваше решение в 13-4 и я ее зачту. \r\n-- Это решение - улучшенный вариант предыдущего решения для 13-3\r\n\r\n\r\n\r\nimport Data.List\r\n\r\nimport Data.Set (Set)\r\n\r\nimport qualified Data.Set as Set\r\n\r\n\r\n\r\n-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\r\n\r\nsplitList xs n m = let \r\n\r\n					 (x, t) = splitAt n xs\r\n\r\n					 (y, z) = splitAt (m - n) t		     \r\n\r\n				   in (x ++ (tail y) ++ (tail z), head y, head z)\r\n\r\n\r\n\r\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\r\n\r\nremoveElem xs n = let\r\n\r\n					(x, y) = splitAt n xs\r\n\r\n				  in (x ++ (tail y), head y)\r\n\r\n\r\n\r\n-- Ситуация, когда 2 элемента соединяем последовательно в 1\r\n\r\nf1 m (rss, s, p) (ans, cache) =	if (s == m || p == m) then (True, cache)\r\n\r\n								else canMakeScheme\' (insert s rss) m (ans, cache)\r\n\r\n\r\n\r\n-- Ситуация, когда 2 элемента соединяем параллельно в 1\r\n\r\nf2 m (rss, s, p) res = 	if s == p then res\r\n\r\n						else canMakeScheme\' (insert p rss) m res\r\n\r\n\r\n\r\n-- Хеш-функция от входного массива\r\n\r\nhash xs = foldr (x res -> res * 37 + x) 0 xs\r\n\r\n\r\n\r\n-- Главная функция\r\n\r\ncanMakeScheme\' rs m (ans, cache)\r\n\r\n	| ans == True = (ans, cache) \r\n\r\n	| rs == [] = (False, cache)\r\n\r\n	| Set.member calculatedHash cache = (False, cache)\r\n\r\n	| otherwise = 	let\r\n\r\n						listsWithoutTwo = 	[(rss, s, p)| n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], \r\n\r\n											let (rss, x, y) = splitList rs n1 n2, let s = x + y, let p = x * y / (x + y)]\r\n\r\n						(ans1, cache1) = foldr (f1 m) (ans, cache) listsWithoutTwo\r\n\r\n					in	if ans1 then (ans1, cache1)\r\n\r\n						else	let\r\n\r\n									(ans2, cache2) = foldr (f2 m) (ans1, cache1) listsWithoutTwo\r\n\r\n								in 	if ans2 then (ans2, cache2)\r\n\r\n									else (ans2, (Set.insert calculatedHash cache2))	\r\n\r\n	where calculatedHash = hash rs											 		\r\n\r\n\r\n\r\ncanMakeScheme rs m = any ( == m) rs || fst (canMakeScheme\' (sort (filter ( > 0) rs)) m (False, Set.empty))\r\n','<br/>Тесты успешно пройдены!'),(6248,57,'3226573','2013-10-11 02:22:55',1,'-- Это решение - улучшенный вариант предыдущего решения для 13-3\r\n\r\n\r\n\r\nimport Data.List\r\n\r\nimport Data.Set (Set)\r\n\r\nimport qualified Data.Set as Set\r\n\r\n\r\n\r\n-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\r\n\r\nsplitList xs n m = let \r\n\r\n					 (x, t) = splitAt n xs\r\n\r\n					 (y, z) = splitAt (m - n) t		     \r\n\r\n				   in (x ++ (tail y) ++ (tail z), head y, head z)\r\n\r\n\r\n\r\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\r\n\r\nremoveElem xs n = let\r\n\r\n					(x, y) = splitAt n xs\r\n\r\n				  in (x ++ (tail y), head y)\r\n\r\n\r\n\r\n-- Ситуация, когда 2 элемента соединяем последовательно в 1\r\n\r\nf1 m (rss, s, p) (ans, cache) =	if (s == m || p == m) then (True, cache)\r\n\r\n								else canMakeScheme\' (insert s rss) m (ans, cache)\r\n\r\n\r\n\r\n-- Ситуация, когда 2 элемента соединяем параллельно в 1\r\n\r\nf2 m (rss, s, p) res = 	if s == p then res\r\n\r\n						else canMakeScheme\' (insert p rss) m res\r\n\r\n\r\n\r\n-- Хеш-функция от входного массива\r\n\r\nhash xs = foldr (x res -> res * 37 + x) 0 xs\r\n\r\n\r\n\r\n-- Главная функция\r\n\r\ncanMakeScheme\' rs m (ans, cache)\r\n\r\n	| ans == True = (ans, cache) \r\n\r\n	| rs == [] = (False, cache)\r\n\r\n	| Set.member calculatedHash cache = (False, cache)\r\n\r\n	| otherwise = 	let\r\n\r\n						listsWithoutTwo = 	[(rss, s, p)| n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], \r\n\r\n											let (rss, x, y) = splitList rs n1 n2, let s = x + y, let p = x * y / (x + y)]\r\n\r\n						(ans1, cache1) = foldr (f1 m) (ans, cache) listsWithoutTwo\r\n\r\n					in	if ans1 then (ans1, cache1)\r\n\r\n						else	let\r\n\r\n									(ans2, cache2) = foldr (f2 m) (ans1, cache1) listsWithoutTwo\r\n\r\n								in 	if ans2 then (ans2, cache2)\r\n\r\n									else (ans2, (Set.insert calculatedHash cache2))	\r\n\r\n	where calculatedHash = hash rs											 		\r\n\r\n\r\n\r\ncanMakeScheme rs m = any ( == m) rs || fst (canMakeScheme\' (sort (filter ( > 0) rs)) m (False, Set.empty))\r\n','<br/>Тесты успешно пройдены!'),(6247,57,'3226573','2013-10-11 02:16:54',0,'-- Это решение - улучшенный вариант предыдущего решения для 13-3\r\n\n\r\n\nimport Data.List\r\n\nimport Data.Set (Set)\r\n\nimport qualified Data.Set as Set\r\n\n\r\n\n-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\r\n\nsplitList xs n m = let \r\n\n					 (x, t) = splitAt n xs\r\n\n					 (y, z) = splitAt (m - n) t		     \r\n\n				   in (x ++ (tail y) ++ (tail z), head y, head z)\r\n\n\r\n\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\r\n\nremoveElem xs n = let\r\n\n					(x, y) = splitAt n xs\r\n\n				  in (x ++ (tail y), head y)\r\n\n\r\n\n-- Ситуация, когда 2 элемента соединяем последовательно в 1\r\n\nf1 m (rss, s, p) (ans, cache) =	if (s == m || p == m) then (True, cache)\r\n\n								else canMakeScheme\' (insert s rss) m (ans, cache)\r\n\n\r\n\n-- Ситуация, когда 2 элемента соединяем параллельно в 1\r\n\nf2 m (rss, s, p) res = 	if s == p then res\r\n\n						canMakeScheme\' (insert p rss) m res\r\n\n\r\n\n-- Хеш-функция от входного массива\r\n\nhash xs = foldr (x res -> res * 37 + x) 0 xs\r\n\n\r\n\n-- Главная функция\r\n\ncanMakeScheme\' rs m (ans, cache)\r\n\n	| ans == True = (ans, cache) \r\n\n	| rs == [] = (False, cache)\r\n\n	| Set.member calculatedHash cache = (False, cache)\r\n\n	| otherwise = 	let\r\n\n						listsWithoutTwo = 	[(rss, s, p)| n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], \r\n\n											let (rss, x, y) = splitList rs n1 n2, let s = x + y, let p = x * y / (x + y)]\r\n\n						(ans1, cache1) = foldr (f1 m) (ans, cache) listsWithoutTwo\r\n\n					in	if ans1 then (ans1, cache1)\r\n\n						else	let\r\n\n									(ans2, cache2) = foldr (f2 m) (ans1, cache1) listsWithoutTwo\r\n\n								in 	if ans2 then (ans2, cache2)\r\n\n									else (ans2, (Set.insert calculatedHash cache2))	\r\n\n	where calculatedHash = hash rs											 		\r\n\n\r\n\ncanMakeScheme rs m = any ( == m) rs || fst (canMakeScheme\' (sort (filter ( > 0) rs)) m (False, Set.empty))\n','Не удалось вычислить выражение \"canMakeScheme [4,4,5] 7\", проверьте правильность синтаксиса'),(6246,66,'deripaska','2013-10-11 02:08:51',1,'{--\r\n\r\n	task 16-02\r\n\r\n*Доп. задача, до 24.10*\r\n\r\n\r\n\r\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 100 (generalizedCantor 3)\r\n\r\n\r\n\r\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет [[1,1,1], [1,1,2], и т.д.\r\n\r\n--}\r\n\r\n\r\n\r\ngeneralizedCantor k = generalizedCantorGen 1 k\r\n\r\ngeneralizedCantorGen n k = dioganalKdGen (n + k - 1) k ++ generalizedCantorGen (n + 1) k\r\n\r\n\r\n\r\n-- аналогично постоению пар, тут мы сторим \"диоганали\", но только для k-мерного случая, т.е. что-то вроде сечений \"диоганальных\"\r\n\r\ndioganalKdGen n 2 = [[i, n - i] | i <- [1..(n - 1)]] -- + 1\r\n\r\ndioganalKdGen n k = [ (i:prevList) | i <- [1..(n - 1)], prevList <- dioganalKdGen (n - i) (k - 1)] -- использовать n + k - 1\r\n\r\n-- dioganal3dGen n = [[i, j, k] | i <- [1..(n - 1)], (j, k) <- dioganal2dGen (n - i)] -- + 2\r\n\r\n-- dioganal4dGen n = [[l, i, j, k] | l <- [1..(n - 1)], (i, j, k) <- dioganal3dGen (n - l)] -- + 3\r\n','Выражение имеет неправильное значение: length(filter(==[4,1,1])(take 100 (generalizedCantor 5)))'),(6245,65,'romos2007','2013-10-11 01:38:42',1,'{--\r\n\r\nЗадача 16-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\n{-\r\n\r\nПредставим график. Перечисление элементов по диагоналям.\r\n\r\n/\r\n\r\n|\r\n\r\n|  \'\r\n\r\n|  \'  \'\r\n\r\n|  \'  \'  \'\r\n\r\n|__\'__\'__\'__\'____>\r\n\r\n\r\n\r\n-}\r\n\r\n\r\n\r\n\r\n\r\ncantor = cantor\' 1\r\n\r\n\r\n\r\n{-	по порядковому номеру числа в таком перечислении можно узнать, чему оно равно.\r\n\r\n-}\r\n\r\ncantor\' n =	let\r\n\r\n				(d,count) = diagNum_AND_elCount n --номер диагонали, содержащей n-ый элемент списка, и количество элементов с 1 по эту диагональ.\r\n\r\n				x = n - (count-d)	-- отсчитываем смещение от первого числа в этой диагонали (в позициях). Это и будет координата x.\r\n\r\n				y = -x + d+1 		-- из уравнения прямой y = -x + b, где b = d+1 (т.к. d-ая диагональ пересек. ось OX в точке d+1)\r\n\r\n			in ((x,y)):cantor\' (n+1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n{-	посчитать номер диагонали, в которой лежит n-ый элемент списка.\r\n\r\n	Нужно читать последовательно, сколько элементов получается в сумме от первой диагонали до какой-то.\r\n\r\n	Если n становится меньше либо равно этому числу, то мы нашли диагональ - текущая. \r\n\r\n-}\r\n\r\ndiagNum_AND_elCount n = diagNumber\' n 1\r\n\r\ndiagNumber\' n k = 	let\r\n\r\n						count = (k*(k+1)) `div` 2 -- количество элементов с 1-ой диагонали (1 элемент) по текущую, k-ую (k элементов), включительно\r\n\r\n					in\r\n\r\n						if n <= count then (k,count) else diagNumber\' n (k+1)\r\n','<br/>Тесты успешно пройдены!'),(6244,57,'3226573','2013-10-11 01:26:33',0,'import Data.List\r\n\nimport Data.Set (Set)\r\n\nimport qualified Data.Set as Set\r\n\n\r\n\n-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\r\n\nsplitList xs n m = let \r\n\n					 (x, t) = splitAt n xs\r\n\n					 (y, z) = splitAt (m - n) t		     \r\n\n				   in (x ++ (tail y) ++ (tail z), head y, head z)\r\n\n\r\n\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\r\n\nremoveElem xs n = let\r\n\n					(x, y) = splitAt n xs\r\n\n				  in (x ++ (tail y), head y)\r\n\n\r\n\n-- Ситуация, когда 2 элемента соединяем последовательно в 1\r\n\nf1 m (rss, s, p) (ans, cache) =	if (s == m || p == m) then (True, cache)\r\n\n								else canMakeScheme\' (insert s rss) m (ans, cache)\r\n\n\r\n\n-- Ситуация, когда 2 элемента соединяем параллельно в 1\r\n\nf2 m (rss, _, p) res =	canMakeScheme\' (insert p rss) m res\r\n\n\r\n\n-- Хеш-функция от входного массива\r\n\nhash xs = foldr (x res -> res * 37 + x) 0 xs\r\n\n\r\n\n-- Главная функция\r\n\ncanMakeScheme\' rs m (ans, cache)\r\n\n	| ans == True = (ans, cache) \r\n\n	| rs == [] = (False, cache)\r\n\n	| Set.member calculatedHash cache = (False, cache)\r\n\n	| otherwise = 	let\r\n\n						listsWithoutTwo = [ (rss, s, p) | n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], let (rss, x, y) = splitList rs n1 n2, let s = x + y, let p = x * y / (x + y)]\r\n\n						(ans1, cache1) = foldr (f1 m) (ans, cache) listsWithoutTwo\r\n\n					in	if ans1 then (ans1, cache1)\r\n\n						else	let\r\n\n									(ans2, cache2) = foldr (f2 m) (ans1, cache1) listsWithoutTwo\r\n\n								in 	if ans2 then (ans2, cache2)\r\n\n									else (ans2, (Set.insert calculatedHash cache2))	\r\n\n	where calculatedHash = hash rs											 		\r\n\n\r\n\ncanMakeScheme rs m = any ( == m) rs || fst (canMakeScheme\' (sort (filter ( > 0) rs)) m (False, Set.empty))\n','<br/>Тесты успешно пройдены!'),(6243,57,'3226573','2013-10-11 01:25:17',0,'import Data.List\r\n\nimport Data.Set (Set)\r\n\nimport qualified Data.Set as Set\r\n\n\r\n\n-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\r\n\nsplitList xs n m = let \r\n\n					 (x, t) = splitAt n xs\r\n\n					 (y, z) = splitAt (m - n) t		     \r\n\n				   in (x ++ (tail y) ++ (tail z), head y, head z)\r\n\n\r\n\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\r\n\nremoveElem xs n = let\r\n\n					(x, y) = splitAt n xs\r\n\n				  in (x ++ (tail y), head y)\r\n\n\r\n\n-- Ситуация, когда 2 элемента соединяем последовательно в 1\r\n\nf1 m (rss, s, p) (ans, cache) =	if (s == m || p == m) then (True, cache)\r\n\n								else canMakeScheme\' (insert s rss) m (ans, cache)\r\n\n\r\n\n-- Ситуация, когда 2 элемента соединяем параллельно в 1\r\n\nf2 m (rss, _, p) res =	canMakeScheme\' (insert p rss) m res\r\n\n\r\n\n-- Хеш-функция от входного массива\r\n\nhash xs = foldr (x res -> res * 37 + x) 0 xs\r\n\n\r\n\n-- Главная функция\r\n\ncanMakeScheme\' rs m (ans, cache)\r\n\n	| ans == True = (ans, cache) \r\n\n	| rs == [] = (False, cache)\r\n\n	| Set.member calculatedHash cache = (False, cache)\r\n\n	| otherwise = 	let\r\n\n						listsWithoutTwo = [ (rss, s, p) | n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], let (rss, x, y) = splitList rs n1 n2, let s = x + y, let p = x * y / (x + y)]\r\n\n						(ans1, cache1) = foldr (f1 m) (ans, cache) listsWithoutTwo\r\n\n					in	if ans1 then (ans1, cache1)\r\n\n						else	let\r\n\n									(ans2, cache2) = foldr (f2 m) (ans1, cache1) listsWithoutTwo\r\n\n								in 	if ans2 then (ans2, cache2)\r\n\n									else (ans2, (Set.insert calculatedHash cache2))	\r\n\n	where calculatedHash = hash rs											 		\r\n\n\r\n\ncanMakeScheme rs m = fst (canMakeScheme\' (sort (filter ( > 0) rs)) m (False, Set.empty))\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),(6242,66,'115753099','2013-10-11 01:02:37',2,'f n 0 = [[]]\r\nf n k =\r\n	[(x:xs) | x <- [1..n], xs <- f n (k-1)]\r\n\r\ngeneralizedCantor n =\r\n	concat (map (x -> map (y -> x:y) (f x (n-1))) [x | x <- [1..]])\r\n  --- Такой тест вроде бы не проходит: length(filter (==[2,1,4]) (take 100000 (generalizedCantor 3)))','Выражение имеет неправильное значение: length(filter(==[4,1,1])(take 100 (generalizedCantor 5)))'),(6241,65,'deripaska','2013-10-11 00:39:35',1,'{--\r\n\r\n	task 16-01\r\n\r\n*Доп. задача, до 24.10*\r\n\r\n\r\n\r\nОписать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntake 100 cantor\r\n\r\n\r\n\r\nЧто получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.\r\n\r\n--}\r\n\r\n\r\n\r\ncantor = cantorGen 1\r\n\r\ncantorGen n = dioganalGen (n + 1) ++ cantorGen (n + 1)\r\n\r\ndioganalGen n = foldr (x res -> (x, n - x) : res) [] [1..(n - 1)]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6240,47,'480387','2013-10-11 00:37:59',1,'g bs xs = [ xs!!n |let k = length bs, n <- [0..(k-1)], let b = bs!!n, b == 1]\r\nf n k = let \r\n	 bs = f\' k []\r\n	 l = length bs\r\n	 in \r\n		if (l< n)\r\n		then (map (\\_ -> 0) [1.. (n-l)])++bs\r\n		else bs\r\nf\' k bs = if (k==0) then bs else f\' (div k 2) ((mod k 2) : bs)\r\npowerset list = \r\n	let\r\n	  n = length list\r\n	  masks = map (f n) [0..(2^n-1)]\r\n	 in [g mask list | mask <- masks]\r\n','<br/>Тесты успешно пройдены!'),(6239,47,'480387','2013-10-11 00:37:36',0,'g bs xs = [ xs!!n |let k = length bs, n <- [0..(k-1)], let b = bs!!n, b == 1]\r\nf n k = let \r\n	 bs = f\' k []\r\n	 l = length bs\r\n	 in \r\n		if (l< n)\r\n		then (map (\\_ -> 0) [1.. (n-l)])++bs\r\n		else bs\r\nf\' k bs = if (k==0) then bs else f\' (div k 2) ((mod k 2) : bs)\r\nps list = \r\n	let\r\n	  n = length list\r\n	  masks = map (f n) [0..(2^n-1)]\r\n	 in [g mask list | mask <- masks]\r\n','Не удалось вычислить выражение \"length (powerset [1,2,3])\", проверьте правильность синтаксиса'),(6238,65,'115753099','2013-10-11 00:28:41',1,'cantor = concat (map (x -> ((x, x) : concat [ [(x, y), (y, x)] | y <- [1..(x-1)]]) ) [x | x <- [1..]])','<br/>Тесты успешно пройдены!'),(6236,47,'2156724','2013-10-10 22:10:19',1,'powerset [] = [[]]\r\n\r\npowerset [x] = [[],[x]]\r\n\r\npowerset (x:xs) = (powerset xs) ++ [x:y | y <- (powerset xs)]\r\n','<br/>Тесты успешно пройдены!'),(6237,47,'8519021','2013-10-10 23:46:07',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) = foldr (:) (map (y -> x:y) (powerset xs)) (powerset xs)\r\n','<br/>Тесты успешно пройдены!'),(6235,47,'2156724','2013-10-10 22:09:07',0,'powerset [] = []\r\n\npowerset [x] = [[],[x]]\r\n\npowerset (x:xs) = (powerset xs) ++ [x:y | y <- (powerset xs)]\n','Выражение имеет неправильное значение: powerset []'),(6234,44,'517309','2013-10-10 21:24:36',3,'dioph [0,0,0,0] [0,0,0,0] = [1,1,1]\r\ndioph [0,0,0,l] [0,0,0,m] = [-11,-11,-11]\r\ndioph [a,b,c,d] [k,l,m,n] = let \r\n								det1 = a*l - b*k\r\n						det2 = a*m - c*k\r\ndet3 = b*m - c*l\r\n							in if det1 /= 0 then f [a,b,c,d] [k,l,m,n]\r\n								else if det2 /= 0 then ([x,z,y] -> [x,y,z]) (f [a,c,b,d] [k,m,l,n])\r\n									else if det3 /= 0 then ([y,z,x] -> [x,y,z]) (f [b,c,a,d] [l,m,k,n])\r\n										else g1 [a,b,c,d] (-2^16) (-2^16)\r\n\r\npr [x,y,z,d] k = map (i -> i*k) [x,y,z,d]\r\n										\r\nf [a,0,c,d] [0,l,m,n] = if( c == 0 && m == 0 ) then [div d a, div n l, 1]\r\n						else if c == 0 then [div d a, x1, y1] \r\n							else if d == 0 then [x2, div n l, y2]\r\n								else g2 [a,0,c,d] [0,l,m,n] (-2^16)\r\n						where \r\n							[x1,y1] = h [l,m,n] (-2^16)\r\n							[x2,y2] = h [a,c,d] (-2^16)\r\n							\r\n\r\nf [a,b,c,d] [0,l,m,n] = let\r\n							lc = lcm b l \r\n							multb = div lc b\r\n							multl = div lc l\r\n							[x1,x2,x3,x4] = pr [a,b,c,d] multb\r\n							[y1,y2,y3,y4] = pr [0,l,m,n]','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(6233,44,'517309','2013-10-10 21:22:37',0,'dioph [0,0,0,0] [0,0,0,0] = (1,1,1)\r\ndioph [0,0,0,l] [0,0,0,m] = (-11,-11,-11)\r\ndioph [a,b,c,d] [k,l,m,n] = let \r\n								det1 = a*l - b*k\r\n						det2 = a*m - c*k\r\ndet3 = b*m - c*l\r\n							in if det1 /= 0 then f [a,b,c,d] [k,l,m,n]\r\n								else if det2 /= 0 then ((x,z,y) -> (x,y,z)) (f [a,c,b,d] [k,m,l,n])\r\n									else if det3 /= 0 then ((y,z,x) -> (x,y,z)) (f [b,c,a,d] [l,m,k,n])\r\n										else g1 [a,b,c,d] (-2^16) (-2^16)\r\n\r\npr [x,y,z,d] k = map (i -> i*k) [x,y,z,d]\r\n										\r\nf [a,0,c,d] [0,l,m,n] = if( c == 0 && m == 0 ) then (div d a, div n l, 1)\r\n						else if c == 0 then (div d a, x1, y1) \r\n							else if d == 0 then (x2, div n l, y2)\r\n								else g2 [a,0,c,d] [0,l,m,n] (-2^16)\r\n						where \r\n							[x1,y1] = h [l,m,n] (-2^16)\r\n							[x2,y2] = h [a,c,d] (-2^16)\r\n							\r\n\r\nf [a,b,c,d] [0,l,m,n] = let\r\n							lc = lcm b l \r\n							multb = div lc b\r\n							multl = div lc l\r\n							[x1,x2,x3,x4] = pr [a,b,c,d] multb\r\n							[y1,y2,y3,y4] = pr [0,l,m,n]','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(6232,44,'517309','2013-10-10 21:21:57',0,'dioph [0,0,0,0] [0,0,0,0] = (1,1,1)\r\ndioph [0,0,0,l] [0,0,0,m] = (-11,-11,-11)\r\ndioph [a,b,c,d] [k,l,m,n] = let \r\n								det1 = a*l - b*k\r\n						det2 = a*m - c*k\r\ndet3 = b*m - c*l\r\n							in if det1 /= 0 then f [a,b,c,d] [k,l,m,n]\r\n								else if det2 /= 0 then ((x,z,y) -> (x,y,z)) (f [a,c,b,d] [k,m,l,n])\r\n									else if det3 /= 0 then ((y,z,x) -> (x,y,z)) (f [b,c,a,d] [l,m,k,n])\r\n										else g1 [a,b,c,d] (-2^16) (-2^16)\r\n\r\npr [x,y,z,d] k = map (i -> i*k) [x,y,z,d]\r\n										\r\nf [a,0,c,d] [0,l,m,n] = if( c == 0 && m == 0 ) then (div d a, div n l, 1)\r\n						else if c == 0 then (div d a, x1, y1) \r\n							else if d == 0 then (x2, div n l, y2)\r\n								else g2 [a,0,c,d] [0,l,m,n] (-2^16)\r\n						where \r\n							[x1,y1] = h [l,m,n] (-2^16)\r\n							[x2,y2] = h [a,c,d] (-2^16)\r\n							\r\n\r\nf [a,b,c,d] [0,l,m,n] = let\r\n							lc = lcm b l \r\n							multb = div lc b\r\n							multl = div lc l\r\n							[x1,x2,x3,x4] = pr [a,b,c,d] multb\r\n							[y1,y2,y3,y4] = pr [0,l,m,n]','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(6230,65,'1595828','2013-10-10 16:43:58',1,'cantor\' (n1,n2)=\r\n\r\n let\r\n\r\n	n\'\r\n\r\n		| n1 == n2 = (1,n2+1)\r\n\r\n		| n1 > n2  =  (n1,n2+1)\r\n\r\n		| ((n1 < n2) && ((n1+1) == n2))  = (n2,1)\r\n\r\n		| otherwise = (n1+1,n2)\r\n\r\n in n\':cantor\' n\'\r\n\r\n  \r\n\r\ncantor = cantor\' (1,0)\r\n','<br/>Тесты успешно пройдены!'),(6231,59,'Artur','2013-10-10 20:39:00',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace NonZLDigits\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Func<int[], int[]> nonZeroLastDigits = y => y.Select(x => x % 10).Where(x => x > 0).ToArray() ; \r\n\r\n            int[] a = {354, 20, 9, 31} ;\r\n\r\n            int[] b = { 33210, 1, 30, 0, 40, 7, 110, 1 } ;\r\n\r\n            \r\n\r\n            int[] c =  nonZeroLastDigits(a) ;\r\n\r\n            int[] c1 = nonZeroLastDigits(b) ;\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6229,47,'1170660','2013-10-10 16:43:31',1,'powerset  [] = [[]]\r\n\r\npowerset  (x:xs) = [x:sublist | sublist <- powerset  xs] ++ powerset  xs\r\n','<br/>Тесты успешно пройдены!'),(6228,48,'nbumakov','2013-10-10 10:53:46',1,'{--\r\n        Не скажу, что сам дошел до решения, \r\n        решение пришло после прочтения статьи о том, как foldl представить через foldr\r\n        http://blog.wakatta.jp/blog/2011/11/09/haskell-foldl-as-foldr/ \r\n--}\r\n  --- ОК, очень хорошо.. Разобраться в этот трактате, это не хуже, чем решить задачу средней сложности:) \r\nmyreverse xs = foldr (x g ys -> g (x : ys)) id xs []','<br/>Тесты успешно пройдены!'),(6227,47,'nbumakov','2013-10-10 10:52:51',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) =\r\n  let \r\n    ys = powerset xs\r\n    zs = map (x:) ys\r\n  in powerset xs ++ zs','<br/>Тесты успешно пройдены!'),(6225,48,'nomeansno','2013-10-10 01:22:53',2,'myreverse = foldr f []\r\n\r\n where f last =  foldr (:) [last] \r\n   --- Нет, Юрий, это не по условию, к сожалению. Там же написано, что должно быть линейное\r\n   --- время. И значит, нельзя приписывать в конец. А вы приписываете,\r\n   --- и у вас в foldr еще вложенный foldr те время O(n^2)\r\n   --- Могу немного подсказать - тут удобно воспользоваться тем, что\r\n   --- Хаскел умеет работать с функциями, как с данными - брать их в качестве параметра,\r\n   --- возвращать как результат, строить новые функции и т.д. \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6226,63,'ilia','2013-10-10 01:40:24',1,'gen_num d i p = let\r\n\r\n		di = d * (10 ^ i)\r\n\r\n		dip = di + p\r\n\r\n	in\r\n\r\n		dip : gen_num d (i + 1) dip\r\n\r\n\r\n\r\nluckyNumbers = gen_num 7 0 0\r\n\r\n\r\n\r\nmain = print (take 5 luckyNumbers)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6223,128,'ilia','2013-10-10 01:01:39',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\ndef CheckDigitCurried(digit):\r\n\r\n	return lambda n: str(digit) in str(n)\r\n\r\n\r\n\r\nprint CheckDigitCurried(7)(123)\r\n\r\nprint CheckDigitCurried(7)(567)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6224,59,'ilia','2013-10-10 01:16:41',1,'#!/usr/bin/env python\r\n\r\n\r\n\r\ndef nonZeroLastDigits(m):\r\n\r\n	return filter(lambda d: d != 0, map(lambda n: n % 10, m))\r\n\r\n\r\n\r\nprint nonZeroLastDigits([354, 20, 9, 31])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6222,64,'romos2007','2013-10-10 00:35:44',1,'{--\r\n\r\nЗадача 15-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Empty\r\n\r\n			| Node Integer Tree Tree\r\n\r\n\r\n\r\n\r\n\r\n-- левосторонний обход\r\n\r\n{-\r\n\r\n	Запускаем foldTree от поддерева с обновленным \"аккумулятором\", равным вычисленному значению функции от другого поддерева.\r\n\r\n	Здесь левое поддерево считается сначала.\r\n\r\n-}\r\n\r\nfoldTree f start Empty = start\r\n\r\nfoldTree f start (Node n l r) = foldTree f (foldTree f (f n start) l) r\r\n\r\n\r\n\r\n-- правосторонний обход\r\n\r\n{-\r\n\r\n	Запускаем foldTree от поддерева с обновленным \"аккумулятором\", равным вычисленному значению функции от другого поддерева.\r\n\r\n	Здесь левое поддерево считается сначала.\r\n\r\n-}\r\n\r\nfoldTree\' f start Empty = start\r\n\r\nfoldTree\' f start (Node n l r) = foldTree\' f (foldTree\' f (f n start) r) l\r\n\r\n\r\n\r\n\r\n\r\n-- что-то, основанное на простой рекурсивной идее: f(Node i l r) = f(l) и f(r)\r\n\r\nfoldTree\'\' f start Empty = start\r\n\r\nfoldTree\'\' f start (Node n l r) = f (foldTree\'\' f (f n start) l)  (foldTree\'\' f start r)\r\n\r\n\r\n\r\n\r\n\r\n{-\r\n\r\n	Никак не придумать, как сделать нечто более общее...\r\n\r\n	Или как записать, например, высоту дерева с помощью имеющихся выше функций.\r\n   --- ОК, засчитано, и мы это обсудим. Но, просто мб интересно, могу немного намекнуть\r\n   --- - решение очень простое, даже проще ваших решений\r\n   --- - но у него немного другой интерфейс (чуть-чуть сложнее)\r\n   --- - вот еще один пример, который бы хотелось решать - написать функцию,\r\n   ---   которая возвращает копию дерева, но в ней все элементы увеличены в 2 раза\r\n   ---   мб поможет, если вы попробуете это написать, а потом подумаете, что получилось\r\n   ---   общего с высотой.\r\n   --- Если придумаете какок-нибуль решение, пришлите, пожалуйста, просто интересно.\r\n-}\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6221,47,'ilia','2013-10-09 23:22:08',1,'powerset m = let\r\n\r\n		l = length m\r\n\r\n		lp2 = 2 ^ l\r\n\r\n	in\r\n\r\n		[ gen_set x m (l - 1) | x <- [0..lp2 - 1] ]\r\n\r\n\r\n\r\ngen_set 0 _ _ = []\r\n\r\ngen_set x m l = let\r\n\r\n		lp2 = 2 ^ l\r\n\r\n	in\r\n\r\n		gen_set (mod x lp2) m (l - 1)\r\n\r\n			++ [ m !! l | mod (div x lp2) 2 == 1 ]\r\n\r\n\r\n\r\nmain = print (powerset [1,2,3])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6220,63,'romos2007','2013-10-09 22:55:02',1,'{--\r\n\r\nЗадача 15-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-x - число, которое хотим повторять. n - предыдущее число списка-}\r\n\r\nlist x n = n:list x (n*10+x)\r\n\r\n\r\n\r\nluckyNumbers = list 7 7\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6219,62,'romos2007','2013-10-09 22:34:04',1,'{--\r\n\r\nЗадача 15-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-	Собираем делители сразу парами: если число x - делитель N, то соответствующее частное N/x - тоже делитель.\r\n\r\n	Т.о. сразу включаем его в список. Образуется список пар. Все эти числа надо сложить, но:\r\n\r\n	из пары (1,N) и (x,x) надо брать только 1 и x соответственно.\r\n\r\n-}\r\n\r\nsumDiv n = foldl (\r\nes (x,y) -> if (x == 1 || x == y) then res+x else res+x+y ) 0 [ (x,div n x) | x<-[1.. truncate (sqrt (fromIntegral n))], mod n x == 0 ]\r\n\r\n\r\n\r\n{- Перебираем одно число, а по нему генерируем второе и проверяем на условие x<y-}\r\n\r\namicables n = [ (x,y) | x<-[1..n], let y = sumDiv x, x < y, x == sumDiv y ]\r\n','<br/>Тесты успешно пройдены!'),(6218,61,'romos2007','2013-10-09 22:28:40',1,'{--\r\n\r\nЗадача 15-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-	Собираем делители сразу парами: если число x - делитель N, то соответствующее частное N/x - тоже делитель.\r\n\r\n	Т.о. сразу включаем его в список. Образуется список пар. Все эти числа надо сложить, но:\r\n\r\n	из пары (1,N) и (x,x) надо брать только 1 и x соответственно.\r\n\r\n-}\r\n\r\nsumDiv n = foldl (\r\nes (x,y) -> if (x == 1 || x == y) then res+x else res+x+y ) 0 [ (x,div n x) | x<-[1.. truncate (sqrt (fromIntegral n))], mod n x == 0 ]\r\n\r\n\r\n\r\nperfects n = [x|x<-[2..n], sumDiv x == x]\r\n','<br/>Тесты успешно пройдены!'),(6217,63,'3320654','2013-10-09 22:26:19',1,'luckyNumbers = help 0\r\n\r\nhelp n = let\r\n	k = 10 * n + 7\r\n              in\r\n	k : help k','<br/>Тесты успешно пройдены!'),(6214,63,'5247795','2013-10-09 21:52:05',1,'luckyNumbers = luckyNumbers\' 7\r\n\r\nluckyNumbers\' n = n : (luckyNumbers\' (n * 10 + 7)) \r\n','<br/>Тесты успешно пройдены!'),(6215,63,'5543298','2013-10-09 21:58:52',1,'getNumber 1 res = res\r\n\r\ngetNumber n res = getNumber (n - 1) (res * 10 + 7)\r\n\r\nluckyNumbers = [getNumber x 7 | x <- [1..]]\r\n','<br/>Тесты успешно пройдены!'),(6216,62,'3320654','2013-10-09 22:12:20',1,'amicables 2 = [] \r\namicables n = 	let\r\n			x = sumDiv n\r\n			y = sumDiv x\r\n	    	in \r\n			if (y == n) \r\n			then	if  (x < y)\r\n				then (x,y):(amicables (n - 1))\r\n				else (amicables (n - 1))\r\n			else	amicables (n - 1)\r\n			\r\n\r\nsumDiv n = sum (allDivisors n)\r\n\r\nallDivisors n 	= allDivisors\' [] n (div n 2) 1\r\nallDivisors\' list n t cD	= if ((mod n cD) == 0)\r\n		   then allDivisors\' (cD:list) n t (cD + 1)\r\n		   else	if (cD < t)\r\n			then allDivisors\' (list) n t (cD + 1)\r\n			else list	','<br/>Тесты успешно пройдены!'),(6210,48,'ilia','2013-10-09 21:10:27',2,'myreverse m = let\r\n\r\n		l = length m\r\n\r\n	in\r\n\r\n		foldr (i j -> m !! i : j) [] [ l - i | i <- [1..l] ]\r\n  --- Нет, к сожалению, так получится квадратичная сложность. Потому что m !! i требует O(i) операций,\r\n  --- и вы ее вызываете для i <- [1..l] - всего, значит O(l^2)\r\n\r\n\r\nmain = print (myreverse [1,2,3])\r\n\r\n','<br/>Тесты успешно пройдены!'),(6211,61,'5543298','2013-10-09 21:15:16',1,'sumDiv n = sum [x | x <- [1..(n - 1)], n `mod` x == 0]\r\n\r\n\r\n\r\nperfects n = [x | x <-[1..n], sumDiv x == x] \r\n','<br/>Тесты успешно пройдены!'),(6212,62,'5543298','2013-10-09 21:32:21',1,'sumDiv n = sum [x | x <- [1..(n - 1)], n `mod` x == 0]\r\n\r\n\r\n\r\ngetList n = filter ((a, b) -> b /= 1 && b < n && a < b) (map (x -> (x, sumDiv x))[1..(n - 1)])\r\n\r\n\r\n\r\namicables  n = [(x, y) | (x, y) <- getList n, sumDiv y == x]\r\n','<br/>Тесты успешно пройдены!'),(6213,61,'3320654','2013-10-09 21:50:02',1,'sumDiv n = sum (allDivisors n)\r\n\r\nperfects 1 = []\r\nperfects n = reverse (	if (n == sumDiv n)\r\n		then n:(perfects (n - 1))\r\n		else perfects (n - 1))\r\n\r\nallDivisors n 	= allDivisors\' [] n (div n 2) 1\r\nallDivisors\' list n t cD	= if ((mod n cD) == 0)\r\n		   then allDivisors\' (cD:list) n t (cD + 1)\r\n		   else	if (cD < t)\r\n			then allDivisors\' (list) n t (cD + 1)\r\n			else list	','<br/>Тесты успешно пройдены!'),(6207,61,'5247795','2013-10-09 18:08:02',1,'sumDiv n = foldr (x res -> if (n `mod` x == 0) then res+x else res) 0 [1..(n-1)]\r\n\r\nperfects n = [ x | x <- [1..(n-1)], x == (sumDiv x) ]\r\n','<br/>Тесты успешно пройдены!'),(6208,62,'5247795','2013-10-09 18:34:20',1,'sumDiv n = foldr (x res -> if (n `mod` x == 0) then res+x else res) 0 [1..(n-1)]\r\n\r\namicables n = [ (x,y) | x <- [1..(n-2)], y <- [(x+1)..(n-1)], x == (sumDiv y), y == (sumDiv x)]\r\n','<br/>Тесты успешно пройдены!'),(6209,57,'1835693','2013-10-09 20:21:38',2,'  --- (13 параллельно 2) последовательно (7 параллельно 3)  :(\r\n-- Функция, нумерующая элементы списка\r\n\r\n-- Каждый элемент преобразуется : x -> (id, x), где id - номер в списке\r\n\r\n-- Используется для того, чтобы брать заведомо разные элементы, даже если у них одно значение\r\n\r\nnumerate list = reverse $ numerateH 0 [] list\r\n\r\n\r\n\r\nnumerateH _  res []       = res\r\n\r\nnumerateH id res (e:list) = numerateH (id + 1) ((id, e) : res) list\r\n\r\n\r\n\r\n-- Поскольку соединение 3 и больше соединных (последовательно или параллельно - неважно)\r\n\r\n-- резисторов можно рассматривать как соединение двух - первого и соединения остальных двух,\r\n\r\n-- то используется следующий подход: выбираются всевозможные пары и \'соединяются\'.\r\n\r\n-- В итоге, из списка сопротивлений получается список всевозможных сопротивлений, если соединены ровно два\r\n\r\ncombine list = [xs | a <- numerate list, b <- numerate list, fst a < fst b,\r\n\r\n                     -- Соединение - последовательное или параллельное\r\n\r\n                     combined <- [snd a + snd b, 1 / ((1 / (snd a)) + (1 / (snd b)))],\r\n\r\n					 -- Добавление всех незадействованных резисторов\r\n\r\n                     let front = take (fst a) list,\r\n\r\n					 let middle = drop (fst a + 1) (take (fst b) list),\r\n\r\n					 let back = drop (fst b + 1) list,\r\n\r\n					 let xs = combined : front ++ middle ++ back]\r\n\r\n\r\n\r\ncanMakeScheme rs m = canMakeSchemeH False [rs] m\r\n\r\n\r\n\r\n-- В функции-помощнике одним из аргументов всегда будет флаг завершеня (1 аргумент)\r\n\r\n-- 2 аргумент - это список возможных полученных комбинаций сопротивлений (через функцию combine)\r\n\r\n-- Если хоть на каком-то этапе искомое сопротивление (m) будет содержаться в первой комбинации,\r\n\r\n-- то решение найдено (все остальные резисторы, кроме тех, через которые получилось это значение,\r\n\r\n-- использовать необязательно). Иначе эта комбинация \'разворачивается\' дальше\r\n\r\ncanMakeSchemeH True _      _ = True\r\n\r\ncanMakeSchemeH _    []     _ = False\r\n\r\ncanMakeSchemeH _    (r:rs) m = canMakeSchemeH (elem m r) ((combine r) ++ rs) m\r\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),(6204,61,'1595828','2013-10-09 16:03:48',1,'sumDiv n =  sum[x|i<-[1..(truncate (sqrt (fromIntegral n)))], mod n i == 0, \r\n\r\n let x \r\n\r\n	| (i ==(n `div` i)) = i\r\n\r\n	|otherwise = i+(n `div` i)] -n\r\n\r\nperfects n= [x|x<-[2..n],sumDiv x == x]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6205,62,'1595828','2013-10-09 16:13:05',1,'sumDiv n =  sum[x|i<-[1..(truncate (sqrt (fromIntegral n)))], mod n i == 0, \r\n\r\n let x \r\n\r\n	| (i ==(n `div` i)) = i\r\n\r\n	|otherwise = i+(n `div` i)] -n\r\n\r\namicables  n= [(x,y)|x<-[2..n], let y= (sumDiv x),x<y,sumDiv y == x]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6206,63,'1595828','2013-10-09 16:30:04',1,'luckyNumbers\' n =\r\n\r\n let\r\n\r\n	n\'=n*10+7\r\n\r\n in n\':luckyNumbers\' n\'\r\n\r\n  \r\n\r\nluckyNumbers = luckyNumbers\' 0\r\n','<br/>Тесты успешно пройдены!'),(6203,58,'3226573','2013-10-09 15:48:50',0,'-- Данное решение работает чуть больше 3 минут (3:12) для 8 резисторов. Для 9 не тестировал\n\n-- Это решение потянет на 5 баллов, или нужно еще улучшать? :)\n\n\n\nimport Data.List\n\nimport Data.Set (Set)\n\nimport qualified Data.Set as Set\n\n\n\n-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\n\nsplitList xs n m = let \n\n					 (x, t) = splitAt n xs\n\n					 (y, z) = splitAt (m - n) t		     \n\n				   in (x ++ (tail y) ++ (tail z), head y, head z)\n\n\n\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\n\nremoveElem xs n = let\n\n					(x, y) = splitAt n xs\n\n				  in (x ++ (tail y), head y)\n\n\n\n-- Ситуация, когда один из резисторов учитывается как элемент последовательного соединения в исходной цепи\n\nf1 m (rss, x) res =		if x < m then canMakeScheme\' rss (m - x) res\n\n						else res\n\n\n\n-- Ситуация, когда 2 элемента соединяем последовательно в 1\n\nf2 m (rss, s, p) (ans, cache) =	if (s == m || p == m) then (True, cache)\n\n								else canMakeScheme\' (sort (s:rss)) m (ans, cache)\n\n\n\n-- Ситуация, когда 2 элемента соединяем параллельно в 1\n\nf3 m (rss, _, p) res =	canMakeScheme\' (sort (p:rss)) m res\n\n\n\n-- Хеш-функция от входного массива\n\nhash\' [] res _ = res\n\nhash\' (x:xs) res base = hash\' xs (res + x * base) (base * 37)\n\nhash xs = hash\' xs 0 37\n\n\n\n-- Главная функция\n\ncanMakeScheme\' rs m (ans, cache)\n\n	| ans == True = (ans, cache) \n\n	| rs == [] = (False, cache)\n\n	| Set.member calculatedHash cache = (False, cache)\n\n	| any ( == m) rs = (True, cache)\n\n	| otherwise = 	let\n\n						listsWithoutOne = [ (rss, x) | n <- [0..(length rs - 1)], let (rss, x) = removeElem rs n]\n\n						(ans1, cache1) = foldr (f1 m) (ans, cache) listsWithoutOne\n\n					in 	if ans1 then (ans1, cache1)\n\n						else	let\n\n									listsWithoutTwo = [ (rss, s, p) | n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], let (rss, x, y) = splitList rs n1 n2, let s = x + y, let p = x * y / (x + y)]\n\n									(ans2, cache2) = foldr (f2 m) (ans1, cache1) listsWithoutTwo\n\n								in	if ans2 then (ans2, cache2)\n\n									else	let\n\n												(ans3, cache3) = foldr (f3 m) (ans2, cache2) listsWithoutTwo\n\n											in 	if ans3 then (ans3, cache3)\n\n												else (ans3, (Set.insert calculatedHash cache3))	\n\n	where calculatedHash = hash (m:rs)											 		\n\n\n\ncanMakeScheme rs m = fst (canMakeScheme\' (sort (filter ( > 0) rs)) m (False, Set.empty))\n','<br/>Тесты успешно пройдены!'),(6200,47,'641524','2013-10-09 02:52:09',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) = let s = powerset xs\r\n\r\n		   in (s ++ (map (k -> x:k) s))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6201,56,'284427','2013-10-09 13:42:13',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k-1)]\r\n','<br/>Тесты успешно пройдены!'),(6202,47,'284427','2013-10-09 15:16:52',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) = \r\n\r\n	let ss = powerset xs \r\n\r\n	in foldr (:) ss [(x : ys) | ys <- ss]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6197,47,'1990147','2013-10-09 01:03:58',0,'powerset lis= mas lis [[]]\r\n\nmas [] res = res\r\n\nmas (x:xz) resul= mas xz (foldr (i res-> i:([x]++i):res) [] resul)\r\n\n\r\n\n\r\n\nfunc xs = foldr (i res-> i:([5]++i):res) [] xs\n','Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),(6198,47,'1990147','2013-10-09 01:05:33',1,'powerset lis= mas lis [[]]\r\n\r\nmas [] res = res\r\n\r\nmas (x:xz) resul= mas xz (foldr (i res-> i:(i++[x]):res) [] resul)\r\n\r\n\r\n\r\n\r\n\r\nfunc xs = foldr (i res-> i:([5]++i):res) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6199,63,'SNNatalieS','2013-10-09 01:22:18',1,'ff n = n : ff (n * 10 + 7)\r\nluckyNumbers = ff 7  ','<br/>Тесты успешно пройдены!'),(6196,62,'SNNatalieS','2013-10-09 01:01:31',1,'sd n = foldr (x res -> if ((mod n x) == 0) then (res + x) else res) 1 [2 .. (n - 1)]\r\nf m = let t = sd m\r\n		in (m == sd t) && (m > t) && not(t == sd t)\r\n   --- Последнее условие на самом деле лишнее. Оно ведь нужно, чтобы отбросить совершенные числа,\r\n   --- но их, понятно, отбросит уже условие m > t (у совершенных чисел m == t\r\namicables n = foldr (x res -> if (f x) then ((sd x, x): res) else res) [] [2 .. n]','<br/>Тесты успешно пройдены!'),(6194,61,'SNNatalieS','2013-10-09 00:25:23',0,'sumDiv n = foldr (x res -> if ((mod n x) == 0) then (res + x) else res) 1 [2 .. (n - 1)]\r\nperfect 1 = []\r\nperfect n = filter (x -> x == sumDiv x) [2 .. n]','Не удалось вычислить выражение \"perfects 100\", проверьте правильность синтаксиса'),(6195,61,'SNNatalieS','2013-10-09 00:26:45',1,'sumDiv n = foldr (x res -> if ((mod n x) == 0) then (res + x) else res) 1 [2 .. (n - 1)]\r\nperfects 1 = []\r\nperfects n = filter (x -> x == sumDiv x) [2 .. n]','<br/>Тесты успешно пройдены!'),(6193,64,'115753099','2013-10-09 00:11:16',1,'  --- ОК, очень интересно! Я бы не совсем так сделал, но это мы обсудим. \r\ndata Tree t = Nod t (Tree t)  (Tree t)  | Leaf t\r\n\r\ndata Traversal t = PreOrder| InOrder | PostOrder | AlaBreadthFirst Bool ([Tree t] -> t)\r\n\r\n---in all Traversal cases exept the lastest(AlaBre...) function which is pass to foldTree as param will be applied to each tree element in the selected order\r\n\r\n---in AlaBreadthFirst case:\r\n\r\n---		if AlaBreadthFirst b func : b == False then traversal tree in order like breadth-first, func([Tree t] -> t) is not in use, fold\'s(function which is pass to foldTree as param) function \r\n\r\n---			will be applyed on each element of three\r\n\r\n---		else (i.e. b == True) then traversal tree in order like breadth-first, but func applays to all tree levels and push it\'s result in list, on this list will be applied fold\'s function\r\n\r\n\r\n\r\ntreeToList :: Tree t -> [t] -> Traversal t -> [t]\r\n\r\ntreeToList (Leaf element) list _ = element : list\r\n\r\ntreeToList (Nod element left right) list InOrder =\r\n\r\n	let r = treeToList right list InOrder\r\n\r\n	in treeToList left (element : r) InOrder\r\n\r\ntreeToList (Nod element left right) list PreOrder =\r\n\r\n	let r = treeToList right list PreOrder\r\n\r\n	in element : (treeToList left r) PreOrder\r\n\r\ntreeToList (Nod element left right) list PostOrder =\r\n\r\n	let r = treeToList right (element:list) PostOrder\r\n\r\n	in treeToList left r PostOrder\r\n\r\ntreeToList (Nod element left right) list (AlaBreadthFirst False _) =\r\n\r\n	treeToList2 [] [left, right] [element]\r\n\r\ntreeToList (Nod element left right) list (AlaBreadthFirst True func) =\r\n\r\n	treeToList3 [] [left, right] [func[(Nod element left right)]] func\r\n\r\n\r\n\r\ntreeToList2 [] [] acc = acc\r\n\r\ntreeToList2 [] nextLevel acc = treeToList2 nextLevel [] acc\r\n\r\ntreeToList2 ((Nod element left right) : thisLevel) nextLevel acc =\r\n\r\n	treeToList2 thisLevel (left : right : nextLevel) (element : acc)\r\n\r\ntreeToList2 ((Leaf element) : thisLevel) nextLevel acc =\r\n\r\n	treeToList2 thisLevel nextLevel (element : acc)\r\n\r\n\r\n\r\ntreeToList3 [] [] acc func =  acc\r\n\r\ntreeToList3 [] nextLevel acc func = treeToList3 nextLevel [] ((func nextLevel) : acc) func\r\n\r\ntreeToList3 ((Nod element left right) : thisLevel) nextLevel acc func =\r\n\r\n	treeToList3 thisLevel (left : right : nextLevel) acc func\r\n\r\ntreeToList3 ((Leaf element) : thisLevel) nextLevel acc func =\r\n\r\n	treeToList3 thisLevel nextLevel acc func\r\n\r\n\r\n\r\nfoldTree :: (a -> t -> a) -> a -> Tree t -> Traversal t -> a\r\n\r\nfoldTree func value tree traversal = foldl func value (treeToList tree [] traversal)\r\n\r\n\r\n\r\n---examples\r\n\r\n---tree elements sum\r\n\r\nsumAllTreeElements = foldTree (+) 0 ( Nod 4 ( Nod 2 (Leaf 1) (Leaf 3)) (Nod 6 (Leaf 5) (Leaf 7)) ) PreOrder\r\n\r\n---tree elemenct production\r\n\r\nproductAllTreeElements = foldTree (*) 1 ( Nod 4 ( Nod 2 (Leaf 1) (Leaf 3)) (Nod 6 (Leaf 5) (Leaf 7)) ) (AlaBreadthFirst False (\\_->0))\r\n\r\n---tree height\r\n\r\ntreeHeight = foldTree (+) 0 ( Nod 4 ( Nod 2 (Leaf 1) (Leaf 3)) (Nod 6 (Leaf 5) (Leaf 7)) ) (AlaBreadthFirst True (x -> 1))\r\n','<br/>Тесты успешно пройдены!'),(6191,63,'115753099','2013-10-08 22:23:23',1,'luckyNumbers = luckyNumbers2 7\r\n	where luckyNumbers2 i = i : luckyNumbers2 (i * 10 + 7)','<br/>Тесты успешно пройдены!'),(6192,47,'SNNatalieS','2013-10-08 23:07:49',1,'powerset [] = [[]]\r\npowerset (x:xs) = let g = powerset xs\r\n					in g ++ [x : d | d <- g]\r\n','<br/>Тесты успешно пройдены!'),(6190,62,'115753099','2013-10-08 22:17:39',1,'sumDiv n =\r\n	sumDiv2 n (n `div` 2) 1\r\n	where sumDiv2 n pr i \r\n		| i > pr  	     = 0\r\n		| n `rem` i == 0 = i + sumDiv2 n pr (i + 1)\r\n		| otherwise 	 = sumDiv2 n pr (i + 1)\r\n\r\n\r\namicables n = [(x, y) | x <- [1..n], y <- [(x + 1)..n], x == sumDiv y, y == sumDiv x]','<br/>Тесты успешно пройдены!'),(6186,62,'anlun','2013-10-08 21:35:19',1,'sumDiv n = sum numDiv\r\n	where\r\n		numDiv = filter (x -> n `mod` x == 0) [1..(n - 1)]\r\n\r\namicables n = filter ((a, b) -> (a < b) && (sumDiv b == a)) $ map (x -> (x, sumDiv x)) [1..n]','<br/>Тесты успешно пройдены!'),(6187,63,'anlun','2013-10-08 21:35:41',1,'luckyNumbers :: [ Integer ]\r\nluckyNumbers = 7 : [ x * 10 + 7 | x <- luckyNumbers ]','<br/>Тесты успешно пройдены!'),(6188,56,'SNNatalieS','2013-10-08 21:50:50',1,'allLists n 0 = [[]]\r\nallLists n k = [t : h | t <- [1 .. n], h <- allLists n (k - 1)]','<br/>Тесты успешно пройдены!'),(6189,61,'115753099','2013-10-08 22:12:54',1,'sumDiv n =\r\n	sumDiv2 n (n `div` 2) 1\r\n	where sumDiv2 n pr i \r\n		| i > pr  	     = 0\r\n		| n `rem` i == 0 = i + sumDiv2 n pr (i + 1)\r\n		| otherwise 	 = sumDiv2 n pr (i + 1)\r\n\r\nperfects n = [ x | x <- [1..n], x == sumDiv x]','<br/>Тесты успешно пройдены!'),(6185,61,'anlun','2013-10-08 21:34:53',1,'sumDiv n = sum numDiv\r\n	where\r\n		numDiv = filter (x -> n `mod` x == 0) [1..(n - 1)]\r\n\r\nperfects n = filter (x -> x == sumDiv x) [1..n]','<br/>Тесты успешно пройдены!'),(6184,59,'15309342','2013-10-08 21:02:27',1,'using System.IO;\r\nusing System;\r\nusing System.Linq;\r\n\r\nclass Task14_1\r\n{\r\n    static int[] nonZeroLastDigits(int[] a)\r\n    {\r\n        return a.Select(x => x % 10).ToArray().Where(y => y != 0).ToArray();\r\n    }\r\n    static void Main()\r\n    {\r\n        int [] a = {354, 20, 9, 31};\r\n        foreach (var x in nonZeroLastDigits(a))\r\n            Console.Write(x.ToString() + \" \");\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6181,63,'1835693','2013-10-08 20:37:42',1,'luckyNumbers = 7 : map (x -> 10 * x + 7) luckyNumbers\r\n','<br/>Тесты успешно пройдены!'),(6182,64,'15309342','2013-10-08 20:42:56',1,'data Tree = Empty | Node Integer Tree Tree\r\nfoldTree f i Empty = i\r\nfoldTree f i (Node e l r) = f e (foldTree f (foldTree f i l) r)','<br/>Тесты успешно пройдены!'),(6183,64,'3226573','2013-10-08 20:56:53',1,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\n-- порядок обхода: текущий узел, левое поддерево, правое поддерево\r\nfoldTree f res (Empty) = res\r\nfoldTree f res (Node val left right) = foldTree f (foldTree f (f val res) left) right\r\n\r\n-- Примеры\r\n\r\n-- foldTree (+) 0 (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n-- 6\r\n\r\n-- foldTree (*) 1 (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n-- 6\r\n\r\n-- foldTree (:) [] (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n-- [3,2,1]','<br/>Тесты успешно пройдены!'),(6180,61,'15309342','2013-10-08 20:33:34',1,'sumDiv n = foldl (+) 0 [x | x <- [1..(n `div` 2)], n `mod` x == 0]\r\nperfects n = [x | x <- [1..n], x == sumDiv x]','<br/>Тесты успешно пройдены!'),(6177,63,'3226573','2013-10-08 20:32:57',1,'luckyList n l = d : luckyList (n + 1) d\r\n				where d = l * 10 + 7\r\n   --- ОК, но просто как замечание, первый параметр особо не нужен, вы его не используете\r\nluckyNumbers = luckyList 1 0','<br/>Тесты успешно пройдены!'),(6178,63,'15309342','2013-10-08 20:33:27',1,'luckyNumbers = scanl (x y -> x * 10 + y) 7 [7,7..]','<br/>Тесты успешно пройдены!'),(6179,62,'15309342','2013-10-08 20:33:30',1,'sumDiv n = foldl (+) 0 [x | x <- [1..(n `div` 2)], n `mod` x == 0]\r\namicables n = [(x, y) | x <- [1..n], y <- [sumDiv x], x < y, y <= n, x == sumDiv y]','<br/>Тесты успешно пройдены!'),(6176,62,'1835693','2013-10-08 20:30:01',1,'sumDiv n = foldr (addDiv n) 0 [1..(div n 2)]\r\n\r\naddDiv n k res = if (mod n k == 0)\r\n                 then res + k\r\n                 else res\r\n\r\n-- Решение достаточно медленное (~минута для 300). Устроит ли или необходимо оптимизировать?\r\namicables n = [(a,b) | a <- [1..n], b <- [(a + 1)..n], a == sumDiv b, b == sumDiv a]\r\n   --- Устроит, в принципе, но тут очень просто оптимизировать.\r\n   --- Тут, на самом деле, вы допустили ту же ошибку, которую все допустили в последней задаче про монетки \r\n   --- (см слайды). Я вам ее не засчитываю, просто чтобы вы обратили на это внимание.\r\n   --- Но если неохота придумывать, можете просто выложить то же решение еще раз, и я его зачту.  ','<br/>Тесты успешно пройдены!'),(6175,56,'Artur','2013-10-08 20:29:40',1,'allLists n k = [ f x | x <- [0..n^k-1]] \r\n\r\n			where f z = foldl (\r\nes y -> (mod (div z (n^y)) n + 1):res) [] [0..k-1]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6174,56,'Artur','2013-10-08 20:24:42',0,'allLists n k = [ f x | x <- [0..n^k-1]] \r\n\n			where f z = foldl (\res y -> (mod (div z (n^y)) n + 1):res) [] [0..k-1]\r\n\n\r\n\n\n','Выражение имеет неправильное значение: elem [3,2,3] (allLists 3 3)'),(6172,63,'15309342','2013-10-08 20:19:41',0,'luckyNumbers = scanl (x y -> x * 10 + y) 7 [7,7..]','<br/>Тесты успешно пройдены!'),(6173,62,'3226573','2013-10-08 20:24:42',1,'sumDiv 1 = 0\r\nsumDiv n = 1 + sum [ d1 + d2 | d1 <- [2..floor (sqrt (fromIntegral n))], let d2 = (div n d1), d1 * d2 == n]\r\n\r\namicables n = [(x,y) | x <- [2..n], let y = sumDiv x, y > x, x == sumDiv y]','<br/>Тесты успешно пройдены!'),(6170,61,'1835693','2013-10-08 20:12:36',1,'sumDiv n = foldr (addDiv n) 0 [1..(div n 2)]\r\n\r\naddDiv n k res = if (mod n k == 0)\r\n                 then res + k\r\n		 else res\r\n\r\nperfects n = [x | x <- [1..n], x == sumDiv x]','<br/>Тесты успешно пройдены!'),(6171,61,'3226573','2013-10-08 20:15:04',1,'sumDiv 1 = 0\r\nsumDiv n = 1 + sum [ d1 + d2 | d1 <- [2..floor (sqrt (fromIntegral n))], let d2 = (div n d1), d1 * d2 == n]\r\n   --- Так, на самом деле, вы для полных квадратов сумму делателей считаете неправильно.\r\n   ---- Например sumDiv 9 у вас получаться 7. Но ОК, на ваше счастье среди совершенных чисел нет полных квадратов:)  \r\nperfects n = [ x | x <- [1..n], x == sumDiv x]','<br/>Тесты успешно пройдены!'),(6167,61,'15309342','2013-10-08 19:38:21',0,'sumDiv n = foldl (+) 0 [x | x <- [1..(n `div` 2)], n `mod` x == 0]\r\nperfects n = [x | x <- [1..n], x == sumDiv x]','<br/>Тесты успешно пройдены!'),(6168,62,'15309342','2013-10-08 20:00:12',0,'sumDiv n = foldl (+) 0 [x | x <- [1..(n `div` 2)], n `mod` x == 0]\r\namicables n = [(x, y) | x <- [1..n], y <- [sumDiv x], x < y, y <= n, x == sumDiv y]','<br/>Тесты успешно пройдены!'),(6169,47,'1835693','2013-10-08 20:05:21',1,'-- Update: Решение проблемы с элементами подписков в обратном порядке\r\n-- Эффективнее будет сначала один раз развернуть список, чем добавлять элемент в конец каждый раз\r\npowerset xs = powerseth [[]] (reverse xs)\r\n   --- ОК, отличная идея!\r\n\r\npowerseth res [] = res\r\n-- Для каждого просмотренного элемента возможны два действия: добавить его в подсписки (addelem) или нет (в этом случае res не меняется)\r\npowerseth res (x:xs) = powerseth (res ++ addelem res x) xs\r\n   --- Так у вас в подсписках элементы будут идти в обратном порядке, мне кажется\r\n   --- Это очень просто, но исправьте пожалуйста как-нибудь\r\naddelem res e = map (e:) res','<br/>Тесты успешно пройдены!'),(6166,64,'deripaska','2013-10-08 18:41:44',1,'{--\r\n\r\n	task 15-04\r\n\r\nОпишите функцию foldTree, которая для дерева делает что-то аналогичное foldr или foldl для списков.\r\n\r\n\r\n\r\nТ.е. задача написать что-то, что позволяет искать\r\n\r\nсумму, произведение и т.д. для всех элементов дерева. На самом деле это можно сделать разными\r\n\r\nспособами. \r\n\r\n\r\n\r\nа. Например, можно написать функцию foldTree, которая вызывается\r\n\r\nкак-то так:\r\n\r\n\r\n\r\nfoldTree (+) 0 t — ищет сумму всех элементов в дереве\r\n\r\nfoldTree (*) 1 t — ищет произведение всех элементов в дереве\r\n\r\n\r\n\r\nб. Но м.б. можно придумать что-то более общее? Например, придумать такой вариант foldTree, который позволяет реализовывать более сложные функции (например, искать высоту дерева и т.д.). Если придумаете, предложите какой-нибудь такой вариант.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Empty \r\n\r\n			| Node Integer Tree Tree\r\n\r\n\r\n\r\nfoldTree f e Empty = e\r\n\r\nfoldTree f e (Node val left right) = foldTree f (foldTree f (f e val) right) left\r\n\r\n--foldTree (*) 1 (Node 1 (Node 2 (Node 4 Empty Empty) Empty) (Node 3 Empty (Node 5 Empty Empty))) -- 120\r\n\r\n--foldTree (+) 0 (Node 1 (Node 2 (Node 4 Empty Empty) Empty) (Node 3 Empty (Node 5 Empty Empty))) -- 15\r\n\r\n\r\n\r\nfoldTree2 f e Empty = e\r\n\r\nfoldTree2 f e (Node val left right) = f val (foldTree2 f e left) (foldTree2 f e right)\r\n\r\n--foldTree2 (	1 t2 res -> res * t1 * t2) 1 (Node 1 (Node 2 (Node 4 Empty Empty) Empty) (Node 3 Empty (Node 5 Empty Empty))) -- 120\r\n\r\n--foldTree2 (	1 t2 res -> res + t1 + t2) 0 (Node 1 (Node 2 (Node 4 Empty Empty) Empty) (Node 3 Empty (Node 5 Empty Empty))) -- 15\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6165,63,'deripaska','2013-10-08 18:13:00',1,'{--\r\n\r\n	task 15-03\r\n\r\nОпишите переменную luckyNumbers, как бесконечный список [7,77,777,7777,...] - т.е. список из целых положительных чисел, у которых все цифры равны 7.\r\n\r\n\r\n\r\nЗачемание\r\n\r\nПример вызова:\r\n\r\ntake 5 luckyNumbers\r\n\r\nОтвет должен быть равен:\r\n\r\n[7,77,777,7777,77777]\r\n\r\n--}\r\n\r\n\r\n\r\nluckyNumberNear n = nextNumber : luckyNumberNear nextNumber where nextNumber = 7 + 10 * n\r\n\r\nluckyNumbers = luckyNumberNear 0\r\n','<br/>Тесты успешно пройдены!'),(6164,62,'deripaska','2013-10-08 17:58:11',1,'{--\r\n\r\n	task 15-02\r\n\r\nНапишите функция amicables n, которая возвращает список всех пар дружественных чисел, каждое из которых меньше или равно n. \r\n\r\nПример вызова:\r\n\r\namicables 1000\r\n\r\nОтвет должен быть равен\r\n\r\n[(220,284)]\r\n\r\n\r\n\r\nСправка: Числа a и b называется дружественными, если a равно сумме делителей b, а b равно сумме делителей a.\r\n\r\n--}\r\n\r\n\r\n\r\nsumDiv n = foldr (+) 0 [ i | i <- [1..(n - 1)], mod n i == 0]\r\n\r\namicables n = [(i, j) | i <- [2..n], let j = sumDiv i, i < j && sumDiv j == i]\r\n','<br/>Тесты успешно пройдены!'),(6162,56,'3270666','2013-10-08 17:29:55',1,'allLists n 0 = []\r\n   --- Лучше = [[]] - это и правильнее (есть такая последовательность из 0 элементов,\r\n   --- это пустой список). И тогда не надо описывать специально случай с 1\r\nallLists n 1 = [[x] | x <- [1..n]]\r\nallLists n k = [x:xs | x <- [1..n], xs <- (allLists n (k - 1))]','<br/>Тесты успешно пройдены!'),(6163,61,'deripaska','2013-10-08 17:50:51',1,'{--\r\n\r\n	task 15-01\r\n\r\nВ этой задаче надо реализовать сразу две функции: \r\n\r\nа. Напишите функцию sumDiv, которая для данного целого положительного числа возвращает сумму всех его делителей, не считая сам это число.\r\n\r\nб. Напишите функция perfects n, которая возвращает список всех совершенных чисел, меньших или равных n.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nsumDiv 10\r\n\r\nОтвет должен быть равен 8 (так как 1+2+5=8)\r\n\r\nperfects 1000\r\n\r\nОтвет должен быть равен\r\n\r\n[6,28,496]\r\n\r\n--}\r\n\r\n\r\n\r\nsumDiv n = foldr (+) 0 [ i | i <- [1..(n - 1)], mod n i == 0]\r\n\r\nperfects n = [ i | i <- [2..n], sumDiv i == i]\r\n','<br/>Тесты успешно пройдены!'),(6160,63,'517309','2013-10-08 16:39:31',3,'luckyNumbers = [7,77, 777, 7777, 77777]','<br/>Тесты успешно пройдены!'),(6161,128,'3270666','2013-10-08 17:00:56',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FP11_1\r\n{\r\n    class Program\r\n    {\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Func<int, Func<int, bool>> CheckDigitCurried = digit => number =>\r\n            {\r\n                if (digit >= 0 && digit <= 9)\r\n                {\r\n                    return number.ToString().Contains(digit.ToString());\r\n                }\r\n                else\r\n                {\r\n                    return false;\r\n                }\r\n\r\n            };\r\n\r\n            Console.WriteLine(\"Number {0} contains digit {1}: {2}\", 123, 3, CheckDigitCurried(3)(123));\r\n            Console.WriteLine(\"Number {0} contains digit {1}: {2}\", 2, 2, CheckDigitCurried(2)(2));\r\n            Console.WriteLine(\"Number {0} contains digit {1}: {2}\", 12, 5, CheckDigitCurried(5)(12));\r\n            Console.Read();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6159,128,'1595828','2013-10-08 14:11:56',1,'using System.Linq;\r\nusing System;\r\nnamespace zd11_1\r\n{\r\n    class zd\r\n    {\r\n\r\n\r\n        static Func<int, Func<int,bool>>  curry  = (dig => (str_num => str_num.ToString().Contains(dig.ToString())));\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = new int[] { 1, 20, 532 };\r\n            System.Console.WriteLine(curry(2)(123321));\r\n            Console.WriteLine( arr.All(curry(2)));\r\n            System.Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6158,47,'1595828','2013-10-08 12:21:38',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) = makelist  xs [[],[x]]\r\n\r\nmakelist [] ans  = ans\r\n\r\nmakelist (x:xs) ans = makelist xs (foldr(a b-> if b/=[[]] then b++[a]++[a++[x]] else [a]++[a++[x]]) [[]] ans)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6157,56,'42284313','2013-10-08 10:51:54',1,'{--\r\n\r\n\r\n\r\n*Доп.задача, до 17.10*\r\n\r\nОписать функцию allLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nallLists 3 2\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\r\n\r\n\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- В общем случае в списке должно быть, понятно, n^k элементов.\r\n\r\n- Эта задача, мне кажется, совсем не сложная\r\n\r\nПодсказка: Я бы советовал использовать list comprehension, получится очень просто.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nallLists n 0 = [[]]\r\n\r\nallLists n k = [(head : tail) | head <- [1..n],\r\n\r\n	                            tail <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(6155,56,'2260659','2013-10-08 00:28:55',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [ x:xs | x<-[1..n], xs<-allLists n (k-1)] \r\n','<br/>Тесты успешно пройдены!'),(6156,48,'641524','2013-10-08 02:13:46',2,' --- Нет, это у вас, к сожалению, получился квадратичный алгоритм,\r\n --- потому что xs!!x требует x операций, и вы это делаете в цикле.\r\n --- Могу немного подсказать - то решение, которое большинство участников\r\n --- предлагает, использует то, то Хаскел умеет работать с функциями\r\n --- (сооружать из функций новые функции и т.д.) \r\nmyreverse xs = let len = length xs\r\n\r\n	      in foldr (x res -> (xs!!x):res) [] (foldr  (i res -> (len - i):res) [] [1..len])\r\n','<br/>Тесты успешно пройдены!'),(6153,56,'artem.gomerman','2013-10-07 23:32:44',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- (allLists n (k - 1))]\r\n','<br/>Тесты успешно пройдены!'),(6154,59,'artem.gomerman','2013-10-07 23:55:52',1,'#include <iostream>\r\n\r\n#include <time.h>\r\n\r\n#include <vector>\r\n\r\n#include <algorithm>\r\n\r\n\r\n\r\nstd::vector<unsigned int> nonZeroLastDigits(const std::vector<unsigned int>& arr)\r\n\r\n{\r\n\r\n	std::vector<unsigned int> mods;\r\n\r\n	mods.resize(arr.size());\r\n\r\n	std::transform(arr.begin(), arr.end(), mods.begin(), [](unsigned int i) {return i % 10;});\r\n\r\n	auto newModsEnd = std::remove_if(mods.begin(), mods.end(), [](unsigned int i){return i == 0;});\r\n\r\n	return std::vector<unsigned int>(mods.begin(), newModsEnd);\r\n\r\n}\r\n\r\n\r\n\r\nvoid printVector(const std::vector<unsigned int>& arr)\r\n\r\n{\r\n\r\n	for(auto it = arr.begin(); it != arr.end(); it++)\r\n\r\n	{\r\n\r\n		std::cout << *it << \" \";\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	srand(time(NULL));\r\n\r\n\r\n\r\n	const unsigned int testVectorsCount = rand() % 5 + 5;\r\n\r\n	for(unsigned int vectorIndex = 0; vectorIndex < testVectorsCount; vectorIndex++)\r\n\r\n	{\r\n\r\n		// generate vector\r\n\r\n		const unsigned int vectorSize = rand() % 10 + 5;\r\n\r\n		const unsigned int zeroEndingDigitIndex = rand() % vectorSize;\r\n\r\n		std::vector<unsigned int> testVector;\r\n\r\n		for(unsigned int i = 0; i < vectorSize; i++)\r\n\r\n		{\r\n\r\n			testVector.push_back(i == zeroEndingDigitIndex ? (rand() % 10) * 10 : rand() % 100);\r\n\r\n		}\r\n\r\n\r\n\r\n		// test nonZeroLastDigits\r\n\r\n		std::cout << \"Testing nonZeroLastDigits on vector: \";\r\n\r\n		printVector(testVector);\r\n\r\n		std::cout << \"\r\nResult vector: \";\r\n\r\n		printVector(nonZeroLastDigits(testVector));\r\n\r\n		std::cout << \"\r\n\r\n\";\r\n\r\n	}\r\n\r\n	system(\"pause\");\r\n\r\n	return 0;\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6149,56,'62628590','2013-10-07 21:44:48',1,'allLists _ 0 = [[]]\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k-1)]','<br/>Тесты успешно пройдены!'),(6150,47,'Artur','2013-10-07 23:02:09',1,'powerset xs = foldr (x res -> (map (ys -> x:ys) res) ++ res) [[]] xs\r\n','<br/>Тесты успешно пройдены!'),(6151,48,'Artur','2013-10-07 23:03:31',1,'myreverse xs =(foldr (i res -> res . ( xs -> (i:xs) ) )  id xs ) []\r\n','<br/>Тесты успешно пройдены!'),(6152,128,'Artur','2013-10-07 23:05:17',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace _11_10\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Func<int, Func<int, bool>> CheckDigitCurried =\r\n\r\n                    i =>{\r\n\r\n                        return j =>\r\n\r\n                                 {\r\n\r\n                                    int k = j;\r\n\r\n                                    while (k > 0)\r\n\r\n                                    {\r\n\r\n                                        if (k % 10 == i)\r\n\r\n                                            return true;\r\n\r\n                                        k /= 10;\r\n\r\n                                    }\r\n\r\n                                    return false;\r\n\r\n                                  };\r\n\r\n                        };\r\n\r\n            int[] arr = new int[5] { 1, 2, 3, 4, 5 };\r\n\r\n            Console.WriteLine(arr.All(CheckDigitCurried(2)));\r\n\r\n            arr = new int[4] { 7, 71, 217, 33733 };\r\n\r\n            Console.WriteLine(arr.All(CheckDigitCurried(7)));\r\n\r\n\r\n\r\n            Console.WriteLine(CheckDigitCurried(8)(123) + \" \" + CheckDigitCurried(8)(183));\r\n\r\n            Console.ReadLine();\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6148,48,'1170660','2013-10-07 18:45:09',1,'myreverse bs = foldr ( g x -> g (b : x)) id bs []\r\n','<br/>Тесты успешно пройдены!'),(6147,48,'1170660','2013-10-07 18:44:33',0,'reverse bs = foldr ( g x -> g (b : x)) id bs []\n','Не удалось вычислить выражение \"myreverse [1,2,3,4]\", проверьте правильность синтаксиса'),(6146,56,'1835693','2013-10-07 17:57:42',1,'allLists n 0 = [[]]\r\nallLists n k = [x : xs | x <- [1..n], xs <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(6143,47,'ArtemK','2013-10-07 16:47:41',1,'powerset xs = powerset\' xs []\r\npowerset\' [] curs = [curs]\r\npowerset\' (x:xs) curs = powerset\' xs (curs ++ [x]) ++ powerset\' xs curs','<br/>Тесты успешно пройдены!'),(6144,48,'ArtemK','2013-10-07 17:09:34',1,'-- Чуть не сломал мозг, исправляя ошибку в изначальном решении %)\r\n   --- Замечательно, это приятно:) (Что чуть не сломали мозг:):)\r\n-- А потом ошибку в исправленном решении...\r\n-- В итоге написал на бумаге в стиле матана, и победа! (:\r\nmyreverse xs = foldr (y f -> (zs -> f (y:zs))) id xs []','<br/>Тесты успешно пройдены!'),(6145,128,'ArtemK','2013-10-07 17:32:21',1,'# Python\r\n\r\ndef check_digit_curried(n):\r\n    def check_digit(i):\r\n        while i > 0:\r\n            if i % 10 == n:\r\n                return True\r\n            i /= 10\r\n        return False\r\n    return check_digit\r\n\r\n\r\n# Чтобы было красиво\r\ndef my_all(p, xs):\r\n    return all(p(n) for n in xs)\r\n\r\nprint(my_all(check_digit_curried(7), [17,172,73]))\r\n# True','<br/>Тесты успешно пройдены!'),(6142,48,'1835693','2013-10-07 16:33:23',1,'-- Из-за невозможности добавления в конец, будем использовать в качестве аккумулятора foldr функцию добавления последнего элемента в начало\r\nmyreverse list = foldr (x f xs -> f (x : xs)) id list []\r\n','<br/>Тесты успешно пройдены!'),(6140,129,'1835693','2013-10-07 13:39:31',1,'mymap op []   = []\r\nmymap op list = foldr (x xs -> (op x) : xs) [] list\r\n','<br/>Тесты успешно пройдены!'),(6141,47,'1835693','2013-10-07 16:03:59',2,'powerset = powerseth [[]]\r\n\r\npowerseth res [] = res\r\n-- Для каждого просмотренного элемента возможны два действия: добавить его в подсписки (addelem) или нет (в этом случае res не меняется)\r\npowerseth res (x:xs) = powerseth (addelem res x ++ res) xs\r\n   --- Так у вас в подсписках элементы будут идти в обратном порядке, мне кажется\r\n   --- Это очень просто, но исправьте пожалуйста как-нибудь\r\naddelem res e = map (e:) res','Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),(6139,53,'1835693','2013-10-07 13:28:03',1,'coins price = [ [a, b, c] | a <- [0..price], b <- [0..price], c <- [0..price], 2 * a + 3 * b + 5 * c == price]','<br/>Тесты успешно пройдены!'),(6138,54,'MaryK','2013-10-07 13:26:50',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),elem,Show(..),length,(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (==),(<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ndata Sheme a b c flag = Simple a | Complex (flag,b,c)\r\n\r\ndata Elem = Float\r\n\r\ntotalResistance (Complex(flag,b,c)) = if (flag==1) then b+c else (b+c)/2\r\n  --- Формула неправильгая:) Но, видимо, вы очень торопились:) \r\ntotalResistance (Simple a) = a  \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6136,53,'MaryK','2013-10-07 12:11:41',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),elem,Show(..),length,(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ncoins :: Int -> [ [Int] ]\r\n\r\ncoins n = [ [a, b, c] | \r\n\r\n    a <- [ 0 .. n],\r\n\r\n    b <- [ 0 .. n ],\r\n\r\n    c <- [ 0 .. n ],\r\n\r\n    a*2 + b*3 + c*5 == n ]\r\n','<br/>Тесты успешно пройдены!'),(6137,130,'1835693','2013-10-07 13:19:48',1,'trace = traceh 0\r\n\r\ntraceh _ [] = 0\r\ntraceh col (row:rows) = (traceh (col + 1) rows) + (row !! col)\r\n','<br/>Тесты успешно пройдены!'),(6134,53,'MaryK','2013-10-07 12:10:43',0,'module Func where\r\n\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),Show(..),(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\ncoins :: Int -> [ [Int] ]\r\n\ncoins n = [ [a, b, c] | \r\n\n    a <- [ 0 .. n],\r\n\n    b <- [ 0 .. n ],\r\n\n    c <- [ 0 .. n ],\r\n\n    a*2 + b*3 + c*5 == n ]\n','Не удалось вычислить выражение \"length (coins 10)\", проверьте правильность синтаксиса'),(6135,53,'MaryK','2013-10-07 12:11:10',0,'module Func where\r\n\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),Show(..),length,(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\ncoins :: Int -> [ [Int] ]\r\n\ncoins n = [ [a, b, c] | \r\n\n    a <- [ 0 .. n],\r\n\n    b <- [ 0 .. n ],\r\n\n    c <- [ 0 .. n ],\r\n\n    a*2 + b*3 + c*5 == n ]\n','Не удалось вычислить выражение \"elem [1,1,1] (coins 10)\", проверьте правильность синтаксиса'),(6130,130,'MaryK','2013-10-07 11:44:14',1,'module Func where\r\n\r\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),Show(..),(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ntrace ::[[Int]]->Int\r\n\r\ntrace x = sum (zipWith (!!) x [0..])\r\n  --- Очень хорошо, хорошее решение!\r\n','<br/>Тесты успешно пройдены!'),(6131,53,'5247795','2013-10-07 11:48:51',1,'coins n = [[k,l,m] | k <- [0..(div n 2)], l <- [0..(div n 3)], m <- [0..(div n 5)], 2*k+3*l+5*m == n]\r\n','<br/>Тесты успешно пройдены!'),(6132,54,'1170660','2013-10-07 12:04:40',1,'\r\ndata Scheme = Resist Double | Paralel Scheme Scheme| Seq Scheme Scheme\r\n\r\n\r\n\r\ntotalResistance(Resist resist) = resist\r\n\r\ntotalResistance(Seq seq1 seq2)= totalResistance seq1 + totalResistance seq2\r\n\r\ntotalResistance(Paralel par1 par2) = let res1 = totalResistance par1 \r\n\r\n                                         res2 = totalResistance par2 in res1 * res2 / (res1 + res2)\r\n','<br/>Тесты успешно пройдены!'),(6133,53,'MaryK','2013-10-07 12:10:04',0,'module Func where\r\n\nimport Prelude(Bool(..),zipWith,(!!),RealFloat(),Int(),Show(..),(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nf :: Int -> [ [Int] ]\r\n\nf n = [ [a, b, c] | \r\n\n    a <- [ 0 .. n],\r\n\n    b <- [ 0 .. n ],\r\n\n    c <- [ 0 .. n ],\r\n\n    a*2 + b*3 + c*5 == n ]\n','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(6129,130,'5247795','2013-10-07 11:36:07',1,'trace x = trace1 x 0\r\n\r\ntrace1 [] _ = 0\r\n\r\ntrace1 (xs:xss) n = (trace1 xss (n+1)) + xs!!n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6128,48,'42284313','2013-10-07 11:29:09',1,'{--\r\n\r\n\r\n\r\n*Доп задача, до 10.10*\r\n\r\nИспользуя _только_ функцию foldr и лямбда выражения опишите функцию myreverse, возвращающую элементы списка в обратном порядке.\r\n\r\nПример вызова:\r\n\r\nmyreverse [1, 2, 3]\r\n\r\nРезультат д.б. равен [3, 2, 1].\r\n\r\n\r\n\r\nДополнительные условия:\r\n\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.\r\n\r\n- Функция должна работать за линейное время. Технически это означает, что нельзя использовать операцию ++[x] или каким-то другим способом приписывать очередной элемент к концу списка на каждом шаге работы foldr.\r\n\r\n- Чтобы задача была немного еще посложнее, давайте пусть будет еще дополнительно условие - нельзя использовать пары (tuples). (И соответственно нельзя каким-то образом их имитировать, с помощью списков из двух элементов или data и т.д.)\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- Обратите внимание, надо использовать именно foldr, а не foldl. С foldl то все просто..\r\n\r\n- Эта задача не очень простая. Точнее, решение у нее довольно простое и короткое, но додуматься до него, м.б. и не так просто. Если не получиться, не расстраивайтесь..\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nmyreverse bs = foldr ( g x -> g (b : x)) id bs []\r\n','<br/>Тесты успешно пройдены!'),(6126,129,'1170660','2013-10-07 11:09:32',1,'mymap op xs   = foldr (y ys -> (op y):ys) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6127,47,'42284313','2013-10-07 11:16:42',1,'{--\r\n\r\n    Task 1\r\n\r\n    Описать функцию powerset, которая по списку порождает список из всех его подсписков.\r\n\r\n\r\n\r\n    Пример вызова:\r\n\r\n    powerset [1, 2, 3]\r\n\r\n    Результат д.б. равен [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]. (Порядок элементов в ответе м.б. и другим, как вам удобнее).\r\n\r\n--}\r\n\r\n\r\n\r\npowerset [] = [[]]\r\n\r\npowerset (x:xSet) = \r\n\r\n    let\r\n\r\n      ySet = powerset xSet\r\n\r\n      resultSet = map (element -> (x:element)) ySet\r\n\r\n    in foldr (:) resultSet ySet\r\n','<br/>Тесты успешно пройдены!'),(6123,53,'1170660','2013-10-07 10:48:42',0,'coins sum = [[x,y,z]|x<-[0..(sum `div` 2)],y<-[0..(sum `div`3)],z<-[0..(sum `div`5)],2*x+3*y+5*z==sum]\r\n\n\r\n\n\n','<br/>Тесты успешно пройдены!'),(6124,53,'1170660','2013-10-07 10:48:46',1,'coins sum = [[x,y,z]|x<-[0..(sum `div` 2)],y<-[0..(sum `div`3)],z<-[0..(sum `div`5)],2*x+3*y+5*z==sum]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6125,54,'42284313','2013-10-07 11:06:06',1,'{--\r\n\r\n\r\n\r\nПусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:\r\n\r\n- или сопротивление, тогда известно его величина в омах\r\n\r\n- или две схемы, соединенных параллельно\r\n\r\n- или две схемы, соединенных последовательно\r\n\r\n(На самом деле есть схемы, которые таким способом не описать, ну и ладно..)\r\n\r\n\r\n\r\n1. Опишите тип (data) Scheme, который позволяет описывать такие схемы.\r\n\r\n2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы.\r\n\r\n\r\n\r\nНапример, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2.\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- Для этой задачи тестов не будет, потому что я не знаю, как вы решите представлять схемы. Но я проверю задачи вручную.\r\n\r\n- Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ndata Scheme r = Resistance r | \r\n\r\n                Parallel (Scheme r) (Scheme r) |\r\n\r\n                Serial (Scheme r) (Scheme r)\r\n\r\n\r\n\r\ntotalResistance (Resistance resistance) = resistance\r\n\r\ntotalResistance (Serial resistance1 resistance2) = \r\n\r\n	totalResistance resistance1 + \r\n\r\n	totalResistance resistance2\r\n\r\ntotalResistance (Parallel resistance1 resistance2) =\r\n\r\n	let \r\n\r\n		r1 = totalResistance resistance1;\r\n\r\n		r2 = totalResistance resistance2;\r\n\r\n	in \r\n\r\n		(r1 * r2)/(r1 + r2)\r\n\r\n\r\n\r\n\r\n\r\ntotalResistance2 = totalResistance (Serial (Resistance(4)) (Resistance(4)))\r\n\r\ntotalResistance3 = totalResistance (Parallel (Resistance(4)) (Resistance(4)))\r\n\r\ntotalResistance4 = totalResistance (Serial (Serial(Resistance(4)) (Resistance(4))) (Parallel(Resistance(4)) (Resistance(4))))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6120,54,'nbumakov','2013-10-07 09:28:05',1,'data Scheme = Resistance Float | Parallel Scheme Scheme | Sequential Scheme Scheme\r\ntotalResistance (Parallel a b) =\r\n  let\r\n    r1 = totalResistance a\r\n    r2 = totalResistance b\r\n  in r1 * r2 / (r1 + r2)\r\ntotalResistance (Sequential a b) = totalResistance a + totalResistance b\r\ntotalResistance (Resistance r) = r','<br/>Тесты успешно пройдены!'),(6121,130,'1170660','2013-10-07 10:24:45',1,'trace xs = trace\' xs 0 0\r\n\r\ntrace\' [] temp num =temp\r\n\r\ntrace\' (x:xs) temp num = trace\' xs ((x!!num)+temp) (num+1)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6122,53,'42284313','2013-10-07 10:41:39',1,'{--\r\n\r\n\r\n\r\nПеречислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. Результат должен быть списком списков целых чисел, каждый внутренний список - это список из трех элементов [k,l,m], где k - двухкопеечных монет, l - количество трехкопеечных, m - количество пятикопеечных монет.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ncoins 10\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[[5,0,0],[2,2,0],[0,0,2],[1,1,1]]\r\n\r\n(порядок троек в ответе может быть и другим).\r\n\r\n\r\n\r\nЗамечание:\r\n\r\n- Вообще это упражнение на list comprehension. Но, если хотите, вы можете решить задачу и без list comprehension, как хотите.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ncoins n =\r\n\r\n	[[x, y, z] | x <- [0..(div n 2)], \r\n\r\n	             y <- [0..(div n 3)], \r\n\r\n	             z <- [0..(div n 5)], \r\n\r\n	             2 * x + 3 * y + 5 * z == n]\r\n','<br/>Тесты успешно пройдены!'),(6119,47,'2260659','2013-10-07 05:16:17',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) = powerset xs ++ map (x:) (powerset xs)\r\n','<br/>Тесты успешно пройдены!'),(6115,130,'3301494','2013-10-07 01:53:11',1,'trace xs = foldr ((xs, i) r -> r + (xs !! i)) 0 (zip xs [0..(length xs) - 1])\r\n','<br/>Тесты успешно пройдены!'),(6116,129,'MaryK','2013-10-07 02:37:31',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..),(.),foldl,foldr, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nmymap            :: (a -> b) -> [a] -> [b]\r\n\r\nmymap f []       = []\r\n\r\nmymap f (x:xs)   = foldr (x xs -> (f x):xs) [] (x:xs)\r\n','<br/>Тесты успешно пройдены!'),(6117,130,'641524','2013-10-07 02:53:14',1,'trace xs = last (foldl (s x -> [(head s)+1, (last s) + (x !! (head s))]) [0, 0] xs)\r\n','<br/>Тесты успешно пройдены!'),(6118,57,'3226573','2013-10-07 02:55:44',1,'-- Удаляет m-ый и n-ый элементы из массива, возвращает кортеж из полученного списка и удаленных элементов\r\n\r\nsplitList xs n m = let \r\n\r\n		     (x, t) = splitAt n xs\r\n\r\n		     (y, z) = splitAt (m - n) t		     \r\n\r\n		   in (x ++ (tail y) ++ (tail z), head y, head z)\r\n\r\n\r\n\r\n-- Удаляет n-ый элемент из массива, возвращает кортеж из полученного списка и удаленного элемента\r\n\r\nremoveElem xs n = let\r\n\r\n		    (x, y) = splitAt n xs\r\n\r\n		  in (x ++ (tail y), head y) 		 \r\n\r\n\r\n\r\ncanMakeScheme\' [] _ _ = False\r\n\r\ncanMakeScheme\' rs m needCheck = (needCheck && any ( == m) rs) || \r\n\r\n 				any ( == True) [canMakeScheme\' rss m False ||\r\n\r\n						(x < m && (canMakeScheme\' rss (m - x) True))\r\n\r\n						| n <- [0..(length rs - 1)], let (rss, x) = removeElem rs n] ||\r\n\r\n				any ( == True) [seq == m ||\r\n\r\n						par == m ||\r\n\r\n						canMakeScheme\' (seq:rss) m False ||\r\n\r\n						canMakeScheme\' (par:rss) m False \r\n\r\n						| n1 <- [0..(length rs) - 1], n2 <- [n1 + 1..(length rs) - 1], \r\n\r\n						  let (rss, x, y) = splitList rs n1 n2, let seq = x + y, let par = x * y / (x + y)]\r\n\r\n \r\n\r\ncanMakeScheme rs m = canMakeScheme\' rs m True\r\n','<br/>Тесты успешно пройдены!'),(6111,53,'1990147','2013-10-07 01:14:06',1,'coins n = mycoins n 5 ([0,0]) ([])\r\n\r\nmycoins n 5 ([a,b]) xs = if (n<5*a) then xs else mycoins n 3 ([a,b]) xs\r\n\r\n\r\n\r\nmycoins n 3 ([a,b]) xs = if (n<5*a+3*b) then mycoins n 5 ([a+1,0]) xs \r\n\r\n                         else if (mod (n-(5*a+3*b)) 2==0) then mycoins n 3 ([a,b+1]) (([div (n-(5*a+3*b)) 2,b,a]):xs)\r\n\r\n                              else mycoins n 3 ([a,b+1]) xs\r\n','<br/>Тесты успешно пройдены!'),(6112,129,'641524','2013-10-07 01:19:09',1,'mymap f xs = foldr (x res -> (f x):res) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6113,53,'3301494','2013-10-07 01:33:49',1,'coins n = [[a,b,c] | a <- [0..n], b <- [0..n], c <- [0..n], a * 2 + b * 3 + c * 5 == n]\r\n','<br/>Тесты успешно пройдены!'),(6114,54,'3301494','2013-10-07 01:39:22',1,'data Type = P | S\r\n\r\ndata Scheme = Resistance Double | Node Type Scheme Scheme \r\n\r\n\r\n\r\ntotalResistance (Resistance x) = x\r\n\r\ntotalResistance (Node S s1 s2) = totalResistance s1 + totalResistance s2\r\n\r\ntotalResistance (Node P s1 s2) = r1 * r2 / (r1 + r2) where r1 = totalResistance s1 r2 = totalResistance s2\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6106,130,'ilia','2013-10-07 00:10:11',1,'trace m = let\r\n\r\n		l = length m - 1\r\n\r\n	in\r\n\r\n		sum [ m !! i !! i | i <- [0..l] ]\r\n\r\n\r\n\r\nmain = print (trace [[1,2,3],[4,5,6],[7,8,9]])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6107,53,'1990147','2013-10-07 01:12:23',0,'coins n = mycoins n 5 ([0,0]) ([])\r\n\nmycoins n 5 ([a,b]) xs = if (n<5*a) then xs else mycoins n 3 ([a,b]) xs\r\n\n\r\n\nmycoins n 3 ([a,b]) xs = if (n<5*a+3*b) then mycoins n 5 ([a+1,0]) xs \r\n\n                         else if (mod (n-(5*a+3*b)) 2==0) then mycoins n 3 ([a,b+1]) (([a,b, div (n-(5*a+3*b)) 2]):xs)\r\n\n                              else mycoins n 3 ([a,b+1]) xs\n','Выражение имеет неправильное значение: coins 2'),(6108,48,'3226573','2013-10-07 01:12:31',1,'f x xs = (x:xs)\r\nmyreverse ls = (foldr (x res -> res . f x) id ls) []','<br/>Тесты успешно пройдены!'),(6109,129,'3301494','2013-10-07 01:13:48',1,'mymap f xs = foldr (x res -> ((f x):res)) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6110,53,'1990147','2013-10-07 01:13:56',0,'coins n = mycoins n 5 ([0,0]) ([])\r\n\nmycoins n 5 ([a,b]) xs = if (n<5*a) then xs else mycoins n 3 ([a,b]) xs\r\n\n\r\n\nmycoins n 3 ([a,b]) xs = if (n<5*a+3*b) then mycoins n 5 ([a+1,0]) xs \r\n\n                         else if (mod (n-(5*a+3*b)) 2==0) then mycoins n 3 ([a,b+1]) (([div (n-(5*a+3*b)) 2,b,a]):xs)\r\n\n                              else mycoins n 3 ([a,b+1]) xs\n','<br/>Тесты успешно пройдены!'),(6105,53,'ip','2013-10-07 00:01:17',1,'coins 0 = []\r\ncoins 1 = []\r\ncoins x = if ((mod x 2) == 0)\r\n          then c2 ((div x 2):0:0:[])\r\n          else c2 (((div x 2)-1):1:0:[])\r\n\r\nc2 (a:b:c) = if (a>2)\r\n           then (c5 (a:b:c)) ++ \r\n                (c2 ((a-3):(b+2):c))\r\n           else (c5 (a:b:c))\r\n\r\nc5 (a:b:c:[]) =  if ((a>0) & (b>0))\r\n   --- вот тут должно быть два амперсанда\r\n   --- А в остальном вроде бы все правильно\r\n               then ((a:b:c:[]):[]) ++ \r\n                    (c5 ((a-1):(b-1):(c+1):[]))\r\n               else ((a:b:c:[]):[])','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(6104,54,'1990147','2013-10-07 00:01:17',1,'  --- Андрей, вообще предполагается, что программа по крайней мере \r\n  --- компилируется, даже если тестов нет.\r\n  --- А вас, понятно, не компилируется (неизвестная функция countR)\r\n  --- Те засчитано, но в таких случаях могу и не засчитать,\r\n  --- постарайтесь быть внимательнее, пожалуйста \r\n\r\ndata Scheme = R Double | Onebyone Scheme Scheme | Parallel Scheme Scheme\r\n\r\n\r\ntotalResistance (R val)= val\r\ntotalResistance (Onebyone sc1 sc2) = (countR sc1)  + (countR sc2)\r\ntotalResistance (Parallel sc1 sc2) = 1/((1/(countR sc1))+(1/(countR sc2)))\r\n','<br/>Тесты успешно пройдены!'),(6101,130,'ip','2013-10-06 23:58:22',0,'trace xs = sdn (foldl f ((0,0)) xs )\r\n \r\nf x (a,b) = (a+1,b+(x !! a))','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6102,129,'ilia','2013-10-06 23:59:31',1,'mymap f m = foldr (i j -> f i : j) [] m\r\n\r\n\r\n\r\nmain = print (mymap (*3) [1,2,3])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6103,130,'ip','2013-10-07 00:00:21',1,'trace xs = sdn (foldl f (0,0) xs )\r\n --- Дб не sdn а snd, конечно.\r\n --- Засчитано, но вообщн желательно простые синтаксические ошибки исправлять.\r\nf x (a,b) = ((a+1),(b+(x !! a)))','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6095,54,'1990147','2013-10-06 23:43:45',0,'data Scheme = R Double | Onebyone Scheme Scheme | Parallel Scheme Scheme\r\n\n\r\n\ncountR (R val)= val\r\n\ncountR (Onebyone sc1 sc2) = (countR sc1)  + (countR sc2)\r\n\ncountR (Parallel sc1 sc2) = 1/((1/(countR sc1))+(1/(countR sc2)))\r\n\n\n','<br/>Тесты успешно пройдены!'),(6096,130,'ip','2013-10-06 23:45:23',0,'trace xs = head (foldl \r\n      (x (a:b:c) -> ((a+1):(b+(x !! a)):c))\r\n      ([0,0])\r\n      xs ) ','Выражение имеет неправильное значение: trace [[1,2,3],[4,5,6],[7,8,9]]'),(6097,130,'ip','2013-10-06 23:47:36',0,'trace xs = sdn (foldl \r\n                 (x (a,b) ->((a+1),(b+(x !! a))))\r\n                 (0,0)\r\n                 xs ) ','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6098,130,'ip','2013-10-06 23:54:49',0,'trace xs = sdn (foldl f (0,0) xs )\r\n \r\nf x (a,b) = ((a+1),(b+(x !! a)))','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6099,130,'ip','2013-10-06 23:56:41',0,'trace xs = sdn (foldl f (0,0) xs )\r\n \r\nf x (a,b) = (a+1,b+(x !! a))','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6100,130,'ip','2013-10-06 23:57:24',0,'trace xs = sdn (foldl f (0,0) xs )\r\n \r\nf x (a,b) = (a+1,b+(head x))','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6086,54,'ip','2013-10-06 23:15:00',1,'data Scheme = Simple Double |\r\n     Series Scheme Scheme |\r\n     Parallel Scheme Scheme\r\n\r\ntotalResistance x = tR x \r\n\r\ntR (Simple x) = x\r\ntR (Series x y) = tR x + tRe y\r\ntR (Parallel x y) = let a = tR x\r\n                        b = tR y\r\n                    in ((a*b)/(a+b))\r\n','<br/>Тесты успешно пройдены!'),(6087,129,'ip','2013-10-06 23:21:20',0,'mymap f xs = (x a -> (f a):x) [] xs','Не удалось вычислить выражение \"mymap (*3) [1,2,3]\", проверьте правильность синтаксиса'),(6088,129,'ip','2013-10-06 23:22:10',0,'mymap f xs = (x a -> (f a):x) [] xs','Не удалось вычислить выражение \"mymap (*3) [1,2,3]\", проверьте правильность синтаксиса'),(6089,129,'ip','2013-10-06 23:23:14',0,'mymap f xs = foldr (x a -> (f a):x) [] xs','Не удалось вычислить выражение \"mymap (*3) [1,2,3]\", проверьте правильность синтаксиса'),(6090,129,'ip','2013-10-06 23:23:38',0,'mymap f xs = foldr (x a -> ((f a):x)) [] xs','Не удалось вычислить выражение \"mymap (*3) [1,2,3]\", проверьте правильность синтаксиса'),(6091,129,'ip','2013-10-06 23:25:21',1,'mymap f xs = foldr (x a -> ((f x):a)) [] xs','<br/>Тесты успешно пройдены!'),(6092,130,'ip','2013-10-06 23:36:54',0,'trace xs = sdn (foldl \r\n      (x (a,b) ->((a+1),(b+(x !! a))))\r\n      (0,0)\r\n      xs ) ','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6093,130,'ip','2013-10-06 23:39:39',0,'trace xs = sdn (foldl \r\n      (x (a,b) -> ((a+1),(b+(x !! a))))\r\n      (0,0)\r\n      xs ) ','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6094,130,'ip','2013-10-06 23:43:20',0,'trace xs = head (foldl \r\n      (x (a:b:c) -> ((a+1):(b+(x !! a)):c))\r\n      [0,0]\r\n      xs ) ','Выражение имеет неправильное значение: trace [[1,2,3],[4,5,6],[7,8,9]]'),(6085,54,'ilia','2013-10-06 23:02:24',1,'data Scheme = \r\n\r\n	Raw Integer |\r\n\r\n	Par Scheme Scheme |\r\n\r\n	Seq Scheme Scheme\r\n\r\n\r\n\r\ntotalResistance (Raw i) = i\r\n\r\ntotalResistance (Par s1 s2) = let\r\n\r\n		s1i = totalResistance s1\r\n\r\n		s2i = totalResistance s2\r\n\r\n	in\r\n\r\n		div (s1i * s2i) (s1i + s2i)\r\n\r\ntotalResistance (Seq s1 s2) = totalResistance s1 + totalResistance s2\r\n\r\n\r\n\r\nmain = do\r\n\r\n	print (totalResistance (Raw 4))\r\n\r\n	print (totalResistance (Par (Raw 4) (Raw 4)))\r\n\r\n	print (totalResistance (Seq (Raw 4) (Raw 4)))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6083,53,'2260659','2013-10-06 22:55:50',1,'\r\ncoins x = [ [k,l,m] | k <- [0..x], l <-[0..x], m <-[0..x], 2*k + 3*l + 5*m == x ] \r\n','<br/>Тесты успешно пройдены!'),(6084,128,'artem.gomerman','2013-10-06 23:00:46',1,'#include <functional>\r\n\r\n#include <iostream>\r\n\r\n#include <time.h>\r\n\r\n\r\n\r\nstd::function<bool (int)> CheckDigitCurried(int n)\r\n\r\n{\r\n\r\n	return [n](int x)->bool {\r\n\r\n		if(0 <= n && n <= 9)\r\n\r\n		{\r\n\r\n			int mod = x;\r\n\r\n			int div = x;\r\n\r\n			do\r\n\r\n			{\r\n\r\n				mod = div % 10;\r\n\r\n				div /= 10;\r\n\r\n				if(mod == n)\r\n\r\n					return true;\r\n\r\n			} while(div != 0);\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	};\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	srand(time(NULL));\r\n\r\n\r\n\r\n	std::cout << std::boolalpha;\r\n\r\n\r\n\r\n	// generate random numbers and check \'CheckDigitCurried\' work\r\n\r\n	const unsigned int numbersCount = 10 + rand() % 10;\r\n\r\n	const unsigned int digitsCount = 10;\r\n\r\n	for(unsigned int i = 0; i < numbersCount; i++)\r\n\r\n	{\r\n\r\n		int testNumber = rand() % 1000000;\r\n\r\n		std::cout << \"test for number: \" << testNumber << std::endl;\r\n\r\n		for(unsigned int digit = 0; digit < digitsCount; digit++)\r\n\r\n		{\r\n\r\n			std::cout << \"there is digit \'\" << digit << \"\': \"  << CheckDigitCurried(digit)(testNumber) << std::endl;\r\n\r\n		}\r\n\r\n		std::cout << \"\r\n\";\r\n\r\n	}\r\n\r\n	system(\"pause\");\r\n\r\n	return true;\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6082,53,'ip','2013-10-06 22:51:29',0,'coins 0 = []\r\ncoins 1 = []\r\ncoins x = if ((mod x 2) == 0)\r\n          then c2 ((div x 2):0:0:[])\r\n          else c2 (((div x 2)-1):1:0:[])\r\n\r\nc2 a:b:c = if (a>2)\r\n           then (c5 (a:b:c)) ++ \r\n                (c2 ((a-3):(b+2):c))\r\n           else (c5 (a:b:c))\r\n\r\nc5 a:b:c:[] =  if ((a>0) & (b>0))\r\n               then ((a:b:c:[]):[]) ++ \r\n                    (c5 ((a-1):(b-1):(c+1):[]))\r\n               else ((a:b:c:[]):[])','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(6081,53,'ip','2013-10-06 22:49:45',0,'coins 0 = []\r\ncoins 1 = []\r\ncoins x = if ((mod x 2) == 0)\r\n          then c2 ((div x 2):0:0:[])\r\n          else c2 (((div x 2)-1):1:0:[])\r\n\r\nc2 a:b:c = if (a>2)\r\n           then (c5 (a:b:c)) ++ (c2 ((a-3):(b+2):c))\r\n           else (c5 (a:b:c))\r\n\r\nc5 a:b:c:[] =  if ((a>0) & (b>0))\r\n               then ((a:b:c:[]):[]) ++ \r\n                    (c5 ((a-1):(b-1):(c+1):[]))\r\n               else ((a:b:c:[]):[])\r\n                ','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(6076,129,'62628590','2013-10-06 22:16:39',1,'mymap a xs = foldr (x res -> a x:res) [] xs','<br/>Тесты успешно пройдены!'),(6077,130,'62628590','2013-10-06 22:17:28',1,'trace x = trace0 x 0\r\ntrace0 [] _ = 0\r\ntrace0 (x:xs) a = (trace0 xs (a+1)) + x!!a','<br/>Тесты успешно пройдены!'),(6078,53,'ilia','2013-10-06 22:34:18',1,'coins n = [ [ c2, c3, c5] | c2<-[0..n], c3<-[0..n], c5<-[0..n], 2*c2+3*c3+5*c5==n ]\r\n\r\n\r\n\r\nmain = print (coins 10)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6079,53,'bazhutin','2013-10-06 22:36:43',0,'coins c = [[x,y,z] | x <- [0..c], y <- [0..c], z <- [0..c],  2*x + 3*y + 5*z > c-1, 2*x + 3*y + 5*z < c + 1 ]','<br/>Тесты успешно пройдены!'),(6080,53,'bazhutin','2013-10-06 22:39:31',1,'coins c = [[x,y,z] | x <- [0..c], y <- [0..c], z <- [0..c],  2*x + 3*y + 5*z == c]','<br/>Тесты успешно пройдены!'),(6073,54,'bazhutin','2013-10-06 22:08:01',1,'data Scheme = Series Scheme  Scheme \r\n  		| Parallel Scheme Scheme \r\n		| Resistance Float\r\n\r\n\r\ntotalResistance (Series x y) = totalResistance x + totalResistance y \r\n\r\ntotalResistance (Parallel x y) = (totalResistance x * totalResistance y) / (totalResistance x + totalResistance y)\r\n  --- ОК, но так получится очень не эффективно.. Это мы завтра обсудим. \r\ntotalResistance  (Resistance x) = x','<br/>Тесты успешно пройдены!'),(6074,53,'62628590','2013-10-06 22:14:46',1,'coins n = [[k,l,m]|k <- [0..(div n 2)], l <- [0..(div n 3)], m <- [0..(div n 5)], 2*k+3*l+5*m == n]','<br/>Тесты успешно пройдены!'),(6075,54,'62628590','2013-10-06 22:16:09',1,'data Scheme a = Resist a|Paral (Scheme a) (Scheme a)|Posled (Scheme a) (Scheme a)\r\ntotalResistance (Posled x y) = totalResistance x + totalResistance y\r\ntotalResistance (Paral x y) =\r\n    let\r\n      rx = totalResistance x\r\n      ry = totalResistance y\r\n    in rx*ry/(rx+ry)\r\ntotalResistance (Resist a) = a','<br/>Тесты успешно пройдены!'),(6072,54,'2260659','2013-10-06 22:00:44',1,'data Scheme = Resistance Float\r\n\r\n		| Parallel Scheme Scheme \r\n\r\n		| Series Scheme Scheme \r\n\r\n\r\n\r\ntotalResistance (Resistance x) = x\r\n\r\ntotalResistance (Parallel x y) = 1/(1/totalResistance(x) + 1/totalResistance(y))\r\n\r\ntotalResistance (Series x y) = totalResistance(x) + totalResistance(y)\r\n','<br/>Тесты успешно пройдены!'),(6071,57,'115753099','2013-10-06 21:43:38',2,'-- Мб вам поможет: как построиить 6 из 13 7 3 2 :\r\n-- (13 последовательно 2) параллельно (7 последоовательно 3)\r\nimport Data.List\r\n\r\n\r\n\r\ndata Scheme = Resistance Double\r\n\r\n			| ConsistentResistance Scheme Scheme\r\n\r\n			| ParallelResistance Scheme Scheme\r\n\r\n\r\n\r\n--- doScheme(add element into current scheme) surScheme newElement\r\n\r\ndoScheme (Resistance r) newElement =\r\n\r\n	[(ConsistentResistance (Resistance r) (Resistance newElement)), (ParallelResistance (Resistance r) (Resistance newElement))]\r\n\r\ndoScheme (ConsistentResistance s1 s2) newElement =\r\n\r\n	[(ConsistentResistance (Resistance newElement) (ConsistentResistance s1 s2)), (ParallelResistance (Resistance newElement) (ConsistentResistance s1 s2))] ++\r\n\r\n	(map (x -> ConsistentResistance x s2) (doScheme s1 newElement)) ++\r\n\r\n	(map (x -> ConsistentResistance x s1) (doScheme s2 newElement))\r\n\r\ndoScheme (ParallelResistance s1 s2) newElement =\r\n\r\n	[(ConsistentResistance (Resistance newElement) (ParallelResistance s1 s2)), (ParallelResistance (Resistance newElement) (ParallelResistance s1 s2))] ++\r\n\r\n	(map (x -> ParallelResistance x s2) (doScheme s1 newElement)) ++\r\n\r\n	(map (x -> ParallelResistance x s1) (doScheme s2 newElement))\r\n\r\n\r\n\r\ndoScheme1 [] schemeList = schemeList\r\n\r\ndoScheme1 (x:xs) schemeList =\r\n\r\n	doScheme1 xs s\r\n\r\n	where (s,_) = mapAccumL (acc y -> ((doScheme y x) ++ acc, y)) [] schemeList\r\n\r\n\r\n\r\ndoScheme0 (x:xs) = doScheme1 xs [(Resistance x)]\r\n\r\n\r\n\r\ntotalResistance (Resistance r) = r\r\n\r\ntotalResistance (ConsistentResistance s1 s2) =\r\n\r\n	totalResistance s1 + totalResistance s2\r\n\r\ntotalResistance (ParallelResistance s1 s2) =\r\n\r\n	1 / (1 / (totalResistance s1) + 1 / (totalResistance s2))\r\n\r\n\r\n\r\ncalculateListResistance [] = []\r\n\r\ncalculateListResistance (x:xs) = (totalResistance x):(calculateListResistance xs)\r\n\r\n\r\n\r\ncanMakeScheme xs m = \r\n\r\n	foldr (x b-> b || (abs(x - m) < 0.1)) False (calculateListResistance (doScheme0 xs))\r\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 7'),(6065,129,'ArtemK','2013-10-06 20:56:01',1,'mymap f xs = foldr (x ys -> ((f x):ys)) [] xs','<br/>Тесты успешно пройдены!'),(6066,130,'2260659','2013-10-06 21:02:01',1,'getDiag m i = (m !! i) !! i\r\n\r\ntrace1 m 0 = getDiag m 0\r\n\r\ntrace1 m i = (trace1 m (i-1)) + (getDiag m i)\r\n\r\ntrace x = trace1 x ((length x) - 1)\r\n','<br/>Тесты успешно пройдены!'),(6067,130,'ArtemK','2013-10-06 21:24:28',1,'trace xs = sum (map (i -> xs !! i !! i) [0..(length xs)-1])','<br/>Тесты успешно пройдены!'),(6068,129,'bazhutin','2013-10-06 21:26:00',1,'mymap op list = foldr (x y -> (op x):y) [] list','<br/>Тесты успешно пройдены!'),(6069,129,'2260659','2013-10-06 21:26:13',1,'mymap func list = foldr (x xs -> (func x):xs) [] list\r\n','<br/>Тесты успешно пройдены!'),(6070,57,'115753099','2013-10-06 21:39:52',0,'import Data.List\n\n\n\ndata Scheme = Resistance Double\n\n			| ConsistentResistance Scheme Scheme\n\n			| ParallelResistance Scheme Scheme\n\n\n\n--- doScheme(add element into current scheme) surScheme newElement\n\ndoScheme (Resistance r) newElement =\n\n	[(ConsistentResistance (Resistance r) (Resistance newElement)), (ParallelResistance (Resistance r) (Resistance newElement))]\n\ndoScheme (ConsistentResistance s1 s2) newElement =\n\n	[(ConsistentResistance (Resistance newElement) (ConsistentResistance s1 s2)), (ParallelResistance (Resistance newElement) (ConsistentResistance s1 s2))] ++\n\n	(map (x -> ConsistentResistance x s2) (doScheme s1 newElement)) ++\n\n	(map (x -> ConsistentResistance x s1) (doScheme s2 newElement))\n\ndoScheme (ParallelResistance s1 s2) newElement =\n\n	[(ConsistentResistance (Resistance newElement) (ParallelResistance s1 s2)), (ParallelResistance (Resistance newElement) (ParallelResistance s1 s2))] ++\n\n	(map (x -> ParallelResistance x s2) (doScheme s1 newElement)) ++\n\n	(map (x -> ParallelResistance x s1) (doScheme s2 newElement))\n\n\n\ndoScheme1 [] schemeList = schemeList\n\ndoScheme1 (x:xs) schemeList =\n\n	doScheme1 xs s\n\n	where (s,_) = mapAccumL (acc y -> ((doScheme y x) ++ acc, y)) [] schemeList\n\n\n\ndoScheme0 (x:xs) = doScheme1 xs [(Resistance x)]\n\n\n\ntotalResistance (Resistance r) = r\n\ntotalResistance (ConsistentResistance s1 s2) =\n\n	totalResistance s1 + totalResistance s2\n\ntotalResistance (ParallelResistance s1 s2) =\n\n	1 / (1 / (totalResistance s1) + 1 / (totalResistance s2))\n\n\n\ncalculateListResistance [] = []\n\ncalculateListResistance (x:xs) = (totalResistance x):(calculateListResistance xs)\n\n\n\ncanMakeScheme xs m = \n\n	foldr (x b-> b || (x == m)) False (calculateListResistance (doScheme0 xs))\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),(6064,54,'ArtemK','2013-10-06 20:51:54',1,'data Scheme = ParallelScheme Scheme Scheme | SerialScheme Scheme Scheme | Resistor Double\r\ntotalResistance (ParallelScheme a b) =\r\n    let { ra = totalResistance a; rb = totalResistance b} in\r\n        (ra * rb) / (ra + rb)\r\ntotalResistance (SerialScheme a b) = (totalResistance a) + (totalResistance b)\r\ntotalResistance (Resistor r) = r','<br/>Тесты успешно пройдены!'),(6063,53,'ArtemK','2013-10-06 20:17:43',1,'coins n = [[x,y,z] | x <- [0..(div n 2)], y <- [0..(div n 3)], z <- [0..(div n 5)], 2*x + 3*y + 5*z == n]','<br/>Тесты успешно пройдены!'),(6062,128,'3320654','2013-10-06 20:05:07',1,'using System;\r\nusing System.Linq;\r\nnamespace ConsoleApplication4\r\n{\r\n    class Program\r\n    {\r\n        static Func<A, Func<B, Answer>> Curry<A, B, Answer>(Func<A, B, Answer> func)\r\n        {\r\n            return x => y => func(x, y);\r\n        }\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] a = { 156, 143, 212, 331, 4123, 512, 62341, 712, 81, 129, 1034, 1331 };                                    \r\n            Func<int, int, bool> check = (x, y) =>\r\n            {                \r\n                while (y > 0)\r\n                {\r\n                    if (y % 10 == x)\r\n                        return true;\r\n                    y /= 10;                    \r\n                }\r\n                return false;\r\n            };\r\n            Func<int, Func<int, bool>> CheckDigitCurried = Curry(check);\r\n            Console.WriteLine(a.All(CheckDigitCurried(1)));       \r\n            Console.ReadKey();\r\n        }              \r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6061,130,'bazhutin','2013-10-06 19:51:01',1,'trace [[x]] = x\r\ntrace (x:xs) = x!!0  + trace2 (xs) 1\r\n\r\ntrace2 ([]) i = 0\r\ntrace2 ([x]) i = x!!i\r\ntrace2 (x:xs) i =  x!!i + trace2 (xs) (i+1)','<br/>Тесты успешно пройдены!'),(6057,130,'3320654','2013-10-06 18:29:14',1,'trace (xs:xss) = trace\' 0 (xs:xss)\r\n\r\ntrace\' _ []	       = 0\r\ntrace\' n (xs:xss) = (xs !! n) + (trace\' (n + 1) xss)','<br/>Тесты успешно пройдены!'),(6058,56,'3320654','2013-10-06 19:23:19',1,'allLists n k = fst ((repeatFunc f k) ([[]],n))\r\n\r\nrepeatFunc f n = foldl (g x -> f.g) (x -> x) [1..n]\r\n\r\nf (list,n) = ([y:x | y <- [1..n], x <- list],n)\r\n--- Здорово, хорошая идея, но красивее получится, если f описать как вложенную функцию, \r\n--- тогда не надо будет передавать n \r\n---  allLists n k = repeatFunc f k [[]] where \r\n---       f list = [y:x | y <- [1..n], x <- list]','<br/>Тесты успешно пройдены!'),(6059,130,'bazhutin','2013-10-06 19:42:31',0,'trace [[x]] = x\r\ntrace (x:xs) = x!!0  + trace2 (xs) 1\r\n\r\ntrace2 ([]) i = 0\r\ntrace2 ([x]) i = x!!i\r\ntrace2 (x:xs) i =  x!!i + trace2 (xs) 2\r\n','<br/>Тесты успешно пройдены!'),(6060,59,'3320654','2013-10-06 19:42:51',1,'using System;\r\nusing System.Linq;\r\nnamespace ConsoleApplication3\r\n{\r\n    class Program\r\n    {\r\n        static int[] nonZeroLastDigits(int[] a)\r\n        {\r\n            return a.Select(x => x % 10).Where(x => x > 0).ToArray();\r\n        }\r\n        public static void Main(string[] args)\r\n        {\r\n            int[] a = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };\r\n            int[] b = nonZeroLastDigits(a);\r\n            for (int i = 0; i < b.Length; i++)\r\n            {                \r\n                Console.WriteLine(b[i]);\r\n            }            \r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6055,129,'3320654','2013-10-06 18:22:30',1,'mymap f list = foldr ((:).f) [] list','<br/>Тесты успешно пройдены!'),(6056,130,'3320654','2013-10-06 18:26:13',0,'trace (xs:xss) = trace\' 0 (xs:xss)\r\n\r\ntrace\' _ []	       = 0\r\ntrace\' n (xs:xss) = (xs !! n) + (trace\' (n + 1) xss)','<br/>Тесты успешно пройдены!'),(6050,47,'3320654','2013-10-06 17:30:46',1,'--пришлось искусственно прибавлять\r\npowerset list 	 = []:powerset\' list (2^(length list) - 1)	 \r\n\r\n--потому что это съедается \"синтаксическим сахаром\"\r\n   --- А в чем была проблема с синтаксическим сахаром, я не очень понял?\r\n   --- Если это имеет смысл обсудить, напишите мне письмо на эту тему, обсудим. \r\npowerset\' _ 0	= []\r\npowerset\' list n	= (getSubList list (getBinary n)):(powerset\' list (n - 1))\r\n\r\ngetSubList _ []	 = []\r\ngetSubList (x:xs) (y:ys) = if y == 1\r\n		     then x:(getSubList xs ys)\r\n		     else (getSubList xs ys)\r\n\r\ngetBinary 0 = []\r\ngetBinary n = (mod n 2):(getBinary (div n 2))\r\n','<br/>Тесты успешно пройдены!'),(6051,129,'480387','2013-10-06 17:33:27',1,'mymap f xs = \r\n			foldr (x y -> (f x) : y ) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6052,53,'3320654','2013-10-06 17:40:12',1,'coins n = [[k,l,m] | k <- [0..(div n 2)], l <- [0..(div n 3)], m <- [0..(div n 5)], 2 * k + 3 * l + 5 * m == n]','<br/>Тесты успешно пройдены!'),(6053,130,'480387','2013-10-06 17:42:42',1,'trace xs = trace\' 0 0 (length xs) xs\r\ntrace\' sum i len xs = if (i == len)\r\n						then sum\r\n						else trace\' (sum + (xs!!i)!!i) (i+1) len xs','<br/>Тесты успешно пройдены!'),(6054,54,'3320654','2013-10-06 18:07:34',1,'data Sheme = Resistance Double |\r\n	    Parallel Sheme Sheme |\r\n	    Series Sheme Sheme\r\n\r\ntotalResistance (Resistance n)	= n\r\ntotalResistance (Parallel x y)	= let \r\n				z = totalResistance x\r\n				w = totalResistance y\r\n			   in\r\n				z * w / (z + w)\r\ntotalResistance (Series x y)	= totalResistance x + totalResistance y\r\n\r\n--totalResistance test\r\n--1.33333...\r\ntest = Parallel (Series (Resistance 1) (Resistance 3)) (Parallel (Resistance 4) (Resistance 4))','<br/>Тесты успешно пройдены!'),(6046,54,'12828920','2013-10-06 16:07:56',1,'data Scheme = Val Float |\r\n\r\n            Parallel Scheme Scheme | Serial Scheme Scheme\r\n\r\n			\r\n\r\ntotalResistance (Val x) = x\r\n\r\ntotalResistance (Parallel s1 s2) = 1/(1/(totalResistance s1) + 1/(totalResistance s2))\r\n\r\ntotalResistance (Serial s1 s2) = totalResistance s1 + totalResistance s2\r\n','<br/>Тесты успешно пройдены!'),(6047,129,'12828920','2013-10-06 16:11:03',1,'mymap func xs = foldr (i k->(func i):k) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6048,130,'12828920','2013-10-06 16:49:37',1,'trace xs = foldr (i k->k+((xs!!i)!!i)) 0 [0..(length xs)-1]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6049,54,'8519021','2013-10-06 16:54:10',1,'data Scheme = Resistance Double | SeriesCircuits Scheme Scheme | ParallelCircuits Scheme Scheme\r\n\r\ntotalResistance rScheme =\r\n\r\n  case rScheme of\r\n\r\n    (Resistance r) -> r\r\n\r\n    (SeriesCircuits scheme1 scheme2) -> let \r\n\r\n											r1 = totalResistance scheme1\r\n\r\n											r2 = totalResistance scheme2\r\n\r\n								        in r1 + r2\r\n\r\n    (ParallelCircuits scheme1 scheme2) -> let \r\n\r\n											r1 = totalResistance scheme1\r\n\r\n											r2 = totalResistance scheme2\r\n\r\n										  in r1 * r2 / (r1 + r2)\r\n\r\n{-- totalResistance (SeriesCircuits (Resistance 4) (Resistance 4))\r\n\r\n	totalResistance (ParallelCircuits (Resistance 4) (Resistance 4)) --}\r\n','<br/>Тесты успешно пройдены!'),(6044,53,'12828920','2013-10-06 15:42:09',1,'coins n = [[k,l,m] | k<-[0..div n 2], l<-[0..div n 3], m<-[0..div n 5], 2*k+3*l+5*m == n]\r\n','<br/>Тесты успешно пройдены!'),(6045,129,'42284313','2013-10-06 16:05:30',1,'{--\r\n\r\n\r\n\r\nИспользуя _только_ функцию foldr и лямбда выражения опишите функцию mymap, которая делает точно то же, что и стандартная функция map.\r\n\r\nПример вызова:\r\n\r\nmymap (*3) [1, 2, 3]\r\n\r\nРезультат д.б. равен [3, 6, 9].\r\n\r\n\r\n\r\nДополнительные условия:\r\n\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.\r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\nmymap f xs = foldr ((:) . f) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6042,54,'617015','2013-10-06 15:33:20',1,'--схема - бинарное дерево, \r\n\r\n--левое поддерево - сопротивления, соедиденные с узлом послеовательно, правое - параллельно\r\n  --- Мне кажется, так не все схемы получится представить\r\n  --- Например a и b параллельно и потом последовательно с ними c и d параллельно.\r\n  --- Мне кажется, вали формулы такое не считают? \r\n\r\ndata Scheme = Empty | Res Double Scheme Scheme deriving (Show) \r\n\r\n\r\n\r\ntotalResistance Empty = 0\r\n\r\ntotalResistance (Res val l Empty) = totalResistance l + val\r\n\r\ntotalResistance (Res val l r) =  (1/(left + val)) + (1/(right)) \r\n  --- И тут формула не совсем правильная, надо еще раз взять обратное \r\n								where\r\n\r\n								left = totalResistance l\r\n\r\n								right = totalResistance r\r\n','<br/>Тесты успешно пройдены!'),(6043,129,'5247795','2013-10-06 15:40:32',1,'mymap f []       = []\r\n --- Первое правило не нужно...\r\nmymap f xs   = foldr (y ys -> (f y):ys) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6040,129,'284427','2013-10-06 14:50:45',1,'mymap f xs = foldr (x y -> (f x) : y) [] xs\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6041,130,'42284313','2013-10-06 15:23:33',1,'{--\r\n\r\n\r\n\r\n\"След матрицы\"\r\n\r\n\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию trace n, которая для данной квадратной матрицы возвращает сумму ее диагональных элементов.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntrace [[1,2,3],[4,5,6],[7,8,9]]\r\n\r\nДолжно получиться 15 (сумма 1+5+9).\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- В этой задаче может быть удобно использовать оператор xs !! n, который возвращает n-ный элемент списка xs. Элементы нумеруются с 0, т.е. xs !! 0 - это то же, что head xs.\r\n\r\n- Можно считать, что мы точно знаем, что матрица квадратная. Если список не соответствует квадратной матрице (содержит строки разной длины и т.д.), то функция может вести себя как угодно. \r\n\r\n\r\n\r\n--}\r\n\r\n\r\n\r\ntrace\' matrix rest index\r\n\r\n	| rest == 0 = (0)\r\n\r\n	| otherwise =\r\n\r\n		let\r\n\r\n			result = trace\' matrix (rest - 1) (index + 1)\r\n\r\n		in\r\n\r\n			(result + ((matrix !! index) !! index))\r\n\r\n\r\n\r\ntrace matrix = trace\' matrix (length matrix) (0)\r\n','<br/>Тесты успешно пройдены!'),(6039,130,'284427','2013-10-06 14:35:53',1,'trace xs = trace1 xs (length xs) 0\r\n\r\n\r\n\r\ntrace1 xs l k = \r\n\r\n	if (k < l)\r\n\r\n	then ((xs !! k) !! k) + trace1 xs l (k+1)\r\n\r\n	else 0\r\n','<br/>Тесты успешно пройдены!'),(6038,54,'284427','2013-10-06 14:11:27',1,'data Scheme a = Res a | Seq (Scheme a) (Scheme a) | Par (Scheme a) (Scheme a)\r\n\r\n\r\n\r\ntotalResistance (Res a) = a\r\n\r\ntotalResistance (Seq a b) = totalResistance a + totalResistance b  \r\n\r\ntotalResistance (Par a b) =\r\n\r\n	let \r\n\r\n		at = totalResistance a\r\n\r\n		bt = totalResistance b\r\n\r\n	in\r\n\r\n	at*bt / (at + bt)\r\n','<br/>Тесты успешно пройдены!'),(6033,56,'toskira','2013-10-06 10:59:42',1,'allLists n 0 = [[]]\r\nallLists n k = [(h:t) | h <- [1..n], t <- (allLists n (k-1))]','<br/>Тесты успешно пройдены!'),(6034,48,'artem.gomerman','2013-10-06 13:53:14',1,'myreverse xs = foldr (x g ys -> g (x:ys)) id xs []\r\n','<br/>Тесты успешно пройдены!'),(6035,53,'284427','2013-10-06 14:02:45',0,'coins n = [[x1, x2, x3] | x1 <- [0..(div n 5)], x2 <- [0..(div n 3)], x3 <- [0..(div n 2)], 5*x1 + 3*x2 + 2*x3 == n]\n','Выражение имеет неправильное значение: coins 2'),(6036,53,'284427','2013-10-06 14:03:30',1,'coins n = [[x1, x2, x3] | x1 <- [0..(div n 2)], x2 <- [0..(div n 3)], x3 <- [0..(div n 5)], 2*x1 + 3*x2 + 5*x3 == n]\r\n','<br/>Тесты успешно пройдены!'),(6037,54,'284427','2013-10-06 14:09:16',0,'data Scheme a = Res a | Seq (Scheme a) (Scheme a) | Par (Scheme a) (Scheme a)\r\n\n\r\n\ntotalResistance (Res a) = a\r\n\ntotalResistance (Seq a b) = totalResistance a + totalResistance b  \r\n\ntotalResistance (Par a b) =\r\n\n	let at = totalResistance a\r\n\n		bt = totalResistance b\r\n\n	in\r\n\n	at*bt / (at + bt)\n','<br/>Тесты успешно пройдены!'),(6032,53,'517309','2013-10-06 10:12:54',3,'coins n = [[k,l,m] | k <- [0..(n `div` 2)], \r\n\r\n                     l <- [0..(n - 2 * k) `div` 3],\r\n\r\n                     let r = (n - 2 * k - 3 * l), let m = r `div` 5, (r `mod` 5) == 0]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6029,129,'1990147','2013-10-06 03:32:15',1,'mymap f arr = foldr (x res -> f x : res) [] arr\r\n','<br/>Тесты успешно пройдены!'),(6030,53,'517309','2013-10-06 10:10:08',0,'coins n = [(k,l,m) | k <- [0..(n `div` 2)], \r\n\r\n                     l <- [0..(n - 2 * k) `div` 3],\r\n\r\n                     let r = (n - 2 * k - 3 * l), let m = r `div` 5, (r `mod` 5) == 0]\r\n\r\n','Выражение имеет неправильное значение: coins 2'),(6031,53,'517309','2013-10-06 10:12:01',0,'coins n = [(k,l,m) | k <- [0..(n `div` 2)], \r\n            l <- [0..(n - 2 * k) `div` 3],\r\n            let r = (n - 2 * k - 3 * l),\r\n            let m = r `div` 5, (r `mod` 5) == 0]','Выражение имеет неправильное значение: coins 2'),(6026,129,'54411321','2013-10-06 02:19:07',1,'mymap f s = foldr (x res -> (f x):res) [] s\r\n','<br/>Тесты успешно пройдены!'),(6027,130,'54411321','2013-10-06 02:19:33',1,'trace m = foldr (x res ->  res + (m !! x) !! x) 0 [0..(length m - 1)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6028,130,'1990147','2013-10-06 03:01:43',1,'trace n = summ n 0\r\n\r\n\r\n\r\nsumm [] s = 0\r\n\r\nsumm (x:xs) s = x!!s + summ xs (s+1)\r\n','<br/>Тесты успешно пройдены!'),(6024,53,'54411321','2013-10-06 02:14:21',1,'  --- У вас все правильно и даже очень хорошо, но в условии речь шла о списках\r\n  --- аз 3 элементов, а у вас наборы. Из за этого ошибка.\r\n  --- Вы, кстати первый, кто заметили оптимизацию с пятерками (из 30 решения примерно!)\r\n  --- Поэтому пожалуйста никому про нее не говорите, посмотрим, кто еще заметит:)  \r\ncoins n = [(k,l,m) | k <- [0..(n `div` 2)], \r\n\r\n                     l <- [0..(n - 2 * k) `div` 3],\r\n\r\n                     let r = (n - 2 * k - 3 * l), let m = r `div` 5, (r `mod` 5) == 0]\r\n\r\n\r\n','Выражение имеет неправильное значение: coins 2'),(6025,54,'54411321','2013-10-06 02:18:35',1,'data Scheme =  R Float | \r\n\r\n            ParallelScheme Scheme Scheme |\r\n\r\n            SeriesScheme Scheme Scheme            \r\n\r\n\r\n\r\ntotalResistance (R r) = r\r\n\r\ntotalResistance (ParallelScheme s1 s2) = ((totalаistance s1) * (totalResistance s2)) / ((totalResistance s1) + (totalResistance s2))\r\n   --- А вот тут вы как раз нечаяно написали очень неэффективно :)\r\n   --- Конечно, не надо считать Resрекурсивные вызовы по 2 раза,\r\n   --- для рекурсии это очень существенно\r\n\r\ntotalResistance (SeriesScheme s1 s2) = (totalResistance s1) + (totalResistance s2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(6021,47,'artem.gomerman','2013-10-06 00:03:13',1,'import Data.Bits\r\n\r\n\r\n\r\npowerset [] = [[]]\r\n\r\npowerset xs = let \r\n\r\n	indices = generateIndices (2 ^ (length xs) - 1) ((length xs) - 1) in map (ys -> map (y -> xs!!y) ys) indices\r\n\r\n	\r\n\r\ngenerateIndices n m = map (x -> (filter (y -> testBit (x::Int) (y::Int)) [0..m])) [0..n]\r\n','<br/>Тесты успешно пройдены!'),(6022,56,'55363692','2013-10-06 01:21:03',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [i:xs | i <- [1..n], xs <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(6023,53,'54411321','2013-10-06 02:12:25',0,'coins n = [(k,l,m) | k <- [0..(n `div` 2)], \n\n                     l <- [0..(n - 2 * k) `div` 3],\n\n                     let r = (n - 2 * k - 3 * l), let m = r `div` 5, (r `mod` 5) == 0]\n\n\n','Выражение имеет неправильное значение: coins 2'),(6017,130,'2501950','2013-10-05 23:02:05',1,'diag i xss = (xss !! (i-1)) !! (i-1)   \r\ntrace xss = trace\' (length (map sum xss)) xss   \r\n  --- очень хорошо, но тут мне кажется map sum ни к чему. Просто length xss выдаст тот же резуьтат\r\n\r\ntrace\' 0 xss = 0  \r\ntrace\' i xss = trace\' (i-1) xss + diag i xss','<br/>Тесты успешно пройдены!'),(6018,54,'artem.gomerman','2013-10-05 23:05:26',1,'data Connection = Parallel | Series deriving (Eq, Ord, Show)\r\n\r\ndata Scheme = Resistance Float | Subscheme Scheme Connection Scheme deriving (Show)\r\n\r\n\r\n\r\ntotalResistance (Resistance resistance) = resistance\r\n\r\ntotalResistance (Subscheme scheme1 connection scheme2) = let \r\n\r\n	r1 = totalResistance scheme1\r\n\r\n	r2 = totalResistance scheme2 in if connection == Parallel then r1 * r2 / (r1 + r2) else r1 + r2\r\n','<br/>Тесты успешно пройдены!'),(6019,130,'8519021','2013-10-05 23:23:47',1,' trace n = foldl (+) 0 [((n !! i) !! i) | i<-[0..(length n - 1)]]\r\n','<br/>Тесты успешно пройдены!'),(6020,47,'artem.gomerman','2013-10-06 00:02:43',0,'import Data.Bits\r\n\n\r\n\npowerset [] = []\r\n\npowerset xs = let \r\n\n	indices = generateIndices (2 ^ (length xs) - 1) ((length xs) - 1) in map (ys -> map (y -> xs!!y) ys) indices\r\n\n	\r\n\ngenerateIndices n m = map (x -> (filter (y -> testBit (x::Int) (y::Int)) [0..m])) [0..n]\n','Выражение имеет неправильное значение: powerset []'),(6015,130,'2501950','2013-10-05 22:22:10',2,'diag (i+1) xss = (xss !! i) !! i\r\n   --- слева от = нельзя писать i+1\r\n   --- слева можно писать имена переменных, но не арифметические выражения\r\ntrace xss = trace\' (length (map sum xss)) xss \r\ntrace\' 0 xss = 0  \r\ntrace\' i xss = trace\' (i-1) xss + diag i xss ','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(6016,59,'115753099','2013-10-05 22:41:37',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication\r\n{\r\n    class Program\r\n    {\r\n        static int[] f(int [] mas)\r\n        {\r\n            return (mas.Where(x => x % 10 != 0).ToArray()).Select(x => x % 10).ToArray();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int [] mas = new int[]{4,14,54,60};\r\n            foreach (var i in f(mas))\r\n            {\r\n                Console.WriteLine(i.ToString());\r\n            }\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(6014,54,'SNNatalieS','2013-10-05 22:15:29',1,'data Scheme = Resistor Double |\r\n				Paral Scheme Scheme |\r\n				Serial Scheme Scheme\r\n				\r\ntotalResistance (Resistor val) = val\r\ntotalResistance (Paral s1 s2) = 1 / totalResistance s1 + 1 / totalResistance s2\r\n   --- Тут, на самом деле, неправильная формула:) Но ОК, это не так важно, засчитано.\r\ntotalResistance (Serial s1 s2) = totalResistance s1 + totalResistance s2\r\n\r\n--t = res (Paral (Serial (Resistor 5) (Resistor 3)) (Serial (Resistor 2) (Resistor 6)))','<br/>Тесты успешно пройдены!'),(6013,54,'6053606','2013-10-05 22:00:07',1,'data Scheme = Resistance Double\r\n            | Par Scheme Scheme\r\n            | Seq Scheme Scheme\r\n\r\ntotalResistance (Resistance r) = r\r\ntotalResistance (Seq s1 s2) = totalResistance s1 + totalResistance s2\r\ntotalResistance (Par s1 s2) = let r1 = totalResistance s1\r\n                                  r2 = totalResistance s2\r\n                              in r1 * r2 / (r1 + r2)\r\n','<br/>Тесты успешно пройдены!'),(6006,130,'6053606','2013-10-05 21:10:35',1,'trace xs = sum $ zipWith (!!) xs [0..]\r\n','<br/>Тесты успешно пройдены!'),(6007,54,'2501950','2013-10-05 21:15:45',1,'data Scheme =\r\n Resistance |\r\n    --- Не совсем так, ведь при сопротивлении надо хранить его значение (число) \r\n Sequentially Scheme Scheme  |  \r\n Concurrently Scheme Scheme\r\n\r\ntotalResistance Resistance = Resistance\r\ntotalResistance (Sequentially scheme1 scheme2) = \r\n scheme1 + scheme2\r\n   --- Не совсем так. Ведь scheme1 и scheme2 - это не числа, это схемы.\r\n   --- Те надо сначала сосчитать их сопротивления, а потом уж складывать\r\ntotalResistance (Concurrently scheme1 scheme2) =\r\n scheme1*scheme2/(scheme1 + scheme2)\r\n   --- И тут тоже.\r\n--- Попробуйте это исправить, пожалуйста. Но если вдруг не получится,\r\n--- можете снова выожить это решение, я его зачту.\r\n','<br/>Тесты успешно пройдены!'),(6008,53,'artem.gomerman','2013-10-05 21:31:49',1,'coins n = [ [k, l, m] | k <- [0..n], l <- [0..n], m <- [0..n], 2 * k + 3 * l + 5 * m == n]\r\n','<br/>Тесты успешно пройдены!'),(6009,129,'2501950','2013-10-05 21:32:22',1,'mymap f xs = foldr (x xs -> (f x):xs) [] xs  ','<br/>Тесты успешно пройдены!'),(6010,53,'6053606','2013-10-05 21:45:07',1,'coins n = [ [i, j, k]\r\n          | i <- [0..n `div` 2]\r\n          , j <- [0..n `div` 3]\r\n          , k <- [0..n `div` 5]\r\n          , i * 2 + j * 3 + k * 5 == n\r\n          ]\r\n','<br/>Тесты успешно пройдены!'),(6011,129,'artem.gomerman','2013-10-05 21:51:43',1,'mymap f xs = foldr (x res -> f x : res) [] xs\r\n','<br/>Тесты успешно пройдены!'),(6012,130,'artem.gomerman','2013-10-05 21:59:01',1,'trace xxs = sum (map (x -> (xxs !! x) !! x) [0..((length xxs) - 1)])\r\n','<br/>Тесты успешно пройдены!'),(6002,53,'2501950','2013-10-05 20:16:00',1,'coins n = [[x,y,z] | x <- [0..n], y <- [0..n], \r\n z <- [0..n], 2*x+3*y+5*z == n ]','<br/>Тесты успешно пройдены!'),(6003,54,'SNNatalieS','2013-10-05 20:50:34',2,'data Scheme = Resistor Double |\r\n				Paral Double Scheme |\r\n				Serial Double Scheme\r\n				deriving Show\r\n--- вообще хорошо, но так можно выразить не все схемы. Предсьавьте, например\r\n--- такую схему:\r\n---     +--- 5 --- 3 ---+\r\n---   --|               |				\r\n---     +--- 2 --- 6 ---+\r\n--- Те две пары соедиеняем последовательно, и все весте параллельно\r\n--- У вас, мне кажется, такую схему не представить. Попробуйте это исправить?\r\n--- Но если не получится, можете выложить еще раз эту вашу программу, я ее зачту  \r\n\r\nres (Resistor val) = val\r\nres (Paral val sc) = (1 / val) + (1 / (res sc))\r\nres (Serial val sc) = val + (res sc)','<br/>Тесты успешно пройдены!'),(6004,129,'6053606','2013-10-05 20:56:36',1,'mymap f = foldr (x acc -> f x:acc) []\r\n','<br/>Тесты успешно пройдены!'),(6005,59,'SNNatalieS','2013-10-05 21:05:06',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _14_1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = { 354, 20, 9, 31 };\r\n            int [] b = a.Where(x => x % 10 > 0 ).Select(x => x % 10).ToArray();\r\n            foreach (var i in b) Console.WriteLine(i);\r\n  --- В принципе все правильно, но ведь в условии сказано не просто написать кусок кода\r\n  --- а написать функцию nonZeroLastDigits. Это не сложно но попробуйте написать, пожалуйста.\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(6000,129,'toskira','2013-10-05 20:02:12',1,'mymap f l = foldr ((:).f) [] l','<br/>Тесты успешно пройдены!'),(6001,130,'toskira','2013-10-05 20:11:37',1,'trace l = f l 0\r\n\r\nf [] _ = 0\r\nf (h:t) n = (h !! n) + (f t (n+1))','<br/>Тесты успешно пройдены!'),(5999,54,'toskira','2013-10-05 19:56:14',1,'data Scheme = Resistance Float\r\n            | Parallel Scheme Scheme\r\n            | Sequence Scheme Scheme\r\n\r\ntotalResistance (Resistance r) = r\r\ntotalResistance (Sequence a b) = (totalResistance a) + (totalResistance b)\r\ntotalResistance (Parallel a b) = let r1 = totalResistance a\r\n                                     r2 = totalResistance b\r\n                                 in (r1*r2)/(r1+r2)','<br/>Тесты успешно пройдены!'),(5998,53,'toskira','2013-10-05 19:40:59',1,'coins n = [[k,l,m] | k <- [0..(div n 2)], l <- [0..(div n 3)], m <- [0..div n 5], 2*k+3*l+5*m == n]','<br/>Тесты успешно пройдены!'),(5997,59,'anlun','2013-10-05 18:17:53',1,'#include <algorithm>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint* nonZeroLastDigits(int* arr, int size, int& newSize) {\r\n  --- только лучше const int* arr\r\n	int* b = new int[size]; \r\n	transform(arr, arr + size, b, [] (int el) { return el % 10; });\r\n	int* end = remove_if(b, b + size, [] (int el) { return el == 0; });\r\n	newSize = end - b;\r\n	return b;\r\n}\r\n\r\nint main() {\r\n	int arr[] = {1, 2, 3, 40};\r\n	int size = 4;\r\n\r\n	int newSize;\r\n	int* b = nonZeroLastDigits(arr, size, newSize);\r\n	cout << newSize << endl;\r\n\r\n	for (int i = 0; i < newSize; i++) {\r\n		cout << b[i] << \" \";\r\n	}\r\n	cout << endl;\r\n\r\n	delete [] b;\r\n}','<br/>Тесты успешно пройдены!'),(5996,129,'SNNatalieS','2013-10-05 18:15:04',1,'mymap f xs = foldr (x res -> (f x) : res) [] xs','<br/>Тесты успешно пройдены!'),(5995,59,'anlun','2013-10-05 17:47:17',0,'#include <algorithm>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint* nonZeroLastDigits(int* arr, int size, int& newSize) {\r\n	int* b = new int[size]; \r\n	transform(arr, arr + size, b, [] (int el) { return el % 10; });\r\n	int* end = remove_if(b, b + size, [] (int el) { return el == 0; });\r\n	newSize = end - b;\r\n	return b;\r\n}\r\n\r\nint main() {\r\n	int arr[] = {1, 2, 3, 40};\r\n	int size = 4;\r\n\r\n	int newSize;\r\n	int* b = nonZeroLastDigits(arr, size, newSize);\r\n	cout << newSize << endl;\r\n\r\n	for (int i = 0; i < newSize; i++) {\r\n		cout << b[i] << \" \";\r\n	}\r\n	cout << endl;\r\n}','<br/>Тесты успешно пройдены!'),(5994,57,'3226573','2013-10-05 16:55:48',2,'-- Заменяет первый и n-ый элементы массива на их сопротивление при параллельном соединении\r\nsplitList xs n = let \r\n		   (x,y) = splitAt (n - 1) (tail xs) \r\n		   x1 = (head xs)\r\n		   x2 = xs !! n\r\n		   elem = x1 * x2 / (x1 + x2)\r\n		 in ( elem : (x ++ (tail y)) ) 		 \r\n\r\ncanMakeScheme\' [] _ _ = False\r\ncanMakeScheme\' rs m needCheck = (needCheck && any ( == m) rs) ||\r\n				(head rs < m && canMakeScheme\' (tail rs) (m - (head rs)) True) ||\r\n				canMakeScheme\' (tail rs) m False ||\r\n				any ( == True) [canMakeScheme\' (splitList rs n) m True | n <- [1..(length rs) - 1]]\r\n\r\ncanMakeScheme rs m = canMakeScheme\' rs m True','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),(5993,130,'SNNatalieS','2013-10-05 16:38:08',1,'trace [[]] = 0\r\ntrace xs = let t = zip xs ([0 .. (length xs)-1])\r\n		in foldr (x res -> res + (fst x !! snd x)) 0 t','<br/>Тесты успешно пройдены!'),(5992,56,'3226573','2013-10-05 15:24:45',1,'allLists n k = foldr (\\_ res -> [(x:xs) | x <- [1..n], xs <- res]) [[]] [1..k]','<br/>Тесты успешно пройдены!'),(5991,130,'3226573','2013-10-05 14:55:58',1,'-- Решение не очень эффективное, зато в 1 строчку\r\ntrace x = sum ([(x !! n) !! n | n <- [0..((length x) - 1)]])','<br/>Тесты успешно пройдены!'),(5989,54,'3226573','2013-10-05 14:43:04',1,'data Scheme = 	Resistance Double |\r\n		ParallelScheme Scheme Scheme |\r\n		SequenceScheme Scheme Scheme\r\n\r\ntotalResistance (Resistance x) = x\r\ntotalResistance (ParallelScheme s1 s2) = let x = totalResistance s1 \r\n					     y = totalResistance s2\r\n					 in x * y / (x + y)\r\ntotalResistance (SequenceScheme s1 s2) = (totalResistance s1) + (totalResistance s2)','<br/>Тесты успешно пройдены!'),(5990,129,'3226573','2013-10-05 14:47:34',1,'mymap f xs = foldr (x res -> ((f x):res)) [] xs','<br/>Тесты успешно пройдены!'),(5986,129,'anna','2013-10-05 14:20:56',1,'mymap f = foldr (x xs -> f x : xs) []','<br/>Тесты успешно пройдены!'),(5987,53,'3226573','2013-10-05 14:22:02',1,'coins n = [[x,y,z]| x <- [0..(div n 2)], y <- [0..(div n 3)], z <- [0..(div n 5)], 2*x + 3*y + 5*z == n]\r\n','<br/>Тесты успешно пройдены!'),(5988,47,'nomeansno','2013-10-05 14:28:36',1,'powerset = foldr f [[]] \r\n\r\n\r\n\r\nf x s = s ++ l\r\n\r\n where l = [x:y | y<-s]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5985,53,'anna','2013-10-05 14:00:16',1,'coins n = [[x,y,z]|x<-[0..n],y<-[0..n],z<-[0..n], 2*x+3*y+5*z==n]\r\n --- Не знаю, почему выдало ошибку - вроде бы все правильно.','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(5984,53,'anna','2013-10-05 13:59:05',0,'coins n = [[x,y,z]|x<-[0..n],y<-[0..n],z<-[0..n], 2*x+3*y+5*z==n]\n','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(5983,54,'nomeansno','2013-10-05 13:03:53',1,'data Scheme = Resistance Double | SeriesResistance Scheme Scheme | DerivedResistance Scheme Scheme \r\n\r\n\r\n\r\ntotalResistance (Resistance r) = r\r\n\r\ntotalResistance (SeriesResistance s1 s2) = r1 + r2\r\n\r\n where r1 = totalResistance s1; r2 =  totalResistance s2\r\n\r\ntotalResistance (DerivedResistance s1 s2) = r1*r2 / (r1+r2)\r\n\r\n where r1 = totalResistance s1; r2 = totalResistance s2\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5975,56,'4604056','2013-10-05 00:43:50',0,'--abc n k = [foldl (x y -> y:x) [] (map (i -> x) [1..k])|x<-[1..k]]\r\n--a = foldl (x y -> y:x) [] (map (i -> 1) [1..10])\r\n--a=[x:x:[]|x<-[1..10]]\r\n--abc x = foldl (x y -> y:x) [] (map (i -> x) [1..4])\r\nabc k 1 = [[x]|x<-[1..k]]\r\nabc k n = [x:xs|x<-[1..k], xs<-(abc k (n-1))]','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(5976,56,'4604056','2013-10-05 00:44:40',0,'--abc n k = [foldl (x y -> y:x) [] (map (i -> x) [1..k])|x<-[1..k]]\r\n--a = foldl (x y -> y:x) [] (map (i -> 1) [1..10])\r\n--a=[x:x:[]|x<-[1..10]]\r\n--abc x = foldl (x y -> y:x) [] (map (i -> x) [1..4])\r\nallLists k 1 = [[x]|x<-[1..k]]\r\nallLists k n = [x:xs|x<-[1..k], xs<-(abc k (n-1))]','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(5977,56,'4604056','2013-10-05 00:45:11',1,'--abc n k = [foldl (x y -> y:x) [] (map (i -> x) [1..k])|x<-[1..k]]\r\n--a = foldl (x y -> y:x) [] (map (i -> 1) [1..10])\r\n--a=[x:x:[]|x<-[1..10]]\r\n--abc x = foldl (x y -> y:x) [] (map (i -> x) [1..4])\r\nallLists k 1 = [[x]|x<-[1..k]]\r\nallLists k n = [x:xs|x<-[1..k], xs<-(allLists k (n-1))]','<br/>Тесты успешно пройдены!'),(5978,130,'8519021','2013-10-05 00:47:30',2,'--- А почему (length y) `div` 2)??? Это вы нвпример для массива 4 на 4\r\n--- во всех строках берете элемент номер 2. А надо в первом - элемент\r\n--- номер 0, во втором - номер 1, и т.д.\r\n--- Попробуйте исправить? Но если не получится, выложите снова то же\r\n--- решение, я его зачитаю.\r\ntrace n = foldl (+) 0 (map ( y -> y !! ((length y) `div` 2)) n)\r\n','Выражение имеет неправильное значение: trace [[1,2],[4,5]]'),(5979,129,'nomeansno','2013-10-05 01:24:22',0,'euclid 1 b = if b == 0 then (1,0)\n\nelse (1-b, 1)\n\neuclid a 1 = if a == 0 then (0,1)\n\nelse (1, 1-a)\n\neuclid a b = f b r (0,1) (1,-q)\n\n where q = a `div` b; r = a `mod` b\n\n\n\nf _ 1 _ (x,y) = (x,y)\n\nf b rn (xb,yb) (xrn,yrn) = f rn rn\' (xrn,yrn) (xrn\',yrn\') \n\n where qn\' = b `div` rn; rn\' = b `mod` rn; xrn\'=xb-xrn*qn\'; yrn\'=yb-yrn*qn\'       \n\n\n','Не удалось вычислить выражение \"mymap (*3) [1,2,3]\", проверьте правильность синтаксиса'),(5980,129,'nomeansno','2013-10-05 01:25:07',1,'mymap f = foldr (x y -> f x :y) []\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5981,53,'nomeansno','2013-10-05 11:30:12',1,'coins n = listcomp n [2,3,5]\r\n\r\n\r\n\r\nchangecoins 0 _ s ss = s:ss\r\n\r\nchangecoins _ [] _ ss = ss \r\n\r\nchangecoins n (x:xs) s ss = if n>0 then changecoins (n-x) (x:xs) (x:s) ss ++ changecoins n xs s ss \r\n\r\nelse ss\r\n\r\n\r\n\r\nlistcomp n s = [f x | x <- l]\r\n\r\n where l = changecoins n s [] []; f x = [ length [z | z <- x, z == y] | y <- s] \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5982,130,'nomeansno','2013-10-05 12:20:51',1,'f n xs (i, sum) = (i+1, sum+xs !! (n-i))\r\n\r\n\r\n\r\ntrace s = snd (foldr (f n) (1,0) s)\r\n\r\n where n = length s\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5974,57,'deripaska','2013-10-05 00:33:16',1,'{--\r\n\r\n	task 13-02\r\n\r\nОписать функцию canMakeScheme с двумя параметрами:\r\n\r\n- список целых чисел [r1, r2, … rn]. Этот список задает набор имеющихся у нас сопротивлений.\r\n\r\n- целое число m. \r\n\r\nФункция должна проверить, можно ли построить из этих сопротивлений (не обязательно из всех) электрическую схему с общим сопротивлением m и вернуть в качестве результата True или False. \r\n\r\nСаму схему строить не надо.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ncanMakeScheme [4,4,5] 7\r\n\r\n\r\n\r\nОтвет должен быть True, потому что мы можем соединить параллельно 4 и 4, а потом присоединить последовательно 5.\r\n\r\n\r\n\r\nЗамечание:\r\n\r\n- Можно считать, что сопротивлений будет не больше 5.\r\n\r\n- Если вы напишете решение, которое работает за разумное время (скажем, за 15 мин.) для 9 резисторов, выложите ее, как решение задачи 12-3, за нее будет 5 баллов.\r\n\r\n- Если вы напишите решение, которое работает для 15 резисторов, присылайте мне, за нее будет 30 баллов (но я не думаю, что это возможно..).\r\n\r\n--}\r\n\r\ncanMakeScheme xs r = foldr (curResistance res -> res || (curResistance == r)) False (countAllPossibleSchemesResistance xs)\r\n\r\n\r\n\r\n{--\r\n\r\ncountAllPossibleSchemesResistance возвращает список сопротивлений всех возможных схем, которые можно составить из имеющихся резисторов xs\r\n\r\n--} \r\n\r\ncountAllPossibleSchemesResistance [] = []\r\n\r\ncountAllPossibleSchemesResistance [r] = [r]\r\n\r\ncountAllPossibleSchemesResistance [r1, r2] = [r1, r2, r1 + r2, r1 * r2 / (r1 + r2)]\r\n\r\ncountAllPossibleSchemesResistance xs = foldr (curScheme res -> res ++ (countAllPossibleSchemesResistance curScheme)) [] (generateSchemeWithTwoJoinedResistors xs)\r\n\r\n\r\n\r\n{--\r\n\r\ngenerateSchemeWithTwoJoinedResistors \r\n\r\n	- на вход: принимает список резисторов, из которых можно составлять схему\r\n\r\n	- выход: возвращает список всех возможных \"схем\" (точнее это уже будет список из списков резисторов), учитывая соединения каких-то двух резисторов параллельно или последовательно\r\n\r\nт.е. по сути мы \r\n\r\n	- рассматриваем все возможные пары резисторов из исходной схемы\r\n\r\n	- для каждой такой пары \r\n\r\n		-- считаем их общее сопротивление, соединяя их двумя способами (параллельно / последовательно)\r\n\r\n		-- строим новые две схемы (для каждого типа соединения), где мы эту пару из исходной схемы резисторов рассматриваем как один новый резистор (т.е. схема составляется из резисторов старой схемы, но с заменой текущей пары резисторов на их общее сопротивление)\r\n\r\n--}\r\n\r\n\r\n\r\ngenerateSchemeWithTwoJoinedResistors xs =  \r\n\r\n	foldr ([r1, r2] res -> \r\n\r\n				let	restScheme = removePairResistor xs (r1, r2)\r\n\r\n				in ((r1 + r2) : restScheme) : ((r1 * r2 / (r1 + r2)) : restScheme) : res\r\n\r\n		  ) [] (generateAllPairs xs) \r\n\r\n\r\n\r\n-- генерируем всевозможные пары резисторов из списка предложенных резисторов\r\n\r\ngenerateAllPairs xs = removeNullPairs (generateAllPairsHelp xs)\r\n\r\ngenerateAllPairsHelp (x:xs)\r\n\r\n	| xs == [] = []\r\n\r\n	| otherwise = (generateAllPairsHelp xs) ++ (foldr (cur res -> [x, cur] : res) [] xs)\r\n\r\n\r\n\r\n-- \"удаляем\" из списка один резистор\r\n\r\nremoveOneResistor (x:xs) r\r\n\r\n	| x == r = xs\r\n\r\n	| otherwise = x : removeOneResistor xs r\r\n\r\n-- \"удаляем\" из списка пару резисторов \r\n\r\nremovePairResistor xs (r1, r2) = removeOneResistor (removeOneResistor xs r1) r2\r\n\r\n\r\n\r\n-- \"удаляем\" нулевые \"пары\"\r\n\r\nremoveNullPairs xs = filter (x -> x /= []) xs\r\n\r\n	\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5971,56,'15309342','2013-10-05 00:04:33',1,'allLists n 0 = [[]]\r\nallLists n k = [ x:xs | x <- [1..n], xs <- allLists n (k - 1)]','<br/>Тесты успешно пройдены!'),(5972,129,'8519021','2013-10-05 00:20:58',1,'mymap f xs = foldr (y ys -> (f y):ys) [] xs\r\n','<br/>Тесты успешно пройдены!'),(5973,57,'deripaska','2013-10-05 00:27:09',0,'{--\r\n\n	task 13-02\r\n\nОписать функцию canMakeScheme с двумя параметрами:\r\n\n- список целых чисел [r1, r2, … rn]. Этот список задает набор имеющихся у нас сопротивлений.\r\n\n- целое число m. \r\n\nФункция должна проверить, можно ли построить из этих сопротивлений (не обязательно из всех) электрическую схему с общим сопротивлением m и вернуть в качестве результата True или False. \r\n\nСаму схему строить не надо.\r\n\n\r\n\nПример вызова:\r\n\ncanMakeScheme [4,4,5] 7\r\n\n\r\n\nОтвет должен быть True, потому что мы можем соединить параллельно 4 и 4, а потом присоединить последовательно 5.\r\n\n\r\n\nЗамечание:\r\n\n- Можно считать, что сопротивлений будет не больше 5.\r\n\n- Если вы напишете решение, которое работает за разумное время (скажем, за 15 мин.) для 9 резисторов, выложите ее, как решение задачи 12-3, за нее будет 5 баллов.\r\n\n- Если вы напишите решение, которое работает для 15 резисторов, присылайте мне, за нее будет 30 баллов (но я не думаю, что это возможно..).\r\n\n--}\r\n\ncanMakeScheme xs r = foldr (curResistance res -> res || (curResistance == r)) False (countAllPossibleSchemesResistance xs)\r\n\n\r\n\n{--\r\n\ncountAllPossibleSchemesResistance возвращает список сопротивлений всех возможных схем, которые можно составить из имеющихся резисторов xs\r\n\n--} \r\n\ncountAllPossibleSchemesResistance [] = []\r\n\ncountAllPossibleSchemesResistance [r] = [r]\r\n\ncountAllPossibleSchemesResistance [r1, r2] = [r1, r2, r1 + r2, r1 * r2 / (r1 + r2)]\r\n\ncountAllPossibleSchemesResistance xs = foldr (curScheme res -> res ++ (countAllPossibleSchemesResistance curScheme)) [] (generateSchemeWithTwoJoinedResistors xs)\r\n\n\r\n\n{--\r\n\ngenerateSchemeWithTwoJoinedResistors \r\n\n	- на вход: принимает список резисторов, из которых можно составлять схему\r\n\n	- выход: возвращает список всех возможных \"схем\" (точнее это уже будет список из списков резисторов), учитывая соединения каких-то двух резисторов параллельно или последовательно\r\n\nт.е. по сути мы \r\n\n	- рассматриваем все возможные пары резисторов из исходной схемы\r\n\n	- для каждой такой пары \r\n\n		-- считаем их общее сопротивление, соединяя их двумя способами (параллельно / последовательно)\r\n\n		-- строим новые две схемы (для каждого типа соединения), где мы эту пару из исходной схемы резисторов рассматриваем как один новый резистор (т.е. схема составляется из резисторов старой схемы, но с заменой текущей пары резисторов на их общее сопротивление)\r\n\n--}\r\n\n\r\n\ngenerateSchemeWithTwoJoinedResistors xs =  \r\n\n	foldr ([r1, r2] res -> \r\n\n				let	restScheme = removePairResistor xs (r1, r2)\r\n\n				in ((r1 + r2) : restScheme) : ((r1 * r2 / (r1 + r2)) : restScheme) : res\r\n\n		  ) [] (generateAllPairs xs) \r\n\n\r\n\n-- генерируем всевозможные пары резисторов из списка предложенных резисторов\r\n\ngenerateAllPairs xs = removeNullPairs (generateAllPairsHelp xs)\r\n\ngenerateAllPairsHelp (x:xs)\r\n\n	| xs == [] = []\r\n\n	| otherwise = (generateAllPairsHelp xs) ++ (foldr (cur res -> [x, cur] : res) [] xs)\r\n\n\r\n\n-- \"удаляем\" из списка один резистор\r\n\nremoveOneResistor (x:xs) r\r\n\n	| x == r = xs\r\n\n	| otherwise = removeOneResistor xs r\r\n\n-- \"удаляем\" из списка пару резисторов \r\n\nremovePairResistor xs (r1, r2) = removeOneResistor (removeOneResistor xs r1) r2\r\n\n\r\n\n-- \"удаляем\" нулевые \"пары\"\r\n\nremoveNullPairs xs = filter (x -> x /= []) xs\r\n\n	\r\n\n\r\n\n\r\n\n\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),(5966,56,'8519021','2013-10-04 22:41:37',1,'allLists n 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(5967,45,'480387','2013-10-04 22:44:43',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace ConsoleApplication4\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] a = new int[2][];\r\n            a[0] = new int[] { 1,2};\r\n            a[1] = new int[] { 3,4,-3};\r\n\r\n            bool b = a.All(m => m.Any(x => (x % 2 == 0)));\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5968,129,'4604056','2013-10-04 22:44:51',1,'mymap _ [] = []\r\nmymap f xs = foldr (x y -> f x : y) [] xs','<br/>Тесты успешно пройдены!'),(5969,53,'8519021','2013-10-04 23:05:46',1,'coins n = [[k, l, m] | k<-[0..(div n 2)], l<-[0..(div n 3)], m<-[0..(div n 5)], 2*k + 3*l + 5*m == n]\r\n','<br/>Тесты успешно пройдены!'),(5970,130,'4604056','2013-10-04 23:14:52',1,'a = [1,2,3]\r\nb=[3,3,3]\r\nc=[a,b]\r\n\r\nwrapper xs = map (x -> xs) [1..length xs]\r\n\r\ntrace xss = counter \r\n	(wrapper xss) \r\n	(length xss - 1)\r\n	0\r\n\r\ncounter (xss:xsss) 0 acc = acc + xss!!0!!0\r\ncounter (xss:xsss) i acc = counter xsss (i-1) (acc+xss!!i!!i)','<br/>Тесты успешно пройдены!'),(5965,45,'egeorge','2013-10-04 22:36:15',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static bool EvenElementInEachRow(int[][] m) {\r\n            return m.All(row => row.Any(x => (x % 2 == 0)));\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] m = { new[] { 1, 2, 3 }, new[] { 1, 2, 3 }, new[] { 1, 2, 3 } };\r\n            Console.WriteLine(EvenElementInEachRow(m));\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5964,57,'5543298','2013-10-04 22:32:46',2,'--- (13 последовательно с 2) и параллельно с ними (7 последовательно с 2) - это будет как раз 6 \r\naddList _ 0 res = [res]\r\n\r\naddList [x] i res = if (i /= 1) then [] else [res++[x]] \r\n\r\naddList [] _ _ = []\r\n\r\naddList (x:xs) i res = if (i == 0) then [res] else if i == length (x:xs) then [res++(x:xs)] else (addList xs (i - 1) (res++[x]))++(addList xs i res)\r\n\r\npowerset xs = filter (ys -> let n = length ys in n /= 0 && n /= m) (foldr (x res -> (addList xs x [])++res) [] [0..(length xs)]) where m = length xs\r\n\r\n\r\n\r\nremoveElement [] _ res = res\r\n\r\nremoveElement (x:xs) n res = if n == 0 then removeElement xs (n - 1) res else (x:(removeElement xs (n - 1) res)) \r\n\r\n\r\n\r\ncanMakeScheme [] _ = True\r\n\r\ncanMakeScheme [x] n = x == n\r\n\r\ncanMakeScheme [x1, x2] n = canMakeScheme [x1] n || canMakeScheme [x2] n || x1 + x2 == n || x1 * x2 / (x1 + x2) == n\r\n\r\ncanMakeScheme xs n = any (ys -> canMakeScheme ys n) (powerset xs) || any (==True)(map (i -> canMakeScheme (removeElement xs i []) (n - (xs !! i))) [0..m]) || (foldr (x res -> res + 1 / x) 0 xs) == 1 / n where m = (length xs) - 1\r\n','Выражение имеет неправильное значение: canMakeScheme [13, 7, 2, 3] 6'),(5963,43,'480387','2013-10-04 22:21:53',1,'g x y = if x>y \r\n\r\n	  then (x,y)\r\n\r\n	  else (y,x)\r\n\r\n\r\n\r\n\r\n\r\nf x y = f\' x y []\r\n\r\n	\r\n\r\nf\' rp r qs = \r\n\r\n	let \r\n\r\n	 new_r = rp `mod` r\r\n\r\n	 q = rp `div` r\r\n\r\n	 new_rp = r\r\n\r\n	in \r\n\r\n		if (new_r == 0)\r\n\r\n			then (q:qs)\r\n\r\n			else f\' new_rp new_r (q:qs)\r\n\r\n		\r\n\r\neuclid  a b = \r\n\r\n         let \r\n\r\n	      (s,t) = g a b\r\n\r\n	      qs = reverse (f s t)\r\n\r\n		 in if (t == 1)\r\n\r\n				then if swapped then (1-s,1) else (1, 1-s)\r\n\r\n				else if (len == i)\r\n\r\n					  then if swapped then (y0,x0) else (x0,y0)\r\n\r\n					  else\r\n\r\n						ou\' x0 x1 y0 y1 i len qs swapped\r\n\r\n						where\r\n\r\n						  (s,t) = g a b\r\n\r\n						  qs = reverse (f s t)\r\n\r\n						  x0 = 1\r\n\r\n						  x1 = -x0*(qs!!1)\r\n\r\n						  y0 = - (qs!!0)\r\n\r\n						  y1 = 1 -y0*(qs!!1)\r\n\r\n						  i = 2\r\n\r\n						  len = length qs\r\n\r\n						  swapped = (a/=s)\r\n\r\n\r\n\r\n        \r\n\r\nou\' x0 x1 y0 y1 i len qs swapped=\r\n\r\n	if (len - 1 == i)\r\n\r\n	then (if swapped then (y1,x1) else (x1,y1))\r\n\r\n	else ou\' x1 (x0 - x1*q) y1 (y0 - y1*q) (i+1) len qs swapped\r\n\r\n	where q = (qs!!i)\r\n\r\n\r\n\r\n	\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5961,59,'romos2007','2013-10-04 21:21:57',1,'﻿/*\r\n\r\n * Задача 14-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace _14_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] nonZeroLastDigits(int[] a)\r\n\r\n        {\r\n\r\n            return a.Select(x => x % 10).Where(x => x > 0).ToArray();\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] a = { 354, 20, 9, 31 };\r\n\r\n            int[] b = { 1, 2, 3, 4, 5, 10, 11, 20, 25, 1000, 1001, 5443 };\r\n\r\n            foreach (int x in nonZeroLastDigits(a))\r\n\r\n            {\r\n\r\n                Console.Write(x+\" \");\r\n\r\n            }\r\n\r\n            Console.WriteLine();\r\n\r\n            foreach (int x in nonZeroLastDigits(b))\r\n\r\n            {\r\n\r\n                Console.Write(x + \" \");\r\n\r\n            }\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5962,45,'Leonid','2013-10-04 21:29:28',1,'#!/usr/bin/perl\r\n\r\n\r\n\r\n# program was tested in Linux leon-1011PX 3.2.0-49-generic-pae\r\n\r\n# example \r\n\r\n# perl any_all_lambda.pl {{1,-1,2,3}{4,1,3,5}{1,6,3,1}} - TRUE.\r\n\r\n# perl any_all_lambda.pl {{1,5,3,-199}{1,2,1,1},{0,-11,-121,1}}  - FALSE.\r\n\r\n\r\n\r\nuse strict; \r\n\r\nuse warnings;\r\n\r\n\r\n\r\n$ = $/;\r\n\r\n\r\n\r\n# key h to show help menu\r\n\r\ndo {write; exit} if (defined(@ARGV) && $ARGV[0] eq \'-h\');\r\n\r\n\r\n\r\nmy $inpt = <STDIN>;\r\n\r\nchomp($inpt);\r\n\r\n\r\n\r\n# parse expression\r\n\r\n# note that string must be in format {{}{}{}{,,,,}{,}} and so on\r\n\r\nmy @matches = $inpt =~ /{((?:d|-d)+(?:,{0,1}(?:d|-d))*)}/g;\r\n\r\n\r\n\r\nprint \"@matches\r\n\";\r\n\r\n\r\n\r\n# perl doesn\'t have lambda expression in style like #C,\r\n\r\n# but we can model it, using anonimus closers\r\n\r\n# it will be done simply, because garbage collector remove \r\n\r\n# variable from memory after all references deleted.\r\n\r\n\r\n\r\n# some simple lambda functions\r\n\r\nsub Plus {\r\n\r\n	my $x = shift;\r\n\r\n	return sub {\r\n\r\n		my $y = shift;\r\n\r\n		return $y + $x;\r\n\r\n	};\r\n\r\n};\r\n\r\n\r\n\r\nsub Minus {\r\n\r\n	my $x = shift;\r\n\r\n	return sub {\r\n\r\n		my $y = shift;\r\n\r\n		return $x - $y;\r\n\r\n	};\r\n\r\n};\r\n\r\n\r\n\r\nsub Eval {\r\n\r\n	my $x = shift;\r\n\r\n	sub {\r\n\r\n		if ($x % 2 == 0) { return 0 }\r\n\r\n		else { return 1 };\r\n\r\n	};\r\n\r\n}\r\n\r\n\r\n\r\n# example\r\n\r\n#my $el1 = Plus(1); \r\n\r\n#print $el1->(2);\r\n\r\n\r\n\r\n# gets @mathes\r\n\r\nsub All (){\r\n\r\n	my @data = @_;\r\n\r\n	foreach my $arg (@data) {\r\n\r\n		my @in_data = split(\',\', $arg);\r\n\r\n		my $count = scalar(@in_data);\r\n\r\n		foreach my $in_arg (@in_data) {		\r\n\r\n			my $lambda = Eval($in_arg);\r\n\r\n			$count -= $lambda->();\r\n\r\n		}\r\n\r\n		return \"FALSE\" if $count == 0;\r\n\r\n	}\r\n\r\n	return \"TRUE\";\r\n\r\n}\r\n\r\n\r\n\r\nprint &All (@matches) if scalar @matches;\r\n\r\n\r\n\r\n\r\n\r\nformat STDOUT =\r\n\r\n----------------------------HELP MENU----------------------------\r\n\r\nUSEFULL use less to show help menu in more management view. ./generate_matrix_csr.pl -h | less\r\n\r\nperl any_all_lambda.pl {{1,-1,2,3}{4,1,3,5}{1,6,3,1}} - TRUE.\r\n\r\nperl any_all_lambda.pl {{1,5,3,-199}{1,2,1,1},{0,-11,-121,1}}  - FALSE\r\n\r\n.\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5960,59,'5543298','2013-10-04 21:03:36',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"14.1\":\r\n\r\n                    {\r\n\r\n                        var test = new []{ 354, 20, 9, 31 };\r\n\r\n                        var result = test.Select(item => item.ToString().Last()).Where(item => item != \'0\').ToList();\r\n\r\n                        var resStr = result.Aggregate(new StringBuilder(), (workingSentence, next)  =>\r\n\r\n                                                  workingSentence.Append(String.Format(\"{0} \", next)), res => res.ToString());\r\n\r\n                        Console.WriteLine(resStr);\r\n\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"11.1\":\r\n\r\n                    {\r\n\r\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\r\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                        {\r\n\r\n                                            new List<int> {1, 2, 3},\r\n\r\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                            new List<int> {501, 1001, 33, 14},\r\n\r\n                                            //Раскомментировать, чтоб было False\r\n\r\n                                            //new List<int> {37, 47, 15},\r\n\r\n                                        };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\r\n        {\r\n\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a)/steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step*(func(point) + func(point + step))/2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5956,56,'115753099','2013-10-04 19:30:06',1,'allLists n 0 = [[]]\r\nallLists n k =\r\n	[x:xs | x <- [1..n], xs <- allLists n (k-1)]','<br/>Тесты успешно пройдены!'),(5957,45,'nomeansno','2013-10-04 19:37:22',1,'#include <iostream>\r\n\r\n#include <list>\r\n\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ntypedef list<int> list1;\r\n\r\ntypedef list<list1> list2;\r\n\r\n\r\n\r\nbool f (const list2 &l) {\r\n\r\n	return all_of(l.begin(), l.end(), [](list1 s){return any_of(s.begin(), s.end(), [](int x){return x % 2 == 0;});});\r\n  --- Тут лучше, конечно [](const list1& s)\r\n  --- А то list будет копироваться при каждом вызова, и это неэффективно.\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n	list2 l1, l2;\r\n\r\n	list1 s1, s2, s3;\r\n\r\n	for(int i = 0; i<10; i++) {\r\n\r\n		s1.push_back(1);\r\n\r\n		s2.push_back(i*i);\r\n\r\n		s3.push_back(i % 2);\r\n\r\n	}\r\n\r\n	l1.push_back(s1);\r\n\r\n	l2.push_back(s2);\r\n\r\n	l2.push_back(s3);\r\n\r\n	cout << f(l1) << f(l2);\r\n\r\n}\r\n\r\n','<br/>Тесты успешно пройдены!'),(5958,59,'1595828','2013-10-04 20:04:45',1,'using System.Linq;\r\nnamespace zd14_1\r\n{\r\n    class zd\r\n    {\r\n        static int[] nonZeroLastDigits(int[] array)\r\n		{\r\n            return array.Select(x => (x % 10)).Where(x => x != 0).ToArray();\r\n      \r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] arr = new int[] { 1, 30, 532 };\r\n            arr= nonZeroLastDigits(arr);\r\n            for (int i = 0; i < arr.Length; i++)\r\n                System.Console.Write(\"{0} \", arr[i]);\r\n            System.Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5959,59,'115753099','2013-10-04 20:40:09',2,'--- Во всех C# задачах надо присылать _полную_ программу, которую реально можно было бы с компилировать\r\n--- (с using, в частности. Пришлите такую версию, пожалуйста).\r\n\r\n   class Program\r\n    {\r\n        static int[] f(int [] mas)\r\n        {\r\n            return (mas.Where(x => x % 10 != 0).ToArray()).Select(x => x % 10).ToArray();\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int [] mas = new int[]{4,14,54,60};\r\n            foreach (var i in f(mas))\r\n            {\r\n                Console.WriteLine(i.ToString());\r\n            }\r\n        }\r\n    }','<br/>Тесты успешно пройдены!'),(5949,54,'15309342','2013-10-04 15:39:48',1,'data Scheme x = R x | PCon (Scheme x) (Scheme x) | SCon (Scheme x) (Scheme x)\r\ntotalResistance (PCon scheme1 scheme2) =\r\n    let\r\n      r1 = totalResistance scheme1\r\n      r2 = totalResistance scheme2\r\n    in r1*r2/(r1 + r2)\r\ntotalResistance (SCon scheme1 scheme2) = totalResistance scheme1 + totalResistance scheme2\r\ntotalResistance (R n) = n','<br/>Тесты успешно пройдены!'),(5950,45,'1170660','2013-10-04 15:49:50',1,'﻿using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Check\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n      \r\n\r\n        static bool checkOdd(int[][] a,int n)\r\n\r\n        { \r\n\r\n		  bool result =false;  \r\n\r\n		    result=a.All(y=>y.Any(x=>x%2==0));		  \r\n\r\n			\r\n\r\n	      return result;		\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {   bool result=false;\r\n\r\n			int n = 10;\r\n\r\n            var a = new int[n][];\r\n\r\n            for (int i = 0; i < n; i++)\r\n\r\n            {\r\n\r\n                a[i] = new int[n];\r\n\r\n                \r\n\r\n                for(int j=0;j<n;j++){\r\n\r\n                	a[i][j]=1;\r\n\r\n                	\r\n\r\n                	//Console.WriteLine(a[i][j]);\r\n\r\n                }\r\n\r\n                //Console.WriteLine(\"======\");\r\n\r\n            }\r\n\r\n			\r\n\r\n			result=checkOdd(a,n);\r\n\r\n            \r\n\r\n			Console.WriteLine(result);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5951,53,'3270666','2013-10-04 15:50:37',1,'coins n = let sum k l m = k * 2 + l * 3 + m * 5\r\n          in [[k, l, m] | k <- [0..n], l <- [0..n], m <- [0..n], sum k l m == n]','<br/>Тесты успешно пройдены!'),(5952,54,'3270666','2013-10-04 16:01:55',1,'data Scheme = Resistance Float | Series Scheme Scheme \r\n  | Parallel Scheme Scheme\r\n\r\ntotalResistance (Resistance r) = r\r\ntotalResistance (Series r1 r2) = totalResistance r1 + totalResistance r2\r\ntotalResistance (Parallel r1 r2) = let res1 = totalResistance r1\r\n                                       res2 = totalResistance r2\r\n                                    in res1 * res2 / (res1 + res2)','<br/>Тесты успешно пройдены!'),(5953,129,'3270666','2013-10-04 16:06:10',1,'mymap f xs = foldr (x res -> (f x):res) [] xs','<br/>Тесты успешно пройдены!'),(5954,130,'3270666','2013-10-04 16:16:35',1,'trace matrix = let n = length matrix - 1\r\n                   traces = zipWith (xs i -> xs !! i) matrix [0..n]\r\n	           in foldr (+) 0 traces','<br/>Тесты успешно пройдены!'),(5955,45,'42284313','2013-10-04 17:01:01',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace testLambda\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static bool checkOneDimArray(int[] testArray)\r\n\r\n        {\r\n\r\n            return testArray.Any(x => x % 2 == 0);\r\n\r\n        }\r\n\r\n\r\n\r\n        static bool checkExpression(int[][] testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(checkOneDimArray);\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] testArray1 = { 1, 3, 4, 5 };\r\n\r\n            int[] testArray2 = { 4, 4, 3, 4, 24, 2 };\r\n\r\n            int[] testArray3 = { 3, 5, 7, 9, 10 };\r\n\r\n            int[][] testMultArray = { testArray1, testArray2, testArray3 };\r\n\r\n            for (int i = 0; i < testMultArray.Length; i++)\r\n\r\n            {\r\n\r\n                for (int j = 0; j < testMultArray[i].Length; j++)\r\n\r\n                    Console.Write(\"{0}, \", testMultArray[i][j]);\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n\r\n\r\n            Console.WriteLine(checkExpression(testMultArray));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5948,45,'artem.gomerman','2013-10-04 14:11:07',1,'#include <vector>\r\n\r\n#include <algorithm>\r\n\r\n#include <iostream>\r\n\r\n#include <time.h>\r\n\r\n\r\n\r\ntypedef std::vector<std::vector<int> > double_vector;\r\n\r\n\r\n\r\nbool evenExistInEveryArray(const double_vector& arr)\r\n\r\n{\r\n\r\n	return std::all_of(arr.cbegin(), arr.cend(), [](std::vector<int> v){ return std::any_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; }); } );\r\n   --- Тут в ляюбда выражении лучше передавать не вектор, а константную ссылку на него. А то он будет кажый раз копироваться, очень не эффективно.\r\n}\r\n\r\n\r\n\r\nvoid printArray(const double_vector& arr)\r\n\r\n{\r\n\r\n	for(auto currentArray = arr.begin(); currentArray != arr.end(); currentArray++)\r\n\r\n	{\r\n\r\n		for(auto it = currentArray->begin(); it != currentArray->end(); it++)\r\n\r\n		{\r\n\r\n			std::cout << *it << \" \";\r\n\r\n		}\r\n\r\n		std::cout << std::endl;\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	// each array will have only one even number\r\n\r\n	double_vector arrEvenExist;\r\n\r\n\r\n\r\n	// each array will have no even numbers\r\n\r\n	double_vector arrNoEvenExist;\r\n\r\n\r\n\r\n	// generate random arrays\r\n\r\n	srand((unsigned) time(NULL));\r\n\r\n	const unsigned int arraysCount = 2 + rand() % 3;\r\n\r\n	for(unsigned int i = 0; i < arraysCount; i++)\r\n\r\n	{\r\n\r\n		unsigned int currentArraySize = 5 + rand() % 10;\r\n\r\n\r\n\r\n		std::vector<int> arrayWithEvenNumber;\r\n\r\n		std::vector<int> arrayWithNoEvenNumber;\r\n\r\n		unsigned int evenPosition = rand() % currentArraySize;\r\n\r\n		for(unsigned int j = 0; j < currentArraySize; j++)\r\n\r\n		{\r\n\r\n			int number = rand() % 1000;\r\n\r\n			number += number % 2 + 1;\r\n\r\n			arrayWithEvenNumber.push_back(j == evenPosition ? number + 1 : number);\r\n\r\n			arrayWithNoEvenNumber.push_back(number);\r\n\r\n		}\r\n\r\n		arrEvenExist.push_back(arrayWithEvenNumber);\r\n\r\n		arrNoEvenExist.push_back(arrayWithNoEvenNumber);\r\n\r\n	}\r\n\r\n\r\n\r\n	std::cout.setf(std::ios::boolalpha);\r\n\r\n	std::cout << \"Array with even number in every array\r\n\";\r\n\r\n	printArray(arrEvenExist);\r\n\r\n	std::cout << \"\r\nArray with no even number in every array\r\n\";\r\n\r\n	printArray(arrNoEvenExist);\r\n\r\n\r\n\r\n	std::cout << \"\r\nCheck if even number exist in every array in\r\narray with even number in every array: \" << evenExistInEveryArray(arrEvenExist) << std::endl;\r\n\r\n	std::cout << \"array with no even number in every array: \" << evenExistInEveryArray(arrNoEvenExist) << std::endl;\r\n\r\n	system(\"pause\");\r\n\r\n	\r\n\r\n	return 0;\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5946,129,'617015','2013-10-04 13:48:44',1,'mymap f xs = foldr ((:) . f) [] xs\r\n','<br/>Тесты успешно пройдены!'),(5947,130,'617015','2013-10-04 13:49:24',1,'trace xs = trace\' xs 0\r\n\r\n\r\n\r\ntrace\' (x:xs) i = getDiag x i + trace\' xs (i+1)\r\n\r\n\r\n\r\ntrace\' [] i = 0\r\n\r\n\r\n\r\ngetDiag x i = x!!i   \r\n','<br/>Тесты успешно пройдены!'),(5945,53,'617015','2013-10-04 13:47:40',1,'coins n = [[x,y,z]| x<-[0..n], y<-[0..n], z<-[0..n], (x*2+y*3+z*5)== n]\r\n','<br/>Тесты успешно пройдены!'),(5944,59,'deripaska','2013-10-04 13:34:53',1,'﻿/*\r\n\r\n	task 14-01\r\n\r\nАналогом map в C# является, видимо, метод Select, а аналогом filter - метод Where (это части LINQ но их вполне можно использовать и просто как удобные методы). См. простые примеры вызова этих методов тут:\r\n\r\nhttp://msimuni.wikidot.com/fp-select-where \r\n\r\n\r\n\r\nС помощью Select и Where опишите функцию nonZeroLastDigits, которая:\r\n\r\n- берет в качестве параметра массив целых положительных чисел\r\n\r\n- возвращает массив из последних цифр всех чисел из исходного массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\n\r\n\r\nНапример, если входной массив содержит числа 354, 20, 9, 31, то надо вернуть массив из чисел 4, 9, 1 .\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Task_14_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static int[] nonZeroLastDigits(int[] array)\r\n\r\n        {\r\n\r\n            return array.Select(x => x % 10).ToArray().Where(x => x != 0).ToArray();\r\n  --- Тут, на самом деле, средний ToArray() не нужен, достаточно\r\n  ---   return array.Select(x => x % 10).Where(x => x != 0).ToArray();\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[] mas = new int[] { 354, 20, 9, 31 };\r\n\r\n            foreach (int x in nonZeroLastDigits(mas))\r\n\r\n            {\r\n\r\n                Console.WriteLine(x);\r\n\r\n            }\r\n\r\n            Console.Read();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n','<br/>Тесты успешно пройдены!'),(5943,57,'deripaska','2013-10-04 13:22:52',2,'--- Что-то у вас похоже не совсем так, хотя идея конечно правильная.\r\n--- Вот таки примеры у вас выдают False, а дб True\r\n--- canMakeScheme [4,4,4,4,4] 4\r\n--- canMakeScheme [4,4,4,4,4] 12\r\n--- canMakeScheme [4,4,4,4,4] 6  --- соеднияем 4 и 4 параллельно и к ним 2 последовательно\r\n--- Мб вы не уситываете, что можно использовать не все сопротивления?\r\n--- Но такой пример у вас тоже выдает False, а такую сзему сожно собрать\r\n--- canMakeScheme [4,4,4,4,4] 5\r\n--- Попроьуйте исправить пожалуйста (а я сейчас добавлю такие тесты)\r\n\r\n\r\n{--\r\n\r\n	task 13-02\r\n\r\nОписать функцию canMakeScheme с двумя параметрами:\r\n\r\n- список целых чисел [r1, r2, … rn]. Этот список задает набор имеющихся у нас сопротивлений.\r\n\r\n- целое число m. \r\n\r\nФункция должна проверить, можно ли построить из этих сопротивлений (не обязательно из всех) электрическую схему с общим сопротивлением m и вернуть в качестве результата True или False. \r\n\r\nСаму схему строить не надо.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ncanMakeScheme [4,4,5] 7\r\n\r\n\r\n\r\nОтвет должен быть True, потому что мы можем соединить параллельно 4 и 4, а потом присоединить последовательно 5.\r\n\r\n\r\n\r\nЗамечание:\r\n\r\n- Можно считать, что сопротивлений будет не больше 5.\r\n\r\n- Если вы напишете решение, которое работает за разумное время (скажем, за 15 мин.) для 9 резисторов, выложите ее, как решение задачи 12-3, за нее будет 5 баллов.\r\n\r\n- Если вы напишите решение, которое работает для 15 резисторов, присылайте мне, за нее будет 30 баллов (но я не думаю, что это возможно..).\r\n\r\n--}\r\n\r\n\r\n\r\ncanMakeScheme xs r = foldr (curResistance res -> res || (curResistance == r)) False (countAllPossibleSchemesResistance xs)\r\n\r\n\r\n\r\n{--\r\n\r\ncountAllPossibleSchemesResistance возвращает список сопротивлений всех возможных схем, которые можно составить из имеющихся резисторов xs\r\n\r\n--} \r\n\r\ncountAllPossibleSchemesResistance [] = []\r\n\r\ncountAllPossibleSchemesResistance [r] = [r]\r\n\r\ncountAllPossibleSchemesResistance [r1, r2] = [r1, r2, r1 + r2, r1 * r2 / (r1 + r2)]\r\n\r\ncountAllPossibleSchemesResistance xs = foldr (curScheme res -> res ++ (countAllPossibleSchemesResistance curScheme)) [] (generateSchemeWithTwoJoinedResistors xs)\r\n\r\n\r\n\r\n{--\r\n\r\ngenerateSchemeWithTwoJoinedResistors \r\n\r\n	- на вход: принимает список резисторов, из которых можно составлять схему\r\n\r\n	- выход: возвращает список всех возможных \"схем\" (точнее это уже будет список из списков резисторов), учитывая соединения каких-то двух резисторов параллельно или последовательно\r\n\r\nт.е. по сути мы \r\n\r\n	- рассматриваем все возможные пары резисторов из исходной схемы\r\n\r\n	- для каждой такой пары \r\n\r\n		-- считаем их общее сопротивление, соединяя их двумя способами (параллельно / последовательно)\r\n\r\n		-- строим новые две схемы (для каждого типа соединения), где мы эту пару из исходной схемы резисторов рассматриваем как один новый резистор (т.е. схема составляется из резисторов старой схемы, но с заменой текущей пары резисторов на их общее сопротивление)\r\n\r\n--}\r\n\r\ngenerateSchemeWithTwoJoinedResistors [] = [[]]\r\n\r\ngenerateSchemeWithTwoJoinedResistors xs =  \r\n\r\n	foldr ([r1, r2] res -> \r\n\r\n				let	restScheme = removePairResistor xs (r1, r2)\r\n\r\n				in ((r1 + r2) : restScheme) : ((r1 * r2 / (r1 + r2)) : restScheme) : res\r\n\r\n		  ) [[]] (generateAllPairs xs) \r\n\r\n\r\n\r\n-- генерируем всевозможные пары резисторов из списка предложенных резисторов\r\n\r\ngenerateAllPairs xs = removeNullPairs (generateAllPairsHelp xs)\r\n\r\ngenerateAllPairsHelp (x:xs)\r\n\r\n	| xs == [] = []\r\n\r\n	| otherwise = (generateAllPairsHelp xs) ++ buildPairWithHead\r\n\r\n	where buildPairWithHead = foldr (cur res -> [x, cur] : res) [[]] xs\r\n\r\n	\r\n\r\n-- \"удаляем\" из списка пару резисторов \r\n\r\nremovePairResistor xs (r1, r2) = filter (x -> (x /= r1 && x /= r2)) xs \r\n\r\n\r\n\r\n-- \"удаляем\" нулевые \"пары\"\r\n\r\nremoveNullPairs xs = filter (x -> x /= []) xs\r\n\r\n	\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5942,45,'1170660','2013-10-04 12:13:42',2,'﻿using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Check\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n      \r\n\r\n        static bool checkOdd(int[][] a,int n)\r\n\r\n        { \r\n\r\n		  bool result =false;  \r\n\r\n		    result=a.Any(y=>y.Any(x=>x%2==0));		  \r\n --- Это не совсем то. Так вы проверяете, верно ли что \"**хотя бы в одном** из массивов есть хотя бы один четный\"\r\n --- А надо - \"**во всех массивах**\"\r\n --- Это очень просто, но исправьте, пожалуйста.\r\n			\r\n\r\n	      return result;		\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {   bool result=false;\r\n\r\n			int n = 10;\r\n\r\n            var a = new int[n][];\r\n\r\n            for (int i = 0; i < n; i++)\r\n\r\n            {\r\n\r\n                a[i] = new int[n];\r\n\r\n                \r\n\r\n                for(int j=0;j<n;j++){\r\n\r\n                	a[i][j]=1;\r\n\r\n                	\r\n\r\n                	//Console.WriteLine(a[i][j]);\r\n\r\n                }\r\n\r\n                //Console.WriteLine(\"======\");\r\n\r\n            }\r\n\r\n			\r\n\r\n			result=checkOdd(a,n);\r\n\r\n            \r\n\r\n			Console.WriteLine(result);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5941,43,'517309','2013-10-04 10:19:54',3,'g x y = if x>y \r\n\r\n	  then (x,y)\r\n\r\n	  else (y,x)\r\n\r\n\r\n\r\nmod1 (x,y) = mod x y\r\n\r\ndiv1 (x,y) = div x y\r\n\r\n\r\n\r\nf x y = f\' x y []\r\n\r\n	\r\n\r\nf\' rp r qs = \r\n\r\n	let \r\n\r\n	 new_r = rp `mod` r\r\n\r\n	 q = rp `div` r\r\n\r\n	 new_rp = r\r\n\r\n	in \r\n\r\n		if (new_r == 0)\r\n\r\n			then (q:qs)\r\n\r\n			else f\' new_rp new_r (q:qs)\r\n\r\n		\r\n\r\neuclid  a b = \r\n\r\n         let \r\n\r\n	     (s,t) = g a b\r\n\r\n	     qs = reverse (f s t)\r\n\r\n	     x0 = 1\r\n\r\n	     x1 = -x0*(qs!!1)\r\n\r\n             y0 = - (qs!!0)\r\n\r\n             y1 = 1 -y0*(qs!!1)\r\n\r\n	     i = 2\r\n\r\n	     len = length qs\r\n\r\n	     swapped = (a/=s)\r\n\r\n        in ou\' x0 x1 y0 y1 i len qs swapped\r\n\r\nou\' x0 x1 y0 y1 i len qs swapped=\r\n\r\n	if (len - 1 == i)\r\n\r\n	then (if swapped then (y1,x1) else (x1,y1))\r\n\r\n	else ou\' x1 (x0 - x1*q) y1 (y0 - y1*q) (i+1) len qs swapped\r\n\r\n	where q = (qs!!i)\r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 1 in 1*x+1*y\", проверьте правильность синтаксиса'),(5937,130,'egeorge','2013-10-04 01:00:03',1,'trace m = sum (map (i ->((m !! i) !! i)) [0..(length m - 1)])','<br/>Тесты успешно пройдены!'),(5938,56,'5543298','2013-10-04 01:00:23',1,'checkList xs n k = sum xs <= n * k\r\n\r\nallLists\' n k xs = if length xs == k then [xs] else foldr (ys res -> (allLists\' n k ys)++res) [] [(x:xs) | x <- [1..n], checkList xs n k]\r\n\r\nallLists n k = allLists\' n k []\r\n','<br/>Тесты успешно пройдены!'),(5939,56,'egeorge','2013-10-04 01:28:15',1,'allLists n k = [[(i `mod` (n^j)) `div` n^(j - 1) + 1| j <- [1..k]] |  i <- [1 .. (n^k)]]','<br/>Тесты успешно пройдены!'),(5940,43,'517309','2013-10-04 10:14:43',0,'g x y = if x>y \r\n\r\n	  then (x,y)\r\n\r\n	  else (y,x)\r\n\r\n\r\n\r\nmod1 (x,y) = mod x y\r\n\r\ndiv1 (x,y) = div x y\r\n\r\n\r\n\r\nf x y = f\' x y []\r\n\r\n	\r\n\r\nf\' rp r qs = \r\n\r\n	let \r\n\r\n	 new_r = rp `mod` r\r\n\r\n	 q = rp `div` r\r\n\r\n	 new_rp = r\r\n\r\n	in \r\n\r\n		if (new_r == 0)\r\n\r\n			then (q:qs)\r\n\r\n			else f\' new_rp new_r (q:qs)\r\n\r\n		\r\n\r\neuclid  a b = \r\n\r\n         let \r\n\r\n	     (s,t) = g a b\r\n\r\n	     qs = reverse (f s t)\r\n\r\n	     x0 = 1\r\n\r\n	     x1 = -x0*(qs!!1)\r\n\r\n             y0 = - (qs!!0)\r\n\r\n             y1 = 1 -y0*(qs!!1)\r\n\r\n	     i = 2\r\n\r\n	     len = length qs\r\n\r\n	     swapped = (a/=s)\r\n\r\n        in ou\' x0 x1 y0 y1 i len qs swapped\r\n\r\nou\' x0 x1 y0 y1 i len qs swapped=\r\n\r\n	if (len - 1 == i)\r\n\r\n	then (if swapped then (y1,x1) else (x1,y1))\r\n\r\n	else ou\' x1 (x0 - x1*q) y1 (y0 - y1*q) (i+1) len qs swapped\r\n\r\n	where q = (qs!!i)\r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5933,56,'romos2007','2013-10-03 21:53:31',1,'{--\r\n\r\nЗадача 13-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\n-- Перебрать первый элемент, а хвост - это то же самое, но на 1 меньше длины\r\n\r\nallLists n k = [(x:xs)| x<-[1..n], xs <- if k>1 then allLists n (k-1) else [[]] ] -- allList n 0 = [[]]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5934,56,'1595828','2013-10-04 00:00:38',1,'allLists n 0=[[]]\r\n\r\nallLists n k =[(x:xs)|x<-[1..n], xs<-allLists n (k-1)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5935,56,'deripaska','2013-10-04 00:36:15',1,'{--\r\n\r\n	task 13-01\r\n\r\nОписать функцию allLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n. \r\n\r\n\r\n\r\nПример вызова:\r\n\r\nallLists 3 2\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\r\n\r\n--}\r\n\r\n\r\n\r\nallLists _ 0 = [[]]\r\n\r\nallLists n k = [(x:xs) | x <- [1..n], xs <- allLists n (k - 1)]\r\n','<br/>Тесты успешно пройдены!'),(5936,129,'egeorge','2013-10-04 00:59:41',1,'mymap f xs = foldr (x res -> (f x):res) [] xs','<br/>Тесты успешно пройдены!'),(5931,56,'romos2007','2013-10-03 21:52:10',0,'{--\r\n\nЗадача 13-1\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\n\r\n\n-- Перебрать первый элемент, а хвост - это то же самое, но на 1 меньше длины\r\n\nallList n k = [(x:xs)| x<-[1..n], xs <- if k>1 then allList n (k-1) else [[]] ] -- allList n 0 = [[]]\r\n\n\r\n\n\n','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(5932,56,'romos2007','2013-10-03 21:52:33',0,'{--\r\n\nЗадача 13-1\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\n\r\n\n-- Перебрать первый элемент, а хвост - это то же самое, но на 1 меньше длины\r\n\nallLists n k = [(x:xs)| x<-[1..n], xs <- if k>1 then allList n (k-1) else [[]] ] -- allList n 0 = [[]]\r\n\n\r\n\n\n','Не удалось вычислить выражение \"allLists 1 1\", проверьте правильность синтаксиса'),(5929,129,'romos2007','2013-10-03 20:51:18',1,'{--\r\n\r\nЗадача 12-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nmymap f xs = foldr (x res -> (f x):res) [] xs\r\n\r\n\r\n\r\n-- для проверки:\r\n\r\n-- realmap f xs = map f xs\r\n','<br/>Тесты успешно пройдены!'),(5930,130,'romos2007','2013-10-03 21:16:49',1,'{--\r\n\r\nЗадача 12-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n-- На каждом шаге инкрементируем позицию элемента,\r\n\r\n-- который прибавляется к следу матрицы, и увеличиваем сам след\r\n\r\ntrace xss = let\r\n\r\n				(ind,res) = foldl ((index,summ) xs-> (index+1,summ+(xs!!index))) (0,0) xss\r\n\r\n			in res\r\n\r\n\r\n\r\n\r\n\r\n-- другой способ.\r\n\r\n-- А как здесь можно записать \"!! . !!\"с помощью карринга? Т.е. хочется i убрать, но у меня не получилось\r\n   --- Я думаю, в вашем случае нельзя убрать, разве что каким-то хитрым искусственным способом.\r\n   --- Потому что если переменная справа встречается два раза, значит придется как-то ее назвать..  \r\n\r\ntrace\' xss = let\r\n\r\n				lxss = length xss\r\n\r\n\r\n\r\n			in sum (map (i -> ((xss !! i) !! i)) [0..lxss-1])\r\n','<br/>Тесты успешно пройдены!'),(5927,53,'romos2007','2013-10-03 20:03:41',1,'{--\r\n\r\nЗадача 12-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\ncoins n = [[c2,c3,c5]|c2<-[0..div n 2],c3<-[0..div n 3],c5<-[0..div n 5],c2*2+c3*3+c5*5==n]\r\n','<br/>Тесты успешно пройдены!'),(5928,54,'romos2007','2013-10-03 20:50:43',1,'{--\r\n\r\nЗадача 12-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Scheme t = Resistance t |\r\n\r\n				Parallel (Scheme t) (Scheme t) |\r\n\r\n				Sequential (Scheme t) (Scheme t)\r\n\r\n\r\n\r\ntotalResistance (Resistance t) = t\r\n\r\ntotalResistance (Sequential r1 r2) = totalResistance r1 + totalResistance r2\r\n\r\ntotalResistance (Parallel r1 r2) = (totalResistance r1) * (totalResistance r2) / (totalResistance r1 + totalResistance r2)\r\n   --- Так лучше не писать, потому что у вас totalResistance r1 и totalResistance r2 вызываются по два раза.\r\n   --- А для рекурсии это очень существенно. Те лучше использовать let, например\r\n\r\n','<br/>Тесты успешно пройдены!'),(5926,48,'3270666','2013-10-03 19:52:21',1,'myreverse xs = (foldr (x f -> f . (x:)) (id) xs) []','<br/>Тесты успешно пройдены!'),(5925,45,'1170660','2013-10-03 19:26:49',2,'﻿using System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Check\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n      \r\n\r\n        static bool checkOdd(int[][] a,int n)\r\n\r\n        { \r\n\r\n		  bool result =false;  \r\n\r\n		  bool[] temp = new bool[n];\r\n\r\n          \r\n\r\n          for(int i=0;i<n;i++){\r\n\r\n		  \r\n\r\n			temp[i]=a[i].Any(x=>x%2==0);		  \r\n\r\n			}		  \r\n\r\n        		  \r\n\r\n          for(int i=0;i<n;i++){\r\n\r\n           result=result||temp[i];\r\n   --- Не совсем так. Во первых, в тут проверяете, что хотя бы в одном из массивов есть\r\n   --- четный элемент. А в условии написано *в каждом*.\r\n   --- Во вторых, для проверки массива temp попробуйте, пожалуйста, тоже воспользоваться Any или All\r\n   --- Это очень просто (но если что, пишите, я подскажу)  \r\n          }		 \r\n\r\n		\r\n\r\n	      return result;		\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {   bool result=false;\r\n\r\n			int n = 10;\r\n\r\n            var a = new int[n][];\r\n\r\n            for (int i = 0; i < n; i++)\r\n\r\n            {\r\n\r\n                a[i] = new int[n];\r\n\r\n                \r\n\r\n                for(int j=0;j<n;j++){\r\n\r\n                	a[i][j]=i+j;\r\n\r\n                	//Console.WriteLine(a[i][j]);\r\n\r\n                }\r\n\r\n                //Console.WriteLine(\"======\");\r\n\r\n            }\r\n\r\n			\r\n\r\n			result=checkOdd(a,n);\r\n\r\n            \r\n\r\n			Console.WriteLine(result);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5923,47,'3270666','2013-10-03 19:09:46',1,'powerset xs = let l = length xs\r\n                  n = 2^l - 1\r\n              in map (i -> genSet xs (toBinary i)) [0..n]\r\n\r\ngenSet xs [] = []\r\ngenSet (x:xs) (b:binx) = if (b == 0) then genSet xs binx else x : genSet xs binx\r\n\r\ntoBinary 0 = []\r\ntoBinary x = (x `mod` 2) : toBinary (x `div` 2)','<br/>Тесты успешно пройдены!'),(5924,44,'517309','2013-10-03 19:15:12',3,'dioph [a,0,c,d] [0,l,m,n] = let\r\n								f = i -> mod (d - c*i) a == 0 \r\n								g = j -> mod (n - m*j) l == 0 \r\n								ans = foldr (k res -> if f k && (g k) then k else res ) 0 [0..2^32]\r\n							in [div (d-c*ans) a, div (n-m*ans) l, ans]  \r\n\r\ndioph [a,b,c,d] [0,l,m,n] = let \r\n								lc = lcm b l \r\n								lb = div lc b\r\n								ll = div lc l\r\n								f x y = -lb*x + ll*y \r\n							in dioph [(f a 0),(f b l),(f c m),(f d n)] [0,l,m,n]\r\ndioph [a,b,c,d] [k,l,m,n] = let \r\n								lc =  lcm a b \r\n								la = div lc a\r\n								lk = div lc k\r\n								f x y = lk*x - la*y\r\n							in dioph [a,b,c,d] [(f k a ), (f l b),(f m c),(f n d)] ','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z\", проверьте правильность синтаксиса'),(5922,44,'517309','2013-10-03 19:05:13',0,'dioph [a,0,c,d] [0,l,m,n] = let\r\n								f = i -> mod (d - c*i) a == 0 \r\n								g = j -> mod (n - m*j) l == 0 \r\n								ans = foldr (k res -> if f k && (g k) then k else res ) 0 [0..2^32]\r\n							in (div (d-c*ans) a, div (n-m*ans) l, ans)  \r\n\r\ndioph [a,b,c,d] [0,l,m,n] = let \r\n								lc = lcm b l \r\n								lb = div lc b\r\n								ll = div lc l\r\n								f x y = -lb*x + ll*y \r\n							in dioph [(f a 0),(f b l),(f c m),(f d n)] [0,l,m,n]\r\ndioph [a,b,c,d] [k,l,m,n] = let \r\n								lc =  lcm a b \r\n								la = div lc a\r\n								lk = div lc k\r\n								f x y = lk*x - la*y\r\n							in dioph [a,b,c,d] [(f k a ), (f l b),(f m c),(f n d)] ','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5921,43,'517309','2013-10-03 19:04:35',3,'euclid 1 0 = (1,0)\r\neuclid 0 1 = (0,1)\r\n\r\neuclid a b = bezout [a,1,0] [b,0,1]\r\n\r\nbezout [x,ax,bx] [y,ay,by] = if mod x y == 0 \r\n  then (ay,by) \r\n  else bezout [y,ay,by] [(mod x y), ax - k*ay, bx - k*by] \r\n where k = div x y','<br/>Тесты успешно пройдены!'),(5920,43,'517309','2013-10-03 19:00:35',0,'euclid a b = bezout [a,1,0] [b,0,1]\r\n\r\nbezout [x,ax,bx] [y,ay,by] = if mod x y == 0 then (ay,by) \r\n								else bezout [y,ay,by] [(mod x y), ax - k*ay, bx - k*by] \r\n									where k = div x y\r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5919,44,'42284313','2013-10-03 18:34:17',1,'{--\r\n\r\n*Доп задача, до 3.10*\r\n\r\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\r\n\r\n\r\n\r\na*x+b*y+c*z=d\r\n\r\nk*x+l*y+m*z=n\r\n\r\n\r\n\r\nЗамечания: \r\n\r\n- Что делать, если таких чисел нет - на ваше усмотрение. Можно выдать ошибку, можно вернуть (0, 0, 0) и т.д. В тестах таких случаев не будет.\r\n\r\n- Числа в тестах могут быть достаточно большими для того, чтобы эту задачу не было смысла решать простым перебором, надо придумать что-то более эффективное.\r\n\r\n- Эта задача не то чтобы очень сложная, но решение, которое я знаю - довольно громоздкое, в нем надо рассматривать разные вырожденные случаи и т.д.. Т.е. это для тех, кому интересно решить что-то немного посложнее. Но зато за нее будет 2 балла. \r\n\r\n--}\r\n\r\n\r\n\r\neuclid a b \r\n\r\n  | a == 0 = (0, div b (abs b))\r\n\r\n  | otherwise =\r\n\r\n      let\r\n\r\n        (resX, resY) = euclid (mod b a) a\r\n\r\n      in (resY - (div b a) * resX, resX)\r\n\r\n\r\n\r\neuclidMult a b res = \r\n\r\n    let\r\n\r\n      (x,y) = euclid a b\r\n\r\n      d = div res (gcd a b)\r\n\r\n    in (x*d, y*d)\r\n\r\n\r\n\r\ndioph\' [a,b,c,d]\r\n\r\n  | b /= 0 = \r\n\r\n      let\r\n\r\n        (y, z) = euclid b c\r\n\r\n        gcdBC = gcd b c\r\n\r\n        (x, koef) = euclidMult a gcdBC d\r\n\r\n      in [x, y*koef, z*koef]\r\n\r\n  | a /= 0 =\r\n\r\n      let\r\n\r\n        [y,x,z] = dioph\' [b,a,c,d]\r\n\r\n      in [x,y,z]\r\n\r\n  | c /= 0 =\r\n\r\n      let\r\n\r\n        [x,z,y] = dioph\' [a,c,b,d]\r\n\r\n      in [x,y,z]\r\n\r\n  | otherwise = [0,0,0]\r\n\r\n\r\n\r\ndioph [a,b,c,d] [k,l,m,n]\r\n\r\n  | a*n == d*k && b*n == d*l && c*n == d*m = \r\n\r\n      if d == 0 && n == 0 then [0,0,0]\r\n\r\n      else if d == 0 then dioph\' [k,l,m,n]\r\n\r\n      else dioph\' [a,b,c,d]\r\n\r\n\r\n\r\n  | b*k == a*l && c*k == a*m = [0,0,0]\r\n\r\n\r\n\r\n  | b*k /= a*l && c*k == a*m =\r\n\r\n      let\r\n\r\n        y = div (d*k - n*a) (b*k - l*a)\r\n\r\n      in if a == 0 && c == 0\r\n\r\n         then \r\n\r\n           let\r\n\r\n             (x, z) = euclidMult k m (n - l*y)\r\n\r\n           in [x, y, z]\r\n\r\n         else\r\n\r\n           let\r\n\r\n             (x, z) = euclidMult a c (d - b*y)\r\n\r\n           in [x, y, z]\r\n\r\n\r\n\r\n  | b*k == a*l && c*k /= a*m =\r\n\r\n      let\r\n\r\n        z = div (d*k - n*a) (c*k - m*a)\r\n\r\n      in if a == 0 && b == 0\r\n\r\n         then \r\n\r\n           let\r\n\r\n             (x, y) = euclidMult k l (n - m*z)\r\n\r\n           in [x, y, z]\r\n\r\n         else\r\n\r\n           let\r\n\r\n             (x, y) = euclidMult a b (d - c*z)\r\n\r\n           in [x, y, z]\r\n\r\n\r\n\r\n  | a*n /= d*k =\r\n\r\n      let\r\n\r\n        k1 = b*k - l*a\r\n\r\n        k2 = c*k - m*a\r\n\r\n        (y, z) = euclidMult k1 k2 (d*k - n*a)\r\n\r\n        gcdK12 = gcd k1 k2\r\n\r\n        m1 = div k1 gcdK12\r\n\r\n        m2 = div k2 gcdK12\r\n\r\n        k3 = b*m2 - c*m1\r\n\r\n        k4 = d - b*y - c*z\r\n\r\n        (x, t) = euclidMult a k3 k4\r\n\r\n      in [x, y + m2*t, z - m1*t]\r\n\r\n\r\n\r\n  | a*n == d*k =\r\n\r\n      let\r\n\r\n        k1 = div (b*k - l*a) (m*a - c*k)\r\n\r\n        k2 = b + k1*c\r\n\r\n        (x, y) = euclidMult a k2 d\r\n\r\n      in [x, y, k*y]\r\n','<br/>Тесты успешно пройдены!'),(5907,53,'egeorge','2013-10-03 13:31:34',1,'coins n = [[k,l,m] | k <- [0..(n `div` 2)], l <- [0..(n `div` 3)], m <- [0..(n `div` 5)], 2*k + 3*l + 5*m == n]','<br/>Тесты успешно пройдены!'),(5908,43,'1595828','2013-10-03 14:42:49',1,'euclid a b\r\n\r\n	| a == 0    = (0,1)\r\n\r\n	| otherwise = (y - (div b a) * x, x)\r\n\r\n				where (x, y) = euclid (mod b a) a\r\n\r\n	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5909,43,'284427','2013-10-03 14:48:06',1,'\r\n\r\n\r\neuclid 0 b = (0,1)\r\n\r\neuclid a b =\r\n\r\n	let (x1,y1) = euclid (b `mod` a) a in\r\n\r\n	if not (gcd a b == 1) \r\n\r\n	then (0, 0)\r\n\r\n	else ((y1 - (b `div` a) * x1),x1)\r\n\r\n	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5910,45,'1595828','2013-10-03 15:06:45',1,'using System.Linq;\r\nnamespace zd8_1\r\n{\r\n	class zd\r\n	{\r\n		static bool Check_even(int[][] array)\r\n		{\r\n            return array.All(x => x.Any(y => y % 2 == 0));\r\n		}\r\n		\r\n		static void Main(string[] args)\r\n		{\r\n			int[][] arr_odd = { new int[] {1, 3, 5}, new int[] {5, 7, 8, 9}};\r\n			int[][] arr_even = { new int[] {1, 2, 3, 4}, new int[] {5, 6, 7}};\r\n            System.Console.WriteLine(\"{0}\", Check_even(arr_odd));\r\n            System.Console.WriteLine(\"{0}\", Check_even(arr_even));\r\n            System.Console.ReadKey();\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(5911,53,'1595828','2013-10-03 15:42:21',1,'coins n =[ [a,b,c] |a<-[0..n], b<-[0..n],c<-[0..n] , a*2+b*3+c*5 == n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5912,129,'1595828','2013-10-03 16:06:33',1,'mymap f xs = foldr(x res ->[f(x)]++ res ) [] xs\r\n','<br/>Тесты успешно пройдены!'),(5913,130,'1595828','2013-10-03 16:45:53',1,'trace xs=trace\' xs 0 0\r\n\r\ntrace\' [] _ sum= sum\r\n\r\ntrace\' (x:xs) n sum= trace\' xs (n+1) (x!!n+sum) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5914,48,'3226573','2013-10-03 16:46:24',0,'processElem i xs = (x:xs) \r\n                   where x = xs !! (i * 2)\r\nmyreverse xs = take d (foldr processElem xs [0..(d-1)])\r\n               where d = (length xs)','Не удалось вычислить выражение \"myreverse [1,2,3,4]\", проверьте правильность синтаксиса'),(5915,48,'3226573','2013-10-03 17:12:07',2,'  --- Нет, взятие индекса работает за O(N), так что этот вариант не подойдет, к сожалению.  \r\n-- Если в листе взятие элемента по индексу делается за O(1), то это решение работает за O(n)\r\nprocessElem d i xs = (x:xs) \r\n					 where x = xs !! ((d-1-i) * 2)\r\nmyreverse xs = take d (foldr (processElem d) xs [0..(d-1)])\r\n               where d = (length xs)','<br/>Тесты успешно пройдены!'),(5916,54,'egeorge','2013-10-03 17:59:34',1,'data Scheme = Resistance Double |\r\n              Parallel Scheme Scheme |\r\n              Series Scheme Scheme\r\n			  \r\ntotalResistance (Resistance r) = r\r\n\r\ntotalResistance (Series r1 r2) = (totalResistance r1) + (totalResistance r2)\r\n\r\ntotalResistance (Parallel r1 r2) = let r1Total = totalResistance r1\r\n                                       r2Total = totalResistance r2\r\n                                   in  (r1Total * r2Total) / (r1Total+ r2Total)','<br/>Тесты успешно пройдены!'),(5917,44,'42284313','2013-10-03 18:26:33',0,'{--\n\n*Доп задача, до 3.10*\n\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\n\n\n\na*x+b*y+c*z=d\n\nk*x+l*y+m*z=n\n\n\n\nЗамечания: \n\n- Что делать, если таких чисел нет - на ваше усмотрение. Можно выдать ошибку, можно вернуть (0, 0, 0) и т.д. В тестах таких случаев не будет.\n\n- Числа в тестах могут быть достаточно большими для того, чтобы эту задачу не было смысла решать простым перебором, надо придумать что-то более эффективное.\n\n- Эта задача не то чтобы очень сложная, но решение, которое я знаю - довольно громоздкое, в нем надо рассматривать разные вырожденные случаи и т.д.. Т.е. это для тех, кому интересно решить что-то немного посложнее. Но зато за нее будет 2 балла. \n\n--}\n\n\n\neuclid a b \n\n  | a == 0 = (0, div b (abs b))\n\n  | otherwise =\n\n      let\n\n        (resX, resY) = euclid (mod b a) a\n\n      in (resY - (div b a) * resX, resX)\n\n\n\neuclidMult a b res = \n\n    let\n\n      (x,y) = euclid a b\n\n      d = div res (gcd a b)\n\n    in (x*d, y*d)\n\n\n\ndioph\' [a,b,c,d]\n\n  | b /= 0 = \n\n      let\n\n        (y, z) = euclid b c\n\n        gcdBC = gcd b c\n\n        (x, koef) = euclidMult a gcdBC d\n\n      in [x, y*koef, z*koef]\n\n  | a /= 0 =\n\n      let\n\n        [y,x,z] = dioph\' [b,a,c,d]\n\n      in [x,y,z]\n\n  | c /= 0 =\n\n      let\n\n        [x,z,y] = dioph\' [a,c,b,d]\n\n      in [x,y,z]\n\n  | otherwise = [0,0,0]\n\n\n\ndioph [a,b,c,d] [k,l,m,n]\n\n  | a*n == d*k && b*n == d*l && c*n == d*m = \n\n      if d == 0 || n == 0 then [0,0,0]\n\n      else dioph\' [a,b,c,d]\n\n\n\n  | b*k == a*l && c*k == a*m = [0,0,0]\n\n\n\n  | b*k /= a*l && c*k == a*m =\n\n      let\n\n        y = div (d*k - n*a) (b*k - l*a)\n\n      in if a == 0 && c == 0\n\n         then [0, y, 0]\n\n         else\n\n           let\n\n             (x, z) = euclidMult a c (d - b*y)\n\n           in [x, y, z]\n\n\n\n  | b*k == a*l && c*k /= a*m =\n\n      let\n\n        z = div (d*k - n*a) (c*k - m*a)\n\n      in if a == 0 && b == 0\n\n         then [0, 0, z]\n\n         else\n\n           let\n\n             (x, y) = euclidMult a b (d - c*z)\n\n           in [x, y, z]\n\n\n\n  | a*n /= d*k =\n\n      let\n\n        k1 = b*k - l*a\n\n        k2 = c*k - m*a\n\n        (y, z) = euclidMult k1 k2 (d*k - n*a)\n\n        gcdK12 = gcd k1 k2\n\n        m1 = div k1 gcdK12\n\n        m2 = div k2 gcdK12\n\n        k3 = b*m2 - c*m1\n\n        k4 = d - b*y - c*z\n\n        (x, t) = euclidMult a k3 k4\n\n      in [x, y + m2*t, z - m1*t]\n\n\n\n  | a*n == d*k =\n\n      let\n\n        k1 = div (b*k - l*a) (m*a - c*k)\n\n        k2 = b + k1*c\n\n        (x, y) = euclidMult a k2 d\n\n      in [x, y, k*y]\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y'),(5918,44,'42284313','2013-10-03 18:29:30',0,'{--\n\n*Доп задача, до 3.10*\n\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\n\n\n\na*x+b*y+c*z=d\n\nk*x+l*y+m*z=n\n\n\n\nЗамечания: \n\n- Что делать, если таких чисел нет - на ваше усмотрение. Можно выдать ошибку, можно вернуть (0, 0, 0) и т.д. В тестах таких случаев не будет.\n\n- Числа в тестах могут быть достаточно большими для того, чтобы эту задачу не было смысла решать простым перебором, надо придумать что-то более эффективное.\n\n- Эта задача не то чтобы очень сложная, но решение, которое я знаю - довольно громоздкое, в нем надо рассматривать разные вырожденные случаи и т.д.. Т.е. это для тех, кому интересно решить что-то немного посложнее. Но зато за нее будет 2 балла. \n\n--}\n\n\n\neuclid a b \n\n  | a == 0 = (0, div b (abs b))\n\n  | otherwise =\n\n      let\n\n        (resX, resY) = euclid (mod b a) a\n\n      in (resY - (div b a) * resX, resX)\n\n\n\neuclidMult a b res = \n\n    let\n\n      (x,y) = euclid a b\n\n      d = div res (gcd a b)\n\n    in (x*d, y*d)\n\n\n\ndioph\' [a,b,c,d]\n\n  | b /= 0 = \n\n      let\n\n        (y, z) = euclid b c\n\n        gcdBC = gcd b c\n\n        (x, koef) = euclidMult a gcdBC d\n\n      in [x, y*koef, z*koef]\n\n  | a /= 0 =\n\n      let\n\n        [y,x,z] = dioph\' [b,a,c,d]\n\n      in [x,y,z]\n\n  | c /= 0 =\n\n      let\n\n        [x,z,y] = dioph\' [a,c,b,d]\n\n      in [x,y,z]\n\n  | otherwise = [0,0,0]\n\n\n\ndioph [a,b,c,d] [k,l,m,n]\n\n  | a*n == d*k && b*n == d*l && c*n == d*m = \n\n      if d == 0 && n == 0 then [0,0,0]\n\n      else if d == 0 then dioph\' [k,l,m,n]\n\n      else dioph\' [a,b,c,d]\n\n\n\n  | b*k == a*l && c*k == a*m = [0,0,0]\n\n\n\n  | b*k /= a*l && c*k == a*m =\n\n      let\n\n        y = div (d*k - n*a) (b*k - l*a)\n\n      in if a == 0 && c == 0\n\n         then [0, y, 0]\n\n         else\n\n           let\n\n             (x, z) = euclidMult a c (d - b*y)\n\n           in [x, y, z]\n\n\n\n  | b*k == a*l && c*k /= a*m =\n\n      let\n\n        z = div (d*k - n*a) (c*k - m*a)\n\n      in if a == 0 && b == 0\n\n         then [0, 0, z]\n\n         else\n\n           let\n\n             (x, y) = euclidMult a b (d - c*z)\n\n           in [x, y, z]\n\n\n\n  | a*n /= d*k =\n\n      let\n\n        k1 = b*k - l*a\n\n        k2 = c*k - m*a\n\n        (y, z) = euclidMult k1 k2 (d*k - n*a)\n\n        gcdK12 = gcd k1 k2\n\n        m1 = div k1 gcdK12\n\n        m2 = div k2 gcdK12\n\n        k3 = b*m2 - c*m1\n\n        k4 = d - b*y - c*z\n\n        (x, t) = euclidMult a k3 k4\n\n      in [x, y + m2*t, z - m1*t]\n\n\n\n  | a*n == d*k =\n\n      let\n\n        k1 = div (b*k - l*a) (m*a - c*k)\n\n        k2 = b + k1*c\n\n        (x, y) = euclidMult a k2 d\n\n      in [x, y, k*y]\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [0,1,0,0] [1,1,0,10] in (y,x+y)'),(5906,43,'42284313','2013-10-03 12:47:48',1,'{--\r\n\r\n    Task 1\r\n\r\n    *Доп задача, до 7.10*\r\n\r\n    У функции два параметра - целые числа a и b. Точно известно, что они взаимно простые. Функция должна вернуть такую пару целых чисел x и y, что a*x + b*y == 1. (Таких пар, конечно, бесконечно много, можно вернуть любую).\r\n\r\n\r\n\r\n    Пример вызова:\r\n\r\n    euclid 3 5\r\n\r\n    Должно получиться (2, -1), потому что 3*2+5*(-1) == 1\r\n\r\n\r\n\r\n    Замечания:\r\n\r\n    - Если a и b не взаимно простые, то функция может делать что угодно (например, аварийно завершаться, или выдавать любой ответ).\r\n\r\n    - Желательно, чтобы функция быстро работала для _очень_ больших чисел, например, для 2^100 и 3^100. Но, если не получится, напишите любое решение, не обязательно очень эффективное (например, которое ищет решения перебором).\r\n\r\n    - Подсказка: идея, которую можно использовать для эффективного решения, была впервые опубликована примерно в 300 г. до н.э. :)\r\n\r\n--}\r\n\r\neuclid a b\r\n\r\n    | a == 0 = (0, 1)\r\n\r\n    | otherwise = let (resX, resY) = euclid (mod b a) a\r\n\r\n                      in (resY - (div b a) * resX, resX)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5904,129,'nbumakov','2013-10-03 11:09:42',1,'mymap f = foldr ( x xs -> (f x : xs)) []','<br/>Тесты успешно пройдены!'),(5905,130,'nbumakov','2013-10-03 11:10:02',1,'trace xs = foldr  (i s -> s+((xs !! i) !! i)) 0 [0..length xs - 1]','<br/>Тесты успешно пройдены!'),(5900,129,'55363692','2013-10-03 01:27:02',1,'mymap f xs = foldr (cur res ys -> ((f cur) : (res ys))) id xs []\r\n  --- А зачем вы тут используете работу с функциями? (id и т.д.) Тут, мне кажется, и без этого просто получается.\r\n','<br/>Тесты успешно пройдены!'),(5901,130,'55363692','2013-10-03 01:34:10',1,'trace xs = sum [((xs !! i) !! i) | i <- [0..(n - 1)]] where n = length xs\r\n','<br/>Тесты успешно пройдены!'),(5902,54,'55363692','2013-10-03 01:49:26',1,'data Scheme a = Res a | Par (Scheme a) (Scheme a) | Seq (Scheme a) (Scheme a)\r\n\r\n\r\n\r\ntotalResistance (Res a) = a\r\n\r\ntotalResistance (Par a b) = (r1 * r2) / (r1 + r2) where \r\n\r\n	r1 = totalResistance a\r\n\r\n	r2 = totalResistance b \r\n\r\ntotalResistance (Seq a b) = r1 + r2 where \r\n\r\n	r1 = totalResistance a\r\n\r\n	r2 = totalResistance b\r\n','<br/>Тесты успешно пройдены!'),(5903,53,'nbumakov','2013-10-03 11:09:17',1,'coins n = [[x,y,z]|x<-[0..div n 2], y<-[0..div n 3], z<-[0..div n 5], 2*x+3*y+5*z==n]','<br/>Тесты успешно пройдены!'),(5899,54,'55363692','2013-10-03 01:16:56',0,'data Scheme a = Res a | Par (Scheme a) (Scheme a) | Seq (Scheme a) (Scheme a)\n\n\n\ntotalResistance (Res a) = a\n\ntotalResistance (Par a b) = (r1 + r2) / (r1 * r2) where \n\n	r1 = totalResistance a\n\n	r2 = totalResistance b \n\ntotalResistance (Seq a b) = r1 + r2 where \n\n	r1 = totalResistance a\n\n	r2 = totalResistance b\n','<br/>Тесты успешно пройдены!'),(5898,53,'55363692','2013-10-03 00:57:40',1,'coins n = [[k, l, m] | k <- [0..(n `div` 2)], l <- [0..(n `div` 3)], m <- [0..(n `div` 5)], 2 * k + 3 * l + 5 * m == n]\r\n','<br/>Тесты успешно пройдены!'),(5897,44,'artem.gomerman','2013-10-03 00:26:39',2,'  --- Надо, вилимо, рассмотреть, разные вырожденные частные случаи \r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let\r\n\r\n	dir = (direction [a:b:c:d:[], k:l:m:n:[]])\r\n\r\n	in if (first dir) /= 0 \r\n\r\n		then [0,(determinant [[d, c], [n, m]]),(determinant [[b, d], [l, n]])]\r\n\r\n		else if (second dir) /= 0\r\n\r\n			then [ (determinant [[d, c], [n, m]]),0 ,(determinant [[a, d], [k, n]])]\r\n\r\n			else if (third dir) /= 0\r\n\r\n				then [(determinant [[d, b], [n, l]]),(determinant [[a, d], [k, n]]),0]\r\n\r\n				else [0,0,0]\r\n\r\n\r\n\r\nfirst (x, _, _) = x\r\n\r\nsecond (_, x, _) = x\r\n\r\nthird (_, _, x) = x\r\n\r\ndirection [a:b:c:xs, k:l:m:ys] = (determinant [[b, c], [l, m]], determinant [[a, c], [k, m]], determinant [[a, b], [k, l]])\r\n\r\ndeterminant ([x:y:[],k:m:[]]) = x * m - y * k\r\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z'),(5893,54,'2156724','2013-10-02 21:44:52',1,'data Scheme =\r\n     R Double |\r\n     ParallelScheme Scheme Scheme |\r\n     PosledScheme Scheme Scheme\r\n\r\n\r\ntotalResistance (R r) = r\r\ntotalResistance (ParallelScheme s1 s2) = \r\n	1/(1/(totalResistance s1) + 1/(totalResistance s2))\r\ntotalResistance (PosledScheme s1 s2) = \r\n	totalResistance s1 + totalResistance s2\r\n\r\n--- Забыл, сначала везде была функция f, а потом в торопях исправил только название а внутри забыл','<br/>Тесты успешно пройдены!'),(5894,44,'artem.gomerman','2013-10-02 23:54:04',0,'dioph [a:b:c:d:[], k:l:m:n:[]] = let\r\n\n	dir = (direction [a:b:c:d:[], k:l:m:n:[]])\r\n\n	in if (first dir) /= 0 \r\n\n		then (0, determinant [[d, c], [n, m]] / (first dir), determinant [[b, d], [l, n]] / (first dir))\r\n\n		else if (second dir) /= 0\r\n\n			then (determinant [[d, c], [n, m]], 0, determinant [[a, d], [k, n]])\r\n\n			else if (third dir) /= 0\r\n\n				then (determinant [[d, b], [n, l]], determinant [[a, d], [k, n]], 0)\r\n\n				else (0, 0, 0)\r\n\nfirst (x, _, _) = x\r\n\nsecond (_, x, _) = x\r\n\nthird (_, _, x) = x\r\n\ndirection [a:b:c:xs, k:l:m:ys] = (determinant [[b, c], [l, m]], determinant [[a, c], [k, m]], determinant [[a, b], [k, l]])\r\n\ndeterminant ([x:y:[],k:m:[]]) = x * m - y * k\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5895,44,'artem.gomerman','2013-10-03 00:03:30',0,'dioph (a:b:c:d:[]) (k:l:m:n:[]) = let\r\n\n	dir = (direction [a:b:c:d:[], k:l:m:n:[]])\r\n\n	in if (first dir) /= 0 \r\n\n		then (0, determinant [[d, c], [n, m]] / (first dir), determinant [[b, d], [l, n]] / (first dir))\r\n\n		else if (second dir) /= 0\r\n\n			then (determinant [[d, c], [n, m]], 0, determinant [[a, d], [k, n]])\r\n\n			else if (third dir) /= 0\r\n\n				then (determinant [[d, b], [n, l]], determinant [[a, d], [k, n]], 0)\r\n\n				else (0, 0, 0)\r\n\nfirst (x, _, _) = x\r\n\nsecond (_, x, _) = x\r\n\nthird (_, _, x) = x\r\n\ndirection [a:b:c:xs, k:l:m:ys] = (determinant [[b, c], [l, m]], determinant [[a, c], [k, m]], determinant [[a, b], [k, l]])\r\n\ndeterminant ([x:y:[],k:m:[]]) = x * m - y * k\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5896,44,'artem.gomerman','2013-10-03 00:12:30',0,'dioph (a:b:c:d:[]) (k:l:m:n:[]) = let\r\n\n	dir = (direction [a:b:c:d:[], k:l:m:n:[]])\r\n\n	in if (first dir) /= 0 \r\n\n		then [0,((determinant [[d, c], [n, m]]) / (first dir)),((determinant [[b, d], [l, n]]) / (first dir))]\r\n\n		else if (second dir) /= 0\r\n\n			then [ ((determinant [[d, c], [n, m]]) / (second dir)),0 ,((determinant [[a, d], [k, n]]) / (second dir))]\r\n\n			else if (third dir) /= 0\r\n\n				then [((determinant [[d, b], [n, l]]) / (third dir)),((determinant [[a, d], [k, n]]) / (third dir)),0]\r\n\n				else [0,0,0]\r\n\n\r\n\nfirst (x, _, _) = x\r\n\nsecond (_, x, _) = x\r\n\nthird (_, _, x) = x\r\n\ndirection [a:b:c:xs, k:l:m:ys] = (determinant [[b, c], [l, m]], determinant [[a, c], [k, m]], determinant [[a, b], [k, l]])\r\n\ndeterminant ([x:y:[],k:m:[]]) = x * m - y * k\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),(5892,130,'2156724','2013-10-02 21:16:31',1,'func [] i n = 0\r\n\r\nfunc (x:xs) i n =\r\n\r\n   if i == n then 0\r\n\r\n   else\r\n\r\n    (x !! i)  + func xs (i+1) n   \r\n\r\n   \r\n\r\n\r\n\r\ntrace (x:xs) = func (x:xs) 0 (length (x:xs))\r\n\r\n\r\n\r\n  \r\n','<br/>Тесты успешно пройдены!'),(5891,129,'2156724','2013-10-02 21:15:07',1,'mymap f [] = []\r\n\r\nmymap f (x:xs) = foldr (i -> ((f i):)) [] (x:xs)\r\n','<br/>Тесты успешно пройдены!'),(5890,129,'2156724','2013-10-02 21:13:58',0,'mymap f (x:xs) = foldr (i -> ((f i):)) [] (x:xs)\n','Не удалось вычислить выражение \"mymap (*3) []\", проверьте правильность синтаксиса'),(5888,48,'12828920','2013-10-02 17:35:46',1,'  --- А что же вы прошлое решение убрали? :) Я честно говоря, просто не успел помотреть ваши возражения.\r\n  --- Вы как считаете, ваше предыдущее решение все-таки было линейным? Если вы считаете что да, пришлите\r\n  --- его, пожалуйста (или выложите сюда), я посмотрю.\r\nf x xs = x:xs\r\n\r\nmyreverse xs = (foldr (i k->k.f i) id xs) []\r\n','<br/>Тесты успешно пройдены!'),(5889,54,'2156724','2013-10-02 21:13:34',2,'data Scheme =\r\n\r\n     R Double |\r\n\r\n     ParallelScheme Scheme Scheme |\r\n\r\n     PosledScheme Scheme Scheme\r\n\r\n\r\n\r\n\r\n\r\ntotalResistance (R r) = r\r\n\r\ntotalResistance (ParallelScheme s1 s2) = \r\n\r\n	1/(1/(f s1) + 1/(f s2))\r\n   --- Что это за функция f тут у вас участвует, не очень понятно??\r\ntotalResistance (PosledScheme s1 s2) = \r\n\r\n	f s1 + f s2\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5886,53,'15309342','2013-10-02 10:12:25',1,'coins n = [[k, l, m] | k <- [0..n], l <- [0..n], m <- [0..n], 2 * k + 3 * l + 5 * m == n]','<br/>Тесты успешно пройдены!'),(5887,45,'2156724','2013-10-02 11:27:15',1,'задача отправлена по почте\r\n','<br/>Тесты успешно пройдены!'),(5885,130,'15309342','2013-10-02 09:49:36',1,'trace n = fst (foldl ((sum, i) x -> (((x !! i) + sum), i + 1)) (0, 0) n)','<br/>Тесты успешно пройдены!'),(5884,43,'1990147','2013-10-02 04:14:33',1,'cubeTable n = zip ([1..n]) (map (i->i*i*i) [1..n])\r\n\r\n\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nheight myTree = treeHeight\' myTree 0\r\n\r\ntreeHeight\' Empty nowh = nowh\r\n\r\ntreeHeight\' (Node val left right) nowh = let {ldeep = treeHeight\' left (nowh+1); rdeep = treeHeight\' right (nowh+1)} \r\n\r\n                                         in  if ( ldeep > rdeep) then ldeep else rdeep\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmin4 a b c d = let abmin=(min a b)\r\n\r\n                   cdmin=(min c d) \r\n\r\n               in if (abmin>0) then if (cdmin>0) then min abmin cdmin \r\n\r\n                                    else abmin\r\n\r\n                  else cdmin \r\n\r\ncheck 1 0 = True\r\n\r\ncheck a 0 = False\r\n\r\ncheck a b = check b (mod a b)\r\n\r\n\r\n\r\neuclid a b = if (b==0 && a==1) then (1,0) else\r\n\r\n             if (b==0 && a==(-1)) then (-1,0) else\r\n\r\n             if (a==0 && b==1) then (0,1) else\r\n\r\n             if (a==0 && b==(-1)) then (0,-1) else\r\n\r\n             if (check a b) then if (a<b) then xyfinder a b (mod b a) (- (div b a)) 1 else xyfinder a b (mod a b) 1 (-(div a b))\r\n\r\n             else (0,0)\r\n\r\n\r\n\r\nxyfinder a b 1 xnow ynow = (xnow, ynow)\r\n\r\nxyfinder a b (-1) xnow ynow = ((-xnow),(-ynow))\r\n\r\n\r\n\r\nxyfinder a b nowp xnow ynow = let  a1 = mod a nowp \r\n\r\n                                   a2 = nowp-a1\r\n\r\n                                   b1 = mod b nowp \r\n\r\n                                   b2 = nowp-b1 \r\n\r\n                                   minel = min4 a1 a2 b1 b2\r\n\r\n                               in if ( a1 == minel ) then xyfinder a b a1 (-xnow * (div a nowp) + 1) (-ynow * (div a nowp)) \r\n\r\nelse if ( minel == a2) then xyfinder a b a2 (xnow * ((div a nowp) + 1) - 1) ( ynow *((div a nowp) + 1)) \r\n\r\nelse if ( minel == b1) then xyfinder a b b1 (-xnow * (div b nowp)) (-ynow * (div b nowp) + 1) \r\n\r\nelse xyfinder a b b2 ((xnow * ((div b nowp) + 1))) ( ynow * ((div b nowp) + 1) - 1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5881,129,'15309342','2013-10-02 02:36:00',1,'mymap f xs = foldr ((:) . f) [] xs','<br/>Тесты успешно пройдены!'),(5882,45,'1990147','2013-10-02 02:42:27',2,'--- Не совсем по условию. Там вель написано:\r\n--- \"код должен быть таким, чтобы его можно было скомпилировать и запустить, с каким-нибудь примером вызова.\"\r\n--- Те выложите, пожалуйста, полный код.\r\n\r\n int[][] a = \r\n{\r\n    new int[] {1,3,5,7,9},\r\n    new int[] {0,2,4,6},\r\n    new int[] {11,22}\r\n};\r\nbool chetn_vezde= a.All(x=>x.Any(y=>y % 2 == 0));','<br/>Тесты успешно пройдены!'),(5883,43,'1990147','2013-10-02 04:03:02',0,'cubeTable n = zip ([1..n]) (map (i->i*i*i) [1..n])\r\n\n\r\n\ndata Tree = Empty | Node Integer Tree Tree\r\n\nheight myTree = treeHeight\' myTree 0\r\n\ntreeHeight\' Empty nowh = nowh\r\n\ntreeHeight\' (Node val left right) nowh = let {ldeep = treeHeight\' left (nowh+1); rdeep = treeHeight\' right (nowh+1)} \r\n\n                                         in  if ( ldeep > rdeep) then ldeep else rdeep\r\n\n\r\n\n\r\n\n\r\n\nmin4 a b c d = let abmin=(min a b)\r\n\n                   cdmin=(min c d) \r\n\n               in if (abmin>0) then if (cdmin>0) then min abmin cdmin \r\n\n                                    else abmin\r\n\n                  else cdmin \r\n\n\r\n\neuclid a b = if (a<b) then xyfinder a b (mod b a) (- (div b a)) 1 else xyfinder a b (mod a b) 1 (-(div a b))\r\n\n\r\n\nxyfinder a b 1 xnow ynow = (xnow, ynow)\r\n\nxyfinder a b (-1) xnow ynow = ((-xnow),(-ynow))\r\n\n\r\n\nxyfinder a b nowp xnow ynow = let  a1 = mod a nowp \r\n\n                                   a2 = nowp-a1\r\n\n                                   b1 = mod b nowp \r\n\n                                   b2 = nowp-b1 \r\n\n                                   minel = min4 a1 a2 b1 b2\r\n\n                               in if ( a1 == minel ) then xyfinder a b a1 (-xnow * (div a nowp) + 1) (-ynow * (div a nowp)) \r\n\nelse if ( minel == a2) then xyfinder a b a2 (xnow * ((div a nowp) + 1) - 1) ( ynow *((div a nowp) + 1)) \r\n\nelse if ( minel == b1) then xyfinder a b b1 (-xnow * (div b nowp)) (-ynow * (div b nowp) + 1) \r\n\nelse xyfinder a b b2 ((xnow * ((div b nowp) + 1))) ( ynow * ((div b nowp) + 1) - 1)\r\n\n\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5879,129,'1526701','2013-10-02 01:57:37',1,'mymap f [] = [];	\r\nmymap f l = foldr (x xs -> (f x):xs) [] l;','<br/>Тесты успешно пройдены!'),(5880,130,'1526701','2013-10-02 02:02:45',1,'mtrace [] i = 0;\r\nmtrace (x:xs) i = x !! i + mtrace xs (i+1);\r\n\r\ntrace l = mtrace l 0;','<br/>Тесты успешно пройдены!'),(5877,53,'1526701','2013-10-02 01:17:21',1,'coins n = [ [x1,x2,x3] | x1 <- [0..n], x2 <- [0..n], x3 <- [0..n], x1*2+x2*3+x3*5 == n ]','<br/>Тесты успешно пройдены!'),(5878,54,'1526701','2013-10-02 01:47:39',1,'-- паралельно : Pr, последовательно : Sq\r\n-- пример вызова\r\n-- totalResistance (Con (Ohm 4) (Ohm 4) Pr)\r\n\r\ndata Type = Pr | Sq;\r\ndata Scheme a = Ohm a | Con (Scheme a) (Scheme a) (Type)\r\n\r\ntotalResistance (Ohm a) = a;\r\ntotalResistance (Con x1 x2 Sq) = totalResistance x1 + totalResistance x2;\r\ntotalResistance (Con x1 x2 Pr) = 1 / ( (1 / totalResistance x1) + (1 / totalResistance x2) );','<br/>Тесты успешно пройдены!'),(5875,54,'5543298','2013-10-02 00:11:33',1,'data Type = Par | Seq\r\n\r\ndata Scheme = Resistance Double | Node Type Scheme Scheme \r\n\r\n\r\n\r\ntotalResistance (Resistance x) = x\r\n\r\ntotalResistance (Node Seq s1 s2) = totalResistance s1 + totalResistance s2\r\n\r\ntotalResistance (Node Par s1 s2) = let \r\n\r\n									r1 = totalResistance s1\r\n\r\n									r2 = totalResistance s2\r\n\r\n								in r1 * r2 / (r1 + r2)\r\n\r\n\r\n\r\nf1 = totalResistance (Resistance 1)\r\n\r\nf2 = totalResistance (Node Par (Resistance 4) (Resistance 4))\r\n\r\nf3 = totalResistance (Node Seq (Resistance 4) (Resistance 4))\r\n\r\nf4 = totalResistance (Node Par (Node Seq (Resistance 2) (Resistance 2)) (Node Seq (Resistance 2) (Resistance 2)))\r\n\r\nf5 = totalResistance (Node Seq (Node Par (Resistance 2) (Resistance 2)) (Node Par (Resistance 2) (Resistance 2)))\r\n','<br/>Тесты успешно пройдены!'),(5876,48,'12828920','2013-10-02 01:07:03',0,'myreverse xs = foldr (i k->foldr (l m->l:m) [i] k) [] xs\r\n\n\r\n\n{-2.1 Fast operations\r\n\nThe following operations are always \'fast\':\r\n\n\r\n\nPrepend 1 element (the : operator) это ведь в начало приписывание....\r\n\nhead (get first element)\r\n\ntail (remove first element) \r\n\n\r\n\nя же тут как раз приписываю в начало, разве нет ?\r\n\nкак я понимаю работу:\r\n\nпусть [1,2,3] - xs\r\n\n1 итерация внешнего фолдера) i - 3, k - [] вложенный фолдер: l - _, m - [3], возвращяет [3]\r\n\n2 итерация внешнего фолдера) i - 2, k - [3], вложенный фолдер: l - 3, m -[2], приписываю 3:[2], возвращает [3,2]\r\n\n3 итерация внешнего фолдера) i - 1, k - [3,2], вложенный фолдер: a) l - 2, m - [1], приписываю 2:[1], возвращаю [2,1]\r\n\n												b) l - 3, m - [2,1], приписываю 3:[2,1], возвращаю [3,2,1]\r\n\n												\r\n\nв конец списка я ведь элементы не добавляю...\r\n\n\r\n\np.s. по-другому можно как то комментарии писать ?\r\n\n-}\n','<br/>Тесты успешно пройдены!'),(5874,130,'deripaska','2013-10-01 23:56:25',1,'{--\r\n\r\n	task 12-04\r\n\r\n\"След матрицы\"\r\n\r\n\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию trace n, которая для данной квадратной матрицы возвращает сумму ее диагональных элементов.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ntrace [[1,2,3],[4,5,6],[7,8,9]]\r\n\r\nДолжно получиться 15 (сумма 1+5+9).\r\n\r\n--}\r\n\r\n\r\n\r\ntrace xs = foldr (k res -> res + xs !! k !! k) 0 [0..(length xs - 1)]\r\n','<br/>Тесты успешно пройдены!'),(5873,54,'deripaska','2013-10-01 23:41:32',1,'{--\r\n\r\n	task 12-02\r\n\r\nПусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:\r\n\r\n- или сопротивление, тогда известно его величина в омах\r\n\r\n- или две схемы, соединенных параллельно\r\n\r\n- или две схемы, соединенных последовательно\r\n\r\n(На самом деле есть схемы, которые таким способом не описать, ну и ладно..)\r\n\r\n\r\n\r\n1. Опишите тип (data) Scheme, который позволяет описывать такие схемы.\r\n\r\n2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы.\r\n\r\n\r\n\r\nНапример, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Scheme r = Resistance r\r\n\r\n				| ParallelConnection (Scheme r) (Scheme r)\r\n\r\n				| SerialConnection (Scheme r) (Scheme r)\r\n\r\n\r\n\r\ntotalResistance (Resistance r) = r\r\n\r\ntotalResistance (ParallelConnection s1 s2) = r1 * r2 / (r1 + r2)\r\n\r\n		where \r\n\r\n			r1 = totalResistance s1\r\n\r\n			r2 = totalResistance s2\r\n\r\ntotalResistance (SerialConnection s1 s2) = totalResistance s1 + totalResistance s2\r\n\r\n\r\n\r\n-- totalResistance (ParallelConnection (SerialConnection (Resistance 2) (Resistance 4)) (SerialConnection (Resistance 3) (Resistance 3))) 	-- R = 3 \r\n\r\n-- totalResistance (SerialConnection (ParallelConnection (Resistance 2) (Resistance 4)) (ParallelConnection (Resistance 3) (Resistance 3))) -- R = 17 / 6 = 2.8(3)\r\n\r\n-- totalResistance (SerialConnection (Resistance 4) (Resistance 4))   -- R = 8\r\n\r\n-- totalResistance (ParallelConnection (Resistance 4) (Resistance 4)) -- R = 2\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5871,53,'SNNatalieS','2013-10-01 23:40:48',2,'--- вы не вставили текст?','Не удалось вычислить выражение \"coins 2\", проверьте правильность синтаксиса'),(5872,53,'SNNatalieS','2013-10-01 23:41:11',1,'coins n = [[x, y, z]| x <- [0 .. n], y <- [0 .. n], z <- [0 .. n], x * 2 + y * 3 + z * 5 == n]','<br/>Тесты успешно пройдены!'),(5870,129,'deripaska','2013-10-01 23:20:58',1,'{--\r\n\r\n	task 12-03\r\n\r\nИспользуя _только_ функцию foldr и лямбда выражения опишите функцию mymap, которая делает точно то же, что и стандартная функция map.\r\n\r\nПример вызова:\r\n\r\nmymap (*3) [1, 2, 3]\r\n\r\nРезультат д.б. равен [3, 6, 9].\r\n\r\n--}\r\n\r\n\r\n\r\nmymap f xs = foldr (x res -> (f x) : res) [] xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5869,53,'deripaska','2013-10-01 23:20:15',1,'{--\r\n\r\n	task 12-01\r\n\r\nПеречислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. Результат должен быть списком списков целых чисел, каждый внутренний список - это список из трех элементов [k,l,m], где k - двухкопеечных монет, l - количество трехкопеечных, m - количество пятикопеечных монет.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ncoins 10\r\n\r\n\r\n\r\nДолжно получиться:\r\n\r\n[[5,0,0],[2,2,0],[0,0,2],[1,1,1]]\r\n\r\n(порядок троек в ответе может быть и другим).\r\n\r\n--}\r\n\r\n\r\n\r\ncoins n = [ [a, b, c] | a <- [0..(div n 2)], b <- [0..(div n 3)], c <- [0..(div n 5)], 2 * a + 3 * b + 5 * c == n]\r\n','<br/>Тесты успешно пройдены!'),(5862,53,'2156724','2013-10-01 21:53:17',1,'coins n = [ [x,y,z] | x<-[0..n], y<-[0..n], z<-[0..n], 2*x + 3 * y + 5*z == n]\r\n','<br/>Тесты успешно пройдены!'),(5863,54,'115753099','2013-10-01 21:58:56',1,'data Scheme = Resistance Float\r\n			| ConsistentResistance Float Float\r\n			| ParallelResistance Float Float\r\n\r\ntotalResistance (Resistance r) = r\r\ntotalResistance (ConsistentResistance r1 r2) =\r\n	r1 + r2\r\ntotalResistance (ParallelResistance r1 r2) =\r\n	1 / (1 / r1 + 1 / r2)','<br/>Тесты успешно пройдены!'),(5864,129,'115753099','2013-10-01 22:07:45',1,'mymap f [] = []\r\nmymap f xs =\r\n	foldr (x xs -> f x : xs) [] xs','<br/>Тесты успешно пройдены!'),(5865,130,'115753099','2013-10-01 22:23:39',1,'trace matrix = s\r\n	where (s,_) = foldr ( xs (a, i) -> (a + (xs !! i), i + 1)) (0, 0) matrix','<br/>Тесты успешно пройдены!'),(5866,129,'5543298','2013-10-01 22:32:37',1,'mymap f xs = foldr (x res -> ((f x):res)) [] xs\r\n','<br/>Тесты успешно пройдены!'),(5867,130,'5543298','2013-10-01 22:39:17',1,'trace xs = foldr ((x, y) res -> res + (x !! y)) 0 (zip xs [0..(length xs) - 1])\r\n','<br/>Тесты успешно пройдены!'),(5868,53,'5543298','2013-10-01 23:04:08',1,'getList n m = [x | x <- [0..n], x * m <= n]\r\n  --- или проще x <- [0..div n m] \r\ncoins n = [[x,y,z] | x <- getList n 2, y <- getList n 3, z <- getList n 5, x * 2 + y * 3 + z * 5 == n]','<br/>Тесты успешно пройдены!'),(5861,53,'115753099','2013-10-01 21:41:00',1,'coins n =\r\n	[ [x, y, z] | x <- [0..(n `div` 2)], y <- [0..(n `div` 3)], z <- [0..(n `div` 5)], x*2 + y*3 + z*5 == n]','<br/>Тесты успешно пройдены!'),(5860,53,'115753099','2013-10-01 21:39:54',0,'coins n =\r\n	[ (x, y, z) | x <- [0..(n `div` 2)], y <- [0..(n `div` 3)], z <- [0..(n `div` 5)], x*2 + y*3 + z*5 == n]','Выражение имеет неправильное значение: coins 2'),(5857,130,'517309','2013-10-01 20:48:00',3,'trace xss = sum $ zipWith (!!) xss [0..]','<br/>Тесты успешно пройдены!'),(5858,129,'anlun','2013-10-01 21:35:29',1,'mymap :: (a -> b) -> [a] -> [b]\r\nmymap f = foldr (x l -> (f x):l) []','<br/>Тесты успешно пройдены!'),(5859,130,'anlun','2013-10-01 21:35:45',1,'trace :: Num a => [[a]] -> a\r\ntrace matrix = sum [matrix !! i !! i | i <- [0..(length matrix) - 1]]\r\n','<br/>Тесты успешно пройдены!'),(5856,130,'517309','2013-10-01 20:43:44',0,'trace xss = sum $ zipWith (!!) xss [1..]','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(5854,129,'517309','2013-10-01 20:42:20',3,'mymap = map','<br/>Тесты успешно пройдены!'),(5855,130,'517309','2013-10-01 20:43:12',0,'trace xss = sum $ zipWith xss [1..]','Не удалось вычислить выражение \"trace [[1,2,3],[4,5,6],[7,8,9]]\", проверьте правильность синтаксиса'),(5852,129,'517309','2013-10-01 20:40:04',0,'maymap = map','Не удалось вычислить выражение \"mymap (*3) [1,2,3]\", проверьте правильность синтаксиса'),(5853,129,'517309','2013-10-01 20:40:46',0,'mymap = map','Выражение имеет неправильное значение: mymap (*3) [1,2,3]'),(5851,43,'6053606','2013-10-01 18:10:24',1,'euclid a b = case b of\r\n           0 -> (1, 0)\r\n           _ -> let q = a `div` b\r\n                    r = a `mod` b\r\n                    (s, t) = euclid b r\r\n                in (t, s - q * t)\r\n','<br/>Тесты успешно пройдены!'),(5849,48,'12828920','2013-10-01 13:06:47',2,'   --- нет, это не совсе по условию. Там написано\r\n   --- \"Функция должна работать за линейное время. Технически это означает, что нельзя использовать \r\n   --- операцию ++[x] или каким-то другим способом приписывать очередной элемент к концу списка \r\n   --- на каждом шаге работы foldr.\"\r\n   --- А вы как раз приписываете на каждом шагу.  \r\nmyreverse xs = foldr (i k->foldr (l m->l:m) [i] k) [] xs','<br/>Тесты успешно пройдены!'),(5850,43,'6053606','2013-10-01 18:03:53',0,'euclid a b = case b of\r\n           1 -> (0, 1)\r\n           _ -> let q = a `div` b\r\n                    r = a `mod` b\r\n                    (s, t) = euclid b r\r\n                in (t, s - q * t)\r\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5848,43,'ArtemK','2013-10-01 11:47:26',1,'euclid a b = euclid\' 1 0 0 1 a b\r\neuclid\' _ _ _ _ 1 0 = (1, 0) \r\neuclid\' x1 x2 y1 y2 a b = let { r = mod a b; q = div a b } in\r\n                                if r == 0 then (x2, y2)\r\n                                else euclid\' x2 (x1-q*x2) y2 (y1-q*y2) b r ','<br/>Тесты успешно пройдены!'),(5847,43,'ArtemK','2013-10-01 11:42:53',0,'euclid a b = euclid\' 1 0 0 1 a b\r\neuclid\' x1 x2 y1 y2 a b = let { r = mod a b; q = div a b } in\r\n                                if r == 0 then (x2, y2)\r\n                                else euclid\' x2 (x1-q*x2) y2 (y1-q*y2) b r ','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5846,43,'ArtemK','2013-10-01 11:41:52',0,'euclid a b = euclid\' 1 0 0 1 a b\r\neuclid\' x1 x2 y1 y2 a b = let r = mod a b\r\n                                            q = div a b in\r\n                                if r == 0 then (x2, y2)\r\n                                else euclid\' x2 (x1-q*x2) y2 (y1-q*y2) b r ','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5845,43,'ArtemK','2013-10-01 11:39:48',0,'euclid a b = euclid\' 1 0 0 1 a b\r\neuclid\' x1 x2 y1 y2 a b = let r = mod a b in\r\n                               let q = div a b in\r\n                                if r == 0 then (x2, y2)\r\n                                else euclid\' x2 (x1-q*x2) y2 (y1-q*y2) b r','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5844,48,'egeorge','2013-10-01 03:43:56',1,'mymap f xs = foldr (y ys -> (f y):ys) [] xs\r\n\r\nmyreverse xs = mymap ([x] -> x) (myreverse\' xs)\r\n\r\nmyreverse\' xs = foldr (\\_ ((resFirst:res):resTail) -> (res:[resFirst]:resTail))\r\n                     [xs]\r\n                     [1..(length xs - 1)]','<br/>Тесты успешно пройдены!'),(5843,47,'1526701','2013-10-01 03:04:09',1,'inst t [] = [];\r\ninst t (x:xs) = (t:x) : inst t xs;\r\n\r\nrun [x] = [[x]];\r\nrun (x:xs) = inst x (run xs) ++ run xs ++ [[x]];\r\n\r\npowerset [] = [[]];\r\npowerset (x:xs) = [[]] ++ run (x:xs);','<br/>Тесты успешно пройдены!'),(5842,47,'1526701','2013-10-01 03:02:36',0,'inst t [] = [];\r\ninst t (x:xs) = (t:x) : inst t xs;\r\n\r\nrun [x] = [[x]];\r\nrun (x:xs) = inst x (run xs) ++ run xs ++ [[x]];\r\n\r\npowerset (x:xs) = [[]] ++ run (x:xs);','Не удалось вычислить выражение \"powerset []\", проверьте правильность синтаксиса'),(5841,44,'deripaska','2013-10-01 02:36:47',1,'{--\r\n\r\n	task 07-02\r\n\r\n*Доп задача*\r\n\r\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\r\n\r\n\r\n\r\na*x+b*y+c*z=d\r\n\r\nk*x+l*y+m*z=n\r\n\r\n--}\r\n\r\n\r\n\r\neuclid 0 b = (0, 1)\r\n\r\neuclid a b = (y - (div b a) * x, x)\r\n\r\n		where (x, y) = euclid (mod b a) a\r\n\r\n\r\n\r\neuclidCommon a b nod\r\n\r\n	| nod /= gcd a b = error(\"no solution\")\r\n\r\n	| otherwise = euclid a b\r\n\r\n	\r\n\r\n{-- Если \r\n\r\n		у одного из уравнений все коэффициенты равны 0 \r\n\r\n		или же коэффициенты одного уравнения является произведением некоторого числа на соответствующие коэффициенты второго уравнения,\r\n\r\n	то \r\n\r\n		из двух уравнений значимое уравнение только одно.\r\n\r\n	Тогда это частный случай (diophSpecial): решение только одного уравнения с x, y, z\r\n\r\n--}\r\n\r\n\r\n\r\ndiophSpecial [a, b, c, d]\r\n\r\n	| mod d nodNC /= 0 = error(\"no 1 solution\")\r\n\r\n	| otherwise = [uv * x, uv * y, u * z]\r\n\r\n	where\r\n\r\n		nodAB = gcd a b\r\n\r\n		nodNC = gcd nodAB c\r\n\r\n		u = div d nodNC\r\n\r\n		(x, y) = euclid a b\r\n\r\n		(v, z) = euclid nodAB c\r\n\r\n		uv = u * v\r\n\r\n{--\r\n\r\n	Общий случай, когда оба уравнения значимы\r\n\r\n--}\r\n\r\ndiophGeneral [a, b, c, d] [k, l, m, n]\r\n\r\n	| g == 0 = [x0, y0, 0]\r\n\r\n	| mod d2 g /= 0 = [0, 0, 0] \r\n\r\n	| otherwise = [x, y3 + u * y2, z3 + u * z2]\r\n\r\n	where\r\n\r\n		b2 = (a * l - k * b)\r\n\r\n		c2 = (a * m - k * c)\r\n\r\n		d2 = (a * n - k * d)\r\n\r\n		(y, z) = euclid b2 c2\r\n\r\n		g = b2 * y + c2 * z\r\n\r\n		fraction = div d2 g\r\n\r\n		t = div (b2 * c2)  g\r\n\r\n		y2 = if b2 == 0 then 1 else div (-t) b2\r\n\r\n		z2 = if c2 == 0 then 1 else div t c2\r\n\r\n		y3 = fraction * y\r\n\r\n		z3 = fraction * z\r\n\r\n		b3 = b * y2 + c * z2\r\n\r\n		d3 = d - b * y3 - c * z3\r\n\r\n		l3 = l * y2 + m * z2\r\n\r\n		n3 = n - l * y3 - m * z3\r\n\r\n		(x0, y0) = diophForTwoVariables [a, b, d] [k, l, n]\r\n\r\n		(x, u) = diophForTwoVariables [a, b3, d3] [k, l3, n3]\r\n\r\n		\r\n\r\n{--\r\n\r\n	Решение системы уравнений с 3 переменными сводится к решению системы уравнений с 2 переменными.\r\n\r\n	Для решения аналогичной системы уравнений, но с двумя параметрами (и тут тоже есть аналогичный вырожденный случай)\r\n\r\n--}\r\n\r\ndiophForTwoVariablesSpecial [a, b, d]\r\n\r\n	| nod == 0 || mod d nod /= 0 = error(\"no solution\")\r\n\r\n	| otherwise = (koef * u, koef * v)\r\n\r\n	where\r\n\r\n		(u, v) = euclid a b\r\n\r\n		nod = gcd u v\r\n\r\n		koef = div d nod \r\n\r\n\r\n\r\ndiophForTwoVariables [a, b, d] [k, l, n]\r\n\r\n	| secondIsKoefFirst || (k == 0 && l == 0 && n == 0) = diophForTwoVariablesSpecial [a, b, d]\r\n\r\n	| firstIsKoefSecond || (a == 0 && b == 0 && d == 0) = diophForTwoVariablesSpecial [k, l, n]\r\n\r\n	| u == 0 && v == 0 = diophForTwoVariablesSpecial [a, b, d]\r\n\r\n	| otherwise = (y, div (d - y * a) a)\r\n\r\n	where \r\n\r\n		u = -a * l + k * b\r\n\r\n		v = -d * l + n * b\r\n\r\n		y  = div v u\r\n\r\n		secondIsKoefFirst\r\n\r\n				| a /= 0 = (a * koef == k && b * koef == l && d * koef == n)\r\n\r\n				| otherwise = False\r\n\r\n				where koef = div k a\r\n\r\n		firstIsKoefSecond\r\n\r\n				| k /= 0 = (k * koef == a && l * koef == b && n * koef == d)\r\n\r\n				| otherwise = False\r\n\r\n				where koef = div a k\r\n\r\n				\r\n\r\n{--\r\n\r\n	Собственно,саморешение, собираем результаты\r\n\r\n--}\r\n\r\ndioph [a, b, c, d] [k, l, m, n]\r\n\r\n	| secondIsKoefFirst || (k == 0 && l == 0 && m == 0 && n == 0) = diophSpecial [a, b, c, d]\r\n\r\n	| firstIsKoefSecond || (a == 0 && b == 0 && c == 0 && d == 0) = diophSpecial [k, l, m, n]\r\n\r\n	| otherwise = diophGeneral [a, b, c, d] [k, l, m, n]\r\n\r\n	where \r\n\r\n		secondIsKoefFirst\r\n\r\n				| a /= 0 = (a * koef == k && b * koef == l && c * koef == m && d * koef == n)\r\n\r\n				| otherwise = False\r\n\r\n				where koef = div k a\r\n\r\n		firstIsKoefSecond\r\n\r\n				| k /= 0 = (k * koef == a && l * koef == b && m * koef == c && n * koef == d)\r\n\r\n				| otherwise = False\r\n\r\n				where koef = div a k\r\n','<br/>Тесты успешно пройдены!'),(5840,44,'deripaska','2013-10-01 01:35:38',0,'{--\r\n\n	task 07-02\r\n\n*Доп задача*\r\n\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\r\n\n\r\n\na*x+b*y+c*z=d\r\n\nk*x+l*y+m*z=n\r\n\n--}\r\n\n\r\n\neuclid 0 b = (0, 1)\r\n\neuclid a b = (y - (div b a) * x, x)\r\n\n		where (x, y) = euclid (mod b a) a\r\n\n\r\n\neuclidCommon a b nod\r\n\n	| nod /= gcd a b = error(\"no solution\")\r\n\n	| otherwise = euclid a b\r\n\n	\r\n\n{-- Если \r\n\n		у одного из уравнений все коэффициенты равны 0 \r\n\n		или же коэффициенты одного уравнения является произведением некоторого числа на соответствующие коэффициенты второго уравнения,\r\n\n	то \r\n\n		из двух уравнений значимое уравнение только одно.\r\n\n	Тогда это частный случай (diophSpecial): решение только одного уравнения с x, y, z\r\n\n--}\r\n\n\r\n\ndiophSpecial [a, b, c, d]\r\n\n	| mod d nodNC /= 0 = error(\"no 1 solution\")\r\n\n	| otherwise = [uv * x, uv * y, u * z]\r\n\n	where\r\n\n		nodAB = gcd a b\r\n\n		nodNC = gcd nodAB c\r\n\n		u = div d nodNC\r\n\n		(x, y) = euclid a b\r\n\n		(v, z) = euclid nodAB c\r\n\n		uv = u * v\r\n\n{--\r\n\n	Общий случай, когда оба уравнения значимы\r\n\n--}\r\n\ndiophGeneral [a, b, c, d] [k, l, m, n] = [x, y - product, z + product]\r\n\n	where\r\n\n		b2 = (a * l - k * b)\r\n\n		c2 = (a * m - k * c)\r\n\n		d2 = (a * n - k * d)\r\n\n		nok = lcm b2 c2\r\n\n		fraction = div nok b2\r\n\n		(y, z) = euclid b2 c2\r\n\n		b3 = (c - b) * fraction\r\n\n		d3 = d - b * y - c * z\r\n\n		l3 = (m - l) * fraction\r\n\n		n3 = n - l * y - m * z\r\n\n		(x, u) = diophForTwoVariables [a, b3, d3] [k, l3, n3]\r\n\n		product = u * fraction\r\n\n		\r\n\n{--\r\n\n	Решение системы уравнений с 3 переменными сводится к решению системы уравнений с 2 переменными.\r\n\n	Для решения аналогичной системы уравнений, но с двумя параметрами (и тут тоже есть аналогичный вырожденный случай)\r\n\n--}\r\n\ndiophForTwoVariables [a, b, d] [k, l, n]\r\n\n	| (a == 0 && b == 0 && d == 0) || (k == 0 && l == 0 && n == 0) = error(\"no 2 solution\")\r\n\n	| secondIsKoefFirst = euclidCommon a b d\r\n\n	| firstIsKoefSecond = euclidCommon k l n\r\n\n	| otherwise = (y, div (d - b * y) a)\r\n\n	where \r\n\n		y = div (a * n - k * d) (a * l - k * b)\r\n\n		secondIsKoefFirst\r\n\n				| a /= 0 = (a * koef == k && b * koef == l && d * koef == n)\r\n\n				| otherwise = False\r\n\n				where koef = div k a\r\n\n		firstIsKoefSecond\r\n\n				| k /= 0 = (k * koef == a && l * koef == b && n * koef == d)\r\n\n				| otherwise = False\r\n\n				where koef = div a k\r\n\n				\r\n\n{--\r\n\n	Собственно,саморешение, собираем результаты\r\n\n--}\r\n\ndioph [a, b, c, d] [k, l, m, n]\r\n\n	| (a == 0 && b == 0 && c == 0 && d == 0) || (k == 0 && l == 0 && m == 0 && n == 0) = error(\"no 3 solution\")\r\n\n	| secondIsKoefFirst = diophSpecial [a, b, c, d]\r\n\n	| firstIsKoefSecond = diophSpecial [k, l, m, n]\r\n\n	| otherwise = diophGeneral [a, b, c, d] [k, l, m, n]\r\n\n	where \r\n\n		secondIsKoefFirst\r\n\n				| a /= 0 = (a * koef == k && b * koef == l && c * koef == m && d * koef == n)\r\n\n				| otherwise = False\r\n\n				where koef = div k a\r\n\n		firstIsKoefSecond\r\n\n				| k /= 0 = (k * koef == a && l * koef == b && m * koef == c && n * koef == d)\r\n\n				| otherwise = False\r\n\n				where koef = div a k\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),(5839,44,'deripaska','2013-10-01 01:32:29',0,'{--\r\n\n	task 07-02\r\n\n*Доп задача*\r\n\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\r\n\n\r\n\na*x+b*y+c*z=d\r\n\nk*x+l*y+m*z=n\r\n\n--}\r\n\n\r\n\neuclid 0 b = (0, 1)\r\n\neuclid a b = (y - (div b a) * x, x)\r\n\n		where (x, y) = euclid (mod b a) a\r\n\n\r\n\neuclidCommon a b nod\r\n\n	| nod /= gcd a b = error(\"no solution\")\r\n\n	| otherwise = euclid a b\r\n\n	\r\n\n{-- Если \r\n\n		у одного из уравнений все коэффициенты равны 0 \r\n\n		или же коэффициенты одного уравнения является произведением некоторого числа на соответствующие коэффициенты второго уравнения,\r\n\n	то \r\n\n		из двух уравнений значимое уравнение только одно.\r\n\n	Тогда это частный случай (diophSpecial): решение только одного уравнения с x, y, z\r\n\n--}\r\n\n\r\n\ndiophSpecial [a, b, c, d]\r\n\n	| mod d nodNC /= 0 = error(\"no 1 solution\")\r\n\n	| otherwise = [uv * x, uv * y, u * z]\r\n\n	where\r\n\n		nodAB = gcd a b\r\n\n		nodNC = gcd nodAB c\r\n\n		u = div d nodNC\r\n\n		(x, y) = euclid a b\r\n\n		(v, z) = euclid nodAB c\r\n\n		uv = u * v\r\n\n{--\r\n\n	Общий случай, когда оба уравнения значимы\r\n\n--}\r\n\ndiophGeneral [a, b, c, d] [k, l, m, n] = [x, y - product, z + product]\r\n\n	where\r\n\n		b2 = (a * l - k * b)\r\n\n		c2 = (a * m - k * c)\r\n\n		d2 = (a * n - k * d)\r\n\n		nok = lcm b2 c2\r\n\n		fraction = div nok b2\r\n\n		(y, z) = euclidCommon b2 c2 d2\r\n\n		b3 = (c - b) * fraction\r\n\n		d3 = d - b * y - c * z\r\n\n		l3 = (m - l) * fraction\r\n\n		n3 = n - l * y - m * z\r\n\n		(x, u) = diophForTwoVariables [a, b3, d3] [k, l3, n3]\r\n\n		product = u * fraction\r\n\n		\r\n\n{--\r\n\n	Решение системы уравнений с 3 переменными сводится к решению системы уравнений с 2 переменными.\r\n\n	Для решения аналогичной системы уравнений, но с двумя параметрами (и тут тоже есть аналогичный вырожденный случай)\r\n\n--}\r\n\ndiophForTwoVariables [a, b, d] [k, l, n]\r\n\n	| (a == 0 && b == 0 && d == 0) || (k == 0 && l == 0 && n == 0) = error(\"no 2 solution\")\r\n\n	| secondIsKoefFirst = euclidCommon a b d\r\n\n	| firstIsKoefSecond = euclidCommon k l n\r\n\n	| otherwise = (y, div (d - b * y) a)\r\n\n	where \r\n\n		y = div (a * n - k * d) (a * l - k * b)\r\n\n		secondIsKoefFirst\r\n\n				| a /= 0 = (a * koef == k && b * koef == l && d * koef == n)\r\n\n				| otherwise = False\r\n\n				where koef = div k a\r\n\n		firstIsKoefSecond\r\n\n				| k /= 0 = (k * koef == a && l * koef == b && n * koef == d)\r\n\n				| otherwise = False\r\n\n				where koef = div a k\r\n\n				\r\n\n{--\r\n\n	Собственно,саморешение, собираем результаты\r\n\n--}\r\n\ndioph [a, b, c, d] [k, l, m, n]\r\n\n	| (a == 0 && b == 0 && c == 0 && d == 0) || (k == 0 && l == 0 && m == 0 && n == 0) = error(\"no 3 solution\")\r\n\n	| secondIsKoefFirst = diophSpecial [a, b, c, d]\r\n\n	| firstIsKoefSecond = diophSpecial [k, l, m, n]\r\n\n	| otherwise = diophGeneral [a, b, c, d] [k, l, m, n]\r\n\n	where \r\n\n		secondIsKoefFirst\r\n\n				| a /= 0 = (a * koef == k && b * koef == l && c * koef == m && d * koef == n)\r\n\n				| otherwise = False\r\n\n				where koef = div k a\r\n\n		firstIsKoefSecond\r\n\n				| k /= 0 = (k * koef == a && l * koef == b && m * koef == c && n * koef == d)\r\n\n				| otherwise = False\r\n\n				where koef = div a k\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5835,52,'ip','2013-10-01 00:04:31',1,'repeatFunc f 1 = f\r\nrepeatFunc f n = foldr (x a -> a.x) f \r\n           (map (x -> f) [1..(n-1)])','<br/>Тесты успешно пройдены!'),(5836,43,'nomeansno','2013-10-01 00:22:43',0,'euclid 1 b = if b == 0 then (1,0)\n\nelse (1-b, 1)\n\neuclid a 1 = if a == 0 then (0,1)\n\nelse (1, 1-a)\n\neuclid a b = f a b r (0,1) (1,-q)\n\n where q = a `div` b; r = a `mod` b\n\n\n\nf _ _ 1 _ (x,y) = (x,y)\n\nf a b rn (xb,yb) (xrn,yrn) = f b rn rn\' (xrn,yrn) (xrn\',yrn\') \n\n where qn\' = b `div` rn; rn\' = b `mod` rn; xrn\'=xb-xrn*qn\'; yrn\'=yb-yrn*qn\'       \n\n\n','<br/>Тесты успешно пройдены!'),(5837,43,'nomeansno','2013-10-01 00:28:48',1,'euclid 1 b = if b == 0 then (1,0)\r\n\r\nelse (1-b, 1)\r\n\r\neuclid a 1 = if a == 0 then (0,1)\r\n\r\nelse (1, 1-a)\r\n\r\neuclid a b = f b r (0,1) (1,-q)\r\n\r\n where q = a `div` b; r = a `mod` b\r\n\r\n\r\n\r\nf _ 1 _ (x,y) = (x,y)\r\n\r\nf b rn (xb,yb) (xrn,yrn) = f rn rn\' (xrn,yrn) (xrn\',yrn\') \r\n\r\n where qn\' = b `div` rn; rn\' = b `mod` rn; xrn\'=xb-xrn*qn\'; yrn\'=yb-yrn*qn\'       \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5838,44,'deripaska','2013-10-01 01:29:47',0,'{--\r\n\n	task 07-02\r\n\n*Доп задача*\r\n\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\r\n\n\r\n\na*x+b*y+c*z=d\r\n\nk*x+l*y+m*z=n\r\n\n--}\r\n\n\r\n\neuclid 0 b = (0, 1)\r\n\neuclid a b = (y - (div b a) * x, x)\r\n\n		where (x, y) = euclid (mod b a) a\r\n\n\r\n\neuclidCommon a b nod\r\n\n	| nod /= gcd a b = error(\"no solution\")\r\n\n	| otherwise = euclid a b\r\n\n	\r\n\n{-- Если \r\n\n		у одного из уравнений все коэффициенты равны 0 \r\n\n		или же коэффициенты одного уравнения является произведением некоторого числа на соответствующие коэффициенты второго уравнения,\r\n\n	то \r\n\n		из двух уравнений значимое уравнение только одно.\r\n\n	Тогда это частный случай (diophSpecial): решение только одного уравнения с x, y, z\r\n\n--}\r\n\n\r\n\ndiophSpecial [a, b, c, d]\r\n\n	| mod d nodNC /= 0 = error(\"no solution\")\r\n\n	| otherwise = (uv * x, uv * y, u * z)\r\n\n	where\r\n\n		nodAB = gcd a b\r\n\n		nodNC = gcd nodAB c\r\n\n		u = div d nodNC\r\n\n		(x, y) = euclid a b\r\n\n		(v, z) = euclid nodAB c\r\n\n		uv = u * v\r\n\n{--\r\n\n	Общий случай, когда оба уравнения значимы\r\n\n--}\r\n\ndiophGeneral [a, b, c, d] [k, l, m, n] = (x, y - product, z + product)\r\n\n	where\r\n\n		b2 = (a * l - k * b)\r\n\n		c2 = (a * m - k * c)\r\n\n		d2 = (a * n - k * d)\r\n\n		nok = lcm b2 c2\r\n\n		fraction = div nok b2\r\n\n		(y, z) = euclidCommon b2 c2 d2\r\n\n		b3 = (c - b) * fraction\r\n\n		d3 = d - b * y - c * z\r\n\n		l3 = (m - l) * fraction\r\n\n		n3 = n - l * y - m * z\r\n\n		(x, u) = diophForTwoVariables [a, b3, d3] [k, l3, n3]\r\n\n		product = u * fraction\r\n\n		\r\n\n{--\r\n\n	Решение системы уравнений с 3 переменными сводится к решению системы уравнений с 2 переменными.\r\n\n	Для решения аналогичной системы уравнений, но с двумя параметрами (и тут тоже есть аналогичный вырожденный случай)\r\n\n--}\r\n\ndiophForTwoVariables [a, b, d] [k, l, n]\r\n\n	| (a == 0 && b == 0 && d == 0) || (k == 0 && l == 0 && n == 0) = error(\"no solution\")\r\n\n	| secondIsKoefFirst = euclidCommon a b d\r\n\n	| firstIsKoefSecond = euclidCommon k l n\r\n\n	| otherwise = (y, div (d - b * y) a)\r\n\n	where \r\n\n		y = div (a * n - k * d) (a * l - k * b)\r\n\n		secondIsKoefFirst\r\n\n				| a /= 0 = (a * koef == k && b * koef == l && d * koef == n)\r\n\n				| otherwise = False\r\n\n				where koef = div k a\r\n\n		firstIsKoefSecond\r\n\n				| k /= 0 = (k * koef == a && l * koef == b && n * koef == d)\r\n\n				| otherwise = False\r\n\n				where koef = div a k\r\n\n				\r\n\n{--\r\n\n	Собственно,саморешение, собираем результаты\r\n\n--}\r\n\ndioph [a, b, c, d] [k, l, m, n]\r\n\n	| (a == 0 && b == 0 && c == 0 && d == 0) || (k == 0 && l == 0 && m == 0 && n == 0) = error(\"no solution\")\r\n\n	| secondIsKoefFirst = diophSpecial [a, b, c, d]\r\n\n	| firstIsKoefSecond = diophSpecial [k, l, m, n]\r\n\n	| otherwise = diophGeneral [a, b, c, d] [k, l, m, n]\r\n\n	where \r\n\n		secondIsKoefFirst\r\n\n				| a /= 0 = (a * koef == k && b * koef == l && c * koef == m && d * koef == n)\r\n\n				| otherwise = False\r\n\n				where koef = div k a\r\n\n		firstIsKoefSecond\r\n\n				| k /= 0 = (k * koef == a && l * koef == b && m * koef == c && n * koef == d)\r\n\n				| otherwise = False\r\n\n				where koef = div a k\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5833,43,'nomeansno','2013-10-01 00:00:50',0,'euclid a b = f a b r (0,1) (1,-q)\n\n where q = a `div` b; r = a `mod` b\n\n\n\nf _ _ 1 _ (x,y) = (x,y)\n\nf a b rn (xb,yb) (xrn,yrn) = f b rn rn\' (xrn,yrn) (xrn\',yrn\') \n\n where qn\' = b `div` rn; rn\' = b `mod` rn; xrn\'=xb-xrn*qn\'; yrn\'=yb-yrn*qn\'       \n\n\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5834,42,'1526701','2013-10-01 00:02:08',2,'  --- Задачи к понедельнику надо присылать до 13:40.. Мы про это говорили.\r\nmyfoldl f s [] = s;\r\nmyfoldl f s (x:xs) = myfoldl f (f s x) xs;','<br/>Тесты успешно пройдены!'),(5829,51,'ip','2013-09-30 23:54:43',2,'   --- На самом деле задачи к понедельнику принимаются только до 13:40, до начала пары.\r\n   --- Я вам зачту 2 задачи из 4 (50%). Но вообще присылайте во время, пожалуйста.\r\nrepeatFunc f 1 = f\r\nrepeatFunc f n = f . (repeatFunc f (n-1))','<br/>Тесты успешно пройдены!'),(5830,52,'ip','2013-09-30 23:56:10',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = foldr (x a -> a.f) f [1..(n-1)]','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(5831,52,'ip','2013-09-30 23:58:28',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = foldr (x a -> a.x) f \r\n           (map (x -> f) [1..(n-1)])','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(5832,52,'ip','2013-10-01 00:00:10',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = foldr (x a -> a.x) f \r\n           (map (x -> f) [1..(n-1)])','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(5822,51,'ip','2013-09-30 23:23:12',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = repeatFunc (f f) (n-1)','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5823,51,'ip','2013-09-30 23:27:54',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = repeatFunc (f . f) (n-1)','Выражение имеет неправильное значение: (repeatFunc (*2) 3) 1'),(5824,51,'ip','2013-09-30 23:31:18',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = repeatFunc (f . f) (n-1)','Выражение имеет неправильное значение: (repeatFunc (*2) 3) 1'),(5825,41,'ip','2013-09-30 23:42:52',1,'countOdd xs = foldr (x t -> if ((mod x 2) == 0)\r\n                          then t\r\n                          else (t+1))\r\n                    0 xs\r\n\r\ncountOdd1 xs = sum (map (x -> if ((mod x 2) == 0)\r\n                              then 0\r\n                              else 1)\r\n                    xs)\r\n','<br/>Тесты успешно пройдены!'),(5826,52,'ip','2013-09-30 23:46:47',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = foldr (x a -> a.a) f [1..n-1]','Выражение имеет неправильное значение: repeatFunc (*2) 3 10'),(5827,52,'ip','2013-09-30 23:47:17',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = foldr (x a -> a.a) f [1..n-1]','Выражение имеет неправильное значение: repeatFunc (*2) 3 10'),(5828,52,'ip','2013-09-30 23:48:24',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = foldr (x a -> a.a) f [1..(n-1)]','Выражение имеет неправильное значение: repeatFunc (*2) 3 10'),(5816,41,'ip','2013-09-30 23:08:01',0,'countOdd xs = foldr (x -> if ((mod x 2) == 0)\r\n                          then x\r\n                          else x+1)\r\n                    0 xs\r\n\r\ncountOdd1 xs = sum (map (x -> if ((mod x 2) == 0)\r\n                              then 0\r\n                              else 1)\r\n                    xs)','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5817,41,'ip','2013-09-30 23:08:55',0,'countOdd xs = foldr (x -> if ((mod x 2) == 0)\r\n                          then x\r\n                          else (x+1))\r\n                    0 xs\r\n\r\ncountOdd1 xs = sum (map (x -> if ((mod x 2) == 0)\r\n                              then 0\r\n                              else 1)\r\n                    xs)','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5818,42,'ip','2013-09-30 23:15:28',0,'myfoldl _ a [] = a\r\nmyfoldl f a b:xs = my foldl f (f a b) xs','Не удалось вычислить выражение \"myfoldl (+) 0 [1,2,3]\", проверьте правильность синтаксиса'),(5819,42,'ip','2013-09-30 23:15:55',0,'myfoldl _ a [] = a\r\nmyfoldl f a (b:xs) = my foldl f (f a b) xs','Не удалось вычислить выражение \"myfoldl (+) 0 [1,2,3]\", проверьте правильность синтаксиса'),(5820,42,'ip','2013-09-30 23:16:26',2,'myfoldl _ a [] = a\r\nmyfoldl f a (b:xs) = myfoldl f (f a b) xs','<br/>Тесты успешно пройдены!'),(5821,51,'ip','2013-09-30 23:22:42',0,'repeatFunc f 1 = f\r\nrepeatFunc f n = repeatFunc (f f) (n-1)','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5815,41,'ip','2013-09-30 23:07:02',0,'countOdd xs = foldr (x -> if ((mod x 2) == 0)\r\n                           then x\r\n                           else x+1)\r\n                    0 xs\r\n\r\n','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5814,41,'ip','2013-09-30 23:05:57',0,'countOdd xs = foldr (x -> if ((mod x 2) == 0)\r\n                           then x\r\n                           else x+1)\r\n                    0 xs\r\n\r\ncountOdd1 xs = sum (map (x -> if ((mod x 2) == 0)\r\n                               then 0\r\n                               else 1)\r\n                    xs)','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5813,41,'ip','2013-09-30 23:05:15',0,'countOdd xs = foldr (x -> if (mod x 2) == 0\r\n                           then x\r\n                           else x+1)\r\n                    0 xs\r\n\r\ncountOdd1 xs = sum (map (x -> if (mod x 2) == 0\r\n                               then 0\r\n                               else 1)\r\n                    xs)','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5811,40,'1526701','2013-09-30 22:38:36',2,'--- Те задачи, которые задаются  к понедельнику, можно присылать только до начала пары,\r\n--- Я это говорил, и это неписано в слайдаз\r\nlst 0 k = [];\r\nlst n k = (if n==k then 1 else 0) : lst (n-1) k;\r\n\r\nlop n 0 = [];\r\nlop n m = lst n m : lop n (m-1);\r\n\r\nidentity n = lop n n;','<br/>Тесты успешно пройдены!'),(5812,40,'ip','2013-09-30 22:40:42',2,'identity n = identity3 n n []\r\n\r\nidentity3 0 _ xs = xs\r\nidentity3 k n xs = identity3 (k-1) n \r\n          ((identity2 n k []):xs)\r\n\r\nidentity2 0 _ xs = xs\r\nidentity2 k k xs = identity2 (k-1) k (1:xs)\r\nidentity2 n k xs = identity2 (n-1) k (0:xs)\r\n','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5809,40,'ip','2013-09-30 22:36:25',0,'identity n = identity3 n n []\r\n\r\nidentity3 0 _ xs = xs\r\nidentity3 k n xs = identity3 (k-1) n \r\n          ((identity2 n k []):xs)\r\n\r\nidentity2 0 _ xs = xs\r\nidentity2 k k xs = identity2 (k-1) k (1:xs)\r\nidentity2 n k xs = identity2 n-1 k (0:xs)\r\n','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5810,40,'ip','2013-09-30 22:36:55',0,'identity n = identity3 n n []\r\n\r\nidentity3 0 _ xs = xs\r\nidentity3 k n xs = identity3 (k-1) n \r\n          ((identity2 n k []):xs)\r\n\r\nidentity2 0 _ xs = xs\r\nidentity2 k k xs = identity2 (k-1) k (1:xs)\r\nidentity2 n k xs = identity2 (n-1) k (0:xs)\r\n','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5808,45,'3270666','2013-09-30 18:01:30',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FP8_1\r\n{\r\n    class Program\r\n    {\r\n        static bool Check(int[][] matrix)\r\n        {\r\n            return matrix.All(array => array.Any(x => x % 2 == 0));\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.Write(\"Check({{1, 2}, {2, 3}, {3, 4}}) = \");\r\n            Console.WriteLine(Check(new int[][] {\r\n                    new int[] {1, 2}, \r\n                    new int[] {2, 3}, \r\n                    new int[] {3, 4}\r\n                }));\r\n            Console.Write(\"Check({{1, 3, 9}, {5, 15}}) = \");\r\n            Console.WriteLine(Check(new int[][] {\r\n                    new int[] {1, 3, 9}, \r\n                    new int[] {5, 15}\r\n                }));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5807,47,'3226573','2013-09-30 16:37:11',1,'makePair x xs = [(x:xs), xs]\r\naddElem elem xs = foldr (x res -> (makePair elem x) ++ res) [] xs\r\npowerset xs = foldr (x res -> addElem x res) [[]] xs','<br/>Тесты успешно пройдены!'),(5806,52,'1835693','2013-09-30 14:33:34',1,'-- Эту задачу я уже посылал через почту (когда у меня не было доступа к тестовой системе).\r\n-- Добавляю ее сюда для более удобного отслеживания.\r\nf = repeatFunc sin 3\r\n\r\nrepeatFunc func times = foldl (.) id (replicate times func)','<br/>Тесты успешно пройдены!'),(5805,41,'1835693','2013-09-30 14:32:46',1,'-- Эту задачу я уже посылал через почту (когда у меня не было доступа к тестовой системе).\r\n-- Добавляю ее сюда для более удобного отслеживания.\r\n\r\n-- update: Поменял местами val и sum в checkOdd - перепутал foldr и foldl.\r\ncountOdd list = foldr checkOdd 0 list\r\n\r\ncheckOdd val sum = if (mod val 2 == 0)\r\n                   then sum\r\n				   else (sum + 1)\r\n\r\ncountOdd1 = countOdd','<br/>Тесты успешно пройдены!'),(5803,43,'3226573','2013-09-30 14:00:14',1,'euclid 0 b = (0,1)\r\neuclid a b = (y1 - (div b a) * x1, x1) \r\n	     where (x1,y1) = euclid (mod b a) a','<br/>Тесты успешно пройдены!'),(5804,41,'1835693','2013-09-30 14:27:16',0,'-- Эту задачу я уже посылал через почту (когда у меня не было доступа к тестовой системе).\r\n-- Добавляю ее сюда для более удобного отслеживания.\r\ncountOdd list = foldr checkOdd 0 list\r\n\r\ncheckOdd sum val = if (mod val 2 == 0)\r\n                   then sum\r\n				   else (sum + 1)\r\n			   \r\ncountOdd1 = countOdd','Выражение имеет неправильное значение: countOdd [2, 3, 4, 8, 5, 33, 9]'),(5801,40,'1595828','2013-09-30 13:06:16',1,'identity n = map (j -> map (i -> if i == j then 1 else 0)[1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5802,51,'1835693','2013-09-30 13:10:37',1,'f = repeatFunc sin 3\r\n\r\nrepeatFunc func times = repeatFuncH id func times\r\n\r\nrepeatFuncH res _ 0        = res\r\nrepeatFuncH res func times = repeatFuncH (res . func) func (times - 1)','<br/>Тесты успешно пройдены!'),(5799,42,'1835693','2013-09-30 12:46:28',1,'myfoldl op initval [] = initval\r\nmyfoldl op initval (val:values) = myfoldl op (op initval val) values','<br/>Тесты успешно пройдены!'),(5800,52,'617015','2013-09-30 12:54:34',1,'id\' = (x -> x) \r\n\r\nrepeatFunc f n = foldr (.) id\' (map(i->f) [1..n]) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5798,40,'1835693','2013-09-30 12:38:37',1,'identity n = identityh [] 0 n n\r\nidentityh res _ 0 _     = res\r\nidentityh res pos row n = identityh ((makerow pos n) : res) (pos + 1) (row - 1) n\r\n\r\nmakerow pos n = addzeroes (1 : (addzeroes [] pos)) (n - pos - 1)\r\n\r\naddzeroes res 0 = res\r\naddzeroes res n = addzeroes (0 : res) (n - 1)','<br/>Тесты успешно пройдены!'),(5797,41,'1595828','2013-09-30 12:36:09',1,'countOdd xs = foldr (x res -> if odd x then res+1 else res) 0 xs\r\n\r\ncountOdd1 xs = sum(map(x ->if odd x then 1 else 0 ) xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5794,51,'1595828','2013-09-30 11:41:03',1,'f = repeatFunc sin 3\r\n\r\nrepeatFunc f n = foldr (\\_ f\' -> (.)f f\') f [1..(n-1)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5795,42,'1595828','2013-09-30 11:58:17',1,'myfoldl _ par []     = par\r\n\r\nmyfoldl f par (x:xs) = foldl f (f par x) xs\r\n','<br/>Тесты успешно пройдены!'),(5796,41,'1595828','2013-09-30 12:32:46',0,'countOdd xs = foldr (x res -> if odd x then res+1 else res) 0 xs\r\n\ncountOdd1 xs = summ(map(x ->if odd x then 1 else 0 ) xs)\r\n\nsumm xs = foldr (+) 0 xs\n','<br/>Тесты успешно пройдены!'),(5793,52,'1595828','2013-09-30 11:39:36',1,'repeatFunc f n = foldr (\\_ f\' -> f.f\') f [1..(n-1)]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5792,39,'6053606','2013-09-30 11:31:52',1,'data Tree = Empty\r\n          | Node Integer Tree Tree\r\n\r\nminHeight Empty = 0\r\nminHeight t = go t 0 (maxBound :: Int) where\r\n  go Empty h mh = mh\r\n  go (Node _ Empty Empty) h mh= min mh h\r\n  go (Node _ l r) h mh = if mh > h\r\n                         then let lmh = go l (h + 1) mh\r\n                              in go r (h + 1) lmh\r\n                         else mh\r\n\r\n-- В предыдущей версии я, кажется, добавила mh как минимальную\r\n-- достигнутую глубину, но забыла добавить проверку.\r\n-- Спасибо!','<br/>Тесты успешно пройдены!'),(5791,39,'6053606','2013-09-30 11:30:03',0,'data Tree = Empty\r\n          | Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 0\r\nminHeight t = go t 0 (maxBound :: Int) where\r\n  go Empty h mh = mh\r\n  go (Node _ Empty Empty) h mh= min mh h\r\n  go (Node _ l r) h mh = if mh > h\r\n                         then let lmh = go l (h + 1) mh\r\n                              in go r (h + 1) lmh\r\n                         else mh\r\n\r\n-- В предыдущей версии я, кажется, добавила mh как минимальную\r\n-- достигнутую глубину, но забыла добавить проверку.\r\n-- Спасибо!','<br/>Тесты успешно пройдены!'),(5790,45,'nbumakov','2013-09-30 11:02:41',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace FuncHW\r\n{\r\n    class Hw8\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] array = { \r\n                                new int[] { 1, 3, 5 }, \r\n                                new int[] { 1, 3, 5 } \r\n                            };\r\n           \r\n            Console.WriteLine(array.All(a => a.Any(x => x % 2 == 0)));\r\n\r\n            int[][] array2 = { \r\n                                new int[] { 1, 3, 5, 2 }, \r\n                                new int[] { 1, 3, 5, 2 } \r\n                            };\r\n            Console.WriteLine(array2.All(a => a.Any(x => x % 2 == 0)));\r\n\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5788,41,'Valentina Guleva','2013-09-30 10:47:15',1,'countOdd   xs = foldr (x y -> y + (mod x 2)) 0 xs\r\n\r\n\r\n\r\ncountOdd1 xs = length (filter odd xs)\r\n\r\n\r\n\r\n{--countOdd   xs = foldr (x y -> y + if (odd x) then 1 else 0) 0 xs--}\r\n','<br/>Тесты успешно пройдены!'),(5789,42,'Valentina Guleva','2013-09-30 10:56:23',1,'myfoldl (function) value [] = value\r\n\r\nmyfoldl (function) value xs = myfoldl (function) (function value (head xs)) (tail xs)\r\n','<br/>Тесты успешно пройдены!'),(5787,40,'Valentina Guleva','2013-09-30 10:46:32',1,'identity n = [map (j -> if( j == i )then 1 else 0) [1..n] | i <- [1..n]]\r\n\r\n\r\n\r\n{-- or in other view\r\n\r\nidentity n = [[if (i == j) then 1 else 0 | j <- [1..n]]| i <- [1..n]]\r\n\r\n--}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5785,43,'nbumakov','2013-09-30 10:06:08',0,'euclid a b = \r\n    if a `mod` b == 0 then (0, 1)\r\n    else \r\n        let (x, y) = euclid b (a `mod` b)\r\n        in (y, x-(y*(a `div` b)))','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5786,43,'nbumakov','2013-09-30 10:11:44',1,'euclid a b = \r\n    if b == 0 then (1, 0) else\r\n    if a `mod` b == 0 then (0, 1)\r\n    else \r\n        let (x, y) = euclid b (a `mod` b)\r\n        in (y, x-(y*(a `div` b)))','<br/>Тесты успешно пройдены!'),(5784,41,'517309','2013-09-30 07:12:50',3,'proc = x -> if mod x 2 == 0\r\n		then 0\r\n		else 1\r\ncountOdd1 xs = foldr (+) 0 (map proc xs)\r\n\r\nmodsum x y = mod x 2 + y \r\ncountOdd xs = foldr modsum 0 xs','<br/>Тесты успешно пройдены!'),(5783,43,'MaryK','2013-09-30 02:49:50',1,'module Func where\r\n\r\nimport Prelude(Bool(..),div,RealFloat(),Double(),Int(),Show(..),(.),rem,foldl, Eq(..),id, map ,(/), (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nmodd :: Float->Float->Float\r\n\r\nmodd 1 0 = 0\r\n\r\nmodd a b = if a < b then a else modd (a-b) b \r\n\r\neuclid::Float->Float->(Float,Float)\r\n\r\neuclid 1 0 = (1,0)\r\n\r\neuclid a b = e a b (1,0) (0,1) \r\n\r\ne:: Float->Float->(Float,Float)->(Float,Float)->(Float,Float)\r\n\r\ne a b x1 x2  = if r == 0 then (snd x1, snd x2) else e b r (y1,y2) (z1,z2) where r =  modd a b\r\n\r\n									        q = (a-r)/b\r\n\r\n									        y1= (fst x1)*0+(snd x1)*1	\r\n\r\n									        y2 = (fst x1)*1+(snd x1)*(-1)*q\r\n\r\n									        z1 =(fst x2)*0+(snd x2)*1 \r\n\r\n									        z2 = (fst x2)*1+(snd x2)*(-1)*q	\r\n','<br/>Тесты успешно пройдены!'),(5782,43,'MaryK','2013-09-30 02:48:30',0,'module Func where\r\n\nimport Prelude(Bool(..),div,RealFloat(),Double(),Int(),Show(..),(.),rem,foldl, Eq(..),id, map ,(/), (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nmodd :: Float->Float->Float\r\n\nmodd 1 0 = 0\r\n\nmodd a b = if a < b then a else modd (a-b) b \r\n\neuclid::Float->Float->(Float,Float)\r\n\neuclid a b = e a b (1,0) (0,1) \r\n\ne:: Float->Float->(Float,Float)->(Float,Float)->(Float,Float)\r\n\ne a b x1 x2  = if r == 0 then (snd x1, snd x2) else e b r (y1,y2) (z1,z2) where r =  modd a b\r\n\n									        q = (a-r)/b\r\n\n									        y1= (fst x1)*0+(snd x1)*1	\r\n\n									        y2 = (fst x1)*1+(snd x1)*(-1)*q\r\n\n									        z1 =(fst x2)*0+(snd x2)*1 \r\n\n									        z2 = (fst x2)*1+(snd x2)*(-1)*q	\n','Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),(5781,43,'MaryK','2013-09-30 02:45:18',0,'','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5777,52,'12828920','2013-09-30 02:31:46',1,'repeatFunc func n = foldl (i j->i.func) func [1..n-1]\r\n','<br/>Тесты успешно пройдены!'),(5778,43,'MaryK','2013-09-30 02:35:51',0,'module Func where\r\n\nimport Prelude(Bool(..),div,RealFloat(),Double(),Int(),Show(..),(.),rem,foldl, Eq(..),id, map ,(/), (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nmodd :: Float->Float->Float\r\n\nmodd a b = if a < b then a else modd (a-b) b \r\n\neuclid::Float->Float->(Float,Float)\r\n\neuclid a b = e a b (1,0) (0,1) \r\n\ne:: Float->Float->(Float,Float)->(Float,Float)->(Float,Float)\r\n\ne a b x1 x2  = if r == 0 then (snd x1, snd x2) else e b r (y1,y2) (z1,z2) where r =  modd a b\r\n\n									        q = (a-r)/b\r\n\n									        y1= (fst x1)*0+(snd x1)*1	\r\n\n									        y2 = (fst x1)*1+(snd x1)*(-1)*q\r\n\n									        z1 =(fst x2)*0+(snd x2)*1 \r\n\n									        z2 = (fst x2)*1+(snd x2)*(-1)*q	\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5779,43,'MaryK','2013-09-30 02:38:56',0,'module Func where\r\n\nimport Prelude(Bool(..),div,RealFloat(),Double(),Int(),Show(..),(.),rem,foldl, Eq(..),id, map ,(/), (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nmodd :: Float->Float->Float\r\n\nmodd a b = if a < b then a else modd (a-b) b \r\n\neuclid::Float->Float->(Float,Float)\r\n\neuclid a b = e a b (1,0) (0,1) \r\n\ne:: Float->Float->(Float,Float)->(Float,Float)->(Float,Float)\r\n\ne a b x1 x2  = if r == 0 then (snd x1, snd x2) else e b r (y1,y2) (z1,z2) where r =  modd a b\r\n\n									        q = (a-r)/b\r\n\n									        y1= (fst x1)*0+(snd x1)*1	\r\n\n									        y2 = (fst x1)*1+(snd x1)*(-1)*q\r\n\n									        z1 =(fst x2)*0+(snd x2)*1 \r\n\n									        z2 = (fst x2)*1+(snd x2)*(-1)*q	\n','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5780,43,'MaryK','2013-09-30 02:43:42',0,'module Func where\r\n\nimport Prelude(Bool(..),div,RealFloat(),Double(),Int(),Show(..),(.),rem,foldl, Eq(..),id, map ,(/), (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nmodd :: Float->Float->Float\r\n\nmodd 1 0 = 0\r\n\nmodd a b = if a < b then a else modd (a-b) b \r\n\neuclid::Float->Float->(Float,Float)\r\n\neuclid a b = e a b (1,0) (0,1) \r\n\ne:: Float->Float->(Float,Float)->(Float,Float)->(Float,Float)\r\n\ne a b x1 x2  = if r == 0 then (snd x1, snd x2) else e b r (y1,y2) (z1,z2) where r =  modd a b\r\n\n									        q = (a-r)/b\r\n\n									        y1= (fst x1)*0+(snd x1)*1	\r\n\n									        y2 = (fst x1)*1+(snd x1)*(-1)*q\r\n\n									        z1 =(fst x2)*0+(snd x2)*1 \r\n\n									        z2 = (fst x2)*1+(snd x2)*(-1)*q	\n','Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),(5776,51,'12828920','2013-09-30 02:24:06',1,'repeatFunc func 1 = func\r\n\r\nrepeatFunc func n = func.(repeatFunc func (n-1))\r\n','<br/>Тесты успешно пройдены!'),(5770,42,'12828920','2013-09-30 02:06:46',1,'myfoldl func number [] = number\r\n\r\nmyfoldl func number (x:xs) = myfoldl func(func number x) xs\r\n','<br/>Тесты успешно пройдены!'),(5771,42,'5247795','2013-09-30 02:07:01',1,'myfoldl _ i [] = i\r\n\r\nmyfoldl f i (x:xs) = myfoldl f (f i x) xs\r\n','<br/>Тесты успешно пройдены!'),(5772,51,'5247795','2013-09-30 02:07:40',1,'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n-1))\r\n\r\nf = repeatFunc sin 3\r\n','<br/>Тесты успешно пройдены!'),(5773,41,'480387','2013-09-30 02:17:46',0,'proc = x -> if mod x 2 == 0\r\n		then 0\r\n		else 1\r\ncountOdd1 xs = foldr (+) 0 (map proc xs)\r\n\r\nmodsum x y = mod x 2 + y \r\ncountOdd  = foldr modsum 0\r\n		','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5774,41,'480387','2013-09-30 02:19:39',0,'proc = x -> if mod x 2 == 0\r\n		then 0\r\n		else 1\r\ncountOdd1 xs = foldr (+) 0 (map proc xs)\r\n\r\nmodsum x y = mod x 2 + y \r\ncountOdd  = foldr modsum 0','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5775,41,'480387','2013-09-30 02:23:30',1,'proc = x -> if mod x 2 == 0\r\n		then 0\r\n		else 1\r\ncountOdd1 xs = foldr (+) 0 (map proc xs)\r\n\r\nmodsum x y = mod x 2 + y \r\ncountOdd xs = foldr modsum 0 xs','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5751,52,'480387','2013-09-30 00:09:04',1,'repeatFunc f n = foldr (.) id (map (\\_ -> f) [1..n])','<br/>Тесты успешно пройдены!'),(5752,51,'480387','2013-09-30 00:09:44',1,'repeatFunc f n = foldr (.) id (map (\\_ -> f) [1..n])','<br/>Тесты успешно пройдены!'),(5753,42,'ArtemK','2013-09-30 00:13:31',1,'myfoldl f b [] = b\r\nmyfoldl f b (x:xs) = myfoldl f (f b x) xs','<br/>Тесты успешно пройдены!'),(5754,42,'480387','2013-09-30 00:20:39',0,'myfoldrl f e [] = e\r\nmyfoldrl f e xs = (myfoldrl f e (init xs)) `f` (last xs)','Не удалось вычислить выражение \"myfoldl (+) 0 [1,2,3]\", проверьте правильность синтаксиса'),(5755,42,'480387','2013-09-30 00:21:04',1,'myfoldl f e [] = e\r\nmyfoldl f e xs = (myfoldl f e (init xs)) `f` (last xs)','<br/>Тесты успешно пройдены!'),(5756,41,'480387','2013-09-30 00:32:43',0,'proc = x -> if mod x 2 == 0\r\n		then 0\r\n		else 1\r\ncountOdd1 xs = foldr (+) 0 (map proc xs)\r\ncountOdd = countOdd1\r\n','<br/>Тесты успешно пройдены!'),(5757,40,'480387','2013-09-30 00:41:08',1,'gete i n = map (x -> if x == i then 1 else 0) [1..n]\r\nidentity n = map (i -> gete i n) [1..n]\r\n ','<br/>Тесты успешно пройдены!'),(5758,51,'ArtemK','2013-09-30 00:43:17',0,'repeatFunc f n = foldr (.) id (map (\\_ -> f) [1..n])','<br/>Тесты успешно пройдены!'),(5759,52,'ArtemK','2013-09-30 00:45:33',1,'repeatFunc f n = foldr (.) id (map (\\_ -> f) [1..n])','<br/>Тесты успешно пройдены!'),(5760,51,'ArtemK','2013-09-30 00:52:34',1,'repeatFunc f 1 = f\r\nrepeatFunc f n = f . (repeatFunc f (n-1))','<br/>Тесты успешно пройдены!'),(5761,52,'nbumakov','2013-09-30 01:04:01',1,'repeatFunc f n = foldl (g _ -> f . g ) id [1..n]','<br/>Тесты успешно пройдены!'),(5762,51,'nbumakov','2013-09-30 01:04:22',1,'repeatFunc f n = foldl (g _ -> f . g ) id [1..n]','<br/>Тесты успешно пройдены!'),(5763,42,'nbumakov','2013-09-30 01:04:57',1,'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs','<br/>Тесты успешно пройдены!'),(5764,41,'nbumakov','2013-09-30 01:05:15',1,'countOdd = foldr ( i sum -> if mod i 2 == 0 then sum else sum + 1) 0\r\ncountOdd1 xs =  sum (map (`mod` 2)  xs)','<br/>Тесты успешно пройдены!'),(5765,40,'nbumakov','2013-09-30 01:05:28',1,'identity n = foldr (i xs -> vector n i : xs ) [] [1..n]\r\nvector n i = map (x -> if x == i then 1 else 0) [1..n]','<br/>Тесты успешно пройдены!'),(5766,41,'5247795','2013-09-30 01:12:17',1,'countOdd xs = foldr (x c -> if (x `mod` 2 == 1) then c+1 else c) 0 xs\r\n\r\ncountOdd1 xs = foldr (+) 0 (map (i -> i `mod` 2) xs)\r\n','<br/>Тесты успешно пройдены!'),(5767,40,'12828920','2013-09-30 01:27:14',1,'identity n = map (i->map (k->if (k==i) then 1 else 0) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5768,41,'12828920','2013-09-30 01:53:33',1,'countOdd xs = foldr (i j->(mod i 2) + j) 0 xs\r\n\r\n\r\n\r\ncountOdd1 xs = sum (map (i->mod i 2) xs)\r\n','<br/>Тесты успешно пройдены!'),(5769,42,'12828920','2013-09-30 02:06:07',0,'myfoldl func number [x] = func number x\r\n\nmyfoldl func number (x:xs) = myfoldl func(func number x) xs\n','Не удалось вычислить выражение \"myfoldl (+) 10 []\", проверьте правильность синтаксиса'),(5749,52,'MaryK','2013-09-30 00:07:36',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..),(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nrepeatFunc f  1 = f                \r\n\r\nrepeatFunc f n = foldl (.) f (map (i->f)[1..n-1])\r\n\r\nf = repeatFunc sin 3\r\n','<br/>Тесты успешно пройдены!'),(5750,52,'480387','2013-09-30 00:08:43',0,'repeat f n = foldr (.) id (map (\\_ -> f) [1..n])','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(5748,51,'MaryK','2013-09-30 00:07:02',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..),(.),foldl, Eq(..),id, map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nrepeatFunc f  1 = f                \r\n\r\nrepeatFunc f n = foldl (.) f (map (i->f)[1..n-1])\r\n\r\nf = repeatFunc sin 3\r\n','<br/>Тесты успешно пройдены!'),(5746,51,'617015','2013-09-30 00:04:09',1,'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n= f.(repeatFunc (f) (n-1))\r\n','<br/>Тесты успешно пройдены!'),(5747,51,'MaryK','2013-09-30 00:06:09',0,'module Func where\r\n\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..),(.),foldl, Eq(..), map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nrepeatFunc f  1 = f                \r\n\nrepeatFunc f n = foldl (.) f (map (i->f)[1..n-1])\r\n\nf = repeatFunc sin 3\n','Не удалось вычислить выражение \"repeatFunc id 10 1\", проверьте правильность синтаксиса'),(5743,51,'3301494','2013-09-30 00:01:36',1,'repeatFunc f n = foldl (.) f (map (x -> f) [1..(n - 1)])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5744,52,'3301494','2013-09-30 00:02:07',1,'repeatFunc f n = foldl (.) f (map (x -> f) [1..(n - 1)])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5745,51,'MaryK','2013-09-30 00:03:11',0,'module Func where\r\n\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..),(.),foldl, Eq(..), map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nlistf f 0 [] = []\r\n\nlistf f n xs = listf f (n-1) (f:xs)\r\n\nrepeatFunc f  1 = f                \r\n\nrepeatFunc f n = foldl (.) f (map (i->f)[1..n])\r\n\nf = repeatFunc sin 3\n','Выражение имеет неправильное значение: (repeatFunc (*2) 3) 1'),(5742,41,'ArtemK','2013-09-29 23:56:54',1,'countOdd xs = foldr (x y -> mod x 2 + y) 0 xs\r\ncountOdd1 xs = length (filter (x -> mod x 2 == 1) xs)','<br/>Тесты успешно пройдены!'),(5733,51,'artem.gomerman','2013-09-29 23:08:54',1,'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = repeatFunc\' (f) n (f) n\r\n\r\nrepeatFunc\' _ _ res 1 = res\r\n\r\nrepeatFunc\' f n res p = repeatFunc\' (f) n (x -> res (f x) ) (p - 1)\r\n','<br/>Тесты успешно пройдены!'),(5734,40,'3301494','2013-09-29 23:16:48',1,'identity n = map (x -> map (y -> if (x == y) then 1 else 0) [1..n]) [1..n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5735,41,'3301494','2013-09-29 23:27:35',1,'countOdd xs = foldr (x res -> res + if (x `mod` 2 == 1) then 1 else 0) 0 xs\r\n\r\ncountOdd1 xs = length (filter (x -> x `mod` 2 == 1) xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5736,40,'617015','2013-09-29 23:30:00',1,'identity n = iden n 1 n\r\n\r\niden n i 1 = [createList n n n]\r\n\r\niden n i k = [(createList n i n)] ++ (iden n (i+1) (k-1))\r\n\r\n\r\n\r\n\r\n\r\ncreateList n i 0 = []\r\n\r\ncreateList n i j = if j==(n-i+1) then (1:(createList n i (j-1))) else (0:(createList n i (j-1)))\r\n','<br/>Тесты успешно пройдены!'),(5737,42,'3301494','2013-09-29 23:37:56',1,'myfoldl _ res [] = res\r\n\r\nmyfoldl op initValue (x:xs) = myfoldl op (op initValue x) xs \r\n','<br/>Тесты успешно пройдены!'),(5738,40,'ArtemK','2013-09-29 23:40:39',1,'identity n = map (x -> map (y -> if (y == x) then 1 else 0) [1..n] ) [1..n]','<br/>Тесты успешно пройдены!'),(5739,41,'ArtemK','2013-09-29 23:51:06',0,'countOdd xs = foldr (x y -> x + 1 - mod y 2) 0 xs\r\ncountOdd1 xs = length (filter (x -> mod x 2 == 0) xs)','Выражение имеет неправильное значение: countOdd [2, 3, 4, 8, 5, 33, 9]'),(5740,41,'ArtemK','2013-09-29 23:54:50',0,'countOdd xs = foldr (x y -> 1 - mod x 2 + y) 0 xs\r\ncountOdd1 xs = length (filter (x -> mod x 2 == 0) xs)','Выражение имеет неправильное значение: countOdd [2, 3, 4, 8, 5, 33, 9]'),(5741,52,'artem.gomerman','2013-09-29 23:56:41',1,'repeatFunc f n = foldr (.) (x->x) (map (x->f) [1..n])\r\n','<br/>Тесты успешно пройдены!'),(5731,51,'641524','2013-09-29 23:05:30',1,'repeatFunc f n = foldr (f1 f2->f2.f1) (x->x) (map (x->f) [1..n]) \r\n','<br/>Тесты успешно пройдены!'),(5732,52,'641524','2013-09-29 23:06:09',1,'repeatFunc f n = foldr (f1 f2->f2.f1) (x->x) (map (x->f) [1..n]) \r\n','<br/>Тесты успешно пройдены!'),(5730,45,'8519021','2013-09-29 22:55:53',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace AnyEven\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static bool CheckArray(int[][] a)\r\n\r\n        {\r\n\r\n            return a.All(b => b.Any(x => x % 2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[][] a = new int[][] {new int[] {1, 2}, new int[] {3, 4}, new int[] {5, 6}, new int[] {7, 8}};\r\n\r\n            int[][] b = new int[][] { new int[] { 1, 2 }, new int[] { 3, 5 }};\r\n\r\n            Console.WriteLine(\"В каждом из массивов a есть хотя бы один четный элемент: {0}\", CheckArray(a));\r\n\r\n            Console.WriteLine(\"В каждом из массивов b есть хотя бы один четный элемент: {0}\", CheckArray(b));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5728,42,'617015','2013-09-29 22:38:18',1,'myfoldl _ z []     = z\r\n\r\nmyfoldl f z (x:xs) = myfoldl f (f z x) xs\r\n','<br/>Тесты успешно пройдены!'),(5729,51,'641524','2013-09-29 22:39:39',0,'repeatFunc f 1 = f\r\n\nrepeatFunc f n = f (repeatFunc f (n-1)) \n','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5718,42,'641524','2013-09-29 22:07:25',0,'myfoldl f e [] = e\r\n\nmyfoldl f e (x:xs) = myfoldl\' (f x e) f xs\r\n\nmyfoldl\' s f [] = s\r\n\nmyfoldl\' s f (x:xs) = myfoldl\' (f s x) f xs  \n','Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),(5719,41,'artem.gomerman','2013-09-29 22:14:39',1,'countOdd [] = 0\r\n  --- Жто правило не нужно, оно следует из второго\r\ncountOdd xs = foldr (x res -> res + (x `mod` 2) ) 0 xs\r\n\r\n\r\n\r\ncoundOdd1 [] = 0\r\n   --- И это тоже\r\ncountOdd1 xs = length (filter (i -> i `mod` 2 == 1) xs)\r\n','<br/>Тесты успешно пройдены!'),(5720,42,'641524','2013-09-29 22:15:22',1,'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl\' (f e x) f xs\r\n\r\nmyfoldl\' s f [] = s\r\n\r\nmyfoldl\' s f (x:xs) = myfoldl\' (f s x) f xs  \r\n','<br/>Тесты успешно пройдены!'),(5721,47,'6053606','2013-09-29 22:21:26',1,'powerset xs = go [[]] xs where\r\n  go acc [] = acc\r\n  go acc (x:xs) =\r\n    let acc\' = acc ++ map (++ [x]) acc\r\n        --- Лучше вместо ++[х] написать [х]++ или x:\r\n        --- Для алгоритма это все равно, а работать будет гораздо быстрее\r\n    in go acc\' xs\r\n','<br/>Тесты успешно пройдены!'),(5722,42,'artem.gomerman','2013-09-29 22:23:09',0,'myfoldl f e [] = e\r\n\nmyfoldl f e (x:xs) = (myfoldl f x xs) `f` e\n','Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),(5723,40,'5247795','2013-09-29 22:24:03',1,'identity n = map (i -> map (j -> if (i==j) then 1 else 0) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5724,42,'artem.gomerman','2013-09-29 22:26:07',0,'myfoldl f e [] = e\r\n\nmyfoldl f e (x:xs) = (myfoldl f e xs) `f` x\n','Выражение имеет неправильное значение: let f x y = 2*x+y in myfoldl f 2 [3,5]'),(5725,48,'6053606','2013-09-29 22:34:17',1,'myreverse xs = foldr (x acc l -> acc $ x:l) id xs []\r\n','<br/>Тесты успешно пройдены!'),(5726,41,'617015','2013-09-29 22:37:16',1,'countOdd (xs)  =	foldr (x res -> res + (x `mod` 2) ) 0 xs\r\n\r\n\r\n\r\ncountOdd1 xs = sum( map (x  -> x `mod` 2 ) xs)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5727,42,'artem.gomerman','2013-09-29 22:37:57',1,'myfoldl _ e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (e `f` x) xs\r\n','<br/>Тесты успешно пройдены!'),(5716,42,'641524','2013-09-29 22:03:09',0,'myfoldl f e [] = e\r\n\nmyfoldl f e (x:xs) = myfoldl\' (f e x) f xs\r\n\nmyfoldl\' s f [] = s\r\n\nmyfoldl\' s f (x:xs) = myfoldl\' (f x s) f xs  \n','Выражение имеет неправильное значение: let f x y = 2*x+y in myfoldl f 2 [3,5]'),(5717,39,'6053606','2013-09-29 22:05:09',2,'data Tree = Empty\r\n          | Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\nminHeight Empty = 0\r\nminHeight t = go t 0 (maxBound :: Int) where\r\n  go Empty h mh = mh\r\n  go (Node _ Empty Empty) h mh= min mh h\r\n  go (Node _ l r) h mh = let lmh = go l (h + 1) mh\r\n    --- Где-то здесь надо рассмотреть случай, когда мы уже зашли глубоко, и дальше смотреть нет смысла.\r\n    --- Я вам задачу потом засчитаю в любом случае, но попробуйте исправить, пожалуйста?\r\n                         in go r (h + 1) lmh\r\n','<br/>Тесты успешно пройдены!'),(5715,39,'6053606','2013-09-29 22:02:08',0,'data Tree = Empty\r\n          | Node Integer Tree Tree\r\n\r\nminHeight Empty = 0\r\nminHeight t = go t 0 (maxBound :: Int) where\r\n  go Empty h mh = min mh h\r\n  go (Node _ Empty Empty) h mh= min mh h\r\n  go (Node _ l r) h mh = let lmh = go l (h + 1) mh\r\n                         in go r (h + 1) lmh\r\n','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),(5712,42,'641524','2013-09-29 21:58:03',0,'myfoldl f e (x:xs) = myfoldl\' (f e x) f xs\r\n\nmyfoldl\' s f [] = s\r\n\nmyfoldl\' s f (x:xs) = myfoldl\' (f s x) f xs  \n','Не удалось вычислить выражение \"myfoldl (+) 10 []\", проверьте правильность синтаксиса'),(5713,42,'641524','2013-09-29 21:59:12',0,'myfoldl f e [] = e\r\n\nmyfoldl f e (x:xs) = myfoldl\' (f e x) f xs\r\n\nmyfoldl\' s f [] = s\r\n\nmyfoldl\' s f (x:xs) = myfoldl\' (f s x) f xs  \n','Выражение имеет неправильное значение: let f x y = 2*x+y in myfoldl f 2 [3,5]'),(5714,47,'egeorge','2013-09-29 21:59:16',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) = let xs_pwset = powerset xs\r\n                  in merge xs_pwset\r\n                           (map (ys -> (x:ys)) xs_pwset)\r\n                                \r\nmerge xs [] = xs\r\nmerge [] ys = ys\r\nmerge (x:xs) (y:ys) = x : y : merge xs ys\r\n  --- OK, но зачем вообще  merge? Мне кажется, и простой ++ тут вполне подойдет?','<br/>Тесты успешно пройдены!'),(5710,52,'egeorge','2013-09-29 21:49:48',1,'repeatFunc f n = foldr (f g-> f.g) (x -> x) (replicate n f)','<br/>Тесты успешно пройдены!'),(5711,40,'artem.gomerman','2013-09-29 21:53:56',1,'identity 0 = [[]]\r\n\r\nidentity n = map (normList n) [1..n]\r\n\r\nnormList n p = normList\' p n n []\r\n\r\nnormList\' _ _ 0 xs = xs\r\n\r\nnormList\' p n x xs = if x == p then normList\' p n (x - 1) (1:xs) else normList\' p n (x - 1) (0:xs)\r\n','<br/>Тесты успешно пройдены!'),(5709,52,'6053606','2013-09-29 21:46:16',1,'repeatFunc f n = foldr (.) id $ replicate n f\r\n','<br/>Тесты успешно пройдены!'),(5708,51,'6053606','2013-09-29 21:45:36',1,'repeatFunc f n = foldr (.) id $ replicate n f\r\n','<br/>Тесты успешно пройдены!'),(5707,42,'6053606','2013-09-29 21:41:48',1,'myfoldl f init xs = go init xs where\r\n  go acc [] = acc\r\n  go acc (x:xs) = go (f acc x) xs','<br/>Тесты успешно пройдены!'),(5706,43,'8519021','2013-09-29 21:38:54',1,'euclid a b\r\n\r\n  | gcd a b /= 1 = error \"a and b are not relatively prime!\"\r\n\r\n  | a == 0 = (0, 1)\r\n\r\n  | otherwise =\r\n\r\n      let\r\n\r\n        (x1, y1) = euclid (mod b a) a\r\n\r\n      in (y1 - (div b a) * x1, x1)\r\n','<br/>Тесты успешно пройдены!'),(5705,51,'egeorge','2013-09-29 21:37:39',1,'repeatFunc _ 0 = (x -> x)\r\n\r\nrepeatFunc f n = (x -> f (repeatFunc f (n-1) x))','<br/>Тесты успешно пройдены!'),(5704,51,'egeorge','2013-09-29 21:36:29',0,'repeatFunc _ 0 = (x -> x)\r\n\r\nrepeatFunc f n = (x -> f (repeatfunc f (n-1) x))','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5696,30,'6053606','2013-09-29 21:14:56',0,'parts xs = foldr gcd (head ls) (tail ls) >= 2 where\r\n  ls = go [1] $ zip xs $ tail xs\r\n  go acc [] = acc\r\n  go (c:acc) ((x, y):xs) = if x < y\r\n                           then go (c + 1:acc) xs\r\n                           else go (1:c:acc) xs\r\n\r\n-- Насколько я понимаю, проблема предыдущей загрузки была в  том, что\r\n-- gcd считался попарно. ','<br/>Тесты успешно пройдены!'),(5697,30,'6053606','2013-09-29 21:15:06',1,'parts xs = foldr gcd (head ls) (tail ls) >= 2 where\r\n  ls = go [1] $ zip xs $ tail xs\r\n  go acc [] = acc\r\n  go (c:acc) ((x, y):xs) = if x < y\r\n                           then go (c + 1:acc) xs\r\n                           else go (1:c:acc) xs\r\n\r\n-- Насколько я понимаю, проблема предыдущей загрузки была в  том, что\r\n-- gcd считался попарно. ','<br/>Тесты успешно пройдены!'),(5698,41,'egeorge','2013-09-29 21:19:02',1,'countOdd xs = foldr (x res -> if (x `mod` 2 == 1)\r\n                         then 1 + res\r\n                         else res) 0 xs\r\n\r\ncountOdd1 xs = length (filter (x -> x `mod` 2 == 1) xs)','<br/>Тесты успешно пройдены!'),(5699,40,'6053606','2013-09-29 21:22:13',1,'identity n = map row [1..n] where\r\n  row i = replicate (i - 1) 0 ++ [1] ++ replicate (n - i) 0\r\n','<br/>Тесты успешно пройдены!'),(5700,42,'egeorge','2013-09-29 21:29:50',1,'myfoldl f init [] = init\r\n\r\nmyfoldl f init (x:xs)  = myfoldl f (f init x) xs','<br/>Тесты успешно пройдены!'),(5701,41,'641524','2013-09-29 21:32:33',1,'countOdd xs = foldr (x s -> \r\n\r\n			if x `mod` 2 == 1 then s+1 else s ) 0 xs\r\n\r\ncountOdd1 xs = sum (map (x -> if x `mod` 2 == 1 then 1 else 0) xs)\r\n','<br/>Тесты успешно пройдены!'),(5702,41,'6053606','2013-09-29 21:35:00',1,'countOdd = foldr\r\n              (x acc -> if odd x\r\n                         then acc + 1\r\n                         else acc)\r\n              0\r\n\r\ncountOdd1 xs = sum [1 | x <- xs, odd x]\r\n','<br/>Тесты успешно пройдены!'),(5703,51,'egeorge','2013-09-29 21:36:13',0,'repeatfunc _ 0 = (x -> x)\r\n\r\nrepeatfunc f n = (x -> f (repeatfunc f (n-1) x))','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5682,51,'8519021','2013-09-29 19:00:52',1,'repeatFunc f n = foldr (\\_ f\' -> f.f\') f [1..(n - 1)]\r\n\r\nf = repeatFunc sin 3\r\n','<br/>Тесты успешно пройдены!'),(5683,40,'3320654','2013-09-29 19:04:29',1,'identity n 		= identity\' n n []\r\n\r\nidentity\' n 0 list	= list\r\nidentity\' n k list	= (identity\' n (k - 1) ((identity\'\' n k 1):list))\r\n\r\nidentity\'\' n k t	= if t <= n\r\n		   then 	if t == k\r\n		   	then 1:(identity\'\' n k (t + 1))\r\n		   	else 0:(identity\'\' n k (t + 1))\r\n		   else []','<br/>Тесты успешно пройдены!'),(5684,41,'3320654','2013-09-29 19:15:10',1,'countOdd list = foldr (x y -> (mod x 2) + y) 0 list\r\n\r\ncountOdd1 list = foldl (x y -> (mod y 2) + x) 0 list','<br/>Тесты успешно пройдены!'),(5685,42,'3320654','2013-09-29 19:20:34',1,'myfoldl _ res []	= res\r\nmyfoldl f res (x:s)	= myfoldl f (f res x) s','<br/>Тесты успешно пройдены!'),(5686,51,'3320654','2013-09-29 19:31:35',0,'myfoldl _ res []	= res\r\nmyfoldl f res (x:s)	= myfoldl f (f res x) s','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5687,51,'3320654','2013-09-29 19:32:09',1,'repeatFunc f 0 = (x -> x)\r\nrepeatFunc f n = f.(repeatFunc f (n - 1))','<br/>Тесты успешно пройдены!'),(5688,52,'3320654','2013-09-29 19:38:09',1,'repeatFunc f n = foldl (g x -> f.g) (x -> x) [1..n]','<br/>Тесты успешно пройдены!'),(5689,48,'3320654','2013-09-29 20:03:42',1,'myreverse list = (foldr (x f y -> f (x:y)) (x -> x) list) []','<br/>Тесты успешно пройдены!'),(5690,40,'2501950','2013-09-29 20:47:05',1,'identity n =  map (i -> map (c -> if c == i\r\n  then 1 else 0) [1..n]) [1..n]','<br/>Тесты успешно пройдены!'),(5691,41,'2501950','2013-09-29 21:03:12',2,'countOdd xs = foldr (+) 0 (map (i -> i `mod` 2) xs)  \r\n  --- в countOdd по условию можно использовать _только_ foldr. Те map использовать нельзя\r\n  --- Попробуйте исправить, пожалуйста \r\ncountOdd1 xs = sum (map (i -> i `mod` 2) xs)','<br/>Тесты успешно пройдены!'),(5692,40,'641524','2013-09-29 21:04:31',1,'identity n = identity\' 1 n\r\n\r\nidentity\' i n = if i==n\r\n\r\n			then [identityRow n n]\r\n\r\n			else (identityRow i n):(identity\' (i+1) n)\r\n\r\nidentityRow i n = map (k-> if k == i then 1 else 0) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5693,40,'egeorge','2013-09-29 21:11:35',0,'indicator n x = if (n == x)\r\n                then 1\r\n                else 0\r\n                \r\nidentity n = map (i -> map (indicator i) [1..n]) [1..n]','<br/>Тесты успешно пройдены!'),(5694,40,'egeorge','2013-09-29 21:11:43',1,'indicator n x = if (n == x)\r\n                then 1\r\n                else 0\r\n                \r\nidentity n = map (i -> map (indicator i) [1..n]) [1..n]','<br/>Тесты успешно пройдены!'),(5695,30,'6053606','2013-09-29 21:14:46',0,'parts xs = foldr gcd (head ls) (tail ls) >= 2 where\r\n  ls = go [1] $ zip xs $ tail xs\r\n  go acc [] = acc\r\n  go (c:acc) ((x, y):xs) = if x < y\r\n                           then go (c + 1:acc) xs\r\n                           else go (1:c:acc) xs\r\n\r\n-- Насколько я понимаю, проблема предыдущей загрузки была в  том, что\r\n-- gcd считался попарно. ','<br/>Тесты успешно пройдены!'),(5681,52,'8519021','2013-09-29 18:56:04',1,'repeatFunc f n = foldr (\\_ f\' -> f.f\') f [1..(n - 1)]\r\n\r\nf = repeatFunc sin 3\r\n','<br/>Тесты успешно пройдены!'),(5680,42,'MaryK','2013-09-29 18:55:51',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), map , (^), sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\r\nmyfoldl f z [] = z                  \r\n\r\nmyfoldl f z (x:xs) = myfoldl f (f z x) xs\r\n','<br/>Тесты успешно пройдены!'),(5671,47,'5543298','2013-09-29 16:31:51',0,'addList _ 0 res = [res]\r\n\naddList [x] i res = if (i /= 1) then [] else [x:res] \r\n\naddList [] _ _ = []\r\n\naddList (x:xs) i res = if (i == 0) then [res] else if i == length (x:xs) then [res++(x:xs)] else (addList xs (i - 1) (x:res))++(addList xs i res)\r\n\npowerset xs = foldr (x res -> (addList xs x [])++res) [] [0..(length xs)]\r\n\n\n','Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),(5672,47,'5543298','2013-09-29 16:31:54',0,'addList _ 0 res = [res]\r\n\naddList [x] i res = if (i /= 1) then [] else [x:res] \r\n\naddList [] _ _ = []\r\n\naddList (x:xs) i res = if (i == 0) then [res] else if i == length (x:xs) then [res++(x:xs)] else (addList xs (i - 1) (x:res))++(addList xs i res)\r\n\npowerset xs = foldr (x res -> (addList xs x [])++res) [] [0..(length xs)]\r\n\n\n','Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),(5673,40,'MaryK','2013-09-29 16:46:31',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..),map,Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<), head, tail, (++), sqrt, snd,fst, (||))\r\n\r\ncreate::Int->Int->[Int]\r\n\r\ncreate k n = map (i-> if i == k then 1 else 0) [1..n]\r\n\r\n\r\n\r\nidentity::Int->[[Int]]\r\n\r\nidentity n = f [[]] n 1\r\n\r\n\r\n\r\nf::[[Int]]->Int->Int->[[Int]]\r\n\r\nf list _ 0 = list\r\n\r\nf list n k = if k<n+1 then   f (list ++[create k n] ) n (k+1) else f (tail(list)) n 0	\r\n   --- Тут гораздо проще получится, если тоже использовать map\r\n','<br/>Тесты успешно пройдены!'),(5674,47,'5543298','2013-09-29 16:53:09',1,'addList _ 0 res = [res]\r\n\r\naddList [x] i res = if (i /= 1) then [] else [res++[x]] \r\n   --- Лучше приписывать в начало. Для вашего алгоритма это все равно, а получится гораздо эффективнее\r\naddList [] _ _ = []\r\n\r\naddList (x:xs) i res = if (i == 0) then [res] else if i == length (x:xs) then [res++(x:xs)] else (addList xs (i - 1) (res++[x]))++(addList xs i res)\r\n\r\npowerset xs = foldr (x res -> (addList xs x [])++res) [] [0..(length xs)]\r\n  --- ОК, но можно примерно ту же идею записать короче, мы это потом обсудим.\r\n\r\n','<br/>Тесты успешно пройдены!'),(5675,40,'8519021','2013-09-29 17:06:32',1,'identity n = map (x -> addZero (x - 1) (n - x) n [] []) [1..n]\r\n\r\naddZero l1 l2 n xs ys \r\n\r\n  | (l1 == 0 && l2 == 0) = xs ++ (1:ys)\r\n\r\n  | l1 /= 0 = addZero (l1 - 1) l2 n (0:xs) ys\r\n\r\n  | l2 /= 0 = addZero l1 (l2 - 1) n xs (0:ys)\r\n  --- Или addZaro тоже можно реализовать через map\r\n','<br/>Тесты успешно пройдены!'),(5676,41,'8519021','2013-09-29 17:31:20',1,'countOdd xs = foldr (x res -> if mod x 2 /= 0 then res + 1 else res) 0 xs\r\n\r\ncountOdd1 xs = length (filter odd xs)\r\n','<br/>Тесты успешно пройдены!'),(5677,42,'8519021','2013-09-29 17:42:30',1,'myfoldl _ res [] = res\r\n\r\nmyfoldl f res (x:xs) = myfoldl f (f res x) xs\r\n','<br/>Тесты успешно пройдены!'),(5678,41,'MaryK','2013-09-29 18:46:56',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), map ,foldl, sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n  --- Да зачем же вы это все время пишете, просто интересно?? ) \r\n\r\ncountOdd1::[Int]->Int\r\n\r\ncountOdd1 [] = 0\r\n\r\ncountOdd1 xs = c 0 xs\r\n\r\nc::Int->[Int]->Int\r\n\r\nc n [] = 0\r\n\r\nc n xs = sum(map (i-> if i `mod` 2 == 1 then 1 else 0) xs)\r\n   --- Параметр n, мне кажется, не нужен, вы его нигде и не используете. \r\n\r\n\r\n\r\ncountOdd::[Int]->Int\r\n\r\ncountOdd [] = 0\r\n\r\ncountOdd xs = foldl(x y-> if y`mod` 2 == 1 then x+1 else x) 0 xs\r\n\r\n\r\n\r\n	\r\n','<br/>Тесты успешно пройдены!'),(5679,42,'MaryK','2013-09-29 18:54:54',0,'module Func where\r\n\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), map , sum, Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<),mod, head, tail, (++), sqrt, snd,fst, (||))\r\n\nmyfoldl f z [] = z                  \r\n\nmyfoldl f z (x:xs) = myfoldl f (f z x) xs\n','Не удалось вычислить выражение \"myfoldl (^) 2 [3]\", проверьте правильность синтаксиса'),(5668,51,'1170660','2013-09-29 16:25:17',1,'repeatFunc f n = foldr (\\_ x -> f.x) f [1..(n-1)]\r\n','<br/>Тесты успешно пройдены!'),(5669,52,'1170660','2013-09-29 16:29:32',1,'repeatFunc f n = foldr (\\_ x -> f.x) f [1..(n-1)]\r\n','<br/>Тесты успешно пройдены!'),(5670,47,'5543298','2013-09-29 16:31:27',0,'addList _ 0 res = [res]\r\n\naddList [x] i res = if (i /= 1) then [] else [x:res] \r\n\naddList [] _ _ = []\r\n\naddList (x:xs) i res = if (i == 0) then [res] else if i == length (x:xs) then [res++(x:xs)] else (addList xs (i - 1) (x:res))++(addList xs i res)\r\n\npowerset xs = foldr (x res -> (addList xs x [])++res) [] [0..(length xs)]\r\n\n\n','Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),(5664,41,'1170660','2013-09-29 16:02:07',1,'countOdd list= foldr (x e -> e + x `mod` 2) 0 list\r\n\r\ncountOdd1 list = length (filter(>0)(map (mod 2) list))\r\n','Выражение имеет неправильное значение: countOdd1 [2, 3, 4, 8, 5, 33, 9]'),(5665,41,'1170660','2013-09-29 16:06:34',1,'countOdd list= foldr (x e -> e + x `mod` 2) 0 list\r\n\r\ncountOdd1 list = length (filter(/=0)(map f list))\r\n\r\nf x = mod x 2\r\n','<br/>Тесты успешно пройдены!'),(5666,42,'1170660','2013-09-29 16:19:48',1,'myfoldl f e [] = e                  \r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n\r\n\r\n\r\n\r\n\r\nmyfoldl1 op e list = foldr op e (reverse list)\r\n','<br/>Тесты успешно пройдены!'),(5667,48,'62628590','2013-09-29 16:24:22',1,'myreverse xs = foldr (x y ys -> y (x:ys)) id xs []','<br/>Тесты успешно пройдены!'),(5659,42,'62628590','2013-09-29 15:35:32',1,'myfoldl _ i [] = i\r\nmyfoldl op i (x:xs) = myfoldl op (op i x) xs','<br/>Тесты успешно пройдены!'),(5660,51,'62628590','2013-09-29 15:40:07',0,'repeatFunc f n = foldr (\\_ f\' -> f.f\') f [1..(n-1)]','<br/>Тесты успешно пройдены!'),(5661,52,'62628590','2013-09-29 15:41:36',1,'repeatFunc f n = foldr (\\_ f\' -> f.f\') f [1..(n-1)]','<br/>Тесты успешно пройдены!'),(5662,51,'62628590','2013-09-29 15:45:29',1,'repeatFunc f 1 = f\r\nrepeatFunc f n = f.(repeatFunc f (n-1))','<br/>Тесты успешно пройдены!'),(5663,47,'62628590','2013-09-29 15:51:41',1,'powerset [] = [[]]\r\npowerset (x:xs) = \r\n    let\r\n      ys = powerset xs\r\n      zs = map (ls -> (x:ls)) ys\r\n    in foldr (:) ys zs','<br/>Тесты успешно пройдены!'),(5658,40,'1170660','2013-09-29 15:05:42',1,'identity n = f (putCol [] n 1) ([])\r\n\r\n\r\n\r\nputCol matrix dim colN = if(colN==dim) then ((putUnit [1] (makeZeroRow [] dim) colN ):matrix) else putCol ((putUnit [1] (makeZeroRow [] dim) colN ):matrix) dim (colN+1)\r\n\r\n\r\n\r\n\r\n\r\nputUnit temp (l:list) k = if k==1 then (temp++list) else putUnit (0:temp) list (k-1)\r\n\r\n\r\n\r\n\r\n\r\nmakeZeroRow list n = if length  list ==n then list else makeZeroRow (0:list) n\r\n\r\n\r\n\r\nf[] ys = ys\r\n\r\nf(x:xs) ys = f xs (x:ys) \r\n','<br/>Тесты успешно пройдены!'),(5657,41,'62628590','2013-09-29 14:49:19',1,'countOdd (xs) = foldr (x res -> if (mod x 2==1) then res+1 else res) 0 xs\r\n\r\ncountOdd1 xs = length (xs) - length (filter (even) xs)','<br/>Тесты успешно пройдены!'),(5650,42,'284427','2013-09-29 13:00:32',1,'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs \r\n','<br/>Тесты успешно пройдены!'),(5651,52,'nomeansno','2013-09-29 13:19:30',1,'repeatFunc f n = foldr (.) (x -> x) s\r\n\r\n where s = map (x -> f) [1..n] \r\n','<br/>Тесты успешно пройдены!'),(5652,51,'284427','2013-09-29 13:34:16',1,'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n-1))  \r\n','<br/>Тесты успешно пройдены!'),(5653,52,'284427','2013-09-29 13:39:19',0,'repeatFunc1 f n = foldr (.) f (map (i -> f) [1..(n-1)])\n','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(5654,52,'284427','2013-09-29 13:39:57',0,'repeatFunc1 f n = foldr (.) f (map (i -> f) [1..(n-1)])\n','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(5655,52,'284427','2013-09-29 13:40:49',1,'repeatFunc f n = foldr (.) f (map (i -> f) [1..(n-1)])\r\n','<br/>Тесты успешно пройдены!'),(5656,40,'62628590','2013-09-29 13:59:10',1,'identity n = map (i -> map (j -> if (i==j) then 1 else 0) [1..n]) [1..n]','<br/>Тесты успешно пройдены!'),(5645,128,'115753099','2013-09-29 12:16:57',1,'    class Program\r\n    {\r\n        static Func<int, Func<int, bool>> CheckDigitCurried = (x => (n =>\r\n        { while (n != 0) { if (n % 10 == x) { return true; } else n = n / 10; } return false; }));\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(CheckDigitCurried(4)(45));\r\n            int [] mas = new int[]{4,14,54};\r\n            Console.WriteLine(mas.All(CheckDigitCurried(4)));\r\n        }\r\n    }','<br/>Тесты успешно пройдены!'),(5646,40,'284427','2013-09-29 12:25:41',0,'','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5647,40,'284427','2013-09-29 12:26:01',0,'identity n = id1 n n []\r\n\n\r\n\nid1 n m xs = \r\n\n	if (m >= 1) \r\n\n	then  id1 n (m-1) ((id2 m n []):xs)\r\n\n	else xs\r\n\n	\r\n\nid2 n m xs = \r\n\n	if (m >= 1)\r\n\n	then if (m == n) \r\n\n		 then id2 n (m-1) (1:xs)\r\n\n		 else id2 n (m-1) (0:xs)\r\n\n	else xs\n','<br/>Тесты успешно пройдены!'),(5648,40,'284427','2013-09-29 12:33:33',1,'identity n = map (i -> map (c -> if (c==i) then 1 else 0) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5649,41,'284427','2013-09-29 12:45:56',1,'countOdd xs = foldr (x e -> if(x `mod` 2 == 1) then e+1 else e) 0 xs\r\n\r\ncountOdd1 xs = length (filter test xs)\r\n\r\n\r\n\r\ntest x = if (x `mod` 2 == 1) then True else False\r\n  --- Просто test x = x `mod` 2 == 1\r\n  ---- Мы как раз в прошлый раз про это говорили! :(','<br/>Тесты успешно пройдены!'),(5643,48,'55363692','2013-09-29 11:25:56',1,'myreverse xs = f [] where f = foldr (cur f -> f . (cur:)) id xs\r\n','Не удалось вычислить выражение \"myrevese [True,False]\", проверьте правильность синтаксиса'),(5644,45,'anna','2013-09-29 11:39:41',1,'using System;\r\nusing System.Linq;\r\n\r\n\r\nnamespace ConsoleApplication2\r\n{\r\n    class Program\r\n    {\r\n\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var arr1 = new int[] { 1, 3, 3 };\r\n            var arr2 = new int[] { -4, 5, 6 };\r\n            int[][] a = { arr1, arr2 };\r\n\r\n            var b = a.All(x => x.Any(y => y % 2 == 0));\r\n\r\n            Console.WriteLine(b);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5642,47,'anna','2013-09-29 10:42:14',1,'powerset [] = [[]]\r\n\r\npowerset (x:xs) = powerset xs ++ map (x:)(powerset xs)\r\n','<br/>Тесты успешно пройдены!'),(5639,43,'egeorge','2013-09-29 06:55:11',0,'euclid a b = euclid\' (a, b)\r\n\r\neuclid\' (_, 1) = (0, 1)\r\n\r\neuclid\' (a, b) = f (euclid\' (b, a `mod` b)) (a `div` b)\r\n\r\nf (x, y) z = (y, x - y*z)','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5640,43,'egeorge','2013-09-29 06:56:26',0,'euclid a b = euclid\' (a, b)\r\n\r\neuclid\' (_, 1) = (0, 1)\r\neuclid\' (1, _) = (1, 0)\r\n\r\neuclid\' (a, b) = f (euclid\' (b, a `mod` b)) (a `div` b)\r\n\r\nf (x, y) z = (y, x - y*z)','<br/>Тесты успешно пройдены!'),(5641,43,'egeorge','2013-09-29 06:56:34',1,'euclid a b = euclid\' (a, b)\r\n\r\neuclid\' (_, 1) = (0, 1)\r\neuclid\' (1, _) = (1, 0)\r\n\r\neuclid\' (a, b) = f (euclid\' (b, a `mod` b)) (a `div` b)\r\n\r\nf (x, y) z = (y, x - y*z)','<br/>Тесты успешно пройдены!'),(5637,43,'egeorge','2013-09-29 06:37:28',0,'euclid (_, 1) = (0, 1)\r\n\r\neuclid (a, b) = f (euclid (b, a `mod` b)) (a `div` b)\r\n\r\nf (x, y) z = (y, x - y*z)','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5638,43,'egeorge','2013-09-29 06:38:59',0,'euclid a b = euclid`(a, b)\r\n\r\neuclid` (_, 1) = (0, 1)\r\n\r\neuclid` (a, b) = f (euclid (b, a `mod` b)) (a `div` b)\r\n\r\nf (x, y) z = (y, x - y*z)','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5634,52,'nomeansno','2013-09-29 00:01:11',2,'--- Очень хорошо, идея совершенно праввильная.\r\n--- Но в makelist используется рекурсивная функция, и это не по условию.\r\n--- Те надо как-то записать makelist без рекурсии\r\n--- Попробуйте, пожалуйста.\r\n--- (Если хотите, могу немного подсказать, но вообще это просто).\r\nmakelist f 0 = []\r\n\r\nmakelist f n = f:makelist f (n-1)\r\n\r\n\r\n\r\nrepeatFunc f n = foldr (.) (x -> x) (makelist f n) \r\n','<br/>Тесты успешно пройдены!'),(5635,51,'nomeansno','2013-09-29 00:03:15',1,'makelist f 0 = []\r\n\r\nmakelist f n = f:makelist f (n-1)\r\n\r\n\r\n\r\nrepeatFunc f n = foldr (.) (x -> x) (makelist f n) \r\n','<br/>Тесты успешно пройдены!'),(5636,128,'SNNatalieS','2013-09-29 02:28:29',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _8_1\r\n{\r\n    class Program\r\n    {\r\n        static bool CheckDigit(int n, int t)\r\n        {\r\n            bool b = false;\r\n            while (n > 0)\r\n            {\r\n                if (n % 10 == t)\r\n                {\r\n                    b = true;\r\n                    break;\r\n                }\r\n                else n = n / 10;\r\n            }\r\n            return b;\r\n        }\r\n        static Func<int, bool> CheckDigitCurried(int t)\r\n        {\r\n            return (x => CheckDigit(x, t));\r\n               \r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int[] a = new int[3] { 345, 4632, 764 };\r\n            bool b = a.All(CheckDigitCurried(5));\r\n            Console.WriteLine(b);\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5632,43,'SNNatalieS','2013-09-28 23:32:40',1,'euclid 0 _ = (0, 1)\r\neuclid a b = let (x1, y1) = euclid (mod b a) a\r\n				in (y1 - (div b a) * x1, x1)','<br/>Тесты успешно пройдены!'),(5633,52,'nomeansno','2013-09-29 00:00:03',0,'--composition f g = f g \r\n\n\r\n\nide x = x + 1\r\n\n\r\n\nf (x:xs) = x 5 \r\n\n\r\n\n\r\n\n\r\n\nmakelist f 0 = []\r\n\nmakelist f n = f:makelist f (n-1)\r\n\n\r\n\nrepeatFunc f n = foldr (.) (x -> x) (makelist f n) \n','<br/>Тесты успешно пройдены!'),(5629,51,'anna','2013-09-28 23:16:29',1,'repeatFunc f n = foldr (\\_ f\' -> f.f\') f [1..(n-1)]\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5630,52,'anna','2013-09-28 23:19:39',1,'repeatFunc f n = foldr (\\_ f\' -> f.f\') f [1..(n-1)]\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5631,42,'nomeansno','2013-09-28 23:21:32',1,'myfoldl _ result [] = result\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs    \r\n','<br/>Тесты успешно пройдены!'),(5627,41,'nomeansno','2013-09-28 22:58:23',1,'countOdd s = foldr (+) 0 (map (x -> if x `mod` 2 == 1 then 1 else 0) s)\r\n\r\n\r\n\r\ncountOdd1 s = length (filter (x -> x `mod` 2 == 1) s)\r\n','<br/>Тесты успешно пройдены!'),(5628,45,'SNNatalieS','2013-09-28 23:09:54',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _8_1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] numbers = new int[2][] { new int[] { 4, 7}, new int[] { 5, 7, 9, 8 } };\r\n            bool b = numbers.All(x => x.Any(r => (r % 2 == 0)));\r\n            Console.WriteLine(b);\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5603,41,'55363692','2013-09-28 19:26:08',1,'countOdd = foldr (x cnt -> if (x `mod` 2 == 1) then cnt + 1 else cnt) 0\r\n\r\n\r\n\r\ncountOdd1 = sum . map (x -> if (x `mod` 2 == 1) then 1 else 0)\r\n','<br/>Тесты успешно пройдены!'),(5604,42,'55363692','2013-09-28 19:34:27',0,'myfoldl f e xs = foldr f e (reverse xs)\n','Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),(5605,48,'5543298','2013-09-28 19:39:20',1,'myreverse\' xs = foldr (x changeOrderFunc -> changeOrderFunc.(ys -> x:ys)) id xs\r\n   --- Вместо (ys -> x:ys) можно короче написать (x:)\r\nmyreverse xs = myreverse\' xs []','<br/>Тесты успешно пройдены!'),(5606,40,'SNNatalieS','2013-09-28 19:42:18',1,'identity n = g n n\r\ng h 0 = []\r\ng n m = (map (i -> if i == (n - m + 1) then 1 else 0) [1 .. n]) : (g n (m - 1))','<br/>Тесты успешно пройдены!'),(5607,42,'55363692','2013-09-28 19:42:34',1,'myfoldl f e xs = myfoldl\' f e xs\r\n\r\nmyfoldl\' f acc [] = acc\r\n\r\nmyfoldl\' f acc (x:xs) = myfoldl\' f (f acc x) xs\r\n','<br/>Тесты успешно пройдены!'),(5608,51,'55363692','2013-09-28 19:48:53',0,'repeatFunc f n = f . repeatFunc f (n - 1) \n','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5609,51,'55363692','2013-09-28 19:50:36',1,'repeatFunc f n = if n == 1 then f else f . repeatFunc f (n - 1) \r\n','<br/>Тесты успешно пройдены!'),(5610,41,'SNNatalieS','2013-09-28 20:03:42',1,'countOdd xs = foldr (i e -> e + (mod i 2)) 0 xs\r\ncountOdd1 r = sum (map (i -> mod i 2) r)','<br/>Тесты успешно пройдены!'),(5611,52,'55363692','2013-09-28 20:07:49',1,'repeatFunc f n = foldr (.) id (replicate n f)\r\n','<br/>Тесты успешно пройдены!'),(5612,42,'SNNatalieS','2013-09-28 20:13:36',0,'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (f x e) xs','Выражение имеет неправильное значение: myfoldl (^) 2 [3]'),(5613,42,'SNNatalieS','2013-09-28 20:15:40',1,'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs','<br/>Тесты успешно пройдены!'),(5614,47,'55363692','2013-09-28 20:18:48',0,'powerset\' set [] = [set]\r\n\npowerset\' set (x:xs) = powerset\' (x:set) xs ++ (powerset\' set xs)\r\n\npowerset xs = powerset\' [] xs\n','Выражение имеет неправильное значение: elem [1,3] (powerset [1,2,3])'),(5615,47,'55363692','2013-09-28 20:20:54',1,'powerset\' set [] = [set]\r\n\r\npowerset\' set (x:xs) = powerset\' (set ++ [x]) xs ++ (powerset\' set xs)\r\n\r\npowerset xs = powerset\' [] xs\r\n','<br/>Тесты успешно пройдены!'),(5616,128,'romos2007','2013-09-28 20:32:30',1,'﻿/*\r\n\r\n * Задача 11-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n */\r\n\r\n\r\n\r\nusing System;\r\n\r\n\r\n\r\nnamespace _11_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static Func<int,bool> CheckDigitCurried(int i)\r\n\r\n        {\r\n\r\n            return n => Convert.ToString(i).Contains(Convert.ToString(n));\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int where = 1234567890; // число, в котором искать подпоследовательность\r\n\r\n            string what = Console.ReadLine();  // считываем с клавиатуры число, которое ищем\r\n\r\n            int what_int = 0;\r\n\r\n            \r\n\r\n            while (what != \"\")\r\n\r\n            {\r\n\r\n                what_int = Convert.ToInt32(what);\r\n\r\n                Console.WriteLine(CheckDigitCurried(where)(what_int));\r\n\r\n                what = Console.ReadLine();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5617,51,'SNNatalieS','2013-09-28 20:40:31',1,'repeatFunc f 0 = id\r\nrepeatFunc f n = f.(repeatFunc f (n - 1))','<br/>Тесты успешно пройдены!'),(5618,52,'SNNatalieS','2013-09-28 20:50:22',1,'repeatFunc f n = foldl (.) id (map (i -> f) [1 .. n])','<br/>Тесты успешно пройдены!'),(5619,48,'55363692','2013-09-28 21:26:58',2,'--- ваше решение предполагает, что элементы - целые числа, но это\r\n--- ведь может быть и не так.\r\n--- Например, вызов мб myreverse [True,False]\r\n--- Попробуйте исправить, пожалуйста (а я сейчас добавлю такой тест) \r\nmyreverse xs = [f(i) | i <- [1..f(0)]] where \r\n\r\n	f = foldr (\r\n\r\n		cur f -> \r\n\r\n			let \r\n\r\n				len = 1 + f 0\r\n\r\n				g x = \r\n\r\n					if (x == 0) then len\r\n\r\n					else if (x == len) then cur\r\n\r\n					else f x\r\n\r\n			in g\r\n\r\n		) id xs\r\n','<br/>Тесты успешно пройдены!'),(5620,128,'55363692','2013-09-28 21:41:03',1,'﻿using System;\r\n\r\nusing System.Globalization;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static bool CheckDigit(char digit, int a)\r\n\r\n        {\r\n\r\n            return a.ToString(CultureInfo.InvariantCulture).ToCharArray().Contains(digit);\r\n\r\n        }\r\n\r\n\r\n\r\n        private static Func<int, bool> CheckDigitCurried(char digit)\r\n\r\n        {\r\n\r\n            return (x => CheckDigit(digit, x));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            var a = new[] {7, 17, 67};\r\n\r\n\r\n\r\n            Console.WriteLine(a.All(i => CheckDigit(\'7\', i)));\r\n\r\n            Console.WriteLine(a.All(CheckDigitCurried(\'7\')));\r\n\r\n            Console.WriteLine(CheckDigitCurried(\'7\')(1));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5621,42,'anna','2013-09-28 21:43:40',1,'myfoldl f y []      = y\r\n\r\nmyfoldl f y (x:xs)  = myfoldl f (f y x) xs \r\n\r\n                  \r\n','<br/>Тесты успешно пройдены!'),(5622,40,'nomeansno','2013-09-28 22:21:35',0,'','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5623,40,'nomeansno','2013-09-28 22:21:54',1,'makefirst 0 = []\r\n\r\nmakefirst n = 0:makefirst (n-1)\r\n\r\n\r\n\r\nmakeonelist [] _ result = result\r\n\r\nmakeonelist (x:first) second result = makeonelist first (0:second) (l:result)\r\n\r\n where l = first ++ (1:second)\r\n\r\n\r\n\r\nidentity n = makeonelist (makefirst n) [] []\r\n','<br/>Тесты успешно пройдены!'),(5624,30,'6053606','2013-09-28 22:25:33',2,' --- Вообще почти правильно, но вот пример, когда у вас неверные ответы\r\n --- parts ([1..6]++[1..10]++[1..15])\r\n --- Исправьте пожалуйста (желательно до начала пары)\r\n --- А я сейчас добавлю такой тест\r\nparts xs = and [gcd n m >= 2 | n <- ls, m <- ls, m < n] where\r\n  ls = go [1] $ zip xs $ tail xs\r\n  go acc [] = acc\r\n  go (c:acc) ((x, y):xs) = if x < y\r\n                           then go (c + 1:acc) xs\r\n                           else go (1:c:acc) xs\r\n','<br/>Тесты успешно пройдены!'),(5625,40,'anna','2013-09-28 22:39:50',1,'identity n =\r\n\r\n  let\r\n\r\n    foo k = map (	 -> if t == k then 1 else 0) [1..n]\r\n\r\n    in map (k -> foo k )[1..n] \r\n','<br/>Тесты успешно пройдены!'),(5626,41,'anna','2013-09-28 22:54:47',1,'countOdd xs = foldr (x y -> if mod x 2 == 1 then y + 1 else y) 0 xs\r\n\r\n\r\n\r\ncountOdd1 xs = sum (map (x -> mod x 2) xs)\r\n','<br/>Тесты успешно пройдены!'),(5602,128,'toskira','2013-09-28 19:21:08',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace _11_1 {\r\n\r\n	class Program {\r\n\r\n		static Func<int, Func<int, bool>> CheckDigitCurried = digit => n => {\r\n			bool result = false;\r\n			while (n != 0) {\r\n				result |= (n % 10) == digit;\r\n				n /= 10;\r\n			}\r\n			return result;\r\n		};\r\n\r\n		static void Main(string[] args) {\r\n			int[] a = { 7, 5678 };\r\n			int[] b = { 67, 23, 78 };\r\n			Console.WriteLine(a.All(CheckDigitCurried(7)));\r\n			Console.WriteLine(b.All(CheckDigitCurried(7)));\r\n			Console.WriteLine(CheckDigitCurried(1)(123));\r\n			Console.WriteLine(CheckDigitCurried(1)(678));\r\n			Console.ReadKey();\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(5601,44,'toskira','2013-09-28 18:32:34',1,'dioph l1 l2 = let (e1, e2) = preprocess l1 l2\r\n\r\n                  b = build_basis e1\r\n\r\n                  e = get_elements b e2\r\n\r\n                  c = solve e (((_,_,_,n) -> n) e2)\r\n\r\n              in  ((a,b,c) -> a:b:c:[]) (foldr (((x,y,z),c) (x\',y\',z\') -> (x\'+x*c,y\'+y*c,z\'+z*c)) (0,0,0) (zip b c))\r\n\r\n\r\n\r\npreprocess (a:b:c:0:[]) (k:l:m:n:[]) = ((a,b,c), (k,l,m,n))\r\n\r\npreprocess (a:b:c:d:[]) (k:l:m:0:[]) = ((k,l,m), (a,b,c,d))\r\n\r\npreprocess (a:b:c:d:[]) (k:l:m:n:[]) = ((a*n-k*d, b*n-l*d, c*n-m*d), (k,l,m,n))\r\n\r\n\r\n\r\nbuild_basis (0,0,0) = (1,0,0):(0,1,0):(0,0,1):[]\r\n\r\nbuild_basis (_,0,0) = (0,1,0):(0,0,1):[]\r\n\r\nbuild_basis (0,_,0) = (1,0,0):(0,0,1):[]\r\n\r\nbuild_basis (0,0,_) = (1,0,0):(0,1,0):[]\r\n\r\nbuild_basis (0,b,c) = let t  = gcd b c in (1,0,0):(0,-(div c t),div b t):[]\r\n\r\nbuild_basis (a,0,c) = let t  = gcd a c in (0,1,0):(-(div c t),0,div a t):[]\r\n\r\nbuild_basis (a,b,0) = let t  = gcd a b in (0,0,1):(-(div b t),div a t,0):[]\r\n\r\nbuild_basis (a,b,c) = let t1 = gcd b c\r\n\r\n                          t2 = gcd a c\r\n\r\n                          t3 = gcd a b\r\n\r\n                      in  (0,-(div c t1),div b t1):(-(div c t2),0,div a t2):(-(div b t3),div a t3,0):[]\r\n\r\n\r\n\r\nget_elements basis (k,l,m,_) = map ((x, y, z) -> k*x+l*y+m*z) basis\r\n\r\n\r\n\r\neuclid 0 (-1) = (0, -1)\r\n\r\neuclid 0 1 = (0, 1)\r\n\r\neuclid a b = let r = mod b a\r\n\r\n                 q = div b a\r\n\r\n                 (a\', b\') = euclid r a\r\n\r\n             in  (b\' - q * a\', a\')\r\n\r\n\r\n\r\neuclid\' a b = let g = gcd a b in  euclid (div a g) (div b g)\r\n\r\n\r\n\r\nsolve (e1:e2:[])    n = let (p, q) = euclid\' e1 e2\r\n\r\n                            m = div n (gcd e1 e2)\r\n\r\n                        in  (p*m):(q*m):[]\r\n\r\nsolve (e1:e2:e3:[]) n = let (p, q) = euclid\' e1 e2\r\n\r\n                            (s, t) = euclid\' (gcd e1 e2) e3\r\n\r\n                            m = div n (gcd (gcd e1 e2) e3)\r\n\r\n                        in (p*s*m):(q*s*m):(t*m):(p):(q):[]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5595,128,'115753099','2013-09-28 18:01:39',2,'--- Для всех задач на C# ответом должна быть программа на C# целиком, так чтобы ее можно было сомпилировать и с примерами вызова\r\n--- Я нисколько не сомневаюсь, что вы можете написать такую программу, но все-таки, поскольку требования\r\n--- для всех одинаковые, пришлите ее пожалуйста. \r\nFunc<int, Func<int, bool>> CheckDigitCurried = (x => (n =>\r\n                { while (n != 0) { if (n % 10 == x) { return true; } else n = n / 10; } return false; }));','<br/>Тесты успешно пройдены!'),(5596,128,'5543298','2013-09-28 18:03:22',1,'namespace FunctionalTasks\r\n{\r\n    internal class Program\r\n    {\r\n        private static void Main(string[] args)\r\n        {\r\n            var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n            var test2 = new[] { 5017, 1001, 337, 174 };\r\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\r\nConsole.WriteLine(\"Press any key to exit...\");\r\n            Console.ReadKey();\r\n        }\r\n\r\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n        {\r\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5597,40,'55363692','2013-09-28 18:06:56',1,'identity n = [ [if (i == j) then 1 else 0 | j <- [1..n]] | i <- [1..n]]\r\n','<br/>Тесты успешно пройдены!'),(5598,52,'3226573','2013-09-28 18:07:02',1,'funcList f n = foldr (x res -> (f:res)) [] [1..n]\r\nrepeatFunc f n = foldr (.) (x -> x) (funcList f n)','<br/>Тесты успешно пройдены!'),(5599,128,'3226573','2013-09-28 18:08:55',2,'  --- Извините, в условиях была опечатка:( Это решения может быть засчитано за решение 9.4\r\n  --- А для 11.1 надо, конечно, отдельное решение. Извините, пожалуйста, за недоразумение.     \r\n-- Решение из задачи 9.5\r\nfuncList f n = foldr (x res -> (f:res)) [] [1..n]\r\nrepeatFunc f n = foldr (.) (x -> x) (funcList f n)','<br/>Тесты успешно пройдены!'),(5600,44,'toskira','2013-09-28 18:28:54',0,'dioph l1 l2 = let (e1, e2) = preprocess l1 l2\r\n\n                  b = build_basis e1\r\n\n                  e = get_elements b e2\r\n\n                  c = solve e (((_,_,_,n) -> n) e2)\r\n\n              in  ((a,b,c) -> a:b:c:[]) (foldr (((x,y,z),c) (x\',y\',z\') -> (x\'+x*c,y\'+y*c,z\'+z*c)) (0,0,0) (zip b c))\r\n\n\r\n\npreprocess (a:b:c:0:[]) (k:l:m:n:[]) = ((a,b,c), (k,l,m,n))                                   \r\n\npreprocess (a:b:c:d:[]) (k:l:m:0:[]) = ((k,l,m), (a,b,c,d))                                   \r\n\npreprocess (a:b:c:d:[]) (k:l:m:n:[]) = ((a*n-k*d, b*n-l*d, c*n-m*d), (k,l,m,n))               \r\n\n                                                                                              \r\n\nbuild_basis (0,0,0) = (1,0,0):(0,1,0):(0,0,1):[]                                              \r\n\nbuild_basis (_,0,0) = (0,1,0):(0,0,1):[]                                            \r\n\nbuild_basis (0,_,0) = (1,0,0):(0,0,1):[]                                            \r\n\nbuild_basis (0,0,_) = (1,0,0):(0,1,0):[]                                            \r\n\nbuild_basis (0,b,c) = let t  = gcd b c in (1,0,0):(0,div c t,div b t):[]            \r\n\nbuild_basis (a,0,c) = let t  = gcd a c in (0,1,0):(div c t,0,div a t):[]            \r\n\nbuild_basis (a,b,0) = let t  = gcd a b in (0,0,1):(div b t,div a t,0):[]            \r\n\nbuild_basis (a,b,c) = let t1 = gcd b c                                                        \r\n\n                          t2 = gcd a c                                                        \r\n\n                          t3 = gcd a b                                                        \r\n\n                      in  (0,-(div c t1),div b t1):(-(div c t2),0,div a t2):(-(div b t3),div a t3,0):[]                                                                                     \r\n\n                                                                                              \r\n\nget_elements basis (k,l,m,_) = map ((x, y, z) -> k*x+l*y+m*z) basis                          \r\n\n\r\n\neuclid 0 (-1) = (0, -1)\r\n\neuclid 0 1 = (0, 1)\r\n\neuclid a b = let r = mod b a\r\n\n                 q = div b a\r\n\n                 (a\', b\') = euclid r a\r\n\n             in  (b\' - q * a\', a\')\r\n\n\r\n\neuclid\' a b = let g = gcd a b in euclid (div a g) (div b g)\r\n\n\r\n\nsolve (e1:e2:[])    n = let (p, q) = euclid\' e1 e2\r\n\n                            m = div n (gcd e1 e2)\r\n\n                        in  (p*m):(q*m):[]\r\n\nsolve (e1:e2:e3:[]) n = let (p, q) = euclid\' e1 e2\r\n\n                            (s, t) = euclid\' (gcd e1 e2) e3\r\n\n                            m = div n (gcd (gcd e1 e2) e3)\r\n\n                        in (p*s*m):(q*s*m):(t*m):(p):(q):[]\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)'),(5592,42,'3226573','2013-09-28 17:34:36',1,'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs','<br/>Тесты успешно пройдены!'),(5593,51,'3226573','2013-09-28 17:52:12',1,'repeatFunc f 1 = f\r\nrepeatFunc f n = f . repeatFunc f (n - 1)','<br/>Тесты успешно пройдены!'),(5594,128,'5543298','2013-09-28 17:59:43',0,'﻿using System;\r\n\nusing System.Collections.Generic;\r\n\nusing System.Linq;\r\n\n\r\n\nnamespace FunctionalTasks\r\n\n{\r\n\n    internal class Program\r\n\n    {\r\n\n        private static void Main(string[] args)\r\n\n        {\r\n\n            if (args.Length < 1)\r\n\n            {\r\n\n                Console.WriteLine(\"Invalid task name parametr. \nPress any key to exit...\");\r\n\n                Console.ReadKey();\r\n\n                return;\r\n\n            }\r\n\n            switch (args[0])\r\n\n            {\r\n\n                case \"11.1\":\r\n\n                    {\r\n\n                        var test1 = new[] { 17, 57, 7, 97, 5007 };\r\n\n                        var test2 = new[] { 5017, 1001, 337, 174 };\r\n\n                        Console.WriteLine(test1.All(CheckDigitCurried(7)));\r\n\n                        Console.WriteLine(test2.All(CheckDigitCurried(7)));\r\n\n                        Console.WriteLine(CheckDigitCurried(7)(1001));\r\n\n                        Console.WriteLine(CheckDigitCurried(7)(5017));\r\n\n                        break;\r\n\n                    }\r\n\n                case \"8.1\":\r\n\n                    {\r\n\n                        var test = new List<List<int>>\r\n\n                                        {\r\n\n                                            new List<int> {1, 2, 3},\r\n\n                                            new List<int> {1, 5, 7, 9, 500},\r\n\n                                            new List<int> {501, 1001, 33, 14},\r\n\n                                            //Раскомментировать, чтоб было False\r\n\n                                            //new List<int> {37, 47, 15},\r\n\n                                        };\r\n\n                        Console.WriteLine(Check_8_1(test));\r\n\n                        break;\r\n\n                    }\r\n\n                case \"5.1\":\r\n\n                    {\r\n\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Exp(x), 0, 1, 100));\r\n\n                        Console.WriteLine(Intgrate_5_1(x => (float) Math.Sin(x), 0, 1, 100));\r\n\n                        break;\r\n\n                    }\r\n\n                default:\r\n\n                    Console.WriteLine(\"Unknow task name.\");\r\n\n                    break;\r\n\n            }\r\n\n            Console.WriteLine(\"Press any key to exit...\");\r\n\n            Console.ReadKey();\r\n\n        }\r\n\n\r\n\n        private static Func<int, bool> CheckDigitCurried(int pattern)\r\n\n        {\r\n\n            return arg => arg.ToString().Contains(pattern.ToString());\r\n\n        }\r\n\n\r\n\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\n        {\r\n\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\n        }\r\n\n\r\n\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\n        {\r\n\n            float result = 0;\r\n\n            float step = (b - a)/steps;\r\n\n            for (var point = a; point < b; point += step)\r\n\n            {\r\n\n                result += step*(func(point) + func(point + step))/2;\r\n\n            }\r\n\n            return result;\r\n\n        }\r\n\n    }\r\n\n}\r\n\n\n','<br/>Тесты успешно пройдены!'),(5587,40,'3226573','2013-09-28 16:10:17',0,'identityLine n i = foldl (x res -> if x == i then 1:res else 0:res) [] [1..n]\r\nidentity n = foldl (:) [] (map (identityLine n) [1..n])','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5588,40,'3226573','2013-09-28 16:23:16',1,'identityLine n i = foldr (x res -> if x == i then (1:res) else (0:res)) [] [1..n]\r\nidentity n = map (identityLine n) [1..n]','<br/>Тесты успешно пройдены!'),(5589,41,'3226573','2013-09-28 16:57:30',1,'-- Надеюсь, в countOdd допустимо использование функции \'mod\'\r\ncountOdd xs = foldr (x res -> if mod x 2 == 1 then res + 1 else res) 0 xs\r\ncountOdd1 xs = length (filter (x -> mod x 2 == 1) xs)','<br/>Тесты успешно пройдены!'),(5590,42,'3226573','2013-09-28 17:03:31',0,'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = f (myfoldl f e xs) x','Выражение имеет неправильное значение: let f x y = 2*x+y in myfoldl f 2 [3,5]'),(5591,42,'3226573','2013-09-28 17:18:00',0,'myfoldl f e [] = e\r\nmyfoldl f e (x:xs) = f (myfoldl f e xs) x','Выражение имеет неправильное значение: let f x y = 2*x+y in myfoldl f 2 [3,5]'),(5586,128,'anlun','2013-09-28 15:06:49',1,'#include <iostream> \r\n\r\n#include <vector> \r\n\r\n#include <algorithm>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nbool checkDigit(int digit, int num) {\r\n\r\n	while (num > 0) {\r\n\r\n		int curDigit = num % 10;\r\n\r\n		if (curDigit == digit) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		num /= 10;\r\n\r\n	}\r\n\r\n	return false;\r\n\r\n}\r\n\r\n\r\n\r\nfunction<bool (int)> checkDigitCurried(int digit) {\r\n\r\n	return [digit](int num) {\r\n\r\n		return checkDigit(digit, num);\r\n\r\n	};\r\n\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n	auto f5 = checkDigitCurried(5);\r\n\r\n	cout << f5(10) << endl;\r\n\r\n	cout << checkDigitCurried(7)(1710) << endl;\r\n\r\n\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5582,51,'54411321','2013-09-28 02:31:13',1,'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n-1))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5583,52,'54411321','2013-09-28 02:42:07',1,'repeatFunc f n = foldr (x res -> f.res) f [1..n-1]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5584,48,'115753099','2013-09-28 10:10:21',1,'myreverse xs = foldr f id xs [] where f x g = g . (x:)','<br/>Тесты успешно пройдены!'),(5585,43,'anna','2013-09-28 15:03:58',1,'euclid a b = if b == 0 then (1,0)\r\n\r\n                 else let (x,y) = euclid b (mod a b)\r\n\r\n                       in (y, x - (div a b)*y)				 \r\n\r\n\r\n\r\n					\r\n\r\n\r\n\r\n              \r\n\r\n                                     \r\n\r\n                    \r\n','<br/>Тесты успешно пройдены!'),(5580,42,'54411321','2013-09-28 02:08:13',1,'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5581,128,'15309342','2013-09-28 02:16:52',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n\r\nnamespace FP_homework\r\n{\r\n    class Tas11_1\r\n    {\r\n        static Func<int, bool> CheckDigitCurried(int digit)\r\n        {\r\n          return (i => digitList(i).Any(a => a == digit)); \r\n        }\r\n        \r\n        static List<int> digitList(int i)\r\n   --- Просто как замечание, тут можно написать IEnumerable<int>\r\n        {\r\n            List<int> list = new List<int>();\r\n            while(i > 0)\r\n            {\r\n                list.Add(i % 10);\r\n   --- А тут yield return i%10\r\n   --- И потом точно так же использовать Any \r\n                i = i / 10;\r\n            }\r\n            return list;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[] testArray = {1, 2, 3, 4, 5, 6, 7};\r\n            bool result = testArray.Any(CheckDigitCurried(7));\r\n            Console.WriteLine(result);\r\n            result = CheckDigitCurried(7)(12345);\r\n            Console.WriteLine(result);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5577,40,'54411321','2013-09-28 00:25:26',1,'identity n = map (i -> map (j -> if i == j then 1 else 0) [1..n]) [1..n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5578,41,'54411321','2013-09-28 00:45:53',1,'countOdd l = foldr (x res -> if x `mod` 2 /= 0 then res + 1 else res) 0 l\r\n\r\n\r\n\r\ncountOdd1 l = foldl (\r\nes x -> if x `mod` 2 /= 0 then res + 1 else res) 0 l\r\n','<br/>Тесты успешно пройдены!'),(5579,128,'deripaska','2013-09-28 01:13:10',1,'/* \r\n\r\n    task 11-01\r\n\r\n*Простая задача про карринг на C#. Дополнительная, до 11.10*\r\n\r\nВступительная история:\r\n\r\nПусть у нас есть знакомый программист Василий, которому часто надо для списков целых положительных чисел проверять, верно ли, что все они содержат какую-то данную цифру. Т.е. типичная задача Василия - что-то вроде:\r\n\r\nПроверить, верно ли что в массиве a все числа содержат цифру 7.\r\n\r\nВасилий написал вспомогательную функцию CheckDigit c параметрами a - цифра, которую мы ищем и i - целое число. И вызывает ее как-то так:\r\n\r\n\r\n\r\nbool b = a.Any(i => CheckDigit(7, i));\r\n\r\nНо однажды у нему пришел его друг, функциональный программист Петр, и сказал: ты же можешь воспользоваться каррингом! И написать функцию CheckDigitCurried, которую можно вызывать как-то так:\r\n\r\nbool b = a.Any(CheckDigitCurried(7));\r\n\r\nТ.е. будет немного короче. А если потребуется проверить одно конкретное число, ее можно будет вызвать как-то так:\r\n\r\nbool b = CheckDigitCurried(7)(n); // Проверить , есть ли в числe n цифра 7\r\n\r\n\r\n\r\nЗадача:\r\n\r\nПомогите Василию, и напишите функцию CheckDigitCurried, которую можно так вызывать. \r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Task_11_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static Func<int, Func<int, bool>> CheckDigitCurried = i => { return new Func<int, bool>(n => n.ToString().Contains(i.ToString())); };\r\n\r\n        //static Func<int, int, bool> CheckDigit = (i, n) => { return n.ToString().Contains(i.ToString()); };\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int n1 = 17;\r\n\r\n            int n2 = 23;\r\n\r\n            int[] mas1 = new int[] { 72, 27, 317 };\r\n\r\n            int[] mas2 = new int[] { 22, 25, 31 };\r\n\r\n\r\n\r\n            bool b1 = mas1.Any(CheckDigitCurried(7)); //true\r\n\r\n            bool b2 = mas2.Any(CheckDigitCurried(7)); //false\r\n\r\n            bool b3 = CheckDigitCurried(7)(n1); //true\r\n\r\n            bool b4 = CheckDigitCurried(7)(n2); //false\r\n\r\n\r\n\r\n            Console.WriteLine(b1 + \"  \" + b2 + \"  \" + b3 + \"  \" + b4);\r\n\r\n\r\n\r\n            Console.Read();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5576,33,'480387','2013-09-27 23:39:59',1,'        static double integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double d = (b - a) / 5000, S = 0, x1 = a , x2 = x1 + d ;\r\n\r\n            for (int i = 0; i < 5000; i++)\r\n            {\r\n                S += d * (f(x1) + f(x2)) / 2;\r\n                x1 += d;\r\n                x2 += d;\r\n            }\r\n            return S;\r\n        }\r\n','<br/>Тесты успешно пройдены!'),(5574,47,'115753099','2013-09-27 22:42:42',1,'powerset2 [] = []\r\npowerset2 (x:xs) =\r\n	(map (y -> x:y) (powerset2 xs)) ++  ([x] : powerset2(xs))\r\n\r\npowerset xs = [] : (powerset2 xs)','<br/>Тесты успешно пройдены!'),(5575,48,'115753099','2013-09-27 22:42:56',2,'myreverse xs =\r\n	foldr (x ys-> ys ++ [x]) [] xs\r\n  --- Посмотрите условие внимательно, пожалуйста. Там написано, что ++ использовать нельзя..','<br/>Тесты успешно пройдены!'),(5571,42,'3270666','2013-09-27 20:50:48',1,'myfoldl op res [] = res\r\nmyfoldl op res [x] = res `op` x\r\nmyfoldl op res (x:xs) = myfoldl op (op res x) xs','<br/>Тесты успешно пройдены!'),(5572,33,'nomeansno','2013-09-27 21:25:01',0,'#include <iostream>\n\n#include <functional>\n\nusing namespace std;\n\n\n\nconst int n = 100;\n\n\n\ndouble sum(double a, double b, function<double (double)> term, \n\nfunction<double (double)> next) {\n\n	if (a>b)\n\n		return 0;\n\n	else \n\n		return term(a) + sum(next(a),b,term,next); \n\n}\n\n\n\ndouble integral(double a, double b, function<double (double)> f) {\n\n	double dx = (b - a) / n;\n\n	return dx * sum(a + dx / 2,b,f, [dx] (double x) {return x + dx;}); \n\n}\n\n\n\nint main() {\n\n	\n\n	cout << integral(0,1,[] (double x) {return x * x * x;});\n\n}\n\n\n','<br/>Тесты успешно пройдены!'),(5573,33,'nomeansno','2013-09-27 21:26:37',1,'#include <iostream>\r\n#include <functional>\r\nusing namespace std;\r\n\r\nconst int n = 100;\r\n\r\ndouble sum(double a, double b, function<double (double)> term,\r\nfunction<double (double)> next) {\r\n        if (a>b)\r\n                return 0;\r\n        else\r\n                return term(a) + sum(next(a),b,term,next);\r\n   --- ОК, но этой задаче можно было и просто написать цикл. Тут не надо было обязательно использовать рекурсию.\r\n}\r\n\r\ndouble integral(double a, double b, function<double (double)> f) {\r\n        double dx = (b - a) / n;\r\n        return dx * sum(a + dx / 2,b,f, [dx] (double x) {return x + dx;});\r\n}\r\n\r\nint main() {\r\n\r\n        cout << integral(0,1,[] (double x) {return x * x * x;});\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5570,48,'15309342','2013-09-27 20:41:26',1,'--используем частичную параметризацию, в результате foldr получаем функцию\r\n--(1 `g` (2 `g` (3 `g` id))) = (1 `g` (2 `g` id(3 : ys))) = (1 `g` (2 `g` (3 : ys))) = (1 `g` (3 : ys)(2 : ys1)) = (1 `g` (3 : 2 : ys1)) = (3 : 2 : ys1)(1 : ys2) = (3 : 2 : 1 : ys2) \r\n-- получилась функция одной переменной, осталось применить ее к пустому списку\r\nmyreverse xs = (foldr (x f ys -> f(x:ys)) id xs) []','<br/>Тесты успешно пройдены!'),(5567,52,'2156724','2013-09-27 19:43:02',1,'repeatFunc f n =  foldr (.) f (map (x-> f) [1..n-1])\r\n\r\ng = repeatFunc (sin) 3\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5568,51,'2156724','2013-09-27 19:59:46',1,'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n-1))\r\n\r\n\r\n\r\nf = repeatFunc (sin) 3\r\n','<br/>Тесты успешно пройдены!'),(5569,48,'deripaska','2013-09-27 20:18:42',1,'{--\r\n\r\n	task 10-02\r\n\r\n*Доп задача*\r\n\r\nИспользуя _только_ функцию foldr и лямбда выражения опишите функцию myreverse, возвращающую элементы списка в обратном порядке.\r\n\r\nПример вызова:\r\n\r\nmyreverse [1, 2, 3]\r\n\r\nРезультат д.б. равен [3, 2, 1].\r\n\r\n\r\n\r\nДополнительные условия:\r\n\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.\r\n\r\n- Функция должна работать за линейное время. Технически это означает, что нельзя использовать операцию ++[x] или каким-то другим способом приписывать очередной элемент к концу списка на каждом шаге работы foldr. \r\n\r\n- Чтобы задача была немного еще посложнее, давайте пусть будет еще дополнительно условие - нельзя использовать пары (tuples). (И соответственно нельзя каким-то образом их имитировать, с помощью списков из двух элементов или data и т.д.)\r\n\r\n--}\r\n\r\n\r\n\r\n--myreverse xs = foldl (\r\nes x -> x:res) [] xs\r\n\r\n--myreverse xs = foldr (x res -> res++[x]) [] xs\r\n\r\n--myreverse xs = map ((y:ys) -> y) (buildTails xs) where buildTails ys = foldr (k res@((y:curTail):tail) -> if curTail /= [] then (curTail:res) else res) [ys] ys\r\n\r\n\r\n\r\nmyreverse xs = foldr ((y:ys) res -> y:res) [] (buildTails xs) \r\n\r\n	where buildTails ys = foldr (k res@((y:curTail):tail) -> if curTail /= [] then (curTail:res) else res) [ys] ys\r\n','<br/>Тесты успешно пройдены!'),(5566,48,'romos2007','2013-09-27 19:31:17',1,'{--\r\n\r\nЗадача 10-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-	Идея представить массив операторами (x:), где x - элемент массива. Т.е. [1,2,3]=((1:).(2:).(3:)) []\r\n\r\nТ.о. надо сформировать операторы в обратном порядке.\r\n\r\nНачать можно с тождественного отображения, которое ничего не поменяет.\r\n\r\n\r\n\r\nТ.е. представим foldr, как цикл с последнего элемента массива [x1,...,xN] к первому.\r\n\r\nНа каждом шаге будем приписывать x (очередной элемент массива) к концу нового массива.\r\n\r\nНо нельзя (++). Тогда делаем так: acc.(x:) - здесь к сформированным элементам добавляем в конец операцию добавления нового эл-та\r\n\r\n\r\n\r\nТ.е. по шагам:\r\n\r\n	(i->i).(xN:) --> (i->i).(x[N]:) .(x[N-1]:) --> ... --> (i->i).(x[N]:). ... .(x[1]:)\r\n\r\n\r\n\r\nОсталось дать этой функции аргумент []\r\n\r\n-}\r\n\r\n\r\n\r\n myreverse xs = (foldr (x acc -> acc.(x:)) (i->i) xs) []\r\n','<br/>Тесты успешно пройдены!'),(5565,48,'romos2007','2013-09-27 19:29:57',0,'{--\r\n\nЗадача 10-2\r\n\nОдеров Роман, 545 гр.\r\n\n--}\r\n\n\r\n\n{-	Идея представить массив операторами (x:), где x - элемент массива. Т.е. [1,2,3]=((1:).(2:).(3:)) []\r\n\nТ.о. надо сформировать операторы в обратном порядке.\r\n\nНачать можно с тождественного отображения, которое ничего не поменяет.\r\n\n\r\n\nТ.е. представим foldr, как цикл с последнего элемента массива [x1,...,xN] к первому.\r\n\nНа каждом шаге будем приписывать x (очередной элемент массива) к концу нового массива.\r\n\nНо нельзя (++). Тогда делаем так: acc.(x:) - здесь к сформированным элементам добавляем в конец операцию добавления нового эл-та\r\n\n\r\n\nТ.е. по шагам:\r\n\n	(i->i).(xN:) --> (i->i).(x[N]:) .(x[N-1]:) --> ... --> (i->i).(x[N]:). ... .(x[1]:)\r\n\n\r\n\nОсталось дать этой функции аргумент []\r\n\n-}\r\n\n\r\n\nrev xs = (foldr (x acc -> acc.(x:)) (i->i) xs) []\n','Не удалось вычислить выражение \"myreverse [1,2,3,4]\", проверьте правильность синтаксиса'),(5563,44,'toskira','2013-09-27 19:09:04',0,'dioph l1 l2 = let (e1, e2, h) = preprocess l1 l2\r\n\n                  result = solve (e1, e2)\r\n\n              in foldl (a b -> b a) result h\r\n\n\r\n\npreprocess (a:b:c:0:[]) (k:l:m:n:[]) = regroup ((a,b,c), (k,l,m,n), [])\r\n\npreprocess (a:b:c:d:[]) (k:l:m:0:[]) = regroup ((k,l,m), (a,b,c,d), [])\r\n\npreprocess (a:b:c:d:[]) (k:l:m:n:[]) = regroup ((a*n-k*d, b*n-l*d, c*n-m*d), (k,l,m,n), [])\r\n\nregroup t = (regroup\' . regroup\'\' . regroup\') t\r\n\nregroup\'  ((0,b,c), (k,l,m,n), history) = ((b,0,c), (l,k,m,n), (swap\' ):history)\r\n\nregroup\'  t = t\r\n\nregroup\'\' ((a,0,c), (k,l,m,n), history) = ((a,c,0), (k,m,l,n), (swap\'\'):history)\r\n\nregroup\'\' t = t\r\n\nswap\'  (a,b,c) = (b,a,c)\r\n\nswap\'\' (a,b,c) = (a,c,b)\r\n\n\r\n\nsolve ((0,0,0), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((0,0,0), (k,0,0,n)) = (n/k, 0, 0)\r\n\nsolve ((0,0,0), (_,l,0,n)) = (0, n/l, 0)\r\n\nsolve ((0,0,0), (_,_,m,n)) = (0, 0, n/m)\r\n\nsolve ((a,0,0), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((a,0,0), (k,0,0,n)) = (0, 0, 0)\r\n\nsolve ((a,0,0), (_,l,0,n)) = (0, n/l, 0)\r\n\nsolve ((a,0,0), (_,_,m,n)) = (0, 0, n/m)\r\n\nsolve ((a,b,0), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((a,b,0), (k,0,0,n)) = (n/k, -n*a/(k*b), 0)\r\n\nsolve ((a,b,0), (k,l,0,n)) = let t = n/(a*l-k*b) in (-b*t, a*t, 0)\r\n\nsolve ((a,b,0), (_,_,m,n)) = (0, 0, n/m)\r\n\nsolve ((a,b,c), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((a,b,c), (k,0,0,n)) = (n/k, -n*a/(k*b), 0)\r\n\nsolve ((a,b,c), (_,l,0,n)) = (0, n/l, -n*b/(l*c))\r\n\nsolve ((a,b,c), (k,l,m,n))\r\n\n  | a*l-b*k /= 0 = let t = a*l-b*k in (-b*n/t, a*n/t, 0)\r\n\n  | a*m-c*k /= 0 = let t = a*m-c*k in (-c*n/t, 0, a*n/t)\r\n\n  | b*m-c*l /= 0 = let t = b*m-c*l in (0, -c*n/t, b*n/t)\r\n\n  | otherwise = (0, 0, 0)\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5564,44,'toskira','2013-09-27 19:09:37',2,'dioph l1 l2 = let (e1, e2, h) = preprocess l1 l2\r\n\r\n                  result = solve (e1, e2)\r\n\r\n              in ((a,b,c) -> a:b:c:[]) (foldl (a b -> b a) result h)\r\n\r\n\r\n\r\npreprocess (a:b:c:0:[]) (k:l:m:n:[]) = regroup ((a,b,c), (k,l,m,n), [])\r\n\r\npreprocess (a:b:c:d:[]) (k:l:m:0:[]) = regroup ((k,l,m), (a,b,c,d), [])\r\n\r\npreprocess (a:b:c:d:[]) (k:l:m:n:[]) = regroup ((a*n-k*d, b*n-l*d, c*n-m*d), (k,l,m,n), [])\r\n\r\nregroup t = (regroup\' . regroup\'\' . regroup\') t\r\n\r\nregroup\'  ((0,b,c), (k,l,m,n), history) = ((b,0,c), (l,k,m,n), (swap\' ):history)\r\n\r\nregroup\'  t = t\r\n\r\nregroup\'\' ((a,0,c), (k,l,m,n), history) = ((a,c,0), (k,m,l,n), (swap\'\'):history)\r\n\r\nregroup\'\' t = t\r\n\r\nswap\'  (a,b,c) = (b,a,c)\r\n\r\nswap\'\' (a,b,c) = (a,c,b)\r\n\r\n\r\n\r\nsolve ((0,0,0), (0,0,0,_)) = (0, 0, 0)\r\n\r\nsolve ((0,0,0), (k,0,0,n)) = (n/k, 0, 0)\r\n\r\nsolve ((0,0,0), (_,l,0,n)) = (0, n/l, 0)\r\n\r\nsolve ((0,0,0), (_,_,m,n)) = (0, 0, n/m)\r\n\r\nsolve ((a,0,0), (0,0,0,_)) = (0, 0, 0)\r\n\r\nsolve ((a,0,0), (k,0,0,n)) = (0, 0, 0)\r\n\r\nsolve ((a,0,0), (_,l,0,n)) = (0, n/l, 0)\r\n\r\nsolve ((a,0,0), (_,_,m,n)) = (0, 0, n/m)\r\n\r\nsolve ((a,b,0), (0,0,0,_)) = (0, 0, 0)\r\n\r\nsolve ((a,b,0), (k,0,0,n)) = (n/k, -n*a/(k*b), 0)\r\n\r\nsolve ((a,b,0), (k,l,0,n)) = let t = n/(a*l-k*b) in (-b*t, a*t, 0)\r\n\r\nsolve ((a,b,0), (_,_,m,n)) = (0, 0, n/m)\r\n\r\nsolve ((a,b,c), (0,0,0,_)) = (0, 0, 0)\r\n\r\nsolve ((a,b,c), (k,0,0,n)) = (n/k, -n*a/(k*b), 0)\r\n\r\nsolve ((a,b,c), (_,l,0,n)) = (0, n/l, -n*b/(l*c))\r\n\r\nsolve ((a,b,c), (k,l,m,n))\r\n\r\n  | a*l-b*k /= 0 = let t = a*l-b*k in (-b*n/t, a*n/t, 0)\r\n\r\n  | a*m-c*k /= 0 = let t = a*m-c*k in (-c*n/t, 0, a*n/t)\r\n\r\n  | b*m-c*l /= 0 = let t = b*m-c*l in (0, -c*n/t, b*n/t)\r\n\r\n  | otherwise = (0, 0, 0)\r\n\r\n\r\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)'),(5562,44,'toskira','2013-09-27 19:05:14',0,'dioph l1 l2 = let (e1, e2, h) = preprocess l1 l2\r\n\n                  result = solve (e1, e2)\r\n\n              in foldl (a b -> b a) result h\r\n\n\r\n\npreprocess (a:b:c:0:[]) (k:l:m:n:[]) = regroup ((a,b,c), (k,l,m,n), [])\r\n\npreprocess (a:b:c:d:[]) (k:l:m:0:[]) = regroup ((k,l,m), (a,b,c,d), [])\r\n\npreprocess (a:b:c:d:[]) (k:l:m:n:[]) = regroup ((a*n-k*d, b*n-l*d, c*n-m*d), (k,l,m,n), [])\r\n\nregroup t = (regroup\' . regroup\'\' . regroup\') t\r\n\nregroup\'  ((0,b,c), (k,l,m,n), history) = ((b,0,c), (l,k,m,n), (swap\' ):history)\r\n\nregroup\'  t = t\r\n\nregroup\'\' ((a,0,c), (k,l,m,n), history) = ((a,c,0), (k,m,l,n), (swap\'\'):history)\r\n\nregroup\'\' t = t\r\n\nswap\'  (a,b,c) = (b,a,c)\r\n\nswap\'\' (a,b,c) = (a,c,b)\r\n\n\r\n\nsolve ((0,0,0), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((0,0,0), (k,0,0,n)) = (n/k, 0, 0)\r\n\nsolve ((0,0,0), (_,l,0,n)) = (0, n/l, 0)\r\n\nsolve ((0,0,0), (_,_,m,n)) = (0, 0, n/m)\r\n\nsolve ((a,0,0), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((a,0,0), (k,0,0,n)) = (0, 0, 0)\r\n\nsolve ((a,0,0), (_,l,0,n)) = (0, n/l, 0)\r\n\nsolve ((a,0,0), (_,_,m,n)) = (0, 0, n/m)\r\n\nsolve ((a,b,0), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((a,b,0), (k,0,0,n)) = (n/k, -n*a/(k*b), 0)\r\n\nsolve ((a,b,0), (k,l,0,n)) = let t = n/(a*l-k*b) in (-b*t, a*t, 0)\r\n\nsolve ((a,b,0), (_,_,m,n)) = (0, 0, n/m)\r\n\nsolve ((a,b,c), (0,0,0,_)) = (0, 0, 0)\r\n\nsolve ((a,b,c), (k,0,0,n)) = (n/k, -n*a/(k*b), 0)\r\n\nsolve ((a,b,c), (_,l,0,n)) = (0, n/l, -n*b/(l*c))\r\n\nsolve ((a,b,c), (k,l,m,n))\r\n\n  | a*l-b*k /= 0 = let t = a*l-b*k in (-b*n/t, a*n/t, 0)\r\n\n  | a*m-c*k /= 0 = let t = a*m-c*k in (-c*n/t, 0, a*n/t)\r\n\n  | b*m-c*l /= 0 = let t = b*m-c*l in (0, -c*n/t, b*n/t)\r\n\n  | otherwise = (0, 0, 0)\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5561,30,'284427','2013-09-27 17:50:08',2,'parts (x:xs) = let (y:ys) = count xs x 1 [] in\r\n\r\n	if (length (x:xs) < 2) then False\r\n\r\n	else if (y < 2) then False\r\n\r\n	else if ((length ys > 0) && (minimum ys > 1))  then div1 ys (minimum (y:ys))\r\n\r\n	else if (length ys < 1) then True\r\n\r\n	else False\r\n\r\n	\r\n\r\ncount [] last c ys = (c:ys)\r\n\r\ncount (x:xs) last c ys = \r\n\r\n	if (x > last)\r\n\r\n	then count xs x (c+1) ys\r\n\r\n	else count xs x 1 (c:ys)\r\n\r\n				\r\n\r\ndiv1 [] _ = True\r\n\r\ndiv1 (x:xs) y = \r\n\r\n	if (x == y) || (x `mod` y == 0)\r\n\r\n	then div1 xs y\r\n\r\n	else False\r\n','Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),(5560,30,'284427','2013-09-27 17:48:15',0,'parts (x:xs) = let (y:ys) = count xs x 1 [] in\r\n\n	if (length (x:xs) < 2) then False\r\n\n	else if (y < 2) then False\r\n\n	else if ((length ys > 0) && (minimum ys > 2))  then div1 ys (minimum (y:ys))\r\n\n	else if (length ys < 1) then True\r\n\n	else False\r\n\n	\r\n\ncount [] last c ys = (c:ys)\r\n\ncount (x:xs) last c ys = \r\n\n	if (x > last)\r\n\n	then count xs x (c+1) ys\r\n\n	else count xs x 1 (c:ys)\r\n\n				\r\n\ndiv1 [] _ = True\r\n\ndiv1 (x:xs) y = \r\n\n	if (x == y) || (x `mod` y == 0)\r\n\n	then div1 xs y\r\n\n	else False\n','Выражение имеет неправильное значение: parts [1, 2, 1, 2, 3, 4]'),(5559,30,'284427','2013-09-27 17:47:52',0,'parts (x:xs) = let (y:ys) = count xs x 1 [] in\r\n\n	if (length (x:xs) < 2) then False\r\n\n	else if (y < 2) then False\r\n\n	else if ((length ys > 0) && (minimum ys > 2))  then div1 ys (minimum (y:ys))\r\n\n	else if (length ys < 1) then True\r\n\n	else False\r\n\n	\r\n\ncount [] last c ys = (c:ys)\r\n\ncount (x:xs) last c ys = \r\n\n	if (x > last)\r\n\n	then count xs x (c+1) ys\r\n\n	else count xs x 1 (c:ys)\r\n\n				\r\n\ndiv1 [] _ = True\r\n\ndiv1 (x:xs) y = \r\n\n	if (x == y) || (x `mod` y == 0)\r\n\n	then div1 xs y\r\n\n	else False\n','Выражение имеет неправильное значение: parts [1, 2, 1, 2, 3, 4]'),(5558,30,'284427','2013-09-27 17:44:49',0,'parts (x:xs) = let (y:ys) = count xs x 1 [] in\r\n\n	if (length (x:xs) < 2) then False\r\n\n	else if (y < 2) then False\r\n\n	else if ((length ys > 0) && (minimum ys < 2))  then div1 ys (minimum (y:ys))\r\n\n	else if (length ys < 1) then True\r\n\n	else False\r\n\n	\r\n\ncount [] last c ys = (c:ys)\r\n\ncount (x:xs) last c ys = \r\n\n	if (x > last)\r\n\n	then count xs x (c+1) ys\r\n\n	else count xs x 1 (c:ys)\r\n\n				\r\n\ndiv1 [] _ = True\r\n\ndiv1 (x:xs) y = \r\n\n	if (x == y) || (x `mod` y == 0)\r\n\n	then div1 xs y\r\n\n	else False\n','Выражение имеет неправильное значение: parts [1, 2, 8, 2, 5, 6]'),(5556,42,'517309','2013-09-27 17:30:38',2,'myfoldl = foldl','<br/>Тесты успешно пройдены!'),(5557,30,'284427','2013-09-27 17:43:09',0,'parts (x:xs) = let (y:ys) = count xs x 1 [] in\r\n\n	if (length (x:xs) < 2) then False\r\n\n	else if (y < 2) then False\r\n\n	else if ((length ys > 0) && (minimum ys < 2))  then div1 ys (minimum (y:ys))\r\n\n	else if (length ys < 1) then True\r\n\n	else False\r\n\n	\r\n\ncount [] last c ys = (c:ys)\r\n\ncount (x:xs) last c ys = \r\n\n	if (x > last)\r\n\n	then count xs x (c+1) ys\r\n\n	else count xs x 1 (c:ys)\r\n\n				\r\n\ndiv1 [] _ = True\r\n\ndiv1 (x:xs) y = \r\n\n	if (x == y) || (x `mod` y == 0)\r\n\n	then div1 xs y\r\n\n	else False\n','Выражение имеет неправильное значение: parts [1, 2, 8, 2, 5, 6]'),(5554,42,'517309','2013-09-27 17:28:23',0,'myfoldl = foldl','Не удалось вычислить выражение \"let f res x->if x then res+1 else res in myfoldl  0 [True,False,True]\", проверьте правильность синтаксиса'),(5555,42,'517309','2013-09-27 17:29:27',0,'myfoldl = foldl','Не удалось вычислить выражение \"let f res x->if x then res+1 else res in myfoldl f 0 [True,False,True]\", проверьте правильность синтаксиса'),(5553,30,'284427','2013-09-27 17:28:13',2,'parts [] = False\r\n\r\nparts [x] = False\r\n\r\nparts [x,y] = \r\n\r\n	if (x<y) \r\n\r\n	then True\r\n\r\n	else False\r\n\r\nparts (x:xs) = let (y:ys) = count xs x 1 [] in\r\n\r\n	if (minimum ys == 1) \r\n\r\n	then False\r\n\r\n	else div1 ys y\r\n\r\n\r\n\r\ncount [] last c ys = (c:ys)\r\n\r\ncount (x:xs) last c ys = \r\n\r\n	if (x > last)\r\n\r\n	then count xs x (c+1) ys\r\n\r\n	else count xs x 1 (c:ys)\r\n\r\n				\r\n\r\ndiv1 [] _ = True\r\n\r\ndiv1 (x:xs) y = \r\n\r\n	if (x == y) || (x `mod` y == 0)\r\n\r\n	then div1 xs y\r\n\r\n	else False\r\n','Не удалось вычислить выражение \"parts [1, 2, 3, 4, 5]\", проверьте правильность синтаксиса'),(5552,42,'517309','2013-09-27 17:26:43',0,'myfoldl = foldl','Не удалось вычислить выражение \"myfoldl (\res x->if x then res+1 else res) 0 [True,False,True]\", проверьте правильность синтаксиса'),(5550,43,'2156724','2013-09-27 16:59:52',0,'\r\n\nbezu m n bm bn = \r\n\n  if (1 == (m * bm - n * bn)) then (0-bn, bm)\r\n\n  else\r\n\n    if ( m * bm > n * (bn + 1)) then bezu m n bm (bn+1)\r\n\n    else  bezu n m (bn+1) bm \r\n\n  \r\n\n\r\n\neuclid 0 n = \r\n\n    if n ==1 then (0,1) else\r\n\n       (0,0)\r\n\n\r\n\neuclid n 0 = \r\n\n    if n ==1 then (0,1) else\r\n\n       (0,0)\r\n\n       \r\n\neuclid m n = bezu m n 1 1 \n','Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),(5551,43,'2156724','2013-09-27 17:00:55',1,'\r\nbezu m n bm bn = \r\n\r\n  if (1 == (m * bm - n * bn)) then (0-bn, bm)\r\n\r\n  else\r\n\r\n    if ( m * bm > n * (bn + 1)) then bezu m n bm (bn+1)\r\n\r\n    else  bezu n m (bn+1) bm \r\n\r\n  \r\n\r\n\r\n\r\neuclid 0 n = \r\n\r\n    if n == 1 then (0,1) else\r\n\r\n       (0,0)\r\n\r\n\r\n\r\neuclid n 0 = \r\n\r\n    if n ==1 then (1,0) else\r\n\r\n       (0,0)\r\n\r\n       \r\n\r\neuclid m n = bezu m n 1 1 \r\n','<br/>Тесты успешно пройдены!'),(5548,52,'3270666','2013-09-27 16:02:55',1,'repeatFunc f n = foldr (.) (i -> i) (map (i -> f) [1..n])','<br/>Тесты успешно пройдены!'),(5549,43,'2156724','2013-09-27 16:56:49',0,'bezu m n bm bn = \r\n\n  if (1 == (m * bm - n * bn)) then (0-bn, bm)\r\n\n  else\r\n\n    if ( m * bm > n * (bn + 1)) then bezu m n bm (bn+1)\r\n\n    else  bezu n m (bn+1) bm \r\n\n  \r\n\neuclid m n = bezu m n 1 1\n','Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),(5547,51,'3270666','2013-09-27 15:58:59',1,'repeatFunc f 1 = f\r\nrepeatFunc f n = f . repeatFunc f (n - 1)','<br/>Тесты успешно пройдены!'),(5545,42,'3270666','2013-09-27 15:54:49',0,'myfoldl op e xs = fold op (e:xs)\r\n\r\nfold op [x1, x2] = x1 `op` x2\r\nfold op (x1:x2:xs) = fold op ((x1 `op` x2):xs)','Не удалось вычислить выражение \"myfoldl (+) 10 []\", проверьте правильность синтаксиса'),(5546,42,'3270666','2013-09-27 15:55:30',2,'--- На самом деле не совсем правильно.\r\n--- Проблема возникает втом случае, когда у нас спастое одного типа - а результат другого.\r\n--- Например у меня список логических значений и я хочу сосчитать сколько из них True\r\n--- Это можно записать так: myfoldl (\res x->if x then res+1 else res) 0 [True,False,True]\r\n--- Но у вас такой вызов не скомпилируется. (Я сейчас добавлю такой тест).\r\n--- Я вам задачу не зачту и вы попроьуйте ее исправить, пожалуйста. Это просто.\r\n--- Но если не получится, просто пришлите ее еще раз, и я ее зачту неправильной.\r\nmyfoldl op e xs = fold op (e:xs)\r\n\r\nfold _ [x] = x\r\nfold op [x1, x2] = x1 `op` x2\r\nfold op (x1:x2:xs) = fold op ((x1 `op` x2):xs)\r\n','<br/>Тесты успешно пройдены!'),(5543,40,'3270666','2013-09-27 15:21:30',1,'identity n = map (i -> makeRow i n) [1..n]\r\nmakeRow k n = map (j -> if (j == k) then 1 else 0) [1..n]','<br/>Тесты успешно пройдены!'),(5544,41,'3270666','2013-09-27 15:46:34',1,'countOdd xs = foldr (x res -> res + (x `mod` 2)) 0 xs\r\n\r\ncountOdd1 xs = foldr (+) 0 (map (i -> (i `mod` 2)) xs)','<br/>Тесты успешно пройдены!'),(5542,33,'2156724','2013-09-27 14:51:03',1,'--- В этой задаче, на самом деле, надо прислать всю программу целиком - так, чтобы ее можно было скомпилировать\r\n--- и увидеть какой-то результат. В частности, дб примервы вызова.\r\n--- Пришлите или выложите полный текст, пожалуйста. Если сегодня не успете, можете прислать завтра.\r\n\r\npublic static double integral(Func<double,double> func,double a, double b)\r\n        {\r\n            int m = 100;\r\n            double h = (b - a) / m;\r\n            List<double> z = new List<double>();\r\n            double result = 0;\r\n            for (int i = 0; i <= m; i++)\r\n            {\r\n                z.Add(a + i * h);\r\n            }\r\n            for (int i = 1; i <= m; i++)\r\n            {\r\n                result += func((z[i - 1] + z[i]) / 2);\r\n            }\r\n            return result * h;\r\n        }','<br/>Тесты успешно пройдены!'),(5541,43,'toskira','2013-09-27 12:15:32',1,'euclid 0 (-1) = (0, -1)\r\neuclid 0 1 = (0, 1)\r\neuclid a b = let\r\n               r = mod b a\r\n               q = div b a\r\n               (a\', b\') = euclid r a\r\n             in (b\' - q * a\', a\')','<br/>Тесты успешно пройдены!'),(5539,47,'15309342','2013-09-27 11:24:21',1,'powerset [] = [[]]\r\npowerset (x:xs) = zs ++ [x:ys | ys <- zs]\r\n  where zs = powerset xs','<br/>Тесты успешно пройдены!'),(5540,30,'517309','2013-09-27 12:11:16',2,'parts yadas = go [[]] yadas where\r\n  go acc [] = all check $ zip acc (tail acc)\r\n  go ([]:rest) (x:xs) = go ([x]:rest) xs\r\n  go acc@(q:rest) (x:xs)  =\r\n    let update = x > head q && go ((x:q):rest) xs\r\n        renew  = go ([x]:acc) xs\r\n    in update || renew\r\n\r\n  check (a, b) =\r\n    let la = length a\r\n        lb = length b\r\n    in la > 1 && la == lb\r\n','Не удалось вычислить выражение \"parts ([1..9] ++ [1..18] ++ [1..6])\", проверьте правильность синтаксиса'),(5538,43,'toskira','2013-09-27 01:22:41',0,'euclid 0 _ = (0, 0)\r\neuclid _ 0 = (0, 0)\r\neuclid a b = euclid\' (1, 0, 0, 1) a b\r\n\r\neuclid\' (e00, e01, e10, e11) a b = \r\n  let\r\n    r = mod a b\r\n  in if r == 0\r\n     then (e01, e11)\r\n     else let\r\n            q = div a b\r\n            e00\' = e01\r\n            e01\' = e00 - e01 * q\r\n            e10\' = e11 \r\n            e11\' = e10 - e11 * q\r\n          in euclid\' (e00\', e01\', e10\', e11\') b r','Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),(5537,43,'toskira','2013-09-27 01:18:27',0,'euclid a b = euclid\' (1, 0, 0, 1) a b\r\n\r\neuclid\' (e00, e01, e10, e11) a b = \r\n  let\r\n    r = mod a b\r\n  in if r == 0\r\n     then (e01, e11)\r\n     else let\r\n            q = div a b\r\n            e00\' = e01\r\n            e01\' = e00 - e01 * q\r\n            e10\' = e11 \r\n            e11\' = e10 - e11 * q\r\n          in euclid\' (e00\', e01\', e10\', e11\') b r','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5535,47,'romos2007','2013-09-27 00:42:24',0,'','Не удалось вычислить выражение \"length (powerset [1,2,3])\", проверьте правильность синтаксиса'),(5536,47,'romos2007','2013-09-27 00:45:46',1,'{--\r\n\r\nЗадача 10-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-	Стоит заметить возможную схему генерации подобного массива массивов: (для [1,2,3])\r\n\r\npowerset [1,2,3] = \r\n\r\n	[1]			|\r\n\r\n	[1,2] [1,3]	|	1 : (все x из powerset[2,3])\r\n\r\n	[1,2,3]		|\r\n\r\n\r\n\r\npowerset [2,3] = \r\n\r\n	[2]			|	2 : (все x из powerset[3])\r\n\r\n	[2,3]		|\r\n\r\n\r\n\r\npowerset [3] = \r\n\r\n	[3]			|	3: (все x из powerset[])\r\n\r\n	\r\n\r\n	[]			|	default powerset[]\r\n\r\n\r\n\r\nТ.е. надо соединить ф-цией foldr массивы\r\n\r\n-}\r\n\r\n\r\n\r\npowerset (x:xs) = 	let rest = powerset xs\r\n\r\n					in foldr (:)\r\n\r\n							 (map (ys->(x:ys)) rest)	-- К каждому из имеющихся массивов добавить в начало пред.элемент;\r\n\r\n							 							-- 		тем самым получим все массивы, начинающиеся с этого элемента\r\n\r\n							 rest						-- Не забываем добавить еще и эти, ранее сгенерированые, массивы.\r\n\r\npowerset [] = [[]]\r\n','<br/>Тесты успешно пройдены!'),(5533,52,'4604056','2013-09-26 23:52:20',1,'repeatFunc f 1 = f\r\nrepeatFunc f x = foldl (.) id (map (i -> f) [1..x])\r\n\r\nfuns = repeatFunc (*2) 3','<br/>Тесты успешно пройдены!'),(5534,31,'2156724','2013-09-27 00:00:13',1,'func a1 a2 l1 l2 [] n = True\r\n\r\nfunc a1 a2 l1 l2 (x:xs) n =\r\n\r\n  if l1 == quot n 2 then \r\n\r\n     if (a2 < x) then func a1 x l1 (l2+1) (xs) n\r\n\r\n                else False\r\n\r\n  else\r\n\r\n     if l2 == quot n 2 then       \r\n\r\n	if (a1 < x) then func x a2 (l1+1) l2 (xs) n\r\n\r\n                else False\r\n\r\n     else\r\n\r\n       if (a2 < x) && (a1 < x) then func x a2 (l1+1) l2 (xs) n ||  func a1 x l1 (l2+1) (xs) n\r\n\r\n       else if (a2 < x) then func a1 x l1 (l2+1) (xs) n      \r\n\r\n            else if (a1 < x) then func  x a2 (l1+1) l2 (xs) n\r\n\r\n                 else False\r\n\r\n\r\n\r\nparts2 (x:xs) =\r\n\r\n   if (rem (length (x:xs)) 2 == 1) then False\r\n\r\n   else func 0 0 0 0 (x:xs) (length (x:xs))  \r\n','<br/>Тесты успешно пройдены!'),(5532,51,'4604056','2013-09-26 23:46:06',1,'repeatFunc f 1 = f\r\nrepeatFunc f x = f.repeatFunc f (x-1)\r\n\r\nfun = repeatFunc (*2) 3\r\n','<br/>Тесты успешно пройдены!'),(5531,45,'toskira','2013-09-26 23:41:23',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace _8_1 {\r\n\r\n	class Program {\r\n\r\n		static bool AnyEven(int [][] a) {\r\n			return a.All(p => p.Any(q => q % 2 == 0));\r\n		}\r\n\r\n		static void Main(string[] args) {\r\n			int[][] x = { new int[] { 1, 2 }, new int[] { 3, 4 }, new int[] { 5, 6 } };\r\n			int[][] y = { new int[] { 1, 3, 9 }, new int[] { 4, 5, 6 } };\r\n			Console.WriteLine(AnyEven(x));\r\n			Console.WriteLine(AnyEven(y));\r\n			Console.ReadKey();\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5530,51,'4604056','2013-09-26 23:37:33',0,'repeatFunc f 1 = f\r\nrepeatFunc f x = f(repeatFunc f (x-1))','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5528,48,'toskira','2013-09-26 23:24:15',1,'myreverse list = (foldr (a b -> (b.(a:))) id list) []','<br/>Тесты успешно пройдены!'),(5529,51,'4604056','2013-09-26 23:36:34',0,'repeatFunc f 0 = (a -> a)\r\nrepeatFunc f x = f(repeatFunc f (x-1))','Не удалось вычислить выражение \"(repeatFunc (*2) 3) 1\", проверьте правильность синтаксиса'),(5527,42,'4604056','2013-09-26 23:11:52',1,'myfoldl _ a [] = a\r\nmyfoldl f a (x:[]) = f a x\r\nmyfoldl f a (x:xs) = myfoldl f b xs\r\n	where b = f a x','<br/>Тесты успешно пройдены!'),(5525,41,'4604056','2013-09-26 23:06:04',1,'countOdd [] = 0\r\ncountOdd xs = foldr (i n -> n + mod i 2) 0 xs\r\n\r\ncountOdd1 [] = 0\r\ncountOdd1 xs = sum (map (i -> mod i 2) xs)','<br/>Тесты успешно пройдены!'),(5526,42,'4604056','2013-09-26 23:11:09',0,'myfoldl f a (x:[]) = f a x\r\nmyfoldl f a (x:xs) = myfoldl f b xs\r\n	where b = f a x','Не удалось вычислить выражение \"myfoldl (+) 10 []\", проверьте правильность синтаксиса'),(5524,47,'toskira','2013-09-26 23:05:45',1,'powerset list = foldr add [[]] list\r\n\r\nadd _ [] = []\r\nadd e ((h):t) = (h):(e:h):(add e t)','<br/>Тесты успешно пройдены!'),(5523,40,'4604056','2013-09-26 22:32:30',1,'identity 0 = []\r\nidentity n = map (identity\' n) [1..n]\r\n\r\n\r\nidentity\' n i = map (j -> if j == i\r\n	then 1\r\n	else 0) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5522,48,'deripaska','2013-09-26 22:29:14',2,'{--\r\n\r\n	task 10-02\r\n\r\n*Доп задача*\r\n\r\nИспользуя _только_ функцию foldr и лямбда выражения опишите функцию myreverse, возвращающую элементы списка в обратном порядке.\r\n\r\nПример вызова:\r\n\r\nmyreverse [1, 2, 3]\r\n\r\nРезультат д.б. равен [3, 2, 1].\r\n\r\n\r\n\r\nДополнительные условия:\r\n\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.\r\n\r\n- Функция должна работать за линейное время. Технически это означает, что нельзя использовать операцию ++[x] или каким-то другим способом приписывать очередной элемент к концу списка на каждом шаге работы foldr. \r\n\r\n- Чтобы задача была немного еще посложнее, давайте пусть будет еще дополнительно условие - нельзя использовать пары (tuples). (И соответственно нельзя каким-то образом их имитировать, с помощью списков из двух элементов или data и т.д.)\r\n\r\n--}\r\n--- OK, хорошо (хотя я знаю другое решение, короче). Но строго говоря, вы ведь кроме foldr \r\n--- используете еще и map..\r\n--- Давайте вы напишете вариант, в котором вместо map тоже используется foldr (это просто)\r\n--- и я вам зачту, хорошо?\r\n\r\n\r\n--myreverse xs = foldl (\r\nes x -> x:res) [] xs\r\n\r\n--myreverse xs = foldr (x res -> res++[x]) [] xs\r\n\r\n\r\n\r\nmyreverse xs = map ((y:ys) -> y) (buildTails xs)\r\n\r\n	where buildTails ys = foldr (k res@((y:curTail):tail) -> if curTail /= [] then (curTail:res) else res) [ys] ys\r\n','<br/>Тесты успешно пройдены!'),(5521,48,'anlun','2013-09-26 21:20:49',1,'myreverse :: [a] -> [a]\r\nmyreverse l = (foldr (e f -> f . (e:)) id l) []','<br/>Тесты успешно пройдены!'),(5519,43,'15309342','2013-09-26 18:37:57',1,'euclid a b = euclid1 a b 1 0 0 1\r\neuclid1 a b c1 d1 c2 d2 | b == 0 = (c1, d1)\r\n			| otherwise = euclid1 b (a `mod` b) c2 d2 (c1 - (a `div` b) * c2) (d1 - (a `div` b) * d2)','<br/>Тесты успешно пройдены!'),(5520,47,'deripaska','2013-09-26 21:04:49',1,'{--\r\n\r\n	task 10-01\r\n\r\n*Доп задача*\r\n\r\nОписать функцию powerset, которая по списку порождает список из всех его подсписков.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\npowerset [1, 2, 3]\r\n\r\nРезультат д.б. равен [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]. (Порядок элементов в ответе м.б. и другим, как вам удобнее).\r\n\r\n--}\r\n\r\n\r\n\r\npowerset [] = [[]]\r\n\r\npowerset (x:xs) = foldr (:) (map (ys -> x:ys) onlyTailSet) onlyTailSet\r\n  --= Ну или тут можно использовать ++\r\n	where onlyTailSet = powerset xs\r\n','<br/>Тесты успешно пройдены!'),(5518,31,'15309342','2013-09-26 18:21:39',1,'--добавлена проверка, что в списке, куда мы хотим добавить, еще меньше половины элементов\r\n\r\nparts2 list = parts3 list [] [] 0 0 ((length list) `div` 2)\r\n\r\nparts3 [] list1 list2 l1 l2 n = (l1 == l2)\r\n  --- Теперь эта проверка особо не нужна, и так в обеих списках должна получиться половина\r\n\r\nparts3 (x:xs) [] [] 0 0 n = (parts3 xs [x] [] 1 0 n) || (parts3 xs [] [x] 0 1 n)\r\n\r\nparts3 (x:xs) list1 [] l1 0 n | (x > head list1 && l1 < n) = (parts3 xs (x:list1) [] (l1 + 1) 0 n) || (parts3 xs list1 [x] l1 1 n)\r\n\r\n                            | otherwise = parts3 xs list1 [x] l1 1 n\r\n\r\nparts3 (x:xs) [] list2 0 l2 n = parts3 (x:xs) list2 [] l2 0 n\r\n\r\nparts3 (x:xs) z1@(x1:list1) z2@(x2:list2) l1 l2 n | (x <= x1 && x <= x2) = False\r\n\r\n                                                  | (x > x1 && x <= x2) = parts3_1 xs z1 z2 l1 l2 n x\r\n\r\n                                                  | (x <= x1 && x > x2) = parts3_2 xs z1 z2 l1 l2 n x\r\n\r\n                                                  | otherwise = (parts3_1 xs z1 z2 l1 l2 n x) || (parts3_2 xs z1 z2 l1 l2 n x)\r\n\r\nparts3_1 xs z1 z2 l1 l2 n x | l1 >= n = False\r\n\r\n			    | otherwise = parts3 xs (x:z1) z2 (l1 + 1) l2 n\r\n\r\nparts3_2 xs z1 z2 l1 l2 n x = parts3_1 xs z2 z1 l2 l1 n x\r\n','<br/>Тесты успешно пройдены!'),(5517,45,'15309342','2013-09-26 16:58:30',1,'using System;\r\nusing System.Linq;\r\n\r\n\r\nnamespace FP_homework\r\n{\r\n    class Task8_1\r\n    {\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] testArray1 = \r\n            {\r\n                new int[] {1,3,5,7,9},\r\n                new int[] {0,2,4,6},\r\n                new int[] {11,22}\r\n            };\r\n            bool result = testArray1.All(a => a.Any(x => x % 2 == 0));\r\n            Console.WriteLine(result);\r\n            \r\n            int[][] testArray2 = \r\n            {\r\n                new int[] {2,3,5,7,9},\r\n                new int[] {0,2,4,6},\r\n                new int[] {11,22}\r\n            };\r\n            result = testArray2.All(a => a.Any(x => x % 2 == 0));\r\n            Console.WriteLine(result);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5516,33,'15309342','2013-09-26 16:31:13',1,'using System;\r\n\r\nnamespace FP_homework\r\n{\r\n    class Task5_1\r\n    {\r\n       static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            int n = 100;\r\n            double result = 0;\r\n            double h = (b - a) / n;\r\n            double x = a;\r\n            double y = a + h;\r\n            for (int i = 0; i < n; ++i)\r\n            {\r\n                result += f((x + y) / 2) * h;\r\n                x = y;\r\n                y = y + h;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            // Примеры вызова:\r\n            Console.WriteLine(Integral(x => x * x * x, 0, 1));\r\n            Console.WriteLine(Integral(x => x * x, 0, 1));\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5514,41,'2156724','2013-09-26 12:53:32',1,'isEven n = n `mod` 2 == 1\r\n\r\n\r\n\r\ncountOdd1 [] = 0\r\n  --- Это правило не нужно, и без него все будет работать\r\ncountOdd1 (x:xs) = \r\n\r\n   foldr (+) 0  (map (i-> 1) (filter isEven (x:xs)))\r\n\r\n\r\n\r\n\r\n\r\ncountOdd [] = 0\r\n  --- И это правило тоже не нужно...\r\ncountOdd (x:xs) = foldr (x res -> if (isEven x) then 1+res else res) 0 (x:xs) \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5515,42,'2156724','2013-09-26 13:05:54',1,'myfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs \r\n','<br/>Тесты успешно пройдены!'),(5511,51,'toskira','2013-09-26 12:39:52',1,'repeatFunc f n = repeatFunc\' f id n\r\n\r\nrepeatFunc\' f c 0 = c\r\nrepeatFunc\' f c n = repeatFunc\' f (c . f) (n - 1)','<br/>Тесты успешно пройдены!'),(5512,52,'toskira','2013-09-26 12:50:45',1,'repeatFunc f n = foldr (.) id (map (\\_ -> f) (take n [1..]))','<br/>Тесты успешно пройдены!'),(5513,41,'2156724','2013-09-26 12:51:19',0,'isEven n = n `mod` 2 == 1\r\n\n\r\n\ncountOdd1 (x:xs) = \r\n\n   foldr (+) 0  (map (i-> 1) (filter isEven (x:xs)))\r\n\n\r\n\n\r\n\n\r\n\ncountOdd (x:xs) = foldr (x res -> if (isEven x) then 1+res else res) 0 (x:xs) \r\n\n\n','Не удалось вычислить выражение \"countOdd []\", проверьте правильность синтаксиса'),(5509,41,'toskira','2013-09-26 12:26:18',1,'countOdd list = foldr (a b -> b + (mod a 2)) 0 list\r\n\r\ncountOdd1 list = length (filter (odd) list)','<br/>Тесты успешно пройдены!'),(5510,42,'toskira','2013-09-26 12:28:57',1,'myfoldl f e [] = e\r\nmyfoldl f e (h:t) = myfoldl f (f e h) t','<br/>Тесты успешно пройдены!'),(5504,51,'1048693','2013-09-26 02:18:08',1,'repeatFunc :: (a -> a) -> Integer -> (a -> a)\r\n\r\nrepeatFunc f n = foldl (acc _ -> acc . f) id [1..n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5505,52,'1048693','2013-09-26 02:18:16',0,'','Не удалось вычислить выражение \"repeatFunc (*2) 3 10\", проверьте правильность синтаксиса'),(5506,52,'1048693','2013-09-26 02:18:28',1,'repeatFunc :: (a -> a) -> Integer -> (a -> a)\r\n\r\nrepeatFunc f n = foldl (acc _ -> acc . f) id [1..n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5507,40,'2156724','2013-09-26 12:18:02',1,'f k n = map (i -> if i == k then 1 else 0)[1..n]\r\n\r\n\r\n\r\nidentity\' k n (x:xs)=\r\n\r\n   if k == 1 then ((f 1 n):x:xs)\r\n\r\n   else identity\' (k-1) n ((f k n):x:xs)\r\n\r\n\r\n\r\nidentity 1 = [[1]]\r\n\r\nidentity n = identity\' (n-1) n [(f n n)]  \r\n    --- или тут можно было тоже применить map\r\n    --- identity n = map (i-> ... и тут надо что-то вставить... ) [1..n]\r\n\r\n    \r\n','<br/>Тесты успешно пройдены!'),(5508,40,'toskira','2013-09-26 12:18:49',1,'identity n = map (a -> map ( -> if a == b then 1 else 0) [1..n]) [1..n]','<br/>Тесты успешно пройдены!'),(5500,41,'1048693','2013-09-26 01:52:43',0,'countOdd  :: [Integer] -> Integer\n\ncountOdd  = foldr (s k -> if k `mod` 2 == 1 then s + 1 else s) 0\n\n\n\ncountOdd1 :: [Integer] -> Integer\n\ncountOdd1 = sum . map (`mod` 2)\n\n\n','Выражение имеет неправильное значение: countOdd [2, 3, 4, 8, 5, 33, 9]'),(5501,40,'1048693','2013-09-26 01:53:21',1,'type Matrix a = [[a]]\r\n\r\n\r\n\r\nidentity :: Integer -> Matrix Integer\r\n\r\nidentity n = [ map (j -> if i == j then 1 else 0) [1..n] | i <- [1..n] ]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5502,41,'1048693','2013-09-26 01:58:12',1,'countOdd  :: [Integer] -> Integer\r\n\r\ncountOdd  = foldr (k s -> if k `mod` 2 == 1 then s + 1 else s) 0\r\n\r\n\r\n\r\ncountOdd1 :: [Integer] -> Integer\r\n\r\ncountOdd1 = sum . map (`mod` 2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5503,42,'1048693','2013-09-26 02:03:13',1,'myfoldl :: (a -> b -> a) -> a -> [b] -> a\r\n\r\nmyfoldl _ a    []  = a\r\n\r\nmyfoldl f a (x:xs) = myfoldl f (f a x) xs\r\n\r\n\r\n\r\nmyfoldr :: (b -> a -> a) -> a -> [b] -> a\r\n\r\nmyfoldr _ a    []  = a\r\n\r\nmyfoldr f a (x:xs) = f x (myfoldr f a xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5498,30,'6053606','2013-09-26 00:19:56',2,'  --- Похоже не совсем правильно.\r\n  --- Вот пример, когда у вас, похоже, программа циклится:\r\n  ---  parts ([1..9] ++ [1..18] ++ [1..6])\r\n  --- Попробуйте исправить, пожалуйста, желательно до начала пары, но можно и немного позже,\r\n  --- если что.\r\n  --- Как исправить, вам виднее, но мне кажется у вас как-то слишком сложно.. Я бы тут не использлвал\r\n  --- списков списков и тд - это довольно простая задача. \r\n  --- Задачу можно загрузить, даже если ее срок уже прошел, с помощью ссылки Загрузить решение\r\n  --- на первой странице.\r\nparts yadas = go [[]] yadas where\r\n  go acc [] = all check $ zip acc (tail acc)\r\n  go ([]:rest) (x:xs) = go ([x]:rest) xs\r\n  go acc@(q:rest) (x:xs)  =\r\n    let update = x > head q && go ((x:q):rest) xs\r\n        renew  = go ([x]:acc) xs\r\n    in update || renew\r\n\r\n  check (a, b) =\r\n    let la = length a\r\n        lb = length b\r\n    in la > 1 && la == lb','<br/>Тесты успешно пройдены!'),(5499,18,'1048693','2013-09-26 01:46:14',1,'type Matrix a = [[a]]\r\n\r\n\r\n\r\nidentity :: Integer -> Matrix Integer\r\n\r\nidentity n = [ map (j -> if i == j then 1 else 0) [1..n] | i <- [1..n] ]\r\n\r\n\r\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(5497,52,'deripaska','2013-09-25 22:30:48',1,'{--\r\n\r\n	task 09-05\r\n\r\nОпределите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\n\r\n\r\n\r\nДополнительное условие:\r\n\r\n- В этой задаче нельзя определять свои рекурсивные функции. Можно использовать стандартные функции и можно, если хотите, определять нерекурсивные функции.\r\n\r\n--}\r\n\r\n\r\n\r\nrepeatFunc f n = foldr (\\_ res -> f.res) f [1..(n - 1)]\r\n','<br/>Тесты успешно пройдены!'),(5496,51,'deripaska','2013-09-25 22:30:27',1,'{--\r\n\r\n	task 09-04\r\n\r\nОпределите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\n\r\nПример вызова:\r\n\r\n\r\n\r\nf = repeatFunc sin 3\r\n\r\n\r\n\r\nдолжно определить f x = sin (sin (sin x))\r\n\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n\r\n--}\r\n\r\n\r\n\r\nrepeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n - 1))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5495,42,'deripaska','2013-09-25 22:30:01',1,'{--\r\n\r\n	task 09-03\r\n\r\nОпишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl (т.е. сворачивает все элементы слева направо).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nmyfoldl (+) 0 [1,2,3]\r\n\r\nФункция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить именно в таком порядке.\r\n\r\n--}\r\n\r\n\r\n\r\nmyfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n\r\n		\r\n','<br/>Тесты успешно пройдены!'),(5492,43,'3270666','2013-09-25 20:33:06',1,'euclid _ 1 = (0, 1)\r\neuclid 1 _ = (1, 0)\r\neuclid 0 _ = (0, 0)\r\neuclid _ 0 = (0, 0)\r\neuclid a b = if (a > b)\r\n	then euclid\' a b [] 0 False\r\n	else euclid\' b a [] 0 True\r\n\r\neuclid\' a b qs n reflect = let q = a `div` b\r\n                               r = a `mod` b\r\n                           in case r of\r\n                           	  1 -> let res = solve_r (n + 1) (q:qs)\r\n                           	       in output (sum (fst res), sum (snd res)) reflect\r\n                           	  0 -> (0, 0)\r\n                           	  _ -> euclid\' b r (q:qs) (n + 1) reflect\r\n\r\n\r\nsolve_r 1 [q0] = ([1], [-q0])\r\nsolve_r 2 [q1, q0] = ([-q1], [1, q1*q0])\r\nsolve_r n (qn:qn_1:qs) = (fst (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (fst (solve_r (n - 1) (qn_1:qs)))),\r\n	snd (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (snd (solve_r (n - 1) (qn_1:qs)))))\r\n\r\noutput answer reflect = if reflect\r\n	then (snd answer, fst answer)\r\n	else answer','<br/>Тесты успешно пройдены!'),(5493,40,'deripaska','2013-09-25 22:28:52',1,'{--\r\n\r\n	task 09-01\r\n\r\n\"Единичная матрица\"\r\n\r\n\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию identity n, которая возвращает список списков, соответствующий единичной матрице n на n. Т.е. элементы на главной диагонали д.б. равны 1, а все остальные элементы равны 0.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nidentity 4\r\n\r\nДолжно получиться:\r\n\r\n[[1, 0, 0, 0],\r\n\r\n[0, 1, 0, 0],\r\n\r\n[0, 0, 1, 0],\r\n\r\n[0, 0, 0, 1]]\r\n\r\n--}\r\n\r\n\r\n\r\nidentity n = map (k -> map (x -> if x == k then 1 else 0) [1..n]) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5494,41,'deripaska','2013-09-25 22:29:31',1,'{--\r\n\r\n	task 09-02\r\n\r\nОпишите две функции, countOdd и countOdd1, которые для данного списка вычисляют количество нечетных чисел в этом списке. (Т.е. надо написать две версии одной функции).\r\n\r\n\r\n\r\nДополнительные условия:\r\n\r\n- В функции countOdd можно использовать _только_ стандартную функцию foldr. Можно (но особо не нужно) задавать свои нерекурсивные функции. Можно, \r\n\r\nконечно, использовать лямбда-выражения.\r\n\r\n\r\n\r\n- В функции countOdd1 можно использовать любые стандартные функции, и тоже, если надо, можно использовать свои нерекурсивные функции и лямбда-выражения. Но _нельзя_ определять свои рекурсивные функции.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ncountOdd [2, 3, 4, 8, 5, 33, 9]\r\n\r\nОтвет должен быть равен 4\r\n\r\n--}\r\n\r\n\r\n\r\ncountOdd xs = foldr (x res -> if (mod x 2 == 0) then res else res + 1) 0 xs\r\n\r\ncountOdd1 xs = length (filter (x -> mod x 2 /= 0) xs)\r\n','<br/>Тесты успешно пройдены!'),(5491,43,'3270666','2013-09-25 20:31:08',0,'euclid 0 _ = (0, 0)\r\neuclid _ 0 = (0, 0)\r\neuclid a b = if (a > b)\r\n	then euclid\' a b [] 0 False\r\n	else euclid\' b a [] 0 True\r\n\r\neuclid\' a b qs n reflect = let q = a `div` b\r\n                               r = a `mod` b\r\n                           in case r of\r\n                           	  1 -> let res = solve_r (n + 1) (q:qs)\r\n                           	       in output (sum (fst res), sum (snd res)) reflect\r\n                           	  0 -> (0, 0)\r\n                           	  _ -> euclid\' b r (q:qs) (n + 1) reflect\r\n\r\n\r\nsolve_r 1 [q0] = ([1], [-q0])\r\nsolve_r 2 [q1, q0] = ([-q1], [1, q1*q0])\r\nsolve_r n (qn:qn_1:qs) = (fst (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (fst (solve_r (n - 1) (qn_1:qs)))),\r\n	snd (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (snd (solve_r (n - 1) (qn_1:qs)))))\r\n\r\noutput answer reflect = if reflect\r\n	then (snd answer, fst answer)\r\n	else answer','Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),(5490,43,'3270666','2013-09-25 20:28:11',0,'euclid 0 _ = (0, 0)\r\neuclid _ 0 = (0, 0)\r\neuclid a b = if (a > b)\r\n	then euclid\' a b [] 0 False\r\n	else euclid\' b a [] 0 True\r\n\r\neuclid\' a b qs n reflect = let q = a `div` b\r\n                               r = a `mod` b\r\n                           in case r of\r\n                           	  1 -> let res = solve_r (n + 1) (q:qs)\r\n                           	       in output (sum (fst res), sum (snd res)) reflect\r\n                           	  0 -> (0, 0)\r\n                           	  _ -> euclid\' b r (q:qs) (n + 1) reflect\r\n--                           in if (r == 1)\r\n--                  	then let res = solve_r (n + 1) (q:qs)\r\n--                  	     in output (sum (fst res), sum (snd res)) reflect\r\n--                   	else euclid\' b r (q:qs) (n + 1) reflect\r\n\r\nsolve_r 1 [q0] = ([1], [-q0])\r\nsolve_r 2 [q1, q0] = ([-q1], [1, q1*q0])\r\nsolve_r n (qn:qn_1:qs) = (fst (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (fst (solve_r (n - 1) (qn_1:qs)))),\r\n	snd (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (snd (s','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5489,43,'3270666','2013-09-25 20:26:50',0,'euclid 0 _ = error \"Numbers are not coprime\"\r\neuclid _ 0 = error \"Numbers are not coprime\"\r\neuclid a b = if (a > b)\r\n	then euclid\' a b [] 0 False\r\n	else euclid\' b a [] 0 True\r\n\r\neuclid\' a b qs n reflect = let q = a `div` b\r\n                               r = a `mod` b\r\n                           in case r of\r\n                           	  1 -> let res = solve_r (n + 1) (q:qs)\r\n                           	       in output (sum (fst res), sum (snd res)) reflect\r\n                           	  0 -> error \"Numbers are not coprime\"\r\n                           	  _ -> euclid\' b r (q:qs) (n + 1) reflect\r\n--                           in if (r == 1)\r\n--                  	then let res = solve_r (n + 1) (q:qs)\r\n--                  	     in output (sum (fst res), sum (snd res)) reflect\r\n--                   	else euclid\' b r (q:qs) (n + 1) reflect\r\n\r\nsolve_r 1 [q0] = ([1], [-q0])\r\nsolve_r 2 [q1, q0] = ([-q1], [1, q1*q0])\r\nsolve_r n (qn:qn_1:qs) = (fst (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (fst (solve_r (n - 1','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5488,43,'3270666','2013-09-25 20:07:04',0,'euclid a b = if (a > b)\r\n	then euclid\' a b [] 0 False\r\n	else euclid\' b a [] 0 True\r\n\r\neuclid\' a b qs n reflect = let q = a `div` b\r\n                               r = a `mod` b\r\n                           in if (r == 1)\r\n                  	then let res = solve_r (n + 1) (q:qs)\r\n                  	     in output (sum (fst res), sum (snd res)) reflect\r\n                   	else euclid\' b r (q:qs) (n + 1) reflect\r\n\r\nsolve_r 1 [q0] = ([1], [-q0])\r\nsolve_r 2 [q1, q0] = ([-q1], [1, q1*q0])\r\nsolve_r n (qn:qn_1:qs) = (fst (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (fst (solve_r (n - 1) (qn_1:qs)))),\r\n	snd (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (snd (solve_r (n - 1) (qn_1:qs)))))\r\n\r\noutput answer reflect = if reflect\r\n	then (snd answer, fst answer)\r\n	else answer','Не удалось вычислить выражение \"let (x,y) = euclid 1 0 in 1*x+0*y\", проверьте правильность синтаксиса'),(5483,31,'3226573','2013-09-25 16:02:11',0,'-- parts2\' params: last1 last2 len1 len2 maxSublistLen\r\nparts2\' [] _ _ _ _ = True\r\nparts2\' (x:xs) last1 last2 len1 len2 msl = \r\n        (x > last1 && len1 < msl && parts2\' xs x last2 (len1 + 1) len2 msl) ||\r\n        (x > last2 && len2 < msl && parts2\' xs last1 x len1 (len2 + 1) msl)\r\n\r\nparts2 xs = (mod (length xs) 2 == 0) && \r\n            parts\' xs m1 m1 0 0 ((length xs) / 2) \r\n            where m1 = (minimum xs) - 1','Не удалось вычислить выражение \"parts2 [1, 3, 1, 8, 4, 9]\", проверьте правильность синтаксиса'),(5484,31,'3226573','2013-09-25 16:06:58',0,'-- parts2\' params: last1 last2 len1 len2 maxSublistLen\r\nparts2\' [] _ _ _ _ = True\r\nparts2\' (x:xs) last1 last2 len1 len2 msl = \r\n        (x > last1 && len1 < msl && parts2\' xs x last2 (len1 + 1) len2 msl) ||\r\n        (x > last2 && len2 < msl && parts2\' xs last1 x len1 (len2 + 1) msl)\r\n\r\nparts2 xs = (mod (length xs) 2 == 0) && \r\n            parts2\' xs m1 m1 0 0 ((length xs) / 2) \r\n            where m1 = (minimum xs) - 1','Не удалось вычислить выражение \"parts2 [1, 3, 1, 8, 4, 9]\", проверьте правильность синтаксиса'),(5485,31,'3226573','2013-09-25 16:08:19',0,'-- parts2\' params: last1 last2 len1 len2 maxSublistLen\r\nparts2\' [] _ _ _ _ _ = True\r\nparts2\' (x:xs) last1 last2 len1 len2 msl = \r\n        (x > last1 && len1 < msl && parts2\' xs x last2 (len1 + 1) len2 msl) ||\r\n        (x > last2 && len2 < msl && parts2\' xs last1 x len1 (len2 + 1) msl)\r\n\r\nparts2 xs = (mod (length xs) 2 == 0) && \r\n            parts2\' xs m1 m1 0 0 ((length xs) / 2) \r\n            where m1 = (minimum xs) - 1','Не удалось вычислить выражение \"parts2 [1, 3, 1, 8, 4, 9]\", проверьте правильность синтаксиса'),(5486,31,'3226573','2013-09-25 16:18:06',1,'-- parts2\' params: inputRest last1 last2 len1 len2 maxSublistLen\r\nparts2\' [] _ _ _ _ _ = True\r\nparts2\' (x:xs) last1 last2 len1 len2 msl = \r\n        (x > last1 && len1 < msl && parts2\' xs x last2 (len1 + 1) len2 msl) ||\r\n        (x > last2 && len2 < msl && parts2\' xs last1 x len1 (len2 + 1) msl)\r\n\r\nparts2 xs = (mod (length xs) 2 == 0) && \r\n            parts2\' xs m1 m1 0 0 (div (length xs) 2)\r\n            where m1 = (minimum xs) - 1','<br/>Тесты успешно пройдены!'),(5487,43,'3270666','2013-09-25 20:02:28',0,'euclid a b = if (a > b)\r\n	then euclid\' a b [] 0\r\n	else euclid\' b a [] 0\r\n\r\neuclid\' a b qs n = let q = a `div` b\r\n                       r = a `mod` b\r\n                   in if (r == 1)\r\n                  	then let res = solve_r (n + 1) (q:qs)\r\n                  	     in (sum (fst res), sum (snd res))\r\n                   	else euclid\' b r (q:qs) (n + 1)\r\n\r\nsolve_r 1 [q0] = ([1], [-q0])\r\nsolve_r 2 [q1, q0] = ([-q1], [1, q1*q0])\r\nsolve_r n (qn:qn_1:qs) = (fst (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (fst (solve_r (n - 1) (qn_1:qs)))),\r\n	snd (solve_r (n - 2) qs) ++ (map (x -> -(x * qn)) (snd (solve_r (n - 1) (qn_1:qs)))))','Выражение имеет неправильное значение: let (x,y) = euclid 3 5 in 3*x+5*y'),(5482,33,'3226573','2013-09-25 13:51:50',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace IntegralTask\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static float Integral(Func<float, float> f, float a, float b)\r\n\r\n        {\r\n\r\n            int n = 100;\r\n\r\n            float add = (b - a) / n;\r\n\r\n            float res = 0;\r\n\r\n\r\n\r\n            float cur = a + add / 2;\r\n\r\n            for (int i = 0; i < n; i++)\r\n\r\n            {\r\n\r\n                res += f(cur);\r\n\r\n                cur += add;\r\n\r\n            }\r\n\r\n            return res;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            Func<float, float> sqr = i => i * i;\r\n\r\n\r\n\r\n            float a = 0;\r\n\r\n            float b = 1;\r\n\r\n            Console.WriteLine(Integral(sqr, a, b));\r\n\r\n            Console.WriteLine(Integral(i => i*i*i, a, b));\r\n\r\n\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5481,30,'3226573','2013-09-25 12:43:00',1,'updateGCD a b = if b == 0 then a\r\n                else gcd a b\r\n\r\nparts\' [] _ len gComDiv = (updateGCD len gComDiv) > 1\r\nparts\' (x:xs) prev len gComDiv = if x > prev then parts\' xs x (len + 1) gComDiv\r\n                                 else if (updateGCD len gComDiv) == 1 then False\r\n                                 else parts\' xs x 1 (updateGCD len gComDiv)\r\n\r\nparts (x:xs) = parts\' xs x 1 0','<br/>Тесты успешно пройдены!'),(5480,51,'romos2007','2013-09-25 01:24:00',1,'{--\r\n\r\nЗадача 9-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nrepeatFunc f n = foldr (.) f (map (\\_ -> f) [1..(n-1)])\r\n\r\n\r\n\r\nsi3 x = let f = repeatFunc sin 3\r\n\r\n				in f x\r\n','<br/>Тесты успешно пройдены!'),(5479,52,'romos2007','2013-09-25 01:22:58',1,'{--\r\n\r\nЗадача 9-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-\r\n\r\nСкажите, пожалуйста, можно ли засчитать эту задачу и за предыдущую?\r\n\r\n-}\r\n---Да, конечно\r\n\r\n\r\nrepeatFunc f n = foldr (.) f (map (\\_ -> f) [1..(n-1)])\r\n\r\n\r\n\r\nsi3 x = let f = repeatFunc sin 3\r\n\r\n				in f x\r\n','<br/>Тесты успешно пройдены!'),(5478,45,'ArtemK','2013-09-25 00:25:12',1,'# Python\r\n# А мне понравилась эта сторона питона (:\r\n  --- Это приятно:)\r\ndef check(l):\r\n    return all(any(x % 2 == 0 for x in ll) for ll in l)\r\n\r\nprint(check([[1, 2, 3], [1, 3]]))\r\n# False\r\nprint(check([[2, 3], [2]]))\r\n# True','<br/>Тесты успешно пройдены!'),(5477,31,'ArtemK','2013-09-24 23:51:06',1,'parts2 xs = let m = minimum xs in parts2\' xs (m-1) (m-1) 0 0\r\n-- Лишние 2 правила от оставшихся в голове условий предыдущей задачи (:\r\nparts2\' [] _ _ alen blen = alen == blen\r\nparts2\' (x:xs) amax bmax alen blen = if x > amax && x > bmax then\r\n                                (parts2\' xs x bmax (alen+1) blen) || \r\n                                (parts2\' xs amax x alen (blen+1))\r\n                            else if x > amax then parts2\' xs x bmax (alen+1) blen\r\n                            else if x > bmax then parts2\' xs amax x alen (blen+1)\r\n                            else False','<br/>Тесты успешно пройдены!'),(5476,31,'ArtemK','2013-09-24 23:48:07',0,'parts2 xs = let m = minimum xs in parts2\' xs (m-1) (m-1) 0 0\r\nparts2\' [] _ _ 1 _ = False\r\nparts2\' [] _ _ _ 1 = False\r\nparts2\' [] _ _ alen blen = alen == blen\r\nparts2\' (x:xs) amax bmax alen blen = if x > amax && x > bmax then\r\n                                (parts2\' xs x bmax (alen+1) blen) || \r\n                                (parts2\' xs amax x alen (blen+1))\r\n                            else if x > amax then parts2\' xs x bmax (alen+1) blen\r\n                            else if x > bmax then parts2\' xs amax x alen (blen+1)\r\n                            else False','Выражение имеет неправильное значение: parts2 [1, 1]'),(5475,30,'ArtemK','2013-09-24 23:30:14',1,'parts [] = False\r\nparts (x:xs) = parts\' xs 1 0 x\r\nparts\' [] 1 _ _ = False\r\nparts\' [] _ 1 _ = False\r\nparts\' [] cur prev _ = not ((if prev == 0 then cur else gcd cur prev) == 1)\r\nparts\' (x:xs) cur prev l = if x > l\r\n                           then parts\' xs (cur+1) prev x\r\n                           else parts\' xs 1 (if prev == 0 then cur else gcd cur prev) x','<br/>Тесты успешно пройдены!'),(5474,30,'ArtemK','2013-09-24 23:22:18',0,'parts [] = False\r\nparts (x:xs) = parts\' xs 1 0 x\r\nparts\' [] 1 _ _ = False\r\nparts\' [] _ 1 _ = False\r\nparts\' [] _ _ _ = True\r\nparts\' (x:xs) cur prev l = if x > l\r\n                           then parts\' xs (cur+1) prev x\r\n                           else parts\' xs 1 (if prev == 0 then cur else gcd cur prev) x','Выражение имеет неправильное значение: parts [4, 6, 3, 5, 7]'),(5473,42,'romos2007','2013-09-24 22:43:25',1,'{--\r\n\r\nЗадача 9-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nmyfoldl f e [] = e\r\n\r\nmyfoldl f e (x:xs) = myfoldl f (f e x) xs\r\n','<br/>Тесты успешно пройдены!'),(5470,51,'115753099','2013-09-24 21:59:00',1,'import Data.List\r\n\r\nrepeatFunc f n =\r\n	x -> last (take (n + 1) (iterate f x))','<br/>Тесты успешно пройдены!'),(5471,52,'115753099','2013-09-24 21:59:35',1,'import Data.List\r\n\r\nrepeatFunc f n =\r\n	x -> last (take (n + 1) (iterate f x))','<br/>Тесты успешно пройдены!'),(5472,41,'romos2007','2013-09-24 22:14:59',1,'{--\r\n\r\nЗадача 9-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ncountOdd [] = 0\r\n  --- Это правило не нужно, оно следует из второго (и то же в countOdd1 и countOdd1\')\r\ncountOdd xs = foldr (x i->if mod x 2 == 0 then i else i+1 ) 0 xs\r\n\r\n\r\n\r\ncountOdd1 [] = 0\r\n\r\ncountOdd1 xs = length (filter (x->mod x 2 /= 0) xs)\r\n\r\n\r\n\r\ncountOdd1\' [] = 0\r\n\r\ncountOdd1\' xs = sum (map (x->mod x 2) xs)\r\n','<br/>Тесты успешно пройдены!'),(5469,51,'115753099','2013-09-24 21:57:44',0,'import Data.List\r\n\r\nrepeatFunc f n =\r\n	x -> last (take n (iterate f x))','Выражение имеет неправильное значение: (repeatFunc (*2) 3) 1'),(5467,52,'15309342','2013-09-24 20:39:53',1,'repeatFunc f n = foldl (g x -> f . g) id (take n [1, 1..])\r\n','<br/>Тесты успешно пройдены!'),(5468,40,'romos2007','2013-09-24 21:44:35',1,'{--\r\n\r\nЗадача 9-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\nidentity n = map (i -> map (j->if j==i then 1 else 0) [1..n]) [1..n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5465,42,'115753099','2013-09-24 20:32:21',1,'myfoldl _ e [] = e\r\nmyfoldl f e (x:xs) = myfoldl f (e `f` x) xs\r\n\r\n---Михаил Лазаревич, foldr, который написан у Вас в слайдах, у меня работает неправильно:\r\n---foldr (-) 1 [1,2,3] === 1\r\n---ffoldr (-) 1 [1,2,3] === 0\r\nffoldr f e [] = e\r\nffoldr f e (x:xs) = f e (ffoldr f e xs)','<br/>Тесты успешно пройдены!'),(5466,33,'1170660','2013-09-24 20:37:45',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace Simpson\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n      \r\n\r\n        static double Integral(Func<double, double> f, int a,int b)\r\n\r\n        {int n =50;\r\n\r\n		 double sum=0,sum2=0;\r\n\r\n		 double[] x=new double[n];\r\n\r\n		 double h=(b-a)/n;\r\n\r\n		 for(int i=0;i<n;i++){\r\n\r\n							x[i]=a+i*h;\r\n\r\n						}\r\n\r\n		 for(int i=1;i<n;i++){\r\n\r\n								sum+=f(x[i]);\r\n\r\n								sum2+=f((x[i-1]+x[i])/2);\r\n\r\n          }\r\n\r\n		return h/6*(f(a)+f(b)+2*sum+4*(sum2+b));\r\n\r\n            \r\n\r\n        }\r\n\r\n\r\n\r\n        static double Cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            double resultLambda=0;\r\n\r\n            double result=0;\r\n\r\n			\r\n\r\n            result=Integral(Cube, 1,10); \r\n\r\n            resultLambda=Integral(i => i*i*i, 1,10);\r\n\r\n			Console.WriteLine(result);\r\n\r\n			Console.WriteLine(resultLambda);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5464,51,'15309342','2013-09-24 20:31:48',1,'repeatFunc f n = repeatFunc1 f n id\r\nrepeatFunc1 f 0 g = g\r\nrepeatFunc1 f n g = repeatFunc1 f (n - 1) f . g','<br/>Тесты успешно пройдены!'),(5456,41,'115753099','2013-09-24 19:56:00',1,'import Data.List\r\n\r\ncountOdd xs = foldr (x acc -> if x `mod` 2 == 1 then (acc + 1) else acc) 0 xs\r\n\r\ncountOdd1 xs = foldl (acc x -> if x `mod` 2 == 1 then (acc + 1) else acc) 0 xs','<br/>Тесты успешно пройдены!'),(5457,42,'5543298','2013-09-24 19:56:30',1,'import Debug.Trace\r\n\r\n\r\n\r\nmyfoldl _ res [] = res\r\n\r\nmyfoldl op initValue (x:xs) = let newValue = op initValue x in trace (show initValue)  myfoldl op newValue xs \r\n','<br/>Тесты успешно пройдены!'),(5458,40,'15309342','2013-09-24 20:13:50',1,'identity n = identity1 n n\r\nidentity1 n 1 = [kvector n 1]\r\nidentity1 n k = (kvector n k) : (identity1 n (k - 1))\r\nkvector 1 k | (k == 1) = [1]\r\n	    | otherwise = [0]\r\nkvector n k | (n == k) = 1 : (kvector (n - 1) k)\r\n	    | otherwise = 0 : (kvector (n - 1) k)','<br/>Тесты успешно пройдены!'),(5459,41,'15309342','2013-09-24 20:14:23',1,'countOdd list = foldr (x n -> if odd x then n + 1 else n) 0 list\r\n\r\ncountOdd1 = sum . map (`mod` 2)','<br/>Тесты успешно пройдены!'),(5460,40,'5543298','2013-09-24 20:15:26',1,'getRow n i xs = if (0 == n) then xs else getRow (n - 1)(i - 1) (if (i == 1) then (1:xs) else (0:xs))  \r\n\r\ngetResult n i xss = if i == n + 1 then xss else getResult n (i + 1) ((getRow n i []):xss)  \r\n\r\nidentity n = getResult n 1 []\r\n\r\n\r\n\r\nidentity1 n = map (x -> map (y -> if (x == y) then 1 else 0) [1..n]) [1..n]\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5461,51,'5543298','2013-09-24 20:18:42',1,'repeatFunc f 1 = f\r\n\r\nrepeatFunc f n = f.(repeatFunc f (n - 1))\r\n\r\n\r\n\r\nf = repeatFunc sin 3\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5462,42,'15309342','2013-09-24 20:26:10',1,'myfoldl f y [] = y\r\nmyfoldl f y (x:xs) = myfoldl f (f y x) xs','<br/>Тесты успешно пройдены!'),(5463,52,'5543298','2013-09-24 20:31:34',1,'repeatFunc f n = foldl (.) f (map (x -> f) [1..(n - 1)])\r\n\r\n\r\n\r\nf = repeatFunc sin 3\r\n','<br/>Тесты успешно пройдены!'),(5453,52,'anlun','2013-09-24 19:40:02',1,'repeatFunc f n = foldl (x _ -> f . x) id [1..n]','<br/>Тесты успешно пройдены!'),(5454,51,'anlun','2013-09-24 19:41:11',1,'repeatFunc f 0 = id\r\nrepeatFunc f n = f . (repeatFunc f (n - 1))','<br/>Тесты успешно пройдены!'),(5455,41,'5543298','2013-09-24 19:46:27',1,'countOdd xs = foldr (x res -> res + x `mod` 2) 0 xs\r\n\r\ncountOdd1 xs = length (filter (x -> x `mod` 2 == 1) xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5452,42,'anlun','2013-09-24 19:35:33',1,'myfoldl :: (a -> b -> a) -> a -> [b] -> a\r\nmyfoldl _ v [] = v\r\nmyfoldl f v (x:xs) = myfoldl f (f v x) xs','<br/>Тесты успешно пройдены!'),(5451,40,'115753099','2013-09-24 19:34:52',1,'import Data.List\r\n\r\nidentity n = \r\n	map (i -> map (x -> if x == i then 1 else 0) [1 ..n]) [1..n]','<br/>Тесты успешно пройдены!'),(5449,40,'anlun','2013-09-24 19:27:20',1,'identity :: Integer -> [[Integer]]\r\nidentity n = [[if x == y then 1 else 0 | y <- [1..n]] | x <- [1..n]]','<br/>Тесты успешно пройдены!'),(5450,41,'anlun','2013-09-24 19:33:13',1,'countOdd  = foldr (x v -> if x `mod` 2 /= 0 then v + 1 else v) 0\r\ncountOdd1 = length . (filter (x -> (x `mod` 2) /= 0))','<br/>Тесты успешно пройдены!'),(5445,41,'517309','2013-09-24 18:30:45',2,'countOdd = sum . map (`mod`2)\r\ncountOdd1 = sum . map (`mod`2)','<br/>Тесты успешно пройдены!'),(5446,42,'517309','2013-09-24 18:32:08',2,'myfoldl = foldl','<br/>Тесты успешно пройдены!'),(5447,52,'517309','2013-09-24 18:34:40',2,'repeatFunc f n = foldr (.) id $ map (const f) [1..n]','<br/>Тесты успешно пройдены!'),(5448,40,'5543298','2013-09-24 19:27:15',0,'getRow n i xs = if (0 == n) then xs else getRow (n - 1)(i - 1) (if (i == 1) then (1:xs) else (0:xs))  \r\n\ngetResult n i xss = if i == n + 1 then xss else getResult n (i + 1) ((getRow n i []):xss)  \r\n\nidentity n = getResult n 1 []\r\n\n\n','<br/>Тесты успешно пройдены!'),(5442,40,'517309','2013-09-24 18:26:24',0,'identity n = [[if i==j then 1 else 0|i<-[1..n]|j<-[1..n]]','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5443,40,'517309','2013-09-24 18:26:56',2,'identity n = [[if i==j then 1 else 0|i<-[1..n]]|j<-[1..n]]','<br/>Тесты успешно пройдены!'),(5444,41,'517309','2013-09-24 18:30:18',0,'contOdd = sum . map (`mod`2)\r\ncontOdd1 = sum . map (`mod`2)','Не удалось вычислить выражение \"countOdd [2, 3, 4, 8, 5, 33, 9]\", проверьте правильность синтаксиса'),(5441,40,'517309','2013-09-24 18:25:41',0,'identity n = [[if i==j then 1 else o|i<=[1..n]|j<-[1..n]]','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5440,40,'517309','2013-09-24 18:25:14',0,'identity [[if i==j then 1 else o|i<=[1..n]|j<-[1..n] ','Не удалось вычислить выражение \"identity 4\", проверьте правильность синтаксиса'),(5439,39,'nomeansno','2013-09-24 17:35:41',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\ncond x y = x == y - 1\r\n\r\n\r\n\r\nminHeight t = minHeight\' t 0 0\r\n\r\n\r\n\r\nminHeight\' (Node _ Empty Empty) h _ = h\r\n\r\nminHeight\' (Node _ Empty r) h maxh = if cond h maxh then maxh\r\n\r\nelse minHeight\' r (h+1) maxh\r\n\r\nminHeight\' (Node _ l Empty) h maxh = if cond h maxh then maxh\r\n\r\nelse minHeight\' l (h+1) maxh\r\n\r\nminHeight\' (Node _ l r) h maxh = if cond h maxh then maxh\r\n\r\nelse minHeight\' r (h+1) (minHeight\' l (h+1) maxh)\r\n','<br/>Тесты успешно пройдены!'),(5436,39,'15309342','2013-09-24 13:24:15',1,'data Tree = Empty | Node Integer Tree Tree\r\nminHeight t = minHeight1 t 0 (1/0)\r\nminHeight1 Empty h mh = mh\r\nminHeight1 (Node e Empty Empty) h mh = h\r\nminHeight1 (Node e l r) h mh | h >= mh = mh\r\n                             | otherwise = minHeight1 r (h + 1) (min mh (minHeight1 l (h + 1) mh))','<br/>Тесты успешно пройдены!'),(5437,43,'1170660','2013-09-24 17:29:43',1,'euclid a b \r\n\r\n  | a == 0 = (0, 1)\r\n\r\n  | otherwise = let (x, y) = euclid (mod b a) a  in (y - (div b a) * x, x)\r\n\r\n \r\n','<br/>Тесты успешно пройдены!'),(5438,39,'nomeansno','2013-09-24 17:34:06',0,'data Tree = Empty | Node Integer Tree Tree\r\n\n\r\n\ncond x y = x == y - 1\r\n\n\r\n\nminHeight\' (Node _ Empty Empty) h _ = h\r\n\nminHeight\' (Node _ Empty r) h maxh = if cond h maxh then maxh\r\n\nelse minHeight\' r (h+1) maxh\r\n\nminHeight\' (Node _ l Empty) h maxh = if cond h maxh then maxh\r\n\nelse minHeight\' l (h+1) maxh\r\n\nminHeight\' (Node _ l r) h maxh = if cond h maxh then maxh\r\n\nelse minHeight\' r (h+1) (minHeight\' l (h+1) maxh)\n','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5435,30,'1170660','2013-09-24 12:31:12',1,'parts (x:xs) = partition xs x 2\r\n\r\n\r\n\r\npartition [] y listLength = True\r\n\r\npartition (x:xs) y listLength\r\n\r\n  | checkLength (x:xs) y (listLength - 1) listLength = True\r\n\r\n  | x > y = partition xs x (listLength + 1)\r\n\r\n  | otherwise = False\r\n\r\n\r\n\r\ncheckLength [] y partLemgth listLength\r\n\r\n  | partLemgth == listLength = True\r\n\r\n  | otherwise = False\r\n\r\n  \r\n\r\ncheckLength (x:xs) y partLemgth listLength\r\n\r\n  | partLemgth == listLength = checkLength xs x 1 listLength\r\n\r\n  | x > y = checkLength xs x (partLemgth + 1) listLength\r\n\r\n  | otherwise = False\r\n','<br/>Тесты успешно пройдены!'),(5428,37,'6053606','2013-09-23 23:00:32',1,'minsum xs = minimum $ map ((x, y) -> x + y) $ zip xs (tail xs)\r\n','<br/>Тесты успешно пройдены!'),(5429,36,'6053606','2013-09-23 23:02:50',1,'cubeTable n = zip [1..n] $ map (^3) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5430,38,'6053606','2013-09-23 23:11:48',1,'data Tree = Empty\r\n          | Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n','<br/>Тесты успешно пройдены!'),(5431,39,'6053606','2013-09-23 23:24:53',0,'data Tree = Empty\r\n          | Node Integer Tree Tree\r\n\r\nminHeight t = minimum $ go t 0 where\r\n  go Empty h = [h]\r\n  go (Node _ Empty Empty) h = [h]\r\n  go (Node _ l r) h = go l (h + 1) ++ go r (h + 1)\r\n','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),(5432,39,'6053606','2013-09-23 23:37:08',2,'  --- Нет, тут нужно было реализовать оптимизацию, о которой мы говорили.\r\n  --- Вы можете спросить у кого-нибудь, но, если коротко, надо как-то не обходить\r\n  ---  ветки, в которых точно нет минимума. Например, если вы уже нашди лист на расстоянии 3,\r\n  --- в дерево нет смысла заходить глубже, чем на 3\r\n  --- Попробуйте, если хотите, что-ybmelm в таком роде написать до следующей пары?    \r\ndata Tree = Empty\r\n          | Node Integer Tree Tree\r\n\r\nminHeight Empty = 0\r\nminHeight t = minimum $ go t 0 where\r\n  go Empty h = []\r\n  go (Node _ Empty Empty) h = [h]\r\n  go (Node _ l r) h = go l (h + 1) ++ go r (h + 1)\r\n','<br/>Тесты успешно пройдены!'),(5433,35,'6053606','2013-09-23 23:44:17',1,'isosc a b c = ab == bc || ab == ac || ac == bc where\r\n  ab = a `dist` b\r\n  bc = b `dist` c\r\n  ac = a `dist` c\r\n\r\n  (x1, y1) `dist` (x2, y2)  = sqrt $ (x2 - x1)^2 + (y2 - y1)^2\r\n','<br/>Тесты успешно пройдены!'),(5434,37,'15309342','2013-09-24 10:33:42',1,'minsum :: [Integer] -> Integer\r\nminsum (y:x:xs) = fst $ foldl f (x + y, x) xs\r\nf x y = if (fst x) < (snd x + y) then (fst x, y) else (snd x + y, y)','<br/>Тесты успешно пройдены!'),(5427,39,'romos2007','2013-09-23 22:04:25',1,'{--\r\n\r\nЗадача 6-5\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Empty\r\n\r\n			| Node Integer Tree Tree\r\n\r\n			deriving Eq\r\n\r\n\r\n\r\n{-	Функция minHeight вызывает ф-цию bfs, реализующую\r\n\r\n	обычный поиск в ширину с целью найти первый попавшийся лист и\r\n\r\n	выдать высоту этого листа.\r\n\r\n\r\n\r\n	С отсечением по высоте как-то не хотелось делать... :-)\r\n\r\n-}\r\n\r\nminHeight Empty = 0\r\n\r\nminHeight (Node i l r) = bfs 0 [(Node i l r)]\r\n\r\n\r\n\r\n{- 	bfs - поиск в ширину\r\n\r\n	Заключается в \"поуровневом\" просмотре вершин дерева, начиная с корня.\r\n\r\n	Ведется подсчет текущей высоты дерева, т.е. при переходе на след.уровень\r\n\r\n	высота увеличивается на 1 (такого рода аккумулирующий параметр)\r\n\r\n\r\n\r\n	h - высота текущего уровня\r\n\r\n	ns - список вершин на текущем уровне\r\n\r\n-}\r\n\r\nbfs h ns = 	if check ns	-- если среди соседних вершин текущего уровня есть лист,\r\n\r\n			then h 		-- то нужно закончить и выдать высоту h\r\n\r\n			else bfs (h+1) (childs ns) 	--иначе, если листа не нашлось, искать на след.уровне,\r\n\r\n										--увеличив высоту на 1.\r\n\r\n\r\n\r\n{- 	Поиск листа в массиве вершин\r\n\r\n	Лист - если оба потомка у него пустые.\r\n\r\n-}\r\n\r\ncheck [] = False\r\n\r\ncheck ((Node _ l r):ns)\r\n\r\n	|l == Empty && r == Empty = True\r\n\r\n	|otherwise = check ns\r\n\r\n\r\n\r\n{-	Составление списка детей от всех текущих узлов дерева\r\n\r\n	Включаем в список детей, очевидно, только непустые узлы.\r\n\r\n-}\r\n\r\nchilds [] = []\r\n\r\nchilds ((Node _ l r):ns)\r\n\r\n	|l /= Empty && r /= Empty = l:r:childs ns\r\n\r\n	|l /= Empty = l:childs ns\r\n\r\n	|r /= Empty = r:childs ns\r\n\r\n\r\n\r\n{-\r\n\r\n	Возможная оптимизация, видимо, заключается в том, чтобы \r\n\r\n	не делать два прохода по списку вершин (внутри ф-ций check и childs),\r\n\r\n	а сразу при проверке в check давать массив \"детей\".\r\n\r\n-}\r\n','<br/>Тесты успешно пройдены!'),(5426,33,'toskira','2013-09-23 21:49:20',1,'using System;\r\n\r\nnamespace IntegralCalculator {\r\n\r\n	class IntegralCalculator {\r\n\r\n		private const int N = 100;\r\n\r\n		static double Integral(Func<double, double> f, double a, double b) {\r\n			double sum1 = 0;\r\n			double sum2 = 0;\r\n			double step = (b - a) / (double)(N * 2);\r\n			for(double i = a + step; i < b; i += step * 2.0) {\r\n				sum1 += f(i);\r\n				sum2 += f(i + step);\r\n			}\r\n			return (b - a) * (f(a) + 4.0 * sum1 + 2.0 * sum2 - f(b)) / (6 * N);\r\n		}\r\n\r\n		static double f1(double i) {\r\n			return i * i;\r\n		}\r\n\r\n		static Func<double, double> f2 = x => Math.Sin(x);\r\n\r\n		static void Main(string[] args) {\r\n			Console.WriteLine(Integral(f1, 0, 1));\r\n			Console.WriteLine(Integral(f2, -1, 1));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5424,30,'1170660','2013-09-23 18:35:51',0,'parts(x:xs) = f xs x [x] []\r\n\n\r\n\nf [] k temp (l:ll) = check ll l True\r\n\nf (x:xs) k temp ll = if(x>k) then f xs x (x:temp) ll else f xs x (x:[]) ((length temp):ll)\r\n\n\r\n\ncheck [] k p= p \r\n\ncheck (x:xs) k p = if( x == k && p) then check xs k p else check xs k False\r\n\n\r\n\n\n','Не удалось вычислить выражение \"parts [1, 2, 3, 4, 5]\", проверьте правильность синтаксиса'),(5425,30,'1170660','2013-09-23 18:45:40',0,'parts(x:xs) = f xs x [x] []\r\n\n\r\n\nf [] k temp ll = check\' ((length temp):ll)\r\n\nf (x:xs) k temp ll = if(x>k) then f xs x (x:temp) ll else f xs x (x:[]) ((length temp):ll)\r\n\n\r\n\ncheck\' (l:ll) = check ll l True\r\n\ncheck [] k p= p \r\n\ncheck (x:xs) k p = if( x == k && p) then check xs k p else check xs k False\r\n\n\r\n\n\n','Выражение имеет неправильное значение: parts [1, 2, 1, 2, 3, 4]'),(5423,39,'3270666','2013-09-23 15:56:07',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight (Node val l r) = mh [((Node val l r), 0)]\r\n\r\nmh (((Empty), h):xs) = mh xs\r\nmh (((Node val l r), h):xs) = if (isLeaf (Node val l r))\r\n	then h\r\n	else mh (xs ++ [(l, h + 1), (r, h + 1)])\r\n\r\nisLeaf (Node _ Empty Empty) = True\r\nisLeaf (Node _ _ _) = False','<br/>Тесты успешно пройдены!'),(5421,38,'3270666','2013-09-23 15:33:18',1,'  --- Задачи сданы сильно после срока :( \r\n  --- Крайний срок - 13:40\r\n  --- Я вас по этому засчитал 3 задачи из 5. Но пожалуйста, присылайте вовремя,\r\n  --- в следующий раз вообще не засчитаю.\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node val l r) = max (height l + 1) (height r + 1)','<br/>Тесты успешно пройдены!'),(5422,38,'15309342','2013-09-23 15:43:28',1,'  --- Задачи, к сожалению, присланы сильно позже срока.\r\n  --- Я вас то этому одну произвольную задачу не засчитываю.\r\n  --- Но вообще присылайте, пожалуйста, не позже 13:40, я вообще в таких случаях\r\n  --- на засчитываю все.\r\ndata Tree = Empty | Node Integer Tree Tree\r\nheight Empty = -1\r\nheight (Node e l r) = max (height l) (height r) + 1','<br/>Тесты успешно пройдены!'),(5419,36,'3270666','2013-09-23 15:25:27',1,'cubeTable n = zip ([1..n]) (map (x -> x * x * x) [1..n])','<br/>Тесты успешно пройдены!'),(5420,37,'3270666','2013-09-23 15:28:52',1,'  --- То же, не засчитано, потому что позже срока\r\nminsum (x:xs) = minimum (map (x -> fst x + snd x) (zip (x:xs) xs))','<br/>Тесты успешно пройдены!'),(5416,35,'15309342','2013-09-23 14:47:22',1,'isosc a b c = (sqd a b b c || sqd b c a c || sqd a b a c)\r\nsqd (x1, x2) (y1, y2) (z1, z2) (t1, t2) = (((y1 - x1)^2 + (y2 - x2)^2) == ((t1 - z1)^2 + (t2 - z2)^2))','<br/>Тесты успешно пройдены!'),(5417,36,'15309342','2013-09-23 14:57:57',1,'cubeTable n = zip [1..n] (map (^3) [1..n])','<br/>Тесты успешно пройдены!'),(5418,35,'3270666','2013-09-23 15:13:51',1,'isosc a b c = if ((snd b - snd a) / (fst b - fst a) == (snd c - snd a) / (fst c - fst a))\r\n	then False -- точки лежат на одной прямой\r\n	else check a b c\r\n\r\ncheck a b c = let ab = sqrt (sqr (fst a - fst b) + sqr (snd a - snd b))\r\n                  ac = sqrt (sqr (fst a - fst c) + sqr (snd a - snd c))\r\n                  bc = sqrt (sqr (fst b - fst c) + sqr (snd b - snd c))\r\n                  sqr x = x * x\r\n              in (ab == ac) || (ab == bc) || (ac == bc)','<br/>Тесты успешно пройдены!'),(5410,33,'5247795','2013-09-23 12:01:33',1,'using System;\r\n\r\nnamespace RectangleMethod\r\n{\r\n	class Program\r\n	{\r\n\r\n		static void RectangleMethod(Func<double, double> f, int a, int b)\r\n		{\r\n			double n = 100;\r\n			double h = (b - a) / n;\r\n			double sum = 0;\r\n\r\n			for (int i = 1; i <= n; i++)\r\n			{\r\n				double x = a + i * h;\r\n				sum += f(x - h / 2);\r\n			}\r\n			Console.WriteLine(h * sum);\r\n		}\r\n\r\n		static void Main(string[] args)\r\n		{\r\n			// Примеры вызова с лямбда выражениями:\r\n\r\n			RectangleMethod(i => i, 0, 10);\r\n			RectangleMethod(i => i * i, 0, 1);\r\n			RectangleMethod(i => i * i, 0, 10);\r\n			RectangleMethod(i => i * i * i, 0, 10);\r\n\r\n			Console.ReadKey();\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(5411,33,'nbumakov','2013-09-23 12:08:57',0,'using System;\r\nusing System.Linq;\r\n\r\nnamespace hw_5\r\n{\r\n	class Task5\r\n	{\r\n        const int MethodSteps = 1000;\r\n\r\n		static double Integral( double a, double b, Func<double, double> funcrion)\r\n		{\r\n\r\n            var step = (b - a) / MethodSteps;\r\n			var integral = 0d;\r\n            for (int i = 0; i < MethodSteps; i++)\r\n			{\r\n				integral += funcrion(a + i * step) * step ;\r\n			}\r\n			\r\n			return integral;\r\n		}\r\n\r\n		static double F(double x)\r\n		{\r\n			return x * x;\r\n		}\r\n\r\n        static double F2(double x)\r\n        {\r\n            return x;\r\n        }\r\n\r\n		static void Main(string[] args)\r\n		{\r\n            Console.WriteLine(Integral(0, 1, F));\r\n			Console.WriteLine(Integral(0, 1, F2));\r\n            Console.ReadLine();\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(5412,38,'MaryK','2013-09-23 12:15:00',0,'module Func where\r\n\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..),max, (&&), (>), (<), head, tail, (++),sqrt, snd,fst, (||), zip, map)\r\n\ndata Tree = Empty | Node Int Tree Tree\r\n\nheight :: (Tree) -> Int\r\n\nheight Empty = 0\r\n\nheight (Node 1 Empty Empty) = 0\r\n\nheight (Node x t1 t2) = 1 + (max(height t1) (height t2))\n','Выражение имеет неправильное значение: height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)'),(5413,38,'MaryK','2013-09-23 12:20:07',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..),max, (&&), (>), (<), head, tail, (++),sqrt, snd,fst, (||), zip, map)\r\n\r\ndata Tree = Empty | Node Int Tree Tree\r\n\r\nheight :: (Tree) -> Int\r\n\r\nheight Empty = -1\r\n\r\nheight (Node x t1 t2) = (1 + (max(height t1) (height t2)))\r\n','<br/>Тесты успешно пройдены!'),(5414,33,'nbumakov','2013-09-23 12:22:51',1,'using System;\r\n\r\nnamespace hw_5\r\n{\r\n	class Task5\r\n	{\r\n        const int MethodSteps = 1000;\r\n\r\n		static double Integral( double a, double b, Func<double, double> funcrion)\r\n		{\r\n\r\n            var step = (b - a) / MethodSteps;\r\n			var integral = 0d;\r\n            for (int i = 0; i < MethodSteps; i++)\r\n			{\r\n				integral += funcrion(a + i * step) * step ;\r\n			}\r\n			\r\n			return integral;\r\n		}\r\n\r\n		static double F(double x)\r\n		{\r\n			return x * x;\r\n		}\r\n\r\n        static double F2(double x)\r\n        {\r\n            return x;\r\n        }\r\n\r\n		static void Main(string[] args)\r\n		{\r\n            Console.WriteLine(Integral(0, 1, F));\r\n			Console.WriteLine(Integral(0, 1, F2));\r\n            Console.ReadLine();\r\n		}\r\n	}\r\n}','<br/>Тесты успешно пройдены!'),(5415,37,'MaryK','2013-09-23 13:48:17',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..),minimum, (&&), (>), (<), head, tail, (++),sqrt, snd,fst, (||), zip, map)\r\n\r\nsum::(Int,Int)->Int\r\n\r\nsum a = fst a + snd a\r\n\r\nminsum::[Int]->Int\r\n\r\nminsum (x:xs) = minimum(map sum (zip (x:xs) xs))\r\n','<br/>Тесты успешно пройдены!'),(5407,38,'nbumakov','2013-09-23 10:31:08',1,'data Tree = Empty | Node Integer Tree Tree\r\nheight Empty = -1\r\nheight (Node _ left right) = 1 + max (height left) (height right)','<br/>Тесты успешно пройдены!'),(5408,39,'SNNatalieS','2013-09-23 11:26:37',2,'  --- Нет, тут все сложнее.. Если хотите можете попробовать до следующего занятия исправить,\r\n  --- но вообще это не очень простая задача. \r\ndata Tree = Empty | \r\n		Node Integer Tree Tree\r\nminHeight  Empty = 0\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ l r) = 1 + min (minHeight  l) (minHeight r)','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),(5409,37,'nbumakov','2013-09-23 11:45:11',1,'minsum (x:xs) = \r\n        minimum (tail (foldl ((y:ys) t -> (t:(t + y):ys)) [x] xs))','<br/>Тесты успешно пройдены!'),(5405,35,'nbumakov','2013-09-23 10:30:09',1,'lgth :: (Double, Double) -> (Double, Double) -> Double\r\nlgth (x1, y1) (x2, y2) = sqrt ((x1 - x2) ^ (2 :: Integer) + (y1 - y2) ^ (2 :: Integer))\r\n\r\n\r\nisosc :: (Double, Double) -> (Double, Double) -> (Double, Double) -> Bool\r\nisosc x y z =\r\n        let \r\n        l1 = lgth x y\r\n        l2 = lgth x z\r\n        l3 = lgth y z   \r\n        in l1 == l2 || l1 == l3 || l2 == l3 ','<br/>Тесты успешно пройдены!'),(5406,36,'nbumakov','2013-09-23 10:30:35',1,'cubeTable n = map (i -> (i, i^3)) [1..n]','<br/>Тесты успешно пройдены!'),(5404,33,'toskira','2013-09-23 03:14:45',2,'--- Вообще все правильно, но обратите пожалуйста внимание на условие - в этой задаче надо присылать\r\n--- именно целую программу с примерами вызова, а не фрагмент программы.\r\n--- Те выложите, пожалуйста, полный текст, и я ее зачту. \r\nprivate const int N = 100;\r\n\r\nstatic double Integral(Func<double, double> f, double a, double b) {\r\n	double sum1 = 0;\r\n	double sum2 = 0;\r\n	double step = (b - a) / (double)(N * 2);\r\n	for(double i = a + step; i < b; i += step * 2.0) {\r\n		sum1 += f(i);\r\n		sum2 += f(i + step);\r\n	}\r\n	return (b - a) * (f(a) + 4.0 * sum1 + 2.0 * sum2 - f(b)) / (6 * N);\r\n}','<br/>Тесты успешно пройдены!'),(5403,31,'toskira','2013-09-23 02:45:27',1,'-- O(N^2)\r\n\r\n\r\n\r\ndata Pair = Empty |\r\n\r\n             Pair Integer Integer\r\n\r\n    deriving Show\r\n\r\n\r\n\r\ndata Cell = Cell Pair Pair\r\n\r\n    deriving Show\r\n\r\n\r\n\r\nparts2 list = let even = (mod (length list) 2) == 0\r\n\r\n                  n = (div (length list) 2)\r\n\r\n                  table = create_table [[(Cell (Pair (-1) (-1)) (Pair (-1) (-1)))]] n list 0\r\n\r\n              in even && (check_result table n)\r\n\r\n\r\n\r\nnew_pair (Cell Empty Empty) _ _ _ = Empty\r\n\r\nnew_pair (Cell v Empty) value f1 f2\r\n\r\n    | (f1 v) < value = Pair (f2 v) value\r\n\r\n    | otherwise = Empty\r\n\r\nnew_pair (Cell Empty h) value f1 f2\r\n\r\n    | (f1 h) < value = Pair (f2 h) value\r\n\r\n    | otherwise = Empty\r\n\r\nnew_pair (Cell v h) value f1 f2\r\n\r\n    | (f1 v) < value && (f1 h) < value = Pair (min (f2 v) (f2 h)) value\r\n\r\n    | (f1 v) < value = Pair (f2 v) value\r\n\r\n    | (f1 h) < value = Pair (f2 h) value\r\n\r\n    | otherwise = Empty\r\n\r\n\r\n\r\nfirst  (Pair a _) = a\r\n\r\nsecond (Pair _ b) = b\r\n\r\n\r\n\r\nswap_pair (Empty) = Empty\r\n\r\nswap_pair (Pair a b) = Pair b a\r\n\r\n\r\n\r\nnew_pair_h c value = swap_pair (new_pair c value first second)\r\n\r\nnew_pair_v c value = new_pair c value second first\r\n\r\n\r\n\r\nnew_cell v h value = Cell (new_pair_v v value) (new_pair_h h value)\r\n\r\n\r\n\r\nadd_line [] p value x _ n\r\n\r\n    | x <= n = [[new_cell (Cell Empty Empty) p value]]\r\n\r\n    | otherwise = []\r\n\r\nadd_line ((h:t):t\') p value x y n\r\n\r\n    | y > n = ((h:t):(add_line t\' h value (x + 1) (y - 1) n))\r\n\r\n    | x > n = []\r\n\r\n    | otherwise = let new_c = new_cell h p value\r\n\r\n                  in ((new_c:h:t):(add_line t\' h value (x + 1) (y - 1) n))\r\n\r\n\r\n\r\ncreate_table table _ [] _ = table\r\n\r\ncreate_table table n (h:t) c = let c\' = c + 1\r\n\r\n                                   table\' = add_line table (Cell Empty Empty) h 0 c\' n\r\n\r\n                               in create_table table\' n t c\'\r\n\r\n\r\n\r\ncheck_result (((Cell Empty Empty):_):_) 0 = False\r\n\r\ncheck_result _ 0 = True\r\n\r\ncheck_result (_:t) n = check_result t (n - 1)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5402,31,'toskira','2013-09-23 02:42:57',0,'-- O(N^2)\r\n\n\r\n\ndata Pair = Empty |\r\n\n             Pair Integer Integer\r\n\n    deriving Show\r\n\n\r\n\ndata Cell = Cell Pair Pair\r\n\n    deriving Show\r\n\n\r\n\nparts2 list = let n = (div (length list) 2)\r\n\n                  table = create_table [[(Cell (Pair (-1) (-1)) (Pair (-1) (-1)))]] n list 0\r\n\n              in check_result table n\r\n\n\r\n\nnew_pair (Cell Empty Empty) _ _ _ = Empty\r\n\nnew_pair (Cell v Empty) value f1 f2\r\n\n    | (f1 v) < value = Pair (f2 v) value\r\n\n    | otherwise = Empty\r\n\nnew_pair (Cell Empty h) value f1 f2\r\n\n    | (f1 h) < value = Pair (f2 h) value\r\n\n    | otherwise = Empty\r\n\nnew_pair (Cell v h) value f1 f2\r\n\n    | (f1 v) < value && (f1 h) < value = Pair (min (f2 v) (f2 h)) value\r\n\n    | (f1 v) < value = Pair (f2 v) value\r\n\n    | (f1 h) < value = Pair (f2 h) value\r\n\n    | otherwise = Empty\r\n\n\r\n\nfirst  (Pair a _) = a\r\n\nsecond (Pair _ b) = b\r\n\n\r\n\nswap_pair (Empty) = Empty\r\n\nswap_pair (Pair a b) = Pair b a\r\n\n\r\n\nnew_pair_h c value = swap_pair (new_pair c value first second)\r\n\nnew_pair_v c value = new_pair c value second first\r\n\n\r\n\nnew_cell v h value = Cell (new_pair_v v value) (new_pair_h h value)\r\n\n\r\n\nadd_line [] p value x _ n\r\n\n    | x <= n = [[new_cell (Cell Empty Empty) p value]]\r\n\n    | otherwise = []\r\n\nadd_line ((h:t):t\') p value x y n\r\n\n    | y > n = ((h:t):(add_line t\' h value (x + 1) (y - 1) n))\r\n\n    | x > n = []\r\n\n    | otherwise = let new_c = new_cell h p value\r\n\n                  in ((new_c:h:t):(add_line t\' h value (x + 1) (y - 1) n))\r\n\n\r\n\ncreate_table table _ [] _ = table\r\n\ncreate_table table n (h:t) c = let c\' = c + 1\r\n\n                                   table\' = add_line table (Cell Empty Empty) h 0 c\' n\r\n\n                               in create_table table\' n t c\'\r\n\n\r\n\ncheck_result (((Cell Empty Empty):_):_) 0 = False\r\n\ncheck_result _ 0 = True\r\n\ncheck_result (_:t) n = check_result t (n - 1)\n','Выражение имеет неправильное значение: parts2 [1,6,9]'),(5401,36,'MaryK','2013-09-23 02:39:38',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<), head, tail, (++),sqrt, snd,fst, (||), zip, map)\r\n\r\ncube::Int->Int\r\n  --- А зачем вы все это пишете, давно хотел спросить? ) \r\n  --- Если убрать все предыдущие строки, все равно будет комипилировться \r\n\r\ncube a = a*a*a \r\n\r\ncubeTable::Int->[(Int,Int)]\r\n\r\ncubeTable 0 = []\r\n   --- Предыдушая строчка лишняя, [1..0] и так даст пустую строку\r\ncubeTable num = zip ([1..num])  (map cube ([1..num]))\r\n','<br/>Тесты успешно пройдены!'),(5400,35,'MaryK','2013-09-23 01:47:59',1,'module Func where\r\n\r\nimport Prelude(Bool(..),RealFloat(),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<), head, tail, (++),sqrt, snd,fst, (||))\r\n\r\nf::(Float,Float)->(Float,Float)->Float\r\n\r\nf a b = sqrt((fst a - fst b)*(fst a - fst b) + (snd a - snd b)*(snd a - snd b))\r\n\r\nisosc::(Float,Float)->(Float,Float)->(Float,Float)->Bool\r\n\r\nisosc p1 p2 p3 = if (f p1 p2 == f p2 p3) ||(f p1 p2 == f p1 p3)||(f p2 p3 == f p1 p3) then True  \r\n\r\nelse False\r\n\r\n			\r\n','<br/>Тесты успешно пройдены!'),(5399,38,'3301494','2013-09-23 00:12:47',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5398,37,'3301494','2013-09-23 00:11:46',1,'type Point = (Integer, Integer)\r\n\r\nminsum  xs = minimum (map ((x1, y1) -> x1 + y1) (zip xs (tail xs)))\r\n','<br/>Тесты успешно пройдены!'),(5390,39,'nomeansno','2013-09-22 21:11:56',2,'  --- Ну, как мы сегодня говорили, тут все таки нет оптимизации. Попробуйте ее \r\n  --- исправить, если хотите, и выложите сюда, или пришлите мне по почте.\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\ncond (Node _ Empty Empty) = True\r\n\r\ncond (Node _ _ _) = False\r\n\r\n\r\n\r\nminHeight (Node _ Empty Empty) = 0\r\n\r\nminHeight (Node _ Empty right) = 1 + minHeight right\r\n\r\nminHeight (Node _ left Empty) = 1 + minHeight left\r\n\r\nminHeight (Node _ left right) = if cond left || cond right then 1\r\n\r\nelse 1 + min (minHeight left) (minHeight right)\r\n','<br/>Тесты успешно пройдены!'),(5391,36,'12828920','2013-09-22 21:21:38',1,'cubeTable n = zip [1..n] (map (i->i^3)[1..n])\r\n','<br/>Тесты успешно пройдены!'),(5392,37,'12828920','2013-09-22 21:35:20',1,'minsum (x:xs) = minimum (map ((x,y)->x+y) (zip (x:xs) xs))\r\n','<br/>Тесты успешно пройдены!'),(5393,38,'12828920','2013-09-22 22:11:35',1,'data Tree = Empty |\r\n\r\n            Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node val l r) = 1 + (max (height l) (height r))\r\n','<br/>Тесты успешно пройдены!'),(5394,35,'3301494','2013-09-22 22:14:45',1,'type Point = (Integer, Integer)\r\n\r\nisOnLine (x1, y1) (x2, y2) (x3, y3) = (x3 - x1) * (y2 - y1) == (y3 - y1) * (x2 - x1)\r\n\r\ndist (x1, y1) (x2, y2) = (x1 - x2)^2 + (y1 - y2)^2\r\n\r\nisosc (x1, y1) (x2, y2) (x3, y3) = let\r\n\r\n											a = (x1, y1)\r\n\r\n											b = (x2, y2)\r\n\r\n											c = (x3, y3)\r\n\r\n										in (not(isOnLine a b c)) && (dist a b == dist a c || dist a b == dist b c || dist a c == dist b c)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5395,36,'3301494','2013-09-22 22:17:05',1,'type Point = (Integer, Integer)\r\n\r\ncubeTable n = map (x -> (x, x^3))([1..n])\r\n','<br/>Тесты успешно пройдены!'),(5396,33,'ArtemK','2013-09-22 22:37:25',1,'# Python\r\n\r\ndef intSimpson(f, a, b):\r\n    return (b - a) * (f(a) + 4 * f((a+b)/2) + f(b)) / 6\r\n\r\ndef integral(f, a, b):\r\n    INTERVALS = 10\r\n    dx = (b - a) / INTERVALS\r\n    i = 0\r\n    result = 0.0\r\n    while i < INTERVALS:\r\n        result += intSimpson(f, a + dx*i, a + dx*(i+1))\r\n        i += 1\r\n    return result\r\n\r\nprint(integral(lambda x: x * x, 2.0, 3.0))','<br/>Тесты успешно пройдены!'),(5397,31,'8519021','2013-09-23 00:00:05',1,'parts2 (x:xs)\r\n\r\n  | mod (length (x:xs)) 2 /= 0 = False\r\n\r\n  | otherwise = parts2\' xs x (-1/0) 1 0 (div (length (x:xs)) 2)\r\n\r\nparts2\' [] _ _ l1 l2 _ = l1 == l2\r\n\r\nparts2\' (x:xs) min1 min2 l1 l2 lMax\r\n\r\n  | l1 > lMax || l2 > lMax = False\r\n\r\n  | x > max min1 min2 = parts2\' xs x min2 (l1 + 1) l2 lMax || parts2\' xs min1 x l1 (l2 + 1) lMax\r\n\r\n  | x > min1 = parts2\' xs x min2 (l1 + 1) l2 lMax \r\n\r\n  | x > min2 = parts2\' xs min1 x l1 (l2 + 1) lMax\r\n\r\n  | otherwise = False\r\n','<br/>Тесты успешно пройдены!'),(5389,35,'12828920','2013-09-22 21:06:43',1,'isosc (x1,y1) (x2,y2) (x3,y3) = if (f1 == f2 || f1 == f3 || f2 == f3)\r\n\r\n								then True\r\n\r\n								else False\r\n\r\n								where \r\n\r\n									f1 = (x1-x2)^2 + (y1-y2)^2\r\n\r\n									f2 = (x2-x3)^2 + (y2-y3)^2\r\n\r\n									f3 = (x1-x3)^2 + (y1-y3)^2\r\n','<br/>Тесты успешно пройдены!'),(5387,38,'nomeansno','2013-09-22 20:51:08',0,'','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5388,38,'nomeansno','2013-09-22 20:51:40',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = 0\r\n\r\nheight (Node _ Empty Empty) = 0\r\n\r\nheight (Node _ left right) = 1 + max (height left) (height right)\r\n','<br/>Тесты успешно пройдены!'),(5386,45,'romos2007','2013-09-22 20:36:00',1,'﻿/*\r\n\r\n *Задача 8-1\r\n\r\n *Одеров Роман, 545 гр.\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace _8_1\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        private static bool checkEven(int[][] array)\r\n\r\n        {\r\n\r\n            return array.All(arr => arr.Any(a => (a % 2 == 0)));\r\n\r\n        }\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[][] a1 = { new int[] { 1, 3, 2 },\r\n\r\n                           new int[] { 3, 8, 9 } };\r\n\r\n            int[][] a2 = { new int[] { 1, 3, 5 },\r\n\r\n                           new int[] { 3, 7, 9 } };\r\n\r\n            foreach (Array a in a1)\r\n\r\n            {\r\n\r\n                foreach (int i in a)\r\n\r\n                {\r\n\r\n                    Console.Write(\"{0} \", i);\r\n\r\n                }\r\n\r\n                Console.Write(\"\r\n\");\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"{0}\r\n\", checkEven(a1));\r\n\r\n            foreach (Array a in a2)\r\n\r\n            {\r\n\r\n                foreach (int i in a)\r\n\r\n                {\r\n\r\n                    Console.Write(\"{0} \", i);\r\n\r\n                }\r\n\r\n                Console.Write(\"\r\n\");\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"{0}\r\n\", checkEven(a2));\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5385,38,'nomeansno','2013-09-22 20:32:35',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nheight (Node _ Empty Empty) = 0\r\n\r\nheight (Node _ Empty left) = 1 + height left\r\n\r\nheight (Node _ right Empty) = 1 + height right\r\n\r\nheight (Node _ left right) = 1 + max (height left) (height right)  \r\n','<br/>Тесты успешно пройдены!'),(5384,38,'nomeansno','2013-09-22 20:31:15',0,'data Tree = Empty | Node Integer Tree Tree\r\n\n\r\n\nheight (Node _ Empty Empty) = 0\r\n\nheight (Node _ Empty left) = 1 + height left\r\n\nheight (Node _ right Empty) = 1 + height right\r\n\nheight (Node _ left right) = max (height left) (height right)  \n','Выражение имеет неправильное значение: height (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))'),(5383,31,'8519021','2013-09-22 20:14:40',0,'parts2 (x:xs) = parts2\' xs x (-1/0) 1 0 (div (length (x:xs)) 2)\r\n\nparts2\' [] _ _ l1 l2 _ = l1 == l2\r\n\nparts2\' (x:xs) min1 min2 l1 l2 lMax\r\n\n  | l1 > lMax || l2 > lMax = False\r\n\n  | x > min1 || x > min2 = parts2\' xs x min2 (l1 + 1) l2 lMax || parts2\' xs min1 x l1 (l2 + 1) lMax\r\n\n  | otherwise = False\n','Выражение имеет неправильное значение: parts2 [5,1,2,3, 7,8,9,10,11,12,13,6,20,14,15,16]'),(5382,31,'8519021','2013-09-22 20:14:27',0,'parts2 (x:xs) = parts2\' xs x (-1/0) 1 0 (div (length (x:xs)) 2)\r\n\nparts2\' [] _ _ l1 l2 _ = l1 == l2\r\n\nparts2\' (x:xs) min1 min2 l1 l2 lMax\r\n\n  | l1 > lMax || l2 > lMax = False\r\n\n  | x > min1 || x > min2 = parts2\' xs x min2 (l1 + 1) l2 lMax || parts2\' xs min1 x l1 (l2 + 1) lMax\r\n\n  | otherwise = False\n','Выражение имеет неправильное значение: parts2 [5,1,2,3, 7,8,9,10,11,12,13,6,20,14,15,16]'),(5381,31,'8519021','2013-09-22 20:13:49',0,'parts2 (x:xs) = parts2\' xs x (-1/0) 1 0 (div (length (x:xs)) 2)\r\n\nparts2\' [] _ _ l1 l2 _ = l1 == l2\r\n\nparts2\' (x:xs) min1 min2 l1 l2 lMax\r\n\n  | l1 > lMax || l2 > lMax = False\r\n\n  | x > min1 || x > min2 = parts2\' xs x min2 (l1 + 1) l2 lMax || parts2\' xs min1 x l1 (l2 + 1) lMax\r\n\n  | otherwise = False\n','Выражение имеет неправильное значение: parts2 [5,1,2,3, 7,8,9,10,11,12,13,6,20,14,15,16]'),(5380,31,'15309342','2013-09-22 20:12:03',2,'  --- Вообще правильно, но я вас попрошу добавить еще проверку, что ели в каком-то списке уже есть\r\n  --- n/2 элементов, то туда больше добавлять нет смысла. Вроде бы у вас ее нет, вы проверяете это только\r\n  --- в самом конце? Добавьте, пожалуйста, это не трудно. \r\nparts2 list = parts3 list [] [] 0 0\r\nparts3 [] list1 list2 l1 l2 = (l1 == l2)\r\nparts3 (x:xs) [] [] 0 0 = (parts3 xs [x] [] 1 0) || (parts3 xs [] [x] 0 1)\r\nparts3 (x:xs) list1 [] l1 0 | (x > head list1) = (parts3 xs (x:list1) [] (l1 + 1) 0) || (parts3 xs list1 [x] l1 1)\r\n                            | otherwise = parts3 xs list1 [x] l1 1\r\nparts3 (x:xs) [] list2 0 l2 = parts3 (x:xs) list2 [] l2 0 \r\nparts3 (x:xs) z1@(x1:list1) z2@(x2:list2) l1 l2 | (x <= x1 && x <= x2) = False\r\n                                                | (x > x1 && x <= x2) = parts3 xs (x:z1) z2 (l1 + 1) l2\r\n                                                | (x <= x1 && x > x2) = parts3 xs z1 (x:z2) l1 (l2 + 1)\r\n                                                | otherwise = (parts3 xs (x:z1) z2 (l1 + 1) l2) || (parts3 xs z1 (x:z2) l1 (l2 + 1))\r\n','<br/>Тесты успешно пройдены!'),(5379,43,'romos2007','2013-09-22 20:03:38',1,'{--\r\n\r\nЗадача 7-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-	Без комментариев, это алгоритм Евклида :-)\r\n\r\n	Источник: Кормен и компания, \"Алгоритмы. Построение и анализ\", стр. 966-}\r\n\r\n\r\n\r\neuclid a b = 	if (b == 0) then (1,0)\r\n\r\n				else\r\n\r\n					let (x\', y\') = euclid b (mod a b)\r\n\r\n					in (y\', x\' - (div a b)*y\')\r\n','<br/>Тесты успешно пройдены!'),(5378,30,'5543298','2013-09-22 20:03:26',1,'isSorted [x, y] c _ = if (c == 2) && (x < y) then True else False\r\n\r\nisSorted (x:xs) 1 n = isSorted (xs) n n \r\n\r\nisSorted (x1:x2:xs) c n = x1 < x2 && isSorted (x2:xs) (c - 1) n \r\n\r\n\r\n\r\nparts\' xs n = (length (xs) `mod` n == 0 && isSorted (xs) n n) || (n > 2 && parts\' (xs) (n - 1)) \r\n\r\nparts [] = False\r\n\r\nparts [x] = False \r\n\r\nparts xs = parts\' xs (length (xs))\r\n','<br/>Тесты успешно пройдены!'),(5377,45,'62628590','2013-09-22 19:55:32',1,'using System;\r\nusing System.Linq;\r\n\r\nnamespace task8\r\n{\r\n	class Task\r\n	{\r\n		static bool task8_1(int[][] a)\r\n		{\r\n			return a.All(xs => xs.Any(x => x % 2 == 0));\r\n		}\r\n		\r\n		static void Main(string[] args)\r\n		{\r\n            int[][] array1 = { new int[] { 1, 3, 5 }, new int[] { 1, 3, 5 }, new int[] { 1, 3, 5 } };\r\n            int[][] array2 = { new int[] { 1, 3, 5 }, new int[] { 1, 3, 5 }, new int[] { 1, 3, 4 } };\r\n            int[][] array3 = { new int[] { 1, 3, 4 }, new int[] { 1, 2, 3 }, new int[] { 1, 3, 5, 6 } };\r\n			\r\n			Console.WriteLine(\"{0}\", task8_1(array1)); // False\r\n			Console.WriteLine(\"{0}\", task8_1(array2)); // False\r\n            Console.WriteLine(\"{0}\", task8_1(array3)); // True\r\n            Console.ReadLine();\r\n		}\r\n	}\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5376,35,'480387','2013-09-22 19:32:40',1,'sqr x = x*x\r\n\r\nisosc (x1,y1) (x2,y2) (x3,y3) = \r\n\r\n	r1 == r2 || r2 == r3 || r1 == r3\r\n\r\n	where \r\n\r\n	  r1 = sqr (x1-x2) + sqr (y1-y2)\r\n\r\n	  r2 = sqr (x2-x3) + sqr (y2-y3)\r\n\r\n	  r3 = sqr (x1-x3) + sqr (y1-y3)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5374,37,'egeorge','2013-09-22 19:18:10',1,'minsum xs =  minimum [(xs !! n) + (xs !! (n-1)) | n <- [1..(length xs - 1)]]\r\n  --- ОК, но так довольно медленно (!! - долгая операция) ','<br/>Тесты успешно пройдены!'),(5375,38,'egeorge','2013-09-22 19:24:00',1,'data Tree = Empty |\r\n            Node Integer Tree Tree\r\n\r\n            \r\nheight Empty = -1\r\n\r\nheight (Node _ child1 child2) = 1 + max (height child1) (height child2)','<br/>Тесты успешно пройдены!'),(5373,35,'egeorge','2013-09-22 19:10:06',1,'isosc a b c = let d1 = distSquared a b\r\n                  d2 = distSquared a c\r\n                  d3 = distSquared b c\r\n              in d1 == d2 ||\r\n                 d1 == d3 ||\r\n                 d2 == d3\r\n\r\ndistSquared (x1, y1) (x2, y2) = (x1 - x2)^2 + (y1 - y2)^2','<br/>Тесты успешно пройдены!'),(5372,35,'egeorge','2013-09-22 19:09:08',0,'isosc a b c = let d1 = distSquared a b\r\n                  d2 = distSquared a c\r\n                  d3 = distSquared b c\r\n              in d1 == d2 ||\r\n                 d1 == d3 ||\r\n                 d2 == d3\r\n\r\ndistSquared (x1 y1) (x2 y2) = (x1 - x2)^2 + (y1 - y2)^2','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5371,44,'62628590','2013-09-22 19:07:02',1,'nod x y = nod0 (abs x) (abs y)\r\nnod0 x 0 = x\r\nnod0 x y = nod0 y (rem x y)\r\neuclid a b \r\n	|a==0 = (0,div b (abs b))\r\n	|otherwise =\r\n		let\r\n			(x1,y1) = euclid (mod b a) a\r\n		in (y1-(div b a)*x1,x1)\r\neuclid0 a b =\r\n	let\r\n		c = nod a b\r\n		(x,y) = euclid (div a c) (div b c)\r\n	in (x,y)\r\neuclid1 a b f = \r\n	let\r\n		(x,y)=euclid0 a b\r\n		c=div f (nod a b)\r\n	in (x*c,y*c)\r\ndioph0 [a1,a2,a3,a4]\r\n	|a2/=0 = \r\n		let\r\n			(y,z)=euclid0 a2 a3\r\n			d=nod a2 a3\r\n			(x,k)=euclid1 a1 d a4\r\n		in [x,y*k,z*k]\r\n	|a1/=0 =\r\n		let\r\n			[y,x,z]=dioph0 [a2,a1,a3,a4]\r\n		in [x,y,z]\r\n	|a3/=0 =\r\n		let\r\n			[x,z,y]=dioph0 [a1,a3,a2,a4]\r\n		in [x,y,z]\r\n	|otherwise = [0,0,0]\r\ndioph [a1,a2,a3,a4] [b1,b2,b3,b4]\r\n	|a1*b4==a4*b1&&a2*b4==a4*b2&&a3*b4==a4*b3 = \r\n		if a4==0&&b4==0 then [0,0,0]\r\n		else if a4==0 then dioph0 [b1,b2,b3,b4]\r\n			else if b4==0 then dioph0 [a1,a2,a3,a4]\r\n				else dioph0 [a1,a2,a3,a4]\r\n	|a2*b1==a1*b2&&a3*b1==a1*b3 = [0,0,0]\r\n	|a2*b1/=a1*b2&&a3*b1==a1*b3 =\r\n		let\r\n			y=div (a4*b1-b4*a1) (a2*b1-b2*a1)\r\n		in  if a1==0&&a3==0 then\r\n			let\r\n				(x,z)=euclid1 b1 b3 (b4-b2*y)\r\n			in [x,y,z]\r\n			else\r\n			let\r\n				(x,z)=euclid1 a1 a3 (a4-a2*y)\r\n			in [x,y,z]\r\n	|a2*b1==a1*b2&&a3*b1/=a1*b3 =\r\n		let\r\n			z=div (a4*b1-b4*a1) (a3*b1-b3*a1)\r\n		in if a1==0&&a2==0 then\r\n			let\r\n				(x, y)=euclid1 b1 b2 (b4-b3*z)\r\n			in [x,y,z]\r\n		else\r\n			let\r\n				(x, y)=euclid1 a1 a2 (a4-a3*z)\r\n			in [x,y,z]\r\n	|a1*b4/=a4*b1 =\r\n		let\r\n			k1=a2*b1-b2*a1\r\n			k2=a3*b1-b3*a1\r\n			(y,z)=euclid1 k1 k2 (a4*b1-b4*a1)\r\n			d=nod k1 k2\r\n			m1=div k1 d\r\n			m2=div k2 d\r\n			k3=a2*m2-a3*m1\r\n			k4=a4-a2*y-a3*z\r\n			(x,t)=euclid1 a1 k3 k4\r\n		in [x,y+m2*t,z-m1*t]\r\n	|a1*b4==a4*b1 =\r\n		let\r\n			k=div (a2*b1-b2*a1) (b3*a1-a3*b1)\r\n			k1=a2+k*a3\r\n			(x,y)=euclid1 a1 k1 a4\r\n		in [x,y,k*y]','<br/>Тесты успешно пройдены!'),(5369,36,'egeorge','2013-09-22 19:02:08',1,'cubeTable n = zip [1..n] [x*x*x | x <- [1..n]]','<br/>Тесты успешно пройдены!'),(5370,37,'617015','2013-09-22 19:03:11',2,'  --- Нет это не по условию.. Выописали рекурсивную функцию sums а надо вместо нее ка-то использоваь стандартные функциим \r\nminsum [x,y] = x+y\r\n\r\nminsum (x:y:xs) = minimum (sums [x+y] (y:xs))\r\n\r\nsums xs [y,z] = xs++ [y+z]\r\n\r\nsums xs (y:z:ys)= xs ++ sums[y+z] (z:ys)\r\n','<br/>Тесты успешно пройдены!'),(5368,43,'5543298','2013-09-22 19:01:37',1,'nod 1 0 = (1, 0)\r\n\r\nnod 0 1 = (0, 1)\r\n\r\nnod a b = let \r\n\r\n			m = min a b\r\n\r\n			nextA = max a b - m\r\n\r\n			nextB = m\r\n\r\n			(x, y) = nod nextA nextB \r\n\r\n		in if x * a + (y - x) * b == 1 then (x, (y - x)) else ((y - x), x)\r\n\r\n\r\n\r\neuclid 0 0 = (0, 0)\r\n\r\neuclid 0 1 = (0, 1)\r\n\r\neuclid 1 0 = (1, 0)\r\n\r\neuclid 0 (-1) = (0, (-1))\r\n\r\neuclid (-1) 0 = ((-1), 0)\r\n\r\neuclid a b = nod a b\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5367,36,'egeorge','2013-09-22 19:00:43',0,'cubeTable n = zip [1..n] [x*x | x <- [1..n]]','Выражение имеет неправильное значение: cubeTable 4'),(5365,25,'480387','2013-09-22 18:58:25',2,'  --- Сильно после срока :(\r\nminlist (x:xs) = ml xs x\r\n\r\nml [] m = m\r\n\r\nml (t:ts) m = ml ts (if (m>=t) then t else m)\r\n','<br/>Тесты успешно пройдены!'),(5366,44,'62628590','2013-09-22 19:00:32',0,'nod x y = nod0 (abs x) (abs y)\r\nnod0 x 0 = x\r\nnod0 x y = nod0 y (rem x y)\r\neuclid a b \r\n	|a==0 = (0,div (abs b) b)\r\n	|otherwise =\r\n		let\r\n			(x1,y1) = euclid (mod b a) a\r\n		in (y1-(div b a)*x1,x1)\r\neuclid0 a b =\r\n	let\r\n		c = nod a b\r\n		(x,y) = euclid (div a c) (div b c)\r\n	in (x,y)\r\neuclid1 a b f = \r\n	let\r\n		(x,y)=euclid0 a b\r\n		c=div f (nod a b)\r\n	in (x*f,y*f)\r\ndioph0 [a1,a2,a3,a4]\r\n	|a2/=0 = \r\n		let\r\n			(y,z)=euclid0 a2 a3\r\n			d=nod a2 a3\r\n			(x,k)=euclid1 a1 d a4\r\n		in [x,y*k,z*k]\r\n	|a1/=0 =\r\n		let\r\n			[y,x,z]=dioph0 [a2,a1,a3,a4]\r\n		in [x,y,z]\r\n	|a3/=0 =\r\n		let\r\n			[x,z,y]=dioph0 [a1,a3,a2,a4]\r\n		in [x,y,z]\r\n	|otherwise = [0,0,0]\r\ndioph [a1,a2,a3,a4] [b1,b2,b3,b4]\r\n	|a1*b4==a4*b1&&a2*b4==a4*b2&&a3*b4==a4*b3 = \r\n		if a4==0&&b4==0 then [0,0,0]\r\n		else if a4==0 then dioph0 [b1,b2,b3,b4]\r\n			else if b4==0 then dioph0 [a1,a2,a3,a4]\r\n				else dioph0 [a1,a2,a3,a4]\r\n	|a2*b1==a1*b2&&a3*b1==a1*b3 = [0,0,0]\r\n	|a2*b1/=a1*b2&&a3*b1==a1*b3 =\r\n		let\r\n			y=div (a4*b1-b4*a1) (a2*b1-b2*a1)\r\n		in  if a1==0&&a3==0 then\r\n			let\r\n				(x,z)=euclid1 b1 b3 (b4-b2*y)\r\n			in [x,y,z]\r\n			else\r\n			let\r\n				(x,z)=euclid1 a1 a3 (a4-a2*y)\r\n			in [x,y,z]\r\n	|a2*b1==a1*b2&&a3*b1/=a1*b3 =\r\n		let\r\n			z=div (a4*b1-b4*a1) (a3*b1-b3*a1)\r\n		in if a1==0&&a2==0 then\r\n			let\r\n				(x, y)=euclid1 b1 b2 (b4-b3*z)\r\n			in [x,y,z]\r\n		else\r\n			let\r\n				(x, y)=euclid1 a1 a2 (a4-a3*z)\r\n			in [x,y,z]\r\n	|a1*b4/=a4*b1 =\r\n		let\r\n			k1=a2*b1-b2*a1\r\n			k2=a3*b1-b3*a1\r\n			(y,z)=euclid1 k1 k2 (a4*b1-b4*a1)\r\n			d=nod k1 k2\r\n			m1=div k1 d\r\n			m2=div k2 d\r\n			k3=a2*m2-a3*m1\r\n			k4=a4-a2*y-a3*z\r\n			(x,t)=euclid1 a1 k3 k4\r\n		in [x,y+m2*t,z-m1*t]\r\n	|a1*b4==a4*b1 =\r\n		let\r\n			k=div (a2*b1-b2*a1) (b3*a1-a3*b1)\r\n			k1=a2+k*a3\r\n			(x,y)=euclid1 a1 k1 a4\r\n		in [x,y,k*y]','Выражение имеет неправильное значение: let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)'),(5364,35,'egeorge','2013-09-22 18:57:09',0,'isosc a b c = let d1 = distSquared a b\r\n                  d2 = distSquared a c\r\n                  d3 = distSquared b c\r\n              in d1 == d2 ||\r\n                 d1 == d3 ||\r\n                 d2 == d3\r\n\r\ndistSquared b a = (fst a - fst b)^2 + (snd a - snd b)^2','<br/>Тесты успешно пройдены!'),(5363,35,'egeorge','2013-09-22 18:56:42',0,'isocs a b c = let d1 = distSquared a b\r\n                  d2 = distSquared a c\r\n                  d3 = distSquared b c\r\n              in d1 == d2 ||\r\n                 d1 == d3 ||\r\n                 d2 == d3\r\n\r\ndistSquared b a = (fst a - fst b)^2 + (snd a - snd b)^2','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5361,35,'617015','2013-09-22 18:54:57',1,'isosc(x1,y1)(x2,y2)(x3,y3) = if ((x1-x2)^2+(y1-y2)^2 == (x3-x2)^2+(y3-y2)^2)|| ((x1-x2)^2+(y1-y2)^2 == (x3-x1)^2+(y3-y1)^2)||((x3-x2)^2+(y3-y2)^2 == (x3-x1)^2+(y3-y1)^2) then True else False\r\n','<br/>Тесты успешно пройдены!'),(5362,36,'617015','2013-09-22 18:55:27',2,'  --- Тут тоже не по условию, тут _нельзя_ определять рекурсивные функции. Исправьте, пожалуйста. \r\ncubeTable n = cubeT (n-1) [n] [n*n*n]\r\n\r\ncubeT 0 xs ys= zip xs ys\r\n\r\ncubeT n xs ys= cubeT (n-1) ([n]++xs) ([n*n*n] ++ ys)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5360,38,'617015','2013-09-22 18:53:16',1,'data Tree a = Empty| Node a (Tree a) (Tree a)\r\n\r\nheight :: Tree a -> Integer\r\n\r\nheight Empty=0\r\n\r\nheight (Node a Empty Empty)= 0\r\n\r\nheight(Node val l r) = 1 + max(height l) (height r)\r\n','<br/>Тесты успешно пройдены!'),(5359,30,'15309342','2013-09-22 18:31:23',1,'parts list = parts1 (tail list) (head list) 1\r\nparts1 [] e l = (l >= 2)\r\nparts1 [x] e l = (x > e) && (l >= 1)\r\nparts1 (x:xs) e l | (e < x) && (l < 2) = parts1 xs x (l + 1)\r\n                  | (e < x) && (l >= 2) = (parts1 xs x (l + 1)) || (parts2 xs x l 1)\r\n                  | otherwise = parts2 xs x l 1\r\n\r\nparts2 [] h l l1 = (l == l1)\r\nparts2 [x] h l l1 = (x > h) && (1 + l1 == l)\r\nparts2 (x:xs) h l l1 | (l1 < l) && (h < x) = parts2 xs x l (l1 + 1)\r\n                     | (l1 < l) && (h >= x) = False\r\n                     | (l1 == l) = parts2 xs x l 1','<br/>Тесты успешно пройдены!'),(5358,44,'55363692','2013-09-22 18:10:53',1,'import Debug.Trace\r\n\r\n\r\n\r\neuclid a b = \r\n\r\n	if b == 0 then \r\n\r\n		(1, 0) \r\n\r\n	else \r\n\r\n		(t, s - q * t) where \r\n\r\n			q = a `div` b\r\n\r\n			r = a `mod` b\r\n\r\n			(s, t) = euclid b r\r\n\r\n			\r\n\r\ndioph\' a b c d = let \r\n\r\n		(q1, q2) = euclid a b\r\n\r\n		g1 = a * q1 + b * q2\r\n\r\n		(q3, q4) = euclid g1 c\r\n\r\n		g2 = g1 * q3 + c * q4\r\n\r\n		in \r\n\r\n			if g2 == 0 || d `mod` g2 /= 0 then error \"No such numbers\"\r\n\r\n			else\r\n\r\n				let k = d `div` g2\r\n\r\n				in [k * q3 * q1, k * q3 * q2, k * q4]\r\n\r\n			\r\n\r\nsolve\' a1 a2 b = \r\n\r\n				let\r\n\r\n					(s, r) = euclid a1 a2\r\n\r\n					g = gcd s r\r\n\r\n				in\r\n\r\n					if g == 0 || b `mod` g /= 0 then\r\n\r\n						error \"No such numbers\"\r\n\r\n					else \r\n\r\n						let k = b `div` g in (k * s, k * r)		\r\n\r\n\r\n\r\n		\r\n\r\nsolve 0 0 0 a21 a22 b2 = solve\' a21 a22 b2\r\n\r\nsolve a11 a12 b1 0 0 0 = solve\' a11 a12 b1			\r\n\r\n			\r\n\r\n-- h * a11 + z * a12 = b1\r\n\r\n-- h * a21 + z * a22 = b2			\r\n\r\nsolve a11 a12 b1 a21 a22 b2 = let \r\n\r\n		a = -a11 * a22 + a21 * a12\r\n\r\n		b = -b1 * a22 + b2 * a12\r\n\r\n	in\r\n\r\n		if a == 0 then \r\n\r\n			if b == 0 then solve\' a11 a12 b1\r\n\r\n			else\r\n\r\n				error \"No such numbers\"\r\n\r\n		else \r\n\r\n			let\r\n\r\n				h  = b `div` a\r\n\r\n				a\' = a12\r\n\r\n				b\' = b1 - h * a11\r\n\r\n			in\r\n\r\n				if a\' == 0 || b\' `mod` a\' /= 0 then error \"No such numbers\"\r\n\r\n				else (h, b\' `div` a\')\r\n\r\n					\r\n\r\ndioph (0:0:0:0:[]) (k:l:m:n:[]) = dioph\' k l m n\r\n\r\ndioph (a:b:c:d:[]) (0:0:0:0:[]) = dioph\' a b c d					\r\n\r\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let \r\n\r\n	t = if a == 0 then 0 else k `div` a in\r\n\r\n	if (t * a == k && t * b == l && t * c == m && t * d == n) then dioph\' a b c d\r\n\r\n	else\r\n\r\n	let \r\n\r\n	a\' = -a * m + k * c\r\n\r\n	b\' = -b * m + l * c\r\n\r\n	c\' = -d * m + n * c\r\n\r\n-- a\'x + b\'y = c\'\r\n\r\n	(q1, q2) = euclid a\' b\'\r\n\r\n	g = a\' * q1 + b\' * q2\r\n\r\n	in \r\n\r\n	if g == 0 then \r\n\r\n		let (x, y) = solve a b d k l n\r\n\r\n		in [x, y, 0]\r\n\r\n	else \r\n\r\n		if c\' `mod` g /= 0 then [0, 0, 0] \r\n\r\n		else let\r\n\r\n			v = c\' `div` g\r\n\r\n			t = a\' * b\' `div` g\r\n\r\n			r\' = if a\' == 0 then 1 else -t `div` a\'\r\n\r\n			s\' = if b\' == 0 then 1 else t `div` b\'\r\n\r\n			r = v * q1\r\n\r\n			s = v * q2\r\n\r\n	-- x = r + h * r\'\r\n\r\n	-- y = s + h * s\'\r\n\r\n	-- h - unknown\r\n\r\n			a11 = a * r\' + b * s\'\r\n\r\n			a12 = c\r\n\r\n			b1 = d - a * r - b * s\r\n\r\n			a21 = k * r\' + l * s\'\r\n\r\n			a22 = m\r\n\r\n			b2 = n - k * r - l * s\r\n\r\n			(h, z) = solve a11 a12 b1 a21 a22 b2\r\n\r\n			in [r + h * r\', s + h * s\', z]\r\n','<br/>Тесты успешно пройдены!'),(5356,37,'nomeansno','2013-09-22 18:08:42',1,'minsum (x:xs) = minimum (zipWith (+) (x:xs) xs)\r\n','<br/>Тесты успешно пройдены!'),(5357,39,'toskira','2013-09-22 18:09:33',1,'data Tree = Empty |\r\n            Node Integer Tree Tree\r\n\r\nminHeight t = f t (0) [] []\r\n\r\nf (Node _ Empty Empty) cur _ _ = cur\r\nf Empty cur [] (h:t) = f h (cur + 1) t []\r\nf Empty cur (h:t) next = f h cur t next\r\nf (Node _ l r) cur [] [] = f l (cur + 1) [r] []\r\nf (Node _ l r) cur [] (h:t) = f h (cur + 1) (l:r:t) []\r\nf (Node _ l r) cur (h:t) next = f h cur t (l:r:next)','<br/>Тесты успешно пройдены!'),(5355,38,'romos2007','2013-09-22 18:02:32',1,'{--\r\n\r\nЗадача 6-4\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ndata Tree = Empty\r\n\r\n			| Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = 0\r\n\r\nheight (Node _ Empty Empty) = 0\r\n\r\nheight (Node i l r) = 1 + max (height l) (height r)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5354,43,'5543298','2013-09-22 17:58:55',0,'nod _ _ 1 0 = (0, 0)\r\n\nnod _ _ 0 1 = (0, 0)\r\n\nnod a b c d = if c * a - b * d == 1 then (c, -d) else if -c * a + b * d == 1 then (-c, d) else if (c > d ) then nod a b (c - d) d else nod a b c (d - c)\r\n\neuclid 0 1 = (0, 1)\r\n\neuclid 1 0 = (1, 0)\r\n\neuclid 0 (-1) = (0, (-1))\r\n\neuclid (-1) 0 = ((-1), 0)\r\n\neuclid a b = nod a b a b\r\n\n\r\n\n\n','Выражение имеет неправильное значение: let (x,y) = euclid 33 25 in 33*x+25*y'),(5353,43,'5543298','2013-09-22 17:57:55',0,'nod _ _ 1 0 = (0, 0)\r\n\nnod _ _ 0 1 = (0, 0)\r\n\nnod a b c d = if c * a - b * d == 1 then (c, -d) else if -c * a + b * d == 1 then (-c, d) else if (c > d ) then nod a b (c - d) d else nod a b c (d - c)\r\n\neuclid 0 1 = (0, 1)\r\n\neuclid 1 0 = (1, 0)\r\n\neuclid 0 -1 = (0, -1)\r\n\neuclid -1 0 = (-1, 0)\r\n\neuclid a b = nod a b a b\r\n\n\r\n\n\n','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5351,43,'5543298','2013-09-22 17:55:54',0,'nod _ _ 1 0 = (0, 0)\r\n\nnod _ _ 0 1 = (0, 0)\r\n\nnod a b c d = if c * a - b * d == 1 then (c, -d) else if -c * a + b * d == 1 then (-c, d) else if (c > d ) then nod a b (c - d) d else nod a b c (d - c)\r\n\neuclid a b = nod a b a b\r\n\n\r\n\n\n','Выражение имеет неправильное значение: let (x,y) = euclid 1 0 in 1*x+0*y'),(5352,44,'55363692','2013-09-22 17:57:34',0,'import Debug.Trace\r\n\n\r\n\neuclid a b = \r\n\n	if b == 0 then \r\n\n		(1, 0) \r\n\n	else \r\n\n		(t, s - q * t) where \r\n\n			q = a `div` b\r\n\n			r = a `mod` b\r\n\n			(s, t) = euclid b r\r\n\n			\r\n\ndioph\' a b c d = let \r\n\n		(q1, q2) = euclid a b\r\n\n		g1 = a * q1 + b * q2\r\n\n		(q3, q4) = euclid g1 c\r\n\n		g2 = g1 * q3 + c * q4\r\n\n		in \r\n\n			if g2 == 0 || d `mod` g2 /= 0 then error \"No such numbers\"\r\n\n			else\r\n\n				let k = d `div` g2\r\n\n				in [k * q3 * q1, k * q3 * q2, k * q4]\r\n\n			\r\n\nsolve\' a1 a2 b = \r\n\n				let\r\n\n					(s, r) = euclid a1 a2\r\n\n					g = gcd s r\r\n\n				in\r\n\n					if g == 0 || b `mod` g /= 0 then\r\n\n						error \"No such numbers\"\r\n\n					else \r\n\n						let k = b `div` g in (k * s, k * r)		\r\n\n\r\n\n		\r\n\nsolve 0 0 0 a21 a22 b2 = solve\' a21 a22 b2\r\n\nsolve a11 a12 b1 0 0 0 = solve\' a11 a12 b1			\r\n\n			\r\n\n-- h * a11 + z * a12 = b1\r\n\n-- h * a21 + z * a22 = b2			\r\n\nsolve a11 a12 b1 a21 a22 b2 = let \r\n\n		a = -a11 * a22 + a21 * a12\r\n\n		b = -b1 * a22 + b2 * a12\r\n\n	in\r\n\n		if a == 0 then \r\n\n			if b == 0 then solve\' a11 a12 b1\r\n\n			else\r\n\n				error \"No such numbers\"\r\n\n		else \r\n\n			let\r\n\n				h  = b `div` a\r\n\n				a\' = a12\r\n\n				b\' = b1 - h * a11\r\n\n			in\r\n\n				if a\' == 0 || b\' `mod` a\' /= 0 then error \"No such numbers\"\r\n\n				else (h, b\' `div` a\')\r\n\n					\r\n\ndioph (0:0:0:0:[]) (k:l:m:n:[]) = dioph\' k l m n\r\n\ndioph (a:b:c:d:[]) (0:0:0:0:[]) = dioph\' a b c d					\r\n\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let \r\n\n	a\' = -a * m + k * c\r\n\n	b\' = -b * m + l * c\r\n\n	c\' = -d * m + n * c\r\n\n-- a\'x + b\'y = c\'\r\n\n	(q1, q2) = euclid a\' b\'\r\n\n	g = a\' * q1 + b\' * q2\r\n\n	in \r\n\n	if g == 0 then dioph\' a b c d\r\n\n	else \r\n\n		if c\' `mod` g /= 0 then [0, 0, 0] \r\n\n		else let\r\n\n			v = c\' `div` g\r\n\n			t = a\' * b\' `div` g\r\n\n			r\' = if a\' == 0 then 1 else -t `div` a\'\r\n\n			s\' = if b\' == 0 then 1 else t `div` b\'\r\n\n			r = v * q1\r\n\n			s = v * q2\r\n\n	-- x = r + h * r\'\r\n\n	-- y = s + h * s\'\r\n\n	-- h - unknown\r\n\n			a11 = a * r\' + b * s\'\r\n\n			a12 = c\r\n\n			b1 = d - a * r - b * s\r\n\n			a21 = k * r\' + l * s\'\r\n\n			a22 = m\r\n\n			b2 = n - k * r - l * s\r\n\n			(h, z) = solve a11 a12 b1 a21 a22 b2\r\n\n			in [r + h * r\', s + h * s\', z]\n','Выражение имеет неправильное значение: let [x,y,z] = dioph [0,1,0,0] [1,1,0,10] in (y,x+y)'),(5349,38,'8519021','2013-09-22 17:42:05',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight tree =\r\n\r\n  case tree of\r\n\r\n    Empty -> 0\r\n\r\n    (Node _ Empty Empty) -> 0\r\n\r\n    (Node _ l r) -> 1 + max (height l) (height r) \r\n','<br/>Тесты успешно пройдены!'),(5350,36,'nomeansno','2013-09-22 17:43:39',1,'cubeTable n = zip [1..n] (map (x -> x*x*x) [1..n])\r\n','<br/>Тесты успешно пройдены!'),(5348,35,'nomeansno','2013-09-22 17:38:59',1,'distance_sqr (x,y) = sqr (x2 - x1) + sqr (y2 - y1) \r\n\r\n where sqr = (x -> x*x); x1 = fst x; y1 = snd x; x2 = fst y; y2 = snd y\r\n\r\n\r\n\r\nisosc x y z = check (map distance_sqr [(x,y),(x,z),(y,z)])\r\n\r\n where check [a,b,c] = a==b || a==c || b==c\r\n','<br/>Тесты успешно пройдены!'),(5347,37,'romos2007','2013-09-22 17:38:20',1,'{--\r\n\r\nЗадача 6-3\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-	Создаем массив пар (элемент #i, элемент #i+1) с помощью zip\r\n\r\n	Map\'им его в массив сумм последовательных элементов:\r\n\r\n		т.е. (эл. #i, эл. #i+1) -> (эл. #i + эл. #i+1)\r\n\r\n	Выбираем минимум из полученных сумм последовательных элементов.\r\n\r\n\r\n\r\n	*Замечание: пользуемся тем, что функция zip обрезает итоговый массив по минимальной длине двух входных массивов\r\n\r\n-}\r\n\r\nminsum (x:xs) = minimum (map ((x,y)->(x+y)) (zip (x:xs) xs))\r\n','<br/>Тесты успешно пройдены!'),(5346,39,'toskira','2013-09-22 17:36:35',0,'data Tree = Empty |\r\n            Node Integer Tree Tree\r\n\r\nminHeight t = f t (-1) [] []\r\n\r\nf Empty cur _ _ = cur\r\nf (Node _ l r) cur (h:t) next = f h cur t (l:r:next)\r\nf (Node _ l r) cur [] (h:t) = f h (cur + 1) (l:r:t) []\r\nf (Node _ l r) cur [] [] = f l (cur + 1) [r] []','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5344,44,'62628590','2013-09-22 17:26:21',0,'','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5345,44,'55363692','2013-09-22 17:26:54',0,'import Debug.Trace\r\n\n\r\n\neuclid a b = \r\n\n	if b == 0 then \r\n\n		(1, 0) \r\n\n	else \r\n\n		(t, s - q * t) where \r\n\n			q = a `div` b\r\n\n			r = a `mod` b\r\n\n			(s, t) = euclid b r\r\n\n			\r\n\ndioph\' a b c d = let \r\n\n		(q1, q2) = euclid a b\r\n\n		g1 = a * q1 + b * q2\r\n\n		(q3, q4) = euclid g1 c\r\n\n		g2 = g1 * q3 + c * q4\r\n\n		in \r\n\n			if g2 == 0 || d `mod` g2 /= 0 then error \"No such numbers\"\r\n\n			else\r\n\n				let k = d `div` g2\r\n\n				in [k * q3 * q1, k * q3 * q2, k * q4]\r\n\n			\r\n\n-- h * a11 + z * a12 = b1\r\n\n-- h * a21 + z * a22 = b2			\r\n\nsolve a11 a12 b1 a21 a22 b2 = let \r\n\n		a = -a11 * a22 + a21 * a12\r\n\n		b = -b1 * a22 + b2 * a12\r\n\n	in\r\n\n		if a == 0 then \r\n\n			if b == 0 then\r\n\n				let \r\n\n					(s, r) = euclid a11 a22\r\n\n					g = gcd s r\r\n\n				in\r\n\n					if g == 0 || b1 `mod` g /= 0 then\r\n\n						error \"No such numbers\"\r\n\n					else \r\n\n						let k = b1 `div` g in (k * s, k * r)\r\n\n			else\r\n\n				error \"No such numbers\"\r\n\n		else \r\n\n			let\r\n\n				h  = b `div` a\r\n\n				a\' = a12\r\n\n				b\' = b1 - h * a11\r\n\n			in\r\n\n				if a\' == 0 || b\' `mod` a\' /= 0 then error \"No such numbers\"\r\n\n				else (h, b\' `div` a\')\r\n\n					\r\n\ndioph (a:b:c:d:[]) (k:l:m:n:[]) = let \r\n\n	a\' = -a * m + k * c\r\n\n	b\' = -b * m + l * c\r\n\n	c\' = -d * m + n * c\r\n\n-- a\'x + b\'y = c\'\r\n\n	(q1, q2) = euclid a\' b\'\r\n\n	g = a\' * q1 + b\' * q2\r\n\n	in \r\n\n	if g == 0 then dioph\' a b c d\r\n\n	else \r\n\n		if c\' `mod` g /= 0 then [0, 0, 0] \r\n\n		else let\r\n\n			v = c\' `div` g\r\n\n			t = a\' * b\' `div` g\r\n\n			r\' = if a\' == 0 then 1 else -t `div` a\'\r\n\n			s\' = if b\' == 0 then 1 else -t `div` b\'\r\n\n			r = v * q1\r\n\n			s = v * q2\r\n\n	-- x = r + h * r\'\r\n\n	-- y = s + h * s\'\r\n\n	-- h - unknown\r\n\n			a11 = a * r\' + b * s\'\r\n\n			a12 = c\r\n\n			b1 = d - a * r - b * s\r\n\n			a21 = k * r\' + l * s\'\r\n\n			a22 = m\r\n\n			b2 = n - k * r - l * s\r\n\n			(h, z) = solve a11 a12 b1 a21 a22 b2\r\n\n			in\r\n\n				[r + h * r\', s + h * s\', z]\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)\", проверьте правильность синтаксиса'),(5343,38,'toskira','2013-09-22 17:16:35',1,'data Tree = Empty |\r\n            Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ l r) = 1 + max (height l) (height r)','<br/>Тесты успешно пройдены!'),(5342,37,'8519021','2013-09-22 17:15:47',1,'minsum xs = minimum (zipWith (+) (tail xs) xs)\r\n','<br/>Тесты успешно пройдены!'),(5341,33,'5543298','2013-09-22 17:13:44',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                       {\r\n\r\n                                           new List<int> {1, 2, 3},\r\n\r\n                                           new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                           new List<int> {501, 1001, 33, 14},\r\n\r\n                                           //Раскомментировать, чтоб было False\r\n\r\n                                           //new List<int> {37, 47, 15},\r\n\r\n                                       };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                case \"5.1\":\r\n\r\n                    {\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => x*x, 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float)Math.Exp(x), 0, 1, 100));\r\n\r\n                        Console.WriteLine(Intgrate_5_1(x => (float)Math.Sin(x), 0, 1, 100));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static float Intgrate_5_1(Func<float, float> func, float a, float b, int steps)\r\n\r\n        {\r\n\r\n            float result = 0;\r\n\r\n            float step = (b - a) / steps;\r\n\r\n            for (var point = a; point < b; point += step)\r\n\r\n            {\r\n\r\n                result += step * (func(point) + func(point + step)) / 2;\r\n\r\n            }\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5340,44,'55363692','2013-09-22 17:13:34',0,'import Debug.Trace\r\n\n\r\n\neuclid a b = \r\n\n	if b == 0 then \r\n\n		(1, 0) \r\n\n	else \r\n\n		(t, s - q * t) where \r\n\n			q = a `div` b\r\n\n			r = a `mod` b\r\n\n			(s, t) = euclid b r\r\n\n			\r\n\ndioph\' a b c d = let \r\n\n		(q1, q2) = euclid a b\r\n\n		g1 = a * q1 + b * q2\r\n\n		(q3, q4) = euclid g1 c\r\n\n		g2 = g1 * q3 + c * q4\r\n\n		in \r\n\n			if g2 == 0 || d `mod` g2 /= 0 then error \"No such numbers\"\r\n\n			else\r\n\n				let k = d `div` g2\r\n\n				in (k * q3 * q1, k * q3 * q2, k * q4)\r\n\n			\r\n\n-- h * a11 + z * a12 = b1\r\n\n-- h * a21 + z * a22 = b2			\r\n\nsolve a11 a12 b1 a21 a22 b2 = let \r\n\n		a = -a11 * a22 + a21 * a12\r\n\n		b = -b1 * a22 + b2 * a12\r\n\n	in\r\n\n		if a == 0 then \r\n\n			if b == 0 then\r\n\n				let \r\n\n					(s, r) = euclid a11 a22\r\n\n					g = gcd s r\r\n\n				in\r\n\n					if g == 0 || b1 `mod` g /= 0 then\r\n\n						error \"No such numbers\"\r\n\n					else \r\n\n						let k = b1 `div` g in (k * s, k * r)\r\n\n			else\r\n\n				error \"No such numbers\"\r\n\n		else \r\n\n			let\r\n\n				h  = b `div` a\r\n\n				a\' = a12\r\n\n				b\' = b1 - h * a11\r\n\n			in\r\n\n				if a\' == 0 || b\' `mod` a\' /= 0 then error \"No such numbers\"\r\n\n				else (h, b\' `div` a\')\r\n\n			\r\n\ndioph:: (Int, Int, Int, Int)->(Int, Int, Int, Int)->(Int, Int, Int)			\r\n\ndioph (a, b, c, d) (k, l, m, n) = let \r\n\n	a\' = -a * m + k * c\r\n\n	b\' = -b * m + l * c\r\n\n	c\' = -d * m + n * c\r\n\n-- a\'x + b\'y = c\'\r\n\n	(q1, q2) = euclid a\' b\'\r\n\n	g = a\' * q1 + b\' * q2\r\n\n	in \r\n\n	if g == 0 then dioph\' a b c d\r\n\n	else \r\n\n		if c\' `mod` g /= 0 then (0, 0, 0) \r\n\n		else let\r\n\n			v = c\' `div` g\r\n\n			t = a\' * b\' `div` g\r\n\n			r\' = if a\' == 0 then 1 else -t `div` a\'\r\n\n			s\' = if b\' == 0 then 1 else -t `div` b\'\r\n\n			r = v * q1\r\n\n			s = v * q2\r\n\n	-- x = r + h * r\'\r\n\n	-- y = s + h * s\'\r\n\n	-- h - unknown\r\n\n			a11 = a * r\' + b * s\'\r\n\n			a12 = c\r\n\n			b1 = d - a * r - b * s\r\n\n			a21 = k * r\' + l * s\'\r\n\n			a22 = m\r\n\n			b2 = n - k * r - l * s\r\n\n			(h, z) = solve a11 a12 b1 a21 a22 b2\r\n\n			in\r\n\n				(r + h * r\', s + h * s\', z)\n','Не удалось вычислить выражение \"let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)\", проверьте правильность синтаксиса'),(5338,39,'ip','2013-09-22 17:10:17',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\nheight2 Empty _ = -1\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               b=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then (a+1)\r\n                              else (b+1)','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),(5339,39,'ip','2013-09-22 17:12:11',2,'  --- Нет, это е совсем то, тут нет оптимизации, о которой мы говорили\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\nheight2 Empty _ = (1/0)\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               b=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then (a+1)\r\n                              else (b+1)','<br/>Тесты успешно пройдены!'),(5337,39,'ip','2013-09-22 17:09:42',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\n\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               b=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then (a+1)\r\n                              else (b+1)','Не удалось вычислить выражение \"minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)\", проверьте правильность синтаксиса'),(5336,39,'ip','2013-09-22 17:09:16',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\nheight2 Empty = -1\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               b=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then (a+1)\r\n                              else (b+1)','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5335,36,'8519021','2013-09-22 17:05:13',1,'cubeTable n = zip [1..n] (map (^3) [1..n])\r\n','<br/>Тесты успешно пройдены!'),(5334,39,'ip','2013-09-22 17:04:57',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               b=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then (a+1)\r\n                              else (b+1)','Не удалось вычислить выражение \"minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)\", проверьте правильность синтаксиса'),(5333,39,'ip','2013-09-22 17:04:07',0,'data Tree = Empty | Node Integer Tree Tree\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               a=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then (a+1)\r\n                              else (b+1)','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5332,39,'ip','2013-09-22 17:03:52',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               a=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then (a+1)\r\n                              else (b+1)','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5331,38,'ip','2013-09-22 17:02:11',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node i t1 t2) = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                           then (a+1)\r\n                           else (b+1)','<br/>Тесты успешно пройдены!'),(5329,39,'ip','2013-09-22 17:01:46',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\n','Не удалось вычислить выражение \"minHeight (Node 1  (Node 2  (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(5330,39,'ip','2013-09-22 17:02:01',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\n','Не удалось вычислить выражение \"minHeight (Node 1  (Node 2  (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))\", проверьте правильность синтаксиса'),(5328,39,'ip','2013-09-22 17:01:14',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               a=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then a+1\r\n                              else b+1','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5327,39,'ip','2013-09-22 17:00:38',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0\r\n\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               a=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then a+1\r\n                              else b+1','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5323,35,'8519021','2013-09-22 16:54:35',1,'isosc a b c = \r\n\r\n  let\r\n\r\n    ab = side a b\r\n\r\n    bc = side b c\r\n\r\n    ac = side a c\r\n\r\n  in ab == bc || ab == ac || bc == ac\r\n\r\nside (x1, y1) (x2, y2) = sqrt((x1 - x2)^2 + (y1 - y2)^2)\r\n','<br/>Тесты успешно пройдены!'),(5324,36,'anna','2013-09-22 16:55:56',1,'cubeTable n = map(x ->(x, x^3)) [1..n]\r\n\r\n					\r\n\r\n\r\n\r\n              \r\n\r\n                                     \r\n\r\n                    \r\n','<br/>Тесты успешно пройдены!'),(5325,39,'ip','2013-09-22 16:57:42',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               a=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then a+1\r\n                              else b+1\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5326,39,'ip','2013-09-22 16:58:21',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight2 (Node _ (Node _ Empty Empty) _) k = k+1\r\nheight2 (Node _ _ (Node _ Empty Empty)) k = k+1\r\nheight2 (Node _ t1 t2) k = let a=(height2 t1 k)\r\n                               a=(height2 t2 k)\r\n                           in if (a<b)\r\n                              then a+1\r\n                              else b+1\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node i t1 t2)= height2 (Node i t1 t2) 0','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5319,35,'romos2007','2013-09-22 16:49:32',1,'{--\r\n\r\nЗадача 6-1\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n\r\n\r\nisosc a b c = (dist a b == dist a c)||(dist a b == dist b c)||(dist a c == dist b c)\r\n\r\n\r\n\r\ndist (x1,y1) (x2,y2) = sqrt((x1-x2)^2+(y1-y2)^2)\r\n','<br/>Тесты успешно пройдены!'),(5320,38,'ip','2013-09-22 16:50:53',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node i t1 t2) = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                           then (a+1)\r\n                           else (b+1)','<br/>Тесты успешно пройдены!'),(5321,36,'romos2007','2013-09-22 16:53:39',1,'{--\r\n\r\nЗадача 6-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\ncubeTable n = map(x->(x,x^3)) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5322,36,'anna','2013-09-22 16:53:53',0,'cubeTable n = map(x ->(x, x^n)) [1..n]\n\n					\n\n\n\n              \n\n                                     \n\n                    \n','Выражение имеет неправильное значение: cubeTable 4'),(5318,38,'ip','2013-09-22 16:49:25',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node i t1 t2) = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                           then (a+1)\r\n                           else (b+1)','Не удалось вычислить выражение \"height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)\", проверьте правильность синтаксиса'),(5317,35,'ip','2013-09-22 16:49:16',1,'isosc (a,b) (c,d) (e,f)= if (((l (a,b))== (l (c,d)))\r\n   --- Тут надо конечно l (a.b) (c,d) == l (c,d) (e,f) и т.д. Но ок, засчитано\r\n   --- Еще несколько замечаний по этой задаче были на занятии. \r\n                            ||\r\n                            ((l (e,f))== (l (c,d)))\r\n                            || \r\n                            ((l (a,b))== (l (e,f))))\r\n                         then True\r\n                         else False\r\n\r\nl (a,b) (c,d) = sqrt((a-c)^2 + (b-d)^2)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5316,37,'anna','2013-09-22 16:47:15',1,'--pair xs = map snd . filter fst . zip (iterate not True) $ zip xs (drop 1 xs)\r\n\r\n\r\n\r\nminsum xs = let a = zip xs (tail xs)\r\n\r\n                    in minimum[x+y | (x,y) <-a]\r\n\r\n					\r\n\r\n\r\n\r\n              \r\n\r\n                                     \r\n\r\n                    \r\n','<br/>Тесты успешно пройдены!'),(5315,38,'ip','2013-09-22 16:46:24',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node i t1 t2) = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                           then (a+1)\r\n                           else (b+1)','<br/>Тесты успешно пройдены!'),(5313,38,'ip','2013-09-22 16:44:18',0,'data Tree = Empty |\r\n     Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight _ Empty Empty = 1\r\nheight Node i t1 t2 = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                           then (a+1)\r\n                           else (b+1)','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5314,38,'ip','2013-09-22 16:45:19',0,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight _ Empty Empty = 1\r\nheight (Node i t1 t2) = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                           then (a+1)\r\n                           else (b+1)','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5312,38,'ip','2013-09-22 16:43:23',0,'data Tree = Empty |\r\n     Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight _ Empty Empty = 1\r\nheight (Node i t1 t2) = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                           then (a+1)\r\n                           else (b+1)','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5311,38,'ip','2013-09-22 16:42:10',0,'data Tree = Empty |\r\n     Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight _ Empty Empty = 1\r\nheight (Node i t1 t2) = let a=(height t1)\r\n                            b=(height t2)\r\n                        in if (a>b)\r\n                        then (a+1)\r\n                        else (b+1)','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5310,38,'ip','2013-09-22 16:40:05',0,'data Tree = Empty |\r\n     Node Integer Tree Tree\r\n\r\nheight Empty = 0\r\nheight _ Empty Empty = 1\r\nheight (i t1 t2) = let a=(height t1)\r\n                       b=(height t2)\r\n                   in if (a>b)\r\n                      then (a+1)\r\n                      else (b+1)','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5308,37,'ip','2013-09-22 16:31:19',1,'minsum xs = minimum (map ((x,y)->(x+y))\r\n                     (zip (tail xs) xs))','<br/>Тесты успешно пройдены!'),(5309,45,'5543298','2013-09-22 16:36:06',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalTasks\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            if (args.Length < 1)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Invalid task name parametr. \r\nPress any key to exit...\");\r\n\r\n                Console.ReadKey();\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            switch (args[0])\r\n\r\n            {\r\n\r\n                case \"8.1\":\r\n\r\n                    {\r\n\r\n                        var test = new List<List<int>>\r\n\r\n                                       {\r\n\r\n                                           new List<int> {1, 2, 3},\r\n\r\n                                           new List<int> {1, 5, 7, 9, 500},\r\n\r\n                                           new List<int> {501, 1001, 33, 14},\r\n\r\n                                           //Раскомментировать, чтоб было False\r\n\r\n                                           //new List<int> {37, 47, 15},\r\n\r\n                                       };\r\n\r\n                        Console.WriteLine(Check_8_1(test));\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                default:\r\n\r\n                    Console.WriteLine(\"Unknow task name.\");\r\n\r\n                    break;\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"Press any key to exit...\");\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static bool Check_8_1(List<List<int>> testArray)\r\n\r\n        {\r\n\r\n            return testArray.All(list => list.Any(element => element%2 == 0));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5305,36,'ip','2013-09-22 16:27:59',1,'cubeTable n = zip [1..n] (map (x->x^3) [1..n])','<br/>Тесты успешно пройдены!'),(5306,37,'ip','2013-09-22 16:30:21',0,'minsum xs = minimum (map ((x,y)->(x+y))\r\n                    (zip (tail xs) xs)','Не удалось вычислить выражение \"minsum [1,8,3,2,7] \", проверьте правильность синтаксиса'),(5307,37,'ip','2013-09-22 16:30:39',0,'minsum xs = minimum (map ((x,y)->(x+y))(zip (tail xs) xs)','Не удалось вычислить выражение \"minsum [1,8,3,2,7] \", проверьте правильность синтаксиса'),(5304,35,'ip','2013-09-22 16:26:23',0,'isosc (a,b) (c,d) (e,f)= if ((l (a,b) == l (c,d)) ||\r\n                            (l (e,f) == l (c,d)) || \r\n                            (l (a,b) == l (e,f)))\r\n                         then True\r\n                         else False\r\n\r\nl (a,b) (c,d) = sqrt((a-c)^2 + (b-d)^2)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5303,35,'ip','2013-09-22 16:22:45',0,'isosc (a,b) (c,d) (e,f)= if (l (a,b) == l (c,d)) ||\r\n                            (l (e,f) == l (c,d)) || \r\n                            (l (a,b) == l (e,f))\r\n                         then True\r\n                         else False\r\n\r\nl (a,b) (c,d) = sqrt((a-c)^2 + (b-d)^2)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5299,35,'ip','2013-09-22 16:10:45',0,'isosc (a,b)(c,d)(e,f)= if (l (a,b) == l (c,d)) |\r\n                          (l (e,f) == l (c,d)) | \r\n                          (l (a,b) == l (e,f))\r\n                       then True\r\n                       else False\r\n\r\nl (a,b)(c,d) = sqrt((a-c)^2 + (c-d)^2)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5300,35,'ip','2013-09-22 16:11:33',0,'isosc (a,b) (c,d) (e,f)= if (l (a,b) == l (c,d)) |\r\n                            (l (e,f) == l (c,d)) | \r\n                            (l (a,b) == l (e,f))\r\n                         then True\r\n                         else False\r\n\r\nl (a,b) (c,d) = sqrt((a-c)^2 + (c-d)^2)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5301,35,'ip','2013-09-22 16:15:03',0,'isosc (a,b) (c,d) (e,f)= if (l (a,b) == l (c,d)) ||\r\n                            (l (e,f) == l (c,d)) || \r\n                            (l (a,b) == l (e,f))\r\n                         then True\r\n                         else False\r\n\r\nl (a,b) (c,d) = sqrt((a-c)^2 + (c-d)^2)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5302,35,'ip','2013-09-22 16:22:36',0,'isosc (a,b) (c,d) (e,f)= if (l (a,b) == l (c,d)) ||\r\n                            (l (e,f) == l (c,d)) || \r\n                            (l (a,b) == l (e,f))\r\n                         then True\r\n                         else False\r\n\r\nl (a,b) (c,d) = sqrt((a-c)^2 + (b-d)^2)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5296,38,'2501950','2013-09-22 15:09:32',1,'data Tree = Empty | Node Integer Tree Tree\r\nheight a = height\' a - 1 \r\nheight\' Empty = 0\r\nheight\' (Node val l r) = 1 + max (height\' l)    (height\' r) ','<br/>Тесты успешно пройдены!'),(5297,37,'2501950','2013-09-22 15:51:28',1,'minsum xs = let \r\n             zxs = zip xs (tail xs)\r\n            in minimum (map ((x, y) -> x+y) zxs)','<br/>Тесты успешно пройдены!'),(5298,39,'5543298','2013-09-22 15:53:14',1,'data Tree = Empty | Node Integer Tree Tree deriving Show\r\n\r\n\r\n\r\n\r\n\r\nisEmpty Empty = True\r\n\r\nisEmpty (Node x l r) = False\r\n\r\n\r\n\r\ncheck cond [] = False\r\n\r\ncheck cond (x:xs) = cond x || check cond xs\r\n\r\n\r\n\r\nnext\' [] ys = ys\r\n\r\n--next\' (Empty:xs) ys = next\' (xs) (ys)\r\n\r\nnext\' ((Node x l r):xs) ys = let zs = (if isEmpty r then (ys) else (r:ys)) in next\' (xs) (if isEmpty l then (zs) else (l:zs))\r\n\r\nnext xs = next\' xs [] \r\n\r\nisContainsList xs = check ((Node x l r) -> isEmpty l && isEmpty r) xs\r\n\r\nminHeight\' xs = 1 + if isContainsList xs then (-1) else minHeight\' (next xs)--((map ((Node x l r) -> l) xs) ++ (map ((Node x l r) -> r) xs)))\r\n\r\nminHeight Empty = 0\r\n\r\nminHeight (Node x l r) = minHeight\' [(Node x l r)]\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5294,37,'5543298','2013-09-22 14:57:28',1,'type Point = (Integer, Integer)\r\n\r\nminsum  xs = minimum (map ((x1, y1) -> x1 + y1) (zip xs (tail xs)))\r\n','<br/>Тесты успешно пройдены!'),(5295,38,'2501950','2013-09-22 14:59:42',0,'data Tree = Empty | Node Integer Tree Tree\r\nheight Empty = 0\r\nheight (Node 1 Empty Empty) = 0 \r\nheight (Node val l r) = 1 + max (height l) \r\n    (height    r)','Выражение имеет неправильное значение: height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)'),(5293,35,'2501950','2013-09-22 14:43:03',1,'isosc (x,y)(k,l)(m,n) = let\r\n                         sqr i = i*i     \r\n                         xk = sqr(x-k)\r\n                         yl = sqr(y-l)\r\n                         xm = sqr(x-m)\r\n                         yn = sqr(y-n)\r\n                         km = sqr(k-m)\r\n                         ln = sqr(l-n)\r\n                         a = sqrt (xk + yl)\r\n                         b = sqrt (xm + yn)\r\n                         c = sqrt (km + ln)\r\n                        in if ((a == b) ||\r\n     (a == c ) || (b == c))\r\n                           then True\r\n                           else False    ','<br/>Тесты успешно пройдены!'),(5291,37,'Valentina Guleva','2013-09-22 13:26:08',1,'minsum xs = minimum [ xs!!i + xs!!(i + 1)| i <- [0..(length xs - 2)]]\r\n  --- ОК, засчитано. Но, просто как замечание, это довольно не эффективно,\r\n  --- потому что !! - это долгая операция \r\n','<br/>Тесты успешно пройдены!'),(5292,31,'1048693','2013-09-22 14:07:13',1,'import Data.Maybe\r\n\r\n\r\n\r\ndata Accumulator a = Fail | Step a Int | Begin\r\n\r\n\r\n\r\nextract :: Accumulator a -> Bool\r\n\r\nextract (Step _ 1) = False\r\n\r\nextract (Step _ _) = True\r\n\r\nextract _          = False\r\n\r\n\r\n\r\nparts  :: Ord a => [a] -> Bool\r\n\r\nparts  xs = or [ extract $ foldl (step l) Begin xs | l <- [2 .. length xs] ]\r\n\r\n    where\r\n\r\n        step _ Fail       _ = Fail\r\n\r\n        step _ Begin      y = Step y 1\r\n\r\n        step l (Step x k) y | k == l = Step y 1\r\n\r\n        step _ (Step x k) y | x <  y = Step y $ k + 1\r\n\r\n        step l (Step x k) _ | k <  l = Fail\r\n\r\n        step _ _          _ = Fail\r\n\r\n\r\n\r\nparts2 :: Ord a => [a] -> Bool\r\n\r\nparts2 xs =\r\n\r\n    let n = length xs\r\n\r\n    in if n `mod` 2 == 1\r\n\r\n       then False\r\n\r\n       else work (n `div` 2) 0 [] [] xs\r\n\r\n           where\r\n\r\n                check :: Ord a => (a -> a -> Bool) -> [a] -> Bool\r\n\r\n                check f xs@(x:xt) = and $ zipWith f xs xt\r\n\r\n                check _       []  = True\r\n\r\n\r\n\r\n                work k = work\'\r\n\r\n                    where\r\n\r\n                        work\' l ls rs    []  | l == k = check (>) ls && check (>) rs\r\n     --- Теперь уж check вроде бы не нужен, монотонность вы проверяете во время добавления каждого элемента\r\n                        work\' l _  _      _  | l == k = False\r\n\r\n                        work\' l ls rs (y:ys) =\r\n\r\n                            (y `ok` ls && work\' (l + 1) (y:ls)   rs  ys) ||\r\n\r\n                            (y `ok` rs && work\'  l         ls (y:rs) ys)\r\n\r\n                            where\r\n\r\n                                ok _   []  = True\r\n\r\n                                ok y (h:_) = y > h\r\n\r\n                        work\' _ _  _     _   = False\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5290,31,'romos2007','2013-09-22 12:56:04',1,'{--\r\n\r\nЗадача 4-2\r\n\r\nОдеров Роман, 545 гр.\r\n\r\n--}\r\n\r\n\r\n\r\n{-Ф-ция parts2\' <xs> <prev1> <prev2> <l1> <l2> <maxl>\r\n\r\n        xs = оставшийся список, подлежащий распределению по двум подспискам\r\n\r\n        prev1 и prev2 = последние элементы подсписков (в силу условия возрастания, в список НЕЛЬЗЯ брать элементы МЕНЬШЕ предыдущего)\r\n\r\n        l1 и l2 = длины подсписков. Должны быть равны ПОЛОВИНЕ ЭЛЕМЕНТОВ исходного списка \r\n\r\n        maxl = Число, половина количества элементов исходного списка\r\n\r\n-}\r\n\r\n{-если количество элементов заведомо нечетно, то раскладывать не имеет смысла.\r\n\r\n  иначе первый элемент \"кидается\" в любой список (первый по умолчанию).\r\n\r\n  Далее бежим по списку и раскидываем элементы туда, куда подходят.  \r\n\r\n  Для пустого второго списка минимальное значение = -(бесконечность)\r\n\r\n-}\r\n\r\n\r\n\r\nparts2 (x:xs) = if (mod (length (x:xs)) 2 == 0) then parts2\' xs x (-1/0) 1 0 (div (length (x:xs)) 2) \r\n\r\n                else False\r\n\r\nparts2\' [] _ _ l1 l2 _ = l1 == l2 -- Когда закончили разбирать список, проверяем одинаковое количество элементов в подсписках\r\n   --- Проверять вроде бы нет смысла - раз в каждом списке не мб больше половины элементов\r\n   --- то в конце обязательно в каждом будет _ровно_ половина\r\n\r\n\r\nparts2\' (x:xs) prev1 prev2 l1 l2 maxl =\r\n\r\n  if (l1>maxl || l2>maxl) then False --если набрали больше половины элементов, False\r\n\r\n  else\r\n\r\n    --если следующий элемент можно поместить в любой из двух подсписков, учитываем оба варианта\r\n\r\n    if (x>prev1 && x>prev2) then parts2\' xs x prev2 (l1+1) l2 maxl || parts2\' xs prev1 x l1 (l2+1) maxl\r\n\r\n    else\r\n\r\n      --если подходит только в один подсписок, добавляем его туда (далее 2 случая в зависимости от подходящего списка):\r\n\r\n      if (x>prev1) then parts2\' xs x prev2 (l1+1) l2 maxl\r\n\r\n      else\r\n\r\n        if (x>prev2) then parts2\' xs prev1 x l1 (l2+1) maxl\r\n\r\n        else False -- если никуда не подходит, False\r\n','<br/>Тесты успешно пройдены!'),(5289,39,'284427','2013-09-22 12:43:21',2,'  --- Нет, тут у вас нет оптимизации, о которой мы говорили..\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nminHeight Empty = -1\r\n\r\nminHeight (Node _ Empty Empty) = 0\r\n\r\nminHeight (Node _ l Empty) = 1 + minHeight l\r\n\r\nminHeight (Node _ Empty r) = 1 + minHeight r\r\n\r\nminHeight (Node _ left right) = \r\n\r\n		let 	l = minHeight left\r\n\r\n			r = minHeight right\r\n\r\n		in\r\n\r\n	if (l > r) then (1 + r) else (1 + l)\r\n','<br/>Тесты успешно пройдены!'),(5286,38,'284427','2013-09-22 12:32:59',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ left right) = 1 + max (height left) (height right)\r\n','<br/>Тесты успешно пройдены!'),(5287,39,'284427','2013-09-22 12:37:06',0,'data Tree = Empty | Node Integer Tree Tree\r\n\n\r\n\nminHeight Empty = -1\r\n\nminHeight (Node _ left right) = \r\n\n		let 	l = minHeight left\r\n\n			r = minHeight right\r\n\n		in\r\n\n	if (l > r) then (1 + r) else (1 + l)\n','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5288,39,'284427','2013-09-22 12:43:06',0,'','Не удалось вычислить выражение \"minHeight (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5285,37,'284427','2013-09-22 12:28:48',1,'minsum (x:xs) = \r\n\r\n	minimum (drop 1 (foldl ((y:ys) k-> k:(k+y):ys) [x] xs))\r\n','<br/>Тесты успешно пройдены!'),(5283,43,'62628590','2013-09-22 12:23:43',0,'prost a b\r\n	|a==0 = (0,1)\r\n	|otherwise =\r\n		let\r\n			(x1,y1) = prost (mod b a) a\r\n		in (y1-(div b a)*x1,x1)','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5284,43,'62628590','2013-09-22 12:26:00',1,'euclid a b\r\n	|a==0 = (0,1)\r\n	|otherwise =\r\n		let\r\n			(x1,y1) = euclid (mod b a) a\r\n		in (y1-(div b a)*x1,x1)','<br/>Тесты успешно пройдены!'),(5282,38,'Valentina Guleva','2013-09-22 12:04:03',1,'data Tree = Empty | Node Integer Tree Tree \r\n\r\n\r\n\r\nheight Empty = 0\r\n\r\nheight (Node _ Empty Empty) = 0\r\n\r\nheight (Node v l r) = 1 + maximum[height l, height r]\r\n','<br/>Тесты успешно пройдены!'),(5281,38,'Valentina Guleva','2013-09-22 12:01:19',0,'data Tree = Empty | Node Integer Tree Tree \r\n\n\r\n\nheight Empty = 0\r\n\nheight (Node v l r) = 1 + maximum[height l, height r]\n','Выражение имеет неправильное значение: height (Node 1 Empty Empty)'),(5278,35,'284427','2013-09-22 11:57:26',1,'distance (a,b) (x,y) = sqrt((a-x)^2 + (b-y)^2)\r\n\r\n\r\n\r\nisosc a b c = let \r\n\r\n				x1 = distance a b\r\n\r\n				x2 = distance b c\r\n\r\n				x3 = distance a c\r\n\r\n			  in\r\n\r\n				if (x1 == x2) || (x2 == x3) || (x1 == x3) then True else False\r\n','<br/>Тесты успешно пройдены!'),(5279,36,'284427','2013-09-22 11:59:53',1,'cubeTable n = map (x -> (x, x^3)) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5280,38,'Valentina Guleva','2013-09-22 12:00:03',0,'data Tree = Empty | Node Integer Tree Tree \r\n\n\r\n\nheightTree Empty = 0\r\n\nheightTree (Node v l r) = 1 + maximum[heightTree l, heightTree r]\n','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5277,37,'Valentina Guleva','2013-09-22 11:37:18',2,'  --- Нет, это не по условию, тут же нельзя использоваь рекурсию\r\n  --- Попробуйте написать эот же с помощью стандартных функций.\r\n  --- Одна из них, конечно яminimum, а вот какие еще?\r\n  --- Если хотите, могу немного подсказать (тогда напишите письмо, пожалуйста) \r\nminsum[a,b] = sum [a, b]\r\n\r\nminsum(a : b : x) = minimum [(sum[a, b]), minsum (b : x)]\r\n','<br/>Тесты успешно пройдены!'),(5275,35,'Valentina Guleva','2013-09-22 11:36:31',1,'isosc :: (Integer, Integer) -> (Integer, Integer) -> (Integer, Integer) -> Bool\r\n\r\nisosc (x1, y1) (x2, y2) (x3, y3) = ((x1 - x2)^2 + (y1 - y2)^2 == (x2 - x3)^2 + (y2 - y3)^2) ||\r\n\r\n								  ((x1 - x3)^2 + (y1 - y3)^2 == (x2 - x3)^2 + (y2 - y3)^2) ||\r\n\r\n								  ((x1 - x2)^2 + (y1 - y2)^2 == (x1 - x3)^2 + (y1 - y3)^2)\r\n','<br/>Тесты успешно пройдены!'),(5276,36,'Valentina Guleva','2013-09-22 11:36:52',1,'cubeTable n = [(x, x^3) | x <- [1..n]]\r\n\r\n\r\n\r\n{-- using standart functions --}\r\n\r\n{--\r\n\r\ncubeTable n = zip [1..n] [x^3 | x <- [1..n]]\r\n\r\n--}\r\n','<br/>Тесты успешно пройдены!'),(5271,36,'5543298','2013-09-22 00:35:43',1,'type Point = (Integer, Integer)\r\n\r\ncubeTable n = map (x -> (x, x^3))([1..n])\r\n','<br/>Тесты успешно пройдены!'),(5272,38,'5543298','2013-09-22 00:48:46',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5273,39,'5543298','2013-09-22 01:31:30',0,'data Tree = Empty | Node Integer Tree Tree\r\n\n\r\n\nisEmpty Empty = True\r\n\nisEmpty (Node x l r) = False\r\n\n\r\n\nminHeight Empty = 0\r\n\nminHeight (Node x l r)  = 1 + if isEmpty l || isEmpty r then -1 else min (minHeight l) (minHeight r)\r\n\n\r\n\n\n','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5274,39,'5543298','2013-09-22 02:01:08',0,'data Tree = Empty | Node Integer Tree Tree\r\n\n\r\n\nisEmpty Empty = True\r\n\nisEmpty (Node x l r) = False\r\n\n\r\n\nminHeight\'::Tree->Integer->Integer\r\n\n\r\n\nminHeightWithStop Empty leftMin result = result\r\n\nminHeightWithStop (Node x l r) leftMin result = if result >= leftMin then leftMin else minHeight\' (Node x l r) (result + 1)\r\n\n\r\n\nminHeight\' Empty result = 10000000\r\n\nminHeight\' (Node x l r) result = if (isEmpty l && isEmpty r) then result + 1 else let leftMin = minHeight\' l (result + 1) in min leftMin (minHeightWithStop r leftMin (result + 1))\r\n\nminHeight (Node x l r) = minHeight\' (Node x l r) (-1)\r\n\n\r\n\n\n','Выражение имеет неправильное значение: minHeight (Node 1 Empty (Node 2 Empty Empty)) '),(5270,39,'62628590','2013-09-22 00:28:35',1,'data Tree = Empty | Node Integer Tree Tree\r\nminHeight x = minHeight0 x (1/0) 0\r\nminHeight0 Empty mh h = mh\r\nminHeight0 (Node _ Empty Empty) _ h = h\r\nminHeight0 (Node _ l r) mh h\r\n	|mh<h = mh\r\n	|otherwise =\r\n		let\r\n			min0 = min mh (minHeight0 l mh (h + 1))\r\n   --- Мне кажется, тут min не нужен. Ваша программа устроена так,\r\n   --- Что вызов minHeight0 l mh (h + 1) не можен вернуть результат\r\n   --- больше своего второго параметра, те mh \r\n		in minHeight0 r min0 (h + 1)','<br/>Тесты успешно пройдены!'),(5267,37,'62628590','2013-09-22 00:08:24',0,'minsum0 (x:xs)=\r\n	let\r\n		(y:ys) = foldl ((z:zs) a->(a:(a+z):zs)) [x] xs\r\n	in minimum ys','Не удалось вычислить выражение \"minsum [1,8,3,2,7] \", проверьте правильность синтаксиса'),(5268,37,'62628590','2013-09-22 00:08:51',1,'minsum (x:xs)=\r\n	let\r\n		(y:ys) = foldl ((z:zs) a->(a:(a+z):zs)) [x] xs\r\n	in minimum ys','<br/>Тесты успешно пройдены!'),(5269,38,'62628590','2013-09-22 00:18:23',1,'data Tree = Empty | Node Integer Tree Tree\r\nheight Empty = -1\r\nheight (Node _ l r) = max (height l) (height r) + 1','<br/>Тесты успешно пройдены!'),(5264,35,'62628590','2013-09-21 23:47:32',1,'isosc (x1,y1) (x2,y2) (x3,y3) = \r\n	let\r\n		a = sqrt ((x1 - x2)^2 + (y1 - y2)^2)\r\n		b = sqrt ((x2 - x3)^2 + (y2 - y3)^2)\r\n		c = sqrt ((x1 - x3)^2 + (y1 - y3)^2)\r\n	in a == b || b == c || c == a','<br/>Тесты успешно пройдены!'),(5265,36,'62628590','2013-09-21 23:50:45',1,'cubeTable n = map (i->(i,i^3)) [1..n]','<br/>Тесты успешно пройдены!'),(5266,37,'62628590','2013-09-22 00:06:56',0,'minsum (x1:x2:xs)=\r\n	let\r\n		(y:ys) = foldl ((z:zs) a->(a:(a+z):zs)) [x1+x2] xs\r\n	in minimum ys','Не удалось вычислить выражение \"minsum [1,1]\", проверьте правильность синтаксиса'),(5263,35,'62628590','2013-09-21 23:43:07',0,'isosc (x1,y1) (x2,y2) (x3,y3) = \r\nlet\r\n	a = sqrt ((x1 - x2)^2 + (y1 - y2)^2)\r\n	b = sqrt ((x2 - x3)^2 + (y2 - y3)^2)\r\n	c = sqrt ((x1 - x3)^2 + (y1 - y3)^2)\r\nin a == b || b == c || c == a','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5262,39,'87635585','2013-09-21 23:34:45',1,'---Нет, это не совсем по условию. Недо как-то записать оптимизацию\r\n--- \"если у нас уже найдено расстояние X то глубже X нам заходить не надо\"\r\n--- Ну иличто-то в таком роде\r\ndata Tree = Empty |  Node Integer Tree Tree\r\nminHeight Empty = 1/0\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ a b) = let l = minHeight a\r\n                             r = minHeight b in if l == 1/0 then 1 + r else 1 + min l r','<br/>Тесты успешно пройдены!'),(5261,39,'87635585','2013-09-21 23:33:07',0,'\r\ndata Tree = Empty |  Node Integer Tree Tree\r\nminHeight Empty = 1/0\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ a b) = let l = minHeight a\r\n                             r = minHeight b in if l == 1/0 then r else 1 + min l r','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5249,45,'55363692','2013-09-21 18:44:37',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    internal class Program\r\n\r\n    {\r\n\r\n        private static bool Check(IEnumerable<IEnumerable<int>> m)\r\n\r\n        {\r\n\r\n            return m.All(row => row.Any(x => x%2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        private static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(Check(new[] {new[] {1, 2, 3}, new[] {1, 2}}));\r\n\r\n            Console.WriteLine(Check(new[] {new[] {1, 2, 3}, new[] {1, 3}}));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5250,30,'egeorge','2013-09-21 19:04:43',1,'ascLen [_] = 1\r\nascLen (x:y:xs) = if y > x\r\n                  then 1 + ascLen (y:xs) \r\n                  else 1\r\n                \r\nascLenList [] = []\r\nascLenList xs = let l = ascLen xs\r\n                in l : ascLenList (drop l xs)\r\n\r\nlistGcd [x] = x\r\nlistGcd (x:xs) = gcd x (listGcd xs)\r\n\r\nparts xs = (listGcd (ascLenList xs)) >= 2','<br/>Тесты успешно пройдены!'),(5251,31,'54411321','2013-09-21 20:31:01',1,'do_parts2 _ [] 0 0 = True\r\n\r\ndo_parts2 _ [] _ _ = False\r\n\r\ndo_parts2 (x, y) (z:l) m k = if z <= min x y \r\n\r\n                             then False\r\n\r\n                             else (if m > 0 && x < z then do_parts2 (z, y) l (m-1) k else False) ||\r\n\r\n                                  (if k > 0 && y < z then do_parts2 (x, z) l m (k-1) else False)\r\n\r\n\r\n\r\nparts2 (x:l) = let\r\n\r\n                   len = length (x:l)\r\n\r\n               in (len `mod` 2 == 0) && \r\n\r\n                  (do_parts2 (x, -1 / 0) l (len `div` 2 - 1) (len `div` 2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5252,35,'87635585','2013-09-21 22:37:50',0,'\r\nisosс (a , a0) (b, b0) (c, c0) = (c - a)*(c - a) + (c0 - a0)*(c0 - a0) == (c - b)*(c - b) + (c0 - b0)*(c0 - b0) ||\r\n                                (c - a)*(c - a) + (c0 - a0)*(c0 - a0) == (a - b)*(a - b) + (a0 - b0)*(a0 - b0) ||\r\n                                (c - b)*(c - b) + (c0 - b0)*(c0 - b0) == (a - b)*(a - b) + (a0 - b0)*(a0 - b0)','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5253,35,'5543298','2013-09-21 22:53:12',1,'type Point = (Integer, Integer)\r\n\r\nisOnLine (x1, y1) (x2, y2) (x3, y3) = (x3 - x1) * (y2 - y1) == (y3 - y1) * (x2 - x1)\r\n\r\ndistance2 (x1, y1) (x2, y2) = (x1 - x2)^2 + (y1 - y2)^2\r\n\r\nisosc (x1, y1) (x2, y2) (x3, y3) = let\r\n\r\n											a = (x1, y1)\r\n\r\n											b = (x2, y2)\r\n\r\n											c = (x3, y3)\r\n\r\n										in (not(isOnLine a b c)) && (distance2 a b == distance2 a c || distance2 a b == distance2 b c || distance2 a c == distance2 b c)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5254,35,'87635585','2013-09-21 22:54:23',1,'isosc (a , a0) (b, b0) (c, c0) = (c - a)*(c - a) + (c0 - a0)*(c0 - a0) == (c - b)*(c - b) + (c0 - b0)*(c0 - b0) ||\r\n                                (c - a)*(c - a) + (c0 - a0)*(c0 - a0) == (a - b)*(a - b) + (a0 - b0)*(a0 - b0) ||\r\n                                (c - b)*(c - b) + (c0 - b0)*(c0 - b0) == (a - b)*(a - b) + (a0 - b0)*(a0 - b0)','<br/>Тесты успешно пройдены!'),(5255,36,'5543298','2013-09-21 22:57:07',0,'type Point = (Integer, Integer)\r\n\ncubeTable n = map (x -> (x, x^3))([1..n])\n','<br/>Тесты успешно пройдены!'),(5256,36,'87635585','2013-09-21 22:59:31',1,'cubeTable n = map (x -> (x, x^3)) [1..n]','<br/>Тесты успешно пройдены!'),(5257,37,'87635585','2013-09-21 23:11:05',1,'minsum l = minimum (map ((a, b)-> a + b) (zip (tail l) l))','<br/>Тесты успешно пройдены!'),(5258,38,'87635585','2013-09-21 23:17:18',1,'data Tree = Empty |  Node Integer Tree Tree\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ a b) = 1 + max (height a) (height b)','<br/>Тесты успешно пройдены!'),(5259,33,'1048693','2013-09-21 23:29:32',1,'#include <iostream>\r\n\r\n#include <functional>\r\n\r\n \r\n\r\n#include <utility>\r\n\r\n#include <list>\r\n\r\n \r\n\r\nusing namespace std;\r\n\r\n \r\n\r\n// higher-order funtions\r\n\r\n \r\n\r\ntemplate <typename Domain, typename Codomain>\r\nlist<Codomain> map(function<Codomain (Domain)> f, list<Domain> xs) {\r\n   --- Если вы используете шаблоны, то лучше, видимо добавить параметр для типа функции, \r\n   --- получится более generic\r\n   --- Еще видимо лучше передавать list по ссылке. В общем,я бы написал как-то так:\r\n--- template <typename Domain, typename Codomain, typename Func>\r\n--- list<Codomain> map(Func f, const list<Domain>& xs) {\r\n  \r\n    list<Codomain> mapped;\r\n\r\n    for (const Domain x : xs) {\r\n  --- или можно auto x :xs \r\n\r\n        mapped.push_back(f(x));\r\n\r\n    }\r\n\r\n    return mapped;\r\n\r\n}\r\n\r\n \r\n\r\ntemplate <typename Codomain, typename First, typename Second, typename Third>\r\n\r\nfunction<Codomain (Second,Third)> apply3(function<Codomain (First, Second,Third)> f, First first) {\r\n\r\n    auto applied = [f,first](Second second, Third third) -> Codomain {\r\n\r\n        return f(first,second,third);\r\n\r\n    };\r\n\r\n    return applied;\r\n\r\n}\r\n\r\n \r\n\r\ntemplate <typename Codomain, typename First, typename Second>\r\n\r\nfunction<Codomain (pair<First,Second>)> uncurry(function<Codomain (First,Second)> f) {\r\n\r\n    auto curried = [f](pair<First,Second> p) -> Codomain {\r\n\r\n        return f(p.first,p.second);\r\n\r\n    };\r\n\r\n    return curried;\r\n\r\n}\r\n\r\n \r\n\r\n// solution\r\n\r\n \r\n\r\ndouble integral(function<double (double)> f, double l, double r) {\r\n\r\n   static const double resolution = 0.0001;\r\n\r\n   if (l > r) {\r\n\r\n       double x = l;\r\n\r\n       l = r; r = l;\r\n  --- или std::swap(l, r);\r\n   }\r\n\r\n   \r\n\r\n   const double range = r - l;\r\n\r\n   const double step  = range * resolution;\r\n\r\n   \r\n\r\n   double result = 0;\r\n\r\n   for (double x = l; x <= r - step; x += step) {\r\n\r\n       result += f(x) * step;\r\n\r\n   }\r\n\r\n   return result;\r\n\r\n}\r\n\r\n\r\n\r\nbool print(double x) {\r\n\r\n    cout << x << endl;\r\n\r\n    return true;\r\n\r\n}\r\n\r\n \r\n\r\nint main()\r\n\r\n{\r\n\r\n    typedef pair<double,double> bounds;\r\n\r\n    #define functiond function<double (double)>\r\n\r\n    #define uncurryd  uncurry<double,double,double>\r\n\r\n    #define apply3d   apply3<double,functiond,double,double>\r\n\r\n    #define mapd_     map<double,bool>\r\n\r\n\r\n\r\n    auto f = [](double x) -> double {\r\n\r\n        return x*x;\r\n\r\n    };\r\n\r\n\r\n\r\n    list<bounds> xs = {{1,2},{3,4},{5,6}};\r\n\r\n    list<double> ys = map(uncurryd(apply3d(integral, f)), xs);\r\n\r\n    mapd_(print, ys);\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5260,39,'87635585','2013-09-21 23:30:57',0,'data Tree = Empty |  Node Integer Tree Tree\r\nminHeight Empty = 1/0\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ a b) = let l = minHeight a in if l == 1/0 then 1/0 else 1 + min l (minHeight b)','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5248,33,'3270666','2013-09-21 18:32:56',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace FPIntegral\r\n{\r\n    class Program\r\n    {\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double h = (b - a) / 100.0;\r\n            double res = 0;\r\n\r\n            for (int i = 1; i <= 100; i++)\r\n            {\r\n                res += f(a + h * (i - 0.5));\r\n            }\r\n            res *= h;\r\n\r\n            return res;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Integral(sin, 0, pi) = {0}\", \r\n                Integral(Math.Sin, 0, Math.PI)); // Должно быть примерно 2\r\n            Console.WriteLine(\"Integral(cos, 0, pi) = {0}\", \r\n                Integral(Math.Cos, 0, Math.PI)); // Должно быть примерно 0\r\n            Console.WriteLine(\"Integral(x*x, 0, 1) = {0}\", \r\n                Integral(x => x * x, 0, 1)); // Должно быть примерно 1/3\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5247,31,'1048693','2013-09-21 17:49:40',2,'  --- Нет, у вас уж очень неэффективно. Вы же, если я правильно понял,\r\n  --- генерируете все разбиения списка на 2 части и потом проверяете\r\n  --- что эти части возрастающие.\r\n  --- Вы, пожалуйста, добавьте по крайней мере такие оптимизации:\r\n  ---  - при добавлении элемента в список мы проверяем, что последовательность\r\n  ---    остается возрастающей\r\n  ---  - при добавлении проверяем, что в последовательности не больше половины элементов\r\n  ---     всего списка.\r\nimport Data.Maybe\r\n\r\n\r\n\r\ndata Accumulator a = Fail | Step a Int | Begin\r\n\r\n\r\n\r\nextract :: Accumulator a -> Bool\r\n\r\nextract (Step _ 1) = False\r\n\r\nextract (Step _ _) = True\r\n\r\nextract _          = False\r\n\r\n\r\n\r\nparts  :: Ord a => [a] -> Bool\r\n\r\nparts  xs = or [ extract $ foldl (step l) Begin xs | l <- [2 .. length xs] ]\r\n\r\n    where\r\n\r\n        step _ Fail       _ = Fail\r\n\r\n        step _ Begin      y = Step y 1\r\n\r\n        step l (Step x k) y | k == l = Step y 1\r\n\r\n        step _ (Step x k) y | x <  y = Step y $ k + 1\r\n\r\n        step l (Step x k) _ | k <  l = Fail\r\n\r\n        step _ _          _ = Fail\r\n\r\n\r\n\r\nparts2 :: Ord a => [a] -> Bool\r\n\r\nparts2 xs =\r\n\r\n    let n = length xs\r\n\r\n    in if n `mod` 2 == 1\r\n\r\n       then False\r\n\r\n       else work (n `div` 2) 0 [] [] xs\r\n\r\n           where\r\n\r\n                check :: Ord a => (a -> a -> Bool) -> [a] -> Bool\r\n\r\n                check f xs@(x:xt) = and $ zipWith f xs xt\r\n\r\n                check _       []  = True\r\n\r\n\r\n\r\n                work k = work\'\r\n\r\n                    where\r\n\r\n                        work\' l ls rs (y:ys) = work\' (l + 1) (y:ls) rs ys || work\' l ls (y:rs) ys\r\n\r\n                        work\' l ls rs    []  | l == k = check (>) ls && check (>) rs\r\n\r\n                        work\' _ _  _     _   = False\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5246,31,'1048693','2013-09-21 17:44:03',0,'import Data.Maybe\n\n\n\ndata Accumulator a = Fail | Step a Int | Begin\n\n\n\nextract :: Accumulator a -> Bool\n\nextract (Step _ 1) = False\n\nextract (Step _ _) = True\n\nextract _          = False\n\n\n\nparts  :: Ord a => [a] -> Bool\n\nparts  xs = or [ extract $ foldl (step l) Begin xs | l <- [2 .. length xs] ]\n\n    where\n\n        step _ Fail       _ = Fail\n\n        step _ Begin      y = Step y 1\n\n        step l (Step x k) y | k == l = Step y 1\n\n        step _ (Step x k) y | x <  y = Step y $ k + 1\n\n        step l (Step x k) _ | k <  l = Fail\n\n        step _ _          _ = Fail\n\n\n\nparts2 :: Ord a => [a] -> Bool\n\nparts2 xs =\n\n    let n = length xs\n\n    in if n `mod` 2 == 1\n\n       then False\n\n       else work (n `div` 2) 0 [] [] xs\n\n           where\n\n                check :: Ord a => (a -> a -> Bool) -> [a] -> Bool\n\n                check f xs@(x:xt) = and $ map (uncurry f) $ zip xs $ xt\n\n                check _       []  = True\n\n\n\n                work k = work\'\n\n                    where\n\n                        work\' l ls rs (y:ys) = work\' (l + 1) (y:ls) rs ys || work\' l ls (y:rs) ys\n\n                        work\' l ls rs    []  | l == k = check (>) ls && check (>) rs\n\n                        work\' _ _  _     _   = False\n\n\n','<br/>Тесты успешно пройдены!'),(5245,30,'1048693','2013-09-21 16:47:56',1,'  --- ОК, но в данном случае есть горазно более эффективное решение, за один проход по списку\r\n  --- Мы это обсудим\r\nimport Data.Maybe\r\n\r\n\r\n\r\ndata Accumulator a = Fail | Step a Int | Begin\r\n\r\n\r\n\r\nextract :: Accumulator a -> Bool\r\n\r\nextract (Step _ 1) = False\r\n\r\nextract (Step _ _) = True\r\n\r\nextract _          = False\r\n\r\n\r\n\r\nparts :: Ord a => [a] -> Bool\r\n\r\nparts xs = or [ extract $ foldl (step l) Begin xs | l <- [2 .. length xs] ]\r\n\r\n    where\r\n\r\n        step _ Fail       _ = Fail\r\n\r\n        step _ Begin      y = Step y 1\r\n\r\n        step l (Step x k) y | k == l = Step y 1\r\n\r\n        step _ (Step x k) y | x <  y = Step y $ k + 1\r\n\r\n        step l (Step x k) _ | k <  l = Fail\r\n\r\n        step _ _          _ = Fail\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5244,30,'54411321','2013-09-21 15:54:44',1,'increasing l = not (any ((x,y) -> x >= y) (zip l (tail l)))\r\n\r\n\r\n\r\nparts [] = True\r\n\r\nparts l = let\r\n\r\n            len = length l\r\n\r\n          in any (x -> if (len `mod` x /= 0)\r\n\r\n                        then False \r\n\r\n                        else (increasing (take x l)) && parts (drop x l)) [2..len]\r\n   --- или немного короче x -> len `mod` x /= 0 &&  increasing (take x l)) && parts (drop x l)) [2..len]\r\n   --- Еще, на самом деле, эту задачу можно сделать существенно эффективнее, а один проход по списку.\r\n   --- Мы это обсудим, если останется время. \r\n','<br/>Тесты успешно пройдены!'),(5243,35,'anna','2013-09-21 15:50:49',1,'--data Point = Pt Integer Integer\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nisosc (x1, y1) (x2, y2) (x3, y3)= \r\n\r\n              let     a = sqrt((x1-x2)^2 + (y1-y2)^2)\r\n\r\n                      b = sqrt((x1-x3)^2 + (y1-y3)^2)\r\n\r\n                      c = sqrt((x3-x2)^2 + (y3-y2)^2)\r\n\r\n				  in\r\n\r\n              if a == b || b == c || c == a then True else False\r\n','<br/>Тесты успешно пройдены!'),(5241,38,'anna','2013-09-21 14:08:07',1,'data Tree a = Empty | Node a (Tree a)(Tree a)	 \r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ n1 n2) = 1 + max (height n1) (height n2)\r\n','<br/>Тесты успешно пройдены!'),(5242,45,'3320654','2013-09-21 14:42:35',1,'using System;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication2\r\n{\r\n    class Program\r\n    {\r\n        static bool checkMethod(int [][] a) {            \r\n            return a.All(x => x.Any(y => (y % 2) == 0));\r\n    }\r\n        static void Main(string[] args)\r\n        {\r\n            int[][] a = new int[3][];\r\n            a[0] = new int[4] { 1, 2, 3, 4};\r\n            a[1] = new int[3] { 1, 2, 3 };\r\n            a[2] = new int[1] { 2 };\r\n            Console.WriteLine(checkMethod(a));            \r\n            a[2][0] = 1;\r\n            Console.WriteLine(checkMethod(a));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5239,38,'anna','2013-09-21 14:07:15',0,'','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5240,18,'anna','2013-09-21 14:07:37',1,'data Tree a = Empty | Node a (Tree a)(Tree a)	 \r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ n1 n2) = 1 + max (height n1) (height n2)\r\n','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(5237,43,'55363692','2013-09-21 01:53:06',1,'euclid a b = \r\n\r\n	if b == 0 then \r\n\r\n		(1, 0) \r\n\r\n	else \r\n\r\n		(t, s - q * t) where \r\n\r\n			q = a `div` b\r\n\r\n			r = a `mod` b\r\n\r\n			(s, t) = euclid b r\r\n','<br/>Тесты успешно пройдены!'),(5238,45,'deripaska','2013-09-21 02:56:41',1,'/* \r\n\r\n    task 08-01\r\n\r\n*Задача (скорее упражнение) на \"обычном\" языке*\r\n\r\n\r\n\r\nВ С# для контейнеров определен метод Any, который позволяет проверить, есть ли в контейнере элемент, удовлетворяющий данному условию. И есть аналогичный метод All. Вот примеры их вызовов:\r\n\r\n\r\n\r\nint [] a = {-1, 2, -3, 4};\r\n\r\nbool b = a.Any(x => x > 0); // Верно, ли что в массиве есть положительный элемент?\r\n\r\nb = a.All(x => x > 0); // Верно, ли что все элементы в массиве положительные?\r\n\r\n\r\n\r\nИспользуя только эти методы и лямбда выражения, проверить для данного двумерного массива массивов (или, если хотите, списка списков), \r\n\r\nчто в каждом из массивов есть хотя бы один четный элемент.\r\n\r\n*/\r\n\r\n\r\n\r\nusing System;\r\n\r\nusing System.Linq;\r\n\r\n\r\n\r\nnamespace Task_08_01\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static bool hasAtLeastOneParityInEach(int[][] doubleMas)\r\n\r\n        {\r\n\r\n            return doubleMas.All(xs => xs.Any(x => x % 2 == 0));\r\n\r\n        }\r\n\r\n\r\n\r\n        static void printDoubleMasWithResult(int[][] doubleMas)\r\n\r\n        {\r\n\r\n            foreach (int[] mas in doubleMas) {\r\n\r\n                foreach (int element in mas) {\r\n\r\n                    Console.Write(element + \" \");\r\n\r\n                }\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n            Console.WriteLine(hasAtLeastOneParityInEach(doubleMas));\r\n\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            int[][] mas1 = { new int[] { 1, 2, 3 }, new int[] { 4, 5, 6}, new int[] { 7, 8, 9 } }; // true\r\n\r\n            int[][] mas2 = { new int[] { 1, 3, 5, 7, 9 }, new int[] { 10, 11, 13 }, new int[] { 14, 15, 16, 20, 3, 3 } }; //false\r\n\r\n            int[][] mas3 = { new int[] { 1, 4 }, new int[] { 5, 6 }, new int[] { 8, 9, 9 }, new int[] { 10, 13, 11 } }; //true\r\n\r\n\r\n\r\n            printDoubleMasWithResult(mas1);\r\n\r\n            printDoubleMasWithResult(mas2);\r\n\r\n            printDoubleMasWithResult(mas3);\r\n\r\n            Console.Read();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5236,33,'SNNatalieS','2013-09-21 01:26:07',1,'using System;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double h = (b - a) / 100;\r\n            double res = 0;\r\n            for (int i = 1; i < 100; i++)\r\n            {\r\n                res += f(a + i * h - h / 2);\r\n            }            \r\n            return (res * h);\r\n        }\r\n\r\n        static double Cube(double i)\r\n        {\r\n            return i * i * i;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Func<double, double> sqr = i => i * i;\r\n            double result = Integral(x => x * x, 0, 1);\r\n            Console.WriteLine(result);\r\n            result = Integral(Cube, 0, 1);\r\n            Console.WriteLine(result);\r\n            result = Integral(sqr, 0, 1);\r\n            Console.WriteLine(result);\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5234,38,'SNNatalieS','2013-09-21 00:50:52',1,'data Tree = Empty | \r\n	Node Integer Tree Tree\r\n		deriving Show\r\n\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = 1 + max (height l) (height r)','<br/>Тесты успешно пройдены!'),(5235,39,'55363692','2013-09-21 00:57:32',1,'data Tree a = Empty |\r\n\r\n   		Node a (Tree a) (Tree a) \r\n\r\n\r\n\r\nminHeight\' curMin curHeight Empty = curMin\r\n\r\nminHeight\' curMin curHeight (Node a Empty Empty) = curHeight\r\n\r\nminHeight\' curMin curHeight (Node a left right)	= \r\n\r\n	if curMin == curHeight \r\n\r\n	then curMin \r\n\r\n	else minHeight\' (minHeight\' curMin (curHeight + 1) left) (curHeight + 1) right	\r\n\r\n		\r\n\r\nminHeight a = minHeight\' (1/0) 0 a\r\n','<br/>Тесты успешно пройдены!'),(5233,38,'55363692','2013-09-20 23:26:53',1,'data Tree a = Empty |\r\n\r\n   		Node a (Tree a) (Tree a) \r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node a x y) = 1 + max (height x) (height y)\r\n','<br/>Тесты успешно пройдены!'),(5232,37,'55363692','2013-09-20 23:19:24',1,'minsum (x:xs) = minimum $ map ((x, y) -> x + y) (zip (x:xs) xs)\r\n','<br/>Тесты успешно пройдены!'),(5231,36,'55363692','2013-09-20 23:15:15',1,'cubeTable n = map (x -> (x, x^3)) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5221,37,'2156724','2013-09-20 16:40:15',1,'minsum (x:xs) =\r\n\r\n   let a = take (length xs) (x:xs)\r\n     --- Это не надо, все равно zip отбросит лишне элементы более длинного списка\r\n       b = xs       \r\n\r\n       c = zip a b\r\n\r\n       d = map ((x, y) -> x+y) c\r\n\r\n  in minimum d\r\n','<br/>Тесты успешно пройдены!'),(5222,45,'115753099','2013-09-20 19:25:57',1,'using System;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace ConsoleApplication\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // я попробовал сделать то же самое для int [,] mas = new int[3,3]{{1,2,3},{4,5,6},{7.8.9}};\r\n            // но на строчку mas.All компилятор сказал, что не знает метода All для int[*,*]\r\n--- Тут можно использовать int [][] т.е. массив массивов, как-то так:\r\n---         int [][] list = new int [][] { \r\n---             new int[] { 1, 2, 3}, \r\n---             new int[] { 4, 5, 6 }, \r\n---             new int[] { 7, 10, 11 } };\r\n--- Еще, кстати, и для списка списков инициализацию можно написать короче, без массивов\r\n---          List<List<int>> list = new List<List<int>> {\r\n---             new List<int> { 1, 2, 3 }, \r\n---             new List<int> { 4, 5, 6 }, \r\n---             new List<int> { 7, 10, 11 } };\r\n \r\n            List<List<int>> list = new List<List<int>> { new List<int>(new int[] { 1, 2, 3 }), new List<int>(new int[] { 4, 5, 6 }), new List<int>(new int[] { 7, 10, 11 }) };\r\n\r\n            bool b = list.All(masItem => masItem.Any(x => x % 2 == 0));\r\n\r\n            Console.WriteLine(b);\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5223,31,'3270666','2013-09-20 19:28:26',1,'parts2 xs = let l = length xs\r\n                n = l `div` 2\r\n            in if ((l `mod` 2) == 0)\r\n	        	then parts2\' xs 0 n 0 n\r\n	        	else False\r\n\r\nparts2\' [] _ cap1 _ cap2 = (cap1 == 0) && (cap2 == 0)\r\nparts2\' (x:xs) min1 cap1 min2 cap2 = \r\n	let try1 = (x > min1) && (cap1 > 0)\r\n	    try2 = (x > min1) && (cap2 > 0)\r\n	in (try1 && parts2\' xs x (cap1 - 1) min2 cap2) || \r\n	   (try2 && parts2\' xs min1 cap1 x (cap2 - 1))','<br/>Тесты успешно пройдены!'),(5224,36,'2501950','2013-09-20 19:33:30',1,'cubeTable n = let\r\n               xs = [1..n]\r\n               cube i = i*i*i \r\n               cubexs = map cube xs\r\n              in zip xs cubexs   ','<br/>Тесты успешно пройдены!'),(5225,45,'anlun','2013-09-20 21:47:15',1,'#include <iostream>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nbool check(vector< vector<int> > t) {\r\n  --- Не по теме курса, но вообще вектора лучше передавать с помощью константной ссылки, это горадо эффективнее.\r\n  --- Те лучше const k(vector< vector<int>>& t _ и то же дальше в лямбда выражении\r\n	return all_of(t.begin(), t.end(),\r\n		[](vector<int> line) {\r\n			return any_of(line.begin(), line.end(),\r\n				[](int i) { return !(i & 0x01); }\r\n			);\r\n		}\r\n	);\r\n}\r\n\r\nint main() {\r\n	vector<int> line1 = {1, 2, 3, 4};\r\n	vector<int> line2 = {1, 3, 5};\r\n	vector<int> line3 = {2, 4};\r\n\r\n	vector< vector<int> > t1 = { line1, line2, line3};\r\n	cout << check(t1) << endl;\r\n	\r\n	vector< vector<int> > t2 = { line1,        line3};\r\n	cout << check(t2) << endl;\r\n\r\n	return 0;\r\n}','<br/>Тесты успешно пройдены!'),(5226,35,'54411321','2013-09-20 22:14:00',1,'abs2 (x1, y1) (x2, y2) = ((x1 - x2) ^ 2) + ((y1 - y2) ^ 2)\r\n\r\n\r\n\r\nisosc x y z = let\r\n\r\n                a = abs2 x y\r\n\r\n                b = abs2 y z\r\n\r\n                c = abs2 z x\r\n\r\n               in (a == b) || (b == c) || (c == a)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5227,36,'54411321','2013-09-20 22:24:12',1,'cubeTable i = zip [1..i] (map (x -> x ^ 3) [1..i])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5228,37,'54411321','2013-09-20 22:44:42',1,'minsum l = minimum (map ((x, y) -> x + y) (zip l (tail l)))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5229,38,'54411321','2013-09-20 22:57:04',1,'data Tree = Empty | \r\n\r\n            Node Integer Tree Tree\r\n\r\n            \r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ l r) = 1 + max (height l) (height r)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5230,35,'55363692','2013-09-20 23:12:56',1,'dist (x1, y1) (x2, y2) = sqrt ((x2 - x1)^2 + (y2 - y1)^2)\r\n\r\n\r\n\r\ncheck\' x y z = x == y && x + y > z\r\n\r\ncheck x y z = check\' x y z || check\' x z y || check\' y z x\r\n\r\n\r\n\r\nisosc a b c = check (dist a b) (dist a c) (dist b c)\r\n','<br/>Тесты успешно пройдены!'),(5220,37,'2156724','2013-09-20 16:36:13',0,'minsum (x:xs) =\r\n\n   let a = take (length xs) (x:xs)\r\n\n       b = xs       \r\n\n       c = zip a b\r\n\n       d = map ((x, y) -> x+y) c\r\n\n  in minimum d:[]\n','Выражение имеет неправильное значение: minsum [1,8,3,2,7] '),(5219,30,'3270666','2013-09-20 16:33:02',1,'--- OK, засчитано, но тут можно сделать гораздо эффективнее, в один проход.\r\n--- Мы это немного обсудим, я думаю.\r\nparts xs = parts\' xs 2\r\n\r\nparts\' xs n = let l = length xs\r\n	in if (n <= l) \r\n		then ((check_div l n) && (divide xs n)) || (parts\' xs (n + 1))\r\n		else False\r\n\r\ncheck_div a b = (a `mod` b) == 0\r\n\r\ndivide xs n = divide\' xs n 1\r\n\r\ndivide\' (_:[]) _ _ = True\r\ndivide\' (x1:x2:xs) n m = if (m == n)\r\n	then divide\' (x2:xs) n 1\r\n	else if (x2 > x1) then divide\' (x2:xs) n (m + 1) else False','<br/>Тесты успешно пройдены!'),(5218,36,'2156724','2013-09-20 16:20:05',1,'cubeTable n =\r\n\r\n   let a =  [1..n]\r\n\r\n       b =  [x * x * x | x<-[1..n]] in zip a b\r\n','<br/>Тесты успешно пройдены!'),(5217,36,'2156724','2013-09-20 16:19:53',0,'','Не удалось вычислить выражение \"cubeTable 4\", проверьте правильность синтаксиса'),(5216,35,'2156724','2013-09-20 16:06:30',1,'isosc (x1,y1) (x2,y2) (x3,y3) =\r\n\r\n      if dist (x1,y1) (x2, y2) == dist (x2,y2) (x3, y3) then True\r\n\r\n      else\r\n\r\n        if dist (x1,y1) (x2, y2) == dist (x1,y1) (x3, y3) then True\r\n\r\n      else\r\n\r\n 	if dist (x1,y1) (x3, y3) == dist (x3,y3) (x2, y2) then True\r\n\r\n      else False       \r\n\r\n\r\n\r\ndist (x1,y1) (x2,y2) = sqrt ((x1-x2) * (x1-x2) + (y1-y2)*(y1-y2))\r\n','<br/>Тесты успешно пройдены!'),(5215,35,'2156724','2013-09-20 16:05:48',0,'','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5213,37,'toskira','2013-09-20 14:45:03',1,'minsum (h:t) = (minimum . map ((a,b) -> a + b)) (zip t (h:t))','<br/>Тесты успешно пройдены!'),(5214,35,'2156724','2013-09-20 16:01:56',0,'isosc (x1,y1) (x2,y2) (x3,y3) =\r\n\n      if dist (x1,y1) (x2, y2) == dist (x2,y2) (x3, y3) then True\r\n\n      else\r\n\n        if dist (x1,y1) (x2, y2) == dist (x1,y1) (x3, y3) then True\r\n\n      else\r\n\n 	if dist (x1,y1) (x3, y3) == dist (x3,y3) (x2, y2) then True\r\n\n      else False       \r\n\n\r\n\ndist (x1,y1) (x2,y2) = sqrt (((x1-x2) + (y1 - y2)) * ((x1-x2) + (y1 - y2)))\n','Выражение имеет неправильное значение: isosc (0,5) (3,4) (5,0)'),(5211,35,'toskira','2013-09-20 14:30:24',1,'isosc a b c = let l1 = len a b\r\n                  l2 = len b c\r\n                  l3 = len c a\r\n              in (l1 == l2) || (l2 == l3) || (l3 == l1)\r\n\r\n\r\nlen (ax, ay) (bx, by) = sqrt ((ax - bx) ^ 2 + (ay - by) ^ 2)','<br/>Тесты успешно пройдены!'),(5212,36,'toskira','2013-09-20 14:34:01',1,'cubeTable n = map (x -> (x, x^3)) [1..n]','<br/>Тесты успешно пройдены!'),(5210,43,'anlun','2013-09-20 10:07:19',1,'euclid :: Integer -> Integer -> (Integer, Integer)\r\neuclid 0 _ = (0, 1)\r\neuclid _ 0 = (1, 0)\r\neuclid a b =\r\n	let (x, y) = euclid (b `mod` a) a in\r\n	(y - (b `div` a) * x, x)','<br/>Тесты успешно пройдены!'),(5209,33,'4604056','2013-09-20 01:20:59',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ConsoleApplication2\r\n{\r\n    class Program\r\n    {\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double step = (b - a) / 100;\r\n            double result = 0;\r\n            for (double x = a; x <= b; x += step)\r\n            {\r\n                result += ((f(x) + f(x+step)) / 2);\r\n            }\r\n            result *= step;\r\n            return result;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Func<double, double> test = r => r * r;\r\n            Console.WriteLine(Integral(test, 0, 1));\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(5208,23,'ArtemK','2013-09-19 20:38:35',1,'c n = c\' 1 n []\r\nc\' x 0 xs = if isPrimePairs xs then 1\r\n            else 0\r\nc\' x n xs = if x > n\r\n        then 0\r\n        else (c\' (x+1) n xs) + (c\' (x+1) (n-x) (x:xs))\r\nisPrimePairs [] = True\r\nisPrimePairs (x:[]) = True\r\nisPrimePairs (x:xs) = (isPrimePairs\' x xs) && (isPrimePairs xs)\r\nisPrimePairs\' y [] = True\r\nisPrimePairs\' y (x:xs) = if (gcd x y) == 1 then isPrimePairs\' y xs\r\n                         else False','<br/>Тесты успешно пройдены!'),(5204,43,'3320654','2013-09-19 19:33:09',0,'euclid a b = euclid\' a b 1 0 0 1\r\n\r\neuclid\' _ 0 x2 _ y2 _	= (x2,y2)\r\neuclid\' a b x2 x1 y2 y1 = if a > b\r\n		   then euclid\' b (mod a b) x1 (x2 - x1 * (div a b)) y1 (y2 - y1 * (div a b))\r\n		   else euclid\' (mod b a) a x1 (x2 - x1 * (div b a)) y1 (y2 - y1 * (div b a))','Выражение имеет неправильное значение: let (x,y) = euclid 3 5 in 3*x+5*y'),(5205,43,'3320654','2013-09-19 19:34:31',0,'euclid a b = euclid\' a b 1 0 0 1\r\n\r\neuclid\' _ 0 x2 _ y2 _	= (x2,y2)\r\neuclid\' a b x2 x1 y2 y1 = if a > b\r\n		   then euclid\' b (mod a b) x1 (x2 - x1 * (div a b)) y1 (y2 - y1 * (div a b))\r\n		   else euclid\' a (mod b a) x1 (x2 - x1 * (div b a)) y1 (y2 - y1 * (div b a))','Выражение имеет неправильное значение: let (x,y) = euclid 3 5 in 3*x+5*y'),(5206,43,'3320654','2013-09-19 19:37:03',1,'euclid a b = euclid\' a b 1 0 0 1\r\n\r\neuclid\' _ 0 x2 _ y2 _	= (x2,y2)\r\neuclid\' a b x2 x1 y2 y1 = if a > b\r\n		   then euclid\' b (mod a b) x1 (x2 - x1 * (div a b)) y1 (y2 - y1 * (div a b))\r\n		   else euclid\' a (mod b a) y1 (y2 - y1 * (div b a)) x1 (x2 - x1 * (div b a))','<br/>Тесты успешно пройдены!'),(5207,22,'ArtemK','2013-09-19 20:15:50',1,'g n = g\' n (n-1)\r\ng\' n 0 = False\r\ng\' n m = if (not (m == (n-m))) && (isPrime m) && (isPrime (n-m)) then True\r\n         else g\' n (m-1)\r\nisPrime 1 = False\r\nisPrime n = isPrime\' n (round (sqrt (fromIntegral n)))\r\nisPrime\' n 1 = True\r\nisPrime\' n m = if mod n m == 0 then False\r\n               else isPrime\' n (m-1)','<br/>Тесты успешно пройдены!'),(5203,22,'517309','2013-09-19 18:41:46',2,'﻿{--\r\n\r\nпредыдущие решения почему-то странно отображаются, попытка 3\r\n\r\nкомпилятор пишет о невозможности создать \r\n\r\nбесконечную последовательность в выражении \r\n\r\ni < x\r\n\r\nпробовал варьировать запись, результата не дало, в чем дело?\r\n\r\n--}\r\n\r\nisPrime x i = if ((x mod i) == 0) \r\n\r\n				then False\r\n\r\n				else if i<x\r\n\r\n						then isPrime x (i+1)\r\n\r\n						else True\r\n\r\n\r\n\r\ng n = g\' n 2\r\n\r\ng\' n i = if (isPrime i 2) && (isPrime (n-i) 2)\r\n\r\n		 	then True\r\n\r\n			else if (i < n) then g\' n (i+1)\r\n\r\n						 	else False\r\n','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5202,22,'517309','2013-09-19 18:41:24',0,'{--\r\nпредыдущие решения почему-то странно отображаются, попытка 3\r\nкомпилятор пишет о невозможности создать \r\nбесконечную последовательность в выражении \r\ni < x\r\nпробовал варьировать запись, результата не дало, в чем дело?\r\n--}\r\nisPrime x i = if ((x `mod` i) == 0) \r\n				then False\r\n				else if i<x\r\n						then isPrime x (i+1)\r\n						else True\r\n\r\ng n = g\' n 2\r\ng\' n i = if (isPrime i 2) && (isPrime (n-i) 2)\r\n		 	then True\r\n			else if (i < n) then g\' n (i+1)\r\n						 	else False','Выражение имеет неправильное значение: g 7'),(5200,22,'517309','2013-09-19 18:37:29',0,'isPrime x i = if ((x mod i) == 0) \r\n				then False\r\n				else if i<x\r\n						then isPrime x (i+1)\r\n						else True\r\n\r\ng n = g\' n 2\r\ng\' n i = if (isPrime i 2) && (isPrime (n-i) 2)\r\n		 	then True\r\n			else if (i < n) then g\' n (i+1)\r\n						 	else False','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5201,22,'517309','2013-09-19 18:38:57',0,'isPrime x i = if ((x `mod` i) == 0) \r\n				then False\r\n				else if i<x\r\n						then isPrime x (i+1)\r\n						else True\r\n\r\ng n = g\' n 2\r\ng\' n i = if (isPrime i 2) && (isPrime (n-i) 2)\r\n		 	then True\r\n			else if (i < n) then g\' n (i+1)\r\n						 	else False','Выражение имеет неправильное значение: g 7'),(5199,23,'15309342','2013-09-19 16:33:37',1,'genCheckList max mult min = [x | x <- [1..max], gcd x mult == 1, x > min]\r\n\r\n\r\n\r\n{-\r\n\r\n - Идем от 1 до n и на каждом шаге добавляем в разложение следующее число, которое взаимно простое с произведением всех предыдущих членов разложения\r\n\r\n -\r\n\r\n - n — расклаываемое число\r\n\r\n - sumLeft — остаток, раскладываемый на данном шаге\r\n\r\n - list — текущий вариант разложения\r\n\r\n - mult — произведение всех чисел в списке list\r\n\r\n - checkList — набор вариантов для последующих проб — взаимно простых с mult чисел, генерируется функцией genCheckList\r\n\r\n -}\r\n\r\ndecomposeRec n 0 list mult checkList = [list]\r\n\r\ndecomposeRec n sumLeft list mult [] | n == 0 = [list]\r\n\r\n                                    | otherwise = [[]]\r\n\r\ndecomposeRec n sumLeft list mult (h:checkList) | h > sumLeft = [[]]\r\n\r\n                                               | otherwise = decomposeRec n (sumLeft - h) (h:list) (mult * h) (genCheckList n (mult * h) h) ++ decomposeRec n sumLeft list mult checkList\r\n\r\n\r\n\r\n-- алгоритм генерирует набор пустых списков для неудавшихся вариантов разложения, убираем их из результата и считаем размер списка (т.е. число удавшихся разложений)\r\n\r\nc n = length (filter (/= []) (decomposeRec n n [] 1 [1..n]))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5198,43,'deripaska','2013-09-19 15:54:09',1,'{--\r\n\r\n	task 07-01\r\n\r\n*Доп задача*\r\n\r\nУ функции два параметра - целые числа a и b. Точно известно, что они взаимно простые. Функция должна вернуть такую пару целых чисел x и y, что a*x + b*y == 1. (Таких пар, конечно, бесконечно много, можно вернуть любую).\r\n\r\n\r\n\r\nПример вызова:\r\n\r\neuclid 3 5\r\n\r\nДолжно получиться (2, -1), потому что 3*2+5*(-1) == 1\r\n\r\n--}\r\n\r\n\r\n\r\neuclid 0 b = (0, div 1 b)\r\n\r\neuclid a b \r\n\r\n	| gcd a b /= 1 = error(\"numbers should be coprime\")\r\n\r\n	| otherwise = (y - (div b a) * x, x)\r\n\r\n		where (x, y) = euclid (mod b a) a\r\n','<br/>Тесты успешно пройдены!'),(5196,43,'115753099','2013-09-19 14:51:21',0,'euclid_ex r x y a b x2 x1 y2 y1\r\n	| b > 0 =\r\n		euclid_ex (a-q*b) (x2-q*x1) (y2-q*y1) b (a-q*b) x1 (x2-q*x1) y1 (y2-q*y1)\r\n	| otherwise = (a, x2, y2)\r\n	where q = a `div` b\r\n\r\neuclid a b\r\n	| b == 0 = (-1, 1, 0)\r\n	| otherwise = euclid_ex  0 0 0 a b 1 0 0 1','Не удалось вычислить выражение \"let (x,y) = euclid 3 5 in 3*x+5*y\", проверьте правильность синтаксиса'),(5197,43,'115753099','2013-09-19 14:54:16',1,'euclid_ex r x y a b x2 x1 y2 y1\r\n	| b > 0 =\r\n		euclid_ex (a-q*b) (x2-q*x1) (y2-q*y1) b (a-q*b) x1 (x2-q*x1) y1 (y2-q*y1)\r\n	| otherwise = (x2, y2)\r\n	where q = a `div` b\r\n\r\neuclid a b\r\n	| b == 0 = (1, 0)\r\n	| otherwise = euclid_ex  0 0 0 a b 1 0 0 1','<br/>Тесты успешно пройдены!'),(5194,23,'54411321','2013-09-19 12:30:59',1,'coprime x l = not (any (i -> 1 /= gcd x i) l)\r\n\r\n\r\n\r\ndo_c x l = let\r\n\r\n            y = if l == [] then x + 1 else head l\r\n\r\n            s = map (i -> if coprime i l\r\n\r\n                           then if x == i then 1 else do_c (x - i) (i:l)\r\n\r\n                           else 0) [1..(min x (y - 1))]\r\n\r\n        in sum s\r\n\r\n\r\n\r\nc x = do_c x []\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5195,22,'284427','2013-09-19 14:33:44',1,'testPrime 1 = False\r\n\r\ntestPrime 2 = True\r\n\r\ntestPrime n = testPrime1 n 2\r\n\r\n\r\n\r\ntestPrime1 n k = \r\n\r\n	if (n == k) then True\r\n\r\n	else if ( mod n k == 0)\r\n\r\n	then False\r\n\r\n	else testPrime1 n (k+1)\r\n\r\n	\r\n\r\ng n = g1 n 1\r\n\r\ng1 n k = let k1 = n - k in\r\n\r\n	if (k1 /= k) && testPrime k && testPrime(k1)\r\n\r\n	then True\r\n\r\n	else if (k1 < k)\r\n\r\n	then False\r\n\r\n	else g1 n (k+1)\r\n\r\n	\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5193,38,'517309','2013-09-19 08:09:45',2,'data Tree = Empty | \r\n	Node Integer Tree Tree\r\nheight Empty = 0\r\nheight (Node v Empty Empty) = 0\r\nheight (Node v l r) = 1 + height l + height r','<br/>Тесты успешно пройдены!'),(5191,35,'SNNatalieS','2013-09-19 01:46:03',1,'dist (s1, s2) (v1, v2) = let\r\n			 d1 = s1 - v1\r\n		         d2 = s2 - v2\r\n			in sqrt(d1^2 + d2^2)\r\ng [] = False\r\ng (x:xs) = any(	 -> t == x) xs || g xs\r\n\r\nisosc (q1, q2) (s1, s2) (d1, d2) = let l = [dist (q1, q2) (s1, s2), dist (s1, s2) (d1, d2), dist (q1, q2) (d1, d2)]	\r\n								in g l','<br/>Тесты успешно пройдены!'),(5192,35,'517309','2013-09-19 08:08:45',2,'data Tree = Empty | \r\n	Node Integer Tree Tree\r\nheight Empty = 0\r\nheight (Node v Empty Empty) = 0\r\nheight (Node v l r) = 1 + height l + height r','Не удалось вычислить выражение \"isosc (0, 2) (2, 0) (2,2)\", проверьте правильность синтаксиса'),(5190,22,'1170660','2013-09-19 00:04:43',1,'g n = g\' 1 (n-1)\r\n\r\n\r\n\r\ng\' i j = let p1 =isprime i 2 1 && isprime j 2 1 &&i/=j in if i>=j ||p1 then primeRes p1 else g\'(i+1)(j-1) \r\n\r\n\r\n\r\nisprime a k r = if(a==k||a<k)then f (r/=0&&a/=1) else isprime a (k+1)(r * mod a k)\r\n\r\n\r\n\r\nf p = if p then True else False\r\n\r\nprimeRes param = if param then True else False\r\n','<br/>Тесты успешно пройдены!'),(5189,22,'1170660','2013-09-19 00:01:38',0,'g n = g\' 2 (n-2)\r\n\n\r\n\ng\' i j = let p1 =isprime i 2 1 && isprime j 2 1 &&i/=j in if i>j ||p1 then primeRes p1 else g\'(i+1)(j-1) \r\n\n\r\n\nisprime a k r = if(a==k||a<k)then f (r/=0&&a/=1) else isprime a (k+1)(r * mod a k)\r\n\n\r\n\nf p = if p then True else False\r\n\nprimeRes param = if param then True else False\n','Выражение имеет неправильное значение: g 2'),(5188,38,'SNNatalieS','2013-09-19 00:01:02',2,'data Tree = Empty | \r\n	Node Integer Tree Tree\r\nheight Empty = 0\r\nheight (Node v Empty Empty) = 0\r\nheight (Node v l r) = 1 + height l + height r\r\n  --- На самом деле вот это правило у вас совсем неправильное :(\r\n  --- Просто у меня тестов было мало, как выяснилось (\r\n  --- Например, такой тест дает неправильное значение:\r\n  ---    height(Node 1  (Node 2   (Node 4  Empty Empty) Empty) (Node 3  Empty  (Node 5  Empty Empty)))\r\n  --- Попробуйте, пожалуйста, исправить (а я сейчас добавлю такой тест) \r\n','<br/>Тесты успешно пройдены!'),(5187,22,'1170660','2013-09-18 23:58:12',0,'g n = g\' 2 (n-2)\r\n\n\r\n\ng\' i j = let p1 =isprime i 2 1 && isprime j 2 1 &&i/=j in if i>j ||p1 then primeRes p1 else g\'(i+1)(j-1) \r\n\n\r\n\nisprime a k r = if(a==k||a<k)then f r else isprime a (k+1)(r * mod a k)\r\n\n\r\n\nf r = if r/=0 then True else False\r\n\nprimeRes param = if param then True else False\n','Хитрый тест номер 4 не пройден :(<br/>Подсказка: 1 - это не простое число'),(5185,36,'SNNatalieS','2013-09-18 23:02:27',1,'cubeTable n = map (i -> (i, i^3)) [1 .. n]','<br/>Тесты успешно пройдены!'),(5186,37,'SNNatalieS','2013-09-18 23:52:41',1,'minsum [] = 0\r\nminsum [a] = a\r\nminsum (x:xs) = let \r\n		t = zip (x:xs) xs\r\n		s = map ((c, v) -> c + v) t\r\n		in minimum s','<br/>Тесты успешно пройдены!'),(5184,31,'nomeansno','2013-09-18 22:55:57',2,'--- Вот, вроде бы, контрпример:\r\n--- parts2 [{--a--} 1,2,3, {--b--}1,10,11,12, {--a--}10,11,20,25,26, {--b--}20,21,22,23,24,25, {--a--}31,32,33, {--b--}31]\r\n--- (подпоследовательности помечены a и b)\r\n\r\ncount\' _ [] = 0\r\n\r\ncount\' x (y:ys) = if y == x then 1 + count\' x ys\r\n\r\nelse count\' x ys\r\n\r\n\r\n\r\ncount\'\' _ [] = 0\r\n\r\ncount\'\' x (y:ys) = if y > x then 1 + count\'\' x ys\r\n\r\nelse count\'\' x ys\r\n\r\n\r\n\r\naddlist s = addlist\' s []\r\n\r\naddlist\' [] s = s\r\n\r\naddlist\' (x:xs) s = addlist\' xs (s ++ [(l,r)])\r\n\r\n 	where l = count\' x xs; r = count\'\' x xs\r\n\r\n\r\n\r\n\r\n\r\ncheckcounts [] = True\r\n\r\ncheckcounts (x:xs) = if count x xs > 1 then False\r\n\r\nelse checkcounts xs\r\n\r\ncount _ [] = 0\r\n\r\ncount x (y:ys) = if x== y then 1 + count x ys\r\n\r\nelse count x ys \r\n\r\n\r\n\r\nmakelists (x:xs) = makelists\' xs [(x,1)] [] 2\r\n\r\nmakelists\' [] s1 s2 _ = (reverse s1, reverse s2)\r\n\r\nmakelists\' (x:xs) (y:ys) s index = if x > fst y then makelists\' xs ((x,index):y:ys) s (index+1)\r\n\r\nelse makelists\' xs (y:ys) ((x,index):s) (index+1)\r\n\r\n\r\n\r\ncheckorder s = checkforall (x y->x<y) s\r\n\r\ncheckforall cond [_] = True\r\n\r\ncheckforall cond (x:y:xs) = if not (cond (fst x) (fst y)) then False\r\n\r\nelse checkforall cond (y:xs)\r\n\r\n\r\n\r\nbigger x y = fst x > fst y && snd x > snd y\r\n\r\nsmaller x y = fst x < fst y && snd x < snd y\r\n\r\nbetween x y = x `bigger` fst y && x `smaller` snd y\r\n\r\n\r\n\r\nf x [] = 0\r\n\r\nf x (y:ys) = if y `between` x then 1 + f x ys\r\n\r\nelse f x ys\r\n\r\n\r\n\r\nh x [] = 0\r\n\r\nh x (y:ys) = if y `bigger` x then 1 + h x ys\r\n\r\nelse h x ys\r\n\r\n\r\n\r\nj x [] = 0\r\n\r\nj x (y:ys) = if fst y /= fst x && y `smaller` x then 1 + j x ys\r\n\r\nelse j x ys\r\n\r\n\r\n\r\ng (x:xs) s = j x s + g\' (x:xs) s\r\n\r\ng\' [x] s = h x s\r\n\r\ng\' (x:y:xys) s = f (x,y) s + g\' (y:xys) s \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nparts2 s = if l `mod` 2 /= 0 then False \r\n\r\nelse if l == l1 then True\r\n\r\nelse if checkcounts s && checkorder s2 && g s2 s1 + l2 >= l `div` 2 then True\r\n\r\nelse False \r\n\r\n	where s1 = fst (makelists s); s2 = snd (makelists s); l = length s; l1 = length s1; l2 = length s2;\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5183,31,'nomeansno','2013-09-18 22:55:30',0,'','Не удалось вычислить выражение \"parts2 [1, 3, 1, 8, 4, 9]\", проверьте правильность синтаксиса'),(5182,31,'nomeansno','2013-09-18 22:55:07',0,'','Не удалось вычислить выражение \"parts2 [1, 3, 1, 8, 4, 9]\", проверьте правильность синтаксиса'),(5181,31,'nomeansno','2013-09-18 22:27:18',0,'count\' _ [] = 0\r\n\ncount\' x (y:ys) = if y == x then 1 + count\' x ys\r\n\nelse count\' x ys\r\n\n\r\n\ncount\'\' _ [] = 0\r\n\ncount\'\' x (y:ys) = if y > x then 1 + count\'\' x ys\r\n\nelse count\'\' x ys\r\n\n\r\n\naddlist s = addlist\' s []\r\n\naddlist\' [] s = s\r\n\naddlist\' (x:xs) s = addlist\' xs (s ++ [(l,r)])\r\n\n 	where l = count\' x xs; r = count\'\' x xs\r\n\n\r\n\n\r\n\ncheckcounts [] = True\r\n\ncheckcounts (x:xs) = if count x xs > 1 then False\r\n\nelse checkcounts xs\r\n\ncount _ [] = 0\r\n\ncount x (y:ys) = if x== y then 1 + count x ys\r\n\nelse count x ys \r\n\n\r\n\nmakelists (x:xs) = makelists\' xs [(x,1)] [] 2\r\n\nmakelists\' [] s1 s2 _ = (reverse s1, reverse s2)\r\n\nmakelists\' (x:xs) (y:ys) s index = if x > fst y then makelists\' xs ((x,index):y:ys) s (index+1)\r\n\nelse makelists\' xs (y:ys) ((x,index):s) (index+1)\r\n\n\r\n\ncheckorder s = checkforall (x y->x<y) s\r\n\ncheckforall cond [_] = True\r\n\ncheckforall cond (x:y:xs) = if not (cond (fst x) (fst y)) then False\r\n\nelse checkforall cond (y:xs)\r\n\n\r\n\nbigger x y = fst x > fst y && snd x > snd y\r\n\nsmaller x y = fst x < fst y && snd x < snd y\r\n\nbetween x y = x `bigger` fst y && x `smaller` snd y\r\n\n\r\n\nf x [] = 0\r\n\nf x (y:ys) = if y `between` x then 1 + f x ys\r\n\nelse f x ys\r\n\n\r\n\nh x [] = 0\r\n\nh x (y:ys) = if y `bigger` x then 1 + h x ys\r\n\nelse h x ys\r\n\n\r\n\ng [x] s = h x s\r\n\ng (x:y:xys) s =  f (x,y) s + g (y:xys) s \r\n\n\r\n\nparts2 s = if l `mod` 2 /= 0 then False \r\n\nelse if l == l1 then True\r\n\nelse if checkcounts s && checkorder s2 && g s2 s1 + l2 >= l `div` 2 then True\r\n\nelse False \r\n\n	where s1 = fst (makelists s); s2 = snd (makelists s); l = length s; l1 = length s1; l2 = length s2;\r\n\n\r\n\n\n','Выражение имеет неправильное значение: parts2 [1,6,9,7]'),(5179,39,'115753099','2013-09-18 12:52:37',1,'import Data.List\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nmHeight [] futureStack curHeight =\r\n	mHeight futureStack [] (curHeight + 1)\r\nmHeight ((Node _ Empty Empty):curStack) futureStack curHeight\r\n	= curHeight\r\nmHeight ((Node _ Empty r):curStack) futureStack curHeight	\r\n	= mHeight curStack (r:futureStack) curHeight\r\nmHeight ((Node _ l Empty):curStack) futureStack curHeight	\r\n	= mHeight curStack (l:futureStack) curHeight\r\nmHeight ((Node _ l r):curStack) futureStack curHeight	\r\n	= mHeight curStack (l:r:futureStack) curHeight\r\n\r\nminHeight Empty = -1\r\nminHeight (Node _ Empty Empty) = 0\r\nminHeight (Node _ Empty r) = mHeight [] [r] 0\r\nminHeight (Node _ l Empty) = mHeight [] [l] 0\r\nminHeight (Node _ l r) = mHeight [] [l,r] 0\r\n','<br/>Тесты успешно пройдены!'),(5180,39,'anlun','2013-09-18 17:49:14',1,'import Data.Sequence\r\n\r\ndata Tree = Empty | Node Integer Tree Tree\r\n\r\nminHeight :: Tree -> Integer\r\nminHeight tree = minHeightDFS $ singleton (tree, 0)\r\n	where\r\n		minHeightDFS seq =\r\n			case viewl seq of\r\n				EmptyL    -> 0\r\n				a :< tail ->\r\n					case a of\r\n						(Empty             , newV) -> minHeightDFS tail\r\n						(Node _ Empty Empty, newV) -> newV\r\n						(Node _ l     r    , newV) -> minHeightDFS (tail |> (l, newV + 1) |> (r, newV + 1))','<br/>Тесты успешно пройдены!'),(5177,33,'3320654','2013-09-18 00:11:30',1,'using System;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double result = 0.0;\r\n            int dimension = 10000;\r\n            double d = (b - a) / dimension;\r\n            for (int i = 0; i <= dimension; i++)\r\n            {\r\n                result += f(a + i * d) * d;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        static double Cube(double x)\r\n        {\r\n            return x * x * x;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(Integral(Cube, 1, 2));        \r\n            Console.WriteLine(Integral(x => x * x, 1, 2));            \r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5178,23,'Valentina Guleva','2013-09-18 09:04:09',2,'areCoprime [x, y] = if sum[ t | t <- [2..(min x y)], mod x t == 0, mod y t == 0 ] == 0\r\n\r\n				    then True\r\n\r\n				    else False\r\n\r\nareCoprime xs = if sum[ t | t <- [2..(head xs)], i <- [0..(length (tail xs) - 1)], mod (head xs) t == 0, mod (tail xs !! i) t == 0] == 0 \r\n\r\n					&& areCoprime (tail xs)\r\n\r\n				then True\r\n\r\n				else False\r\n\r\nc n = sum[ xs | xs <- [replicate 1 1 .. replicate n n] {--?how to say array that it\'s ANY array?--}, \r\n  --- Тут вы хотите сгенерировать все наборы чисел длиной n от 1 до n, я правильно понял?\r\n  --- Стандартной фунцкии такой нет.. Это можно написать, можете попробовать (с помощью рекурсии)\r\n  --- Но вообще я бы советовал делать иначе - взять решение задачи 1-5 из слайдоа и попробовать его как-то дописать\r\n  --- Могу подсказать, там надо добавить еще параметр, где во время рекурсии хранить уже выбранные числа.\r\n \r\n				length xs < n, i <- [0.. (n - 1)], (xs !! i) < n, sum xs == n, areCoprime xs ]\r\n\r\n				\r\n','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(5176,39,'3320654','2013-09-17 23:42:54',1,'--и правда curMin нигде не изменилось\r\n--теперь некоторые из \"правых\" вершин не будут просматриваться\r\ndata Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nminHeight Empty 		= -1\r\nminHeight (Node n l r) 	= minHeight\' (Node n l r) (1/0) 0\r\n\r\nminHeight\' Empty curMin curH			= curMin\r\n\r\nminHeight\' (Node n Empty Empty) curMin curH	= curH\r\n\r\nminHeight\' (Node n l r) curMin curH		= if curMin <= curH\r\n					   then curMin\r\n					   else (minHeight\' r (minHeight\' l curMin (curH + 1)) (curH + 1))\r\n','<br/>Тесты успешно пройдены!'),(5175,38,'517309','2013-09-17 22:52:41',2,'data Tree = Empty |\r\n	Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ left right) = 1 + (max (height left) (height right))','<br/>Тесты успешно пройдены!'),(5174,39,'115753099','2013-09-17 22:22:06',2,'{--\r\nНет, это не совсем то.. Так у вас на самом деле обойдуться все листья.\r\nСмотрите, вот я вставал в вашу программу trace/\r\nПри вызове я вижу, что программа печатает leaf два раза. А надо как-то написать,\r\nчтобы до второго листа она не доходила.\r\n--------------------------\r\nimport Debug.Trace\r\n\r\ndata Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nmaxInt = 1000\r\n\r\nmHeight Empty currMin currHeight = maxInt\r\nmHeight (Node _ Empty Empty) _ _ = trace \"leaf\" 0\r\nmHeight (Node _ l r) currMin currHeight =\r\n	if currMin > currHeight then\r\n		min (mHeight l currMin (currHeight + 1)) (mHeight r currMin (currHeight + 1)) + 1\r\n	else maxInt\r\n\r\nminHeight node = mHeight node maxInt 0\r\n\r\ntest = minHeight (Node 1 (Node 2 Empty Empty) (Node 3 (Node 4  Empty Empty)  Empty))  \r\n----------------------------\r\n--}\r\ndata Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nmaxInt = 1000\r\n\r\nmHeight Empty currMin currHeight = maxInt\r\nmHeight (Node _ Empty Empty) _ _ = 0\r\nmHeight (Node _ l r) currMin currHeight =\r\n	if currMin > currHeight then\r\n		min (mHeight l currMin (currHeight + 1)) (mHeight r currMin (currHeight + 1)) + 1\r\n	else maxInt\r\n\r\nminHeight node = mHeight node maxInt 0','<br/>Тесты успешно пройдены!'),(5173,39,'115753099','2013-09-17 22:09:26',0,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nminHeight Empty = 0\r\nminHeight (Node var Empty Empty) = 0\r\nminHeight (Node var Empty r) = 1\r\nminHeight (Node var l Empty) = 1\r\nminHeight (Node var l r) =\r\n	min (minHeight l) (minHeight r) + 1','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)'),(5172,39,'115753099','2013-09-17 22:08:48',0,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nminHeight Empty = 0\r\nminHeight (Node var Empty r) = 1\r\nminHeight (Node var l Empty) = 1\r\nminHeight (Node var l r) =\r\n	min (minHeight l) (minHeight r) + 1','Выражение имеет неправильное значение: minHeight (Node 1 Empty Empty)'),(5171,38,'115753099','2013-09-17 22:05:35',1,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node var l r) =\r\n	max (height l) (height r) + 1','<br/>Тесты успешно пройдены!'),(5170,38,'115753099','2013-09-17 22:04:06',0,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node var l r) =\r\n	min (minHeight l) (minHeight r) + 1','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5168,37,'115753099','2013-09-17 21:56:35',1,'import Data.List\r\nminsum (x:y:xs) = s where ((s,_),_) = mapAccumL ( (acc, x) y -> ((min acc (x+y), y),y)) ((y+x),x) (y:xs)','<br/>Тесты успешно пройдены!'),(5169,39,'115753099','2013-09-17 22:03:28',0,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight (Node var l r) =\r\n	min (minHeight l) (minHeight r) + 1','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5160,38,'4604056','2013-09-17 21:16:28',1,'data Tree = Empty |\r\n	Node Integer Tree Tree\r\n\r\nheight Empty = -1\r\nheight (Node _ left right) = 1 + (max (height left) (height right))','Выражение имеет неправильное значение: height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)'),(5161,36,'anlun','2013-09-17 21:16:28',1,'cubeTable n = map (x -> (x, x ^ 3)) [1..n]','<br/>Тесты успешно пройдены!'),(5162,37,'anlun','2013-09-17 21:19:55',0,'minsum (x1:x2:xs) = snd $ foldl ((x, ms) v -> (v, ms `min` (x + v))) (x2, x1 + x2) xs','Не удалось вычислить выражение \"minsum [1,8,3,2,7] \", проверьте правильность синтаксиса'),(5163,37,'anlun','2013-09-17 21:20:34',1,'minsum (x1:x2:xs) = snd $ foldl ((x, ms) v -> (v, ms `min` (x + v))) (x2, x1 + x2) xs','<br/>Тесты успешно пройдены!'),(5164,36,'115753099','2013-09-17 21:20:56',1,'cubeTable n =\r\n	map (x -> (x,x*x*x)) [1..n]','<br/>Тесты успешно пройдены!'),(5165,38,'anlun','2013-09-17 21:25:00',1,'data Tree = Empty | Node Integer Tree Tree\r\n\r\nheight :: Tree -> Integer\r\nheight Empty = 0\r\nheight (Node _ Empty Empty) = 0\r\nheight (Node _ l r) = (1 +) $ (height l) `max` (height r)\r\n','<br/>Тесты успешно пройдены!'),(5166,37,'115753099','2013-09-17 21:54:46',0,'import Data.List\r\nminsum (x:y:xs) = s where ((s,_),_) = mapAccumL ( (acc, x) y -> ((min acc (x+y), y),y)) ((y+x),x) (y:xs)','Не удалось вычислить выражение \"minsum [1,8,3,2,7] \", проверьте правильность синтаксиса'),(5167,39,'4604056','2013-09-17 21:55:59',1,'   --- Интересно, почему система сообщила об ошибке.. Я думаю, это что-то связанное с форматом файлов.\r\n   --- Вы наверное загружали файл? Если у вас еще будет такая проблема, вы пришлите мне такой файл оо почте,\r\n   --- пожалуйста, а сами можете попробовать сделать вместо хагрузки файла, paste в окно ввода программы.\r\ndata Tree = Empty |\r\n	Node Integer Tree Tree\r\n\r\nminHeight Empty = -1\r\nminHeight x = minHeight\' x (-1) (1000)\r\n\r\n{-minHeight\' Empty curHeight curMin = min curMin curHeight\r\nminHeight\' (Node _ left right) curHeight curMin = if (curMin > curHeight)\r\n	then min (minHeight\' left (curHeight + 1) curMin) (minHeight\' right (curHeight + 1) curMin)\r\n	else curMin\r\n	-}\r\nminHeight\' Empty curHeight curMin = min curMin curHeight\r\nminHeight\' (Node _ left right) curHeight curMin = if (curMin < curHeight)\r\n	then curMin\r\n	else min \r\n		minleft\r\n		(minHeight\' right (curHeight + 1) newMin)\r\n			where {minleft = (minHeight\' left (curHeight + 1) curMin);\r\n				newMin = min minleft curMin}\r\n    --- На самом деле ваша программа так устроена, что каздый новый min менбше следкющего, и curMin всега\r\n    --- меньше curHeight. А значит, все три раза, когда вы пишете min, его сожно и не писать..','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5159,36,'anlun','2013-09-17 21:16:06',0,'cubeTable n = map (x -> (x, x ^ 2)) [1..n]','Выражение имеет неправильное значение: cubeTable 4'),(5158,35,'anlun','2013-09-17 21:12:44',1,'isosc :: (Integer, Integer) -> (Integer, Integer) -> (Integer, Integer) -> Bool\r\nisosc a b c = l1 == l2 || l1 == l3 || l2 == l3\r\n	where\r\n		sqr x = x * x\r\n		len (x1, y1) (x2, y2) = sqrt $ fromIntegral $ sqr (x1 - x2) + sqr (y1 - y2)\r\n		l1 = len a b\r\n		l2 = len c b\r\n		l3 = len a c','<br/>Тесты успешно пройдены!'),(5156,37,'4604056','2013-09-17 21:09:24',1,'minsum (x:xs) = minimum (map ((x,y) -> x + y) (zip (x:xs) xs))\r\n','<br/>Тесты успешно пройдены!'),(5157,35,'115753099','2013-09-17 21:10:29',1,'sqr a = a * a\r\n\r\nisosc (x1, y1) (x2, y2) (x3, y3)\r\n	| a == b || b == c || a == c = True\r\n	| otherwise = False\r\n	where\r\n		a = sqrt (sqr(x1-x2) + sqr(y1-y2))\r\n		b = sqrt (sqr(x2-x3) + sqr(y2-y3))\r\n		c = sqrt (sqr(x1-x3) + sqr(y1-y3))','<br/>Тесты успешно пройдены!'),(5155,39,'3320654','2013-09-17 20:53:28',2,'--- Нет, это не совсем то.. Так у вас получится что все равно будет обходиться все вершины\r\n--- (вы можете это проверить, если добавите trace). Потому что у вас нигде нет проверки типа\r\n--- \"Если я уже зашел далеко то дальше ходить не буду\"\r\n\r\ndata Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nminHeight Empty 		= -1\r\nminHeight (Node n l r) 	= minHeight\' (Node n l r) (1/0) 0\r\n   --- Поставьте вот тут  minHeight (Node n l r) = trace \"leaf\" (minHeight\' (Node n l r) (1/0) 0)\r\n   --- и вы увидите, то leaf будет напечатан столько раз, сколько у вас листьев, они все будут пройдены\r\n\r\nminHeight\' Empty curMin curH			= curMin\r\n\r\nminHeight\' (Node n Empty Empty) curMin curH	= curH\r\n\r\nminHeight\' (Node n l r) curMin curH		= if curMin <= curH\r\n					   then curMin\r\n					   else min (minHeight\' l curMin (curH + 1)) 							                  (minHeight\' r curMin (curH + 1))','<br/>Тесты успешно пройдены!'),(5153,36,'4604056','2013-09-17 20:49:39',0,'cubeTable n = map (x -> (x^3, x^3)) [1..n]','Выражение имеет неправильное значение: cubeTable 4'),(5154,36,'4604056','2013-09-17 20:50:37',1,'cubeTable n = map (x -> (x, x^3)) [1..n]','<br/>Тесты успешно пройдены!'),(5152,35,'4604056','2013-09-17 20:47:09',1,'sqLen (x,y) (x\',y\') = ((x - x\')^2) + ((y - y\')^2)\r\n\r\nisosc a b c = (sqLen a b == sqLen b c) || \r\n	(sqLen a b == sqLen a c) || (sqLen b c == sqLen a c)','<br/>Тесты успешно пройдены!'),(5151,39,'3320654','2013-09-17 20:29:29',0,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nminHeight Empty		= -1\r\nminHeight (Node n l r) 	= 	if help l\r\n				then 0\r\n				else	if help r\r\n					then 0\r\n					else 1 + min (minHeight l) (minHeight r)\r\n\r\nhelp Empty 	= True\r\nhelp (Node n l r)	= False','Выражение имеет неправильное значение: minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))'),(5149,37,'3320654','2013-09-17 20:12:42',1,'minsum (x:xs) = minimum (map ((x, y) -> x+y) (zip (x:xs) xs))','<br/>Тесты успешно пройдены!'),(5150,38,'3320654','2013-09-17 20:19:33',1,'data Tree = Empty | \r\n            Node Integer Tree Tree\r\n\r\nheight Empty 	= -1\r\nheight (Node n l r) 	= 1 + max (height l) (height r)','<br/>Тесты успешно пройдены!'),(5147,35,'3320654','2013-09-17 20:06:12',1,'isosc (a, b) (c, d) (e, f) = 	let {	x = sqrt ((a - c)^2 + (b - d)^2);\r\n				y = sqrt ((a - e)^2 + (b - f)^2);\r\n			     	z = sqrt ((e - c)^2 + (f - d)^2); }\r\n			in 	if x == y || x == z || y == z\r\n				then True\r\n				else False','<br/>Тесты успешно пройдены!'),(5148,36,'3320654','2013-09-17 20:08:00',1,'cubeTable n = zip [1..n] (map (^3) [1..n])','<br/>Тесты успешно пройдены!'),(5146,39,'deripaska','2013-09-17 19:13:46',1,'{--\r\n\r\n	task 06-05\r\n\r\n* Описать функцию minHeight, хоторая для данного дерева возвращает минимум расстояния от корня до какого-нибудь листа. \r\n\r\nЗамечание: В этой задаче _обязательно_ должна быть реализована какая-то из оптимизаций, о которой мы говорили на занятии. (Ну, или что-то аналогичное)\r\n\r\nНапоминание: Лист - это вершина, у которой и левое и правое поддеревья пустые.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nminHeight(Node 1 Empty Empty)\r\n\r\nОтвет должен быть 0\r\n\r\nminHeight (Node 1 (Node 2 (Node 3 Empty Empty)Empty)(Node 4 Empty Empty))\r\n\r\nОтвет должен быть 1 (расстояние от корня до вершины 4)\r\n\r\n--}\r\n\r\n\r\n\r\n-- так будет получше?\r\n\r\n-- import Debug.Trace\r\n\r\ndata Tree = Empty \r\n\r\n			| Node Integer Tree Tree\r\n\r\nminHeight tree = recMinHeight tree (1/0) 0\r\n\r\n\r\n\r\nrecMinHeight Empty curMinHeight _ = curMinHeight\r\n\r\nrecMinHeight (Node x Empty Empty) _ nodeLevel = {-- trace (show x) --} nodeLevel\r\n\r\n\r\n\r\nrecMinHeight (Node _ left right) curMinHeight nodeLevel\r\n\r\n	| curMinHeight <= nodeLevel = curMinHeight\r\n\r\n	| otherwise = min curMinHeight (recMinHeight left newMinFromRight nextLevel)\r\n\r\n	where \r\n\r\n		nextLevel = nodeLevel + 1\r\n\r\n		newMinFromRight = min curMinHeight (recMinHeight right curMinHeight nextLevel)\r\n\r\n\r\n\r\n\r\n\r\n  \r\n','<br/>Тесты успешно пройдены!'),(5145,37,'deripaska','2013-09-17 18:50:51',1,'{--\r\n\r\n	task 06-03\r\n\r\nОпределить функцию minsum, такую же, как в задаче 3.2. Т.е. функция должна искать минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но не очень нужно), определать свои не рекурсивные функции.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\nminsum [1,8,3,2,7] \r\n\r\nОтвет должен быть равен 5 (3+2).\r\n\r\n--}\r\n\r\n\r\n\r\n{-- first\r\n\r\nminsum xs = minimum (build xs [])\r\n\r\nbuild [_] res = res\r\n\r\nbuild (x:y:xs) res = build (y:xs) ((x + y):res)\r\n\r\n--}\r\n\r\n\r\n\r\n{-- second\r\n\r\nminsum xs = minimum (build sumFun xs [])\r\n\r\n	where sumFun = xs [x, y] -> (x + y):xs\r\n\r\nbuild _ [_] res = res\r\n\r\nbuild f (x:y:xs) res = build f (y:xs) (f res [x, y])\r\n\r\n--}\r\n\r\n\r\n\r\n-- third\r\n\r\nminsum (x:xs) = minimum (map ((x, y) -> (x + y)) (zip (x:xs) xs))\r\n','<br/>Тесты успешно пройдены!'),(5144,23,'6053606','2013-09-17 18:15:22',1,'parts n = concat $ filter (not . null) $ map (go []) [1..n] where\r\n  go acc i\r\n    | sum acc + i == n = [(i:acc)]\r\n    | sum acc + i < n  =\r\n      concatMap (go (i:acc)) [i + 1..n]\r\n    | otherwise = []\r\n\r\nisCoprime xs = and [gcd n m == 1 | n <- xs, m <- xs, m < n]\r\n\r\nc n = sum [if isCoprime xs then 1 else 0 | xs <- parts n]\r\n --- или c n = sum [1 | xs <- parts n, isCoprime xs]','<br/>Тесты успешно пройдены!'),(5143,39,'deripaska','2013-09-17 17:33:15',2,'{-- --- Идея хорошая, но все немного сложнее. У вас на самом деле будет обходится все дерево.. Вы же низде\r\nне проверяете, что вы защли глубже текущего минимума и дальше идти не надо..\r\n\r\nПопробуйте добавить такую проверку, пожалуйста. Чтобы вам было проще, я ниже прилагаю ваш код, в котором я вставил отладочную печать, и вмдно, что обходятся все листья\r\n\r\nimport Debug.Trace  --- Это для печати\r\n\r\n\r\ndata Tree = Empty \r\n\r\n	| Node Integer Tree Tree\r\n\r\nminHeight tree = recMinHeight tree (1/0) 0\r\n\r\n\r\n\r\nrecMinHeight Empty curMinHeight _ = curMinHeight\r\n\r\nrecMinHeight (Node x Empty Empty) _ nodeLevel = trace (show x) nodeLevel --- Так в Хаскеле делается отладочная печать\r\n\r\n\r\n\r\nrecMinHeight (Node _ left right) curMinHeight nodeLevel\r\n\r\n	| curMinHeight <= nodeLevel = curMinHeight\r\n\r\n	| otherwise = min (recMinHeight left curMinHeight nextLevel) (recMinHeight right curMinHeight nextLevel)\r\n\r\n	where nextLevel = nodeLevel + 1\r\n\r\n\r\ntest = minHeight (Node 1 (Node 4 Empty Empty) (Node 2 (Node 3 Empty (Node 5 Empty Empty))Empty) )\r\n   --- Тут будет видно, что узел 5 тоже обходится, хотя он точно глубже 3\r\n\r\n--}\r\n \r\n{--\r\n\r\n	task 06-05\r\n\r\n* Описать функцию minHeight, хоторая для данного дерева возвращает минимум расстояния от корня до какого-нибудь листа. \r\n\r\nЗамечание: В этой задаче _обязательно_ должна быть реализована какая-то из оптимизаций, о которой мы говорили на занятии. (Ну, или что-то аналогичное)\r\n\r\nНапоминание: Лист - это вершина, у которой и левое и правое поддеревья пустые.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nminHeight(Node 1 Empty Empty)\r\n\r\nОтвет должен быть 0\r\n\r\nminHeight (Node 1 (Node 2 (Node 3 Empty Empty)Empty)(Node 4 Empty Empty))\r\n\r\nОтвет должен быть 1 (расстояние от корня до вершины 4)\r\n\r\n--}\r\n\r\ndata Tree = Empty \r\n\r\n			| Node Integer Tree Tree\r\n\r\nminHeight tree = recMinHeight tree (1/0) 0\r\n\r\n\r\n\r\nrecMinHeight Empty curMinHeight _ = curMinHeight\r\n\r\nrecMinHeight (Node _ Empty Empty) _ nodeLevel = nodeLevel\r\n\r\n\r\n\r\nrecMinHeight (Node _ left right) curMinHeight nodeLevel\r\n\r\n	| curMinHeight <= nodeLevel = curMinHeight\r\n\r\n	| otherwise = min (recMinHeight left curMinHeight nextLevel) (recMinHeight right curMinHeight nextLevel)\r\n\r\n	where nextLevel = nodeLevel + 1\r\n\r\n\r\n\r\n\r\n\r\n  \r\n','<br/>Тесты успешно пройдены!'),(5142,38,'deripaska','2013-09-17 17:32:40',1,'{--\r\n\r\n	task 06-04\r\n\r\nОписать функцию height, хоторая ищет высоту данного дерева. \r\n\r\nЗамечание: В задаче вы сначала должны описать data для дерева. И его надо описать точно так же, как на занятии. Извините за ограничение вашей творческой свободы, но это, понятно, ограничение системы тестирования..\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nheight (Node 1 Empty Empty)\r\n\r\nОтвет должен быть 0\r\n\r\nheight (Node 1 (Node 1 Empty Empty) Empty)\r\n\r\nОтвет должен быть 1\r\n\r\n--}\r\n\r\ndata Tree = Empty \r\n\r\n			| Node Integer Tree Tree\r\n\r\n\r\n\r\nheight Empty = -1\r\n\r\nheight (Node _ left right) = max (height left) (height right) + 1\r\n','<br/>Тесты успешно пройдены!'),(5141,36,'deripaska','2013-09-17 17:26:59',1,'{--\r\n\r\n	task 06-02\r\n\r\nОписать функцию cubeTable, которая для данного n возвращает список пар чисел (i, i в кубе) для всех i от 1 до n.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но, видимо, особо не нужно), определять свои не рекурсивные функции.\r\n\r\n\r\n\r\nПример вызова:\r\n\r\ncubeTable 4\r\n\r\nДолжно получиться [(1, 1), (2, 8), (3, 27), (4, 64)]\r\n\r\n--}\r\n\r\n\r\n\r\n{-- first (с рекурсивной функцией, \"в лоб\")\r\n\r\ncubeTable n = cubeTable1 n []\r\n\r\ncubeTable1 0 xs = xs\r\n\r\ncubeTable1 n xs = cubeTable1 (n - 1) ((n, n^3):xs)\r\n\r\n--}\r\n\r\n\r\n\r\n-- second (with Map)\r\n\r\ncubeTable n = map (x -> (x, x^3)) [1..n]\r\n','<br/>Тесты успешно пройдены!'),(5140,35,'deripaska','2013-09-17 17:24:54',1,'{--\r\n\r\n	task 06-01\r\n\r\nОпишите функцию isosc (от слова isosceles - равнобедренный), у которой три параметра - пары целых чисел, и которая возвращает True, если соответствующие точки на плоскости задают равнобедренный треугольник, а иначе False.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nisosc (0, 2) (2, 0) (2,2)\r\n\r\n- результат должен быть равен True\r\n\r\nisosc (-3, 2) (2, 0) (2,2)\r\n\r\n- результат должен быть равен False\r\n\r\n--}\r\n\r\n\r\n\r\nisosc x y z\r\n\r\n	| a == b || a == c || c == b = True\r\n\r\n	| otherwise = False\r\n\r\n	where\r\n\r\n		a = squareSideLength x y\r\n\r\n		b = squareSideLength x z\r\n\r\n		c = squareSideLength z y\r\n\r\n	\r\n\r\nsquareSideLength (x1, y1) (x2, y2) = (x2 - x1)^2 + (y2 - y1)^2\r\n','<br/>Тесты успешно пройдены!'),(5137,35,'517309','2013-09-17 16:52:28',2,'isosc a b c = True','Выражение имеет неправильное значение: isosc (-3, 2) (2, 0) (2,2)'),(5138,36,'517309','2013-09-17 16:56:55',2,'cubeTable n = map (i->(i, i*i*i))[1..n]','<br/>Тесты успешно пройдены!'),(5139,38,'517309','2013-09-17 16:58:01',2,'height xs = 1','Не удалось вычислить выражение \"height (Node 1 Empty Empty)\", проверьте правильность синтаксиса'),(5136,30,'115753099','2013-09-17 12:00:57',1,'import Data.List\r\n\r\n\r\n\r\nnextDerive :: Int -> Int -> Int\r\n\r\nnextDerive n prevDerive\r\n\r\n	| prevDerive >= (n `div` 2) = -1\r\n\r\n	| True = if rem n (prevDerive + 1) == 0 then (prevDerive + 1) else nextDerive n (prevDerive + 1)\r\n\r\nfunc res prevEl x\r\n\r\n	| prevEl < x = res\r\n\r\n	| True = False\r\n\r\n\r\n\r\nisDerivedOnSeq3 [] len = False\r\n\r\nisDerivedOnSeq3 [x] len = False\r\n\r\nisDerivedOnSeq3 (x:xs) len\r\n\r\n	| len < 2 = False\r\n\r\n	| len > length xs = False\r\n\r\n	| otherwise       = s\r\n\r\n		where ((s,_,_,_),_) = \r\n\r\n			mapAccumL ((res, prevEl, len, curLen) x ->\r\n\r\n					if curLen < len\r\n\r\n						then ((func res prevEl x, x, len, (curLen + 1)), x)\r\n\r\n					else ((res, x, len, 1), x)\r\n\r\n			) \r\n\r\n			(True, x, len, 1) xs\r\n\r\n\r\n\r\nisDerivedOnSeq2 [x] prevLen res = True\r\n\r\nisDerivedOnSeq2 xs prevLen res\r\n\r\n	| prevLen == -1 = res\r\n\r\n	| prevLen < length xs =	\r\n\r\n		let res2 = res || isDerivedOnSeq3 xs (nextDerive (length xs) prevLen)\r\n\r\n		in res2 || isDerivedOnSeq2 xs (nextDerive (length xs) prevLen) res2\r\n\r\n	| otherwise = res\r\n\r\n\r\n\r\nisDerivedOnSeq [] = False\r\n\r\nisDerivedOnSeq [x] = True\r\n\r\nisDerivedOnSeq (x:xs) = s\r\n\r\n		where ((s,_),_) = \r\n\r\n			mapAccumL ((is, prev) x ->\r\n\r\n					if prev < x\r\n\r\n						then ((is, x), x)\r\n\r\n					else ((False, x), x)\r\n\r\n			) \r\n\r\n			(True, x) xs\r\n\r\n\r\n\r\nparts xs = isDerivedOnSeq xs || isDerivedOnSeq2 xs 1 False\r\n','<br/>Тесты успешно пройдены!'),(5135,23,'2156724','2013-09-17 11:52:25',1,'vzpr [] n = True\r\n\r\nvzpr [1] n = True\r\n\r\nvzpr (x:xs) n =\r\n\r\n  if gcd x n == 1 then vzpr xs n\r\n\r\n  else False ;\r\n\r\n\r\n\r\nfunc n a1 (x:xs) =\r\n\r\n   if a1 > n then 0\r\n\r\n   else \r\n\r\n     if a1 == n then \r\n\r\n       if vzpr (x:xs) a1 then 1\r\n\r\n       else 0 \r\n\r\n     else  if vzpr (x:xs) (a1) then   func (n - a1) (a1 + 1) (a1:x:xs) + func n (a1 + 1) (x:xs)\r\n\r\n         else func n (a1+1) (x:xs)\r\n\r\n\r\n\r\nc n = func n 1 [1]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	        \r\n','<br/>Тесты успешно пройдены!'),(5134,23,'2156724','2013-09-17 11:52:08',0,'','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(5133,23,'2156724','2013-09-17 01:10:44',0,'vzpr [] n = True\r\n\nvzpr [1] n = True\r\n\nvzpr (x:xs) n =\r\n\n  if gcd x n == 1 then vzpr xs n\r\n\n  else False ;\r\n\n\r\n\nfunc n a1 (x:xs) =\r\n\n   if a1 > n then 0\r\n\n   else if a1 == n then 1\r\n\n   else  if vzpr (x:xs) (a1) then   func (n - a1) (a1 + 1) ((a1+1):x:xs) + func n (a1 + 1) (x:xs)\r\n\n         else func n (a1+1) (x:xs)\r\n\n\r\n\nc n = func n 1 [1]\r\n\n\r\n\n\r\n\n\r\n\n	        \n','Выражение имеет неправильное значение: c 9'),(5132,31,'deripaska','2013-09-17 01:01:27',1,'{--\r\n\r\n	task 04-02\r\n\r\n*Доп.задача, немного посложнее (но не очень сложная)*\r\n\r\nНаписать функцию parts2, которая проверяет, можно ли в данном списке выбрать ровно половину элементов, чтобы\r\n\r\n- они строго возрастали\r\n\r\n- в оставшейся половине элементы тоже строго возрастали.\r\n\r\nВ этой задаче элементы не обязательно брать подряд.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nparts2 [1, 3, 1, 8, 4, 9]\r\n\r\nОтвет должен быть True (разбивается, например, на \r\n\r\n[1, 3, 4] и [1, 8, 9])\r\n\r\nparts2 [1, 2, 3, 5, 1, 7]\r\n\r\nответ должен быть False.\r\n\r\n\r\n\r\nЗамечания:\r\n\r\n- в этой задаче решение должно быть более-менее эффективным. Т.е., если присланное решение покажется мне очень неэффективным, я могу попросить его улучшить, даже если всегда дает правильные результаты \r\n\r\n- я знаю очень эффективное решение, со сложностью, видимо O(N^2), а мб. немного больше (O(N^3)?), в зависимости от реализации. Но вполне подойдут и менее эффективные. \r\n\r\n--}\r\n\r\n\r\n\r\nparts2 (xs) = parts xs [0] [0] k k \r\n\r\n	where k = div (length xs) 2\r\n\r\n\r\n\r\n{--\r\n\r\nНа вход функции передаём \"непросметренный кусок списка\" (rs), \"первый возрастающий список\" (xs), \"второй возрастающий список\" (ys), \r\n\r\n	\"число, сколько осталось добавить элементов в первый список\" (rF), \"число, сколько осталось добавить элементов во второй список\"(rS).\r\n\r\nПроходим с начала списка и рассматриваемый кажый элемент. \r\n\r\nПри рассмотрении элемента:\r\n\r\n- если он строго больше последнего (т.е. максимального) элемента в первом текущем возрастающем (по построению) списке, но при этом он больше и максимального элемента из второго списка,\r\n\r\n	то мы может присоединить этот элемент либо к первому списку, либо ко второму, вызываясь рекурсивно от оставшегося без этого элемента списка\r\n\r\n- если он строго больше только для первого списка, то присоединяем его к первому возрастающему списку и вызываемся рекурсивно\r\n\r\n- аналогично для второго списка возрастающего.\r\n\r\n- иначе мы никуда не можем отнести элемент, а значит в данном случае дальше нам никак не рабить искомым образом\r\n\r\n\r\n\r\nЕсли мы всё-таки обошли все элементы (т.е. потенциально исходный список мы разбили на возрастающие последовательности) (т.е. когда \"оставшийся список\" станет пустым),\r\n\r\nто в этом случае надо только проверить, что найденные списки подходят условиям задачи по своей длине (т.е. проверяем, что и для первого, и для второго \"число, сколько осталось добавить элементов в соответсвующий список\" будет равно 0).\r\n\r\n--} \r\n\r\n\r\n\r\nparts [] _ _ f s\r\n\r\n	| f == 0 && s == 0 = True\r\n\r\n	| otherwise = False\r\n\r\n	\r\n\r\n-- рассматриваем элементы с начала\r\n\r\nparts (r:rs) xs ys rF rS\r\n\r\n	| r > lastXS && r > lastYS = firstVar || secondVar\r\n\r\n	| r > lastXS = firstVar  -- при этом r <= last (ys)\r\n\r\n	| r > lastYS = secondVar  -- при этом r <= last (xs)\r\n\r\n	| otherwise = False \r\n\r\n	where \r\n\r\n			lastXS = last xs\r\n\r\n			lastYS = last ys\r\n\r\n			firstVar = parts rs (xs++[r]) ys (rF - 1) rS\r\n\r\n			secondVar = parts rs xs (ys++[r]) rF (rS - 1)\r\n\r\n\r\n\r\n			\r\n\r\n\r\n\r\n{-- рассматриваем элементы с конца\r\n\r\npart rs (x:xs) (y:ys) rF rS\r\n\r\n	| lastRS < x && lastRS < y = firstVar || secondVar\r\n\r\n	| lastRS < x = firstVar  --при этом lastRS >= last y\r\n\r\n	| lastRS < y = secondVar --при этом lastRS >= last x\r\n\r\n	| otherwise = False \r\n\r\n	where \r\n\r\n			lastRS = last rs\r\n\r\n			initRS = init rs\r\n\r\n			firstVar = (part initRS ([lastRS]:x:xs) ys (rF - 1) rS) \r\n\r\n			secondVar =(part initRS xs ([lastRS]:y:ys) rF (rS - 1))\r\n\r\n--}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5131,31,'62628590','2013-09-16 19:27:56',1,'parts2 (x:xs) = parts3 x (-1/0) 1 0 xs (div (length (x:xs)) 2)\r\nparts3 _ _ l m [] _ \r\n	|l==m = True\r\n	|otherwise = False\r\nparts3 a b l m (x:xs) maxLen\r\n	| l>maxLen || m>maxLen = False\r\n	| x>a&&x>b = parts3 x b (l+1) m xs maxLen || parts3 a x l (m+1) xs maxLen\r\n	| x>a = parts3 x b (l+1) m xs maxLen\r\n	| x>b = parts3 a x l (m+1) xs maxLen\r\n	| otherwise = False','<br/>Тесты успешно пройдены!'),(5130,23,'3270666','2013-09-16 19:10:52',1,'c n = nseq n n []\r\n\r\nnseq 0 0 xs = coprime xs\r\nnseq 1 1 xs = coprime xs\r\n   --- Тут можно написать горадо эффективнее если проверять на взаминую простоту кадое число сразу.\r\n   --- Например, для n = 20 вы будете генерировать 2 4 5 9, 2 4 6 8 и т.д. - но дучше сразу проверить,\r\n   --- что 2 и 4 не взаимно просые и сократить перебор.\r\n   \r\nnseq n m xs = if (((m * (m + 1)) `div` 2) < n)\r\n  then 0\r\n  else nseq (n - m) (min (n - m) (m - 1)) (m:xs) + nseq n (m - 1) xs\r\n\r\ncoprime [] = 1\r\ncoprime (x:xs) = coprime\' xs (x:xs)\r\n\r\ncoprime\' [] [_] = 1\r\ncoprime\' [] (y:y1:ys) = coprime\' ys (y1:ys)\r\ncoprime\' (x:xs) (y:ys) = if (gcd x y == 1) \r\n	then coprime\' xs (y:ys)\r\n	else 0','<br/>Тесты успешно пройдены!'),(5128,22,'3270666','2013-09-16 13:25:43',1,'  -- Одна ошибка есть, ваша программа ломается если x == 2. Но ОК, неважно, засчитано.\r\ng x = if ((mod x 2) == 0)\r\n          --- Тут внутренние скобки не нужны\r\n	then g\' x ((div x 2) - 1)\r\n	else g\' x (div x 2)\r\n          --- Ращ уж вы проверяете на x четность, то тут можно лучше оптимизировать!:) \r\n          --- (Одно из слагаемых точно равно 2)\r\n\r\ng\' x 1 = False\r\ng\' x p = if ((isSimple p && isSimple (x - p)) == True)\r\n   --- == True тут можно не писать\r\n	then True\r\n	else g\' x (p - 1)\r\n\r\nisSimple x = simple x (div x 2)\r\n-- [sqrt x] вместо (div x 2) было бы лучше,\r\n-- но моих познаний в Haskell не хватило, чтобы понять\r\n-- как нормально сделать округление\r\n   --- Да, это проблема Хаскел, и если не знать, правильно написать тут трудно:(\r\n   --- Надо использовать trunkate и fromIntegral как-то так: \r\n   ---   isSimple x = simple x (truncate (sqrt (fromIntegral x)))\r\n\r\nsimple x 1 = True\r\nsimple x p = if ((mod x p) == 0)\r\n	then False\r\n	else simple x (p - 1)','<br/>Тесты успешно пройдены!'),(5129,33,'115753099','2013-09-16 13:50:57',1,'using System;\r\n\r\nnamespace ConsoleApplication\r\n{\r\n    class Program\r\n    {\r\n        static int ACCURACY = 10000;\r\n\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n        {\r\n            double result = 0;\r\n            double step = (a + b) / ACCURACY;\r\n            double curX = a;\r\n            for (int i = 1; i < ACCURACY; i++)\r\n            {\r\n                result += (f(curX) + f(curX + step)) / 2 * step;\r\n                curX += step;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(Integral(i => i * i, 0, 2));\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5127,29,'MaryK','2013-09-16 13:07:53',1,'module Func where\r\nimport Prelude(Bool(..),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<), head, tail, (++))\r\n  --- Вот это все надо убрать, зачем вы это написали? Тогда все скомпилируется, и деже будет работать.\r\n\r\n\r\nminlist::[Int]->Int\r\n\r\nminlist [] = 0\r\n\r\nminlist (x:xs) = m (x:xs) x\r\n\r\nm [] min = min\r\n\r\nm (x:xs) min = if min > x then m xs x \r\n\r\nelse m xs min\r\n\r\n\r\n\r\nfmin :: [Int]->Int->Int->Int\r\n\r\nfmin [] lis cur = cur \r\n\r\nfmin xs lis cur =  if (cur>lis && cur>(head(xs))) then fmin (tail(xs)) lis (head(xs))\r\n\r\n	else fmin (tail(xs)) lis cur \r\n\r\n\r\n\r\ncheckDifferent:: [Int]->Bool\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent xs = c ([fmin (xs) (minlist xs) (head(xs))]) (tail xs) True\r\n\r\nc:: [Int]->[Int]->Bool->Bool\r\n\r\nc xx [] res = res\r\n\r\nc xx xs res =  if (fmin xs (minlist xs) (head(xs)))>head(xx) then c ([fmin xs (minlist xs) (head(xs))]++ xx) (tail (xs)) True\r\n\r\n	else c xx [] False \r\n\r\n\r\n\r\n \r\n','Выражение имеет неправильное значение: checkDifferent [3,2,7]'),(5126,26,'MaryK','2013-09-16 13:07:38',1,'module Func where\r\n\r\nimport Prelude(Bool(..),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<), head, tail)\r\n\r\nrev:: [Int]->[Int]\r\n\r\nrev xs = rev\' [] xs\r\n\r\nrev\':: [Int]->[Int]->[Int]\r\n\r\nrev\' xs [] = xs\r\n\r\nrev\' s1 (x:s2) = rev\' (x:s1) s2 \r\n','<br/>Тесты успешно пройдены!'),(5125,27,'MaryK','2013-09-16 13:07:08',1,'module Func where\r\n\r\nimport Prelude(Bool(..),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<), head, tail)\r\n\r\nminsum:: [Int]->Int\r\n\r\nminsum [] = 0\r\n\r\nminsum (x:xs) = m xs (x+head(xs))\r\n\r\nm:: [Int]->Int->Int\r\n\r\nm [] min = min\r\n\r\nm (x:xs) min = if (xs) /= [] && min > (x + (head (xs))) then m (xs) (x + head (xs)) \r\n\r\nelse m (xs) min \r\n\r\n		\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5124,25,'MaryK','2013-09-16 13:06:44',1,'module Func where\r\n\r\nimport Prelude(Bool(..),Int(),Show(..), Eq(..), Floating(..),Float(..), Num(..), Fractional(..), (&&), (>), (<), head, tail)\r\n\r\nminlist::[Int]->Int\r\n\r\nminlist [] = 0\r\n\r\nminlist (x:xs) = m (x:xs) x\r\n\r\nm [] min = min\r\n\r\nm (x:xs) min = if min > x then m xs x \r\n\r\nelse m xs min\r\n\r\n		\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5123,31,'3320654','2013-09-16 12:02:01',1,'parts2 []		= True\r\nparts2 (x:xs) 	= if (mod (length xs) 2) == 1\r\n		   then parts2\' xs [x] [] (div (length (x:xs)) 2)\r\n		   else False\r\n\r\nparts2\' [] _ _ _		= True\r\nparts2\' (x:xs) (y:ys) list size	= if (countMoreThen xs x 0) > 1\r\n			   then False\r\n			   else 	if ((x > y) && ((length (y:ys)) < size))\r\n				then parts2\' xs (x:y:ys) list size\r\n				else	if (countMoreThen xs x 0) > 0\r\n					then False\r\n					else parts2\' xs (y:ys) (x:list) size\r\n\r\ncountMoreThen [] _ t		= t\r\ncountMoreThen (x:xs) n t	= if (x <= n)\r\n			   then countMoreThen xs n (t + 1)\r\n			   else countMoreThen xs n t','Выражение имеет неправильное значение: parts2 [1,6,9,7]'),(5122,33,'62628590','2013-09-16 11:57:36',1,'using System;\r\n\r\nnamespace PrintTable\r\n{\r\n    class Program\r\n    {\r\n        static double integ(Func<double, double> f, double a, double b)\r\n        {\r\n            if (a >= b)\r\n            {\r\n                return 0;\r\n            }\r\n            else\r\n            {\r\n                double res = 0;\r\n                double step = (a + b) / 100;\r\n                for (int i = 0; i < 100; i++)\r\n                {\r\n                    res = res + f(a + i * step) * step;\r\n                }\r\n                return res;\r\n            }\r\n        }\r\n\r\n        static Func<double, double> sqr = i => i * i;\r\n\r\n        static double cube(double i)\r\n        {\r\n            return i * i * i;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"{0}\", integ(sqr, 0, 1)); //0,32835\r\n            Console.WriteLine(\"{0}\", integ(cube, 0, 1)); //0,245025\r\n            Console.WriteLine(\"{0}\", integ(x => x * x, 0, 1)); //0,32835\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(5121,30,'2156724','2013-09-16 11:22:57',1,'vozr [x] = True\r\n\r\nvozr (x:xs) = \r\n\r\n  if (x > head xs) then False\r\n\r\n  else vozr (xs)\r\n\r\n\r\n\r\nfunc1 [] n = True\r\n\r\n\r\n\r\nfunc1 (x:xs) n =\r\n\r\n   if vozr (take n (x:xs)) == True then func1 (drop n (x:xs)) n\r\n\r\n   else False\r\n\r\n\r\n\r\nfunc (x:xs) n =\r\n\r\n   if n > quot (length (x:xs)) 2 then False\r\n\r\n   else\r\n\r\n    if mod (length (x:xs)) n == 0 && (func1 (x:xs) n == True) then True\r\n\r\n     else func (x:xs) (n+1)\r\n\r\n\r\n\r\nparts (x:xs) = \r\n\r\n   if vozr (x:xs) then True\r\n\r\n   else  func (x:xs) 2 \r\n','<br/>Тесты успешно пройдены!'),(5118,26,'641524','2013-09-16 01:17:18',1,'rev xs = rev\' [] xs\r\n\r\nrev\' xs [] = xs\r\n\r\nrev\' xs (y:ys) = rev\' (y:xs) ys\r\n','<br/>Тесты успешно пройдены!'),(5119,29,'641524','2013-09-16 03:42:29',1,'checkDifferent [] = True\r\n\r\ncheckDifferent (x:xs) = if checkDifferent\' x xs\r\n\r\n				then checkDifferent xs\r\n\r\n				else False\r\n\r\ncheckDifferent\' x [] = True\r\n\r\ncheckDifferent\' x xs = if (x == head xs) \r\n\r\n			  then False\r\n\r\n			  else checkDifferent\' x (tail xs)\r\n','<br/>Тесты успешно пройдены!'),(5120,22,'Valentina Guleva','2013-09-16 05:47:25',1,'isPrime 1 = False\r\n\r\nisPrime 2 = True\r\n\r\nisPrime n = if sum[ x | x <- [2..(n - 1)], mod n x == 0 ] == 0\r\n\r\n	    then True\r\n\r\n	    else False\r\n\r\ng n = if sum[ a | a <- [2..(n - 1)], isPrime a, isPrime (n - a), a /= (n - a)] > 0\r\n   --- или, на самом деле, можно проверять до n `div` 2. (Если есть такие два числа, то точно\r\n   --- одно из них меньше половины\r\n      then True\r\n\r\n      else False	\r\n','<br/>Тесты успешно пройдены!'),(5114,29,'artem.gomerman','2013-09-16 00:54:01',1,'checkDifferent [] = True\r\n\r\ncheckDifferent xs = checkDifferent\' (tail xs) (findFirstElement xs)\r\n\r\ncheckDifferent\' _ True = False\r\n\r\ncheckDifferent\' [] False = True\r\n\r\ncheckDifferent\' xs p = checkDifferent\' (tail xs) (findFirstElement xs)\r\n\r\nfindFirstElement (x:xs) = any (x==) xs\r\n','<br/>Тесты успешно пройдены!'),(5115,30,'nomeansno','2013-09-16 00:57:56',1,'check\' n [] _ = (True, [])\r\n\r\ncheck\' 0 s _ = (True, s) \r\n\r\ncheck\' n (y:ys) x = if x >= y then (False, [])\r\n\r\nelse check\' (n-1) ys y\r\n\r\n\r\n\r\ncheck _ 0 _ = True\r\n\r\ncheck n k (x:xs) = if fst (check\' (n-1) xs x) == True then check n (k-1) (snd (check\' (n-1) xs x))\r\n\r\nelse False\r\n\r\n\r\n\r\nlength\' [] = 0\r\n\r\nlength\' (_:xs) = 1 + length\' xs\r\n\r\n\r\n\r\nparts s = parts\' 2 s l \r\n\r\n          where l = length\' s\r\n\r\n\r\n\r\nparts\' n s l = if n > l then False \r\n\r\nelse if l `mod` n == 0 && check n (l `div` n) s then True\r\n\r\nelse parts\' (n+1) s l\r\n','<br/>Тесты успешно пройдены!'),(5116,28,'641524','2013-09-16 00:58:37',1,'check cond [] = False\r\n\r\ncheck cond (x:xs) = if cond x \r\n\r\n			then True\r\n\r\n			else check cond xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5117,29,'5247795','2013-09-16 00:58:49',1,'checkDifferent [] = True\r\n\r\ncheckDifferent (x:xs) =\r\n\r\n	if check (y->y==x) xs\r\n\r\n	then False\r\n\r\n	else checkDifferent xs\r\n\r\n\r\n\r\ncheck cond [] = False\r\n\r\ncheck cond (x:xs) =\r\n\r\n	if cond x\r\n\r\n	then True\r\n\r\n	else check cond xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5111,28,'5247795','2013-09-16 00:44:08',1,'check cond [] = False\r\n\r\ncheck cond (x:xs) =\r\n\r\n	if cond x\r\n\r\n	then True\r\n\r\n	else check cond xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5112,27,'641524','2013-09-16 00:45:07',1,'minsum (x:y:xs) = minsum\' (x+y) (y:xs)\r\n\r\nminsum\' x [] = x\r\n\r\nminsum\' x [y] = x\r\n\r\nminsum\' x (y:z:xs) = let s = (y + z)\r\n\r\n		   in if s < x\r\n\r\n			then minsum\' s (z:xs)\r\n\r\n			else minsum\' x (z:xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5113,29,'3301494','2013-09-16 00:51:06',1,'checkCond _ [] = False\r\n\r\ncheckCond lambda xs = if (lambda (head xs)) then True else checkCond lambda (tail xs)\r\n\r\ncheck cond xs = checkCond cond xs\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent xs = if (check (x->x==(head xs)) (tail xs)) then False else checkDifferent (tail xs)\r\n','<br/>Тесты успешно пройдены!'),(5110,29,'2156724','2013-09-16 00:40:57',1,'checkDifferent [] = True;\r\n\r\ncheckDifferent [a] = True;\r\n\r\n\r\n\r\ncheckDifferent (x:xs) = if (elem x (xs)) then False\r\n\r\n else checkDifferent xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5109,28,'artem.gomerman','2013-09-16 00:38:48',1,'check cond [] = False\r\n\r\ncheck cond (x:xs) = check\' cond xs (cond x)\r\n\r\ncheck\' _ _ True = True\r\n\r\ncheck\' _ [] False = False\r\n\r\ncheck\' cond (x:xs) _ = check\' cond xs (cond x)\r\n','<br/>Тесты успешно пройдены!'),(5108,28,'artem.gomerman','2013-09-16 00:38:08',0,'check cond (x:xs) = check\' cond xs (cond x)\r\n\ncheck\' _ _ True = True\r\n\ncheck\' _ [] False = False\r\n\ncheck\' cond (x:xs) _ = check\' cond xs (cond x)\n','Не удалось вычислить выражение \"check (x->x>5) []\", проверьте правильность синтаксиса'),(5106,26,'artem.gomerman','2013-09-16 00:31:36',1,'rev [] = []\r\n\r\nrev (x:xs) = rev\' xs [x]\r\n\r\nrev\' [] xs = xs\r\n\r\nrev\' (x:xs) ps = rev\' xs (x:ps)\r\n','<br/>Тесты успешно пройдены!'),(5107,29,'2156724','2013-09-16 00:34:26',0,'checkDifferent [a,b] =\r\n\n  if a == b then False\r\n\n  else True;\r\n\n\r\n\ncheckDifferent [] = True;\r\n\ncheckDifferent [a] = True;\r\n\n\r\n\ncheckDifferent (x:xs) = maximum [(elem x (tail xs)),  checkDifferent xs]\n','Выражение имеет неправильное значение: checkDifferent [3,2,7,5,2,8]'),(5105,28,'3301494','2013-09-16 00:30:30',1,'checkCond _ [] = False\r\n\r\ncheckCond lambda xs = if (lambda (head xs)) then True else checkCond lambda (tail xs)\r\n\r\ncheck cond xs = checkCond cond xs\r\n   --- checkCond на самом деле не очень нужен, все ваши определения\r\n   --- можно было бы написать прямо для check\r\n','<br/>Тесты успешно пройдены!'),(5104,25,'641524','2013-09-16 00:29:27',1,'minlist (x:xs) = minlist\' x xs\r\n\r\nminlist\' x [] = x\r\n\r\nminlist\' x (y:ys) = if y < x\r\n\r\n			then minlist\' y ys\r\n\r\n			else minlist\' x ys\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5103,30,'62628590','2013-09-16 00:27:14',1,'parts (x:xs) = parts0 x xs 2\r\nparts0 _ [] _ = True\r\nparts0 a (x:xs) l\r\n	|parts1 a (x:xs) (l-1) l = True\r\n	|x>a = parts0 x xs (l+1)\r\n	|otherwise = False\r\nparts1 _ [] l lOld\r\n	|l==lOld = True\r\n	|otherwise = False\r\nparts1 a (x:xs) l lOld\r\n	|l==lOld = parts1 x xs 1 lOld\r\n	|x>a = parts1 x xs (l+1) lOld\r\n	|otherwise = False','<br/>Тесты успешно пройдены!'),(5102,29,'2156724','2013-09-16 00:26:51',0,'checkDifferent [] = False;\r\n\ncheckDifferent [a] = False;\r\n\ncheckDifferent (x:xs) = maximum [(elem x (tail xs)),  checkDifferent xs] \n','Выражение имеет неправильное значение: checkDifferent [3,2,7]'),(5101,26,'3301494','2013-09-16 00:20:49',1,'﻿_rev [] xs = xs \r\n\r\n_rev (xs) ys = _rev (tail xs) ((head xs):ys)  \r\n\r\nrev (xs) = _rev (xs) []\r\n  --- вместо (xs) всюду можно xs\r\n','<br/>Тесты успешно пройдены!'),(5099,25,'artem.gomerman','2013-09-16 00:20:06',1,'minlist [] = 0\r\n\r\nminlist xs = minlist\' (tail xs) (head xs)\r\n\r\nminlist\' [] p = p\r\n\r\nminlist\' (x:xs) p = minlist\' xs (min x p)\r\n','<br/>Тесты успешно пройдены!'),(5100,27,'artem.gomerman','2013-09-16 00:20:39',1,'minsum [] = 0\r\n\r\nminsum [x] = x\r\n\r\nminsum (x:y:xs) = minsum\' (y:xs) (x + y)\r\n\r\nminsum\' [_] p = p\r\n\r\nminsum\' (x:y:xs) p = minsum\' (y:xs) (min (x + y) p)\r\n','<br/>Тесты успешно пройдены!'),(5097,26,'5247795','2013-09-16 00:14:34',0,'rev (x:xs) = rev1 xs [x]\r\n\nrev1 (x:xs) ys = rev1 xs (x:ys)\r\n\nrev1 [] ys = ys\n','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(5098,26,'5247795','2013-09-16 00:19:46',1,'rev [] = []\r\n\r\nrev (x:xs) = rev1 xs [x]\r\n\r\nrev1 (x:xs) ys = rev1 xs (x:ys)\r\n\r\nrev1 [] ys = ys\r\n','<br/>Тесты успешно пройдены!'),(5092,28,'2156724','2013-09-16 00:03:57',0,'cond a = 1;\r\n\ncheck cond (x:xs) = maximum (map cond (x:xs))\n','Не удалось вычислить выражение \"check (x->x>5) []\", проверьте правильность синтаксиса'),(5093,27,'5247795','2013-09-16 00:04:48',1,'minsum (x:y:xs) = minsum1 (x + y) (y:xs)\r\n\r\nminsum1 min [x] = min\r\n\r\nminsum1 min (x:y:xs) =\r\n\r\n	if (x + y) > min \r\n\r\n	then minsum1 min (y:xs)\r\n\r\n	else minsum1 (x + y) (y:xs)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5094,28,'2156724','2013-09-16 00:05:19',1,'cond a = 1;\r\n  --- Эта строчка совсем лишняя \r\ncheck cond [] = False\r\n\r\ncheck cond (x:xs) = maximum (map cond (x:xs))\r\n','<br/>Тесты успешно пройдены!'),(5095,27,'3301494','2013-09-16 00:06:08',0,'minElem x y = if x (<= y) then x else y\r\n\nminsum  [x] = x\r\n\nminsum  [x, y] = x + y\r\n\nminsum  (x:y:xs) = minElem (x + y) (minsum (y:xs))\n','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(5096,27,'3301494','2013-09-16 00:10:18',1,'minElem x y = if (x <= y) then x else y\r\n\r\nminsum  [x] = x\r\n\r\nminsum  [x, y] = x + y\r\n\r\nminsum  (x:y:xs) = minElem (x + y) (minsum (y:xs))\r\n','<br/>Тесты успешно пройдены!'),(5091,25,'3301494','2013-09-16 00:03:22',1,'minElem x y = if (x <= y) then x else y\r\n\r\n\r\n\r\nminlist [x] = x\r\n\r\n\r\n\r\nminlist (x:xs) = minElem x (minlist xs)\r\n\r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5085,27,'2156724','2013-09-15 23:21:56',1,'minsum1 [a,b] [] = [a+b]\r\n\r\nminsum1 [a,b] xs = a+b : xs\r\n\r\nminsum1 b xy = \r\n\r\n   minsum1 (tail b) ((head (tail b) + head b) : xy)\r\n\r\n   \r\n\r\nminsum xs = let p1 = minsum1 xs [] in minimum p1\r\n','<br/>Тесты успешно пройдены!'),(5086,29,'6053606','2013-09-15 23:32:02',1,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = not (any (eq x) xs) && checkDifferent xs\r\neq x y = x == y\r\n','<br/>Тесты успешно пройдены!'),(5087,26,'2156724','2013-09-15 23:33:56',0,'','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(5088,26,'2156724','2013-09-15 23:34:08',0,'rev1 [] (x:xs1) = x:xs1\r\n\nrev1 (x:xs) [] = rev1 xs [x]\r\n\nrev1 (x:xs) (y:xs1) = rev1 xs  (x:y:xs1)\r\n\nrev (x:xs) = rev1 (x:xs) [] \r\n\n\n','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(5089,26,'2156724','2013-09-15 23:34:47',1,'\r\nrev1 [] (x:xs1) = x:xs1\r\n\r\nrev1 (x:xs) [] = rev1 xs [x]\r\n\r\nrev1 (x:xs) (y:xs1) = rev1 xs  (x:y:xs1)\r\n\r\nrev [] = []\r\n\r\nrev (x:xs) = rev1 (x:xs) [] \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5090,25,'5247795','2013-09-15 23:41:28',1,'minlist (x:xs) = minlist1 x xs\r\n\r\nminlist1 min (x:xs) =\r\n\r\n	if x > min \r\n\r\n	then minlist1 min xs\r\n\r\n	else minlist1 x xs\r\n\r\nminlist1 min [] = min\r\n','<br/>Тесты успешно пройдены!'),(5084,23,'8519021','2013-09-15 23:15:45',1,'c n = nseq\' n 1 []\r\n\r\nnseq\' n i xs\r\n\r\n  | i == n = if gcd\' (i:xs) then 1 else 0\r\n      --- Засчтано, но вообще лучше было бы проверять взаимною простоту кажле чесло, перед добавлением.\r\n      --- Ну например, если у вас n = 20б то вы возьмете скажем числа 2 4 и будете проверять\r\n      --- дальше всае варианты: 2 4 5 9, 2 4 6 8, 2 4 14 - но они все точно не подходят,\r\n      --- потому что 2 и 4 не взаимно простые\r\n  | i < n = nseq\' (n - i) (i + 1) (i:xs) + nseq\' n (i + 1) xs \r\n\r\n  | otherwise = 0\r\n\r\ngcd\' [] = True\r\n\r\ngcd\' (x:xs) = gcd\'\' x xs && gcd\' xs\r\n\r\ngcd\'\' _ [] = True\r\n\r\ngcd\'\' x (y:ys)\r\n\r\n  | gcd x y == 1 = gcd\'\' x ys\r\n\r\n  | otherwise = False\r\n','<br/>Тесты успешно пройдены!'),(5083,30,'3320654','2013-09-15 22:56:19',1,'parts []		= True\r\nparts list		= allParts (allDivisors (length list)) list\r\n\r\nallParts [] _	= False\r\nallParts (x:s) list	= if (isCOP list x)\r\n		   then True\r\n		   else allParts s list\r\n\r\nallDivisors x 	= allDivisors\' [] x 2\r\nallDivisors\' list x cD	= if ((mod x cD) == 0)\r\n		   then allDivisors\' (cD:list) x (cD + 1)\r\n		   else	if (cD < x)\r\n			then allDivisors\' (list) x (cD + 1)\r\n			else list			\r\n\r\n--consist of increasing parts with length n\r\nisCOP [] _		= True\r\nisCOP list n	= isCOP\' list [] n\r\nisCOP\' [] [] _	= False\r\nisCOP\' [] (x:s) _	= isDecreasing s x\r\nisCOP\' (x:s) listCur n	= if ((length listCur) < n)\r\n		   then isCOP\' s (x:listCur) n\r\n		   else 	if (isDecreasing (tail listCur) (head listCur))\r\n			then True\r\n			else isCOP\' (x:s) [] n\r\n\r\nisDecreasing [] _ 	 = True\r\nisDecreasing (x:s) prev = if x < prev\r\n	     	    then isDecreasing s x\r\n		    else False','<br/>Тесты успешно пройдены!'),(5082,30,'3320654','2013-09-15 22:53:13',0,'parts []		= True\r\nparts list		= allParts (allDivisors (length list)) list\r\n\r\nallParts [] _	= False\r\nallParts (x:s) list	= if (isCOP list x)\r\n		   then True\r\n		   else allParts s list\r\n\r\nallDivisors x 	= allDivisors\' [] x 2\r\nallDivisors\' list x cD	= if ((mod x cD) == 0)\r\n		   then allDivisors\' (cD:list) x (cD + 1)\r\n		   else	if (cD < x)\r\n			then allDivisors\' (list) x (cD + 1)\r\n			else list			\r\n\r\n--consist of increasing parts with length n\r\nisCOP [] _		= True\r\nisCOP list n	= isCOP\' list [] n\r\nisCOP\' [] _ _	= False\r\nisCOP\' (x:s) listCur n	= if ((length listCur) < n)\r\n		   then isCOP\' s (x:listCur) n\r\n		   else 	if (isDecreasing (tail listCur) (head listCur))\r\n			then True\r\n			else isCOP\' (x:s) [] n\r\n\r\nisDecreasing [] _ 	 = True\r\nisDecreasing (x:s) prev = if x < prev\r\n	     	    then isDecreasing s x\r\n		    else False','Выражение имеет неправильное значение: parts [1, 2, 3, 4, 5]'),(5080,25,'2156724','2013-09-15 22:38:18',1,'minlist [a] = a\r\n\r\nminlist xs =\r\n\r\n  if head xs < head (tail xs) then minlist (head xs : tail (tail xs))\r\n\r\n  else minlist (tail xs) \r\n\r\n     \r\n','<br/>Тесты успешно пройдены!'),(5081,30,'3320654','2013-09-15 22:49:25',0,'parts []		= True\r\nparts list		= allParts (allDivisors (length list)) list\r\n\r\nallParts [] _	= False\r\nallParts (x:s) list	= if (isCOP list x)\r\n		   then True\r\n		   else allParts s list\r\n\r\nallDivisors x 	= allDivisors\' [] x 2\r\nallDivisors\' list x cD	= if ((mod x cD) == 0)\r\n		   then allDivisors\' (cD:list) x (cD + 1)\r\n		   else	if (cD < x)\r\n			then allDivisors\' (list) x (cD + 1)\r\n			else list			\r\n\r\n--consist of increasing parts with length n\r\nisCOP [] _		= True\r\nisCOP list n	= isCOP\' list [] n\r\nisCOP\' [] _ _	= False\r\nisCOP\' (x:s) listCur n	= if ((length listCur) < n)\r\n		   then isCOP\' s (x:listCur) n\r\n		   else 	if (isDecreasing (tail listCur) (head listCur))\r\n			then isCOP\' (x:s) [] n\r\n			else False\r\n\r\nisDecreasing [] _ 	 = True\r\nisDecreasing (x:s) prev = if x < prev\r\n	     	    then isDecreasing s x\r\n		    else False','Выражение имеет неправильное значение: parts [1, 2, 8, 2, 5, 6]'),(5079,29,'egeorge','2013-09-15 21:23:12',1,'findElement x [] = False\r\nfindElement x xs = (x == (head(xs))) || findElement x (tail(xs))\r\n   --- тут почти все скобки лишние, можно\r\n   --- x == head xs || findElement x (tail xs)\r\ncheckDifferent [] = True\r\ncheckDifferent (x:xs) = if findElement x xs then False else checkDifferent xs','<br/>Тесты успешно пройдены!'),(5078,29,'egeorge','2013-09-15 21:20:17',0,'findElement x [] = False\r\nfindElement x xs = (x == (head(xs))) || (findElement x (tail(xs)))\r\n\r\ncheckDifferent [] = False\r\ncheckDifferent (x:xs) = if findElement x xs then False else checkDifferent xs','Выражение имеет неправильное значение: checkDifferent [3,2,7]'),(5077,29,'ArtemK','2013-09-15 21:11:42',1,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = not (contains x xs) && checkDifferent xs\r\ncontains _ [] = False\r\ncontains y (x:xs) = if x == y\r\n                    then True\r\n                    else contains y xs','<br/>Тесты успешно пройдены!'),(5076,28,'egeorge','2013-09-15 21:09:38',1,'check cond [] = False\r\ncheck cond (x:xs) = if cond x then True else check cond xs','<br/>Тесты успешно пройдены!'),(5074,26,'egeorge','2013-09-15 21:03:38',1,'rev [] = []\r\nrev (x:xs) = rev(xs) ++ [x]','<br/>Тесты успешно пройдены!'),(5075,22,'54411321','2013-09-15 21:04:32',1,'isPrime x = let\r\n\r\n                l = takeWhile (y ->  y*y <= x) [2..]\r\n\r\n            in not (any (i-> x `mod` i == 0) l)\r\n\r\n\r\n\r\ng x = let\r\n\r\n          l = [2..(x `div` 2)]\r\n      in any (i-> (isPrime i) && isPrime (x - i) && i /= (x - i)) l\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5072,27,'egeorge','2013-09-15 20:55:19',1,'minsum (x:y:[]) = x + y\r\nminsum (x:y:xs) = min (x + y) (minsum (y:xs))','<br/>Тесты успешно пройдены!'),(5073,28,'ArtemK','2013-09-15 20:57:35',1,'check _ [] = False\r\ncheck cond (x:xs) = if cond x\r\n                    then True\r\n                    else check cond xs','<br/>Тесты успешно пройдены!'),(5070,26,'ArtemK','2013-09-15 20:53:43',1,'rev xs = rev\' xs []\r\nrev\' [] ys = ys\r\nrev\' (x:xs) ys = rev\' xs (x:ys)','<br/>Тесты успешно пройдены!'),(5071,25,'egeorge','2013-09-15 20:54:44',1,'minlist (x:[]) = x\r\n    ---или немного короче minlist [x] = x\r\nminlist (x:xs) = min x (minlist xs)','<br/>Тесты успешно пройдены!'),(5069,27,'ArtemK','2013-09-15 20:50:50',1,'minsum (x:y:xs) = minsum\' (x+y) (y:xs)\r\nminsum\' mcur (x:y:xs) = if xy < mcur\r\n                        then minsum\' xy (y:xs)\r\n                        else minsum\' mcur (y:xs) \r\n                        where xy = x+y\r\nminsum\' mcur _ = mcur','<br/>Тесты успешно пройдены!'),(5067,28,'6053606','2013-09-15 20:01:08',1,'check cond [] = False\r\ncheck cond (x:xs) = if cond x\r\n                    then True\r\n                    else check cond xs\r\n','<br/>Тесты успешно пройдены!'),(5068,25,'ArtemK','2013-09-15 20:33:53',1,'minlist (x:xs) = minlist\' x xs\r\nminlist\' mcur [] = mcur\r\nminlist\' mcur (x:xs) = if x < mcur \r\n                                  then minlist\' x xs\r\n                                  else minlist\' mcur xs','<br/>Тесты успешно пройдены!'),(5066,22,'54411321','2013-09-15 20:00:23',0,'isPrime x = let \n\n                l = takeWhile (y ->  y*y <= x) [2..]\n\n            in not (any (i-> x `mod` i == 0) l)\n\n\n\ng x = let\n\n          l = takeWhile (y ->  y <= x `div` 2) [2..]\n\n      in any (i-> (isPrime i) && isPrime (x - i) && i /= (x - i)) l\n\n\n','<br/>Тесты успешно пройдены!'),(5065,26,'6053606','2013-09-15 19:55:57',1,'rev xs = rev\' xs []\r\nrev\' [] acc = acc\r\nrev\' (x:xs) acc = rev\' xs (x:acc)\r\n','<br/>Тесты успешно пройдены!'),(5064,22,'15309342','2013-09-15 19:55:47',1,'isPrime x = ([] == [y | y<-[2..x-1], mod x y == 0])\r\nf n = [ (x, y) | x <- [2..n], y <- [2..n], x + y == n, isPrime x, isPrime y, x /= y]\r\ng n = ([] /= (f n))\r\n   --- Засчитано, но на самом деле это у вас получилось _очень_ не эффективно. Не смысла _перебирать_\r\n   --- все значения у, ведь вы и так знаете, что у дб равен n-y.\r\n   --- Но ОК, засчитано, и мы обсудим похожий пример, когда будем проходить list comprehension  ','<br/>Тесты успешно пройдены!'),(5061,26,'15309342','2013-09-15 19:45:21',1,'rev xs = rev1 xs []\r\nrev1 [] ys = ys\r\nrev1 (x:xs) ys = rev1 xs (x : ys)\r\n','<br/>Тесты успешно пройдены!'),(5062,28,'15309342','2013-09-15 19:47:50',1,'check cond [] = False\r\ncheck cond (x:xs) = if cond x then True else check cond xs\r\n','<br/>Тесты успешно пройдены!'),(5063,29,'15309342','2013-09-15 19:53:32',1,'checkDifferent [] = error \"Not defined on empty lists\"\r\ncheckDifferent (x:[]) = True\r\ncheckDifferent (x:xs) = if existsInList x xs then False else checkDifferent xs\r\n\r\nexistsInList x [] = False\r\nexistsInList x (y:ys) = if x == y then True else existsInList x ys','<br/>Тесты успешно пройдены!'),(5059,25,'15309342','2013-09-15 19:31:03',1,'minlist xs = minlist1 xs (head xs)\r\nminlist1 [] k = k\r\nminlist1 (x:xs) k = if x < k then minlist1 xs x else minlist1 xs k','<br/>Тесты успешно пройдены!'),(5060,27,'15309342','2013-09-15 19:36:31',1,'minsum ([]) = error \"Not enough elements. Should be minimum 2 of them!\"\r\n   --- тут скобки не нужны\r\nminsum (x:[]) = error \"Not enough elements. Should be minimum 2 of them!\"\r\n   -- или короче minsum [x] = ...\r\nminsum (x:y:xs) = minsum1 (y:xs) (x + y)\r\n\r\nminsum1 (x:[]) sum = sum\r\nminsum1 (x:y:xs) sum = if x + y < sum then minsum1 (y:xs) (x + y) else minsum1 (y:xs) sum\r\n','<br/>Тесты успешно пройдены!'),(5058,18,'15309342','2013-09-15 19:30:43',1,'minlist xs = minlist1 xs (head xs)\r\nminlist1 [] k = k\r\nminlist1 (x:xs) k = if x < k then minlist1 xs x else minlist1 xs k','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(5057,27,'6053606','2013-09-15 19:29:47',1,'minsum []  = error \"empty\"\r\nminsum [x] = error \"one element\"\r\nminsum [x, y] = x + y\r\nminsum (x:y:xs) = min (x + y) $ minsum (y:xs)\r\n','<br/>Тесты успешно пройдены!'),(5055,22,'Valentina Guleva','2013-09-15 18:35:15',2,'   --- Ну, у вас впроде правильно, кроме того, что вы не совсем точно поняли условие (то, о чем я написал\r\n   --- в письме). Исправьте пожалуйста это (то, что числа дб разные).  \r\nisPrime 1 = False\r\n\r\nisPrime 2 = True\r\n\r\nisPrime n = if sum[ x | x <- [2..(n - 1)], mod n x == 0 ] == 0\r\n\r\n	    then True\r\n\r\n	    else False\r\n\r\ng n = if sum[ a | a <- [2..(n - 1)], isPrime a, isPrime (n - a)] > 0\r\n\r\n      then True\r\n\r\n      else False	\r\n','Выражение имеет неправильное значение: g 6'),(5056,25,'6053606','2013-09-15 19:17:36',1,'minlist []     = error \"empty\"\r\nminlist [x]    = x\r\nminlist (x:xs) = min x $ minlist xs\r\n','<br/>Тесты успешно пройдены!'),(5054,25,'egeorge','2013-09-15 18:18:02',0,'minlist l = if (length l == 1) then head l else min (head l) (minlist (tail l))','<br/>Тесты успешно пройдены!'),(5052,29,'anna','2013-09-15 17:07:46',0,'foo [] _ = 0\n\nfoo (x:xs) n  = if (x == n) then 1 + foo xs n else foo xs n\n\n\n\n\n\ncheckDifferent [x] = True	\n\ncheckDifferent [] = False		 \n\ncheckDifferent (x:y:xs) = let a = foo \n\n                      in if a (x:y:xs) x == 1 then check (y:xs) else check [] 		 \n','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5053,29,'anna','2013-09-15 17:08:27',1,'foo [] _ = 0\r\n\r\nfoo (x:xs) n  = if (x == n) then 1 + foo xs n else foo xs n\r\n\r\n\r\n\r\n\r\n\r\ncheckDifferent [x] = True	\r\n\r\ncheckDifferent [] = False		 \r\n\r\ncheckDifferent (x:y:xs) = let a = foo \r\n\r\n                      in if a (x:y:xs) x == 1 then checkDifferent (y:xs) else checkDifferent [] \r\n    --- или проще ... else False		 \r\n','<br/>Тесты успешно пройдены!'),(5051,29,'anna','2013-09-15 17:06:54',0,'foo [] _ = 0\n\nfoo (x:xs) n  = if (x == n) then 1 + foo xs n else foo xs n\n\n\n\n\n\ncheck [x] = True	\n\ncheck [] = False		 \n\ncheck (x:y:xs) = let a = foo \n\n                      in if a (x:y:xs) x == 1 then check (y:xs) else check [] 		 \n','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5050,29,'617015','2013-09-15 17:02:10',1,'checkDifferent (x:xs)= chDiff x xs\r\n\r\nchDiff x (y:xs) = if contain x (y:xs) then False else chDiff y xs\r\n\r\nchDiff x [] = True\r\n\r\ncontain x (y:xs) = if x==y then True else contain x xs\r\n\r\ncontain x [] = False\r\n','<br/>Тесты успешно пройдены!'),(5049,28,'617015','2013-09-15 17:01:14',1,'check cond (x:xs) = check\' cond(x) xs\r\n\r\ncheck cond [] = False\r\n\r\ncheck\' cond(x) (y:xs) = if cond(x) then True else check\' cond(y) xs\r\n   --- Можно cond x - без скобок (и то же в других местах)\r\n\r\ncheck\' cond(x) [] = if cond(x) then True else False\r\n','<br/>Тесты успешно пройдены!'),(5046,26,'617015','2013-09-15 16:58:20',1,'rev (x:xs) = rev\' xs [x]\r\n\r\nrev[]=[]\r\n\r\nrev\' (x:xs) vs = rev\' xs ([x]++vs)\r\n\r\nrev\' [] vs = vs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5047,28,'617015','2013-09-15 16:58:49',0,'check cond (x:xs) = check\' cond(x) xs\r\n\ncheck\' cond(x) (y:xs) = if cond(x) then True else check\' cond(y) xs\r\n\ncheck\' cond(x) [] = if cond(x) then True else False\n','Не удалось вычислить выражение \"check (x->x>5) []\", проверьте правильность синтаксиса'),(5048,28,'617015','2013-09-15 16:59:53',0,'check cond (x:xs) = check\' cond(x) xs\r\n\ncheck cond [] = True\r\n\ncheck\' cond(x) (y:xs) = if cond(x) then True else check\' cond(y) xs\r\n\ncheck\' cond(x) [] = if cond(x) then True else False\n','Хитрый тест номер 2 не пройден :(<br/>Подсказка: Как вы думаете, что правильно будет вернуть, если список пустой?'),(5045,26,'617015','2013-09-15 16:56:34',0,'rev (x:xs) = rev\' xs [x]\r\n\nrev\' (x:xs) vs = rev\' xs ([x]++vs)\r\n\nrev\' [] vs = vs\n','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(5043,25,'617015','2013-09-15 16:55:17',1,'minlist (x:xs) = min\' x xs\r\n\r\nmin\' k (x:xs) = if k>x then min\' x xs else min\' k xs\r\n\r\nmin\' k [] = k\r\n','<br/>Тесты успешно пройдены!'),(5044,27,'617015','2013-09-15 16:56:00',1,'minsum (x:y:xs) = minsum\' (x+y) y xs\r\n\r\nminsum\' k y (x:xs) = if k > (y +x) then minsum\' (y+x) x xs else minsum\' k x xs\r\n\r\nminsum\' k x [] = k\r\n','<br/>Тесты успешно пройдены!'),(5042,29,'54411321','2013-09-15 16:39:10',1,'checkDifferent []     = True\r\n\r\ncheckDifferent (x:xs) = not (any (i->i==x) xs) && checkDifferent xs\r\n','<br/>Тесты успешно пройдены!'),(5039,29,'54411321','2013-09-15 16:36:16',0,'checkDifferent []     = True\n\ncheckDifferent (x:xs) = not (any (i->i == x) xs) && checkDifferent xs\n','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5040,22,'ip','2013-09-15 16:36:16',0,'g 0 = False\r\ng 1 = False\r\ng k = g2 (findSimple (k-1) []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs x k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k (t k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = k\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5041,22,'ip','2013-09-15 16:37:43',2,'  --- Тут, на самом деле, три ошибки.\r\n  --- 1. У вас не везде правильно стоят скобки. Например, в самом конце, вокруг p-1 дб скобки.\r\n  ---   Но есть еще не сколько похожих мест, попробуйте их найти сами.\r\n  --- 2. Вторая ошибка сложная, вам ее самому врядли получиться исправить, я тут просто подскажу:\r\n  ---   Вместо t k = truncate(sqrt(k))+1\r\n  ---   Надо написать t k = truncate(sqrt(fromIntegral k))+1\r\n  --- Про это мы потом как-нибудь поговорим\r\n  --- 3. У вас findSimple в списке простых чисел не выдает 2 и поэтоу не всегода правильные результаты\r\n  ---  Попробуйте исправить, пожалуйста\r\ng 0 = False\r\ng 1 = False\r\ng k = g2 (findSimple (k-1) []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs x k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k (t k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = truncate(sqrt(k))+1\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5038,22,'ip','2013-09-15 16:34:02',0,'g 0 = False\r\ng 1 = False\r\ng k = g2 (findSimple (k-1) []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs x k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k (t k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = truncate(sqrt(k))+1\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5037,22,'ip','2013-09-15 16:32:55',0,'g 0 = False\r\ng 1 = False\r\ng k = g2 (findSimple (k-1) []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs s k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k (t k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = truncate(sqrt(k))+1\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5036,22,'ip','2013-09-15 16:32:27',0,'g 0 = False\r\ng 1 = False\r\ng k = g2 (findSimple k-1 []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs s k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k (t k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = truncate(sqrt(k))+1\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5035,22,'ip','2013-09-15 16:32:09',0,'g 0 = Flase\r\ng 1 = False\r\ng k = g2 (findSimple k-1 []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs s k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k (t k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = truncate(sqrt(k))+1\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5034,22,'ip','2013-09-15 16:32:00',0,'g 0 = Flase\r\ng 1 = False\r\ng k = g2 (findSimple k-1 []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs s k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k (t k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = truncate(sqrt(k))+1\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5033,22,'ip','2013-09-15 16:30:46',0,'g 0 = Flase\r\ng 1 = False\r\ng k = g2 (findSimple k-1 []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs s k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k t(k)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nt k = truncate(sqrt(k))+1\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if ((mod k p) == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5032,22,'ip','2013-09-15 16:29:20',0,'g 0 = Flase\r\ng 1 = False\r\ng k = g2 (findSimple k-1 []) k\r\n\r\ng2 [] k = False\r\ng2 (x:xs) k = if (checkSum xs s k == True)\r\n              then True\r\n              else g2 xs k\r\n\r\ncheckSum [] _ _ = False\r\ncheckSum (x:xs) s k = if ((x+s)==k)\r\n                      then True\r\n                      else checkSum xs s k\r\n\r\nfindSimple 1 xs = xs\r\nfindSimple k xs = if isSimple k truncate(sqrt(k))+1)\r\n                  then findSimple k-1 (k:xs)\r\n                  else findSimple k-1 xs\r\n\r\nisSimple k 1 = True\r\nisSimple k p = if (mod k p == 0)\r\n               then False\r\n               else isSimple k p-1','Не удалось вычислить выражение \"g 6\", проверьте правильность синтаксиса'),(5030,29,'ip','2013-09-15 16:18:03',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isIn xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = False\r\nisIn (x:xs) p = if (p == xs)\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5031,29,'ip','2013-09-15 16:18:58',1,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isIn xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = False\r\nisIn (x:xs) p = if (p == x)\r\n                then True\r\n                else isIn xs p','<br/>Тесты успешно пройдены!'),(5028,29,'ip','2013-09-15 16:15:45',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isIn xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = False\r\nisIn (x:xs) p = if (p==xs)\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5029,29,'ip','2013-09-15 16:16:36',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isIn xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = False\r\nisIn (x:xs) p = if (p == xs)\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5026,29,'ip','2013-09-15 16:14:20',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isIn xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = Flase\r\nisIn (x:xs) p = if (p==xs)\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5027,29,'ip','2013-09-15 16:14:48',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isIn xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = False\r\nisIn (x:xs) p = if (p==xs)\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5024,29,'ip','2013-09-15 16:13:58',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isin xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = Flase\r\nisIn (x:xs) p = if (p==xs)\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5025,29,'ip','2013-09-15 16:14:03',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isin xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = Flase\r\nisIn (x:xs) p = if (p==xs)\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5023,29,'ip','2013-09-15 16:13:42',0,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = if isin xs x\r\n                        then False\r\n                        else checkDifferent xs\r\nisIn [] p = Flase\r\nisIn (x:xs) p = if p==xs\r\n                then True\r\n                else isIn xs p','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(5018,26,'ip','2013-09-15 16:07:12',1,'rev xs = rev2 xs []\r\nrev2 [] xd = xd\r\nrev2 (x:xs) xd = rev2 xs (x:xd)','<br/>Тесты успешно пройдены!'),(5019,28,'ip','2013-09-15 16:08:58',0,'check f [] = False\r\ncheck f x:xs = if f x\r\n               then True\r\n               else check f xs','Не удалось вычислить выражение \"check ( x->x>5) [3,2,7,4]\", проверьте правильность синтаксиса'),(5020,28,'ip','2013-09-15 16:09:13',0,'check f [] = False\r\ncheck f (x:xs) = if f x\r\n               then True\r\n               else check f xs','<br/>Тесты успешно пройдены!'),(5021,28,'ip','2013-09-15 16:09:22',1,'check f [] = False\r\ncheck f (x:xs) = if f x\r\n               then True\r\n               else check f xs','<br/>Тесты успешно пройдены!'),(5022,28,'54411321','2013-09-15 16:12:13',1,'check _ [] = False\r\n\r\ncheck cond (x:xs) = if cond x\r\n\r\n                    then True\r\n\r\n                    else check cond xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5014,26,'ip','2013-09-15 15:58:17',0,'rev xs = rev2 xs []\r\nrev2 [] xd = xd\r\nrev2 x:xs xd = rev2 xs x:xd\r\n','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(5015,26,'ip','2013-09-15 15:58:24',0,'rev xs = rev2 xs []\r\nrev2 [] xd = xd\r\nrev2 x:xs xd = rev2 xs x:xd\r\n','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(5016,26,'ip','2013-09-15 16:01:43',0,'rev xs = rev2 xs []\r\nrev2 [] xd = xd\r\nrev2 x:xs xd = rev2 xs x:xd\r\n','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(5017,26,'ip','2013-09-15 16:07:02',0,'rev xs = rev2 xs []\r\nrev2 [] xd = xd\r\nrev2 (x:xs) xd = rev2 xs (x:xd)','<br/>Тесты успешно пройдены!'),(5010,27,'ip','2013-09-15 15:54:28',0,'minsum [] = 0\r\nminsum xs = minsum2 xs 0 0\r\nminsum2(x:[]) p z = p\r\nminsum2(x:(y:xs)) z 0 = minsum2 (y:xs) x+y 1\r\nminsum2(x:(y:xs)) p 1 = if (x+y)<p\r\n                        then minsum2(y:xs) x+y 1\r\n                        else minsum2(y:xs) p 1','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(5011,27,'ip','2013-09-15 15:55:59',1,'minsum [] = 0\r\nminsum xs = minsum2 xs 0 0\r\nminsum2(x:[]) p _ = p\r\nminsum2(x:(y:xs)) _ 0 = minsum2 (y:xs) (x+y) 1\r\nminsum2(x:(y:xs)) p 1 = if (x+y)<p\r\n                        then minsum2(y:xs) (x+y) 1\r\n                        else minsum2(y:xs) p 1','<br/>Тесты успешно пройдены!'),(5012,26,'ip','2013-09-15 15:57:36',0,'rev xs = rev2 xs []\r\nrev2 [] xd = xd\r\nrev2 x:xs xd = rev2 xs x:xd\r\n','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(5013,26,'ip','2013-09-15 15:57:48',0,'rev xs = rev2 xs []\r\nrev2 [] xd = xd\r\nrev2 x:xs xd = rev2 xs x:xd\r\n','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(5007,25,'ip','2013-09-15 15:45:59',0,'minlist (x:[]) = x\r\nminlist (x:(y:xs)) = if x>y\r\n                     then y:xs\r\n                     else x:xs','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(5008,25,'ip','2013-09-15 15:47:22',1,'minlist (x:[]) = x\r\nminlist (x:(y:xs)) = if x>y\r\n                     then minlist(y:xs)\r\n                     else minlist(x:xs)','<br/>Тесты успешно пройдены!'),(5009,27,'ip','2013-09-15 15:53:40',0,'minsum [] = 0\r\nminsum xs = minsum2 xs 0 0\r\nminsum2(x:[]) p _ = p\r\nminsum2(x:(y:xs)) _ 0 = minsum2 (y:xs) x+y 1\r\nminsum2(x:(y:xs)) p 1 = if (x+y)<p\r\n                        then minsum2(y:xs) x+y 1\r\n                        else minsum2(y:xs) p 1','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(5006,25,'ip','2013-09-15 15:45:33',0,'minlist (x:[]) = x\r\nminlist (x:(y:xs)) = if x>y\r\n                    then y:xs\r\n                    else x:xs','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(5005,25,'ip','2013-09-15 15:45:06',0,'minlist (x:[]) = x\r\nminlist (x:(y:xs) = if x>y\r\n                    then y:xs\r\n                    else x:xs','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(5004,29,'1170660','2013-09-15 15:44:38',1,'checkDifferent xs = f xs True\r\n\r\nf[] p = p\r\n\r\nf(x:xs) p = if search x xs True then f xs p else f xs False\r\n\r\n\r\n\r\nsearch a [] p  = p\r\n\r\nsearch a (x:xs) p = if a /= x then search a xs p else search a xs False\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5001,28,'Valentina Guleva','2013-09-15 15:14:46',0,'check cond [a] = if (cond a)\r\n\n				 then True\r\n\n				 else False\r\n\ncheck cond (a:x) = if (cond a || check cond x)\r\n\n				then True\r\n\n				else False\n','Не удалось вычислить выражение \"check (x->x>5) []\", проверьте правильность синтаксиса'),(5002,29,'Valentina Guleva','2013-09-15 15:15:39',1,'  --- И тут всюду if выражение then True else выражение\r\n  --- можно заменить просто на выражение \r\ncheckDifferent [a,b] = if (a /= b) \r\n\r\n					   then True \r\n\r\n					   else False\r\n\r\ncheckDifferent (a:x) = if ((hasNo a x) && (checkDifferent x))\r\n\r\n				   then True\r\n\r\n				   else False\r\n\r\nhasNo a [b,c] = \r\n\r\n	if (a/=b)&&(a/=c)\r\n\r\n	then True\r\n\r\n	else False\r\n\r\nhasNo a x = if (a/=(head x) && hasNo a (tail x))\r\n\r\n			then True\r\n\r\n			else False\r\n','<br/>Тесты успешно пройдены!'),(5003,28,'Valentina Guleva','2013-09-15 15:16:22',1,'check cond [] = False\r\n\r\ncheck cond [a] = if (cond a)\r\n\r\n				 then True\r\n\r\n				 else False\r\n\r\ncheck cond (a:x) = if (cond a || check cond x)\r\n\r\n				then True\r\n\r\n				else False\r\n  --- Или просто .. = cond a || check cond x','<br/>Тесты успешно пройдены!'),(4998,26,'Valentina Guleva','2013-09-15 15:12:36',0,'rev [a] = [a]\r\n\nrev x = (last x) : rev(init x)\n','Не удалось вычислить выражение \"rev []\", проверьте правильность синтаксиса'),(4999,28,'1170660','2013-09-15 15:13:00',1,'check cond xs = f cond xs False\r\n\r\nf cond [] p = p \r\n\r\nf cond (x:xs) p = if cond x then f cond xs True else f cond xs p\r\n   --- в then части можно просто then True и все  \r\n\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(5000,26,'Valentina Guleva','2013-09-15 15:14:03',1,'rev [] = []\r\n\r\nrev [a] = [a]\r\n\r\nrev x = (last x) : rev(init x)\r\n   --- Засчитано, но так тоже будет медленно (O(n^2))\r\n   --- потому что и last и init просмативают есь список\r\n','<br/>Тесты успешно пройдены!'),(4997,27,'Valentina Guleva','2013-09-15 15:11:37',1,'minsum[a,b] = (a + b)\r\n\r\nminsum(a : b : x) = if (sum[a, b]) <= minsum (b : x)\r\n  --- Или вместо sum просто if a+b < ... \r\n	then sum[a, b]\r\n\r\n	else minsum (b : x)\r\n','<br/>Тесты успешно пройдены!'),(4995,26,'1170660','2013-09-15 14:59:56',1,'rev xs = f xs []\r\n\r\nf[] ys = ys\r\n\r\nf(x:xs) ys = f xs (x:ys) \r\n','<br/>Тесты успешно пройдены!'),(4996,25,'Valentina Guleva','2013-09-15 15:10:59',1,'minlist[a] = a\r\n\r\nminlist x = if (head x) <= minlist (tail x)\r\n\r\n	then head x\r\n\r\n	else minlist (tail x)\r\n','<br/>Тесты успешно пройдены!'),(4988,25,'54411321','2013-09-15 14:37:36',0,'-- XXX The behaviour of this program on the input [] is not specified\n\nminlist []     = 0\n\nminlist [x]    = x\n\nminlist (x:xs) = min x (minlist xs)\n\n\n','<br/>Тесты успешно пройдены!'),(4989,25,'1170660','2013-09-15 14:40:42',1,'minlist (x:xs) = f xs x\r\n\r\nf [] p = p\r\n\r\nf(x:xs) p = if x<p then f(xs) x else f(xs) p\r\n','<br/>Тесты успешно пройдены!'),(4990,25,'54411321','2013-09-15 14:41:24',1,'minlist [x]    = x\r\n\r\nminlist (x:xs) = min x (minlist xs)\r\n','<br/>Тесты успешно пройдены!'),(4991,27,'54411321','2013-09-15 14:49:23',1,'minsum [x, y] = x + y\r\n\r\nminsum (x:xs) = min (x + head xs) (minsum xs)\r\n','<br/>Тесты успешно пройдены!'),(4992,27,'1170660','2013-09-15 14:53:29',0,'','Не удалось вычислить выражение \"minsum [1,8,3,2,7]\", проверьте правильность синтаксиса'),(4993,27,'1170660','2013-09-15 14:53:46',1,'minsum (x:y:xs) = f (xs) (y) (x+y)\r\n\r\nf [] p s = s\r\n\r\nf(x:xs) p s = if(x+p<s) then f xs x (x+p) else f xs x s\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4994,26,'54411321','2013-09-15 14:57:55',1,'do_rev [] ys     = ys\r\n\r\ndo_rev (x:xs) ys = do_rev xs (x:ys)\r\n\r\n\r\n\r\nrev xs = do_rev xs []\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4985,28,'anna','2013-09-15 12:52:17',0,'--main = putStrLn \"hello, world\" \n\ngoo a(x:xs) = map a (x:xs)\n\nfoo [True] = True\n\nfoo [False] = False\n\nfoo (x:y:xs) = if x==True then foo(x:xs) else foo(y:xs)  \n\ncheck a [] = []\n\ncheck a (x:xs) = let b = goo a (x:xs)\n\n                     in foo b\n\n\n','Не удалось вычислить выражение \"check ( x->x>5) [3,2,7,4]\", проверьте правильность синтаксиса'),(4986,28,'anna','2013-09-15 12:54:33',1,'--main = putStrLn \"hello, world\" \r\n\r\ngoo a(x:xs) = map a (x:xs)\r\n  --- Да можно было и просто в check вызвать map, goo особо и не нужна \r\n\r\nfoo [True] = True\r\n\r\nfoo [False] = False\r\n\r\nfoo (x:y:xs) = if x==True then foo(x:xs) else foo(y:xs)  \r\n\r\ncheck a [] = False\r\n\r\ncheck a (x:xs) = let b = goo a (x:xs)\r\n\r\n                     in foo b\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4987,30,'8519021','2013-09-15 13:34:53',1,'parts (x:xs) = parts\' x xs 2\r\n\r\nparts\' x (y:ys) l \r\n\r\n  | parts\'\' x (y:ys) (l - 1) l = True\r\n\r\n  | x < y = parts\' y ys (l + 1) \r\n\r\n  | otherwise = False\r\n\r\nparts\'\' _ [] l lMax \r\n\r\n  | l == lMax = True\r\n\r\n  | otherwise = False\r\n\r\nparts\'\' x (y:ys) l lMax\r\n\r\n  | l == lMax = parts\'\' y ys 1 lMax\r\n\r\n  | x < y = parts\'\' y ys (l + 1) lMax\r\n\r\n  | otherwise = False\r\n','<br/>Тесты успешно пройдены!'),(4984,33,'8519021','2013-09-15 12:52:00',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\n\r\n\r\nnamespace Integral\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static double Zk(double a, double h, int k)\r\n\r\n        {\r\n\r\n            return (a + k * h);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Для вычисления интеграла воспользуемся составной квадратурной формулой средних прямоугольников:\r\n\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n\r\n        {\r\n\r\n            double h = (b - a) / 100;\r\n\r\n            double Smid = 0;\r\n\r\n            for (int k = 1; k <= 100; k++)\r\n\r\n            {\r\n\r\n                Smid += h * f((Zk(a, h, k - 1) + Zk(a, h, k)) / 2);\r\n\r\n            }\r\n\r\n            return Smid;\r\n\r\n        }\r\n\r\n\r\n\r\n        static double Cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            double result = Integral(x => x * x, 0, 1);\r\n\r\n            Console.WriteLine(result);\r\n\r\n            Console.WriteLine(\"{0}\", Integral(Cube, 0, 1));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4983,28,'anna','2013-09-15 12:50:54',0,'--main = putStrLn \"hello, world\" \n\ngoo a(x:xs) = map a (x:xs)\n\nfoo [True] = True\n\nfoo [False] = False\n\nfoo (x:y:xs) = if x==True then foo(x:xs) else foo(y:xs)  \n\ncheck a (x:xs) = let b = goo a (x:xs)\n\n                     in foo b\n\n\n','Не удалось вычислить выражение \"check (x->x>5) []\", проверьте правильность синтаксиса'),(4979,26,'284427','2013-09-15 10:57:12',1,'rev xs = r xs []\r\n\r\nr (x:xs) ys = r xs (x:ys)\r\n\r\nr [] ys = ys\r\n','<br/>Тесты успешно пройдены!'),(4980,28,'284427','2013-09-15 11:01:26',1,'check cond (x:xs) = if cond x \r\n\r\n					then True\r\n\r\n					else check cond xs\r\n\r\ncheck cond [] = False\r\n','<br/>Тесты успешно пройдены!'),(4981,29,'284427','2013-09-15 11:06:19',1,'check cond (x:xs) = if cond x \r\n\r\n					then True\r\n\r\n					else check cond xs\r\n\r\ncheck cond [] = False\r\n\r\n\r\n\r\ncheckDifferent (x:xs) = if check (y->y==x) xs\r\n\r\n						then False\r\n\r\n						else checkDifferent xs\r\n\r\ncheckDifferent [] = True\r\n','<br/>Тесты успешно пройдены!'),(4982,33,'romos2007','2013-09-15 12:18:53',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\n\r\n\r\n/* Задача 5-1\r\n\r\n * Одеров Роман, 545 гр.\r\n\r\n *\r\n\r\n * Программа написана однажды для занятий по Методам Вычислений.\r\n\r\n * Передалано лишь одно: в существующие методы интегрирования\r\n\r\n * добавлена \"функциональная суть\", а именно функции-параметры.\r\n\r\n */\r\n\r\n\r\n\r\n\r\n\r\nnamespace FuncIntegral\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        private static double SmMiddleRectan(Func<double,double> func, double a, double b, int m)\r\n\r\n        {\r\n\r\n            double h = (b - a) / m;\r\n\r\n            List<double> z = new List<double>();\r\n\r\n            double result = 0;\r\n\r\n            for (int i = 0; i <= m; i++)\r\n\r\n            {\r\n\r\n                z.Add(a + i * h);\r\n\r\n            }\r\n\r\n            for (int i = 1; i <= m; i++)\r\n\r\n            {\r\n\r\n                result += func((z[i - 1] + z[i]) / 2);\r\n\r\n            }\r\n\r\n            return result * h;\r\n\r\n        }\r\n\r\n        private static double SmTrapezium(Func<double, double> func, double a, double b, int m)\r\n\r\n        {\r\n\r\n            double h = (b - a) / m;\r\n\r\n            List<double> z = new List<double>();\r\n\r\n            double result1 = 0, result2 = 0;\r\n\r\n            for (int i = 0; i <= m; i++)\r\n\r\n            {\r\n\r\n                z.Add(a + i * h);\r\n\r\n            }\r\n\r\n            //1\r\n\r\n            for (int i = 1; i <= m; i++)\r\n\r\n            {\r\n\r\n                result1 += (func(z[i]) + func(z[i - 1]));\r\n\r\n            }\r\n\r\n            //2\r\n\r\n            for (int i = 1; i <= m - 1; i++)\r\n\r\n            {\r\n\r\n                result2 += func(z[i]);\r\n\r\n            }\r\n\r\n            //return result1 * h / 2; //way 1\r\n\r\n            return h * result2 + (func(a) + func(b)) * h / 2; // way 2\r\n\r\n        }\r\n\r\n        private static double SmSimpson(Func<double, double> func, double a, double b, int m)\r\n\r\n        {\r\n\r\n            double h = (b - a) / m;\r\n\r\n            List<double> z = new List<double>();\r\n\r\n            double result = 0;\r\n\r\n            for (int i = 0; i <= m; i++)\r\n\r\n            {\r\n\r\n                z.Add(a + i * h);\r\n\r\n            }\r\n\r\n            for (int i = 1; i <= m; i++)\r\n\r\n            {\r\n\r\n                result += (func(z[i - 1]) + 4 * func((z[i - 1] + z[i]) / 2) + func(z[i]));\r\n\r\n            }\r\n\r\n            return result * h / 6;\r\n\r\n        }\r\n\r\n\r\n\r\n        private static double Cube(double i)\r\n\r\n        {\r\n\r\n            return i * i * i;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main(string[] args)\r\n\r\n        {\r\n\r\n            double a, b;\r\n\r\n            int m;\r\n\r\n            a = 0; b = 1; m = 100;\r\n\r\n            string sa,sb,sm;\r\n\r\n\r\n\r\n            Func<double, double> f1 = i => i * i;\r\n\r\n            Func<double, double> f2 = i => Math.Sin(i);\r\n\r\n            Func<double, double> f3 = i => 1;\r\n\r\n\r\n\r\n            while (true)\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Для выхода нажмите ENTER в любом из пунктов далее:\");\r\n\r\n                Console.WriteLine();\r\n\r\n                \r\n\r\n                Console.Write(\"Введите левую границу промежутка интегрирования:	\");\r\n\r\n                sa = Console.ReadLine();\r\n\r\n                if (sa == \"\"){ break; }\r\n\r\n                a = Convert.ToDouble(sa);\r\n\r\n\r\n\r\n                Console.Write(\"Введите правую границу промежутка интегрирования:	\");\r\n\r\n                sb = Console.ReadLine();\r\n\r\n                if (sb == \"\") { break; }\r\n\r\n                b = Convert.ToDouble(sb);\r\n\r\n                \r\n\r\n                Console.Write(\"На сколько частей разбить отрезок интегрирования:	\");\r\n\r\n                sm = Console.ReadLine();\r\n\r\n                if (sm == \"\") { break; }\r\n\r\n                m = Convert.ToInt32(sm);\r\n\r\n                \r\n\r\n                Console.WriteLine();\r\n\r\n                Console.WriteLine(\"integral( x * x , {0}, {1},{2})\", a, b, m);\r\n\r\n                Console.WriteLine(\"Метод прямоугольников:	\" + SmMiddleRectan(f1, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод трапеций:		\" + SmTrapezium(f1, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод Симпсона:		\" + SmSimpson(f1, a, b, m));\r\n\r\n                Console.WriteLine();\r\n\r\n                Console.WriteLine(\"integral( x * x * x , {0}, {1},{2})\", a, b, m);\r\n\r\n                Console.WriteLine(\"Метод прямоугольников:	\" + SmMiddleRectan(Cube, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод трапеций:		\" + SmTrapezium(Cube, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод Симпсона:		\" + SmSimpson(Cube, a, b, m));\r\n\r\n                Console.WriteLine();\r\n\r\n                Console.WriteLine(\"integral( sin(x) , {0}, {1},{2})\", a, b, m);\r\n\r\n                Console.WriteLine(\"Метод прямоугольников:	\" + SmMiddleRectan(f2, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод трапеций:		\" + SmTrapezium(f2, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод Симпсона:		\" + SmSimpson(f2, a, b, m));\r\n\r\n                Console.WriteLine();\r\n\r\n                Console.WriteLine(\"integral( 1 , {0}, {1},{2})\", a, b, m);\r\n\r\n                Console.WriteLine(\"Метод прямоугольников:	\" + SmMiddleRectan(f3, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод трапеций:		\" + SmTrapezium(f3, a, b, m));\r\n\r\n                Console.WriteLine(\"Метод Симпсона:		\" + SmSimpson(f3, a, b, m));\r\n\r\n                Console.WriteLine();\r\n\r\n\r\n\r\n\r\n\r\n                Console.WriteLine(\"==============\");\r\n\r\n                Console.WriteLine();\r\n\r\n            }\r\n\r\n            Console.WriteLine(\"\r\n\r\nЗавершение работы...\r\n\");\r\n\r\n            System.Threading.Thread.Sleep(1000);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4978,27,'284427','2013-09-15 10:53:34',1,'minsum (x:y:xs) = ms (y:xs) (x+y)\r\n\r\nms (x:y:xs) m = let p = (x+y) in\r\n\r\n				if (p > m)\r\n\r\n				then ms (y:xs) m\r\n\r\n				else ms (y:xs) p\r\n\r\nms [x] m = m\r\n\r\nms [] m = m\r\n','<br/>Тесты успешно пройдены!'),(4977,25,'284427','2013-09-15 10:46:09',1,'minlist (x:xs) = ml1 xs x\r\n\r\nml1 (x:xs) m = if m < x \r\n\r\n               then ml1 xs m\r\n\r\n			   else ml1 xs x\r\n\r\nml1 [] m = m\r\n','<br/>Тесты успешно пройдены!'),(4976,25,'284427','2013-09-15 10:44:23',0,'minlist (x:xs) = ml1 xs m\r\n\nml1 (x:xs) m = if m > x \r\n\n               then ml1 xs m\r\n\n			   else ml1 xs x\r\n\nml1 [] m = m\n','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(4974,29,'SNNatalieS','2013-09-15 03:23:31',1,'import Data.List\r\nf [c] = True\r\nf (x:s:xs) = if (x == s) \r\n		then False\r\n		else f (s:xs)\r\ncheckDifferent [] = True\r\ncheckDifferent  [b] = True\r\ncheckDifferent  xs = f g where g = sort xs','<br/>Тесты успешно пройдены!'),(4975,25,'284427','2013-09-15 10:43:33',0,'minlist (x:xs) = ml1 xs m\r\n\nml1 (x:xs) m = if m > x ml1 xs m\r\n\n			   else ml1 xs x\r\n\nml1 [] m = m\n','Не удалось вычислить выражение \"minlist [3,2,7]\", проверьте правильность синтаксиса'),(4973,33,'55363692','2013-09-15 02:13:47',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace FunctionalProgramming\r\n\r\n{\r\n\r\n    class Program\r\n\r\n    {\r\n\r\n        static double Integral(Func<double, double> f, double a, double b)\r\n\r\n        {\r\n\r\n            double sum = 0;\r\n\r\n            const int n = 1000;\r\n\r\n            double step = (b - a)/n;\r\n\r\n\r\n\r\n            for (int i = 0; i < n; ++i)\r\n\r\n            {\r\n\r\n                double val = f(a + i*step);\r\n\r\n                sum += val*step;\r\n\r\n            }\r\n\r\n            return sum;\r\n\r\n        }\r\n\r\n\r\n\r\n        static void Main()\r\n\r\n        {\r\n\r\n            Console.WriteLine(Integral(x => 1, 0, 1));\r\n\r\n            Console.WriteLine(Integral(x => x, 0, 1));\r\n\r\n            Console.WriteLine(Integral(Math.Sin, 0, 2 * Math.PI));\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4972,28,'SNNatalieS','2013-09-15 02:02:48',1,'g [] b = b\r\ng (x:xs) b = g xs (b || x)\r\ncheck v xs = g m False\r\n		where m = map v xs','<br/>Тесты успешно пройдены!'),(4971,27,'SNNatalieS','2013-09-15 01:37:53',1,'minsum [] = 0\r\nminsum [n] = n\r\nminsum (x:y:xs) = mins (y:xs) (x + y)\r\nmins [] c = c\r\nmins [b] c = c\r\nmins (x:y:xs) c = if x + y < c\r\n			then mins (y:xs) (x + y)\r\n			else mins (y:xs) c','<br/>Тесты успешно пройдены!'),(4970,28,'2501950','2013-09-15 00:41:53',1,'check cond xs = check\' cond xs False\r\ncheck\' cond [] tf = tf\r\ncheck\' cond (x:xs) tf = if (cond x)\r\n                        then check\' cond [] True\r\n   --- Или проще then True\r\n                        else check\' cond xs False  ','<br/>Тесты успешно пройдены!'),(4969,27,'2501950','2013-09-15 00:11:53',1,'minsum (x:xs) = minsum\' (x:xs) (x+head xs)\r\nminsum\' [x] k = k\r\nminsum\' (x:xs) k = if ((x+head xs) < k)\r\n                   then minsum\' xs (x+head xs)\r\n                   else minsum\' xs k    ','<br/>Тесты успешно пройдены!'),(4967,29,'517309','2013-09-14 22:54:30',2,'checkDifferent :: (Eq a) => [a] -> Bool\r\n\r\n\r\n\r\ncheckDifferent = fst . (foldl checker (True,[]))\r\n\r\n\r\n\r\n    where\r\n\r\n\r\n\r\n	    checker (result,looked) x =\r\n\r\n\r\n\r\n		    if not result\r\n\r\n\r\n\r\n			then (False,undefined)\r\n\r\n\r\n\r\n			else (not $ x `elem` looked,x:looked)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4968,26,'SNNatalieS','2013-09-14 23:13:13',1,'rev [] = []\r\nrev (x:xs) = (rev xs) ++[x]','<br/>Тесты успешно пройдены!'),(4966,30,'toskira','2013-09-14 22:53:51',1,'parts l = let (h:t) = f l 1\r\n          in 1 /= (gcd_l t h)\r\n\r\ngcd_l [] s = s\r\ngcd_l (h:t) s = gcd_l t (gcd h s)\r\n\r\nf (_:[])    s = [s]\r\nf (h0:h1:t) s = if h0 >= h1\r\n                then s:(f (h1:t) 1)\r\n                else f (h1:t) (s + 1)','<br/>Тесты успешно пройдены!'),(4964,26,'2501950','2013-09-14 22:47:34',1,'rev xs = rev\' [] xs\r\nrev\' xs [] = xs\r\nrev\' xs1 (x:xs2) = rev\' (x:xs1) xs2 ','<br/>Тесты успешно пройдены!'),(4965,29,'517309','2013-09-14 22:51:55',2,'checkDifferent :: (Eq a) => [a] -> Bool\r\n\r\ncheckDifferent = fst . (foldl checker (True,[]))\r\n\r\n    where\r\n\r\n	    checker (result,looked) x =\r\n\r\n		    if not result\r\n\r\n			then (False,undefined)\r\n\r\n			else (not $ x `elem` looked,x:looked)\r\n','<br/>Тесты успешно пройдены!'),(4963,31,'55363692','2013-09-14 22:47:13',1,'import Data.Maybe\r\n\r\nimport qualified Data.Map as Map\r\n\r\nimport Debug.Trace\r\n\r\n\r\n\r\nparts2 [] = False\r\n\r\nparts2 (x:xs) = find 1 0 x Nothing \r\n\r\n	where\r\n\r\n		cache :: Map.Map (Int, Int, Int, Maybe Int) Bool\r\n\r\n		cache = Map.empty\r\n\r\n		\r\n\r\n		len = 1 + length xs\r\n\r\n		\r\n\r\n		find len1 len2 cur1 cur2 =  \r\n\r\n			let res = Map.lookup (len1, len2, cur1, cur2) cache in \r\n\r\n			if isNothing res \r\n\r\n			then \r\n\r\n				fromJust $ \r\n\r\n				Map.lookup (len1, len2, cur1, cur2) $ \r\n\r\n				Map.insert (len1, len2, cur1, cur2) (parts2\' len1 len2 cur1 cur2 (drop (len1 + len2) (x:xs))) $ cache\r\n\r\n			else \r\n\r\n				fromJust res\r\n\r\n				   		   \r\n\r\n		parts2\' len1 len2 _ _ [] = len1 == len2\r\n\r\n		parts2\' len1 len2 x y (z:zs) = \r\n\r\n			if (2 * len1 > len) || (2 * len2 > len) \r\n\r\n			then \r\n\r\n				False \r\n\r\n			else if x < z && find (len1 + 1) len2 z y \r\n\r\n				then \r\n\r\n					True \r\n\r\n				else \r\n\r\n					(isNothing y || (fromJust y) < z) && find len1 (len2 + 1) x (Just z)		   \r\n','<br/>Тесты успешно пройдены!'),(4962,25,'SNNatalieS','2013-09-14 22:34:25',1,'minlist [] = 0\r\nminlist (x:xs) = minlist\' xs x\r\nminlist\' [] n = n\r\nminlist\' (x:xs) n = if x > n \r\n			then minlist\' xs n\r\n			else minlist\' xs x','<br/>Тесты успешно пройдены!'),(4960,28,'toskira','2013-09-14 22:13:18',1,'check c [] = False\r\ncheck c (h:t) = (c h) || check c t','<br/>Тесты успешно пройдены!'),(4961,29,'toskira','2013-09-14 22:17:49',1,'checkDifferent (h:[]) = True\r\ncheckDifferent (h:t)  = (f h t) && checkDifferent t\r\n\r\nf e [] = True\r\nf e (h:t) = (e /= h) && (f e t)','<br/>Тесты успешно пройдены!'),(4956,23,'toskira','2013-09-14 21:50:51',1,'c n = f\' n n 1\r\n\r\nf\' 0 0 _ = 1\r\nf\' _ 0 _ = 0\r\nf\' n k tmp = let k\' = k - 1\r\n             in if (1 == gcd tmp k)\r\n                then f\' (n - k) k\' (tmp * k) + f\' n k\' tmp\r\n                else f\' n k\' tmp \r\n','<br/>Тесты успешно пройдены!'),(4957,25,'toskira','2013-09-14 21:55:43',1,'minlist (h:t) = f t h\r\n\r\nf []  m = m\r\nf (h:t) m = f t (min h m)','<br/>Тесты успешно пройдены!'),(4958,27,'toskira','2013-09-14 21:59:56',1,'minsum (h0:h1:t) = f (h1:t) (h0 + h1)\r\n                                                                                                 \r\nf (h:[])    m = m                                                                                \r\nf (h0:h1:t) m = f (h1:t) (min m (h0 + h1))  ','<br/>Тесты успешно пройдены!'),(4959,26,'toskira','2013-09-14 22:09:43',1,'rev l = f l []                                                                                   \r\n\r\nf []    l = l\r\nf (h:t) l = f t (h:l)','<br/>Тесты успешно пройдены!'),(4954,29,'1048693','2013-09-14 21:46:49',0,'checkDifferent = fst . (foldl ((result,looked) x -> if not result then (False,undefined) else (not $ x `elem` looked,x:looked)) (True,[]))\n','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(4955,29,'1048693','2013-09-14 21:50:45',1,'checkDifferent :: (Eq a) => [a] -> Bool\r\n\r\ncheckDifferent = fst . (foldl checker (True,[]))\r\n\r\n    where\r\n\r\n	    checker (result,looked) x =\r\n\r\n		    if not result\r\n\r\n			then (False,undefined)\r\n\r\n			else (not $ x `elem` looked,x:looked)\r\n','Выражение имеет неправильное значение: checkDifferent [3,2,7]'),(4953,23,'1545234','2013-09-14 21:45:18',1,'c n = nsq 0 1 0 n []\r\n\r\nnsq ans i sum n xs = if ((sum == n) && (simpl xs)) then ans+1\r\n                       else if ((i> n) || (sum > n)) then ans\r\n                            else nsq (nsq ans (i+1) sum n xs) (i+1) (sum+i) n (i:xs) \r\n\r\n\r\nsimpl [] = True\r\nsimpl (x:[]) = True\r\nsimpl (x:xs) = if (any (y-> not (is x y)) xs) then False\r\n                  else simpl xs\r\n\r\n\r\nis :: Int -> Int -> Bool\r\nis _ 1 = True\r\nis _ 0 = False\r\nis n k = if (n < k) then is k n\r\n          else\r\n             if (div n k /= 0) then (is k (mod n k))\r\n              else False','<br/>Тесты успешно пройдены!'),(4952,23,'1545234','2013-09-14 21:44:49',0,'nseq n = nsq 0 1 0 n []\r\n\r\nnsq ans i sum n xs = if ((sum == n) && (simpl xs)) then ans+1\r\n                       else if ((i> n) || (sum > n)) then ans\r\n                            else nsq (nsq ans (i+1) sum n xs) (i+1) (sum+i) n (i:xs) \r\n\r\n\r\nsimpl [] = True\r\nsimpl (x:[]) = True\r\nsimpl (x:xs) = if (any (y-> not (is x y)) xs) then False\r\n                  else simpl xs\r\n\r\n\r\nis :: Int -> Int -> Bool\r\nis _ 1 = True\r\nis _ 0 = False\r\nis n k = if (n < k) then is k n\r\n          else\r\n             if (div n k /= 0) then (is k (mod n k))\r\n              else False','Не удалось вычислить выражение \"c 10\", проверьте правильность синтаксиса'),(4951,29,'1048693','2013-09-14 21:42:37',0,'checkDifferent = fst . (foldl ((result,looked) x -> if not result then (False,undefined) else (not $ x `elem` looked,x:looked)) (True,[]))','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(4950,29,'1048693','2013-09-14 21:39:25',0,'checkDifferent = fst . (foldl ((result,looked) x -> if not result then (False,undefined) else (not $ x `elem` looked,x:looked)) (True,[]))','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса'),(4947,27,'1048693','2013-09-14 21:23:20',1,'minsum xs@(x:xt) = minimum $ zipWith (+) xs xt','<br/>Тесты успешно пройдены!'),(4948,26,'1048693','2013-09-14 21:26:02',1,'rev = foldl (flip (:)) []','<br/>Тесты успешно пройдены!'),(4949,28,'1048693','2013-09-14 21:30:56',1,'check cond = foldl (acc x -> acc || cond x) False','<br/>Тесты успешно пройдены!'),(4946,25,'1048693','2013-09-14 21:18:44',1,'minlist (x:xs) = foldl (min curr -> if min > curr then curr else min) x xs\r\n   --- Или можно foldl min','<br/>Тесты успешно пройдены!'),(4945,29,'1545234','2013-09-14 21:16:56',1,'checkDifferent [] = True\r\ncheckDifferent (x:[]) = True\r\ncheckDifferent (x:xs) = if (any (y->y==x) xs) then False\r\n                         else checkDifferent xs\r\n\r\n','<br/>Тесты успешно пройдены!'),(4940,25,'1545234','2013-09-14 20:40:00',1,'minlist :: [Int] -> Int\r\nminlist [] = 0\r\nminlist (x:xs) = ml xs x\r\n\r\nml :: [Int]->Int->Int\r\nml [] x = x\r\nml (x:xs) a = if (x < a) then ml xs x\r\n                else ml xs a','<br/>Тесты успешно пройдены!'),(4941,27,'1545234','2013-09-14 20:47:59',1,'minsum :: [Int] -> Int\r\nminsum [] = 0\r\nminsum (x:[]) = x\r\nminsum (x:y:[]) = x+y\r\nminsum (x:y:xs) = ms (y:xs) (x+y)\r\n\r\nms :: [Int]-> Int -> Int\r\nms [] a = a\r\nms (x:[]) a = a\r\nms (x:y:xs) a = if (x+y < a) then (ms (y:xs) (x+y))\r\n                 else (ms (y:xs) a)','<br/>Тесты успешно пройдены!'),(4942,26,'1545234','2013-09-14 21:00:06',1,'rev [] = []\r\nrev (x:xs) = (rev xs) ++ [x]','<br/>Тесты успешно пройдены!'),(4943,26,'anna','2013-09-14 21:12:23',1,'rev:: [a] -> [a]\r\n\r\nrev [] = []\r\n\r\nrev (x:xs) = rev xs ++ [x]\r\n','<br/>Тесты успешно пройдены!'),(4944,25,'anna','2013-09-14 21:15:23',1,'minlist :: [Int]->Int\r\n\r\nminlist[x]=x\r\n\r\nminlist(x:y:xs) = if x < y then minlist(x:xs) else minlist(y:xs)\r\n','<br/>Тесты успешно пройдены!'),(4937,29,'12828920','2013-09-14 19:17:01',1,'check cond [] = False\r\n\r\ncheck cond [x] = cond x\r\n\r\ncheck cond (x:xs) = if (res)\r\n\r\n					then res\r\n\r\n					else check cond xs\r\n\r\n					where res = cond x\r\n\r\n\r\n\r\ncheckDifferent [] = True\r\n\r\ncheckDifferent [x] = True\r\n\r\ncheckDifferent (x:xs) = if (check (i->i==x) xs)\r\n\r\n						then False\r\n\r\n						else checkDifferent xs\r\n','<br/>Тесты успешно пройдены!'),(4938,22,'1545234','2013-09-14 20:02:59',1,'g :: Integer -> Bool\r\ng n = g\' (n-2) 2\r\n\r\ng\' k i = if (i >= k) then False\r\n                else if ((isSimple k) && (isSimple i)) then True\r\n                       else (g\' (k-1) (i+1)) \r\n\r\nisSimple n = if (n <=1) then False\r\n              else iS n 2\r\n\r\niS n k = if (n <= k) then True\r\n           else if (mod n k == 0) then False\r\n                 else (iS n (k+1))','<br/>Тесты успешно пройдены!'),(4939,28,'1545234','2013-09-14 20:20:20',1,'check :: (Integer->Bool)->[Integer]->Bool\r\ncheck _ [] = False\r\ncheck cond (x:xs) = if (cond x) then True\r\n                   else (check cond xs)\r\n   --- Тут, на самом деле, все скобки не нужны.','<br/>Тесты успешно пройдены!'),(4935,28,'12828920','2013-09-14 18:54:40',0,'check cond [x] = cond x\r\n\ncheck cond (x:xs) = if (res)\r\n\n					then res\r\n\n					else check cond xs\r\n\n					where res = cond x\n','Не удалось вычислить выражение \"check (x->x>5) []\", проверьте правильность синтаксиса'),(4936,28,'12828920','2013-09-14 18:57:00',1,'check cond [] = False\r\n\r\ncheck cond [x] = cond x\r\n   --- Это правило на самом не нужно, и без него будет работать (оно следует из двух остальных) \r\ncheck cond (x:xs) = if (res)\r\n\r\n					then res\r\n\r\n					else check cond xs\r\n\r\n					where res = cond x\r\n','<br/>Тесты успешно пройдены!'),(4932,27,'anna','2013-09-14 18:04:53',1,'listsum ::[Int]->[Int]\r\n\r\nlistsum [] = []\r\n\r\nlistsum [x] = []\r\n\r\nlistsum (x:y:xs) = (x+y) : (listsum(y:xs))\r\n\r\n\r\n\r\nb [x] = x\r\n\r\nb (x:y:xs) = if x < y then b (x:xs) else b (y:xs)\r\n    ---- Или вместо b можно было использовать minlist или стандартную функцию minimum\r\n\r\n\r\nminsum [x,y] = x+y;\r\n\r\nminsum (x:xs) = let a = listsum (x:xs)      \r\n\r\n                    in  b a\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4933,27,'12828920','2013-09-14 18:06:03',1,'minsum [] = 0\r\n\r\nminsum [x, y] = x + y\r\n\r\nminsum (x:xs) = b (x + head xs) x xs\r\n\r\nb s x [] = s\r\n\r\nb s x xs = if (s1 < s)\r\n\r\n			then b (s1) (head xs) (tail xs)\r\n\r\n			else b s (head xs) (tail xs)\r\n\r\n			where s1 = x + head xs\r\n','<br/>Тесты успешно пройдены!'),(4934,26,'12828920','2013-09-14 18:32:40',1,'rev [] = []\r\n\r\nrev [x] = [x]\r\n\r\nrev [x, y] = [y, x]\r\n\r\nrev (x:xs) = [last xs] ++ rev (init xs) ++ [x]\r\n   --- Или можно короче rev (x:xs) = rev xs ++ [x]\r\n ','<br/>Тесты успешно пройдены!'),(4923,26,'nbumakov','2013-09-14 14:18:15',1,'rev list = rev2 list []\r\nrev2 [] revlist = revlist\r\nrev2 list revlist = rev2 (tail list) (head list : revlist)','<br/>Тесты успешно пройдены!'),(4924,28,'nbumakov','2013-09-14 14:47:28',1,'check cond [] = False\r\ncheck cond (x:xs) = cond x || check cond xs','<br/>Тесты успешно пройдены!'),(4925,29,'nbumakov','2013-09-14 14:54:12',1,'checkDifferent [] = True\r\ncheckDifferent (x:xs) = not (any ( y -> y == x) xs) && checkDifferent xs','<br/>Тесты успешно пройдены!'),(4926,26,'8519021','2013-09-14 14:58:21',1,'rev xs = rev\' xs []\r\n\r\nrev\' [] ys = ys\r\n\r\nrev\' (x:xs) ys = rev\' xs (x:ys)\r\n','<br/>Тесты успешно пройдены!'),(4927,22,'nbumakov','2013-09-14 15:39:23',0,'isPrime k = null [ x | x <- [2..k - 1], k `mod` x  == 0]\r\n\r\ng k = any ( y -> (y /= k-y) && isPrime (k-y) && isPrime y) [2..k-2]','<br/>Тесты успешно пройдены!'),(4928,22,'nbumakov','2013-09-14 15:50:10',1,'isPrime k = null [ x | x <- [2..round (sqrt (fromIntegral k))], k `mod` x  == 0]\r\n\r\ng k = any ( y -> (y /= k-y) && isPrime (k-y) && isPrime y) [2..k-2]\r\n   --- Ну тут, конечно же, можно было проверять до k `div` 2','<br/>Тесты успешно пройдены!'),(4929,28,'8519021','2013-09-14 15:53:05',1,'check cond [] = False\r\n\r\ncheck cond (x:xs)\r\n\r\n  | cond x = True\r\n\r\n  | otherwise = check cond xs\r\n','<br/>Тесты успешно пройдены!'),(4930,29,'8519021','2013-09-14 16:05:02',1,'checkDifferent [] = True\r\n\r\ncheckDifferent (x:xs)\r\n\r\n  | elem x xs = False\r\n\r\n  | otherwise = checkDifferent xs\r\n','<br/>Тесты успешно пройдены!'),(4931,25,'12828920','2013-09-14 17:49:11',1,'b x [] = x\r\n\r\nb x xs = if (x < head xs)\r\n\r\n		then b x (tail xs)\r\n\r\n		else b (head xs) (tail xs)\r\n\r\nminlist [] = 0\r\n\r\nminlist (x:xs) = b x xs\r\n','<br/>Тесты успешно пройдены!'),(4921,25,'nbumakov','2013-09-14 14:16:43',1,'minlist (x:xs) = minlist2 xs x\r\nminlist2 [] min = min\r\nminlist2 (x:xs) min = minlist2 xs (if x < min then x else min) ','<br/>Тесты успешно пройдены!'),(4922,27,'nbumakov','2013-09-14 14:17:33',1,'minsum (x:y:xs) = minsum2 y xs (x + y)\r\nminsum2 y [] min = min\r\nminsum2 y (x:xs) min = minsum2 x xs (if y+x < min then y+x else min)','<br/>Тесты успешно пройдены!'),(4920,29,'1595828','2013-09-14 14:10:55',1,'checkDifferent [] = True\r\n\r\ncheckDifferent (x:xs)\r\n\r\n  | check_in x xs = False\r\n\r\n  | otherwise = checkDifferent xs\r\n\r\ncheck_in y [] = False\r\n\r\ncheck_in y (x:xs) \r\n\r\n |y == x = True\r\n\r\n |otherwise = check_in y xs\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(4917,27,'8519021','2013-09-14 13:20:40',0,'minsum xs = minimum (zipWith (+) xs ((tail xs)++[0]))\n','Выражение имеет неправильное значение: minsum [5,4,3]'),(4918,27,'8519021','2013-09-14 13:36:30',1,'minsum xs = minimum (tail (zipWith (+) xs (0:(xs))))\r\n   --- Или я бы написал minimum (zipWith (+) (tail xs) xs))\r\n   --- Но вообще очень хорошее решение, замечательно!','<br/>Тесты успешно пройдены!'),(4919,28,'1595828','2013-09-14 13:57:58',1,'check cond (x:xs)\r\n\r\n  | cond x = True\r\n\r\n  | otherwise = check cond xs\r\n\r\ncheck cond [] = False\r\n','<br/>Тесты успешно пройдены!'),(4915,28,'3270666','2013-09-14 12:51:40',1,'check cond [] = False\r\ncheck cond (x:xs) = if (cond x == True)\r\n  --- Или просто if cond x\r\n	then True\r\n	else check cond xs','<br/>Тесты успешно пройдены!'),(4916,29,'3270666','2013-09-14 13:06:56',1,'checkDifferent (x:xs) = cd xs (x:xs)\r\ncd [] [_] = True\r\ncd [] (y:y1:ys) = cd ys (y1:ys)\r\ncd (x:xs) (y:ys) = if (x == y)\r\n	then False\r\n	else cd xs (y:ys)','<br/>Тесты успешно пройдены!'),(4914,26,'3270666','2013-09-14 12:47:19',1,'rev xs = rev\' xs []\r\nrev\' [] ys = ys\r\nrev\' (x:xs) ys = rev\' xs (x:ys)','<br/>Тесты успешно пройдены!'),(4906,25,'1595828','2013-09-14 11:36:10',1,'minlist (x:xs) = minlist\' xs x\r\n\r\nminlist\' [] m = m \r\n\r\nminlist\' (x:xs) m \r\n\r\n	| m>x =minlist\' xs x\r\n\r\n	|otherwise =minlist\' xs m\r\n','<br/>Тесты успешно пройдены!'),(4907,25,'8519021','2013-09-14 12:01:05',1,'minlist (x:xs) = minlist\' xs x\r\n\r\nminlist\' [] minX = minX\r\n\r\nminlist\' (x:xs) minX\r\n\r\n  | x < minX = minlist\' xs x\r\n\r\n  | otherwise = minlist\' xs minX\r\n','<br/>Тесты успешно пройдены!'),(4905,30,'deripaska','2013-09-14 03:47:27',1,' --- ОК, очень хорошо, засчитано! Но, кстати, есть более эффективное решение, которое\r\n --- просматривает список только один раз, и довольно простое. Если вдруг придумаете,\r\n --- пришлите, пожалуйста, интересно будет посмотреть (но это совсем, совсем не обязательно).\r\n{--\r\n\r\n    task 04-01\r\n\r\n*Доп.задача*\r\n\r\nНаписать функцию parts, которая для данного списка проверяет, можно ли его разбить \r\n\r\nна несколько строго возрастающих кусков одинаковой длины. \r\n\r\n\r\n\r\nДлина кусков должна быть не меньше 2. Кусок может быть и только один.\r\n\r\n\r\n\r\nПримеры вызова:\r\n\r\nparts [1, 2, 8, 2, 5, 6]\r\n\r\nparts [1, 2, 3, 4, 5]\r\n\r\nparts [1, 2, 1, 2, 3, 4]\r\n\r\nВо всех этих случаях ответ должен быть равен True.\r\n\r\nparts [4, 6, 3, 5, 7]\r\n\r\nТут ответ должен быть равен False.\r\n\r\n--}\r\n\r\n\r\n\r\n{--\r\n\r\nПомним, что длина искомых кусков должна быть не меньше 2, поэтому вызываем основную функцию проверки именно с 2.\r\n\r\n--}\r\n\r\nparts xs = parts1 xs 2\r\n\r\n\r\n\r\n{--\r\n\r\nСначала, наверное,будет проще написать эту функцию (по аналогии с одной из предыдущих задач).\r\n\r\nФункция \'partsByLenght\' проверяет, можно разбить список на искомые куски, длина которых точно равно neededLenght;\r\n\r\n\'currentLenght\' --- это значение текущей длины искомого куска в списке, т.е. это длина последнего на данный момент найднного искомого куска в списке;\r\n\r\nОчевидно, что чтобы можно было бы разбить по условию задачи, то искомый кусок должен в т.ч. в самом начале. Поэтому по нему сначала проверяем, и если всё хорошо, то вызываем тот же алгоритм от хвоста. \r\n\r\nИтак, когда мы нашли один кусок нужной длины, надо проверить на искомое условие и хвост списка (поэтому-то и надо вызвать рекурсвино себя, если текущая длина = нужной длине);\r\n\r\nКогда еще не нашли искомый кусок, т.е. если же кусок в списке еще является возрастающим, то снова надо рекурсивно вызвать себя от хвоста, но с соответствующим увеличением текущей длины.\r\n\r\nНу а если кусок уже не возрастает, но еще не успел стать нужной длины, то значит нельзя разбить на искомые.\r\n\r\nПри этом, в самом конце обхода при успешном разбиении (да и не только) у нас останется один элемент (ведь в самом алгоритме мы уже проверяли \"голову\" от хвоста). и тут уже можно выдать ответ.\r\n\r\n--}\r\n\r\npartsByLenght [_] currentLenght neededLenght\r\n\r\n  | currentLenght == neededLenght = True\r\n\r\n  | otherwise = False\r\n\r\npartsByLenght (x:xs) currentLenght neededLenght\r\n\r\n  | currentLenght == neededLenght = partsByLenght xs 1 neededLenght\r\n\r\n  | head(xs) > x = partsByLenght xs (currentLenght + 1) neededLenght\r\n\r\n  | otherwise = False\r\n\r\n\r\n\r\n{--\r\n\r\nФункция \'partsByLenght\' проверяет, можно разбить список на искомые куски, длина которых более или равна neededLenght;\r\n\r\nПри этом, сначала проверяется можно ли разбить список на куски длиной, равной neededLenght (\'partsByLenght\'). \r\n\r\nИ если да, то сразу всё хорошо. А если нет, то проверяем с увеличенной на 1 длиной (т.е. себя же вызываем).\r\n\r\nОпять же, в конце обхода останется один элемент. И успешный такой проход будет означать положительный ответ на задачу.\r\n\r\n--}\r\n\r\nparts1 [_] _ = True\r\n\r\nparts1 (x:xs) neededLenght\r\n\r\n  | partsByLenght (x:xs) (neededLenght - 1) neededLenght = True\r\n\r\n  | head(xs) > x = parts1 xs (neededLenght + 1)\r\n\r\n  | otherwise = False\r\n\r\n\r\n\r\n	 \r\n','<br/>Тесты успешно пройдены!'),(4908,27,'1595828','2013-09-14 12:11:40',0,'minsum (x:y:xs) = minsum\' xs (x+y)\r\n\nminsum\' [] m = m \r\n\nminsum\' [x] m = m\r\n\nminsum\' (x:y:xs) m\r\n\n | m<(x+y)= minsum\' (y:xs) m\r\n\n |otherwise = minsum\' xs (x+y)\n','Выражение имеет неправильное значение: minsum [5,4,3]'),(4909,27,'1595828','2013-09-14 12:19:44',0,'minsum (x:y:xs) = minsum\' (y:xs) (x+y)\r\n\nminsum\' [] m = m \r\n\nminsum\' [x] m = m\r\n\nminsum\' (x:y:xs) m\r\n\n | m<(x+y)= minsum\' (y:xs) m\r\n\n |otherwise = minsum\' xs (x+y)\n','Выражение имеет неправильное значение: minsum [5,4,3,2,7]'),(4910,27,'1595828','2013-09-14 12:23:09',1,'minsum (x:y:xs) = minsum\' (y:xs) (x+y)\r\n\r\nminsum\' [] m = m \r\n\r\nminsum\' [x] m = m\r\n\r\nminsum\' (x:y:xs) m\r\n\r\n | m<(x+y)= minsum\' (y:xs) m\r\n\r\n |otherwise = minsum\' (y:xs) (x+y)\r\n','<br/>Тесты успешно пройдены!'),(4911,25,'3270666','2013-09-14 12:34:38',1,'minlist [x] = x\r\nminlist (x:xs) = min x (minlist xs)','<br/>Тесты успешно пройдены!'),(4912,26,'1595828','2013-09-14 12:36:35',1,'rev xs= rev\' xs []\r\n\r\nrev\' (x:xs) ys= rev\' xs (x:ys)\r\n\r\nrev\' [] ys=ys\r\n','<br/>Тесты успешно пройдены!'),(4913,27,'3270666','2013-09-14 12:39:30',1,'minsum [x,y] = x + y\r\nminsum (x:xs) = min (x + head xs) (minsum xs)','<br/>Тесты успешно пройдены!'),(4901,21,'517309','2013-09-13 16:15:56',1,'nseq n = nseq\' 1 n\r\n\r\nnseq\' k n = \r\n    if k*2 >= n \r\n    then 1\r\n    else\r\n      nseq\' (k+1) (n-k) + nseq\' (k+1) n ','<br/>Тесты успешно пройдены!'),(4902,25,'2501950','2013-09-13 21:59:14',1,'minlist [x] = x \r\nminlist (x:xs) = if(x > head xs)\r\n                 then minlist xs\r\n                 else minlist (x:tail xs)      ','<br/>Тесты успешно пройдены!'),(4903,30,'55363692','2013-09-13 23:00:46',1,'next\' cnt _ [] = (cnt, [])\r\n\r\nnext\' cnt cur (x:xs) = if cur < x then next\' (cnt + 1) x xs else (cnt, x:xs)\r\n\r\nnext [] = (0, [])\r\n\r\nnext (x:xs) = next\' 1 x xs \r\n\r\n\r\n\r\nparts\' cur x = let part = next x in if fst part == 0 then cur >= 2 else parts\' (gcd cur (fst part)) (snd part)\r\n\r\n\r\n\r\nparts x = let cur_part = next x in parts\' (fst cur_part) (snd cur_part)\r\n','<br/>Тесты успешно пройдены!'),(4904,33,'deripaska','2013-09-14 02:12:32',1,'﻿/*\r\n\r\n    task 05-01\r\n\r\n*Доп. задача*\r\n\r\nОчень простая функция высшего порядка на C#\r\n\r\n\r\n\r\nНаписать на C# функцию (статический метод) Integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:\r\n\r\n- f - функция (статический метод или лямбда выражение) \r\n\r\n- a, b - пределы интегрирования.\r\n\r\nПример вызова:\r\n\r\n\r\n\r\ndouble result = Integral(x => x*x, 0, 1);\r\n\r\n\r\n\r\nМетод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций.\r\n\r\n*/\r\n\r\n\r\n\r\n#include <iostream>\r\n\r\n#include <functional>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\nconst int n = 100;\r\n\r\n// Функция integral от f в интервале от a до b\r\n\r\n\r\n\r\ndouble integral(function<int (int)> f, double a, double b)	\r\n\r\n{												\r\n\r\n	if (a >= b) {\r\n\r\n		return 0;\r\n\r\n	}\r\n\r\n\r\n\r\n	// Метод трапеций \r\n\r\n	double h = (b - a) / n;\r\n\r\n	double result = (f(a) + f(b)) / 2;\r\n\r\n	\r\n\r\n	for (int i = 1; i < n; ++i) {\r\n\r\n		double x_i = a + i * h;\r\n\r\n		result += f(x_i);\r\n\r\n	}\r\n\r\n	\r\n\r\n	return result * h;\r\n\r\n}\r\n\r\n\r\n\r\n// Примеры функций, которые можно передавать в integral\r\n\r\n\r\n\r\nint square(int i)\r\n\r\n{\r\n\r\n	return i * i;\r\n\r\n}\r\n\r\n\r\n\r\nint cube(int i)\r\n\r\n{\r\n\r\n	return i * i * i;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	// Примеры вызовов\r\n\r\n\r\n\r\n	cout << \"integral(x^2) form 0 to 5 = \" << integral(square, 0, 5) << endl;\r\n\r\n	cout << \"integral(x^3) form 0 to 5 = \" << integral(cube, 0, 5) << endl;\r\n\r\n\r\n\r\n	// с лямбда-выражением\r\n\r\n	cout << \"integral(x^2) form 10 to 20 = \" << integral([] (int i) { return i * i; }, 10, 20) << endl;\r\n\r\n	//getchar();\r\n\r\n\r\n\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8330,98,'8519021','2013-12-05 23:57:20',1,'data Tree = Empty | Node Char Tree Tree deriving Show\r\n\r\n\r\n\r\ntoStr t = toStr\' t []\r\n\r\ntoStr\' Empty = (\'e\':)\r\n\r\ntoStr\' (Node x l r) = (\'n\':).(x:).(toStr\' l).(toStr\' r)\r\n\r\n\r\n\r\nfromStr str = fst (fromStr\' str)\r\n\r\nfromStr\' (s:str) =\r\n\r\n    if s == \'e\' then (Empty, str)\r\n\r\n    else\r\n\r\n        let\r\n\r\n          (l, lRest) = fromStr\' (tail str)\r\n\r\n          (r, rRest) = fromStr\' lRest\r\n\r\n        in (Node (head str) l r, rRest)\r\n','<br/>Тесты успешно пройдены!'),(8331,143,'toskira','2013-12-06 00:34:31',0,'toInt f = f (+1) 0\r\n\r\ndec n = (f x -> (n (p -> (e -> e (p (\\_ b -> b)) (f (p (\\_ b -> b))))) (e -> e 0 x)) (a _ -> a))','<br/>Тесты успешно пройдены!'),(8332,119,'toskira','2013-12-06 00:42:24',1,'-- надеюсь, что в 1 строчку это не так ужасно выглядит. мне так больше нравится :)\r\n\r\ntoInt f = f (+1) 0\r\n\r\ndec n = (f x -> (n (p -> (e -> e (p (\\_ b -> b)) (f (p (\\_ b -> b))))) (e -> e x x)) (a _ -> a))','<br/>Тесты успешно пройдены!'),(8333,143,'toskira','2013-12-06 00:42:39',1,'toInt f = f (+1) 0\r\n\r\ndec n = (f x -> (n (p -> (e -> e (p (\\_ b -> b)) (f (p (\\_ b -> b))))) (e -> e x x)) (a _ -> a))','<br/>Тесты успешно пройдены!'),(8334,139,'6053606','2013-12-06 12:40:36',1,'data Expr = Var String\r\n          | Num Int\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n          | Let String Expr Expr\r\n          deriving Show\r\n\r\neval :: Expr -> [(String, () -> Int)] -> Int\r\neval e ctxv = go e  where\r\n  go (Var v) = case lookup v ctxv of\r\n    Just f -> f ()\r\n    Nothing -> undefined\r\n  go (Num x) = x\r\n  go (Add e1 e2) = go e1 + go e2\r\n  go (Mult e1 e2)  = go e1  * go e2\r\n  go (Let v e body) = eval body ((v, () -> go e):ctxv)','<br/>Тесты успешно пройдены!'),(8335,143,'artem.gomerman','2013-12-06 13:51:00',1,'toInt churchNum = churchNum (x -> x + 1) 0\r\n\r\n\r\n\r\ninc churchNum = f x -> churchNum f (f x)\r\n\r\ndec churchNum = f x -> snd (snd (churchNum ( (f, (g, g\')) -> (f, (f.g, g))) (f, (id, id))) ) x\r\n','<br/>Тесты успешно пройдены!'),(8336,107,'nomeansno','2013-12-06 14:47:54',2,'  --- А вот еще пример, который зацикливается: \r\n  --- Or (Not X)(Not X) == X \r\n  --- Посмотрите, пожалуйста\r\ndata LogExpr = T | F | X | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	T == T = True\r\n\r\n	F == F = True\r\n\r\n	X == X = True\r\n\r\n	T == X = False\r\n\r\n	Not X == Not X = True\r\n\r\n	X == T = False\r\n\r\n	T == F = False\r\n\r\n	F == T = False\r\n\r\n	X == F = False\r\n\r\n	F == X = False\r\n\r\n	Not X == X = False\r\n\r\n	Not X == T = False\r\n\r\n	Not X == F = False\r\n\r\n	X == Not X = False\r\n\r\n	T == Not X = False\r\n\r\n	F == Not X = False \r\n\r\n	e1 == e2 = eval e1 == eval e2\r\n\r\n\r\n\r\neval T = T\r\n\r\neval F = F\r\n\r\neval X = X\r\n\r\neval (Not F) = T\r\n\r\neval (Not T) = F\r\n\r\neval (Not X) = Not X\r\n\r\neval (Not (Not e)) = eval e\r\n\r\neval (Not e) = Not (eval e)\r\n\r\neval (Or T e) = T\r\n\r\neval (Or e T) = T\r\n\r\neval (Or F e) = eval e\r\n\r\neval (Or e F) = eval e\r\n\r\neval (Or X X) = X\r\n\r\neval (Or X (Not X)) = T\r\n\r\neval (Or (Not X) X) = T\r\n\r\neval (Or e1 e2) = eval (Or (eval e1) (eval e2))\r\n\r\neval (And T e) = eval e\r\n\r\neval (And e T) = eval e\r\n\r\neval (And F e) = F\r\n\r\neval (And e F) = F\r\n\r\neval (And X X) = X\r\n\r\neval (And X (Not X)) = F\r\n\r\neval (And (Not X) X) = F \r\n\r\neval (And e1 e2) = eval (And (eval e1) (eval e2))\r\n\r\n','<br/>Тесты успешно пройдены!'),(8337,99,'anna','2013-12-06 16:47:17',1,'﻿using System;\r\n\r\nusing System.Globalization;\r\n\r\n\r\n\r\nnamespace ConsoleApplication1\r\n\r\n{\r\n\r\n    interface IItem\r\n\r\n    {\r\n\r\n         string Print();\r\n\r\n    }\r\n\r\n\r\n\r\n    class Number : IItem\r\n\r\n    {\r\n\r\n        private readonly int _value;\r\n\r\n\r\n\r\n        public Number(int n)\r\n\r\n        {\r\n\r\n            _value = n;\r\n\r\n        }\r\n\r\n\r\n\r\n        public string Print()\r\n\r\n        {\r\n\r\n            return _value.ToString(CultureInfo.InvariantCulture);\r\n\r\n        }\r\n\r\n    } \r\n\r\n\r\n\r\n    class Variable : IItem\r\n\r\n    {\r\n\r\n         public string Print()\r\n\r\n        {\r\n\r\n            return \"x\";\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    class Assign\r\n\r\n    {\r\n\r\n        public IItem Left;\r\n\r\n        public IItem Right;\r\n\r\n\r\n\r\n        protected Assign(IItem l, IItem r)\r\n\r\n        {\r\n\r\n            Left = l;\r\n\r\n            Right = r;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Add : Assign, IItem\r\n\r\n    {\r\n\r\n        public Add(IItem l, IItem r) : base(l, r)\r\n\r\n        {\r\n\r\n        }\r\n\r\n        public string Print()\r\n\r\n        {\r\n\r\n            return \"Add\" + \" (\" + Left.Print() + \") (\" + Right.Print() + \")\";\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Mult :Assign, IItem\r\n\r\n    {\r\n\r\n        public Mult(IItem l, IItem r) : base(l, r)\r\n\r\n        {\r\n\r\n        }\r\n\r\n        public string Print()\r\n\r\n        {\r\n\r\n            return \"Mult\" + \" (\" + Left.Print() + \") (\" + Right.Print() + \")\";\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    class Derivative\r\n\r\n    {\r\n\r\n        public static IItem Diff(IItem n)\r\n\r\n        {\r\n\r\n            if (n is Number)\r\n\r\n            {\r\n\r\n                return new Number(0);\r\n\r\n            }\r\n\r\n            if (n is Variable)\r\n\r\n            {\r\n\r\n                return new Number(1);\r\n\r\n            }\r\n\r\n\r\n\r\n            {\r\n\r\n                var add = n as Add;\r\n\r\n                if (add != null)\r\n\r\n                {\r\n\r\n                    var m = add;\r\n\r\n                    return new Add(Diff(m.Left), Diff(m.Right));\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    var m = (Mult)n;\r\n\r\n                    return new Add(new Mult(Diff(m.Left), m.Right), new Mult(m.Left, Diff(m.Right)));\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            IItem v = new Variable();\r\n\r\n            IItem n = new Number(1);\r\n\r\n            IItem x = new Mult(new Variable() , new Variable());\r\n\r\n\r\n\r\n            Console.WriteLine(\"the derivative of 1 is {0}\", Diff(n).Print());\r\n\r\n            Console.WriteLine(\"the derivative of variable x is {0}\", Diff(v).Print());\r\n\r\n            Console.WriteLine(\"the derivative of function x^2 is {0}\", Diff(x).Print());\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8338,121,'anna','2013-12-06 17:47:34',1,'﻿using System;\r\n\r\n\r\n\r\nnamespace ConsoleApplication1\r\n\r\n{\r\n\r\n\r\n\r\n    class Factorial\r\n\r\n    {\r\n\r\n        static void fact_cps(int num, Action<int> print)\r\n\r\n        {\r\n\r\n            if (num == 0)\r\n\r\n                print(1);\r\n\r\n            else\r\n\r\n                fact_cps(num - 1, x => print(num * x));\r\n\r\n        }\r\n\r\n\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {\r\n\r\n            fact_cps(4, Console.WriteLine);\r\n\r\n            Console.ReadKey();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8339,138,'8519021','2013-12-06 17:56:40',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n(>>>=) f1 f2 xs = let (x, ys) = f1 xs in f2 x ys\r\n\r\nreturn1 f ys = (f, ys)\r\n\r\n\r\n\r\nf = find (>3) >>>= x -> find (>x) >>>= y -> return1 (x+y)\r\n','<br/>Тесты успешно пройдены!'),(8340,121,'5247795','2013-12-06 18:26:14',2,'--- В задачах на C# надо присылать не фрагмент программы, а всю программу со всеми using и тд.\r\n--- Чтобы я ее мог вставить в редактор и запустить\r\n--- Пришлите такой полный код, пожалуйста\r\nstatic void fact_cps(int n, Action<int> cont)\r\n        {\r\n            if (n == 0)\r\n                cont(1);\r\n            else\r\n                fact_cps((n - 1), x => cont(x * n));\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Enter the number:\");\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n            fact_cps(n, fact => Console.WriteLine(\"Result: \" + fact));\r\n            Console.ReadLine();\r\n        }','<br/>Тесты успешно пройдены!'),(8341,121,'5247795','2013-12-06 18:54:35',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace fact_cps\r\n{\r\n    class Program\r\n    {\r\n\r\n        static void fact_cps(int n, Action<int> cont)\r\n        {\r\n            if (n == 0)\r\n                cont(1);\r\n            else\r\n                fact_cps((n - 1), x => cont(x * n));\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Enter the number:\");\r\n            int n = Convert.ToInt32(Console.ReadLine());\r\n            fact_cps(n, fact => Console.WriteLine(\"Result: \" + fact));\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(8342,99,'5247795','2013-12-06 20:00:14',1,'Sent by mail','<br/>Тесты успешно пройдены!'),(8343,119,'artem.gomerman','2013-12-06 20:04:13',1,'toInt churchNum = churchNum (x -> x + 1) 0\r\n\r\n\r\n\r\ninc churchNum = f x -> churchNum f (f x)\r\n\r\ndec churchNum = f x -> (churchNum ( churchNum\' -> (g y -> churchNum\' (f) (g y)) ) (g y -> y)) (id) x\r\n --- Здорово, вы молодец!','<br/>Тесты успешно пройдены!'),(8344,107,'62628590','2013-12-06 23:03:32',1,'\"sent by mail\"','Не удалось вычислить выражение \"Or X (Not X) == T\", проверьте правильность синтаксиса'),(8345,121,'Artur','2013-12-06 23:45:26',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace _07_12\r\n{\r\n    class Program\r\n    {\r\n        public static int fact_cps(int n, Func<int,int> f)\r\n        {\r\n            if (n == 0)\r\n            {\r\n                return f(1) ;\r\n            }\r\n            else\r\n            {\r\n                return fact_cps(n-1, i => f(i*n)) ;\r\n            }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(fact_cps(1, i => i));\r\n            Console.WriteLine(fact_cps(2, i => i));\r\n            Console.WriteLine(fact_cps(3, i => i));\r\n            Console.WriteLine(fact_cps(4, i => i));\r\n            Console.WriteLine(fact_cps(5, i => i));\r\n        }\r\n    }\r\n}\r\n','<br/>Тесты успешно пройдены!'),(8346,143,'8519021','2013-12-07 00:21:01',2,'--- Нет, это не совсем по условию.. Можно пользоваться парами, действительно. Но нельзя пользоваться toInt и целыми числами\r\n--- Если бы было можно, и пары были бы не нужно - переводите в целое, вычитаете 1, переводите обратно.\r\n--- Могу немного подсказать. Надо взять пару в которой два числа черча, соотвествующие 0 и n раз проделать такую\r\n--- операцию: первый элемент пары копировать во второй (те во втором всегда будет пердыдущее значение первого)\r\n--- А первый элемент увеличить на 1, как это делать мы знаем. Тогда в конце во втором элементе пары окажется \r\n--- как раз то, что надо. Если будут вопросы, пишите. \r\ntoInt cn = cn (+1) 0\r\n\r\n\r\n\r\ninc cn = f x -> f (cn f x)\r\n\r\n\r\n\r\ndec cn = dec\' (f x -> x, inc(f x -> x)) cn\r\n\r\ndec\' (cn1, cn2) cn = if toInt cn2 == toInt cn then cn1 else dec\' (cn2, inc(cn2)) cn\r\n','<br/>Тесты успешно пройдены!'),(8347,125,'8519021','2013-12-07 10:49:53',1,'﻿Правило бета-редукции можно уточнить следующим образом:\r\n\r\nВыражение (x -> E)a можно без изменения смысла выражения преобразовать в \r\n\r\nE{x|a} - выражение E, в котором все свободные вхождения переменной x заменены на выражение a. \r\n\r\n\r\n\r\nВ качестве примера рассмотрим выражение:\r\n\r\n(x -> (x -> 2 + x) 1 + x) 2\r\n\r\n\r\n\r\nПрименим правило бета-редукции указанное выше:\r\n\r\n( x -> 2 + x) (1 + 2) = ( x -> 2 + x) 3 = 2 + 3 = 5\r\n\r\n\r\n\r\nЕсли же мы по нашему старому правилу заменим все вхождения переменной x на 2, то такое преобразование приведет нас к неверному результату:\r\n\r\n(x -> 2 + 2) (1 + 2) = 2 + 2 = 4\r\n','<br/>Тесты успешно пройдены!'),(8348,143,'8519021','2013-12-07 11:21:52',1,'--- Подсказать вам про пары? Если надо напишите на simuni@mail.ru, пожалуйста.\r\n--- Но в двух словах, идея такая же как с числами Черча - пары\r\n--- представляем, как функции.\r\ntoInt cn = cn (+1) 0\r\n\r\ninc cn = f x -> f (cn f x)\r\n\r\n\r\n\r\ndec cn = snd (cn ((b, _) -> (inc b, b)) (f x -> x, f x -> x))\r\n','<br/>Тесты успешно пройдены!'),(8349,140,'6053606','2013-12-07 14:16:36',1,'(lambda x.0)((lambda x.xx)(lambda x.xx))\r\n\r\nВ случае нормального порядка получится 0, \r\nа в случае аппликативного - дно\r\n(lambda x.0)((lambda x.xx)(lambda x.xx))\r\n(lambda x.0)((lambda x.xx)(lambda x.xx))\r\nи т п\r\n\r\n','<br/>Тесты успешно пройдены!'),(8350,107,'nomeansno','2013-12-07 14:32:28',1,'data LogExpr = T | F | X | Not LogExpr | And LogExpr LogExpr | Or LogExpr LogExpr deriving Show\r\n\r\n\r\n\r\ninstance Eq LogExpr where\r\n\r\n	T == T = True\r\n\r\n	F == F = True\r\n\r\n	X == X = True\r\n\r\n	T == X = False\r\n\r\n	Not X == Not X = True\r\n\r\n	X == T = False\r\n\r\n	T == F = False\r\n\r\n	F == T = False\r\n\r\n	X == F = False\r\n\r\n	F == X = False\r\n\r\n	Not X == X = False\r\n\r\n	Not X == T = False\r\n\r\n	Not X == F = False\r\n\r\n	X == Not X = False\r\n\r\n	T == Not X = False\r\n\r\n	F == Not X = False \r\n\r\n	e1 == e2 = eval e1 == eval e2\r\n\r\n\r\n\r\neval T = T\r\n\r\neval F = F\r\n\r\neval X = X\r\n\r\neval (Not F) = T\r\n\r\neval (Not T) = F\r\n\r\neval (Not X) = Not X\r\n\r\neval (Not (Not e)) = eval e\r\n\r\neval (Not e) = Not (eval e)\r\n\r\neval (Or T e) = T\r\n\r\neval (Or e T) = T\r\n\r\neval (Or F e) = eval e\r\n\r\neval (Or e F) = eval e\r\n\r\neval (Or X X) = X\r\n\r\neval (Or X (Not X)) = T\r\n\r\neval (Or (Not X) X) = T\r\n\r\neval (Or (Not X) (Not X)) = Not X\r\n\r\neval (Or e1 e2) = eval (Or (eval e1) (eval e2))\r\n\r\neval (And T e) = eval e\r\n\r\neval (And e T) = eval e\r\n\r\neval (And F e) = F\r\n\r\neval (And e F) = F\r\n\r\neval (And X X) = X\r\n\r\neval (And X (Not X)) = F\r\n\r\neval (And (Not X) X) = F \r\n\r\neval (And (Not X) (Not X)) = Not X\r\n\r\neval (And e1 e2) = eval (And (eval e1) (eval e2))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8351,140,'toskira','2013-12-07 15:30:08',2,'--- Идея правильная, но имеется в виду чистое лямбда исчисление Черча, без списков, чисел, деления и т.д.\r\n--- Приведите такой пример, пожалуйста.\r\n\\_ -> length [1/0]','<br/>Тесты успешно пройдены!'),(8352,99,'nomeansno','2013-12-07 16:32:58',1,'#include <iostream>\r\n\r\n#include <cstring>\r\n\r\n#include <sstream>\r\n\r\n#include <stack>\r\n\r\n\r\n\r\nstruct node {\r\n\r\n    std::string value;\r\n\r\n    node *left;\r\n\r\n    node *right;\r\n\r\n\r\n\r\n    node(const std::string &value_, node *left_ = NULL, node *right_ = NULL) :\r\n\r\n        value(value_), left(left_), right(right_)\r\n\r\n    {}\r\n\r\n\r\n\r\n    ~node() {\r\n\r\n        std::cout << \"~\" << value;\r\n\r\n        if (left!=NULL && right !=NULL)\r\n\r\n        {\r\n\r\n           // delete left;\r\n\r\n           // delete right;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    void print() const {\r\n\r\n        if (left!=NULL && right!=NULL)\r\n\r\n        {\r\n\r\n            std::cout << \'(\';\r\n\r\n            (*left).print();\r\n\r\n            std::cout << value;\r\n\r\n            (*right).print();\r\n\r\n            std::cout << \')\';\r\n\r\n        }\r\n\r\n        else std::cout << value;\r\n\r\n    }\r\n\r\n\r\n\r\n    static bool is_digit(char c) {\r\n\r\n        return (c>=\'0\' && c<=\'9\'); // only positive numbers\r\n\r\n    }\r\n\r\n\r\n\r\n    static bool is_sign(char c) {\r\n\r\n        return (c==\'+\' || c==\'*\');\r\n\r\n    }\r\n\r\n\r\n\r\n    static bool is_variable(char c) {\r\n\r\n        return (c==\'x\' || c==\'X\');\r\n\r\n    }\r\n\r\n\r\n\r\n    static std::string int_to_str(int number) {\r\n\r\n        std::string result;\r\n\r\n        std::stringstream temp;\r\n\r\n        temp << number;\r\n\r\n        result = temp.str();\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    static node * differentiation(node *expr) {\r\n\r\n        if (expr->value == \"+\")\r\n\r\n            return new node(expr->value, differentiation(expr->left), differentiation(expr->right));\r\n\r\n        if (expr->value == \"*\")\r\n\r\n        {\r\n\r\n            node *expr_l = new node(expr->left->value, expr->left->left, expr->left->right);\r\n\r\n            node *expr_r = new node(expr->right->value, expr->right->left, expr->right->right);\r\n\r\n            node *expr_ld = differentiation(expr->left);\r\n\r\n            node *expr_rd = differentiation(expr->right);\r\n\r\n            return new node(\"+\", new node(\"*\", expr_l, expr_rd), new node(\"*\", expr_r, expr_ld));\r\n\r\n        }\r\n\r\n        if (expr->value == \"x\" || expr->value == \"X\")\r\n\r\n            return new node(int_to_str(1));\r\n\r\n        return new node(int_to_str(0));\r\n\r\n    }\r\n\r\n\r\n\r\n};\r\n\r\n\r\n\r\nint main() {\r\n\r\n    std::string temp(\"x 1 x + *\"); // input correct expression in reverse polish notation\r\n\r\n    //std::getline(std::cin, temp);\r\n\r\n    char *expr = new char(temp.length()+1);\r\n\r\n    strcpy(expr, temp.c_str());\r\n\r\n    char *p = strtok(expr, \" \");\r\n\r\n    std::stack<node *> S;\r\n\r\n    while (p) {\r\n\r\n        if (node::is_digit(*p) || node::is_variable(*p))\r\n\r\n            S.push(new node(p));\r\n\r\n        if (node::is_sign(*p))\r\n\r\n        {\r\n\r\n            node *arg2 = (S.top());\r\n\r\n            S.pop();\r\n\r\n            node *arg1 = (S.top());\r\n\r\n            S.pop();\r\n\r\n            S.push(new node(p, arg1, arg2));\r\n\r\n        }\r\n\r\n        p = strtok(NULL, \" \");\r\n\r\n    }\r\n\r\n    node *E = S.top();\r\n\r\n    std::cout << \"e = \";\r\n\r\n	E->print();\r\n\r\n    std::cout << std::endl;\r\n\r\n    node *dif_E = node::differentiation(E);\r\n\r\n    std::cout << \"e\' = \";\r\n\r\n	dif_E->print();\r\n\r\n    std::cout << std::endl;\r\n\r\n    node *dif2_E = node::differentiation(dif_E);\r\n\r\n    std::cout << \"e\'\' = \";\r\n\r\n	dif2_E->print();\r\n\r\n    std::cout << std::endl;\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8353,119,'8519021','2013-12-07 17:41:04',1,'--- Здорово, я очень рад ,что у вас получилось!\r\ntoInt cn = cn (+1) 0\r\n\r\ninc cn = f x -> f (cn f x)\r\n\r\n\r\n\r\npair x y = f -> f x y\r\n\r\nfirst = f -> f (x y -> x)\r\n\r\nsecond = f -> f (x y -> y)\r\n\r\n\r\n\r\ndec cn = second (cn ( -> pair (inc (first b)) (first b)) (q -> q (f x -> x) (f x -> x)))\r\n','<br/>Тесты успешно пройдены!'),(8354,126,'1595828','2013-12-07 20:15:05',1,'Док-во: Пусть у выражения А существует две нормальные формы В и С,тогда (т.е. А редуцируемо к В и С) по свойству конфлюентности(применима по теореме (Черча, Россера)) существует выражение D к которому редуцируемы как B, так и C т.е. либо B = C и это одна нормальная форма,либо B и С не находятся в нормальной форме(т.е. хотя бы одно выражение не в нормальной форме)','<br/>Тесты успешно пройдены!'),(8355,143,'Artur','2013-12-07 23:40:04',0,'toInt churchNum = churchNum (+1) 0\r\n\r\ninc churchNum = f x -> f (churchNum f x)\r\n\r\nzero = (f x-> x,f x -> x)\r\nf 0 = zero\r\nf (k+1) = (snd (f k), inc (snd (f k) ))\r\nlChurch n = (f n): lChurch(n+1)\r\n\r\ndec f =fst (head( filter ((h,g)-> toInt g == toInt f) (lChurch 0)))\r\n','Не удалось вычислить выражение \"let ch3 f x = f (f (f x)) in toInt(dec ch3)\", проверьте правильность синтаксиса'),(8356,143,'Artur','2013-12-07 23:41:14',0,'toInt churchNum = churchNum (+1) 0\r\n\n\r\n\ninc churchNum = f x -> f (churchNum f x)\r\n\n\r\n\nzero = (f x-> x,f x -> x)\r\n\nf 0 = zero\r\n\nf (k+1) = (snd (f k), inc (snd (f k) ))\r\n\nlChurch n = (f n): lChurch(n+1)\r\n\n\r\n\ndec f =fst (head( filter ((h,g)-> toInt g == toInt f) (lChurch 0)))\r\n\n\n','Не удалось вычислить выражение \"let ch3 f x = f (f (f x)) in toInt(dec ch3)\", проверьте правильность синтаксиса'),(8357,143,'Artur','2013-12-07 23:41:24',2,'  --- Нет, это не по условию, даже если не считать, что там что-то не компилируется.\r\n  --- Вы в решении пользуетесь toInt, а это делать по условию нельзя, можно пользоваться только парами.\r\ntoInt churchNum = churchNum (+1) 0\r\n\r\n\r\n\r\ninc churchNum = f x -> f (churchNum f x)\r\n\r\n\r\n\r\nzero = (f x-> x,f x -> x)\r\n\r\nf 0 = zero\r\n\r\nf (k+1) = (snd (f k), inc (snd (f k) ))\r\n\r\nlChurch n = (f n): lChurch(n+1)\r\n\r\n\r\n\r\ndec f =fst (head( filter ((h,g)-> toInt g == toInt f) (lChurch 0)))\r\n\r\n\r\n','Не удалось вычислить выражение \"let ch3 f x = f (f (f x)) in toInt(dec ch3)\", проверьте правильность синтаксиса'),(8358,138,'ip','2013-12-08 00:34:23',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\n\r\n\r\nreturn1 x xs = (x,xs)\r\n\r\n\r\n\r\nf >>>= g = xs -> let \r\n\r\n		  (x, xs1) = f xs \r\n\r\n 		  in g x xs1\r\n\r\n\r\n\r\n\r\n\r\nf = find (>3) >>>= x -> find (>x) >>>= y -> return1 (x+y)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8359,140,'2260659','2013-12-08 01:19:24',1,'(x -> y -> y)((x -> x x)(x -> x x))\r\nпри аппликативном порядке редукций первым будет редуцироваться внутреннее выражение, в результате случится зацикливание и выражение не будет приведено к нормальной форме\r\nпри нормальном порядке редукций приведение к нормальной форме начнется с применению редукции к внешнему редексу, в результате чего получится y -> y','<br/>Тесты успешно пройдены!'),(8360,139,'ip','2013-12-08 01:34:32',0,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Expr Expr\r\n\r\n                                                       deriving Show\r\n\r\n\r\n\r\n\r\n\r\ng (x:xs) i ys = if (i /= 0)\r\n\r\n                then (g xs (i-1) (ys++[x]))\r\n\r\n                else ys \r\n\r\n\r\n\r\neval (Num i) xs = i\r\n\r\neval (Var x) xs = last( xs >>= ((a,b,c) -> if (a==x)\r\n\r\n                                    	    then [eval b (g xs c [])]\r\n\r\n                                  	    else [] ))\r\n\r\n \r\n\r\neval (Add a b) xs = (eval a xs) + (eval b xs) \r\n\r\neval (Mult a b) xs = (eval a xs) * (eval b xs)\r\n\r\neval (Let x i a) xs = eval a (xs++[(x, i, length xs)])\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8361,125,'ip','2013-12-08 01:44:43',1,'a. (x -> (x -> x*x) x*x) a\r\nb.\r\nВыражение\r\n(x -> E) a\r\nвсегда можно без изменения смысла выражения заменить на Е в котором все СВОБОДНЫЕ вхождения x заменены на a','<br/>Тесты успешно пройдены!'),(8362,126,'ip','2013-12-08 01:54:33',0,'Пусть есть две разные нормальные формы A и B, тогда по свойству конфлюентности существует D к которому редуцируется A и B, а значит либо они равны либо не нормальны, противоречие.Нормальная форма единственна.','<br/>Тесты успешно пройдены!'),(8363,126,'ip','2013-12-08 02:02:25',1,'Пусть есть две разные нормальные формы A и B, тогда\r\nA редуцируется к B т.к B нормальна а A часть редукции начального выражения\r\nA редуцируется к A т.к одинаковые выражения\r\nи\r\n по свойству конфлюентности существует D к которому редуцируется A и B, а значит либо они равны либо не нормальны, противоречие.Нормальная форма единственна.','<br/>Тесты успешно пройдены!'),(8364,140,'toskira','2013-12-08 02:21:42',2,'--- Не очень понятоно, а почему разные резльтаты? Тут у нас вроде бы вообще только один редекс,\r\n--- так что все порядки ведут себя  одинакого\r\n--- И потом, мы тут говорим о чистом лямбда исчислении, поэтому у лямбда выражений может быть только один параметр? \r\n(a b -> b) (a -> a a)','<br/>Тесты успешно пройдены!'),(8365,140,'ip','2013-12-08 02:34:53',1,'(λx -> 3)((λx->x x)(λx->x x))\r\n\r\nпри нормальном сразу 3\r\nпри аппликативном в бесконечность','<br/>Тесты успешно пройдены!'),(8366,140,'1595828','2013-12-08 09:50:36',1,'(λx->1)((λx->xx) (λx->xx))','<br/>Тесты успешно пройдены!'),(8367,125,'Artur','2013-12-08 10:11:39',1,'(x -> x * (x -> mult x*x*x ) ) a - наверное, такой пример. \r\nВозможное уточнение:\r\nВыражение\r\n(x -> E) a\r\nвсегда можно без изменения смысла выражения заменить на Е в котором все вхождения x заменены на a, в котором нет связанных внешним символом \"x\" переменных x\r\n   --- Уточнение слишком строгое - даже если и есть связанные переменные, это не мешает делать бета редукцимю,\r\n   --- надо просто их не менять.\r\n   --- Но ОК, засчитано.   \r\n ','<br/>Тесты успешно пройдены!'),(8368,125,'1595828','2013-12-08 10:16:55',1,'a.λx->(λy->x+y) (1 x)\r\nб. следить, чтобы в подставляемом выражение не использовались свободные переменные выражения E,и если используются произвести альфа-редукцию т.е. переименовать.','<br/>Тесты успешно пройдены!'),(8369,126,'Artur','2013-12-08 10:27:35',2,'Пусть некоторое лямбда-выражение A  имеет различные нормальные формы B и С, то есть A редуцируемо к выражению B и A редуцируемо к выражениею C, тогда по свойству конфлюентности существует выражение D, что B редуцируемо к D и C редуцируемо к D. Следовательно, B и C не являются нормальными формами. Противоречие.\r\n  --- Это не совсеи корректно, потому что \"редуцируемо\" означаетчто в приниципе выражения могут совпадать.\r\n  --- Те из того, что B редуцируемо к D и B - в нормальной форме само по себе не следует противоречие.\r\n  --- Потому что B может совпадать с D.\r\n  --- Тем не менее противоречие тут, конечно очевидно, но попробуйте, пожалуйста, более четко его описать.','<br/>Тесты успешно пройдены!'),(8370,140,'nomeansno','2013-12-08 13:57:05',1,'f = f\r\n\r\ntest x y = if (x == 0) then 0 else y\r\n\r\ncheck = test 0 f \r\n\r\n--при аппликативном порядке - check не вычисляется, так как вычисление f (второго аргумента функции test) зацикливается (f=f)\r\n\r\n--при нормальном порядке - check возвращает 0, так как 0==0 и вычисление f не происходит  \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8371,138,'nomeansno','2013-12-08 13:57:23',1,'f1 >>>= f2 = s -> let (x,xs) = f1 s in f2 x xs\r\n\r\n\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n\r\n\r\nreturn1 x = s -> (x,s)  \r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8372,125,'nomeansno','2013-12-08 13:57:53',1,'a. F = λx. λy. y x => F y x = (λx. λy. y x) y x -> (λy. y y) x -> x x\r\n\r\nно для произвольных термов m,n: F m n = (λx. λy. y x) m n -> (λy. y m) n -> n m\r\n\r\n(то есть если m=y, n=x получим F y x = x y)\r\n\r\nтаким образом x x = x y !?\r\n\r\n\r\n\r\nб. корректное правило бета-редукции: (λx. expr1) expr2 = expr1, в котором вместо всех вхождений x подставлено expr2 только если expr2 свободен для подстановки вместо x в  expr1 (то есть имена всех связанных переменных в expr1 должны отличаться от expr2)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8373,126,'nomeansno','2013-12-08 13:58:24',2,'Доказательство от противного:\r\n\r\nПусть N1,N2 - разные нормальные формы M.\r\n\r\nПо т. Ч.-Р. бета-редукция для лямбда исчисления обладает свойством конфлюентности, то есть из того, что M редуцируемо к N1 и М редуцируемо к N2 следует существование выражения N: N1,N2 редуцируемы к N.\r\n\r\nНо по предположению N1,N2 - нормальные формы M !? (N1,N2 - выражения, к которым нельзя применить редукцию).\r\n   --- Нет, это не совсем  корректно. Если N1 редуцируемо к N, это не противоречит тому, что N1 - нормальная форма.\r\n   --- Птому что редуцируемость может быть и за 0 редукций. Те это просто означает, что N1 редуцируема к N за 0 редукций.\r\n   --- Теорема тем не менее конечно совершенно очевидна, но попробуйте строго написать почему, пожуалуйста\r\n\r\n','<br/>Тесты успешно пройдены!'),(8374,138,'Artur','2013-12-08 15:53:11',2,'--- Это что-то странное... У вас find описан как возвращаюзий Maybe а вызывается, как возвращающее пару (значениеб список)\r\n--- И опредедение return1 на самом деле вовсе не такое.\r\n--- Попробуйте исправить, пожалуйста.  \r\nfind cond [] = Nothing\r\n\r\nfind cond (x:xs) = if cond x then Just x else find cond xs\r\n\r\n\r\n\r\n\r\n\r\nf xs = do\r\n\r\n	x <- find (<5)   xs\r\n\r\n	y <- find (>10)  xs\r\n\r\n	z <- find (/= 7) xs\r\n\r\n	return (x + y + z)\r\n\r\n\r\n\r\nf  >>>= g  = xs -> \r\n\r\n     let \r\n\r\n		(x, xs1) = f xs \r\n\r\n     in g x xs1\r\n\r\n	 \r\n\r\n	 \r\n\r\nh = find (>3) >>>= x ->\r\n\r\n       find (>x) >>>= y ->\r\n\r\n         return1 (x+y)\r\n\r\n\r\n\r\nreturn1 a = xs -> const a\r\n','<br/>Тесты успешно пройдены!'),(8375,126,'Artur','2013-12-08 15:58:14',1,'Пусть некоторое лямбда-выражение A  имеет различные нормальные формы B и С, \r\nто есть A редуцируемо к выражению B и A редуцируемо к выражениею C, \r\nтогда по свойству конфлюентности существует выражение D, \r\nчто B редуцируемо к D и C редуцируемо к D. \r\nСледовательно, так как B и C являются нормальными формами, то \r\nB и C совпадают. Противоречие с тем, что B и C различны.','<br/>Тесты успешно пройдены!'),(8376,138,'MaryK','2013-12-08 16:58:39',1,'-- 38.1\r\n\r\nf  >>>= g  = xs -> \r\n\r\n     let \r\n\r\n        (x, xs1) = f xs \r\n\r\n     in g x xs1\r\n\r\n\r\n\r\nfind1 cond (x:xs) = \r\n\r\n   if cond x \r\n\r\n   then (x, xs)\r\n\r\n   else find1 cond xs\r\n\r\n\r\n\r\nf = find1 (>3) >>>= x ->\r\n\r\n    find1 (>x) >>>= y ->\r\n\r\n    return1 (x+y)\r\n\r\n\r\n\r\nreturn1 x xs = (x, xs)\r\n\r\n\r\n\r\n-- 38.2 and 39.1\r\n\r\ndata Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Expr Expr | LetFunc String String Expr Expr | Call String Expr\r\n\r\neval\' (Num i) _ _ _ = i\r\n\r\neval\' (Var name) env eenv fenv = \r\n\r\n    if (contains name env)\r\n\r\n    then getValue name env\r\n\r\n    else\r\n\r\n        let\r\n\r\n            (expr, context) = getValue name eenv\r\n\r\n        in eval\' expr context eenv fenv\r\n\r\neval\' (Add x y) env eenv fenv = eval\' x env eenv fenv + eval\' y env eenv fenv\r\n\r\neval\' (Mult x y) env eenv fenv = eval\' x env eenv fenv * eval\' y env eenv fenv\r\n\r\n\r\n\r\neval\' (Let x (Num n) e) env eenv fenv = eval\' e ((x, n) : env) eenv fenv\r\n\r\neval\' (Let x expr e) env eenv fenv = eval\' e env ((x, (expr, env)) : eenv) fenv\r\n\r\n\r\n\r\neval\' (LetFunc name parameter body expr) env eenv fenv = eval\' expr env eenv ((name, (parameter, (body, env))) : fenv)\r\n\r\neval\' (Call name expr) env eenv fenv = \r\n\r\n    let\r\n\r\n        argumentValue = eval\' expr env eenv fenv\r\n\r\n        (parameter, (body, context)) = getValue name fenv\r\n\r\n    in eval\' body ((parameter, argumentValue) : context) eenv fenv\r\n\r\n\r\n\r\neval expr env fenv = eval\' expr env [] fenv\r\n\r\n\r\n\r\ngetValue name env = \r\n\r\n     head [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\ncontains name env = \r\n\r\n    length [v | (n, v) <- env, n == name] > 0\r\n\r\n\r\n\r\n-- eval (Let \"x\" (Num 5) (Let \"y\" (Mult (Var \"x\") (Var \"x\")) (Let \"x\" (Num 10) (Add (Var \"y\") (Num 1))))) [] []\r\n\r\n-- eval (Let \"Y\" (Num 5) (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"Y\")) (Let \"Y\" (Num 10) (Call \"F\" (Num 5))))) [] []\r\n\r\n\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8377,141,'MaryK','2013-12-08 19:06:10',1,'data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Expr Expr | LetFunc String String Expr Expr | Call String Expr\r\n\r\neval\' (Num i) _ _ _ = i\r\n\r\neval\' (Var name) env eenv fenv = \r\n\r\n    if (contains name env)\r\n\r\n    then getValue name env\r\n\r\n    else\r\n\r\n        let\r\n\r\n            (expr, context) = getValue name eenv\r\n\r\n        in eval\' expr context eenv fenv\r\n\r\neval\' (Add x y) env eenv fenv = eval\' x env eenv fenv + eval\' y env eenv fenv\r\n\r\neval\' (Mult x y) env eenv fenv = eval\' x env eenv fenv * eval\' y env eenv fenv\r\n\r\n\r\n\r\neval\' (Let x (Num n) e) env eenv fenv = eval\' e ((x, n) : env) eenv fenv\r\n\r\neval\' (Let x expr e) env eenv fenv = eval\' e env ((x, (expr, env)) : eenv) fenv\r\n\r\n\r\n\r\neval\' (LetFunc name parameter body expr) env eenv fenv = eval\' expr env eenv ((name, (parameter, (body, env))) : fenv)\r\n\r\neval\' (Call name expr) env eenv fenv = \r\n\r\n    let\r\n\r\n        argumentValue = eval\' expr env eenv fenv\r\n\r\n        (parameter, (body, context)) = getValue name fenv\r\n\r\n    in eval\' body ((parameter, argumentValue) : context) eenv fenv\r\n\r\n\r\n\r\neval expr env fenv = eval\' expr env [] fenv\r\n\r\n\r\n\r\ngetValue name env = \r\n\r\n     head [v | (n, v) <- env, n == name]\r\n\r\n\r\n\r\ncontains name env = \r\n\r\n    length [v | (n, v) <- env, n == name] > 0\r\n\r\n\r\n\r\n-- eval (Let \"x\" (Num 5) (Let \"y\" (Mult (Var \"x\") (Var \"x\")) (Let \"x\" (Num 10) (Add (Var \"y\") (Num 1))))) [] []\r\n\r\n-- eval (Let \"Y\" (Num 5) (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"Y\")) (Let \"Y\" (Num 10) (Call \"F\" (Num 5))))) [] []\r\n','<br/>Тесты успешно пройдены!'),(8378,126,'MaryK','2013-12-08 19:27:34',0,'','<br/>Тесты успешно пройдены!'),(8379,125,'MaryK','2013-12-08 19:30:44',1,'﻿-- 38.3\r\n\r\n1. пример:\r\n\r\n(при нормальном порядке бета-редукций)\r\n\r\n(x -> (x -> x) 10) 5 => (x -> 5) 10 => 5 - было бы так\r\n\r\n(x -> (x -> x) 10) 5 => (x -> x) 10 => 10 - ожидается, что будет так\r\n\r\n\r\n\r\n2. более корректная формулировка:\r\n\r\n(x -> E) a  - это Е, в котором все вхождения x заменены на a, но:\r\n\r\n- заменяем только свободные вхождения x в E\r\n\r\n- иногда нужно делать альфа-конверсию, чтобы свободное вхождение некоторой переменной в a не превращалось в связанное в E при подстановке\r\n\r\n(x -> (y -> x)) y => y -> y - некорректно\r\n\r\n(x -> (y -> x)) y => z -> y - корректно\r\n\r\n\r\n\r\n\r\n\r\n-- 38.4\r\n\r\nПусть лямбда-выражение A имеет 2 _различные_ нормальные формы - B и C. Тогда, т.к. A редуцируемо к B и A редуцируемо к C, а бета-редукция для лябмда-исчислений обладает свойством конфлюентности, то существует лямбда-выражение D, к которому редуцируемы и B, и C. При этом, т.к. B и C - нормальные формы, то в них нет редексов, т.е. нельзя применить ни одной бета-редукции, а значит D получено из B и из C за 0 редукций. Но такого не может быть, т.к. B и C различны.\r\n\r\n\r\n\r\n\r\n\r\n-- 38.5\r\n\r\n(x -> y) ((x -> x x) (x -> x x))\r\n\r\nПри нормальном порядке бета-редукций в качестве редекса выберется всё лябмда-выражение, а после проведения редукции получится y, т.к. подстановка происходит по x.\r\n\r\nПри аппликативном порядке в качестве редекса выберется (x -> x x) (x -> x x), который после редукции перейдёт в себя, что ведёт к зацикливанию вычислений (т.е. процесс вычисления по Черчу не закончится).\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8380,126,'MaryK','2013-12-08 19:31:01',1,'﻿-- 38.3\r\n\r\n1. пример:\r\n\r\n(при нормальном порядке бета-редукций)\r\n\r\n(x -> (x -> x) 10) 5 => (x -> 5) 10 => 5 - было бы так\r\n\r\n(x -> (x -> x) 10) 5 => (x -> x) 10 => 10 - ожидается, что будет так\r\n\r\n\r\n\r\n2. более корректная формулировка:\r\n\r\n(x -> E) a  - это Е, в котором все вхождения x заменены на a, но:\r\n\r\n- заменяем только свободные вхождения x в E\r\n\r\n- иногда нужно делать альфа-конверсию, чтобы свободное вхождение некоторой переменной в a не превращалось в связанное в E при подстановке\r\n\r\n(x -> (y -> x)) y => y -> y - некорректно\r\n\r\n(x -> (y -> x)) y => z -> y - корректно\r\n\r\n\r\n\r\n\r\n\r\n-- 38.4\r\n\r\nПусть лямбда-выражение A имеет 2 _различные_ нормальные формы - B и C. Тогда, т.к. A редуцируемо к B и A редуцируемо к C, а бета-редукция для лябмда-исчислений обладает свойством конфлюентности, то существует лямбда-выражение D, к которому редуцируемы и B, и C. При этом, т.к. B и C - нормальные формы, то в них нет редексов, т.е. нельзя применить ни одной бета-редукции, а значит D получено из B и из C за 0 редукций. Но такого не может быть, т.к. B и C различны.\r\n\r\n\r\n\r\n\r\n\r\n-- 38.5\r\n\r\n(x -> y) ((x -> x x) (x -> x x))\r\n\r\nПри нормальном порядке бета-редукций в качестве редекса выберется всё лябмда-выражение, а после проведения редукции получится y, т.к. подстановка происходит по x.\r\n\r\nПри аппликативном порядке в качестве редекса выберется (x -> x x) (x -> x x), который после редукции перейдёт в себя, что ведёт к зацикливанию вычислений (т.е. процесс вычисления по Черчу не закончится).\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8381,140,'MaryK','2013-12-08 19:31:15',1,'﻿-- 38.3\r\n\r\n1. пример:\r\n\r\n(при нормальном порядке бета-редукций)\r\n\r\n(x -> (x -> x) 10) 5 => (x -> 5) 10 => 5 - было бы так\r\n\r\n(x -> (x -> x) 10) 5 => (x -> x) 10 => 10 - ожидается, что будет так\r\n\r\n\r\n\r\n2. более корректная формулировка:\r\n\r\n(x -> E) a  - это Е, в котором все вхождения x заменены на a, но:\r\n\r\n- заменяем только свободные вхождения x в E\r\n\r\n- иногда нужно делать альфа-конверсию, чтобы свободное вхождение некоторой переменной в a не превращалось в связанное в E при подстановке\r\n\r\n(x -> (y -> x)) y => y -> y - некорректно\r\n\r\n(x -> (y -> x)) y => z -> y - корректно\r\n\r\n\r\n\r\n\r\n\r\n-- 38.4\r\n\r\nПусть лямбда-выражение A имеет 2 _различные_ нормальные формы - B и C. Тогда, т.к. A редуцируемо к B и A редуцируемо к C, а бета-редукция для лябмда-исчислений обладает свойством конфлюентности, то существует лямбда-выражение D, к которому редуцируемы и B, и C. При этом, т.к. B и C - нормальные формы, то в них нет редексов, т.е. нельзя применить ни одной бета-редукции, а значит D получено из B и из C за 0 редукций. Но такого не может быть, т.к. B и C различны.\r\n\r\n\r\n\r\n\r\n\r\n-- 38.5\r\n\r\n(x -> y) ((x -> x x) (x -> x x))\r\n\r\nПри нормальном порядке бета-редукций в качестве редекса выберется всё лябмда-выражение, а после проведения редукции получится y, т.к. подстановка происходит по x.\r\n\r\nПри аппликативном порядке в качестве редекса выберется (x -> x x) (x -> x x), который после редукции перейдёт в себя, что ведёт к зацикливанию вычислений (т.е. процесс вычисления по Черчу не закончится).\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8382,138,'62628590','2013-12-08 20:20:38',1,'find cond (x:xs) = if cond x then (x, xs) else find cond xs\r\nreturn1 f xs = (f, xs)\r\n\r\nf >>>= g = xs -> \r\n     let \r\n		(x, xs1) = f xs \r\n     in g x xs1\r\n   \r\nf = find (>3) >>>= x ->\r\n	find (>x) >>>= y ->\r\n	return1 (x+y)','<br/>Тесты успешно пройдены!'),(8383,126,'nomeansno','2013-12-08 20:43:18',1,'Доказательство от противного:\r\n\r\nПусть N1,N2 - разные нормальные формы M.\r\n\r\nПо т. Ч.-Р. бета-редукция для лямбда исчисления обладает свойством конфлюентности, то есть из того, что M редуцируемо к N1 и М редуцируемо к N2 следует существование выражения N: N1,N2 редуцируемы к N.\r\n\r\nНо по предположению N1,N2 - нормальные формы M !? (N1,N2 - выражения, к которым нельзя применить редукцию).\r\n   --- Нет, это не совсем  корректно. Если N1 редуцируемо к N, это не противоречит тому, что N1 - нормальная форма.\r\n   --- Птому что редуцируемость может быть и за 0 редукций. Те это просто означает, что N1 редуцируема к N за 0 редукций.\r\n   --- Теорема тем не менее конечно совершенно очевидна, но попробуйте строго написать почему, пожалуйста\r\n\r\nТак как N1,N2 редуцируемы к N и N1,N2 - нормальные формы, то N1,N2 редуцируемы к N за 0 редукций и т.о. N1=N2 !?','<br/>Тесты успешно пройдены!'),(8384,125,'6053606','2013-12-08 20:50:42',1,'Пример, на котором это правило не работает:\r\n(lambda x -> (lambda x -> x + 1) 42) a\r\nА чтобы исправить правило, надо заменить \"все вхождения\" на \"все свободные вхождения\". \r\nВторая проблема связана с явлением, которое, кажется, называется \"захват переменной\". \r\nТут тоже приведу более-менее абстрактный пример, а то непонятно, как объяснить:\r\n(lambda x.lambda y.T) a\r\nто есть (lambda y.T) [x:=a]\r\nНо в a могут быть y, которые не являются y из лямбды.\r\nА теперь конкретный пример:\r\n(lambda x.lambda y.T) (succ y), а в T есть свободное вхождение x.\r\nЭто можно решить, например, переименовывая переменные или приняв соглашение, что за такой ситуацией мы следим.','<br/>Тесты успешно пройдены!'),(8385,119,'5247795','2013-12-08 21:07:33',1,'toInt n = n (+1) 0\r\n\r\ndec n = f x -> n (g h -> h (g f)) (u -> x) (u -> u)\r\n','<br/>Тесты успешно пройдены!'),(8386,142,'6053606','2013-12-08 21:19:18',0,'newtype State s a = State { runState :: s -> (a, s) }\r\n\r\ninstance Monad (State s) where\r\n  return x = State $ s -> (x, s)\r\n  m >>= f  = State $ s ->\r\n    let (a, s\') = runState m s in\r\n    runState (f a) s\'\r\n\r\nget :: State s s\r\nget = State $ s -> (s, s)\r\n\r\nput :: s -> State s ()\r\nput s = State $ \\_any -> ((), s)\r\n\r\nmain = print $ runState act [1..5] where\r\n  act :: State [Int] ()\r\n  act = do\r\n    s <- get\r\n    put $ map (+1) s','<br/>Тесты успешно пройдены!'),(8387,126,'6053606','2013-12-08 21:29:20',1,'Будем доказывать от противного. \r\nПусть A - лямбда терм, у которого две различные нормальные формы B и C. \r\nТогда по теореме Чёрча-Россера существует терм D, к которому редуцируются B и C. Но B уже в нормальной форме, поэтому B = D, а C тоже в нормальной форме, поэтому D = C, то есть B = D = C. Отсюда B = C. \r\nПришли к противоречию.','<br/>Тесты успешно пройдены!'),(8388,125,'62628590','2013-12-08 21:35:30',1,'Пример: (x -> mult (y*x) x) y\r\n\r\nНадо добавить: где множество названий переменных не пересекается. Иначе перед применением редукции нужно переименовать свободные вхождения, которые могут стать связными после применения редукции','<br/>Тесты успешно пройдены!'),(8389,120,'6053606','2013-12-08 21:57:40',1,'data LExpr = Var String\r\n           | Impl LExpr LExpr\r\n           deriving Show\r\n\r\nvars :: LExpr -> [String]\r\nvars = go [] where\r\n  go vs (Var v) = if v `elem` vs\r\n                  then vs\r\n                  else v:vs\r\n  go vs (Impl e1 e2) = go (go vs e1) e2\r\n\r\neval :: LExpr -> [(String, Bool)] -> Bool\r\neval e ctx = go e where\r\n  go (Var v) = case lookup v ctx of\r\n    Just b -> b\r\n    Nothing -> undefined\r\n  go (Impl e1 e2) =\r\n      let a = go e1\r\n          b = go e2\r\n      in not a || b\r\n\r\nuniverse :: [String] -> [[(String, Bool)]]\r\nuniverse = go where\r\n  go []     = [[]]\r\n  go (v:vs) = [(v, b):acc | b <- [True, False], acc <- go vs]\r\n\r\nisTautology :: LExpr -> Bool\r\nisTautology e = all (eval e) $ universe $ vars e\r\n','<br/>Тесты успешно пройдены!'),(8390,126,'62628590','2013-12-08 21:59:54',1,'(наглядная картинка на ваших слайдах около определения конфлюентности)\r\nПредположим, что это не так и существует две различные нормальные формы b и c. Тогда, по определению, существует форма d, редуцируемая к ним обеим. Следовательно, либо b и c не являются нормальными формами, что противоречит предположению, либо они равны, что так же противоречит. Значит, предположение неверно и форма, если она существует, лишь одна.','<br/>Тесты успешно пройдены!'),(8391,143,'6053606','2013-12-08 22:11:29',1,'toInt m = m (+1) 0\r\n\r\npair a b = f -> f a b\r\nfst\' p = p const\r\nsnd\' p = p $ a b -> b\r\n\r\nzero = f x -> x\r\ninc m = f x -> f (m f x)\r\n\r\ndec m = fst\' $ m s z where\r\n  s p = pair (snd\' p) (inc $ snd\' p)\r\n  z = pair zero zero\r\n','<br/>Тесты успешно пройдены!'),(8392,125,'480387','2013-12-08 22:19:49',0,'а) пример, когда не верно:\r\n(x-> x (x -> x)) (u r) переходит в (u r) (x -> x), а это не совсем согласуется с определением в условии задачи\r\nб) я так понимаю, что заменяться должны свободные переменные, и чтобы в A не было переменных, которые являются свободными в исходном выражении (т.е. для (x y -> E)A в A не должно быть y)\r\n','<br/>Тесты успешно пройдены!'),(8393,140,'62628590','2013-12-08 22:20:10',1,'(x (mult y y))((x xx) (x xx))','<br/>Тесты успешно пройдены!'),(8394,119,'6053606','2013-12-08 22:20:25',1,'--- Если предыдущее не очень подходит\r\n\r\ntoInt m = m (+1) 0\r\n\r\ndec m = m s z $ a b -> a where\r\n  s p f = f (p $ a b -> b) (p $ a b -> f x -> f (b f x))\r\n  z f = f (f x -> x) (f x -> x)\r\n','<br/>Тесты успешно пройдены!'),(8395,126,'5247795','2013-12-08 22:41:03',1,'Док-во. \r\nПусть =β – отношение конвертируемости (равенства). Оно определяется индуктивно:\r\n1)	M ->>β В => M =β B (->>β - многошаговая β-редукция)\r\n2)	M =β N => N =β М\r\n3)	M =β N, N =β L => M =β L\r\nЕсть следствие о существовании общего редукта из теоремы Чёрча-Россера: если M =β N, то существует терм L, такой что: М ->>β L и N ->>β L\r\nПусть λ-терм М имеет 2 нормальные формы: N1 и N2. По следствию о существовании общего редукта имеем: N1 ->>β L и N2 ->>β L для некоторого L. Но из этого следует, что N1 ≡ L и N2 ≡ L, из чего следует, что N1 ≡ N2.\r\n','<br/>Тесты успешно пройдены!'),(8396,125,'480387','2013-12-08 22:43:32',1,'а) пример, когда не верно:\r\n(x-> x (x -> x)) (u r) переходит в (u r) (x -> x), а это не совсем согласуется с определением в условии задачи\r\nб) я так понимаю, что заменяться должны свободные переменные, и чтобы в A не было переменных, которые являются свободными в исходном выражении (т.е. для (x y -> E)A в A не должно быть y)\r\n','<br/>Тесты успешно пройдены!'),(8397,140,'480387','2013-12-08 22:47:44',1,'наверно, подойдет такой пример:\r\n\r\n(x->1)((x->xx)(x->xx)) \r\n\r\nпри нормальном - 1\r\nиначе не вычислимо','<br/>Тесты успешно пройдены!'),(8398,140,'5247795','2013-12-08 23:41:48',1,'(x.y)((x.x x)(x.x x))\r\nПри аппликативном порядке циклится:\r\n(x.y)((x.x x)(x.x x)) -> (x.y)((x.x x)(x.x x)(x.x x)) -> (x.y)((x.x x)(x.x x)(x.x x)(x.x x)) -> ...\r\nПри нормальном порядке сразу выдает ответ:\r\n(x.y)((x.x x)(x.x x)) -> y','<br/>Тесты успешно пройдены!'),(8399,137,'toskira','2013-12-09 00:12:02',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Text;\r\n\r\nusing System.Threading.Tasks;\r\n\r\nusing System.Numerics;\r\n\r\nusing System.Globalization;\r\n\r\n\r\n\r\nnamespace _37_1 {\r\n\r\n\r\n\r\n	class Program {\r\n\r\n\r\n\r\n		private const int THREAD_COUNT = 7;\r\n\r\n\r\n\r\n		private static BigInteger Sqrt(BigInteger n) {\r\n\r\n			BigInteger rootN = n;\r\n\r\n			int count = 0;\r\n\r\n			int bitLength = 1; // There is a bug in finding bit length hence we start with 1 not 0\r\n\r\n			while (rootN / 2 != 0) {\r\n\r\n				rootN /= 2;\r\n\r\n				bitLength++;\r\n\r\n			}\r\n\r\n			bitLength = (bitLength + 1) / 2;\r\n\r\n			rootN = n >> bitLength;\r\n\r\n\r\n\r\n			BigInteger lastRoot = BigInteger.Zero;\r\n\r\n			do {\r\n\r\n				if (lastRoot > rootN) {\r\n\r\n					if (count++ > 1000) // Work around for the bug where it gets into an infinite loop\r\n\r\n                    {\r\n\r\n						return rootN;\r\n\r\n					}\r\n\r\n				}\r\n\r\n				lastRoot = rootN;\r\n\r\n				rootN = (BigInteger.Divide(n, rootN) + rootN) >> 1;\r\n\r\n			}\r\n\r\n			while (!((rootN ^ lastRoot).ToString() == \"0\"));\r\n\r\n			return rootN;\r\n\r\n		}\r\n\r\n\r\n\r\n		class Pair {\r\n\r\n			public int a;\r\n\r\n			public int b;\r\n\r\n\r\n\r\n			public Pair(BigInteger a, BigInteger b) {\r\n\r\n				this.a = (int)a;\r\n\r\n				this.b = (int)b;\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n		static void Main(string[] args) {\r\n\r\n			Console.WriteLine(\"Check, if number is prime\");\r\n\r\n			BigInteger n = BigInteger.Parse(Console.ReadLine(), NumberStyles.Integer);\r\n\r\n			Task<bool>[] tasks = new Task<bool>[THREAD_COUNT];\r\n\r\n			BigInteger range = Sqrt(n) - 1;\r\n\r\n			BigInteger step = range / THREAD_COUNT;\r\n\r\n			BigInteger mod = range % THREAD_COUNT;\r\n\r\n			BigInteger left = 2;\r\n\r\n			BigInteger length = step + 1;\r\n\r\n			for (int i = 0; i < THREAD_COUNT; i++) {\r\n\r\n				if (i == mod) {\r\n\r\n					length--;\r\n\r\n				}\r\n\r\n				BigInteger innerLeft = new BigInteger(left.ToByteArray());\r\n\r\n				BigInteger innerLength = new BigInteger(length.ToByteArray());\r\n\r\n				tasks[i] = new Task<bool>(() => {\r\n\r\n					BigInteger right = innerLeft + innerLength;\r\n\r\n					for (BigInteger k = innerLeft; k < right; k++) {\r\n\r\n						if (n % k == BigInteger.Zero) {\r\n\r\n							return false;\r\n\r\n						}\r\n\r\n					}\r\n\r\n					return true;\r\n\r\n				});\r\n\r\n				left += length;\r\n\r\n			}\r\n\r\n			var continuation = Task.Factory.ContinueWhenAll(tasks, (antecedents) => {\r\n\r\n				bool result = true;\r\n\r\n				for (int i = 0; i < THREAD_COUNT; i++) {\r\n\r\n					result &= antecedents[i].Result;\r\n\r\n				}\r\n\r\n				if (result) {\r\n\r\n					Console.WriteLine(\"{0} is prime\", n);\r\n\r\n				} else {\r\n\r\n					Console.WriteLine(\"{0} is not prime\", n);\r\n\r\n				}\r\n\r\n			});\r\n\r\n			for (int i = 0; i < THREAD_COUNT; i++) {\r\n\r\n				tasks[i].Start();\r\n\r\n			}\r\n\r\n			continuation.Wait();\r\n\r\n		}\r\n\r\n	}\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8400,141,'toskira','2013-12-09 00:36:21',1,'data Expr = Num Int\r\n          | Var String\r\n          | Let String Expr Expr\r\n          | Add Expr Expr\r\n          | Mult Expr Expr\r\n          | LetFunc String String Expr Expr\r\n          | Call String Expr\r\n\r\nfind v ((a, b):t) = if(v == a) then b else find v t\r\nfind_f name ((f, v, e, l):t) = if(f == name) then (v, e, l) else find_f name t\r\n\r\neval (Num a) _ _ = a\r\neval (Var v) l _ = find v l\r\neval (Let s (Num v) e) l lf = eval e ((s, v):l) lf\r\neval (Add e1 e2) l lf = (eval e1 l lf) + (eval e2 l lf)\r\neval (Mult e1 e2) l lf = (eval e1 l lf) * (eval e2 l lf)\r\neval (LetFunc f v e1 e2) l lf = eval e2 l ((f, v, e1, l):lf)\r\neval (Call f e) l lf = let (v, ie, l\') = find_f f lf\r\n                       in eval ie ((v, eval e l lf):l\') lf','<br/>Тесты успешно пройдены!'),(8401,137,'5247795','2013-12-09 01:20:33',2,'--- Я наверное плохо формулировал задачу, но в ней предполагадось, что вы будете использовать\r\n--- именно continuation (ContinueWith например). А не await.\r\n--- Попробуйте, пожалуйста, что-то такое написать?\r\n\r\nusing System;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nnamespace AsyncDemo {\r\n    class Program {\r\n        static void Main(string[] args) {\r\n            Test2();\r\n            while(true) {\r\n                Console.Write(\"-\");\r\n                Console.Out.Flush();\r\n                Thread.Sleep(20);\r\n            }\r\n        }\r\n        static async void Test2() {\r\n            Task<string> task = new AsyncWorker().WorkAsync();\r\n            string message = await task;\r\n            Console.WriteLine(message);\r\n        }\r\n    }\r\n    class AsyncWorker {\r\n        public Task<string> WorkAsync() {\r\n            Task<string> task = new Task<string>(Worker);\r\n            task.Start();\r\n            return task;\r\n        }\r\n        string Worker() {\r\n            Console.WriteLine(\"Step 1\");\r\n            Thread.Sleep(500);\r\n            Console.WriteLine(\"Step 2\");\r\n            Thread.Sleep(500);\r\n            return \"Done\";\r\n        }\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(8402,143,'5247795','2013-12-09 01:46:01',2,'toInt n = n (+1) 0\r\n\r\ninc e = f x -> f (e f x)\r\n\r\npair x y = x y f -> f (x y)\r\n  --- Это что-то немного странное. А вы как получили такое решение? В смысле, сами придумали,\r\n  --- или откуда-то взяли? В любом случае, тут явно опечатка.\r\n\r\nfirst p = p -> p (x y -> x)\r\n\r\nsecond p = p -> p (x y -> y)\r\n\r\nnext p = p -> pair (second p) (inc (second p)) \r\n\r\ndec n = first (n next (pair 0 0))\r\n','Не удалось вычислить выражение \"let ch3 f x = f (f (f x)) in toInt(dec ch3)\", проверьте правильность синтаксиса'),(8403,138,'641524','2013-12-09 02:53:03',1,'return1 x xs = (x, xs)','<br/>Тесты успешно пройдены!'),(8404,138,'5247795','2013-12-09 11:37:56',1,'find cond (x:xs) = if cond x then (x,xs) else find cond xs\r\n\r\n(>>>==) f1 f2 xs1 = let\r\n\r\n   (x, xs2) = f1 xs1\r\n\r\n   in f2 x xs2\r\n\r\nreturn1 f xs2 = (f, xs2)\r\n\r\nf = find (>3) >>>== x -> find (>x) >>>== y -> return1 (x+y)\r\n','<br/>Тесты успешно пройдены!'),(8405,137,'5247795','2013-12-09 11:41:17',1,'using System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nclass ContinuationState\r\n{\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        string userID = null;\r\n\r\n        var loadUserDataTask = new Task(() =>\r\n        {\r\n            Console.WriteLine(\"Loading User Data\");\r\n            Thread.Sleep(2000);\r\n            userID = \"1234\";\r\n            Console.WriteLine(\"User data loaded\");\r\n        });\r\n\r\n        var loadUserPermissionsTask = loadUserDataTask.ContinueWith(t =>\r\n        {\r\n            Console.WriteLine(\"Loading User Permissions for user {0}\", userID);\r\n            Thread.Sleep(2000);\r\n            Console.WriteLine(\"User permissions loaded\");\r\n        });\r\n\r\n        loadUserDataTask.Start();\r\n        loadUserPermissionsTask.Wait();\r\n\r\n        Console.WriteLine(\"CRM Application Loaded\");\r\n\r\n        loadUserDataTask.Dispose();\r\n        loadUserPermissionsTask.Dispose();\r\n\r\n        Console.ReadKey();\r\n    }\r\n}','<br/>Тесты успешно пройдены!'),(8406,137,'nbumakov','2013-12-09 12:20:30',1,'﻿using System;\r\n\r\nusing System.Collections.Generic;\r\n\r\nusing System.Linq;\r\n\r\nusing System.Threading.Tasks;\r\n\r\n\r\n\r\nnamespace Haskell\r\n\r\n{\r\n\r\n    class Task37_1\r\n\r\n    {\r\n\r\n        public static void Main(string[] args)\r\n\r\n        {            \r\n\r\n            Task<String> sortTask = new Task<String>(() =>\r\n\r\n            {\r\n\r\n                var numbers = new List<int>();\r\n\r\n                Random random = new Random();\r\n\r\n                for (int i = 0; i <= 5; i++)\r\n\r\n                {\r\n\r\n                    numbers.Add(random.Next(1, 100));\r\n\r\n                }                \r\n\r\n                \r\n\r\n                while (!IsSorted(numbers))\r\n\r\n                {\r\n\r\n                    Shuffle(numbers);\r\n\r\n                }\r\n\r\n                return string.Join(\", \", numbers);\r\n\r\n            });\r\n\r\n\r\n\r\n            Task<string> continuation = sortTask.ContinueWith((antecedent) =>\r\n\r\n            {\r\n\r\n                Console.WriteLine(\"Sorted array is {0}.\", antecedent.Result);\r\n\r\n                return \"Success!\";\r\n\r\n            });\r\n\r\n\r\n\r\n            sortTask.Start();\r\n\r\n\r\n\r\n            Console.WriteLine(\"Sorting...\");\r\n\r\n            Console.ReadLine();\r\n\r\n        }\r\n\r\n\r\n\r\n        private static IList<int> Shuffle(IList<int> list)\r\n\r\n        {\r\n\r\n            Random rng = new Random();\r\n\r\n            int n = list.Count;\r\n\r\n            while (n > 1)\r\n\r\n            {\r\n\r\n                n--;\r\n\r\n                int k = rng.Next(n + 1);\r\n\r\n                int value = list[k];\r\n\r\n                list[k] = list[n];\r\n\r\n                list[n] = value;\r\n\r\n            }\r\n\r\n            return list;\r\n\r\n        }\r\n\r\n\r\n\r\n        public static bool IsSorted(IList<int> list)\r\n\r\n        {\r\n\r\n            var arr = list.ToArray();\r\n\r\n            for (int i = 1; i < arr.Length; i++)\r\n\r\n            {\r\n\r\n                if (arr[i - 1] > arr[i])\r\n\r\n                {\r\n\r\n                    return false;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return true;\r\n\r\n        }    \r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8407,138,'nbumakov','2013-12-09 12:21:47',1,'f >>>= g = xs -> \r\n     let (x, xs1) = f xs \r\n     in g x xs1\r\n     \r\nreturn1 f xs = (f, xs)\r\n\r\nff = find (>3) >>>= x->\r\n        find (>x) >>>= y ->\r\n           return1 (x+y) ','<br/>Тесты успешно пройдены!'),(8408,143,'nomeansno','2013-12-09 23:27:34',1,'toInt ch_num = ch_num (+1) 0\r\n\r\ninc ch_num = (f x -> f (ch_num f x))\r\n\r\n\r\n\r\nzero = f x -> x\r\n\r\n\r\n\r\ndec = ch_num -> fst (ch_num s z) ; z = (zero, zero); s = (x,y) -> (y,inc y)\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8409,143,'1835693','2013-12-10 16:48:02',1,'toInt wrap = wrap (x -> x + 1) 0\r\n\r\ninc wrap f x = f $ wrap f x\r\n\r\n-- Первое число Черча\r\nchurchFirst = f x -> x\r\n\r\n-- Будем считать числа Черча парами - текущее и предыдущее значение\r\n-- Первая пара будет просто состоять из двух первый значений (==0)\r\nfirstPair = (churchFirst, churchFirst)\r\n-- Для вычисления следующей пары нужно переписать предыдущее значение текущим и увеличить следующее значение\r\nnextPair = p -> (snd p, inc $ snd p)\r\n\r\n-- Поскольку мы храним в паре предыдущее значение, достаточно просто его взять\r\ndec = \r\n -> fst $ n nextPair firstPair\r\n','<br/>Тесты успешно пройдены!'),(8410,120,'1835693','2013-12-10 18:20:32',1,'-- Var - переменная, Impl - импликация\r\n\r\ndata Term a = Var a | Impl (Term a) (Term a)\r\n\r\n\r\n\r\nisTautology term = isTautologyH (getSubstitutions $ simplifyVars $ getVars term) term\r\n\r\n\r\n\r\n-- Проверяет терм на тавтологию путем подстановок значений переменным\r\n\r\nisTautologyH []       term = True\r\n\r\nisTautologyH (s:subs) term = calculate s term && isTautologyH subs term\r\n\r\n\r\n\r\ngetVars = getVarsH []\r\n\r\n\r\n\r\n-- Получает все переменные из терма\r\n\r\ngetVarsH vars (Var var) = var : vars\r\n\r\ngetVarsH vars (Impl a b) = resultVars\r\n\r\n                           where resultVars = getVarsH newVars a\r\n\r\n                                 newVars    = getVarsH vars b\r\n\r\n\r\n\r\n-- Убирает повторы из списка переменных\r\n\r\nsimplifyVars []     = []\r\n\r\nsimplifyVars (v:vs) | elem v vs = simplifyVars vs\r\n\r\n                    | otherwise = v : simplifyVars vs\r\n\r\n\r\n\r\n-- Получение всех подстановок для списка переменных\r\n\r\ngetSubstitutions (v:[]) = [[(v, True)], [(v, False)]]\r\n\r\ngetSubstitutions (v:vs) = map ((v, True) :) (getSubstitutions vs) ++ map ((v, False) :) (getSubstitutions vs)\r\n\r\n\r\n\r\n-- Вычисляет значение терма при конкретной подстановке\r\n\r\ncalculate sub (Var a)    = getValue sub a\r\n\r\ncalculate sub (Impl a b) = isImpl (calculate sub a) (calculate sub b)\r\n\r\n\r\n\r\n-- Получает значение переменной из подстановки\r\n\r\ngetValue sub a = snd $ head $ filter (x -> fst x == a) sub\r\n\r\n\r\n\r\n-- Проверяет, верна ли импликация\r\n\r\nisImpl True False = False\r\n\r\nisImpl _    _     = True\r\n\r\n\r\n\r\n-- Примеры:\r\n\r\n-- A -> A\r\n\r\n-- isTautology (Impl (Var 1) (Var 1))\r\n\r\n-- (A -> B) -> ((B -> C) -> (A -> C))\r\n\r\n-- isTautology (Impl (Impl (Var 1) (Var 2)) (Impl (Impl (Var 2) (Var 3)) (Impl (Var 1) (Var 3))))\r\n\r\n-- (A -> B) -> (B -> A)\r\n\r\n-- isTautology (Impl (Impl (Var 1) (Var 2)) (Impl (Var 2) (Var 1)))\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8411,119,'1835693','2013-12-11 18:42:27',1,'toInt wrap = wrap (x -> x + 1) 0\r\n\r\ninc wrap f x = f $ wrap f x\r\n\r\n-- Описание пары через лямбда-выражения\r\npair a b = f -> f a b\r\n\r\npfst p = p (a b -> a)\r\npsnd p = p (a b -> b)\r\n\r\nchurchFirst = f x -> x\r\n\r\nfirstPair = pair churchFirst churchFirst\r\nnextPair = p -> pair (psnd p) (inc $ psnd p)\r\n\r\ndec = \r\n -> pfst $ n nextPair firstPair\r\n','<br/>Тесты успешно пройдены!'),(8412,144,'nomeansno','2013-12-15 16:43:24',1,'y f = f (y f)\r\n\r\nisPower2\' f = \r\n -> if (n `mod` 2 == 0) && n > 1 then f (n `div` 2) else n == 1\r\n\r\nisPower2 = y isPower2\'\r\n\r\n\r\n','<br/>Тесты успешно пройдены!'),(8413,145,'nomeansno','2013-12-15 18:44:17',2,'--- Но все-таки, обоснуйте пожалуйста почему она не является тавтологией. Это очень просто, но все-таки.. \r\nТак как логическая формула (a -> b) -> (b -> a) не является тавтологией в классическом исчислении высказываний (и следовательно, не является тавтологией в интуиционистской логике высказываний), то из соответствия Карри-Ховарда следует, что функции типа (a -> b) -> (b -> a) не существует.','<br/>Тесты успешно пройдены!'),(8414,145,'nomeansno','2013-12-15 23:14:37',1,'С помощью формулы выражения импликации через дизъюнкцию и отрицание (x=>y экв. ¬x+y) и закона де Моргана (¬(x&y) экв. ¬x+¬y) получим, что (a=>b)=>(b=>a) экв. ¬a&¬b+¬b+a и далее по закону поглощения в итоге получим, что (a=>b)=>(b=>a) экв. a+¬b.\r\n\r\nТак как a+¬b (ложь при a=0,b=1) не является тавтологией, то и экв. ей исх. формула не является тавтологией. (вообще говоря, можно сразу просто сказать,что при a=0,b=1 (a=>b)=>(b=>a) принимает значение ложь и поэтому не явл. тавтологией)','<br/>Тесты успешно пройдены!'),(8415,142,'6053606','2013-12-21 14:39:13',0,'newtype State s a = State { runState :: s -> (a, s) }\r\n\r\ninstance Monad (State s) where\r\n  return x = State $ s -> (x, s)\r\n  m >>= f  = State $ s ->\r\n    let (a, s\') = runState m s in\r\n    runState (f a) s\'\r\n\r\nget :: State s s\r\nget = State $ s -> (s, s)\r\n\r\nput :: s -> State s ()\r\nput s = State $ \\_any -> ((), s)\r\n\r\nmain = print $ runState act [1..5] where\r\n  act :: State [Int] ()\r\n  act = do\r\n    s <- get\r\n    put $ map (+1) s','<br/>Тесты успешно пройдены!'),(8416,26,'517309','2014-01-09 05:18:10',0,'ddd','Не удалось вычислить выражение \"rev [1,2,3] == [3,2,1]\", проверьте правильность синтаксиса'),(8417,18,'517309','2014-01-10 17:46:23',0,'','Не удалось вычислить выражение \"f 1\", проверьте правильность синтаксиса'),(8418,29,'517309','2014-03-12 11:38:43',0,'','Не удалось вычислить выражение \"checkDifferent [3,2,7]\", проверьте правильность синтаксиса');

/*Table structure for table `task` */

DROP TABLE IF EXISTS `task`;

CREATE TABLE `task` (
  `TaskID` int(11) NOT NULL AUTO_INCREMENT,
  `TaskForHometask` int(11) NOT NULL,
  `HometaskID` int(11) NOT NULL,
  `Condition` mediumtext NOT NULL,
  `Price` int(11) NOT NULL,
  PRIMARY KEY (`TaskID`),
  UNIQUE KEY `TaskForHometask` (`TaskForHometask`,`HometaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=146 DEFAULT CHARSET=utf8;

/*Data for the table `task` */

insert  into `task`(`TaskID`,`TaskForHometask`,`HometaskID`,`Condition`,`Price`) values (18,1,1,'Описать функцию f n, которая вычисляет \r\n 1+1/(1+1/(1+ ...+1/1)) - n дробей\r\n\r\nПример вызова:\r\n f 3\r\nДолжно получиться 1+1/(1+1/(1+1/1)), то есть 1.6666..\r\n        \r\n        ',1),(19,3,1,'Описать функцию \r\n sumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\n sumsin 2\r\nДолжно получиться sin(1+2)/(sin 1+sin 2); это равно примерно 0.08 \r\n        ',1),(20,4,1,'Описать функцию sumfact n: \r\n sumfact n = 1!+2!+...+n!\r\nВ решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.\r\n\r\nПример вызова:\r\nsumfact 3\r\nРезультат должен быть равен 9.\r\n        \r\n        \r\n        ',1),(21,5,1,'* Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?\r\nНапример, для n = 9 существуют такие последовательности:\r\n 1 2 6, 1 3 5, 1 8, 2 3 4, 2 7, 3 6, 4 5, 9\r\n, то есть ответ на вопрос равен 8\r\n\r\nОпишите функцию nseq n, которая вычисляет количество таких последовательностей.\r\n\r\nПример вызова:\r\n nseq 9\r\nРезультат должен быть равен 8.\r\n        \r\n        ',1),(22,1,2,'*Дополнительная задача*\r\nОпишите функцию g, которая для данного целого числа, проверяет, можно ли его представить в виде суммы двух различных простых чисел, и возвращает True или False.\r\n\r\nПримеры вызова:\r\n  g 6 должно быть равно False\r\n  g 7 должно быть равно True (так как 7 = 2 + 5).\r\n\r\nЗамечание:\r\n О похожей (но не совсем такой же)задаче написан целый роман см. например: http://royallib.ru/book/doksiadis_apostolos/dyadyushka_petros_i_problema_goldbaha.html        \r\n        \r\n        ',1),(23,2,2,'*Дополнительная задача*\r\nОпишите функцию c n, которая для данного целого числа n вычисляет, сколько есть способов представить данное число, как сумму нескольких различных положительных чисел, причем все числа должны быть попарно взаимно простыми.\r\n\r\nПример вызова:\r\n с 10 - должно получиться 6, потому что есть 6 таких последовательностей (1 2 7, 1 4 5, 1 9, 2 3 5, 3 7, 10).\r\n\r\nЗамечание: В этой задаче, видимо, удобнее использовать списки, которые мы еще пока не проходили. Но на ближайшем занятии мы их пройдем, так что если кто про них не знает - подождите до понедельника. (А можно, кстати и без списков обойтись, если придумать одну хитрость).\r\n        ',1),(24,2,1,'Описать функцию b n, которая вычисляет \r\n 0+1/(1+1/(2+1/(3+ ...+1/n))) - n дробей\r\n\r\nПример вызова:\r\n b 3\r\nДолжно получиться 0+1/(1+1/(2+1/3)), то есть 0.7\r\n        \r\n        \r\n        ',1),(25,1,3,'Описать функцию minlist, которая ищет минимальный элемент в данном списке.\r\n\r\nПример вызова:\r\n  minlist [3,2,7]\r\nОтвет должен быть равен 2.\r\n\r\nЗамечание: На самом деле, конечно, в Хаскеле есть такая стандарная функция (называется minimum), но, пожалуйста, в этой задаче вы ее не используйте.\r\n        \r\n        ',1),(26,3,3,'Описать фунццию rev, которая для списка возвращает список из тех же элементов, но идуших в обратном порядке.\r\n\r\nПример вызова:\r\n  rev [1, 3, 7] \r\n- должен получиться список [7, 3, 1].\r\n\r\nЗамечания:\r\n- Желательно (но не обязательно) описать эту функцию так, чтобы ее время работы было O(n). Технически это означает, что желательно написать функцию, в которой не будет использоваться приписывание в конец списка с помощью ++[x].\r\n- Но, если так не получиться, присылайте любое решение, какое придумаете.\r\n- Конечно, в этой задаче нельзя использовать стандартную функцию reverse.\r\n        \r\n        \r\n        ',1),(29,5,3,'Описать функцию checkDifferent, которая возвращает True, если все элементы в списке разные, и False, если среди них есть одинаковые.\r\n\r\nПримеры вызова:\r\n  checkDifferent [3,2,7]\r\nОтвет должен быть равен True.\r\n  checkDifferent [3,2,7,5,7,8]\r\nОтвет должен быть равен False (два раза встречается число 7).',1),(27,2,3,'Описать функцию minsum, которая ищет минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nПример вызова:\r\n  minsum [1,8,3,2,7]\r\nОтвет должен быть равен 5 (3+2).\r\n        ',1),(28,4,3,'Описать функцию \r\n  check cond xs\r\n, которая для данного списка xs и логической функции cond проверяет, верно ли, что в списке есть элемент, для которого cond возвращает True. Результат должен быть равен True, если такой элемент есть, и False, если его нет.\r\n\r\nПримеры вызова:\r\n check (\\x->x>5) [3,2,7,4]\r\nОтвет должен быть равен True, потому что в списке есть число, большее 5 (это число 7). \r\n\r\n check (\\x->x<1) [3,2,7,4]\r\nОтвет должен быть равен False, потому что в списке нет чисел, меньших 1. \r\n\r\nЗамечание: И такая стандартная функция в Хаскеле есть (называется any), но, пожалуйста, в этой задаче вы ее не используйте.        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        ',1),(30,1,4,'*Доп.задача*\r\nНаписать функцию parts, которая для данного списка проверяет, можно ли его разбить \r\nна несколько строго возрастающих кусков одинаковой длины. \r\n\r\nДлина кусков должна быть не меньше 2. Кусок может быть и только один.\r\n\r\nПримеры вызова:\r\n parts [1, 2, 8, 2, 5, 6]\r\n parts [1, 2, 3, 4, 5]\r\n parts [1, 2, 1, 2, 3, 4]\r\nВо всех этих случаях ответ должен быть равен True.\r\n parts [4, 6, 3, 5, 7]\r\nТут ответ должен быть равен False.\r\n        ',1),(31,2,4,'*Доп.задача, немного посложнее (но не очень сложная)*\r\nНаписать функцию parts2, которая проверяет, можно ли в данном списке выбрать ровно половину элементов, чтобы\r\n- они строго возрастали\r\n- в оставшейся половине элементы тоже строго возрастали.\r\nВ этой задаче элементы не обязательно брать подряд.\r\n\r\nПримеры вызова:\r\n parts2 [1, 3, 1, 8, 4, 9]\r\nОтвет должен быть True (разбивается, например, на \r\n[1, 3, 4] и [1, 8, 9])\r\n parts2 [1, 2, 3, 5, 1, 7]\r\nответ должен быть False.\r\n\r\nЗамечания:\r\n- в этой задаче решение должно быть более-менее эффективным. Т.е., если присланное решение покажется мне очень неэффективным, я могу попросить его улучшить, даже если всегда дает правильные результаты \r\n- я знаю очень эффективное решение, со сложностью,  видимо O(N^2), а мб. немного больше (O(N^3)?), в зависимости от реализации. Но вполне подойдут и менее эффективные. \r\n        ',1),(34,10,47,'*Доп. задача*\r\nОчень простая функция высшего порядка на C++\r\n\r\nНаписать на C++ шаблон функции integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:\r\n- f - функция или лямбда выражение \r\n- a, b - пределы интегрирования.\r\nПример вызова:\r\n\r\n   double result = integral([](double x) { return x*x; }, 0, 1);\r\n\r\nМетод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций. \r\n\r\nПро то, зачем эти задачки, как их сдавать и т.д. см. http://msimuni.wikidot.com/fp-dop2\r\n        \r\n        \r\n        \r\n        \r\n        ',1),(33,1,5,'*Доп. задача*\r\nОчень простая функция высшего порядка на C#\r\n\r\nНаписать на C# функцию (статический метод) Integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:\r\n- f - функция (статический метод или лямбда выражение) \r\n- a, b - пределы интегрирования.\r\nПример вызова:\r\n\r\ndouble result = Integral(x => x*x, 0, 1);\r\n\r\nМетод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций.\r\n\r\nЗамечания:\r\n- Пример похожей программы есть вот тут: http://msimuni.wikidot.com/fp-dop2\r\n- Там же всякие замечания про то, зачем эти задачки про \"обычные\" языки, как их сдавать и т.д. \r\n- Если хотите, можете сделать задачу на С++ или на каком-нибудь другом \"обычном\" языке. Если есть сомнения, подойдет ли тот или иной язык, пишите.\r\n\r\n        ',1),(35,1,6,'Опишите функцию isosc (от слова isosceles - равнобедренный), у которой три параметра - пары целых чисел, и которая возвращает True, если соответствующие точки на плоскости задают равнобедренный треугольник, а иначе False.\r\n\r\nПримеры вызова:\r\n  isosс (0, 2) (2, 0) (2,2)\r\n     - результат должен быть равен True\r\n  isosс (-3, 2) (2, 0) (2,2)\r\n     - результат должен быть равен False\r\n        \r\n        ',1),(36,2,6,'Описать функцию cubeTable, которая для данного n возвращает список пар чисел (i, i в кубе) для всех i от 1 до n.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но, видимо, особо не нужно), определять свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n  cubeTable 4\r\nДолжно получиться [(1, 1), (2, 8), (3, 27), (4, 64)]\r\n        ',1),(37,3,6,'Определить функцию minsum, такую же, как в задаче 3.2. Т.е. функция должна искать минимум суммы двух стоящих рядом элементов в данном списке.\r\n\r\nДополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но не очень нужно), определать свои не рекурсивные функции.\r\n\r\nПример вызова:\r\n minsum [1,8,3,2,7] \r\nОтвет должен быть равен 5 (3+2).\r\n\r\n        \r\n        ',1),(38,4,6,'Описать функцию height, хоторая ищет высоту данного дерева. \r\n\r\nЗамечание: В задаче вы сначала должны описать data для дерева. И его надо описать точно так же, как на занятии. Извините за ограничение вашей творческой свободы, но это, понятно, ограничение системы тестирования..\r\n\r\nПримеры вызова:\r\n  height (Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  height (Node 1 (Node 1 Empty Empty) Empty)\r\nОтвет должен быть 1\r\n        \r\n        \r\n        ',1),(39,5,6,'* Описать функцию minHeight, хоторая для данного дерева возвращает минимум расстояния от корня до какого-нибудь листа. \r\n\r\nЗамечание: В этой задаче _обязательно_ должна быть реализована какая-то из оптимизаций, о которой мы говорили на занятии. (Ну, или что-то аналогичное)\r\n\r\nНапоминание: Лист - это вершина, у которой и левое и правое поддеревья пустые.\r\n\r\nПримеры вызова:\r\n  minHeight(Node 1 Empty Empty)\r\nОтвет должен быть 0\r\n  minHeight (Node 1 \r\n               (Node 2 \r\n                  (Node 3 Empty Empty)\r\n                   Empty)\r\n               (Node 4 Empty Empty))\r\nОтвет должен быть 1 (расстояние от корня до вершины 4)\r\n        \r\n        ',1),(40,1,9,'\"Единичная матрица\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию identity n, которая возвращает список списков, соответствующий единичной матрице n на n. Т.е.  элементы на главной диагонали д.б. равны 1, а все остальные элементы равны 0.\r\n\r\nПример вызова:\r\n  identity 4\r\nДолжно получиться:\r\n [[1, 0, 0, 0],\r\n  [0, 1, 0, 0],\r\n  [0, 0, 1, 0],\r\n  [0, 0, 0, 1]]\r\n        ',1),(41,2,9,'Опишите две функции, countOdd и countOdd1, которые для данного списка вычисляют количество нечетных чисел в этом списке. (Т.е. надо написать две версии одной функции).\r\n\r\nДополнительные условия:\r\n- В функции countOdd можно использовать _только_ стандартную функцию foldr. Можно (но особо не нужно) задавать свои нерекурсивные функции. Можно,  \r\nконечно, использовать лямбда-выражения.\r\n\r\n- В функции countOdd1 можно использовать любые стандартные функции, и тоже, если надо, можно использовать свои нерекурсивные функции и лямбда-выражения. Но _нельзя_ определять свои рекурсивные функции.\r\n\r\nПример вызова:\r\n  countOdd [2, 3, 4, 8, 5, 33, 9]\r\nОтвет должен быть равен 4\r\n\r\n        ',1),(42,3,9,'Опишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl (т.е. сворачивает все элементы слева направо).\r\n\r\nПример вызова:\r\n  myfoldl (+) 0 [1,2,3]\r\nФункция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить именно в таком порядке.\r\n        ',1),(43,1,7,'*Доп задача, до 3.10*\r\nУ функции два параметра - целые числа a и b. Точно известно, что они взаимно простые. Функция должна вернуть такую пару целых чисел x и y, что a*x + b*y == 1. (Таких пар, конечно, бесконечно много, можно вернуть любую).\r\n\r\nПример вызова:\r\n euclid 3 5\r\nДолжно получиться (2, -1), потому что 3*2+5*(-1) == 1\r\n\r\nЗамечания:\r\n- Если a и b не взаимно простые, то функция может делать что угодно (например, аварийно завершаться, или выдавать любой ответ).\r\n- Желательно, чтобы функция быстро работала для _очень_ больших чисел, например, для 2^100 и 3^100. Но, если не получится, напишите любое решение, не обязательно очень эффективное (например, которое ищет решения перебором).\r\n- Подсказка: идея, которую можно использовать для эффективного решения, была впервые опубликована примерно в 300 г. до н.э. :)\r\n        \r\n        \r\n        ',1),(44,2,7,'*Доп задача, до 3.10*\r\nОписать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:\r\n\r\na*x+b*y+c*z=d\r\nk*x+l*y+m*z=n\r\n\r\nЗамечания: \r\n- Что делать, если таких чисел нет - на ваше усмотрение. Можно выдать ошибку, можно вернуть (0, 0, 0) и т.д. В тестах таких случаев не будет.\r\n- Числа в тестах могут быть достаточно большими для того, чтобы эту задачу не было смысла решать простым перебором, надо придумать что-то более эффективное.\r\n- Эта задача не то чтобы очень сложная, но решение, которое я знаю - довольно громоздкое, в нем надо рассматривать разные вырожденные случаи и т.д.. Т.е. это для тех, кому интересно решить что-то немного посложнее. Но зато за нее будет 2 балла.     \r\n        \r\n        ',2),(45,1,8,'*Задача (скорее упражнение) на \"обычном\" языке (дополнительная, до 4.10 включительно*\r\n\r\nВ С# для контейнеров определен метод Any, который позволяет проверить, есть ли в контейнере элемент, удовлетворяющий данному условию. И есть аналогичный метод All.  Вот примеры их вызовов:\r\n\r\n  int [] a = {-1, 2, -3, 4};\r\n  bool b = a.Any(x => x > 0);     // Верно, ли что в массиве есть положительный элемент?\r\n  b = a.All(x => x > 0);         // Верно, ли что все элементы в массиве положительные?\r\n\r\nИспользуя только эти методы и лямбда выражения, проверить для данного массива массивов (или, если хотите, списка списков), \r\nчто в каждом из массивов есть хотя бы один четный элемент.\r\n\r\nЗамечания:\r\n- Задачу можно писать и на С++, там есть похожие функции any_of, all_of и даже еще функция none_of. А можете писать на любом \"обычном\" языке, в которм есть аналогичные возможности.\r\n- На эту задачу тестов нет, вы просто можете выложить в систему код, и я его просмотрю. Но код должен быть таким, чтобы его можно было скомпилировать и запустить, с каким-нибудь примером вызова.\r\n\r\n        \r\n        ',1),(128,1,11,'*Простая задача про карринг на C#. Дополнительная, до 11.10*\r\n\r\nВступительная история:\r\n\r\nПусть у нас есть знакомый программист Василий, которому часто надо для списков целых положительных чисел проверять, верно ли, что все они содержат какую-то данную цифру. Т.е. типичная задача Василия - что-то вроде:\r\nПроверить, верно ли что в массиве a все числа содержат цифру 7.\r\n\r\nВасилий написал вспомогательную функцию CheckDigit c параметрами a - цифра, которую мы ищем и i - целое число. И вызывает ее как-то так:\r\n\r\n  bool b = a.All(i => CheckDigit(7, i));\r\n\r\nНо однажды у нему пришел его друг, функциональный программист Петр, и сказал: ты же можешь воспользоваться каррингом! И написать функцию CheckDigitCurried, которую можно вызывать как-то так:\r\n\r\n  bool b = a.All(CheckDigitCurried(7));\r\n\r\nТ.е. будет немного короче. А если потребуется проверить одно конкретное число, ее можно будет вызвать как-то так:\r\n\r\n  bool b = CheckDigitCurried(7)(n);  // Проверить , есть ли в числe n цифра 7\r\n\r\n\r\nЗадача:\r\nПомогите Василию, и напишите функцию CheckDigitCurried, которую можно так вызывать. \r\n\r\nЗамечания:\r\n- Как обычно, эту задачу можно написать на любом обычном языке \r\n- Если писать на C#, то, обратите внимание, м.б. удобно использовать т.н. statement lambda, которые записываются так:\r\n\r\n  параметр => { последовательность операторов, содержащая return }\r\n\r\n- Если условие не очень понятно - пишите, я поясню.\r\n        ',1),(47,1,10,'*Доп задача, до 10.10*\r\nОписать функцию powerset, которая по списку порождает список из всех его подсписков.\r\n\r\nПример вызова:\r\n powerset [1, 2, 3]\r\nРезультат д.б. равен [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]. (Порядок элементов в ответе м.б. и другим, как вам удобнее).\r\n        ',1),(48,2,10,'*Доп задача, до 10.10*\r\nИспользуя _только_ функцию foldr и лямбда выражения опишите функцию myreverse, возвращающую элементы списка в обратном порядке.\r\nПример вызова:\r\n myreverse [1, 2, 3]\r\nРезультат д.б. равен [3, 2, 1].\r\n\r\nДополнительные условия:\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.\r\n- Функция должна работать за линейное время. Технически это означает, что нельзя использовать операцию ++[x] или каким-то другим способом приписывать очередной элемент к концу списка на каждом шаге работы foldr. \r\n- Чтобы задача была немного еще посложнее, давайте пусть будет еще дополнительно условие - нельзя использовать пары (tuples). (И соответственно нельзя каким-то образом их имитировать, с помощью списков из двух элементов или data и т.д.)\r\n\r\nЗамечания:\r\n- Обратите внимание, надо использовать именно foldr, а не foldl. С foldl то все просто..\r\n- Эта задача не очень простая. Точнее, решение у нее довольно простое и короткое, но додуматься до него, м.б. и не так просто. Если не получиться, не расстраивайтесь..\r\n        ',1),(49,1,48,'*Доп.задача, до 15.10*\r\nОписать на C# тип \"двоичное дерево, элементы которого - целые числа\". Для этого дерева опишите аналог функции Any, которая обсуждалась в задаче 7.1. У этой функции должен быть параметр \"условие\" - логическая функция, и она должна проверять, есть ли a дереве элемент, удовлетворяющий условию.\r\n\r\nТ.е. решение должно состоять из программы на C#, в которой:\r\n- описан тип \"дерево\"\r\n- описана функция, аналогичная Any, но для дерева. Это может быть метод класса \"дерево\", или отдельная статическая функция, как хотите.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызвана функция Any. \r\n\r\nСправка: Логические функции можно описать как Function<int, bool>. (Или можно описать как Predicate<int> - это одно и то же.)\r\n\r\nЗамечания:\r\n- Проще всего весь код записать в одном файле, и поместить в систему тестирования. Но, если хотите, вы можете создать несколько файлов (один для дерева, другой для Main) и прислать мне их по почте.\r\n- Эта задача, конечно, немного посложнее предыдущих по C# - те были, скорее, упражнениями. Если что-то будет не получатся, можете писать и задавать вопросы..\r\n        \r\n        \r\n        \r\n        ',1),(50,2,48,'*Доп.задача, до 15.10*\r\nОписать на C++ тип \"двоичное дерево, элементы которого - целые числа\". Для этого дерева опишите что-то похожее на функцию Any из задачи 7.1. \r\n\r\nВ этом случае, видимо, проще всего описать шаблон функции any, примерно так же, как мы описывали шаблон для интеграла. Один из параметров этой функции - условие, которое надо проверить, в другой - корень дерева (или указатель на корень дерева, как будет удобнее).\r\n\r\nТ.е. решение должно состоять из программы на C++, в которой:\r\n- описан тип \"дерево\"\r\n- описана шаблон функции, аналогичной Any из 7.1, но для дерева.\r\n- приведен пример вызова, т.е. создано какое-то дерево, хоть самое просто, из двух-трех вершин, и для него вызван этот шаблон. \r\n\r\nЗамечания:\r\n- Замечания те же, что 10.1. Эта задача, конечно, немного посложнее предыдущих по C++. Если что-то не получается или непонятно, можете задавать вопросы..\r\n        \r\n        \r\n        \r\n        ',1),(51,4,9,'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n\r\n        ',1),(52,5,9,'Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).\r\nПример вызова:\r\n\r\n  f = repeatFunc sin 3\r\n\r\n  должно определить f x = sin (sin (sin x))\r\nи после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.\r\n\r\nДополнительное условие:\r\n - В этой задаче нельзя определять свои рекурсивные функции. Можно использовать стандартные функции и можно, если хотите, определять нерекурсивные функции.\r\n\r\nЗамечание:\r\n - Если вы решите эту задачу, то можете выложить ее решение и как решение для задачи 9.4, оно будет засчитано.\r\n        \r\n        ',1),(53,1,12,'Перечислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. Результат должен быть списком списков целых чисел, каждый внутренний список - это список из трех элементов [k,l,m], где k - двухкопеечных  монет, l - количество трехкопеечных, m - количество пятикопеечных монет.\r\n\r\nПример вызова:\r\n  coins 10\r\n\r\nДолжно получиться:\r\n [[5,0,0],[2,2,0],[0,0,2],[1,1,1]]\r\n(порядок троек в ответе может быть и другим).\r\n\r\nЗамечание:\r\n - Вообще это упражнение на list comprehension. Но, если хотите, вы можете решить задачу и без list comprehension, как хотите.\r\n        ',1),(54,2,12,'Пусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:\r\n - или сопротивление, тогда известно его величина в омах\r\n - или две схемы, соединенных параллельно\r\n - или две схемы, соединенных последовательно\r\n(На самом деле есть схемы, которые таким способом не описать, ну и ладно..)\r\n\r\n1. Опишите тип (data) Scheme, который позволяет описывать такие схемы.\r\n2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы.\r\n\r\nНапример, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2.\r\n\r\nЗамечания:\r\n- Для этой задачи тестов не будет, потому что я не знаю, как вы решите представлять схемы. Но я проверю задачи вручную.\r\n- Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)\r\n        ',1),(56,1,13,'*Доп.задача, до 17.10*\r\nОписать функцию allLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n. \r\n\r\nПример вызова:\r\n allLists 3 2\r\n\r\nДолжно получиться:\r\n [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- В общем случае в списке должно быть, понятно, n^k элементов.\r\n- Эта задача, мне кажется, совсем не сложная\r\nПодсказка: Я бы советовал использовать list comprehension, получится очень просто.\r\n        ',1),(57,2,13,'*Доп.задача, до 17.10*\r\n\r\nОписать функцию canMakeScheme с двумя параметрами:\r\n - список целых чисел [r1, r2, … rn]. Этот список задает набор имеющихся у нас сопротивлений.\r\n - целое число m. \r\nФункция должна проверить, можно ли построить из этих сопротивлений (не обязательно из всех) электрическую схему с общим сопротивлением m и вернуть в качестве результата True или False. \r\nСаму схему строить не надо.\r\n\r\nПример вызова:\r\n  canMakeScheme [4,4,5] 7\r\n\r\nОтвет должен быть True, потому что мы можем соединить параллельно 4 и 4, а потом присоединить последовательно 5.\r\n\r\nЗамечание:\r\n - Можно считать, что сопротивлений будет не больше 5.\r\n - Если вы напишете решение, которое работает за разумное время (скажем, за 15 мин.) для 9 резисторов, выложите ее, как решение задачи 12-3, за нее будет 5 баллов.\r\n - Если вы напишите решение, которое работает для 15 резисторов, присылайте мне, за нее будет 30 баллов (но я не думаю, что это возможно..).\r\n        ',1),(58,3,13,'*Доп.задача, до 17.10*\r\nУсловие см. в задаче 13-2, задача должна работать для 9 сопротивлений. (Таких тестов в системе нет, но я проверю вручную).\r\n\r\nЗамечание:\r\n- Если вы хотите писать эту задачу не на Haskell - обсудите это со мной сначала, пожалуйста. Точно можно писать на OCaml. Точно нельзя решать эту задачу на обычном языке типе С# (просто в занном случае на C# получается заметно проще).\r\n        ',5),(59,1,14,'*Доп.задача на C#, до 18.10*\r\n\r\nАналогом map в C# является, видимо, метод Select, а  аналогом filter - метод Where (это части LINQ но их вполне можно использовать и просто как удобные методы). См. простые примеры вызова этих методов тут:\r\n  http://msimuni.wikidot.com/fp-select-where \r\n\r\nС помощью Select и Where опишите функцию nonZeroLastDigits, которая:\r\n - берет в качестве параметра массив целых положительных чисел\r\n - возвращает массив из последних цифр всех чисел из исходного массива, кроме тех чисел, которые оканчиваются на 0.\r\n\r\nНапример, если входной массив содержит числа 354, 20, 9, 31, то надо вернуть массив из чисел 4, 9, 1 .\r\n\r\nЗамечание:\r\n - Конечно, в этой задаче нет особого смысла, это просто несложное упражнение на вызов Select и Where.\r\n - Если хотите, это же можно сделать и на С++, про это написано в том же документе. Но на С++, честно говоря, получается гораздо менее удобно.\r\n        ',1),(145,2,40,'Существует ли функция, тип которой \r\n  (a -> b) -> (b -> a)\r\nЕсли да, приведите пример. Если нет, объясните почему.\r\n\r\nЗамечание:\r\nВ этой задаче, понятно, нет тестов, в должны прислать программу или обяснение, почему ее нет.',1),(61,1,15,'В этой задаче надо реализовать сразу две функции: \r\nа. Напишите функцию sumDiv, которая для данного целого положительного числа возвращает сумму всех его делителей (не включая в делители сам это число).\r\nб. Напишите функция perfects n, которая возвращает список всех совершенных чисел, меньших или равных n.\r\n\r\nПримеры вызова:\r\n  sumDiv 10\r\nОтвет должен быть равен 8 (так как 1+2+5=8)\r\n  perfects 1000\r\nОтвет должен быть равен\r\n  [6,28,496]\r\n\r\nСправка: Число называется совершенным, если оно равно сумме своих делителей.\r\n        \r\n        \r\n        ',1),(62,2,15,'Напишите функция amicables n, которая возвращает список всех пар дружественных чисел, каждое из которых меньше или равно n. \r\nПример вызова:\r\n  amicables 1000\r\nОтвет должен быть равен\r\n  [(220,284)]\r\n\r\nСправка: Числа a и b называется дружественными, если a равно сумме делителей b, а b равно сумме делителей a.\r\n\r\nЗамечания: \r\n- Для единообразия давайте включать в список только те пары, в которых первое число меньше второго.\r\n- Видимо, имеет смысл скопировать и использовать функцмю sumDiv из задачи 14-1\r\n        \r\n        \r\n        ',1),(63,3,15,'Опишите переменную luckyNumbers, как бесконечный список [7,77,777,7777,...] - т.е. список из целых положительных чисел, у которых все цифры равны 7.\r\n\r\nЗамание\r\nПример вызова:\r\n  take 5 luckyNumbers\r\nОтвет должен быть равен:\r\n  [7,77,777,7777,77777]\r\n\r\nЗамечание:\r\n- Поскольку мы не можем печатать бесконечные списки, для отладки удобно использовать стандарную фунцкию take n xs, которая возвращает список из первых n элементов списка xs.\r\n        \r\n        \r\n        \r\n        ',1),(64,4,15,'Опишите функцию foldTree, которая для дерева делает что-то аналогичное foldr или foldl для списков.\r\n\r\nТ.е. задача написать что-то, что позволяет искать\r\nсумму, произведение и т.д. для всех элементов дерева. На самом деле это можно сделать разными\r\nспособами. \r\n\r\nа. Например, можно написать функцию foldTree, которая вызывается\r\nкак-то так:\r\n\r\nfoldTree (+) 0 t — ищет сумму всех элементов в дереве\r\nfoldTree (*) 1 t — ищет произведение всех элементов в дереве\r\n\r\nб. Но м.б. можно придумать что-то более общее? Например, придумать такой вариант foldTree, который позволяет реализовывать более сложные функции (например, искать высоту дерева и т.д.). Если придумаете, предложите какой-нибудь такой вариант.\r\n\r\nЗамечания:\r\n- Условие, естественно, не совсем строгое (но так и в жизни часто бывает..). Если есть вопросы - пишите.\r\n- Пункт б. необязательный (хотя и не особо сложный). Решения, описанного в пункте а. тоже вполне достаточно. \r\n- В этой задаче, естественно, тестов не будет. Желательно, чтобы вы включили в текст 2-3 примера  того, как можно использовать программу.\r\n        \r\n        ',1),(65,1,16,'*Доп. задача, до 24.10*\r\n\r\nОписать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу).\r\n\r\nПример вызова:\r\n  take 100 cantor\r\n\r\nЧто получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.\r\n        ',1),(66,2,16,'*Доп. задача, до 24.10*\r\n\r\nОписать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу).\r\n\r\nПример вызова:\r\n  take 100 (generalizedCantor 3)\r\n\r\nЧто при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но начало, видимо, будет  [[1,1,1], [1,1,2], и т.д.\r\n        ',1),(67,1,42,'*Доп.задача до 30.10*\r\n\r\nИспользуя функцию transform из задачи 13-2, напишите функцию zeroDigits с тремя параметрами a (массив), size (размер массива), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 3, 2) в массиве должны быть числа 500, 5600, 76700\r\n\r\nЗамечания:\r\n- Важно: Eсли в С++ в лямбда-выражении используются нелокальные переменные (т.е. используется замыкание), то их надо перечислить в начале лямбда выражения в квадратных скобках (это так называемый список захвата - capture list). Например:\r\n\r\n  [n] (int i) { return i + n; }\r\n\r\n- список захвата можно записать и другими способами, но это остается для самостоятельного изучения :)\r\n        \r\n        \r\n        \r\n        ',1),(68,1,17,'*Доп.задача до 25.10*\r\n\r\nИспользуя функцию Select из задачи 14-1, напишите функцию zeroDigits с двумя параметрами a (массив целых положительных чисел), n (целое положительное число). Эта функция должна во всех элементов массива a заменить последние n цифр на 0 и вернуть полученный новый массив.\r\n\r\nНапример, если в массиве числа, 563, 5643, 76796,\r\nто после вызова zeroDigits(a, 2) должен вернуться массив из чисел 500, 5600, 76700\r\n\r\nЗамечания:\r\n- Если вы захотите писать эту задачу на С++, то там надо вместо Select использовать функцию transform. Еще на С++ надо будет использовать так называемый список захвата (capture list), о нем было немного в слайдах.\r\n        ',1),(69,1,18,'Описать функцию bigSin c параметром x, которая возвращает первый элемент в последовательности\r\n  sin 1, sin 2, sin 3, sin 4, ...\r\n, который больше или равен x. \r\n\r\nДополнительное условие: нельзя определять свои функции (кроме bigSin, конечно). Можно использовать любые стандартные функции и лямбда выражения.\r\n\r\nПример вызова:\r\n  bigSin 0.99\r\nрезультат должен быть равен примерно 0.990607\r\n\r\nЗамечания:\r\n - очевидная подсказка: тут, конечно, удобно использовать бесконечные списки. Но можно и без них, наверное.\r\n        ',1),(70,2,49,'Описать функцию myFilter - свою реализацию функции  filter c точно таким же интерфейсом.\r\nДополнительное условие: эта реализация должна использовать только функцию foldr и лямбда выражения.\r\n\r\nПример вызова:\r\n  myFilter (>0) [1,-2,3,-5]\r\nрезультат должен быть равен [1,3]\r\n        \r\n        \r\n        ',1),(71,3,49,'a. Опишите функцию approxSum, параметр который - бесконечный список и которая считает сумму входящих в него элементов, пока очередной элемент не станет по модулю меньше 0.000001.\r\n\r\nб. Используя approxSum, сосчитайте приближенную сумму ряда 1/1 + 1/4 + 1/9 + ... + 1/(i*i) + ...\r\nЗначение этой приближенной функции присвойте переменной z.\r\n\r\nПример вызова:\r\n  z\r\nДолжно получиться примерно 1.64\r\n        \r\n        \r\n        ',1),(72,2,18,'Пусть в списке я записал последовательность чисел - сколько денег я тратил каждый день в этом году. Запись я начал, конечно же, с понедельника. \r\n\r\nОпишите функцию weekendExpences у которой параметр - такой список расходов, и которая вычисляет для него общую сумму расходов по выходным.\r\n\r\nПример вызова:\r\n  weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1, 3]\r\n\r\nОтвет должен быть равен 5+17+5+1 = 28.\r\n\r\nЗамечание:\r\n- В этой задаче можно (но не обязательно) использовать зацикленный список\r\n        ',1),(73,5,48,'Опишите бесконечный список fibs, состоящий из чисел Фибоначчи.\r\nДополнительное условие: желательно использовать прием \"завязывание в узел\" (tying the knot). Но, если не получится, можно решить эту задачу любым способом.\r\n\r\nПример вызова:\r\n  take 10 fibs\r\n\r\nРезультат должен быть равен:\r\n [1,1,2,3,5,8,13,21,34,55]\r\n\r\nЗамечание:\r\n- Безусловно эту задачу можно найти в интернете - и решение из интернета тоже засчитается. Но мне кажется интереснее попробовать самим что-то придумать, тем более это совсем и не сложно..\r\n        \r\n        ',1),(74,5,18,'Используя функцию foldTree с последнего занятия (второй вариант, который катаморфизм), опишите функцию sumPos. У этой функции параметр - дерево, и она должна вычислять сумму всех положительных чисел в этом дереве.\r\n\r\nПример вызова:\r\n  sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))\r\nОтвет должен быть равен 7.\r\n        \r\n        \r\n        ',1),(75,2,21,'В этой задаче надо прислать не программу, а просто текст.\r\na. Напишите, какой тип у функции foldr (если хотите, можете посмотреть, а можете сами попробовать придумать)\r\nб. Расскажите, как можно вывести этот тип, используя   определение foldr - примерно так, как мы это делали на занятии для map. Т.е. в этой задаче надо показать, неформально, как для foldr работает алгоритм Хиндли-Милнера.\r\n\r\nЗамечания:\r\n - текст foldr, на основании которого надо вывести тип, был у нас на занятии\r\n - если не очень понятно, что тут все-таки надо делать, пишите, обсудим.\r\n        ',1),(76,1,24,'Опишите класс Shape и типы Circle и Rect, как мы это делали на занятии. \r\n\r\nа. Добавьте в оба типа еще два вещественных поля -координаты центра фигуры.\r\n\r\nб. Добавьте в Shape функцию contains c двумя вещественными параметрами, которая проверяет, принадлежит ли точка с данными координатами фигуре, и возвращает True или False. Напишите определение этой функции для Circle и Rect.\r\n\r\nПримеры вызова:\r\n\r\n  contains (Circle 10 0 0) 6 5\r\n\r\nОтвет должен быть True, потому что точка  с координатами 6 5 принадлежит кругу радиуса 10 с центром 1 2.\r\n\r\n  contains (Rect 6 8 0 0) 5 5\r\n\r\nОтвет должен быть равен False, потому что точка 5 5 не принадлежит прямоугольнику со сторонами 6 и 8 и центром 0 0.        \r\n\r\nЗамечание:\r\n- Будем считать, что у прямоугольников стороны всегда параллельны осям координатю\r\n        ',1),(77,1,19,'*Доп. задача, до 31.10*\r\n\r\nОписать sqrt2 как бесконечный список из чисел от 0 до 9, описывающий разложение sqrt(2) в бесконечную десятичную дробь. \r\n\r\nПример вызова:\r\n  take 20 sqrt2\r\n\r\nРезультат должен быть равен \r\n  [1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]\r\n\r\nЗамечания:\r\n - Это, видимо, больше задачка по выч. методам, а не по программированию.. Мне кажется, не очень сложная.\r\n - Подсказка: задача не очень сложная, потому что Haskell может выполнять операции над целыми числами любой длины. Тут это удобно.\r\n        ',1),(78,2,19,'*Доп. задача, до 31.10*\r\n\r\nОписать pascal как бесконечный список списков, содержащий треугольник Паскаля. \r\n\r\nДополнительное условие: В этой задаче нельзя определять никакие новые функции (кроме pascal). Можно использовать стандартные функции. Можно (и я бы советовал) использовать прием tying the knot. \r\n\r\nПример вызова:\r\n  take 6 pascal\r\n\r\nРезультат должен быть равен \r\n  [[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]\r\n        \r\n        ',1),(79,1,20,'*Доп.задача на C# до 1.11*\r\n\r\nОпишите блок итератора digits(int n), возвращающий последовательность цифр дроби 1/n. Например, при обращении к digits(7) должны  возвращаться цифры 1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7, ...\r\n\r\nC использованием digits напишите программу, которая вводит число n и печатает первые 100 цифр числа 1/n.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n\r\nЗамечание:\r\n- Если вы хотите написать эту задачу на каком-то другом языке, но не уверены, есть ли в нем похожая конструкция - напишите, обсудим!\r\n        ',1),(80,2,20,'*Доп.задача на C# до 1.11*\r\n\r\n\"Задача Кантора\" на С#\r\n\r\nОпишите на C# блок итератора, возвращающий последовательность всех пар целых положительных чисел.\r\n\r\nПро блоки итераторов немного написано вот тут:\r\n http://msimuni.wikidot.com/fp-generators\r\n\r\nЗамечание:\r\n- Эту задачу тоже можно написать и на другом \"обычном\" языке.\r\n        ',1),(81,1,21,'Описать бесконечный список lst137, содержащий все целые положительные числа, состоящие только из цифр 1, 3 и 7. (Числа должны идти в порядке возрастания).\r\n\r\nПример вызова:\r\n\r\n  take 15 lst137\r\n\r\nДолжно получиться:\r\n  [1,3,7,11,13,17,31,33,37,71,73,77,111,113,117]\r\n\r\nЗамечание:\r\n - Эта задача, на самом деле, довольно эффектно решается с помощью tying the knot. Но, если не придумаете как тут завязать этот узел, эту задачу можно решить любым способом.\r\n        \r\n        ',1),(82,2,22,'*Доп. задача, до 7.11*\r\n\r\nПусть у нас есть система равенств вида:\r\n  <переменная1> = <переменная2>.\r\nМы представляем ее в Хаскеле, как список пар строк. Например, список [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] описывает систему равенств:\r\n  x = y\r\n  y = z\r\n  n = m\r\nКроме этого пусть у нас есть список переменных. Мы хотим сосчитать, сколько в этом списке различных переменных, с учетом этих равенств. Опишите функцию countDifferentVars, которая для данного списка равенств и списка переменных возвращает число различных переменных.\r\n\r\nПример вызова:\r\n  countDifferentVars [(\"x\",\"y\"),(\"y\",\"z\"), (\"n\",\"m\")] [\"x\",\"w\",\"y\",\"z\",\"x\",\"n\",\"m\"]\r\n\r\nРезультат должен быть равен 3, потому что в списке три различных переменных (x - она же у и z, n - она же m, и w).\r\n\r\nЗамечания:\r\n - Это не упражнение на какую-то тему, которую мы проходили - тут надо просто написать более-менее нетривиальный алгоритм на Хаскеле. (С другой стороны, это немного похоже на унификацию переменных, т.е. то, что происходит в алгоритме Хиндли-Милнера). \r\n        ',1),(83,1,23,'*Доп. задача на C#, до 8.11*\r\n\r\nДля определения IEnumerable на C# тоже можно использовать прием tying the knot. Например, так можно определить геометрическую прогрессию:\r\n\r\npublic static IEnumerable<int> Geom()\r\n{\r\n      yield return 1;\r\n      foreach (int i in geom())\r\n      {\r\n           yield return 3*i;\r\n      }\r\n}\r\n\r\nПолучится, видимо, не так эффективно, как на Хаскеле (из-за того, что нет запоминания уже вычисленных значений), но вполне работоспособно.\r\n\r\nЗадача:\r\nРешить задачу 21-1 про числа из цифр 1, 3, 7 на C#. Т.е., описать блок итератора Lst137(), который по очереди возвращает числа 1, 3, 7, 11, 13, 17, 31, 33, 37, 71, 73, 77, 111, 113, 117 и т.д.\r\n\r\nЗамечание:\r\n - Для C# эта задача очень просто решается с помощью приема tying the knot, даже может быть проще, чем на Хаскеле. Но вы можете решить эту задачу любым способом.       \r\n        ',1),(84,2,51,'*Доп. задача на C#, до 12.11*\r\n\r\nОписать функцию Iterate, у которой следующие примеры вызова:\r\n\r\n  foreach (double x in Iterate(2, x => x*2))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (x > 1000000)\r\n        break;\r\n  }\r\n\r\nПечатает 2, 4, 8, 16, ... и т.д. - степени двойки до 1000000\r\n\r\n  int i = 0;\r\n  foreach (double x in Iterate(1, Math.Sin))\r\n  {\r\n     Console.WriteLine(x);\r\n     if (i++ == 100)\r\n        break;\r\n  }\r\n\r\nПечатает 1, sin 1 , sin (sin 1), и т.д. 100 раз.\r\n\r\nКакие у этой функции должны быть параметры и тип результата, определите, пожалуйста, сами по примерам вызова.\r\n\r\nЗамечание:\r\n - Можно считать, что в этой задаче у нас речь идет только про вещественные числа. (Например, первый параметр Iterate точно имеет тип double.) В принципе, можно было бы определить и generic версию, которая работает с разными типами, но в данном случае это не требуется. \r\n        \r\n        \r\n        \r\n        ',1),(85,2,24,'Определите тип Ration для представления дробей. Конструктор этого типа должен записываться так: Rat <числитель> <знаменатель>.\r\nДля этого типа: \r\na. Определите оператор + (сложение дробей)\r\nb. Определите оператор < (сравнение дробей)\r\nc. Определите функцию show, которая генерирует строковое представление дроби в формате <числитель>/<знаменатель> \r\n\r\nПримеры вызова:\r\n\r\nRat 1 2 + Rat 1 7\r\n\r\nДолжно быть напечатано\r\n\r\n9/14\r\n\r\n(потому что при выводе автоматически вызовется show) \r\n\r\nRat 1 3 < Rat 4 5\r\n\r\nРезультат должен быть равен True\r\n\r\nЗамечания:\r\n- Еще обязательно придется определить ==, без этого программа не будет компилироваться.\r\n- Надо ли сокращать дроби? Например, что будет, если сложить Rat 1 3 и Rat 1 6? \r\nОтвет: Как хотите, не обязательно сокращать. В тестах таких примеров не будет.\r\n- Как должна работать функция show, если знаменатель равен 1 и в других необычных случаях?\r\nОтвет: Тоже как хотите, тут тоже тесты будут только очень простые.\r\n        ',1),(86,3,24,'Определить функцию allNondivisible, которая проверяет, верно ли что в данном списке нет двух элементов, таких, что один делится на другой.\r\n\r\nДополнительное условие: В этой задаче, пожалуйста, обязательно используйте прием с представлением множества с помощью логической функции, который мы разбирали на занятии.\r\n\r\nПримеры вызова:\r\n\r\nallNondivisible [2, 7, 6, 5]\r\n\r\nРезультат должен быть равен False, потому что 6 делится на 2\r\n\r\nallNondivisible [4, 7, 6, 5]\r\n\r\nРезультат должен быть равен True, потому что ни одно число в списке не делится на другое.\r\n\r\nЗамечание: \r\nЕсли совсем непонятно, что это за прием такой, вы можете прислать любое решение этой задачи, а я, в обмен на это, подскажу, как ее делать с этим приемом :)\r\n        ',1),(87,5,29,'Для типа Expr, который мы разбирали на занятии, опишите функцию eval. Эта функция должна вызываться так: eval выражение число. Функция должна вычислять значение выражения при данном значении X.\r\n\r\nПример вызова:\r\n\r\n   eval (Add (Num 3) (Mult X X)) 10\r\n\r\nДолжно получиться 103\r\n        \r\n        ',1),(88,6,29,'Для типа Expr, который мы разбирали на занятии, опишите функцию diff, которая вычисляет производную данного выражения по X.\r\n\r\n  diff (Mult X X)\r\n\r\nДолжно получиться\r\n\r\n   Add (Mult(N 1) X) (Mult X (Num 1))\r\n\r\nЗамечания:\r\n- В описании типа надо обязательно в конце написать deriving Show. (На занятии я забыл это сделать :( ). Иначе не удастся вывести результат. \r\n- Упрощать выражение не надо. Т.е. не требуется, например, пытаться вместо Add (Mult(Num 1) X) (Mult X (Num 1)) получить Mult (Num 2) X.\r\n        \r\n        ',1),(89,6,24,'Опишите функцию flatten, которая для данного дерева возвращает список из всех значений, записанных в вершинах дерева.\r\n\r\nПожелание: \r\nБыло бы замечательно, если бы вы написали реализацию flatten, которая не использует операцию ++. Потому что ++, как мы знаем, работает медленно и flatten получится неэффективным. Но, если не придумаете, подойдет любая реализация, и с использованием ++.\r\n\r\nПример вызова:\r\n\r\nflatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))\r\n\r\nДолжно получиться\r\n\r\n   [1,2,3] \r\n\r\nЗамечание:\r\n- Желательно, чтобы значения шли в в таком порядке, как в примере (вершина, потом левое поддерево, потом правое поддерево).\r\n        ',1),(90,5,24,'Пусть нас попросили написать функцию findSame, которая для данного списка возвращает элемент, который в нем встречается больше одного раза. Например, для [1,2,3,2,5] надо вернуть 2.\r\n\r\nМы, естественно, просим уточнить:\r\n- Что делать, если таких элементов несколько?\r\n- Что делать, если таких элементов вообще нет?\r\n\r\nА нам сказали:\r\n- Если из несколько, можно вернуть любой.\r\n- Если вообще нет таких элементов - ну, нам сказали, придумайте что-нибудь.. Подойдет любое решение, но надо, чтобы пользователь мог понять, нашлось что-то или нет.\r\n\r\nЗадача: придумать интерфейс для findSame и реализовать эту функцию.\r\n\r\nПримеры вызова:\r\n\r\nfindSame [1,2,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должно быть число 2 и еще м.б. какая-то дополнительная информация.\r\n\r\nfindSame [1,3,2,5]\r\n\r\nДолжно получиться что-то на ваше усмотрение, но, видимо это должна быть какая-то информация о том, что мы ничего не нашли.\r\n\r\nЗамечания:\r\n- Самый первый вариант, который лично мне приходит в голову - это вернуть пару (число, логическое значение). Это, на самом деле, видимо вовсе не лучший вариант, но вполне нормальный. Если хотите, можете его реализовать, а можете придумать что-то другое.\r\n- Просто на всякий случай, в этой задаче _не_ требуется использовать прием с представлением множества, как функции. Тут подойдет любая простая реализация.\r\n        ',1),(91,3,21,'Опишите функцию merge, у которой два параметра - списки, причем мы точно знаем, что эти значения в этих списках строго возрастают. Функция должна вернуть строго возрастающий список, содержащий значения из обеих списков. Если элемент встречается в обеих списках, в результате он должен встречаться только один раз. \r\n\r\nПример вызова:\r\n\r\nmerge [1,4,8] [2,4,5,10,20]\r\n\r\nДолжно получиться\r\n\r\n [1,2,4,5,8,10,20]\r\n\r\nЗамечания:\r\n- Списки могут быть и бесконечными\r\n- Эта задаче особо ни какой теме не относится - просто полезная функция, которую полезно уметь писать, и которая вполне часто используется на практике\r\n        ',1),(93,1,22,'*Доп.задача, до 7.11*\r\n\r\nОпишите ham - бесконечную последовательность, состоящую из целых чисел вида 3^i*10^j (где i, j - целые неотрицательные числа), расположенных в порядке возрастания.\r\n\r\nДополнительное условие: функция должна работать более-менее быстро. Скажем, надо, чтобы за 30 секунд можно было вычислить элемент с номером 10000.\r\n  \r\nПримеры вызова:\r\n\r\ntake 10 ham\r\n\r\nДолжно получиться \r\n\r\n  [1,3,9,10,27,30,81,90,100,243]\r\n\r\nham !! 10000\r\n\r\nДолжно получиться \r\n\r\n8862938119652501095929000000000000000000000000000000000000000000000000000000000000000000000000000\r\n        ',1),(94,2,27,'*Доп.задача, до 21.11*\r\n\r\nОпишите для типа \"электрическая схема\" функцию show так, чтобы она наглядно изображала схему в виде резисторов, соединенных проводами, с помощью символов псевдографики (например, с помощью -, |, +).\r\n\r\nСправка: В строках Haskell можно использовать символ backslash n для перехода на следующую строку. Можно, при желании, использовать запись backslash x шестнадцатиричное число для того, чтобы задавать любые символы. \r\n\r\n(Пояснение: backslash - это такой символ, после него надо писать n или x и цифры  подряд. Просто система тестирования плохо относится к backslash в тексте :( )  \r\n\r\nЗа эту задачу будет записано 3 балла.\r\n        ',3),(95,1,26,'*Доп.задача на C#, до 15.11*\r\n\r\nНаписать на C# функцию, которая для данного массива целых чисел проверяет, верно ли, что в нем все элементы разные. При этом функция должна использовать \"представление множеств с помощью логической функции\". Т.е., другими словами, попробуйте переписать на С# пример с последнего занятия.\r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Вы можете спросить, а зачем такую простую задачу решать так сложно? Да в общем-то просто для интереса:) Ну и для тренировки в работе с лямбда-выражениями и т.д. На практике это, наверное, особо не применимо, честно говоря.\r\n\r\nПодсказка: \r\nЯ бы начал решение этой задачи как-то так:\r\n\r\npublic static bool allDifferent(int[] a)\r\n{\r\n   return allDifferent1(a, 0, t => true);\r\n}\r\n\r\n// allDifferent1 - вспомогательная функция\r\n//  a - массив, который мы проверяем\r\n//  from - с какого места в массиве мы проверяем\r\n//  cond - функция проверки (которую мы делаем все сложнее и сложнее)\r\n\r\npublic static bool allDifferent1(int[] a, int from, Predicate<int> cond)\r\n{\r\n  ...\r\n        ',1),(96,2,26,'*Доп.задача на C#, до 15.11*\r\nСлияние IEnumerable\r\n\r\nОпределить генератор Merge с двумя параметрами типа IEnumerable<int>. Пусть мы точно знаем, что в обоих IEnumerable числа строго возрастают. Генератор должен объединять последовательности, т.е. результатом должна быть последовательность чисел из обеих входных последовательностей в порядке возрастания. Если какое-то число было в обеих входных последовательностях, то в выходной оно должно встречаться один раз.\r\n\r\nПример вызова:\r\n\r\nint [] a = { 1, 5, 8 };\r\nint [] b = { 3, 5, 9 };\r\nforeach (int i in Merge(a, b))\r\n{\r\n   Console.WriteLine(i);      // Должно напечататься 1, 3, 5, 8, 9\r\n}\r\n\r\nЗамечания:\r\n- Эта задача, в общем, то не имеет особого отношения к курсу. Просто, раз уж мы начали решать задачи про IEnumerable, то м.б. полезно решить не совсем тривиальную задачу на эту тему. Ну и написать полезную функцию).\r\n- В этой задаче, видимо, надо использовать возможности, которые мы не проходили (в частности, метод IEnumerable.GetEnumerator() и методы IEnumerator). Т.е. это задача для тех, кому интересно во всем этом разобраться. Если не очень интересно, ну, просто пропустите ее и все..\r\n        ',1),(97,1,30,'*Доп.задача до 28.11*\r\n\r\nПусть строчка содержит только символы  ‘[‘, ‘]‘,  ‘(‘ и ‘)‘. Опишите функцию checkBrackets, которая для данной строчки проверяет, что в ней находится правильная скобочная последовательность, и возвращает True или False. \r\n\r\nПримеры вызова:\r\n\r\ncheckBrackets \"[()[]]()\"\r\nРезультат должен быть равен True.\r\n\r\ncheckBrackets \"([)]\"\r\ncheckBrackets \"())[]\"\r\ncheckBrackets \"([]\"\r\nРезультат должен быть равен False.\r\n        ',1),(98,2,33,'*Доп.задача до 5.12 (задача с контрольной, для конкретного формата)*\r\n\r\nПусть у нас есть двоичное дерево, элементы которого – символы ‘a` и ‘b‘. Написать две функции:\r\n- функция toStr по дереву строит его представление в виде строки. \r\n- функция fromStr должна по этой строке восстанавливать исходное дерево.\r\n\r\nДополнительные условия: \r\n- Формат строки используйте, пожалуйста, как описано в слайдах 11 занятия. То есть:\r\n.   Для непустого дерева формат:`n`, потом символ, потом строка для левого поддерева, потом строка для правого поддерева\r\n.   Для пустого дерева: `e`\r\n- В функции toStr используйте, пожалуйста, прием описанный в слайдах 11 занятия для flatten. Т.е. используйте, пожалуйста, оператор композиции.\r\n\r\nПримеры вызова:\r\n\r\ntoStr (Node ‘a‘ Empty (Node ‘b‘ Empty Empty) )\r\nРезультат должен быть равен строке \"naenbee\"\r\n\r\nfromStr \"naenbee\"\r\nРезультат должен быть равен (Node ‘a‘ Empty (Node ‘b‘ Empty Empty) )\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show, без этого тесты не пройдут.\r\n        ',1),(99,2,34,'*Доп.задача на C#, до 6.12*\r\n\r\nРеализовать задачу 29.6 про производную на C# (Или на любом `oбычном` языке.)\r\n\r\nИмеется в виду, что надо придумать какое-то свое внутреннее представление для символьных выражений и для этого представления написать функцию Diff, которая строит производную данного выражения. \r\n\r\nЗамечания:\r\n - Вывод выражения писать не обязательно, разве что он вам понадобится для отладки.\r\n - Эта задача, честно говоря, не имеет особого отношения к функциональному программированию :) Ну, просто, раз уж мы начали решать задачи про символьные вычисления, интересно сравнить, насколько это удобнее (или не удобнее) делать с помощью функциональных языков, чем с помощью обычных.\r\n  - Если что-то в условии непонятно, пишите.\r\n        \r\n        ',1),(100,1,25,'Описать функцию allDiffLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно получиться:\r\n[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- Мы эту задачу решили на последнем занятии, только без приема \"представление множества с помощью функции\". Т.е. это, на самом деле, довольно простое упражнение: переписать существующее решение с этим приемом.\r\n- Те, кто уже присылал решение с этим приемом, могут просто выложить его еще раз.\r\n        ',1),(101,5,32,'Для типа Expr написать функцию simplify. Эта функция должна упрощать выражение, используя только два очень простых правила:\r\n\r\nвыражение * 0 = 0\r\nи\r\n0 * выражение = 0\r\n\r\nПримеры вызова:\r\n\r\nsimplify (Add (Mult X (Num 0)) X)\r\n\r\nДолжно получиться:\r\nAdd (Num 0) X\r\n\r\nsimplify (Mult X (Mult X (Num 0)))\r\n\r\nДолжно получиться:\r\nNum 0\r\n\r\nЗамечание:\r\n- Не забудьте написать deriving Show\r\n        ',1),(102,1,29,'Опишите функцию findMajor, которая для данного списка определяет, есть ли в нем элемент, который больше суммы всех остальных, вместе взятых, и, если есть, возвращает его, как результат.\r\n\r\nДля того, чтобы сообщить, есть такой элемент или нет, используйте стандартный тип Maуbe, который мы проходили на последнем занятии.\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [2,3,15,2,2,2] \r\n\r\nДолжно получиться:\r\nJust 15\r\n\r\nfindMajor [2,3,5,2,4] \r\n\r\nДолжно получиться:\r\nNothing\r\n\r\nЗамечания:\r\n- Тут никаких хитростей, это простое упражнение на использование Maybe\r\n        ',1),(103,2,29,'На занятии мы разобрали функцию find, использующую failure continuation параметр, для того чтобы сообщить, что ничего не найдено. \r\n\r\nИспользуя только эту функцию, описать функцию findInLists, которая ищет элемент, удовлетворяющий данному условию в списке списков.\r\n\r\nПримеры вызова:\r\n\r\nfindInLists [[1,8,2], [2,7]] (>5) 0\r\n\r\nРезультат должен быть равен 8.\r\n  \r\nfindInLists [[1,8,2], [2,7]] (>10) 0\r\n\r\nРезультат должен быть равен 0.\r\n\r\nЗамечание: \r\nЖелательно в программе не использовать оператор if. Потому что, как мы говорили, при использовании failure continuation он, как правило, не нужен. Функция find, в каком-то смысле, сама работает, как оператор if. \r\nНо, если так не получиться, в принципе использовать if можно.\r\n        ',1),(104,3,29,'При помощи оператора >>= для списков описать функцию doubleEven, которая в данном списке все элементы, делящиеся на 2, повторяет два раза, а остальные оставляет, как есть.\r\n\r\nПример вызова:\r\n\r\ndoubleEven [1, 2, 6, 3]\r\n\r\nДолжно получиться:\r\n[1,2,2,6,6,3]\r\n        ',1),(105,4,29,'Описать функцию cartesian, которая для двух списков возвращает список из всех возможных пар элементов из первого и второго списка. Т.е. для списков [x1, x2, x3] и [y1, y2, y3] функция должна вернуть [(x1, y1), (x1, y2), (x1, y3), (x2, y1), (x2, y2), …] (всего 9 пар).\r\n\r\nПри этом желательно использовать только оператор >>= и лямбда выражения. Можно, но не очень нужно, определять вспомогательные функции. \r\n\r\nЕсли не получится сделать задачу с помощью >>=, можно написать любым способом, но только не используя list comprehension (с ним это уж слишком просто).\r\n\r\nПример вызова:\r\n\r\ncartesian [1,2] [3,4]\r\n\r\nДолжно получиться:\r\n[(1,3),(1,4),(2,3),(2,4)]\r\n        ',1),(106,2,30,'**Доп.задача до 28.11*\r\n\r\nОпишите функцию findMajor, которая проверяет, есть ли в списке элемент x, который встречается чаще всех других, вместе взятых, и возвращает Just x или Nothing, если такого элемента нет.\r\n\r\nДополнительное условие: Функция должна работать за линейное время от длины списка, и не должна использовать списки (кроме исходного списка, конечно) или любые другие структуры данных неограниченной длины. Другими словами, должна быть сложность по времени O(n) и сложность по памяти O(1).\r\n\r\nПримеры вызова:\r\n\r\nfindMajor [1,2,3,2,2,2,1]\r\nРезультат должен быть равен Just 2\r\n\r\nfindMajor [1,2,3,2,2,1]\r\nРезультат должен быть равен Nothing\r\n\r\nЗамечания:\r\n- Это просто более-менее известная задачка на сообразительность, с функциональным программированием никак, в общем то, не связанная.\r\n- Я лично знаю решение, которое требует два прохода по списку, и только две вспомогательных переменных\r\n- Интересно, что, если бы задача была найти самое часто встречающееся число, то такое эффективное решение, насколько я понимаю, не существует. \r\nНо раз речь идет не о просто самом частом, а об _очень_ часто встречающемся числе, то все получается гораздо эффективнее.\r\n        ',1),(107,1,33,'**Доп.задача до 5.12*\r\n\r\nОпишите тип LogExpr, аналогичный Expr, но для логических выражений. В нем должны быть конструкторы And, Or, Not для логических операций, конструкторы T и F для логических констант и переменная X.\r\n\r\nОпределите для этого типа операцию ==, которая проверяет, эквивалентны ли эти выражения.\r\n\r\nПримеры вызова:\r\n\r\nOr X (Not X) == T\r\nРезультат должен быть равен True\r\n\r\nOr X (And X (Not X)) == T\r\nРезультат должен быть равен False\r\n        ',1),(108,1,27,'**Доп.задача до 21.11*\r\n\r\nПусть я хочу найти способы расставить ферзей на шахматной доске, чтобы они друг друга не били.\r\n\r\nДля представления позиции на шахматной доске я использую список пар чисел, каждое число >= 1. Первое число обозначает вертикаль, а второе - горизонталь.\r\n\r\nЕще для единообразия давайте считать, что первый ферзь в списке всегда стоит на первой вертикали, второй ферзь - на второй вертикали и т.д. (Т.е., вообще-то хранить вертикали в списке не очень то надо, но для наглядности мы их храним).\r\n\r\nИ вот задача:\r\n\r\nОписать функцию queens с двумя параметрами n и k, которая возвращает список из способов расставить k ферзей на доске с n горизонталями и k вертикалями, чтобы они не били друг друга.\r\n\r\nДополнительное условие: Тут надо обязательно использовать прием \"представление множества с помощью функции\".\r\n\r\nПример вызова:\r\nqueens 3 2\r\n\r\nДолжно получиться:\r\n[[(1,1),(2,3)],[(1,3),(2,1)]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n- Мне кажется задача очень похожа на задачу 25-1. Просто в 25-1 функция проверки попроще, а тут посложнее. \r\n- Если не очень понятно о чем речь, но хочется разобраться - пишите, пожалуйста, я подскажу.\r\n        ',1),(109,1,28,'*Доп.задача на C#, до 22.11*\r\n\r\nОписать функцию AllDiffLists с двумя параметрами n и k, которая печатает все последовательности длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nДополнительное условие: \r\n- В этой задаче нельзя использовать массивы и вообще никакие способы представления данных, кроме целых чисел и лямбда-выражений.\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно быть напечатано:\r\n 1 2\r\n 1 3\r\n 2 1\r\n\r\n... и т.д., всего 6 строчек(не обязательно именно в таком порядке).\r\n\r\nЗамечания:\r\n\r\n- Я бы предложил тут использовать прием \"представление множества с помощью функции\".\r\n\r\n- Но этого мало, потому что нам еще надо как-то хранить числа, которые мы уже отобрали, чтобы потом из напечатать. \r\n\r\nТут я бы предложил использовать еще одну функцию, которая при рекурсивных вызовах становится сложнее и сложнее. Но эта функция будет накапливать не проверки, а _печать_ для отобранных чисел.\r\n\r\n- Техническое замечание: Функция без параметров, которая ничего не возвращает, описывается так:\r\n\r\nAction f\r\n\r\nИ вот примеры лямбда выражений, у которых нет параметров, и которые ничего не возвращают:\r\n\r\n() => { Console.WriteLine(); }\r\n() => { f(); g(); } \r\n        ',1),(110,1,31,'*Доп. задача на C#, до 29.11*\r\n\r\na. Написать на C# функцию Find, которая в данном массиве целых чисел ищет элемент, удовлетворяющий данному логическому условию. При этом функция должна использовать failure continuation, чтобы обрабатывать случай, когда ничего не найден.\r\n\r\nб. Привести пример, как с помощью Find можно решить пример с занятий: \r\n\"Найти в массиве первое число, большее 1000, а если его нет, то первое число большее 500, а если и его нет, то первое число большее 100 (а если и его нет, вернуть 0)\".\r\n\r\nТехнические замечания про failure continuation на C# см. тут: \r\nhttp://msimuni.wikidot.com/fp-failure-continuation \r\n\r\nЗамечания:\r\n- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.\r\n- Эта задача, на самом деле, очень простая, надо только понять, о чем вообще речь.\r\n        ',1),(111,4,32,'а. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:\r\n\r\nAdd (Var \"x\") (Mult (Var \"y\") (Num 3))\r\n\r\n(И это должно соответствовать x+y*3 в обычном языке.) \r\n\r\nб. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).\r\n\r\nПример вызова:\r\n\r\neval (Add (Var \"x\") (Mult (Var \"y\") (Num 3))) [(\"x\", 5), (\"y\", 8)]\r\n\r\nРезультат должен быть равен 29\r\n\r\nЗамечание:\r\n- Не очень понятно, что делать, если для какой-то переменной значение не задано. Вы можете задать любое поведение в этом случае, или вообще не рассматривать такой случай. В тестах такого не будет.\r\n        ',1),(112,4,35,'а. К типу Expr из задачи 32-4, добавить еще возможность описывать что-то похожее на let выражения. Вот пример такого выражения\r\n\r\nAdd (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (Num 1)\r\n\r\n(И это должно соответствовать (let x = 10 in x*y) + 1 в обычном языке.) \r\n\r\nб. Дописать функцию eval (вариант с несколькими переменными), чтобы она вычисляла let выражения. \r\n\r\nПример вызова:\r\n\r\neval Add (Let \"x\" 10 (Mult (Var \"x\") (Var \"y\"))) (Num 1) [(\"y\", 2)]\r\n\r\nРезультат должен быть равен 21.\r\n        \r\n        ',1),(113,6,32,'Опишите функцию sum_cps которая ищет сумму элементов данного списка, используя continuation-passing style.\r\n\r\nПримеры вызова:\r\n\r\nsum_cps [1,2,3] id \r\nРезультат дб равен 6\r\n\r\nsum_cps [1,2,3] (^2)\r\nРезультат дб равен (1+2+3)^2=36\r\n\r\nДополнительные условия:\r\n- Нельзя определять никакие новые функции, кроме sum_cps.\r\n- Нельзя использовать никакие стандартные функции для работы со списками.\r\n- Определение sum_cps должно быть tail recursive\r\n(Эти все условия следуют из того что функция должна  использовать continuation passing style, я их выписал просто для тех, кто мб не был на занятии).     \r\n        ',1),(114,1,32,'*Простое упражнение на использование >>= и do нотации*\r\n\r\nОпишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:\r\n\r\n[1, \r\n 1, 4, \r\n 1, 4, 9,\r\n  ...\r\n 1, 4, 9, ..., n*n]\r\n\r\nТ.е. сначала выписан квадрат 1, потом квадраты чисел от 1 до 2, потом квадраты чисел от 1 до 3 и т.д.\r\n\r\nДополнительные условия:\r\n- triangle1 надо написать с помощью оператора >>= и функции return\r\n- triangle2 надо написать с помощью do нотации\r\n- в обеих задачах нельзя использовать стандартные функции, кроме >>=, return и арифметики. А во второй задаче и >>= и return нельзя использовать, только do.\r\n\r\nПримеры вызова:\r\n\r\ntriangle1 3\r\ntriangle2 3\r\n\r\nВ обоих случаях должно получиться:\r\n[1,1,4,1,4,9]\r\n        ',1),(115,2,32,'Пусть функция find описана так:\r\n\r\nfind cond [] = []\r\nfind cond (x:xs) = if cond x then [x] else find cond xs\r\n\r\n(Т.е. для того, чтобы сообщить о том, что ничего не найдено, мы используем пустой список).\r\n\r\nС помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает []\r\n- если все числа найдены, возвращает список из одного элемента - их суммы.\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен [30], потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен [], потому что один из трех поисков ничего не находит.\r\n\r\nЗамечания: \r\n- Это просто упражнение, на то, как удобнее работать с несколькими вызовами функции, которая может завершиться неудачно.\r\n- Задачу можно решить очень коротко, в одну строку.  \r\n- Если коротко не получиться, вы можете присылать любое решение.\r\n        ',1),(116,6,35,'Написать функцию toInt, которая по данному числу Черча возвращает обычное число.\r\n\r\nПример вызова:\r\n\r\ntoInt (\\f x -> f (f (f x)))\r\n\r\nРезультат должен быть равен 3.\r\n\r\nЗамечание: \r\n- Задача очень простая, пишется в одну строку.\r\n        ',1),(117,7,35,'Написать функцию inc, которая прибавляет 1 к числу Черча.\r\n\r\nНапример, вызов inc (\\ f x -> f (f (f x))) должен вернуть \\ f x -> f (f (f (f x))). \r\n\r\nПример вызова:\r\ntoInt (inc (\\ f x -> f (f (f x))))\r\nРезультат д.б. равен 4.\r\n\r\nЗамечание: \r\n- Это тоже очень простая задача.\r\n- Для того, чтобы тесты прошли, включите пожалуйста,в код определение функцими toInc из предыдущей задачи\r\n        ',1),(118,3,32,'Пусть мы описали функцию find вот так:\r\n\r\nfind cond (x:xs) = if cond x then (x, xs) else find cond xs\r\n\r\n(В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).\r\n\r\nТ.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. Мы бы хотели написать оператор, немного похожий на оператор композиции (.), Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, полученного в результате первого вызова.\r\n\r\nЗадача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:\r\n\r\nf = find (>3) >>> find (>3)  \r\n-- f - это функция, которая ищет в списке второй элемент, больший 3.\r\nf  [1, 3, 5, 2, 20, 25, 2]\r\n-- Должно получиться (20, [25, 2])\r\n        ',1),(119,1,36,'*Доп.задача, до 9.12*\r\n\r\nРеализовать функцию dec, которая вычитает 1 из числа Черча.\r\n\r\nПример вызова: \r\ndec (\\ f x -> f (f (f x))) \r\nдолжен вернуть \\ f x -> f (f x). \r\n\r\nДля проверки имеет смысл вызвать так:\r\ntoInt (dec (\\ f x -> f (f (f x)))) \r\nи ответ д.б. равен 2.\r\n\r\nЗамечания:\r\n- Имеется в виду, что в этой задаче нельзя использовать встроенные функции и вообще нельзя использовать настоящие целые числа (потому что глобальная задача - показать, что встроенные целые числа теоретически не очень нужны, их можно моделировать). Например, нельзя перевести число Черча в обычное, вычесть 1 и перевести обратно.\r\n- Кроме этого, давайте считать, что никакие структуры данных (списки, пары) использовать нельзя. Мы же ставим себя на место Черча и Клини у которых были только лямбда выражения, и больше ничего.\r\n- Эта задача не очень простая. Сам Черч не смог ее решить, ему помог его студент (С.Клини). Так что если у вас не получится, не расстраивайтесь:)\r\n- Вы, безусловно, можете найти решение этой задачи в сети. Это не запрещается, но имейте в виду, что тех, кто сдал эту задачу я могу на зачете попросить ее воспроизвести или объяснить.\r\n        ',2),(120,2,36,'*Доп.задача, до 12.12*\r\n\r\nПусть нас интересуют формулы исчисления высказываний, которые можно составить из переменных и символа следования ->. Вот примеры таких формул:\r\n\r\nA -> A\r\n(A -> B) -> ((B -> C) -> (A -> C))\r\n(A -> B) -> (B -> A)\r\n((A -> B) -> C) -> D\r\n\r\nа. Описать тип данных (data) позволяющий описывать такие формулы (примерно так же, как с помощью Expr мы описывали арифметические формулы).\r\n\r\nб. Написать функцию isTautology, которая по данной формуле определяет, является ли она тавтологией, т.е. верно ли, что она истина при любых значениях входящих в нее переменных, и возвращает True или False. Например, их приведенных выше формул первая и вторая - это тавтологии, а остальные - нет.\r\n\r\nЗамечания:\r\n- Тестов к этой задаче в системе нет, потому что я не знаю, какое представление данных вы выберете.\r\n        ',1),(121,1,34,'*Доп. задача на C# - до 6.12*\r\n\r\nВ этот раз задача наверное не очень полезная и не очень осмысленная:( Ну, рассматривайте ее, пожалуйста, просто как техническое упражнение (и как возможность заработать баллы:)\r\n\r\nЗадание простое: написать функцию fact_cps, которая вычисляет факториал, с использованием рекурсии и continuation passing style. Ну и привести пример вызова - ввести целое число и, с помощью вызова fact_cps напечатать результат.\r\n\r\nТ.е., фактически, надо просто переписать пример с занятий на C# (или на любой другой `обычный` язык программирования).     \r\n        \r\n        ',1),(122,5,35,'а. Добавить в тип Expr конструкции, позволяющие определять свои функции и вызывать их. Для простоты мы рассматриваем только функции с одним параметром, параметр и результат функции - целые числа.\r\nб. Добавить в функцию eval реализацию для этих конструкций.\r\n\r\nПример вызова:\r\n\r\neval (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"X\")) (Add (Num 1) (Call \"F\" (Num 5)))) [] []\r\n\r\nДолжно получиться 26, потому что мы тут записали на нашем языке выражение:\r\nlet f x = x*x in 1 + f 5\r\n\r\nЗамечания:\r\n- Задача не очень простая, но, в общем то, тут надо придумать представление данных (как хранить функции) и дальше все, в общем, не сложно.\r\n- Я бы предложил завести отдельный параметр - список для хранения функций. Поэтому в примере вызова у меня в конце два пустых списка - для переменных и для функций. Но, если хотите, можете немного изменить список для хранения значений переменных, чтобы в нем можно было хранить и функции. Тесты тогда не пройдут, ну и ладно, я так проверю. \r\n- Можно считать, что не надо поддерживать замыкания (т.е. в функциях не используются нелокальные переменные).\r\n        ',1),(123,1,35,'а. Описать функцию find с двумя параметрами - условие (логическая функция) и список. Функция должна искать первый элемент в списка, удовлетворяющий условию, и возвращать Just элемент или Nothing, если ничего не найдено. \r\n\r\nПримеры вызова find:\r\n\r\nfind (>6) [1, 2, 8, 3]\r\nРезультат должен быть Just 8\r\n\r\nfind (>6) [1, 2, 5, 3]\r\nРезультат должен быть Nothing\r\n\r\nб. С помощью этого варианта find описать функцию f, которая делает вот что:\r\nВ данном списке f ищет:\r\n- первое число, меньшее 5\r\n- первое число, большее 10\r\n- первое число, не равное 7\r\nи возвращает:\r\n- если хотя бы один поиск был неудачным, возвращает Nothing\r\n- если все числа найдены, возвращает Just для их суммы.\r\n\r\nДополнительное условие:\r\nОбязательно надо использовать конструкцию do (как это можно сделать, мы обсуждали на последнем занятии).\r\n\r\nПримеры вызова:\r\n\r\nf [7, 6, 4, 3, 20, 15, 9] \r\nРезультат должен быть равен Just 30, потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30\r\n\r\nf [7, 6, 4, 3, 9]\r\nРезультат должен быть равен Nothing, потому что один из трех поисков ничего не находит.\r\n\r\nЗамечание: \r\n- Это очень, очень простое упражнение, абсолютно все решение есть в слайдах.. Просто балл в подарок :)\r\n        ',1),(124,2,35,'Описать функцию downUp, которая для данного параметра n печатает числа:\r\nn n-1 n-2 … 3 2 1 2 3 … n-2 n-1 n\r\nпо одному в столбик.\r\n\r\nДополнительное условие:\r\n- Надо обязательно использовать функцию print и do нотацию\r\n\r\nПример вызова:\r\n\r\ndownUp 3\r\n\r\nДолжно напечататься:\r\n3\r\n2\r\n1\r\n2\r\n3\r\n        ',1),(125,3,38,'Я сказал на занятии примерно следующее:\r\nВыражение\r\n(\\x -> E) a\r\nвсегда можно без изменения смысла выражения заменить на Е в котором все вхождения x заменены на a\r\n\r\nНапример,\r\n(\\x->mult x x)5\r\nэто то же, что\r\nmult 5 5\r\n\r\nНа самом деле я немного ошибся. Для более сложных выражений это правило не всегда верно, его надо как-то уточнить.\r\n\r\nа. Приведите пример, когда это не так\r\nб. Напишите, как сформулировать правило бета редукции более корректно.\r\n\r\nЗамечания:\r\n- Это не задача на программирование. Ответом д.б. текст, что-то вроде: \"Вот пример, когда ваше правило дает неправильные результаты: … какой-то пример … . Его можно исправить так: … правильная формулировка … .\r\n- На самом деле в определении две ошибки, вы можете указать любую.\r\n- Одна из ошибок совсем очевидная (да и вторая, в общем-то, то же), и то, что требуется указать, как исправление, может быть кажется вам само собой разумеющимся. Т.е., если вы придумали ответ на эту задачу, но он кажется вам слишком простым - выкладывайте его в систему, очень может быть это как раз то, что имеется в виду.\r\n        ',1),(126,4,38,'Черч и Россер доказали теорему: бета-редукция для лямбда исчисления обладает свойством конфлюентности.\r\n\r\nИспользуя эту теорему, докажите, что если для лямбда выражения существует нормальная форма, то она единственна.\r\n \r\nЗамечания:\r\n- Тут, понятно, надо написать текст, а именно доказательство этого утверждение, более-менее строгое.\r\n- Это, на самом деле очень простое следствие, практически очевидное. М.б. в этом некоторая трудность, бывает не так просто обосновать , что одно следует из другого, если это очевидно. Но вы попробуйте:)\r\n        \r\n        ',1),(127,3,35,'У функции >>>, мы которую мы описали на предпоследнем занятии, есть принципиальный недостаток - она никак не использует результат, найденный первой функцией - только хвост. \r\n\r\nВ результате, такие задачи, например с ее помощью записать не удастся:\r\n- Найти в списке элемент x, больший 3, а потом первый элемент, больший x.\r\nили\r\n- Найти в списке элемент x, больший 3, а потом первый элемент y, меньший x, а потом первый элемент, не равный сумме x и у\r\n\r\nКакую бы написать функцию, чтобы решить эту проблему?\r\n\r\nОпишите какой-то оператор, который как-то дозволяет это делать.\r\n\r\nПримера вызова не будет, потому что оператор вы должны придумать сами, но по идее что-то такое\r\n\r\nf = find (>3) ... какие-то заклинания ... find (>x) \r\n\r\nИ потом:\r\nf [1,6,5,7,1,2]\r\nдолжно вернуться (7, [1,2])\r\n\r\nЗамечания:\r\n- На занятии мы еще говорили про функцию, которая возвращает сумму двух найденных чисел, но про это давайте мы решим задачу в следующий раз.\r\n- Ответ очень короткий (почти не длиннее чем решение для >>>), надо только понять, что бы тут хотелось иметь.\r\n- Подсказка: я бы назвал нужную нам функцию >>>=. (Я бы еще лучше назвал ее >>=, но тут есть некоторые технические сложности, с которыми неохота разбираться..)\r\n- Если вам не придумать решение, напоминающее >>=, вы можете предложить любое другое. Все что угодно, только не списывайте:) Все, что будет немного похоже на решение, я зачту:)\r\n- Если совсем непонятно о чем речь, вы можете написать мне, и я немного подскажу.\r\n        ',1),(129,3,12,'Используя _только_ функцию foldr и лямбда выражения опишите функцию mymap, которая делает точно то же, что и стандартная функция map.\r\nПример вызова:\r\nmymap (*3) [1, 2, 3]\r\nРезультат д.б. равен [3, 6, 9].\r\n\r\nДополнительные условия:\r\n- В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.',1),(130,4,12,'\"След матрицы\"\r\n\r\nПусть мы используем списки списков, чтобы представлять в Хаскеле матрицы. Описать функцию trace n, которая для данной квадратной матрицы возвращает сумму ее диагональных элементов.\r\n\r\nПример вызова:\r\ntrace [[1,2,3],[4,5,6],[7,8,9]]\r\nДолжно получиться 15 (сумма 1+5+9).\r\n\r\nЗамечания:\r\n- В этой задаче может быть удобно использовать оператор xs !! n, который возвращает n-ный элемент списка xs. Элементы нумеруются с 0, т.е. xs !! 0 - это то же, что head xs.\r\n- Можно считать, что мы точно знаем, что матрица квадратная. Если список не соответствует квадратной матрице (содержит строки разной длины и т.д.), то функция может вести себя как угодно.    ',1),(131,4,13,'*Доп.задача, до 17.10*\r\nУсловие см. в задаче 13-2, задача должна работать для 8 сопротивлений. (Таких тестов в системе нет, но я проверю вручную).\r\n\r\nПо просьбам участников введена еще одна категория для задачи про резисторы, для 8 сопротивдений. За это будет еще 2 балла.',2),(132,3,18,'Описать бесконечный список facts, состоящий из факториалов целых положительных чисел [1!, 2!, 3!, 4!, ...]. \r\n\r\nПро этом в этой задаче довольно строгие дополнительные условия - см ниже. Особенно обратите, пожалуйста, внимание, на первое условие - тут надо обязательно применить именно этот прием. \r\n\r\nПример вызова:\r\n  take 5 facts\r\nРезультат должен быть равен [1, 2, 6, 24, 120].\r\n\r\nДополнительные условия:\r\n- В этой задаче _обязательно_ надо применить прием \"завязывание в узел\" (tying the knot).\r\n- Нельзя определять свои функции (кроме facts, конечно)\r\n- Можно использовать любые стандартные функции.',1),(133,4,18,'*Программа по картинке*\r\n\r\nВ слайдах 7 занятия на последнем слайде есть картинка. Эта картинка взята из одного их руководств по языку Haskell и иллюстрирует некоторую программу, описывающую бесконечный список fib.\r\nВаша задача - написать программу, которая, как вам кажется, соответствует этому рисунку.\r\n\r\nПример вызова:\r\ntake 6 fib\r\nДолжно получиться [1,1,2,3,5,8]\r\n\r\nЗамечания:\r\n- Совсем не обязательно, чтобы вы угадали в точности ту самую программу. Просто напишите тот вариант, который вам кажется более подходящим. А мы потом сравним с оригиналом)',1),(134,4,21,'Описать функцию allDiffLists с двумя параметрами n и k, которая возвращает список из всех списков длины k, которые можно составить из чисел 1..n, и в которых все числа разные.\r\n\r\nПример вызова:\r\nallDiffLists 3 2\r\n\r\nДолжно получиться:\r\n[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\r\n\r\n(не обязательно именно в таком порядке).\r\n\r\nЗамечание:\r\n- Желательно (но не обязательно) взять за основу функцию allLists с последнего занятия, и дописать в ней что-нибудь, чтобы получился allDiffLists.',1),(135,4,24,'superMap\r\n\r\nОписать функцию superMap, похожую на map, но только она умеет заменять один элемент на несколько.\r\n\r\nПример вызова:\r\n\r\nsuperMap (\\x -> [x*x, 100*x]) [1,2,3]\r\n\r\nОтвет должен быть равен [1, 100, 4, 200, 9, 300].\r\n\r\nЗамечания:\r\n- Из примера, мне кажется, ясно, что делает эта функция. Но если не очень ясно - напишите, я поясню.\r\n- На самом деле, в Хаскеле есть стандартная функция, которая делает именно это. И даже две:) Вы можете какую-нибудь их них найти и вызвать. Но м.б. и не имеет смысла это делать, эту функцию и так очень просто написать.\r\n        ',1),(136,2,25,'Сложение и умножение многочленов\r\n\r\nОпишите тип, позволяющий хранить информацию о многочленах с одной переменной, и реализуйте для него операторы + (сложение), * (умножение), ==  (равенство) и функцию show.\r\n\r\nЗамечание:\r\n- Примеры вызова я не могу привести, потому что я не знаю, какое преставление данных вы выберете и как вы опишете тип.\r\n- Если у вас нет идей, какое представление данных выбрать - пишите, обсудим.',1),(144,1,40,'Описать функцию isPower2 с параметром n, которая возвращает True, если n – степень двойки и False, если нет.\r\n\r\nДополнительное условие:\r\n- Функцию надо описать с помощью нерекурсивной функции и функции y (комбинатора неподвижной точки)\r\n\r\nПример вызова:\r\n  isPower2 16\r\nРезультат должен быть равен True\r\n',1),(137,1,37,'В этот раз задача с очень свободным заданием. В .NET 4.5 есть библиотека Task Parallel Library, и в ней есть понятие continuation task. continuations применяются в этой библиотеке для того, чтобы задать, что делать после окончания выполнения некоторой асинхронной задачи. \r\n\r\nСм. документацию:\r\nhttp://msdn.microsoft.com/en-us/library/ee372288(v=vs.110).aspx\r\n\r\nНапишите, пожалуйста, любой демонстрационный пример использования continuation task. Т.е. программа должна выполнять некоторую более-менее длительную операцию асинхронно, и по окончании выполнять некоторое действие. При этом должно быть понятно, что мы получаем от того, что выполняем задачу асинхронно (ну, просто как пример, программа может в нескольких потоках параллельно проверять, верно ли, что некоторое очень большое число - простое и т.д.)\r\n\r\nЕсли задача не очень понятна, но хочется в ней разобраться - пишите. ',1),(138,1,38,'*Чтo-то похожее на return*\r\n\r\nПусть мы хотим, чтобы можно было написать: \r\n\r\nf = find (>3) >>>= x ->\r\n       find (>x) >>>= y ->\r\n           return1 (x+y)\r\n\r\nИ в результате f должна работать так: она ищет в списке первый элемент, больший 3, потом первый элемент, больший первого найденного и возвращает пару (сумма двух найденных чисел, хвост списка).\r\n\r\n>>>= мы уже определили на занятиях. Определите return1.\r\n\r\n(Подсказка: это очень простая функция).\r\n\r\nПример вызова f:\r\n\r\nf [1,2,8,4,9,3,25]\r\n\r\nДолжно получиться (17, [3,25]), потому что первый поиск найдет 8, второй - 9.\r\n        \r\n        ',1),(139,2,38,'*Let со статическим связыванием*\r\n\r\nЗадача похожа на задачу 35-4 про Let. Но Let надо реализовать так, чтобы:\r\n- значением переменной в Let могло бы быть не только число, но и выражение.\r\n- это выражение вычислялось бы не в момент выполнения Let, а потом, при обращении к переменной\r\n- но в то же время, при вычислении этого выражения использовались бы те значения Let, которые были в момент *определения* переменной (статическое связывние).\r\n \r\nПример вызова:\r\n\r\neval (Let \"x\" (Num 5) \r\n       (Let \"y\" (Mult (Var \"x\") (Var \"x\"))\r\n          (Let \"x\" (Num 5)\r\n              (Add (Var \"y\") (Num 1))\r\n      ) ) )\r\n\r\nРезультат должен быть равен 5*5+1 = 26. \r\n\r\nПро то, почему так лучше, и как это можно бы реализовать - см. слайды. \r\n        ',1),(140,5,38,'Приведите пример лямбда выражения, вычисление которого дает разные результаты при нормальном и аппликативном порядке применения редукций.\r\n\r\nЗамечания:\r\n- Это простая задача (если понимать все иностранные слова в ее формулировке:)\r\n- Тут, естественно не надо писать никакой программы, надо просто написать пример. \r\n- Поскольку система не показывает мне символ \\ (это ее известный но неисправленный баг), пишите, пожалуйста вместо \\ или \\\\ или lambda или что-то в таком роде.',1),(141,1,39,'Дописать задачу 35-5 так, чтобы она корректно работало с замыканиями. Т.е.:\r\n- в теле фунцкии могут быть нелокальные переменные\r\n- в качестве значений для них используются те значения, которые были в монмент определения функции (а не в момент ее использования)\r\n\r\nПример вызова:\r\n\r\neval (Let \"Y\" (Num 5) (LetFunc \"F\" \"X\" (Mult (Var \"X\") (Var \"Y\")) (Let \"Y\" (Num 10) (Call \"F\" (Num 5))))) [] []\r\n\r\nДолжно получиться 25, потому что мы тут записали на нашем языке выражение:\r\nlet y = 5 in let f x = x*x in let y = 10 in f 5',1),(142,2,39,'Определить для функций вида\r\n  список -> (значение, список)\r\nоператоры >>= и return.\r\nТ.е. определить функции такого типа, как instance для класса Monad.\r\n\r\nЗамечания:\r\n- тут, видимо, полезно использовать конструкцию newtype\r\nhttp://www.haskell.org/haskellwiki/Newtype\r\n- честно говоря, когда я сейчас попробовал это сделать, то у меня не очень получилось:( Появлялись какте-то странные ошибки. Но вроде бы это возмжно. Я еще попробую, и желающе тоже могут попробовать:)',1),(143,3,36,'Задача 36.1 про dec для чисел Черча, но с более слабыми ограничениями - можно пользоваться парами. \r\nЗа нее будет 1 балл.',1);

/*Table structure for table `test` */

DROP TABLE IF EXISTS `test`;

CREATE TABLE `test` (
  `TestID` int(11) NOT NULL AUTO_INCREMENT,
  `Expression` varchar(100) DEFAULT NULL,
  `Result` varchar(255) DEFAULT NULL,
  `TaskID` int(11) DEFAULT NULL,
  `Smart` int(11) NOT NULL DEFAULT '0',
  `TestForTaskID` int(11) NOT NULL,
  `SmartHelp` varchar(300) DEFAULT NULL,
  PRIMARY KEY (`TestID`),
  UNIQUE KEY `TestForTaskID` (`TestForTaskID`,`TaskID`)
) ENGINE=MyISAM AUTO_INCREMENT=291 DEFAULT CHARSET=utf8;

/*Data for the table `test` */

insert  into `test`(`TestID`,`Expression`,`Result`,`TaskID`,`Smart`,`TestForTaskID`,`SmartHelp`) values (31,'f 1','2',18,0,1,''),(35,'g 6','False',22,0,1,''),(36,'g 7','True',22,0,2,''),(37,'let phi = f 100 in (phi > 1.618) && (phi < 1.619)','True',18,1,2,'При больших f получается замечательное число (первое описание - Евклид, примерно 300 г. до н.э.)'),(38,'let res = b 3 in res > 0.6999 && res < 0.7001','True',24,0,1,''),(39,'let res = b 100 in res > 0.69777 && res < 0.69778','True',24,1,2,'При больших n должно получаться примерно 0.697'),(40,'sumsin 1','1',19,0,1,''),(41,'let { x = sumsin 3; y = sin 6 / (sin 1 + sin 2 + sin 3) } in abs(x - y) < 0.001','True',19,1,2,'Для 3 что-то не так '),(42,'sumfact 1','1',20,0,1,''),(43,'sumfact 2','3',20,0,2,''),(44,'sumfact 3','9',20,1,3,'В условии же приведен пример вызова :( '),(45,'sumfact 4','33',20,0,4,''),(46,'nseq 1','1',21,0,1,''),(47,'nseq 2','1',21,0,2,''),(48,'nseq 3','2',21,0,3,''),(49,'nseq 9','8',21,0,4,''),(50,'g 40','True',22,0,3,''),(51,'g 1000','True',22,0,4,''),(52,'g 3','False',22,1,5,'1 - это не простое число'),(53,'g 11','False',22,0,6,''),(54,'c 10','6',23,0,1,''),(55,'c 3','2',23,0,2,''),(56,'minlist [3,2,7]','2',25,0,1,''),(57,'minsum [1,8,3,2,7]','5',27,0,1,''),(58,'check (\\ x->x>5) [3,2,7,4]','True',28,0,1,''),(59,'check (\\x->x>5) [3,2,1,4]','False',28,0,2,''),(60,'check (\\x->x>5) []','False',28,1,3,'Как вы думаете, что правильно будет вернуть, если список пустой?'),(61,'checkDifferent [3,2,7]','True',29,0,1,''),(62,'checkDifferent [3,2,7,5,2,8]','False',29,0,2,''),(63,'c 9','5',23,0,3,''),(64,'c 20','22',23,0,4,''),(65,'rev [1,2,3] == [3,2,1]','True',26,0,1,''),(66,'rev [1]','[1]',26,0,2,''),(67,'rev []','[]',26,0,3,''),(68,'parts [1, 2, 8, 2, 5, 6]','True',30,0,1,''),(69,'parts [1, 2, 3, 4, 5]','True',30,0,2,''),(70,'parts [1, 2, 1, 2, 3, 4]','True',30,0,3,''),(71,'parts [4, 6, 3, 5, 7]','False',30,0,4,''),(72,'parts [1, 2, 3, 4, 1, 2, 3, 4, 5, 6]','True',30,1,5,'Длина, о которой идет речь в условии, это вовсе не обязательно длина самого короткого куска, она может быть и короче. '),(73,'parts2 [1, 3, 1, 8, 4, 9]','True',31,0,1,''),(74,'parts2 [1, 2, 3, 5, 1, 7]','False',31,0,2,''),(75,'parts2 [1, 1]','True',31,0,3,''),(76,'parts [1, 2, 3, 4, 5, 6, 1, 2, 3, 4]','True',30,0,6,''),(77,'isosc (0, 2) (2, 0) (2,2)','True',35,0,1,''),(78,'isosc (0, 2) (2,2) (2, 0)','True',35,0,2,''),(79,'isosc (2,2) (0, 2) (2, 0)','True',35,0,3,''),(80,'isosc (0, 0) (10, 10) (10, -10)','True',35,0,4,''),(81,'isosc (-3, 2) (2, 0) (2,2)','False',35,0,5,''),(82,'cubeTable 4','[(1,1),(2,8),(3,27),(4,64)]',36,0,1,''),(83,'minsum [1,8,3,2,7] ','5',37,0,1,''),(84,'minsum [1,1]','2',37,0,2,''),(85,'height (Node 1 Empty Empty)','0',38,0,1,''),(86,'height (Node 1 (Node 1 Empty Empty) Empty)','1',38,0,2,''),(87,'height (Node 1 (Node 2 Empty (Node 3 Empty Empty)) Empty)','2',38,0,3,''),(88,'minHeight (Node 1 Empty Empty)','0',39,0,1,''),(89,'minHeight (Node 1  (Node 2  (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))','1',39,0,2,''),(90,'identity 4','[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]',40,0,1,''),(91,'identity 2','[[1,0],[0,1]]',40,0,2,''),(92,'countOdd [2, 3, 4, 8, 5, 33, 9]','4',41,0,1,''),(93,'countOdd1 [2, 3, 4, 8, 5, 33, 9]','4',41,0,2,''),(94,'countOdd []','0',41,1,3,'А если список пустой?'),(95,'countOdd1 []','0',41,1,4,'А если список пустой?'),(96,'myfoldl (+) 0 [1,2,3]','6',42,0,1,''),(97,'myfoldl (+) 10 []','10',42,0,2,''),(98,'myfoldl (^) 2 [3]','8',42,0,3,''),(99,'let f x y = 2*x+y in myfoldl f 2 [3,5]','19',42,0,4,''),(100,'minHeight (Node 1 (Node 2 Empty (Node 3 Empty Empty)) (Node 4 (Node 5 Empty Empty) Empty))','2',39,0,3,''),(101,'parts2 [1,6,9,7]','True',31,0,4,''),(102,'parts2 [2,1]','True',31,0,5,''),(103,'parts2 [1,6,9]','False',31,0,6,''),(104,'let (x,y) = euclid 3 5 in 3*x+5*y','1',43,0,1,''),(105,'let (x,y) = euclid 1 1 in 1*x+1*y','1',43,0,2,''),(106,'let (x,y) = euclid 33 25 in 33*x+25*y','1',43,0,3,''),(107,'let [x,y,z] = dioph [1,1,1,6] [1,2,3,14] in (x+y+z, x+2*y+3*z)','(6,14)',44,0,1,''),(109,'let [x,y,z] = dioph [1,1,1,1] [2,2,2,2] in x+y+z','1',44,0,2,''),(110,'let [x,y,z] = dioph [1,0,1,2] [0,1,0,0] in (x+z, y)','(2,0)',44,0,3,''),(111,'let [x,y,z] = dioph [25,33,0,1] [1,0,1,0] in (25*x+33*y, x+z)','(1,0)',44,0,4,''),(112,'let [x,y,z] = dioph [0,0,0,0] [0,1,0,3] in y','3',44,0,5,''),(113,'let [x,y,z] = dioph [7,11,0,1] [0,25,19,1] in (7*x+11*y, 25*y+19*z)','(1,1)',44,0,6,''),(114,'parts2 [4,3,2,1]','False',31,0,7,''),(115,'let [x,y,z] = dioph [0,1,0,0] [1,1,0,10] in (y,x+y)','(0,10)',44,0,7,''),(116,'minHeight (Node 1 Empty (Node 2 Empty Empty)) ','1',39,0,4,''),(117,'minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) Empty)','2',39,0,5,''),(118,'parts2 [5,1, 2,3, 7,8, 9,10, 11,12, 13,6, 20,14,15,16,17,18]','True',31,0,8,''),(119,'parts2 [5,1,2,3, 7,8,9,10,11,12,13,6,20,14,15,16]','False',31,0,9,''),(120,'myreverse [1,2,3,4]','[4,3,2,1]',48,0,1,''),(121,'length (powerset [1,2,3])','8',47,0,1,''),(122,'powerset []','[[]]',47,0,2,''),(123,'myreverse [1,2,3]','[3,2,1]',48,0,2,''),(124,'elem [1,3] (powerset [1,2,3])','True',47,0,3,''),(125,'elem [3,1] (powerset [1,2,3])','False',47,1,4,'Элементы в подсписках из powerset должны идти в том же порядке, что и в исходном списке.'),(126,'minsum [2,9,1,3]','4',37,0,3,''),(127,'isosc (0,5) (3,4) (5,0)','False',35,0,6,''),(128,'(repeatFunc (*2) 3) 1','8',51,0,1,''),(129,'repeatFunc id 10 1','1',51,0,2,''),(130,'repeatFunc (*2) 3 10','80',52,0,1,''),(131,'coins 2','[[1,0,0]]',53,0,1,''),(132,'length (coins 10)','4',53,0,2,''),(133,'elem [1,1,1] (coins 10)','True',53,0,3,''),(134,'allLists 1 1','[[1]]',56,0,1,''),(135,'length (allLists 3 3)','27',56,0,2,''),(136,'elem [3,2,3] (allLists 3 3)','True',56,0,3,''),(137,'canMakeScheme [4,4,5] 7','True',57,0,1,''),(138,'canMakeScheme [4,4,5] 1','False',57,0,2,''),(139,'canMakeScheme [13, 7, 2, 3] 6','True',57,0,3,''),(140,'sumDiv 10','8',61,0,1,''),(141,'perfects 100','[6,28]',61,0,2,''),(142,'amicables 300','[(220,284)]',62,0,1,''),(143,'take 4 luckyNumbers','[7,77,777,7777]',63,0,1,''),(144,'canMakeScheme [13, 7, 2, 3] 7','True',57,0,4,''),(145,'canMakeScheme [50,13,2,3,7] 56','True',57,0,5,''),(146,'canMakeScheme [13,10, 2, 1000, 1000] 506','True',57,0,6,''),(147,'length(filter(==(3,2))(take 100 cantor))','1',65,0,1,''),(148,'length(filter(==[2,1,2])(take 100 (generalizedCantor 3)))','1',66,0,1,''),(149,'length[x|(x,y)<-take 100 cantor, x<=0||y<=0]','0',65,0,2,''),(150,'(bigSin 0.99) < 0.991','True',69,0,1,''),(151,'myFilter (>0) [1,-2,3,-5]','[1,3]',70,0,1,''),(152,'z>1.64 && z<1.65','True',71,0,1,''),(153,'weekendExpences [3,1,4,12,3,5,17,6,7,7,8,18,5,1,3]','28',72,0,1,''),(154,'take 10 fibs','[1,1,2,3,5,8,13,21,34,55]',73,0,1,''),(155,'sumPos (Node 3 (Node (-1) Empty Empty) (Node 4 Empty Empty))','7',74,0,1,''),(156,'contains (Circle 10 0 0) 6 5','True',76,0,1,''),(157,'contains (Rect 3 7 20 20) 0 0','False',76,0,2,''),(158,'let x = approxSum [sin i/i | i<-[1..]] in x < 1.1','True',71,1,2,'Последовательность может содержать и отрицательные числа'),(159,'length(filter(==[6,3])(take 100 (generalizedCantor 2)))','1',66,0,2,''),(160,'length (allLists 2 5)','32',56,0,4,''),(161,'canMakeScheme [13,2,30,3,7] 6','True',58,0,1,''),(162,'canMakeScheme [13,2,30,3,7] 6','True',57,0,7,''),(163,'take 20 sqrt2','[1,4,1,4,2,1,3,5,6,2,3,7,3,0,9,5,0,4,8,8]',77,0,1,''),(164,'take 6 pascal','[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]',78,0,1,''),(165,'canMakeScheme [13,2,10] 30','False',57,0,8,''),(166,'sqrt2 !! 98','7',77,0,2,''),(167,'sqrt2 !! 99','2',77,0,3,''),(168,'sumPos (Node (-5) (Node 2 Empty Empty) Empty)','2',74,0,2,''),(169,'take 15 lst137','[1,3,7,11,13,17,31,33,37,71,73,77,111,113,117]',81,0,1,''),(170,'countDifferentVars [([\'x\'],[\'y\'])] [[\'x\']]','1',82,0,1,''),(171,'countDifferentVars [(1,3),(2,3)] [1,4,2,3,1]','2',82,0,2,''),(173,'countDifferentVars [(1,2),(2,3), (4,5)] [1,7,2,3,1,4,5]','3',82,0,3,''),(174,'countDifferentVars [(1,3),(2,3), (3,4)] [1,2,3,1,4,5,6]','3',82,0,4,''),(175,'countDifferentVars [(1,2),(2,1)] [1,2,3]','2',82,0,5,''),(176,'countDifferentVars [] [1,2,3]','3',82,1,6,'Списки могут быть и пустыми..'),(177,'countDifferentVars [(1,2),(2,3), (4,5)] []','0',82,1,7,'Списки могут быть и пустыми..'),(178,'length(filter(==[4,1,1])(take 1000 (generalizedCantor 3)))','1',66,0,3,''),(179,'countDifferentVars [(1,2),(2,1),(2,1)] [1,2,3]','2',82,0,8,''),(180,'countDifferentVars [(1,3),(3,2),(2,1),(8,9)] [1,2,3,4,8,9]','3',82,0,9,''),(181,'countDifferentVars  [(1,2),(3,4),(1,3)] [2,4]','1',82,0,10,''),(182,'Rat 1 2 + Rat 1 7','9/14',85,0,1,''),(183,'Rat 1 3 < Rat 4 5','True',85,0,2,''),(184,'Rat 1 (-3) < Rat 4 5','True',85,1,3,'Числа ведь могут быть и отрицательными...'),(185,'allNondivisible [2, 7, 6, 5]','False',86,0,1,''),(186,'allNondivisible [4, 7, 6, 5]','True',86,0,2,''),(187,'eval (Add (Num 3) (Mult X X)) 10','103',87,0,1,''),(188,'diff (Mult X X)','Add (Mult (Num 1) X) (Mult X (Num 1))',88,0,1,''),(189,'flatten (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))','[1,2,3]',89,0,1,''),(190,'merge [1,4,8] [2,4,5,10,20]','[1,2,4,5,8,10,20]',91,0,1,''),(191,'allNondivisible [4,2]','False',86,0,3,'Делимость - это '),(192,'take 10 ham','[1,3,9,10,27,30,81,90,100,243]',93,0,1,''),(193,'ham !! 5000','218700000000000000000000000000000000000000000000000000000000000000000',93,0,2,''),(194,'countDifferentVars [(1,2),(1,5),(3,4),(4,5)] [1..4]','1',82,0,11,''),(195,'checkBrackets [\'(\',\'[\',\']\',\')\']','True',97,0,1,''),(196,'checkBrackets [\'(\',\'[\',\')\',\']\']','False',97,0,2,''),(197,'checkBrackets [\'(\',\'[\',\']\']','False',97,0,3,''),(198,'checkBrackets [\'(\',\'[\',\']\',\')\',\')\']','False',97,0,4,''),(199,'fromStr(toStr (Node \'a\' (Node \'b\' Empty Empty) Empty))','Node \'a\' (Node \'b\' Empty Empty) Empty',98,0,1,''),(200,'checkBrackets [\'(\',\')\',\'[\',\']\']','True',97,0,5,''),(201,'checkBrackets [\'(\',\'(\']','False',97,0,6,''),(202,'countDifferentVars [(1,2),(2,3),(4,5),(1,4)] [1,2,3,4]','1',82,0,12,''),(203,'fromStr(toStr(Node \'a\' (Node \'b\'  Empty Empty) (Node \'b\'  Empty Empty) ))','Node \'a\' (Node \'b\' Empty Empty) (Node \'b\' Empty Empty)',98,0,2,''),(204,'merge [1,2] [3,4]','[1,2,3,4]',91,0,2,''),(205,'length (allDiffLists 3 3)','6',100,0,1,''),(206,'simplify (Mult X (Mult X (Num 0)))','Num 0',101,0,1,''),(207,'findMajor [2,3,15,2,2,2]','Just 15',102,0,1,''),(208,'findMajor [2,3,5,2,4]','Nothing',102,0,2,''),(209,'findInLists [[1,2], [2,8,7]] (>5) 0','8',103,0,1,''),(210,'findInLists [[1,8,2], [2,7]] (>10) 0','0',103,0,2,''),(211,'doubleEven [1,2,6,3]','[1,2,2,6,6,3]',104,0,1,''),(212,'cartesian [1,2] [3,4]','[(1,3),(1,4),(2,3),(2,4)]',105,0,1,''),(213,'simplify (Mult X X)','Mult X X',101,0,2,''),(214,'checkBrackets [\')\',\'(\']','False',97,0,7,''),(215,'checkBrackets [\'[\',\'(\',\')\',\'(\',\']\',\')\']','False',97,0,8,''),(216,'findMajor [1,2,3,2,2,2,1]','Just 2',106,0,1,''),(217,'findMajor [1,2,3,2,1]','Nothing',106,0,2,''),(218,'findMajor [1,2]','Nothing',106,0,3,''),(219,'Or X (Not X) == T','True',107,0,1,''),(220,'Or X (And X (Not X)) == T','False',107,0,2,''),(221,'length(queens 3 2)','2',108,0,1,''),(222,'length (queens 4 4)','2',108,0,2,''),(223,'length (queens 8 8)','92',108,0,3,''),(224,'eval (Add (Var [\'x\']) (Mult (Var [\'y\']) (Num 3))) [([\'x\'], 5), ([\'y\'], 8)]','29',111,0,1,''),(225,'eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'y\'], 2)]','20',112,0,1,''),(226,'sum_cps [1,2,3] (^2)','36',113,0,1,''),(227,'triangle1 3','[1,1,4,1,4,9]',114,0,1,''),(228,'triangle2 3','[1,1,4,1,4,9]',114,0,2,''),(229,'triangle2 1','[1]',114,0,3,''),(230,'f [7, 6, 4, 3, 20, 15, 9] ','[30]',115,0,1,''),(234,'let f = find (>3) >>> find (>3) in f [1, 3, 5, 2, 20, 25, 2]','(20,[25,2])',118,0,1,''),(233,'let c3 f x = f (f x) in toInt (inc c3)','3',117,0,2,''),(235,'let c3 f x = f (f (f x)) in toInt c3','3',116,0,1,''),(236,'let c3 f x = f (f (f x)) in toInt (inc c3)','4',117,0,3,''),(237,'let three f x = f (f (f x)) in toInt (dec three)','2',119,0,1,''),(238,'eval (Let [\'x\'] 10 (Mult (Var [\'x\']) (Var [\'y\']))) [([\'x\'], 0),([\'y\'], 2)]','20',112,0,2,''),(239,'checkBrackets [\'[\',\'[\',\']\',\']\']','True',97,0,9,''),(240,'findMajor [3,3,1,2,1,2,1,3,3]','Nothing',106,0,4,''),(241,'f [7, 6, 4, 3, 20, 15, 9] ','Just 30',123,0,1,''),(242,'f [7, 6, 4, 3, 9]','Nothing',123,0,2,''),(243,'eval (LetFunc [\'F\'] [\'X\'] (Var [\'X\']) (Call [\'F\'] (Num 5))) [] []','5',122,0,1,''),(244,'Not X == Not X','True',107,0,3,''),(245,'Not X == X','False',107,0,4,''),(246,'And (Or X X) (Not X) == Not X','False',107,0,5,''),(247,'F == X','False',107,0,6,''),(248,'eval (LetFunc [\'F\'] [\'X\'] (Mult (Var [\'X\']) (Var [\'X\'])) (Call [\'F\'] (Add (Num 1) (Num 1)))) [] []','4',122,0,2,''),(249,'nseq 10','10',21,0,5,''),(250,'nseq 20','64',21,0,6,''),(251,'c 11','8',23,0,5,''),(252,'minsum [5,4,3]','7',27,0,2,''),(253,'minsum [5,4,3,2,7]','5',27,0,3,''),(254,'minsum [5,2,3,6,7]','5',27,0,4,''),(255,'minsum [5,6,4,3,1,8]','4',27,0,5,''),(256,'g 2','False',22,0,7,''),(257,'height (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty))','1',38,0,4,''),(258,'height(Node 1  (Node 2   (Node 4  Empty Empty) Empty) (Node 3  Empty  (Node 5  Empty Empty)))','2',38,0,5,''),(259,'parts2 [1,2,3,1,10,11,12,10,11,20,25,26,20,21,22,23,24,25,31,32,33,31]','True',31,0,10,''),(260,'parts ([1..9] ++ [1..18] ++ [1..6])','True',30,0,7,''),(261,'let f res x = if x then res+1 else res in myfoldl f 0 [True,False,True]','2',42,0,5,''),(262,'parts ([1..10]++[1..6]++[1..15])','False',30,0,8,''),(263,'myreverse [True,False]','[False,True]',48,0,3,''),(264,'mymap (*3) [1,2,3]','[3,6,9]',129,0,1,''),(265,'mymap (*3) []','[]',129,0,2,''),(266,'trace [[1,2,3],[4,5,6],[7,8,9]]','15',130,0,1,''),(267,'trace [[1,2],[4,5]]','6',130,0,2,''),(268,'trace [[33]]','33',130,0,3,''),(269,'canMakeScheme [4,4,4,4,4] 4','True',57,0,9,''),(270,'canMakeScheme [4,4,4,4,4] 6','True',57,0,10,''),(271,'canMakeScheme [4,4,4,4,4] 5','True',57,0,11,''),(272,'canMakeScheme [4,4,4,4,4] 12','True',57,0,12,''),(273,'length $ filter (canMakeScheme [13,  3, 2,7]) [1..25]','17',57,0,13,''),(274,'length(filter (==[2,1,4]) (take 1000 (generalizedCantor 3)))','1',66,0,4,''),(275,'canMakeScheme [130,777,70,20,223,30,1000] 560','True',131,0,1,''),(276,'canMakeScheme [130,1000,70,20,30,1000] 1560','False',131,0,2,''),(277,'canMakeScheme [130,777,70,20,223,30,1000] 1560','False',131,0,3,''),(278,'canMakeScheme [8,100,8,33,8,100,8] 52','True',131,0,4,''),(279,'canMakeScheme [1,1,1,1,1,1,1] 10','False',131,0,5,''),(280,'canMakeScheme [130,777,70,20,446,30,1000,446] 560','True',131,0,6,''),(281,'take 5 facts','[1,2,6,24,120]',132,0,1,''),(282,'length (allDiffLists 3 3)','6',134,0,1,''),(283,'let f x = [x*x, 100*x] in superMap f [1,2,3]','[1,100,4,200,9,300]',135,0,1,''),(284,'let f x = [] in superMap f [1,2,3] ','[]',135,0,2,''),(285,'contains (Circle 5 5 5) 1 1','False',76,0,3,''),(286,'Rat (-1) (-2) < Rat 1 3','False',85,0,4,''),(287,'findMajor []','Nothing',102,0,3,''),(288,'simplify (Mult (Mult X X) (Mult X X))','Mult (Mult X X) (Mult X X)',101,0,3,''),(289,'eval (Let [\'x\'] (Num 5) (Let [\'y\'] (Var [\'x\']) (Let [\'x\'] (Num 5) (Var [\'y\'])))) []','5',139,0,1,''),(290,'let ch3 f x = f (f (f x)) in toInt(dec ch3)','2',143,0,1,'');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `UserID` varchar(32) NOT NULL,
  `Password` varchar(32) NOT NULL,
  `Name` varchar(30) NOT NULL,
  `Surname` varchar(30) NOT NULL,
  `RoleID` int(11) NOT NULL DEFAULT '1',
  `GroupNumber` int(11) DEFAULT NULL,
  PRIMARY KEY (`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`UserID`,`Password`,`Name`,`Surname`,`RoleID`,`GroupNumber`) values ('alexey.solovyew@gmail.com','Phoenix','Alexey','Solovyew',1,541),('msimuni','12345','Michael','Simuni',2,NULL),('Olga.Bezrukavaya','9036517775vmb','Ольга','Безрукавая',1,543),('54411321','haloween','Александр','Калмук',1,545),('397095','haloween','Артём','',1,0),('12828920','haloween','Tolyan','',1,0),('432992','haloween','Антон','',1,0),('10558725','haloween','Artur','',1,0),('4019402','haloween','Анна','',1,0),('5122688','haloween','Катюшка','Пискунова',1,543),('p.kate','2323641','Екатерина','Пискунова',1,443),('1676722','haloween','Анна','',1,0),('1835693','haloween','Александр','Ильин',1,542),('Anton','Futurama777','Антон','Калинкин',1,542),('62628590','haloween','Никита','Осипов',1,541),('5247795','haloween','Юлия','',1,0),('egeorge','quethapper360','Георгий','Ерохин',1,545),('3301494','haloween','Даша','Диденко',1,543),('641524','haloween','Олег','',1,0),('Yaro_t','03121991Yy','Ярослав','Цимоха',1,542),('ip','12345','pavel','ignat`ev',1,542),('SNNatalieS','genifique','Наталья','Соковикова',1,545),('5543298','haloween','Дмитрий','Зубаревич',1,545),('artem.gomerman','haskell123581321','Артем','Гомерман',1,541),('617015','haloween','Алёна','',1,0),('Julia','nik50392','Юлия','Байцерова',1,545),('1619139','haloween','Nikita','',1,0),('nbumakov','>head246','Nikita','Bumakov',1,545),('Valentina Guleva','happymilk','Valentina','Guleva',1,542),('55363692','access>240','Павел','Федотовский',1,545),('480387','haloween','Олег','',1,541),('toskira','18002','Кирилл','Чередник',1,545),('Jery','441085','Александр','Пономарев',1,543),('4076083','haloween','Антон','',1,0),('3270666','haloween','Борис','Воробьев',1,543),('8519021','haloween','Алина','Птахина',1,545),('1170660','haloween','Влад','Сергеев',1,541),('ArtemK','160392','Артем','Кириенко',1,542),('3226573','haloween','Виктор','Дудин',1,545),('284427','haloween','Николай','Домнин',1,543),('domninnickolay','79602683146','Николай','Домнин',1,543),('215827','haloween','Sergey','',1,0),('anna','rollin445>','Анна','Михайлова',1,543),('1595828','haloween','Севастиан','Шостак',1,541),('4604056','haloween','Ефим','Нефёдов',1,545),('1545234','haloween','Катерина','Ипатова',1,543),('87635585','haloween','Антон','',1,0),('15309342','haloween','Настя','Кузенкова',1,545),('deripaska','576qwerty13','Анна','Дерипаска',1,545),('nomeansno','ybrbajhjd','Юрий','Шахматов',1,541),('matklad','5407_o','Алексей','Кладов',1,545),('6053606','haloween','Екатерина','Соса',1,545),('MaryK','123','Мария','Крень',1,541),('3320654','haloween','Леша','Шершнев',1,542),('2501950','haloween','Елена','Павлячек',1,541),('1048693','rabekta4ti35me16','Кирилл','Таран',1,545),('2156724','haloween','Владимир','Филатов',1,545),('115753099','haloween','Даня','',1,0),('romos2007','romos551992','Роман','Одеров',1,545),('anlun','pr1vet','Антон','Подкопаев',1,545),('419892','haloween','Алекс&','',1,0),('517309','haloween','Михаил','Симуни',1,99),('187177580','haloween','Константин','',1,0),('alebystr','haskell','Алена','Быстрова',1,542),('1526701','haloween','Евгений','Тимофеев',1,542),('1990147','haloween','Андрей','',1,0),('190863485','haloween','Максим','',1,0),('FutureBoy','evcalipt23','Путин','Евгений',1,541),('42284313','haloween','Михаил','Спицин',1,542),('Leonid','1ioZX(!!func','Леонид','Лукьянов',1,541),('ilia','0022025','Илья','Киряновский',1,541),('bazhutin','vbif4634083','Михаил','Бажутин',1,542),('2260659','haloween','Сергей','Серко',1,545),('Artur','1234567890skupon','Артур','Гудиев',1,444),('18625267','haloween','Natasha','',1,0),('48167667','haloween','Кирилл','',1,0),('522234','haloween','Виктор','',1,0),('p.ekaterina','2323641','Екатерина','Пискунова',1,543),('23959','haloween','Мария','',1,0),('14693','haloween','Николай','',1,0);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
